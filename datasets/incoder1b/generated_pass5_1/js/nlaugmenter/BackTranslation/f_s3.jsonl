{"task_id": "JavaScript/0", "prompt": "/* Check that in the given list of numbers, any two numbers are closer together than the given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Check that in the given list of numbers, any two numbers are closer together than the given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const closest = numbers.reduce((prev, curr) => {\n    return Math.abs(curr - prev) < Math.abs(curr - threshold)? curr : prev;\n  }, Number.POSITIVE_INFINITY);\n  return numbers.indexOf(closest)!== -1;\n};\n\n/**\n * Given a string, convert it to a list of numbers, removing any non-numeric characters and converting them to integers.\n * If the string contains only digits, convert it to an array of integers.\n * If the string contains only letters, convert it to an array of strings.\n * If the string contains only letters and digits, convert it to an array of strings.\n * If the string contains only letters and digits and spaces, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and commas and periods and commas and periods, convert it to an array of strings.\n * If the string contains only letters and digits and spaces and periods and comma"}
{"task_id": "JavaScript/1", "prompt": "/* Input to this function is a string containing multiple groups of nested brackets, the goal of which is to separate this group into separate strings and return the list of them. Separate groups are balanced (each open bracket is properly closed), not nested Ignore spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Input to this function is a string containing multiple groups of nested brackets, the goal of which is to separate this group into separate strings and return the list of them. Separate groups are balanced (each open bracket is properly closed), not nested Ignore spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/g);\n  return paren_groups.map((group) => {\n    const [open, close] = group.match(/\\(([^)]+)\\)/);\n    return [open, close];\n  });\n};\n\n/**\n * Given a string, this function will return the string with all the parentheses replaced by their corresponding opening parenthesis.\n  >>> parenReplacement('( () ( ) ) ( ) ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) "}
{"task_id": "JavaScript/2", "prompt": "/* In the case of a positive floating point number, it can be divided into an integer part (largest integer smaller than the specified number) and decimal numbers (remaining part always smaller than 1).\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* In the case of a positive floating point number, it can be divided into an integer part (largest integer smaller than the specified number) and decimal numbers (remaining part always smaller than 1).\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const isNegative = number < 0;\n  const isPositive = number > 0;\n  const isInteger = isPositive || isNegative;\n  const isDecimal = isInteger && isFinite(number);\n  const isFloat = isDecimal && isFinite(number.toFixed(precision));\n\n  if (isFloat) {\n    const decimalPart = number.toFixed(precision);\n    const integerPart = decimalPart.slice(0, precision);\n    return integerPart + decimalPart.slice(precision);\n  }\n\n  return number;\n};\n\nconst getPrecision = (number) => {\n  const isNegative = number < 0;\n  const isPositive = number > 0;\n  const isInteger = isPositive || isNegative;\n  const isDecimal = isInteger && isFinite(number);\n\n  if (isDecimal) {\n    const decimalPart = number.toFixed(precision);\n    const integerPart = decimalPart.slice(0, precision);\n    return integerPart.length + decimalPart.length;\n  }\n\n  return precision;\n};\n\nconst getDecimals = (number) => {\n  const isNegative = number < 0;\n  const isPositive = number > 0;\n  const isInteger = isPositive || isNegative;\n  const isDecimal = isInteger && isFinite(number);\n\n  if (isDecimal) {\n    const decimalPart = number.toFixed(precision);\n    const integerPart = decimalPart.slice(0, precision);\n    return integerPart.length + decimalPart.length;\n  }\n\n  return precision;\n};\n\nconst getRoundingMethod = (number) => {\n  const isNegative = number < 0;\n  const isPositive = number > 0;\n  const isInteger = isPositive || isNegative;\n  const isDecimal = isInteger && isFinite(number);\n\n  if (isDecimal) {\n    const decimalPart = number.toFixed(precision);\n    const integerPart = decimalPart.slice(0, precision);\n    return integerPart.length + decimalPart.length;\n  }\n\n  return roundingMethod;\n};\n\nconst getRoundingPrecision = (number) => {\n  const isNegative = number < 0;\n  const isPositive = number > 0;\n  const isInteger = isPositive || isNegative;\n  const isDecimal = isInteger && isFinite(number);\n\n  if (isDecimal) {\n    const decimalPart = number.toFixed(precision);\n    const integerPart = decimalPart.slice(0, precision);\n    return integerPart.length + decimalPart.length;\n  }\n\n  return roundingPrecision;\n};\n\nconst getRoundingMethodName = (number) => {\n  const isNegative = number < 0;\n  const isPositive = number > 0;\n  const isInteger = isPositive || isNegative;\n  const isDecimal = isInteger && isFinite(number);\n\n  if (isDecimal) {\n    const decimalPart = number.toFixed(precision);\n    const integerPart = decimalPart.slice(0, precision);\n    return integerPart.length + decimalPart.length;\n  }\n\n  return roundingMethodName;\n};\n\nconst getRoundingPrecisionName = (number) => {\n  const isNegative = number < 0;\n  const isPositive = number > 0;\n  const isInteger = isPositive || isNegative;\n  const isDecimal = isInteger && isFinite(number);\n\n  if (isDecimal) {\n    const decimalPart = number.toFixed(precision);\n    const integerPart = decimalPart.slice(0, precision);\n    return integerPart.length + decimalPart.length;\n  }\n\n  return roundingPrecisionName;\n};\n\nconst getRoundingMethodNameFromString = (roundingMethod) => {\n  switch (roundingMethod) {\n    case 'ceiling':\n      return 'ceil';\n    case 'floor':\n      return 'floor';\n    case 'round':\n      return 'round';\n    case 'nearest':\n      return 'round';\n    default:\n      return roundingMethod;\n  }\n};\n\nconst getRoundingPrecisionFromString = (roundingPrecision) => {\n  switch (roundingPrecision) {\n    case 'ceiling':\n      return 'ceil';\n    case 'floor':\n      return 'floor';\n    case 'round':\n      return 'round';\n    case 'nearest':\n      return 'round';\n    default:\n      return roundingPrecision;\n  }\n};\n\nconst getRoundingPrecisionFromNumber = (roundingPrecision) => {\n  const isNegative = number < 0;\n  const isPositive = number > 0;\n  const isInteger = isPositive || isNegative;\n  const isDecimal = isInteger && isFinite(number);\n\n  if (isDecimal) {\n    const decimalPart = number.toFixed(precision);\n    const integerPart = decimalPart.slice(0, precision);\n    return integerPart.length + decimalPart.length;\n  }\n\n  return roundingPrecision;\n};\n\nconst getRoundingPrecisionFromNumberName = (roundingPrecision) => {\n  const isNegative = number < 0;\n  const isPositive = number > 0;\n  const isInteger = isPositive || isNegative;\n  const isDecimal = isInteger && isFinite(number);\n\n  if (isDecimal) {\n    const decimalPart = number.toFixed(precision);\n    const integerPart = decimalPart.slice(0, precision);\n    return integerPart.length + decimalPart.length;\n  }\n\n  return roundingPrecision;\n};\n\nconst getRoundingPrecisionFromNumberNameFromString = (roundingPrecision) => {\n  switch (roundingPrecision) {\n    case 'ceiling':\n      return 'ceil';\n    case 'floor':\n      return 'floor';\n    case 'round':\n      return 'round';\n    case 'nearest':\n      return 'round';\n    default:\n      return roundingPrecision;\n  }\n};\n\nconst getRoundingPrecisionFromNumberNameFromStringFromNumber = (roundingPrecision) => {\n  const isNegative = number < 0;\n  const isPositive = number > 0;\n  const isInteger = isPositive || isNegative;\n  const isDecimal = isInteger && isFinite(number);\n\n  if (isDecimal) {\n    const decimalPart = number.toFixed(precision);\n    const integerPart = decimalPart.slice(0, precision);\n    return integerPart.length + decimalPart.length;\n  }\n\n  return roundingPrecision;\n};\n\nconst getRoundingPrecisionFromNumberNameFromStringFromNumberName = (roundingPrecision) => {\n  const isNegative = number < 0;\n  const isPositive = number > 0;\n  const isInteger = isPositive || isNegative;\n  const isDecimal = isInteger && isFinite(number);\n\n  if (isDecimal) {\n    const decimalPart = number.toFixed(precision);\n    const integerPart = decimalPart.slice(0, precision);\n    return integerPart.length + decimalPart.length;\n  }\n\n  return roundingPrecision;\n};\n\nconst getRoundingPrecisionFromNumberNameFromStringFromNumberNameFromString = (roundingPrecision) => {\n  const isNegative = number < 0;\n  const isPositive = number > 0;\n  const isInteger = isPositive || isNegative;\n  const isDecimal = isInteger && isFinite(number);\n\n  if (isDecimal) {\n    const decimalPart = number.toFixed(precision);\n    const integerPart = decimalPart.slice(0, precision);\n    return integerPart.length + decimalPart.length;\n  }\n\n  return roundingPrecision;\n};\n\nconst getRoundingPrecisionFromNumberNameFromStringFromNumberNameFromStringFromNumberName = (roundingPrecision) => {\n  const isNegative = number < 0;\n  const isPositive = number > 0;\n  const isInteger = isPositive || isNegative;\n  const isDecimal = isInteger && isFinite(number);\n\n  if (isDecimal) {\n    const decimalPart = number.toFixed(precision);\n    const "}
{"task_id": "JavaScript/3", "prompt": "/* You will be given a list of deposits and withdrawals into a bank account, starting with an account balance of zero. Your task is to determine if the account balance drops below zero at any point, and at that point the function should be correct again, otherwise it should be incorrect.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* You will be given a list of deposits and withdrawals into a bank account, starting with an account balance of zero. Your task is to determine if the account balance drops below zero at any point, and at that point the function should be correct again, otherwise it should be incorrect.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  let total = 0;\n  let correct = false;\n  operations.forEach((operation) => {\n    if (operation === '+') {\n      balance = balance + Number(operations[1]);\n      total = total + Number(operations[2]);\n    } else if (operation === '-') {\n      balance = balance - Number(operations[1]);\n      total = total - Number(operations[2]);\n    } else if (operation === '*') {\n      balance = balance * Number(operations[1]);\n      total = total * Number(operations[2]);\n    } else if (operation === '/') {\n      balance = balance / Number(operations[1]);\n      total = total / Number(operations[2]);\n    }\n  });\n  if (balance === 0) {\n    correct = true;\n  }\n  return correct;\n};\n\nmodule.exports = belowZero;\n\n},{}],4:[function(require,module,exports){\n/*\n  You are given a list of deposits and withdrawals into a bank account, starting with an account balance of zero. Your task is to determine if the account balance drops below zero at any point, and at that point the function should be correct again, otherwise it should be incorrect.\n  >>> belowZero([10, 20, 30, 40])\n  true\n  >>> belowZero([10, 20, 30, -40])\n  false\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  let total = 0;\n  let correct = false;\n  operations.forEach((operation) => {\n    if (operation === '+') {\n      balance = balance + Number(operations[1]);\n      total = total + Number(operations[2]);\n    } else if (operation === '-') {\n      balance = balance - Number(operations[1]);\n      total = total - Number(operations[2]);\n    } else if (operation === '*') {\n      balance = balance * Number(operations[1]);\n      total = total * Number(operations[2]);\n    } else if (operation === '/') {\n      balance = balance / Number(operations[1]);\n      total = total / Number(operations[2]);\n    }\n  });\n  if (balance === 0) {\n    correct = true;\n  }\n  return correct;\n};\n\nmodule.exports = belowZero;\n\n},{}],5:[function(require,module,exports){\n/*\n  You are given a list of deposits and withdrawals into a bank account, starting with an account balance of zero. Your task is to determine if the account balance drops below zero at any point, and at that point the function should be correct again, otherwise it should be incorrect.\n  >>> belowZero([10, 20, 30, 40])\n  true\n  >>> belowZero([10, 20, 30, -40])\n  false\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  let total = 0;\n  let correct = false;\n  operations.forEach((operation) => {\n    if (operation === '+') {\n      balance = balance + Number(operations[1]);\n      total = total + Number(operations[2]);\n    } else if (operation === '-') {\n      balance = balance - Number(operations[1]);\n      total = total - Number(operations[2]);\n    } else if (operation === '*') {\n      balance = balance * Number(operations[1]);\n      total = total * Number(operations[2]);\n    } else if (operation === '/') {\n      balance = balance / Number(operations[1]);\n      total = total / Number(operations[2]);\n    }\n  });\n  if (balance === 0) {\n    correct = true;\n  }\n  return correct;\n};\n\nmodule.exports = belowZero;\n\n},{}],6:[function(require,module,exports){\n/*\n  You are given a list of deposits and withdrawals into a bank account, starting with an account balance of zero. Your task is to determine if the account balance drops below zero at any point, and at that point the function should be correct again, otherwise it should be incorrect.\n  >>> belowZero([10, 20, 30, 40])\n  true\n  >>> belowZero([10, 20, 30, -40])\n  false\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  let total = 0;\n  let correct = false;\n  operations.forEach((operation) => {\n    if (operation === '+') {\n      balance = balance + Number(operations[1]);\n      total = total + Number(operations[2]);\n    } else if (operation === '-') {\n      balance = balance - Number(operations[1]);\n      total = total - Number(operations[2]);\n    } else if (operation === '*') {\n      balance = balance * Number(operations[1]);\n      total = total * Number(operations[2]);\n    } else if (operation === '/') {\n      balance = balance / Number(operations[1]);\n      total = total / Number(operations[2]);\n    }\n  });\n  if (balance === 0) {\n    correct = true;\n  }\n  return correct;\n};\n\nmodule.exports = belowZero;\n\n},{}],7:[function(require,module,exports){\n/*\n  You are given a list of deposits and withdrawals into a bank account, starting with an account balance of zero. Your task is to determine if the account balance drops below zero at any point, and at that point the function should be correct again, otherwise it should be incorrect.\n  >>> belowZero([10, 20, 30, 40])\n  true\n  >>> belowZero([10, 20, 30, -40])\n  false\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  let total = 0;\n  let correct = false;\n  operations.forEach((operation) => {\n    if (operation === '+') {\n      balance = balance + Number(operations[1]);\n      total = total + Number(operations[2]);\n    } else if (operation === '-') {\n      balance = balance - Number(operations[1]);\n      total = total - Number(operations[2]);\n    } else if (operation === '*') {\n      balance = balance * Number(operations[1]);\n      total = total * Number(operations[2]);\n    } else if (operation === '/') {\n      balance = balance / Number(operations[1]);\n      total = total / Number(operations[2]);\n    }\n  });\n  if (balance === 0) {\n    correct = true;\n  }\n  return correct;\n};\n\nmodule.exports = belowZero;\n\n},{}],8:[function(require,module,exports){\n/*\n  You are given a list of deposits and withdrawals into a bank account, starting with an account balance of zero. Your task is to determine if the account balance drops below zero at any point, and at that point the function should be correct again, otherwise it should be incorrect.\n  >>> belowZero([10, 20, 30, 40])\n  true\n  >>> belowZero([10, 20, 30, -40])\n  false\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  let total = 0;\n  let correct = false;\n  operations.forEach((operation) => {\n    if (operation === '+') {\n      balance = balance + Number(operations[1]);\n      total = total + Number(operations[2]);\n    } else if (operation === '-') {\n      balance = balance - Number(operations[1]);\n      total = total - Number(operations[2]);\n    } else if (operation === '*') {\n      balance = balance * Number(operations[1]);\n      total = total * Number(operations[2]);\n    } else if (operation === '/') {\n      balance = balance / Number(operations[1]);\n      total = total / Number(operations[2]);\n    }\n  });\n  if (balance === 0) {\n    correct = true;\n  }\n  return correct;\n};\n\nmodule.exports = belowZero;\n\n},{}],9:[function(require,module,exports){\n/*\n  You are given a list of deposits and withdraw"}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate the mean absolute deviation around the mean value of this dataset. The mean absolute deviation is the mean absolute difference between each element and a midpoint (mean in this case): MAD = average | x - x _ mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* For a given list of input numbers, calculate the mean absolute deviation around the mean value of this dataset. The mean absolute deviation is the mean absolute difference between each element and a midpoint (mean in this case): MAD = average | x - x _ mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, num) => acc + num, 0) / numbers.length;\n  return numbers.map((num) => Math.abs(num - mean));\n};\n\n/**\n * Given a list of numbers, calculate the median absolute deviation around the median value of this dataset. The median absolute deviation is the median absolute difference between each element and a midpoint (median in this case): MME = median | x - x _ median |\n  >>> medianAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  2.0\n  */\nconst medianAbsoluteDeviation = (numbers) => {\n  const median = numbers.reduce((acc, num) => acc + num, 0) / numbers.length;\n  return numbers.map((num) => Math.abs(num - median));\n};\n\n/**\n * Given a list of numbers, calculate the mode absolute deviation around the mode value of this dataset. The mode absolute deviation is the mode absolute difference between each element and a midpoint (mode in this case): MME = mode | x - x _ mode |\n  >>> modeAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst modeAbsoluteDeviation = (numbers) => {\n  const mode = numbers.reduce((acc, num) => acc + num, 0) / numbers.length;\n  return numbers.map((num) => Math.abs(num - mode));\n};\n\n/**\n * Given a list of numbers, calculate the standard deviation of this dataset. The standard deviation is the square root of the mean absolute deviation around the standard deviation of this dataset. The standard deviation is the square root of the median absolute deviation around the standard deviation of this dataset. The standard deviation is the square root of the mode absolute deviation around the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root of the standard deviation of this dataset. The standard deviation is the square root "}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number \"delimeter\" between two consecutive elements of the \"Numbers\" input list.\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Insert a number \"delimeter\" between two consecutive elements of the \"Numbers\" input list.\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < numbers.length) {\n    if (numbers[i]!== delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (j === numbers.length) {\n      result.push(delimeter)\n      j = 0\n    }\n    result.push(numbers[i])\n    i++\n    j++\n  }\n  return result\n}\n\n/**\n * Remove all occurrences of a value from an array.\n * If no value is specified, all occurrences are removed.\n * If no array is specified, all elements are removed.\n * If an argument is passed, it is used as the array and all elements are removed.\n * If an array is passed, it is used as the array and all occurrences are removed.\n * If no value is specified, all occurrences are removed.\n * If no array is specified, all elements are removed.\n * If an argument is passed, it is used as the array and all occurrences are removed.\n * If an array is passed, it is used as the array and all occurrences are removed.\n * If no value is specified, all occurrences are removed.\n * If no array is specified, all elements are removed.\n * If an argument is passed, it is used as the array and all occurrences are removed.\n * If an array is passed, it is used as the array and all occurrences are removed.\n * If no value is specified, all occurrences are removed.\n * If no array is specified, all elements are removed.\n * If an argument is passed, it is used as the array and all occurrences are removed.\n * If an array is passed, it is used as the array and all occurrences are removed.\n * If no value is specified, all occurrences are removed.\n * If no array is specified, all elements are removed.\n * If an argument is passed, it is used as the array and all occurrences are removed.\n * If an array is passed, it is used as the array and all occurrences are removed.\n * If no value is specified, all occurrences are removed.\n * If no array is specified, all elements are removed.\n * If an argument is passed, it is used as the array and all occurrences are removed.\n * If an array is passed, it is used as the array and all occurrences are removed.\n * If no value is specified, all occurrences are removed.\n * If no array is specified, all elements are removed.\n * If an argument is passed, it is used as the array and all occurrences are removed.\n * If an array is passed, it is used as the array and all occurrences are removed.\n * If no value is specified, all occurrences are removed.\n * If no array is specified, all elements are removed.\n * If an argument is passed, it is used as the array and all occurrences are removed.\n * If an array is passed, it is used as the array and all occurrences are removed.\n * If no value is specified, all occurrences are removed.\n * If no array is specified, all elements are removed.\n * If an argument is passed, it is used as the array and all occurrences are removed.\n * If an array is passed, it is used as the array and all occurrences are removed.\n * If no value is specified, all occurrences are removed.\n * If no array is specified, all elements are removed.\n * If an argument is passed, it is used as the array and all occurrences are removed.\n * If an array is passed, it is used as the array and all occurrences are removed.\n * If no value is specified, all occurrences are removed.\n * If no array is specified, all elements are removed.\n * If an argument is passed, it is used as the array and all occurrences are removed.\n * If an array is passed, it is used as the array and all occurrences are removed.\n * If no value is specified, all occurrences are removed.\n * If no array is specified, all elements are removed.\n * If an argument is passed, it is used as the array and all occurrences are removed.\n * If an array is passed, it is used as the array and all occurrences are removed.\n * If no value is specified, all occurrences are removed.\n * If no array is specified, all elements are removed.\n * If an argument is passed, it is used as the array and all occurrences are removed.\n * If an array is passed, it is used as the array and all occurrences are removed.\n * If no value is specified, all occurrences are removed.\n * If no array is specified, all elements are removed.\n * If an argument is passed, it is used as the array and all occurrences are removed.\n * If an array is passed, it is used as the array and all occurrences are removed.\n * If no value is specified, all occurrences are removed.\n * If no array is specified, all elements are removed.\n * If an argument is passed, it is used as the array and all occurrences are removed.\n * If an array is passed, it is used as the array and all occurrences are removed.\n * If no value is specified, all occurrences are removed.\n * If no array is specified, all elements are removed.\n * If an argument is passed, it is used as the array and all occurrences are removed.\n * If an array is passed, it is used as the array and all occurrences are removed.\n * If no value is specified, all occurrences are removed.\n * If no array is specified, all elements are removed.\n * If an argument is passed, it is used as the array and all occurrences are removed.\n * If an array is passed, it is used as the array and all occurrences are removed.\n * If no value is specified, all occurrences are removed.\n * If no array is specified, all elements are removed.\n * If an argument is passed, it is used as the array and all occurrences are removed.\n * If an array is passed, it is used as the array and all occurrences are removed.\n * If no value is specified, all occurrences are removed.\n * If no array is specified, all elements are removed.\n * If an argument is passed, it is used as the array and all occurrences are removed.\n * If an array is passed, it is used as the array and all occurrences are removed.\n * If no value is specified, all occurrences are removed.\n * If no array is specified, all elements are removed.\n * If an argument is passed, it is used as the array and all occurrences are removed.\n * If an array is passed, it is used as the array and all occurrences are removed.\n * If no value is specified, all occurrences are removed.\n * If no array is specified, all elements are removed.\n * If an argument is passed, it is used as the array and all occurrences are removed.\n * If an array is passed, it is used as the array and all occurrences are removed.\n * If no value is specified, all occurrences are removed.\n * If no array is specified, all elements are removed.\n * If an argument is passed, it is used as the array and all occurrences are removed.\n * If an array is passed, it is used as the array and all occurrences are removed.\n * If no value is specified, all occurrences are removed.\n * If no array is specified, all elements are removed.\n * If an argument is passed, it is used as the array and all occurrences are removed.\n * If an array is passed, it is used as the array and all occurrences are removed.\n * If no value is specified, all occurrences are removed.\n * If no array is specified, all elements are removed.\n * If an argument is passed, it is used as the array and all occurrences are removed.\n * If an array is passed, it is used as the array and all occurrences are removed.\n * If no value is specified, all occurrences are removed.\n * If no array is specified, all elements are removed.\n * If an argument is passed, it is used as the array and all occurrences are removed.\n * If an array is passed, it is used as the array and all occurrences are removed.\n * If no value is specified, all occurrences are removed.\n * If no array is specified, all elements are removed.\n * If an argument is passed, it is used as the array and all occurrences are removed.\n * If an array is passed, it is used as the array and all occurrences are removed.\n * If no value is specified, all occurrences are removed.\n * If no array is specified, all elements are removed.\n * If an argument is passed, it is used as the array and all occurrences are removed.\n * If an array is passed, it is used as the array and all occurrences are removed.\n * If no value is specified, all occurrences are removed.\n * If no "}
{"task_id": "JavaScript/6", "prompt": "/* Input to this function is a string representing multiple groups of nested brackets, separated by spaces. For each group, the lowest level of nesting of brackets is output. E.g. () ()) has a maximum of two levels of nesting, while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Input to this function is a string representing multiple groups of nested brackets, separated by spaces. For each group, the lowest level of nesting of brackets is output. E.g. () ()) has a maximum of two levels of nesting, while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_is_empty = true;\n  const paren_stack_is_open = false;\n  const paren_stack_is_closed = false;\n  const paren_stack_is_opening = false;\n  const paren_stack_is_closing = false;\n  const paren_stack_is_opening_bracket = false;\n  const paren_stack_is_closing_bracket = false;\n  const paren_stack_is_opening_paren = false;\n  const paren_stack_is_closing_paren = false;\n  const paren_stack_is_opening_square = false;\n  const paren_stack_is_closing_square = false;\n  const paren_stack_is_opening_curly = false;\n  const paren_stack_is_closing_curly = false;\n  const paren_stack_is_opening_paren_double = false;\n  const paren_stack_is_closing_paren_double = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_bracket = false;\n  const paren_stack_is_opening_paren_double_bracket = false;\n  const paren_stack_is_closing_paren_double_b"}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input list of strings only for strings that contain a specific substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Filter an input list of strings only for strings that contain a specific substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1);\n};\n\n/**\n * Filter an input list of strings only for the first element that contains a specific substring\n * >>> filterBySubstring(['abc', 'bacd', 'cde'], 'a')\n * 'abc'\n */\nconst filterBySubstringFirst = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for the first element that contains a specific substring\n * >>> filterBySubstring(['abc', 'bacd', 'cde'], 'b')\n * []\n */\nconst filterBySubstringFirstEmpty = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for the first element that contains a specific substring\n * >>> filterBySubstring(['abc', 'bacd', 'cde'], 'c')\n * []\n */\nconst filterBySubstringFirstEmptyAndNotEmpty = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1 && string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for the first element that contains a specific substring\n * >>> filterBySubstring(['abc', 'bacd', 'cde'], 'd')\n * []\n */\nconst filterBySubstringFirstEmptyAndNotEmptyAndNotEmpty = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1 && string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for the first element that contains a specific substring\n * >>> filterBySubstring(['abc', 'bacd', 'cde'], 'e')\n * []\n */\nconst filterBySubstringFirstEmptyAndNotEmptyAndNotEmptyAndNotEmpty = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1 && string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for the first element that contains a specific substring\n * >>> filterBySubstring(['abc', 'bacd', 'cde'], 'f')\n * []\n */\nconst filterBySubstringFirstEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmpty = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1 && string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for the first element that contains a specific substring\n * >>> filterBySubstring(['abc', 'bacd', 'cde'], 'g')\n * []\n */\nconst filterBySubstringFirstEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmpty = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1 && string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for the first element that contains a specific substring\n * >>> filterBySubstring(['abc', 'bacd', 'cde'], 'h')\n * []\n */\nconst filterBySubstringFirstEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmpty = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1 && string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for the first element that contains a specific substring\n * >>> filterBySubstring(['abc', 'bacd', 'cde'], 'i')\n * []\n */\nconst filterBySubstringFirstEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmpty = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1 && string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for the first element that contains a specific substring\n * >>> filterBySubstring(['abc', 'bacd', 'cde'], 'j')\n * []\n */\nconst filterBySubstringFirstEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmpty = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1 && string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for the first element that contains a specific substring\n * >>> filterBySubstring(['abc', 'bacd', 'cde'], 'k')\n * []\n */\nconst filterBySubstringFirstEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmpty = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1 && string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for the first element that contains a specific substring\n * >>> filterBySubstring(['abc', 'bacd', 'cde'], 'l')\n * []\n */\nconst filterBySubstringFirstEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmpty = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1 && string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for the first element that contains a specific substring\n * >>> filterBySubstring(['abc', 'bacd', 'cde'],'m')\n * []\n */\nconst filterBySubstringFirstEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmpty = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1 && string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for the first element that contains a specific substring\n * >>> filterBySubstring(['abc', 'bacd', 'cde'], 'n')\n * []\n */\nconst filterBySubstringFirstEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmpty = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1 && string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for the first element that contains a specific substring\n * >>> filterBySubstring(['abc', 'bacd', 'cde'], 'o')\n * []\n */\nconst filterBySubstringFirstEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmpty = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1 && string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for the first element that contains a specific substring\n * >>> filterBySubstring(['abc', 'bacd', 'cde'], 'p')\n * []\n */\nconst filterBySubstringFirstEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmpty = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1 && string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for the first element that contains a specific substring\n * >>> filterBySubstring(['abc', 'bacd', 'cde'], 'q')\n * []\n */\nconst filterBySubstringFirstEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmpty = (strings, substring) => {\n  return strings.filter(string "}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisting of a sum and a product of all integers in a list. Empty sum should be 0 and empty product should be 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* For a given list of integers, return a tuple consisting of a sum and a product of all integers in a list. Empty sum should be 0 and empty product should be 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  if (numbers.length === 0) {\n    return (0, 1);\n  }\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/* Given a list containing numbers, return the sum of the numbers in the list and the product of the numbers in the list.\n  >>> sumProduct([10, 20, 30, 40, 50])\n  (30, 120)\n  */\nconst sumProductWithProduct = (numbers, int) => {\n  if (numbers.length === 0) {\n    return (0, 1);\n  }\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/* Given a list containing numbers, return the sum of the numbers in the list and the product of the numbers in the list.\n  >>> sumProduct([10, 20, 30, 40, 50], 2)\n  (30, 120)\n  */\nconst sumProductWithProductAndSum = (numbers, int) => {\n  if (numbers.length === 0) {\n    return (0, 1);\n  }\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/* Given a list containing numbers, return the sum of the numbers in the list and the product of the numbers in the list.\n  >>> sumProduct([10, 20, 30, 40, 50], 3)\n  (30, 120)\n  */\nconst sumProductWithProductAndSumAndSum = (numbers, int) => {\n  if (numbers.length === 0) {\n    return (0, 1);\n  }\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/* Given a list containing numbers, return the sum of the numbers in the list and the product of the numbers in the list.\n  >>> sumProduct([10, 20, 30, 40, 50], 4)\n  (30, 120)\n  */\nconst sumProductWithProductAndSumAndSumAndSum = (numbers, int) => {\n  if (numbers.length === 0) {\n    return (0, 1);\n  }\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/* Given a list containing numbers, return the sum of the numbers in the list and the product of the numbers in the list.\n  >>> sumProduct([10, 20, 30, 40, 50], 5)\n  (30, 120)\n  */\nconst sumProductWithProductAndSumAndSumAndSumAndSum = (numbers, int) => {\n  if (numbers.length === 0) {\n    return (0, 1);\n  }\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/* Given a list containing numbers, return the sum of the numbers in the list and the product of the numbers in the list.\n  >>> sumProduct([10, 20, 30, 40, 50], 6)\n  (30, 120)\n  */\nconst sumProductWithProductAndSumAndSumAndSumAndSumAndSum = (numbers, int) => {\n  if (numbers.length === 0) {\n    return (0, 1);\n  }\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/* Given a list containing numbers, return the sum of the numbers in the list and the product of the numbers in the list.\n  >>> sumProduct([10, 20, 30, 40, 50], 7)\n  (30, 120)\n  */\nconst sumProductWithProductAndSumAndSumAndSumAndSumAndSumAndSum = (numbers, int) => {\n  if (numbers.length === 0) {\n    return (0, 1);\n  }\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/* Given a list containing numbers, return the sum of the numbers in the list and the product of the numbers in the list.\n  >>> sumProduct([10, 20, 30, 40, 50], 8)\n  (30, 120)\n  */\nconst sumProductWithProductAndSumAndSumAndSumAndSumAndSumAndSumAndSum = (numbers, int) => {\n  if (numbers.length === 0) {\n    return (0, 1);\n  }\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/* Given a list containing numbers, return the sum of the numbers in the list and the product of the numbers in the list.\n  >>> sumProduct([10, 20, 30, 40, 50], 9)\n  (30, 120)\n  */\nconst sumProductWithProductAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSum = (numbers, int) => {\n  if (numbers.length === 0) {\n    return (0, 1);\n  }\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/* Given a list containing numbers, return the sum of the numbers in the list and the product of the numbers in the list.\n  >>> sumProduct([10, 20, 30, 40, 50], 10)\n  (30, 120)\n  */\nconst sumProductWithProductAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSum"}
{"task_id": "JavaScript/9", "prompt": "/* Generate from a given list of integers a list of rotating maximum elements found up to a certain moment in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Generate from a given list of integers a list of rotating maximum elements found up to a certain moment in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const maxElement = numbers.reduce((acc, current) => {\n    if (acc > current) {\n      return current;\n    }\n    return acc;\n  }, 0);\n  return numbers.reduce((acc, current) => {\n    if (acc > maxElement) {\n      return current;\n    }\n    return acc;\n  }, 0);\n};\n\n/* Generate from a given list of integers a list of rotating minimum elements found up to a certain moment in the sequence.\n  >>> rollingMin([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 3, 2, 1]\n  */\nconst rollingMin = (numbers) => {\n  const minElement = numbers.reduce((acc, current) => {\n    if (acc < current) {\n      return current;\n    }\n    return acc;\n  }, 0);\n  return numbers.reduce((acc, current) => {\n    if (acc < minElement) {\n      return current;\n    }\n    return acc;\n  }, 0);\n};\n\n/* Generate from a given list of integers a list of rotating average elements found up to a certain moment in the sequence.\n  >>> rollingAverage([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2.5, 2.5, 2.5, 2.5]\n  */\nconst rollingAverage = (numbers) => {\n  const average = numbers.reduce((acc, current) => {\n    if (acc > current) {\n      return current;\n    }\n    return acc;\n  }, 0);\n  return numbers.reduce((acc, current) => {\n    if (acc > average) {\n      return current;\n    }\n    return acc;\n  }, 0);\n};\n\n/* Generate from a given list of integers a list of rotating minimum elements found up to a certain moment in the sequence.\n  >>> rollingMinimum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 3, 2, 1]\n  */\nconst rollingMinimum = (numbers) => {\n  const minElement = numbers.reduce((acc, current) => {\n    if (acc < current) {\n      return current;\n    }\n    return acc;\n  }, 0);\n  return numbers.reduce((acc, current) => {\n    if (acc < minElement) {\n      return current;\n    }\n    return acc;\n  }, 0);\n};\n\n/* Generate from a given list of integers a list of rotating maximum elements found up to a certain moment in the sequence.\n  >>> rollingMaximum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMaximum = (numbers) => {\n  const maxElement = numbers.reduce((acc, current) => {\n    if (acc < current) {\n      return current;\n    }\n    return acc;\n  }, 0);\n  return numbers.reduce((acc, current) => {\n    if (acc > maxElement) {\n      return current;\n    }\n    return acc;\n  }, 0);\n};\n\n/* Generate from a given list of integers a list of rotating minimum elements found up to a certain moment in the sequence.\n  >>> rollingMinimum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 3, 2, 1]\n  */\nconst rollingMinimum = (numbers) => {\n  const minElement = numbers.reduce((acc, current) => {\n    if (acc > current) {\n      return current;\n    }\n    return acc;\n  }, 0);\n  return numbers.reduce((acc, current) => {\n    if (acc > minElement) {\n      return current;\n    }\n    return acc;\n  }, 0);\n};\n\n/* Generate from a given list of integers a list of rotating average elements found up to a certain moment in the sequence.\n  >>> rollingAverage([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2.5, 2.5, 2.5, 2.5]\n  */\nconst rollingAverage = (numbers) => {\n  const average = numbers.reduce((acc, current) => {\n    if (acc > current) {\n      return current;\n    }\n    return acc;\n  }, 0);\n  return numbers.reduce((acc, current) => {\n    if (acc > average) {\n      return current;\n    }\n    return acc;\n  }, 0);\n};\n\n/* Generate from a given list of integers a list of rotating minimum elements found up to a certain moment in the sequence.\n  >>> rollingMinimum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 3, 2, 1]\n  */\nconst rollingMinimum = (numbers) => {\n  const minElement = numbers.reduce((acc, current) => {\n    if (acc < current) {\n      return current;\n    }\n    return acc;\n  }, 0);\n  return numbers.reduce((acc, current) => {\n    if (acc < minElement) {\n      return current;\n    }\n    return acc;\n  }, 0);\n};\n\n/* Generate from a given list of integers a list of rotating maximum elements found up to a certain moment in the sequence.\n  >>> rollingMaximum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMaximum = (numbers) => {\n  const maxElement = numbers.reduce((acc, current) => {\n    if (acc < current) {\n      return current;\n    }\n    return acc;\n  }, 0);\n  return numbers.reduce((acc, current) => {\n    if (acc > maxElement) {\n      return current;\n    }\n    return acc;\n  }, 0);\n};\n\n/* Generate from a given list of integers a list of rotating minimum elements found up to a certain moment in the sequence.\n  >>> rollingMinimum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 3, 2, 1]\n  */\nconst rollingMinimum = (numbers) => {\n  const minElement = numbers.reduce((acc, current) => {\n    if (acc > current) {\n      return current;\n    }\n    return acc;\n  }, 0);\n  return numbers.reduce((acc, current) => {\n    if (acc > minElement) {\n      return current;\n    }\n    return acc;\n  }, 0);\n};\n\n/* Generate from a given list of integers a list of rotating average elements found up to a certain moment in the sequence.\n  >>> rollingAverage([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2.5, 2.5, 2.5, 2.5]\n  */\nconst rollingAverage = (numbers) => {\n  const average = numbers.reduce((acc, current) => {\n    if (acc > current) {\n      return current;\n    }\n    return acc;\n  }, 0);\n  return numbers.reduce((acc, current) => {\n    if (acc > average) {\n      return current;\n    }\n    return acc;\n  }, 0);\n};\n\n/* Generate from a given list of integers a list of rotating minimum elements found up to a certain moment in the sequence.\n  >>> rollingMinimum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 3, 2, 1]\n  */\nconst rollingMinimum = (numbers) => {\n  const minElement = numbers.reduce((acc, current) => {\n    if (acc < current) {\n      return current;\n    }\n    return acc;\n  }, 0);\n  return numbers.reduce((acc, current) => {\n    if (acc < minElement) {\n      return current;\n    }\n    return acc;\n  }, 0);\n};\n\n/* Generate from a given list of integers a list of rotating maximum elements found up to a certain moment in the sequence.\n  >>> rollingMaximum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMaximum = (numbers) => {\n  const maxElement = numbers.reduce((acc, current) => {\n    if (acc > current) {\n      return current;\n    }\n    return acc;\n  }, 0);\n  return numbers.reduce((acc, current) => {\n    if (acc > maxElement) {\n      return current;\n    }\n    return acc;\n  }, 0);\n};\n\n/* Generate from a given list of integers a list of rotating minimum elements found up to a certain moment in the sequence.\n  >>> rollingMinimum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 3, 2, 1]\n  */\nconst rollingMinimum = (numbers) => {\n  const minElement = numbers.reduce((acc, current) => {\n    if (acc < current) {\n      return current;\n    }\n    return acc;\n  }, 0);\n  return numbers.reduce((acc, current) => {\n    if (acc < minElement) {\n      return current;\n    }\n    return acc;\n  }, 0);\n};\n\n/* Generate from a given list of integers a list of rotating average elements "}
{"task_id": "JavaScript/10", "prompt": "/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let longestPalindrome = '';\n  let longestPalindromeLength = 0;\n  let longestPalindromePrefix = '';\n  let longestPalindromeSuffix = '';\n  let longestPalindromePrefixLength = 0;\n  let longestPalindromeSuffixLength = 0;\n  let longestPalindromePrefixReversed = '';\n  let longestPalindromeSuffixReversed = '';\n\n  /* Find the longest postfix of supplied string that is a palindrome */\n  longestPalindrome = string.reverse().split('').reverse().join('');\n\n  /* Append to the end of the string reverse of a string prefix that comes before the palindromic suffix */\n  longestPalindromePrefix = longestPalindrome.substring(0, longestPalindrome.length - 1);\n  longestPalindromeSuffix = longestPalindrome.substring(longestPalindrome.length - 1);\n\n  /* Find the longest palindrome that begins with a supplied string */\n  longestPalindromePrefixLength = longestPalindromePrefix.length;\n  longestPalindromeSuffixLength = longestPalindromeSuffix.length;\n  longestPalindromePrefixReversed = longestPalindromePrefix.split('').reverse().join('');\n  longestPalindromeSuffixReversed = longestPalindromeSuffix.split('').reverse().join('');\n\n  /* Test if given string is a palindrome */\n  if (isPalindrome(longestPalindrome)) {\n    /* Test if given string is a palindrome */\n    if (longestPalindromePrefixLength == longestPalindromeSuffixLength && longestPalindromePrefixReversed == longestPalindromeSuffixReversed) {\n      /* Test if given string is a palindrome */\n      if (longestPalindromePrefixLength > longestPalindromeSuffixLength) {\n        /* Test if given string is a palindrome */\n        longestPalindromeLength = longestPalindromePrefixLength;\n        longestPalindromePrefix = longestPalindromePrefixReversed;\n        longestPalindromeSuffix = longestPalindromeSuffixReversed;\n      }\n    }\n  }\n\n  return longestPalindromeLength;\n}\n\n/* Test if given string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let longestPalindrome = '';\n  let longestPalindromeLength = 0;\n  let longestPalindromePrefix = '';\n  let longestPalindromeSuffix = '';\n  let longestPalindromePrefixLength = 0;\n  let longestPalindromeSuffixLength = 0;\n  let longestPalindromePrefixReversed = '';\n  let longestPalindromeSuffixReversed = '';\n\n  /* Find the longest postfix of supplied string that is a palindrome */\n  longestPalindrome = string.reverse().split('').reverse().join('');\n\n  /* Append to the end of the string reverse of a string prefix that comes before the palindromic suffix */\n  longestPalindromePrefix = longestPalindrome.substring(0, longestPalindrome.length - 1);\n  longestPalindromeSuffix = longestPalindrome.substring(longestPalindrome.length - 1);\n\n  /* Find the longest palindrome that begins with a supplied string */\n  longestPalindromePrefixLength = longestPalindromePrefix.length;\n  longestPalindromeSuffixLength = longestPalindromeSuffix.length;\n  longestPalindromePrefixReversed = longestPalindromePrefix.split('').reverse().join('');\n  longestPalindromeSuffixReversed = longestPalindromeSuffix.split('').reverse().join('');\n\n  /* Test if given string is a palindrome */\n  if (isPalindrome(longestPalindrome)) {\n    /* Test if given string is a palindrome */\n    if (longestPalindromePrefixLength == longestPalindromeSuffixLength && longestPalindromePrefixReversed == longestPalindromeSuffixReversed) {\n      /* Test if given string is a palindrome */\n      if (longestPalindromePrefixLength > longestPalindromeSuffixLength) {\n        /* Test if given string is a palindrome */\n        longestPalindromeLength = longestPalindromePrefixLength;\n        longestPalindromePrefix = longestPalindromePrefixReversed;\n        longestPalindromeSuffix = longestPalindromeSuffixReversed;\n      }\n    }\n  }\n\n  return longestPalindromeLength;\n}\n\n/* Test if given string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let longestPalindrome = '';\n  let longestPalindromeLength = 0;\n  let longestPalindromePrefix = '';\n  let longestPalindromeSuffix = '';\n  let longestPalindromePrefixLength = 0;\n  let longestPalindromeSuffixLength = 0;\n  let longestPalindromePrefixReversed = '';\n  let longestPalindromeSuffixReversed = '';\n\n  /* Find the longest postfix of supplied string that is a palindrome */\n  longestPalindrome = string.reverse().split('').reverse().join('');\n\n  /* Append to the end of the string reverse of a string prefix that comes before the palindromic suffix */\n  longestPalindromePrefix = longestPalindrome.substring(0, longestPalindrome.length - 1);\n  longestPalindromeSuffix = longestPalindrome.substring(longestP"}
{"task_id": "JavaScript/11", "prompt": "/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary XOR on these inputs and return the result as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary XOR on these inputs and return the result as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary AND on these inputs and return the result as a string.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] & b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary OR on these inputs and return the result as a string.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] | b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary XOR OR on these inputs and return the result as a string.\n  >>> stringXorOr('010', '110')\n  '100'\n  */\nconst stringXorOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i] | 0;\n  }\n  return result;\n};\n\n/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary AND OR on these inputs and return the result as a string.\n  >>> stringAndOr('010', '110')\n  '100'\n  */\nconst stringAndOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] & b[i] | 0;\n  }\n  return result;\n};\n\n/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary XOR AND OR on these inputs and return the result as a string.\n  >>> stringXorAndOr('010', '110')\n  '100'\n  */\nconst stringXorAndOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i] & b[i] | 0;\n  }\n  return result;\n};\n\n/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary XOR XOR on these inputs and return the result as a string.\n  >>> stringXorXor('010', '110')\n  '100'\n  */\nconst stringXorXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i] ^ b[i] | 0;\n  }\n  return result;\n};\n\n/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary XOR XOR OR on these inputs and return the result as a string.\n  >>> stringXorXorXor('010', '110')\n  '100'\n  */\nconst stringXorXorXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i] ^ b[i] ^ b[i] | 0;\n  }\n  return result;\n};\n\n/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary XOR XOR AND on these inputs and return the result as a string.\n  >>> stringXorXorXorXor('010', '110')\n  '100'\n  */\nconst stringXorXorXorXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i] ^ b[i] ^ b[i] ^ b[i] | 0;\n  }\n  return result;\n};\n\n/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary XOR XOR AND OR on these inputs and return the result as a string.\n  >>> stringXorXorXorXorXor('010', '110')\n  '100'\n  */\nconst stringXorXorXorXorXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i] ^ b[i] ^ b[i] ^ b[i] ^ b[i] | 0;\n  }\n  return result;\n};\n\n/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary XOR XOR XOR XOR AND on these inputs and return the result as a string.\n  >>> stringXorXorXorXorXorXor('010', '110')\n  '100'\n  */\nconst stringXorXorXorXorXorXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i] ^ b[i] ^ b[i] ^ b[i] ^ b[i] ^ b[i] | 0;\n  }\n  return result;\n};\n\n/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary XOR XOR XOR XOR XOR AND OR on these inputs and return the result as a string.\n  >>> stringXorXorXorXorXorXorXor('010', '110')\n  '100'\n  */\nconst stringXorXorXorXorXorXorXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i] ^ b[i] ^ b[i] ^ b[i] ^ b[i] ^ b[i] ^ b[i] | 0;\n  }\n  return result;\n};\n\n/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary XOR XOR XOR XOR XOR XOR XOR AND on these inputs and return the result as a string.\n  >>> stringXorXorXorXorXorXorXorXor('010', '110')\n  '100'\n  */\nconst stringXorXorXorXorXorXorXorXorXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i] ^ b[i] ^ b[i] ^ b[i] ^ b[i] ^ b[i] ^ b[i] ^ b[i] | 0;\n  }\n  return result;\n};\n\n/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary XOR XOR XOR XOR XOR XOR XOR XOR XOR XOR AND on these inputs and return the result as a string.\n  >>> stringXorXorXorXorXorXorXorXorXorXor('010', '110')\n  '100'\n  */\nconst stringXorXorXorXorXorXorXorXorXorXorXorXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i] ^ b[i] ^ b[i] ^ b[i] ^ b[i] ^ b[i] ^ b[i] ^ b[i] ^ b[i] ^ b[i] | 0;\n  }\n  return result;\n};\n\n/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary XOR XOR XOR XOR XOR XOR XOR XOR XOR XOR XOR XOR AND on these inputs and return the result as a string.\n  >>> stringXorXorXorXorXorXorXorXorXorXorXorXorXorXorXorXorXorXor"}
{"task_id": "JavaScript/12", "prompt": "/* Returns the longest string from the list of strings. Returns the first one if there are multiple strings of the same length. Returns zero if the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Returns the longest string from the list of strings. Returns the first one if there are multiple strings of the same length. Returns zero if the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (strings.length === 0) {\n    return 0;\n  }\n  let longestLength = 0;\n  let longestString = '';\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].length > longestLength) {\n      longestLength = strings[i].length;\n      longestString = strings[i];\n    }\n  }\n  return longestString;\n};\n\n/**\n * Returns the first string from the list of strings. Returns the first one if there are multiple strings of the same length. Returns zero if the input list is empty.\n  >>> first([])\n\n  >>> first(['a', 'b', 'c'])\n  'a'\n  >>> first(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst first = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  let firstString = '';\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].length > firstString.length) {\n      firstString = strings[i];\n    }\n  }\n  return firstString;\n};\n\n/**\n * Returns the last string from the list of strings. Returns the last one if there are multiple strings of the same length. Returns zero if the input list is empty.\n  >>> last([])\n\n  >>> last(['a', 'b', 'c'])\n  'c'\n  >>> last(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst last = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  let lastString = '';\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].length > lastString.length) {\n      lastString = strings[i];\n    }\n  }\n  return lastString;\n};\n\n/**\n * Returns the middle string from the list of strings. Returns the middle one if there are multiple strings of the same length. Returns zero if the input list is empty.\n  >>> middle([])\n\n  >>> middle(['a', 'b', 'c'])\n  'b'\n  >>> middle(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst middle = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  let middleString = '';\n  let middleIndex = 0;\n  let middleIndex2 = 0;\n  let middleIndex3 = 0;\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].length > middleString.length) {\n      middleString = strings[i];\n      middleIndex = i;\n    }\n    if (middleIndex2 > middleIndex3) {\n      middleIndex2 = middleIndex;\n      middleIndex3 = middleIndex;\n    }\n  }\n  return middleString;\n};\n\n/**\n * Returns the middle string from the list of strings. Returns the middle one if there are multiple strings of the same length. Returns zero if the input list is empty.\n  >>> middle([])\n\n  >>> middle(['a', 'b', 'c'])\n  'b'\n  >>> middle(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst middle2 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  let middleString = '';\n  let middleIndex = 0;\n  let middleIndex2 = 0;\n  let middleIndex3 = 0;\n  let middleIndex4 = 0;\n  let middleIndex5 = 0;\n  let middleIndex6 = 0;\n  let middleIndex7 = 0;\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].length > middleString.length) {\n      middleString = strings[i];\n      middleIndex = i;\n    }\n    if (middleIndex2 > middleIndex3) {\n      middleIndex2 = middleIndex;\n      middleIndex3 = middleIndex;\n    }\n    if (middleIndex4 > middleIndex5) {\n      middleIndex4 = middleIndex;\n      middleIndex5 = middleIndex;\n    }\n    if (middleIndex6 > middleIndex7) {\n      middleIndex6 = middleIndex;\n      middleIndex7 = middleIndex;\n    }\n  }\n  return middleString;\n};\n\n/**\n * Returns the middle string from the list of strings. Returns the middle one if there are multiple strings of the same length. Returns zero if the input list is empty.\n  >>> middle([])\n\n  >>> middle(['a', 'b', 'c'])\n  'b'\n  >>> middle(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst middle3 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  let middleString = '';\n  let middleIndex = 0;\n  let middleIndex2 = 0;\n  let middleIndex3 = 0;\n  let middleIndex4 = 0;\n  let middleIndex5 = 0;\n  let middleIndex6 = 0;\n  let middleIndex7 = 0;\n  let middleIndex8 = 0;\n  let middleIndex9 = 0;\n  let middleIndex10 = 0;\n  let middleIndex11 = 0;\n  let middleIndex12 = 0;\n  let middleIndex13 = 0;\n  let middleIndex14 = 0;\n  let middleIndex15 = 0;\n  let middleIndex16 = 0;\n  let middleIndex17 = 0;\n  let middleIndex18 = 0;\n  let middleIndex19 = 0;\n  let middleIndex20 = 0;\n  let middleIndex21 = 0;\n  let middleIndex22 = 0;\n  let middleIndex23 = 0;\n  let middleIndex24 = 0;\n  let middleIndex25 = 0;\n  let middleIndex26 = 0;\n  let middleIndex27 = 0;\n  let middleIndex28 = 0;\n  let middleIndex29 = 0;\n  let middleIndex30 = 0;\n  let middleIndex31 = 0;\n  let middleIndex32 = 0;\n  let middleIndex33 = 0;\n  let middleIndex34 = 0;\n  let middleIndex35 = 0;\n  let middleIndex36 = 0;\n  let middleIndex37 = 0;\n  let middleIndex38 = 0;\n  let middleIndex39 = 0;\n  let middleIndex40 = 0;\n  let middleIndex41 = 0;\n  let middleIndex42 = 0;\n  let middleIndex43 = 0;\n  let middleIndex44 = 0;\n  let middleIndex45 = 0;\n  let middleIndex46 = 0;\n  let middleIndex47 = 0;\n  let middleIndex48 = 0;\n  let middleIndex49 = 0;\n  let middleIndex50 = 0;\n  let middleIndex51 = 0;\n  let middleIndex52 = 0;\n  let middleIndex53 = 0;\n  let middleIndex54 = 0;\n  let middleIndex55 = 0;\n  let middleIndex56 = 0;\n  let middleIndex57 = 0;\n  let middleIndex58 = 0;\n  let middleIndex59 = 0;\n  let middleIndex60 = 0;\n  let middleIndex61 = 0;\n  let middleIndex62 = 0;\n  let middleIndex63 = 0;\n  let middleIndex64 = 0;\n  let middleIndex65 = 0;\n  let middleIndex66 = 0;\n  let middleIndex67 = 0;\n  let middleIndex68 = 0;\n  let middleIndex69 = 0;\n  let middleIndex70 = 0;\n  let middleIndex71 = 0;\n  let middleIndex72 = 0;\n  let middleIndex73 = 0;\n  let middleIndex74 = 0;\n  let middleIndex75 = 0;\n  let middleIndex76 = 0;\n  let middleIndex77 = 0;\n  let middleIndex78 = 0;\n  let middleIndex79 = 0;\n  let middleIndex80 = 0;\n  let middleIndex81 = 0;\n  let middleIndex82 = 0;\n  let middleIndex83 = 0;\n  let middleIndex84 = 0;\n  let middleIndex85 = 0;\n  let middleIndex86 = 0;\n  let middleIndex87 = 0;\n  let middleIndex88 = 0;\n  let middleIndex89 = 0;\n  let middleIndex90 = 0;\n  let middleIndex91 = 0;\n  let middleIndex92 = 0;\n  let middleIndex93 = 0;\n  let middleIndex94 = 0;\n  let middleIndex95 = 0;\n  let middleIndex96 = 0;\n  let middleIndex97 = 0;\n  let middleIndex98 = 0;\n  let middleIndex99 = 0;\n  let middleIndex100 = 0;\n  let middleIndex101 = 0;\n  let middleIndex102 = 0;\n  let middleIndex103 = 0;\n  let middleIndex104 = 0;\n  let middleIndex105 = 0;\n  let middleIndex106 = 0;\n  let middleIndex107 = 0;\n  let middleIndex108 = 0;\n  let middleIndex109 = 0;\n  let middleIndex110 = 0;\n  let middleIndex111 = 0;\n  let middleIndex112 = 0;\n  let middleIndex113 = 0;\n  let middleIndex114 = 0;\n  let middleIndex115 = 0;\n  let middleIndex116 = 0;\n  let middleIndex117 = 0;\n  let middleIndex118 = 0;\n  let "}
{"task_id": "JavaScript/13", "prompt": "/* Returns the largest common divisor of two integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Returns the largest common divisor of two integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 0) return b;\n  if (b === 0) "}
{"task_id": "JavaScript/14", "prompt": "/* Returns a list of all prefixes from the shortest to the longest of the input strings\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Returns a list of all prefixes from the shortest to the longest of the input strings\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  let prefixes = [];\n  let currentPrefix = string;\n  while (currentPrefix.length > 0) {\n    prefixes.push(currentPrefix.slice(0, -1));\n    currentPrefix = currentPrefix.slice(-1);\n  }\n  return prefixes;\n};\n\n/**\n * Returns a list of all suffixes from the shortest to the longest of the input strings\n  >>> allSuffixes('abc')\n  ['abc', 'ab', 'ac', 'ba', 'ca', 'cb', 'ca', 'cc', 'ca', 'cd', 'cb', 'cc', 'cd', 'ce', 'cb', 'cc', 'cd', 'cf', 'ca', 'cb', 'cc', 'cd', 'cg', 'ca', 'cb', 'cc', 'cd', 'ch', 'ca', 'cb', 'cc', 'cd', 'cl', 'ca', 'cb', 'cc', 'cd', 'cm', 'ca', 'cb', 'cc', 'cd', 'cn', 'ca', 'cb', 'cc', 'cd', 'co', 'ca', 'cb', 'cc', 'cd', 'cp', 'ca', 'cb', 'cc', 'cd', 'cu', 'ca', 'cb', 'cc', 'cd', 'cv', 'ca', 'cb', 'cc', 'cd', 'cw', 'ca', 'cb', 'cc', 'cd', 'cx', 'ca', 'cb', 'cc', 'cd', 'cy', 'ca', 'cb', 'cc', 'cd', 'cz', 'ca', 'cb', 'cc', 'cd', 'dd', 'ca', 'cb', 'cc', 'cd', 'de', 'ca', 'cb', 'cc', 'cd', 'dj', 'ca', 'cb', 'cc', 'cd', 'dk', 'ca', 'cb', 'cc', 'cd', 'dm', 'ca', 'cb', 'cc', 'cd', 'do', 'ca', 'cb', 'cc', 'cd', 'dz', 'ca', 'cb', 'cc', 'cd', 'ec', 'ca', 'cb', 'cc', 'cd', 'ee', 'ca', 'cb', 'cc', 'cd', 'eg', 'ca', 'cb', 'cc', 'cd', 'eh', 'ca', 'cb', 'cc', 'cd', 'er', 'ca', 'cb', 'cc', 'cd', 'es', 'ca', 'cb', 'cc', 'cd', 'et', 'ca', 'cb', 'cc', 'cd', 'eu', 'ca', 'cb', 'cc', 'cd', 'fi', 'ca', 'cb', 'cc', 'cd', 'fj', 'ca', 'cb', 'cc', 'cd', 'fk', 'ca', 'cb', 'cc', 'cd', 'fm', 'ca', 'cb', 'cc', 'cd', 'fo', 'ca', 'cb', 'cc', 'cd', 'fr', 'ca', 'cb', 'cc', 'cd', 'ga', 'ca', 'cb', 'cc', 'cd', 'gb', 'ca', 'cb', 'cc', 'cd', 'gd', 'ca', 'cb', 'cc', 'cd', 'ge', 'ca', 'cb', 'cc', 'cd', 'gf', 'ca', 'cb', 'cc', 'cd', 'gg', 'ca', 'cb', 'cc', 'cd', 'gh', 'ca', 'cb', 'cc', 'cd', 'gi', 'ca', 'cb', 'cc', 'cd', 'gl', 'ca', 'cb', 'cc', 'cd', 'gm', 'ca', 'cb', 'cc', 'cd', 'gn', 'ca', 'cb', 'cc', 'cd', 'gp', 'ca', 'cb', 'cc', 'cd', 'gq', 'ca', 'cb', 'cc', 'cd', 'gr', 'ca', 'cb', 'cc', 'cd', 'gs', 'ca', 'cb', 'cc', 'cd', 'gt', 'ca', 'cb', 'cc', 'cd', 'gu', 'ca', 'cb', 'cc', 'cd', 'gw', 'ca', 'cb', 'cc', 'cd', 'gy', 'ca', 'cb', 'cc', 'cd', 'hk', 'ca', 'cb', 'cc', 'cd', 'hm', 'ca', 'cb', 'cc', 'cd', 'hn', 'ca', 'cb', 'cc', 'cd', 'hr', 'ca', 'cb', 'cc', 'cd', 'ht', 'ca', 'cb', 'cc', 'cd', 'hu', 'ca', 'cb', 'cc', 'cd', 'id', 'ca', 'cb', 'cc', 'cd', 'ie', 'ca', 'cb', 'cc', 'cd', 'il', 'ca', 'cb', 'cc', 'cd', 'im', 'ca', 'cb', 'cc', 'cd', 'io', 'ca', 'cb', 'cc', 'cd', 'iq', 'ca', 'cb', 'cc', 'cd', 'ir', 'ca', 'cb', 'cc', 'cd', 'is', 'ca', 'cb', 'cc', 'cd', 'it', 'ca', 'cb', 'cc', 'cd', 'je', 'ca', 'cb', 'cc', 'cd', 'jm', 'ca', 'cb', 'cc', 'cd', 'jo', 'ca', 'cb', 'cc', 'cd', 'jp', 'ca', 'cb', 'cc', 'cd', 'ke', 'ca', 'cb', 'cc', 'cd', 'kg', 'ca', 'cb', 'cc', 'cd', 'kh', 'ca', 'cb', 'cc', 'cd', 'ki', 'ca', 'cb', 'cc', 'cd', 'km', 'ca', 'cb', 'cc', 'cd', 'kn', 'ca', 'cb', 'cc', 'cd', 'kp', 'ca', 'cb', 'cc', 'cd', 'kr', 'ca', 'cb', 'cc', 'cd', 'kw', 'ca', 'cb', 'cc', 'cd', 'ky', 'ca', 'cb', 'cc', 'cd', 'kz', 'ca', 'cb', 'cc', 'cd', 'lb', 'ca', 'cb', 'cc', 'cd', 'lc', 'ca', 'cb', 'cc', 'cd', 'li', 'ca', 'cb', 'cc', 'cd', 'lk', 'ca', 'cb', 'cc', 'cd', 'lr', 'ca', 'cb', 'cc', 'cd', 'ls', 'ca', 'cb', 'cc', 'cd', 'lt', 'ca', 'cb', 'cc', 'cd', 'lu', 'ca', 'cb', 'cc', 'cd', 'lv', 'ca', 'cb', 'cc', 'cd', 'ly', 'ca', 'cb', 'cc', 'cd','ma', 'ca', 'cb', 'cc', 'cd','mc', 'ca', 'cb', 'cc', 'cd','md', 'ca', 'cb', 'cc', 'cd','me', 'ca', 'cb', 'cc', 'cd','mg', 'ca', 'cb', 'cc', 'cd','mh', 'ca', 'cb', 'cc', 'cd','mk', 'ca', 'cb', 'cc', 'cd','ml', 'ca', 'cb', 'cc', 'cd','mm', 'ca', 'cb', 'cc', 'cd','mn', 'ca', 'cb', 'cc', 'cd','mo', 'ca', 'cb', 'cc', 'cd','mp', 'ca', 'cb', 'cc', 'cd','mq', 'ca', 'cb', 'cc', 'cd','mr', 'ca', 'cb', 'cc', 'cd','ms', 'ca', 'cb', 'cc', 'cd','mt', 'ca', 'cb', 'cc', 'cd','mu', 'ca', 'cb', 'cc', 'cd','mv', 'ca', 'cb', 'cc', 'cd','mw', 'ca', 'cb', 'cc', 'cd','mx', 'ca', 'cb', 'cc', 'cd','my', 'ca', 'cb', 'cc', 'cd','mz', 'ca', 'cb', 'cc', 'cd', 'na', 'ca', 'cb', 'cc', 'cd', 'nc', 'ca', 'cb', 'cc', 'cd', 'ne', 'ca', 'cb', 'cc', 'cd', 'nf', 'ca', 'cb', 'cc', 'cd', 'ng', 'ca', 'cb', 'cc', 'cd', 'ni', 'ca', 'cb', 'cc', 'cd', 'nl', 'ca', 'cb', 'cc', 'cd', 'nn', 'ca', 'cb', 'cc', 'cd', 'no', 'ca', 'cb', 'cc', 'cd', 'np', 'ca', 'cb', 'cc', 'cd', 'nr', 'ca', 'cb', 'cc', 'cd', 'nu', 'ca', 'cb', 'cc', 'cd', 'nz', 'ca', 'cb', 'cc', 'cd', 'om', 'ca', 'cb', 'cc', 'cd', 'pa', 'ca', 'cb', 'cc', 'cd', 'pe', 'ca', 'cb', 'cc', 'cd', 'pf', 'ca', 'cb', 'cc', 'cd', 'pg', 'ca', 'cb', 'cc', 'cd', 'ph', 'ca', 'cb', 'cc', 'cd', 'pk', 'ca', 'cb', 'cc', 'cd', 'pl', 'ca', 'cb', 'cc', 'cd', 'pm', 'ca', 'cb', 'cc', 'cd', '"}
{"task_id": "JavaScript/15", "prompt": "/* Returns a string containing spaces from 0 to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Returns a string containing spaces from 0 to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Returns a string containing spaces from 0 to n inclusive.\n * If n is 0, returns an empty string.\n */\nconst stringSequenceWithZero = (n) => {\n  if (n === 0) {\n    return '';\n  }\n  return stringSequence(n);\n};\n\n/**\n * Returns a string containing spaces from 0 to n inclusive.\n * If n is 0, returns an empty string.\n */\nconst stringSequenceWithZeroAndSpace = (n) => {\n  if (n === 0) {\n    return '';\n  }\n  return stringSequence(n) +'';\n};\n\n/**\n * Returns a string containing spaces from 0 to n inclusive.\n * If n is 0, returns an empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZero = (n) => {\n  if (n === 0) {\n    return '';\n  }\n  return stringSequence(n) +'0 ';\n};\n\n/**\n * Returns a string containing spaces from 0 to n inclusive.\n * If n is 0, returns an empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZeroAndSpace = (n) => {\n  if (n === 0) {\n    return '';\n  }\n  return stringSequence(n) +'0'+ stringSequence(n) +'';\n};\n\n/**\n * Returns a string containing spaces from 0 to n inclusive.\n * If n is 0, returns an empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZeroAndSpaceAndZero = (n) => {\n  if (n === 0) {\n    return '';\n  }\n  return stringSequence(n) +'0'+ stringSequence(n) +'0 ';\n};\n\n/**\n * Returns a string containing spaces from 0 to n inclusive.\n * If n is 0, returns an empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZeroAndSpaceAndZeroAndSpace = (n) => {\n  if (n === 0) {\n    return '';\n  }\n  return stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'';\n};\n\n/**\n * Returns a string containing spaces from 0 to n inclusive.\n * If n is 0, returns an empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZero = (n) => {\n  if (n === 0) {\n    return '';\n  }\n  return stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'';\n};\n\n/**\n * Returns a string containing spaces from 0 to n inclusive.\n * If n is 0, returns an empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpace = (n) => {\n  if (n === 0) {\n    return '';\n  }\n  return stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'';\n};\n\n/**\n * Returns a string containing spaces from 0 to n inclusive.\n * If n is 0, returns an empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZero = (n) => {\n  if (n === 0) {\n    return '';\n  }\n  return stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'';\n};\n\n/**\n * Returns a string containing spaces from 0 to n inclusive.\n * If n is 0, returns an empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpace = (n) => {\n  if (n === 0) {\n    return '';\n  }\n  return stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'';\n};\n\n/**\n * Returns a string containing spaces from 0 to n inclusive.\n * If n is 0, returns an empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpace = (n) => {\n  if (n === 0) {\n    return '';\n  }\n  return stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'';\n};\n\n/**\n * Returns a string containing spaces from 0 to n inclusive.\n * If n is 0, returns an empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpace = (n) => {\n  if (n === 0) {\n    return '';\n  }\n  return stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'';\n};\n\n/**\n * Returns a string containing spaces from 0 to n inclusive.\n * If n is 0, returns an empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpace = (n) => {\n  if (n === 0) {\n    return '';\n  }\n  return stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'';\n};\n\n/**\n * Returns a string containing spaces from 0 to n inclusive.\n * If n is 0, returns an empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpace = (n) => {\n  if (n === 0) {\n    return '';\n  }\n  return stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'';\n};\n\n/**\n * Returns a string containing spaces from 0 to n inclusive.\n * If n is 0, returns an empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpace = (n) => {\n  if (n === 0) {\n    return '';\n  }\n  return stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'0'+ stringSequence(n) +'';\n};\n\n/**\n * Returns a string containing spaces from 0 to n inclusive.\n * If n is 0, returns an empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAnd"}
{"task_id": "JavaScript/16", "prompt": "/* Find out how many different characters a string consists of (regardless of the case).\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Find out how many different characters a string consists of (regardless of the case).\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char ==='') {\n      count++;\n    } else {\n      count += countDistinctCharacters(char);\n    }\n  }\n  return count;\n};\n\n/**\n * Find the longest common subsequence in a string.\n * \n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommonSubsequence('abc', 'def')\n * 'def'\n * >>> longestCommonSubsequence('abc', 'abc')\n * 'abc'\n * >>> longestCommon"}
{"task_id": "JavaScript/17", "prompt": "/* Entering this function is a string that represents notes in a special ASCII format. Your task is to analyze this string and return a list of integers corresponding to the number of beats each one does not hold. Here's a legend: \"o\" - whole note, takes four beats \"o | '- half note, takes two beats.\"\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Entering this function is a string that represents notes in a special ASCII format. Your task is to analyze this string and return a list of integers corresponding to the number of beats each one does not hold. Here's a legend: \"o\" - whole note, takes four beats \"o | '- half note, takes two beats.\"\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes_array = music_string.split('|');\n  const notes_array2 = [];\n  for (let i = 0; i < notes_array.length; i++) {\n    if (notes_array[i] === 'o') {\n      notes_array2.push(4);\n    } else if (notes_array[i] === '-') {\n      notes_array2.push(2);\n    } else {\n      notes_array2.push(1);\n    }\n  }\n  return notes_array2;\n};\n\n/**\n * Given a string, return an array of integers corresponding to the number of beats each one does not hold. Here's a legend: \"o\" - whole note, takes four beats \"o | '- half note, takes two beats.\"\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic2 = (string) => {\n  const notes_array = string.split('|');\n  const notes_array2 = [];\n  for (let i = 0; i < notes_array.length; i++) {\n    if (notes_array[i] === 'o') {\n      notes_array2.push(4);\n    } else if (notes_array[i] === '-') {\n      notes_array2.push(2);\n    } else {\n      notes_array2.push(1);\n    }\n  }\n  return notes_array2;\n};\n\n/**\n * Given a string, return an array of integers corresponding to the number of beats each one does not hold. Here's a legend: \"o\" - whole note, takes four beats \"o | '- half note, takes two beats.\"\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic3 = (string) => {\n  const notes_array = string.split('|');\n  const notes_array2 = [];\n  for (let i = 0; i < notes_array.length; i++) {\n    if (notes_array[i] === 'o') {\n      notes_array2.push(4);\n    } else if (notes_array[i] === '-') {\n      notes_array2.push(2);\n    } else {\n      notes_array2.push(1);\n    }\n  }\n  return notes_array2;\n};\n\n/**\n * Given a string, return an array of integers corresponding to the number of beats each one does not hold. Here's a legend: \"o\" - whole note, takes four beats \"o | '- half note, takes two beats.\"\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic4 = (string) => {\n  const notes_array = string.split('|');\n  const notes_array2 = [];\n  for (let i = 0; i < notes_array.length; i++) {\n    if (notes_array[i] === 'o') {\n      notes_array2.push(4);\n    } else if (notes_array[i] === '-') {\n      notes_array2.push(2);\n    } else {\n      notes_array2.push(1);\n    }\n  }\n  return notes_array2;\n};\n\n/**\n * Given a string, return an array of integers corresponding to the number of beats each one does not hold. Here's a legend: \"o\" - whole note, takes four beats \"o | '- half note, takes two beats.\"\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic5 = (string) => {\n  const notes_array = string.split('|');\n  const notes_array2 = [];\n  for (let i = 0; i < notes_array.length; i++) {\n    if (notes_array[i] === 'o') {\n      notes_array2.push(4);\n    } else if (notes_array[i] === '-') {\n      notes_array2.push(2);\n    } else {\n      notes_array2.push(1);\n    }\n  }\n  return notes_array2;\n};\n\n/**\n * Given a string, return an array of integers corresponding to the number of beats each one does not hold. Here's a legend: \"o\" - whole note, takes four beats \"o | '- half note, takes two beats.\"\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic6 = (string) => {\n  const notes_array = string.split('|');\n  const notes_array2 = [];\n  for (let i = 0; i < notes_array.length; i++) {\n    if (notes_array[i] === 'o') {\n      notes_array2.push(4);\n    } else if (notes_array[i] === '-') {\n      notes_array2.push(2);\n    } else {\n      notes_array2.push(1);\n    }\n  }\n  return notes_array2;\n};\n\n/**\n * Given a string, return an array of integers corresponding to the number of beats each one does not hold. Here's a legend: \"o\" - whole note, takes four beats \"o | '- half note, takes two beats.\"\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic7 = (string) => {\n  const notes_array = string.split('|');\n  const notes_array2 = [];\n  for (let i = 0; i < notes_array.length; i++) {\n    if (notes_array[i] === 'o') {\n      notes_array2.push(4);\n    } else if (notes_array[i] === '-') {\n      notes_array2.push(2);\n    } else {\n      notes_array2.push(1);\n    }\n  }\n  return notes_array2;\n};\n\n/**\n * Given a string, return an array of integers corresponding to the number of beats each one does not hold. Here's a legend: \"o\" - whole note, takes four beats \"o | '- half note, takes two beats.\"\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic8 = (string) => {\n  const notes_array = string.split('|');\n  const notes_array2 = [];\n  for (let i = 0; i < notes_array.length; i++) {\n    if (notes_array[i] === 'o') {\n      notes_array2.push(4);\n    } else if (notes_array[i] === '-') {\n      notes_array2.push(2);\n    } else {\n      notes_array2.push(1);\n    }\n  }\n  return notes_array2;\n};\n\n/**\n * Given a string, return an array of integers corresponding to the number of beats each one does not hold. Here's a legend: \"o\" - whole note, takes four beats \"o | '- half note, takes two beats.\"\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic9 = (string) => {\n  const notes_array = string.split('|');\n  const notes_array2 = [];\n  for (let i = 0; i < notes_array.length; i++) {\n    if (notes_array[i] === 'o') {\n      notes_array2.push(4);\n    } else if (notes_array[i] === '-') {\n      notes_array2.push(2);\n    } else {\n      notes_array2.push(1);\n    }\n  }\n  return notes_array2;\n};\n\n/**\n * Given a string, "}
{"task_id": "JavaScript/18", "prompt": "/* Find out how often a particular substring can be found in the original string. Count overlapping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Find out how often a particular substring can be found in the original string. Count overlapping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  let start = 0;\n  let end = string.length;\n  while (start < end) {\n    const char = string.charAt(start);\n    if (char === substring) {\n      count++;\n    }\n    if (char === substring[0]) {\n      start++;\n    }\n    if (char === substring[substring.length - 1]) {\n      end--;\n    }\n  }\n  return count;\n};\n\n// Given a string, return all possible permutations of that string.\n// E.g. \"abc\" -> [\"abc\", \"acb\", \"bac\"]\nconst permutations = (string) => {\n  const result = [];\n  const length = string.length;\n  for (let i = 0; i < length; i++) {\n    const sub = string.substr(i, 1);\n    const permutation = [];\n    for (let j = 0; j < result.length; j++) {\n      permutation.push(result.charAt(j) + sub);\n    }\n    result.push(permutation);\n  }\n  return result;\n};\n\n// Given a string, return all possible permutations of that string.\n// E.g. \"abc\" -> [\"abc\", \"acb\", \"bac\"]\nconst permutations_recursive = (string) => {\n  const result = [];\n  const length = string.length;\n  for (let i = 0; i < length; i++) {\n    const sub = string.substr(i, 1);\n    const permutation = [];\n    for (let j = 0; j < result.length; j++) {\n      permutation.push(result.charAt(j) + sub);\n    }\n    if (result.length === 1) {\n      result.push(permutation);\n    } else {\n      result.push(...permutations_recursive(permutation));\n    }\n  }\n  return result;\n};\n\n// Given a string, return all possible permutations of that string.\n// E.g. \"abc\" -> [\"abc\", \"acb\", \"bac\"]\nconst permutations_iterative = (string) => {\n  const result = [];\n  const length = string.length;\n  for (let i = 0; i < length; i++) {\n    const sub = string.substr(i, 1);\n    const permutation = [];\n    for (let j = 0; j < result.length; j++) {\n      permutation.push(result.charAt(j) + sub);\n    }\n    if (result.length === 1) {\n      result.push(permutation);\n    } else {\n      result.push(...permutations_iterative(permutation));\n    }\n  }\n  return result;\n};\n\n// Given a string, return all possible permutations of that string.\n// E.g. \"abc\" -> [\"abc\", \"acb\", \"bac\"]\nconst permutations_recursive_recursive = (string) => {\n  const result = [];\n  const length = string.length;\n  for (let i = 0; i < length; i++) {\n    const sub = string.substr(i, 1);\n    const permutation = [];\n    for (let j = 0; j < result.length; j++) {\n      permutation.push(result.charAt(j) + sub);\n    }\n    if (result.length === 1) {\n      result.push(permutation);\n    } else {\n      result.push(...permutations_recursive_recursive(permutation));\n    }\n  }\n  return result;\n};\n\n// Given a string, return all possible permutations of that string.\n// E.g. \"abc\" -> [\"abc\", \"acb\", \"bac\"]\nconst permutations_iterative_recursive = (string) => {\n  const result = [];\n  const length = string.length;\n  for (let i = 0; i < length; i++) {\n    const sub = string.substr(i, 1);\n    const permutation = [];\n    for (let j = 0; j < result.length; j++) {\n      permutation.push(result.charAt(j) + sub);\n    }\n    if (result.length === 1) {\n      result.push(permutation);\n    } else {\n      result.push(...permutations_iterative_recursive(permutation));\n    }\n  }\n  return result;\n};\n\n// Given a string, return all possible permutations of that string.\n// E.g. \"abc\" -> [\"abc\", \"acb\", \"bac\"]\nconst permutations_recursive_recursive_iterative = (string) => {\n  const result = [];\n  const length = string.length;\n  for (let i = 0; i < length; i++) {\n    const sub = string.substr(i, 1);\n    const permutation = [];\n    for (let j = 0; j < result.length; j++) {\n      permutation.push(result.charAt(j) + sub);\n    }\n    if (result.length === 1) {\n      result.push(permutation);\n    } else {\n      result.push(...permutations_recursive_recursive_iterative(permutation));\n    }\n  }\n  return result;\n};\n\n// Given a string, return all possible permutations of that string.\n// E.g. \"abc\" -> [\"abc\", \"acb\", \"bac\"]\nconst permutations_iterative_recursive_iterative = (string) => {\n  const result = [];\n  const length = string.length;\n  for (let i = 0; i < length; i++) {\n    const sub = string.substr(i, 1);\n    const permutation = [];\n    for (let j = 0; j < result.length; j++) {\n      permutation.push(result.charAt(j) + sub);\n    }\n    if (result.length === 1) {\n      result.push(permutation);\n    } else {\n      result.push(...permutations_iterative_recursive_iterative(permutation));\n    }\n  }\n  return result;\n};\n\n// Given a string, return all possible permutations of that string.\n// E.g. \"abc\" -> [\"abc\", \"acb\", \"bac\"]\nconst permutations_recursive_recursive_iterative_recursive = (string) => {\n  const result = [];\n  const length = string.length;\n  for (let i = 0; i < length; i++) {\n    const sub = string.substr(i, 1);\n    const permutation = [];\n    for (let j = 0; j < result.length; j++) {\n      permutation.push(result.charAt(j) + sub);\n    }\n    if (result.length === 1) {\n      result.push(permutation);\n    } else {\n      result.push(...permutations_recursive_recursive_iterative_recursive(permutation));\n    }\n  }\n  return result;\n};\n\n// Given a string, return all possible permutations of that string.\n// E.g. \"abc\" -> [\"abc\", \"acb\", \"bac\"]\nconst permutations_iterative_recursive_iterative_recursive = (string) => {\n  const result = [];\n  const length = string.length;\n  for (let i = 0; i < length; i++) {\n    const sub = string.substr(i, 1);\n    const permutation = [];\n    for (let j = 0; j < result.length; j++) {\n      permutation.push(result.charAt(j) + sub);\n    }\n    if (result.length === 1) {\n      result.push(permutation);\n    } else {\n      result.push(...permutations_iterative_recursive_iterative_recursive(permutation));\n    }\n  }\n  return result;\n};\n\n// Given a string, return all possible permutations of that string.\n// E.g. \"abc\" -> [\"abc\", \"acb\", \"bac\"]\nconst permutations_recursive_recursive_iterative_recursive_iterative = (string) => {\n  const result = [];\n  const length = string.length;\n  for (let i = 0; i < length; i++) {\n    const sub = string.substr(i, 1);\n    const permutation = [];\n    for (let j = 0; j < result.length; j++) {\n      permutation.push(result.charAt(j) + sub);\n    }\n    if (result.length === 1) {\n      result.push(permutation);\n    } else {\n      result.push(...permutations_recursive_recursive_iterative_recursive_iterative(permutation));\n    }\n  }\n  return result;\n};\n\n// Given a string, return all possible permutations of that string.\n// E.g. \"abc\" -> [\"abc\", \"acb\", \"bac\"]\nconst permutations_recursive_recursive_iterative_recursive_iterative_recursive = (string) => {\n  const result = [];\n  const length = string.length;\n  for (let i = 0; i < length; i++) {\n    const sub = string.substr(i, 1);\n    const permutation = [];\n    for (let j = 0; j < result.length; j++) {\n      permutation.push(result.charAt(j) + sub);\n    }\n    if (result.length === 1) {\n      result.push(permutation);\n    } else {\n      result.push(...permutations_recursive_recursive_iterative_recursive_iterative_recursive(permutation));\n    }\n  }\n  return result;\n};\n\n// Given a string, return all possible permutations of that string.\n// E.g. \"abc\" -> [\"abc\", \"acb\", \"bac\"]\nconst permutations_recursive_recursive_iterative_recursive_iterative_recursive_iterative = (string) => {\n  const result = [];"}
{"task_id": "JavaScript/19", "prompt": "/* Input is a sequence of numbers delimited by spaces from \"zero\" to \"nine.\" Valid options are \"zero,\" \"one,\" \"two,\" \"three,\" \"four,\" \"five,\" \"six,\" \"seven,\" \"eight\" and \"nine.\"\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Input is a sequence of numbers delimited by spaces from \"zero\" to \"nine.\" Valid options are \"zero,\" \"one,\" \"two,\" \"three,\" \"four,\" \"five,\" \"six,\" \"seven,\" \"eight\" and \"nine.\"\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numbers = numbers.split(' ');\n  return numbers.sort((a, b) => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n};\n\n/* Input is a sequence of numbers delimited by spaces from \"zero\" to \"nine.\" Valid options are \"zero,\" \"one,\" \"two,\" \"three,\" \"four,\" \"five,\" \"six,\" \"seven,\" \"eight\" and \"nine.\"\n  >>> sortNumbers('three one five seven')\n  'one three five seven'\n  */\nconst sortNumbersReversed = (numbers) => {\n  const numbers = numbers.split(' ');\n  return numbers.sort((a, b) => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n};\n\n/* Input is a sequence of numbers delimited by spaces from \"zero\" to \"nine.\" Valid options are \"zero,\" \"one,\" \"two,\" \"three,\" \"four,\" \"five,\" \"six,\" \"seven,\" \"eight\" and \"nine.\"\n  >>> sortNumbersReversed('three one five seven')\n  'one three five seven'\n  */\nconst sortNumbersReversedReversed = (numbers) => {\n  const numbers = numbers.split(' ');\n  return numbers.sort((a, b) => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n};\n\n/* Input is a sequence of numbers delimited by spaces from \"zero\" to \"nine.\" Valid options are \"zero,\" \"one,\" \"two,\" \"three,\" \"four,\" \"five,\" \"six,\" \"seven,\" \"eight\" and \"nine.\"\n  >>> sortNumbersReversedReversed('three one five seven')\n  'one three five seven'\n  */\nconst sortNumbersReversedReversedReversed = (numbers) => {\n  const numbers = numbers.split(' ');\n  return numbers.sort((a, b) => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n};\n\n/* Input is a sequence of numbers delimited by spaces from \"zero\" to \"nine.\" Valid options are \"zero,\" \"one,\" \"two,\" \"three,\" \"four,\" \"five,\" \"six,\" \"seven,\" \"eight\" and \"nine.\"\n  >>> sortNumbersReversedReversedReversedReversed('three one five seven')\n  'one three five seven'\n  */\nconst sortNumbersReversedReversedReversedReversedReversed = (numbers) => {\n  const numbers = numbers.split(' ');\n  return numbers.sort((a, b) => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n};\n\n/* Input is a sequence of numbers delimited by spaces from \"zero\" to \"nine.\" Valid options are \"zero,\" \"one,\" \"two,\" \"three,\" \"four,\" \"five,\" \"six,\" \"seven,\" \"eight\" and \"nine.\"\n  >>> sortNumbersReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed"}
{"task_id": "JavaScript/20", "prompt": "/* From a list of numbers (with a length of at least two) select and return two numbers closest to each other and return them in order (smaller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* From a list of numbers (with a length of at least two) select and return two numbers closest to each other and return them in order (smaller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const minDistance = Number.MAX_VALUE;\n  const minDistanceIndex = 0;\n  const minDistanceElement = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    const distance = numbers[i] - minDistanceElement;\n    if (distance < minDistance) {\n      minDistance = distance;\n      minDistanceIndex = i;\n      minDistanceElement = numbers[i];\n    }\n  }\n  return [minDistanceElement, minDistanceIndex];\n};\n\n/**\n * Given a string, convert it to a list of numbers (each number being a number).\n * If the string contains only digits, return a list of digits, otherwise return a list of strings.\n * If the string contains letters, return a list of letters, otherwise return a list of strings.\n * If the string contains punctuation, return a list of punctuation marks, otherwise return a list of strings.\n * If the string contains whitespace, return a list of whitespace, otherwise return a list of strings.\n * If the string contains any other character, return a list of other characters, otherwise return a list of strings.\n */\nconst stringToNumbers = (str) => {\n  const numbers = [];\n  let currentNumber = 0;\n  let currentChar;\n  let isDigit = false;\n  let isLetter = false;\n  let isPunctuation = false;\n  let isWhitespace = false;\n  let isOtherChar = false;\n  for (let i = 0; i < str.length; i++) {\n    currentChar = str.charAt(i);\n    if (currentChar ==='') {\n      isWhitespace = true;\n    } else if (currentChar === '.') {\n      isOtherChar = true;\n    } else if (currentChar === ',') {\n      isPunctuation = true;\n    } else if (currentChar === '-') {\n      isDigit = true;\n    } else if (currentChar === '+') {\n      isLetter = true;\n    } else if (isDigit && isLetter && isPunctuation && isWhitespace) {\n      numbers.push(currentNumber);\n      currentNumber = 0;\n      isDigit = false;\n      isLetter = false;\n      isPunctuation = false;\n      isWhitespace = false;\n    } else if (isDigit && isLetter && isPunctuation && isOtherChar) {\n      numbers.push(currentNumber);\n      currentNumber = 0;\n      isDigit = false;\n      isLetter = false;\n      isPunctuation = false;\n      isOtherChar = false;\n    } else if (isDigit && isLetter && isPunctuation &&!isOtherChar) {\n      numbers.push(currentNumber);\n      currentNumber = 0;\n      isDigit = false;\n      isLetter = false;\n      isPunctuation = false;\n    } else if (isDigit && isLetter &&!isOtherChar && isPunctuation) {\n      numbers.push(currentNumber);\n      currentNumber = 0;\n      isDigit = false;\n      isLetter = false;\n      isPunctuation = false;\n    } else if (isDigit &&!isLetter && isPunctuation && isOtherChar) {\n      numbers.push(currentNumber);\n      currentNumber = 0;\n      isDigit = false;\n      isLetter = false;\n      isPunctuation = false;\n      isOtherChar = false;\n    } else if (isDigit &&!isLetter &&!isPunctuation &&!isOtherChar) {\n      numbers.push(currentNumber);\n      currentNumber = 0;\n      isDigit = false;\n      isLetter = false;\n      isPunctuation = false;\n    } else if (isDigit &&!isLetter &&!isPunctuation &&!isOtherChar) {\n      numbers.push(currentNumber);\n      currentNumber = 0;\n      isDigit = false;\n      isLetter = false;\n      isPunctuation = false;\n    } else if (isDigit &&!isLetter &&!isPunctuation &&!isOtherChar) {\n      numbers.push(currentNumber);\n      currentNumber = 0;\n      isDigit = false;\n      isLetter = false;\n      isPunctuation = false;\n    } else if (isDigit &&!isLetter &&!isPunctuation &&!isOtherChar) {\n      numbers.push(currentNumber);\n      currentNumber = 0;\n      isDigit = false;\n      isLetter = false;\n      isPunctuation = false;\n    } else if (isDigit &&!isLetter &&!isPunctuation &&!isOtherChar) {\n      numbers.push(currentNumber);\n      currentNumber = 0;\n      isDigit = false;\n      isLetter = false;\n      isPunctuation = false;\n    } else if (isDigit &&!isLetter &&!isPunctuation &&!isOtherChar) {\n      numbers.push(currentNumber);\n      currentNumber = 0;\n      isDigit = false;\n      isLetter = false;\n      isPunctuation = false;\n    } else if (isDigit &&!isLetter &&!isPunctuation &&!isOtherChar) {\n      numbers.push(currentNumber);\n      currentNumber = 0;\n      isDigit = false;\n      isLetter = false;\n      isPunctuation = false;\n    } else if (isDigit &&!isLetter &&!isPunctuation &&!isOtherChar) {\n      numbers.push(currentNumber);\n      currentNumber = 0;\n      isDigit = false;\n      isLetter = false;\n      isPunctuation = false;\n    } else if (isDigit &&!isLetter &&!isPunctuation &&!isOtherChar) {\n      numbers.push(currentNumber);\n      currentNumber = 0;\n      isDigit = false;\n      isLetter = false;\n      isPunctuation = false;\n    } else if (isDigit &&!isLetter &&!isPunctuation &&!isOtherChar) {\n      numbers.push(currentNumber);\n      currentNumber = 0;\n      isDigit = false;\n      isLetter = false;\n      isPunctuation = false;\n    } else if (isDigit &&!isLetter &&!isPunctuation &&!isOtherChar) {\n      numbers.push(currentNumber);\n      currentNumber = 0;\n      isDigit = false;\n      isLetter = false;\n      isPunctuation = false;\n    } else if (isDigit &&!isLetter &&!isPunctuation &&!isOtherChar) {\n      numbers.push(currentNumber);\n      currentNumber = 0;\n      isDigit = false;\n      isLetter = false;\n      isPunctuation = false;\n    } else if (isDigit &&!isLetter &&!isPunctuation &&!isOtherChar) {\n      numbers.push(currentNumber);\n      currentNumber = 0;\n      isDigit = false;\n      isLetter = false;\n      isPunctuation = false;\n    } else if (isDigit &&!isLetter &&!isPunctuation &&!isOtherChar) {\n      numbers.push(currentNumber);\n      currentNumber = 0;\n      isDigit = false;\n      isLetter = false;\n      isPunctuation = false;\n    } else if (isDigit &&!isLetter &&!isPunctuation &&!isOtherChar) {\n      numbers.push(currentNumber);\n      currentNumber = 0;\n      isDigit = false;\n      isLetter = false;\n      isPunctuation = false;\n    } else if (isDigit &&!isLetter &&!isPunctuation &&!isOtherChar) {\n      numbers.push(currentNumber);\n      currentNumber = 0;\n      isDigit = false;\n      isLetter = false;\n      isPunctuation = false;\n    } else if (isDigit &&!isLetter &&!isPunctuation &&!isOtherChar) {\n      numbers.push(currentNumber);\n      currentNumber = 0;\n      isDigit = false;\n      isLetter = false;\n      isPunctuation = false;\n    } else if (isDigit &&!isLetter &&!isPunctuation &&!isOtherChar) {\n      numbers.push(currentNumber);\n      currentNumber = 0;\n      isDigit = false;\n      isLetter = false;\n      isPunctuation = false;\n    } else if (isDigit &&!isLetter &&!isPunctuation &&!isOtherChar) {\n      numbers.push(currentNumber);\n      currentNumber = 0;\n      isDigit = false;\n      isLetter = false;\n      isPunctuation = false;\n    } else if (isDigit &&!isLetter &&!isPunctuation &&!isOtherChar) {\n      numbers.push(currentNumber);\n      currentNumber = 0;\n      isDigit = false;\n      isLetter = false;\n      isPunctuation = false;"}
{"task_id": "JavaScript/21", "prompt": "/* Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const [min, max] = numbers.map(Number);\n  return [min, max]? [min, max] : [0, 1];\n};\n\n/**\n * Given a number x, return the number x rounded to the nearest multiple of n.\n * If n is 0, return x.\n * If n is less than 0, return x.\n * If n is greater than or equal to 0, return x.\n * If n is NaN or Infinity, return NaN.\n */\nconst roundToNearest = (x, n) => {\n  if (isNaN(x) ||!isFinite(x)) {\n    return NaN;\n  }\n  if (n < 0 || n > 0 || n === Infinity) {\n    return x;\n  }\n  return Math.round(x * n) / n;\n};\n\n/**\n * Given a number x, return the number x rounded to the nearest multiple of n.\n * If n is 0, return x.\n * If n is less than 0, return x.\n * If n is greater than or equal to 0, return x.\n * If n is NaN or Infinity, return NaN.\n */\nconst roundToEven = (x, n) => {\n  if (isNaN(x) ||!isFinite(x)) {\n    return NaN;\n  }\n  if (n < 0 || n > 0 || n === Infinity) {\n    return x;\n  }\n  return Math.round(x * n) % n;\n};\n\n/**\n * Given a number x, return the number x rounded to the nearest multiple of n.\n * If n is 0, return x.\n * If n is less than 0, return x.\n * If n is greater than or equal to 0, return x.\n * If n is NaN or Infinity, return NaN.\n */\nconst roundToZero = (x, n) => {\n  if (isNaN(x) ||!isFinite(x)) {\n    return NaN;\n  }\n  if (n < 0 || n > 0 || n === Infinity) {\n    return x;\n  }\n  return Math.round(x * n) / n;\n};\n\n/**\n * Given a number x, return the number x rounded to the nearest multiple of n.\n * If n is 0, return x.\n * If n is less than 0, return x.\n * If n is greater than or equal to 0, return x.\n * If n is NaN or Infinity, return NaN.\n */\nconst roundToNearestMultiple = (x, n) => {\n  if (isNaN(x) ||!isFinite(x)) {\n    return NaN;\n  }\n  if (n < 0 || n > 0 || n === Infinity) {\n    return x;\n  }\n  return Math.round(x * n) / n;\n};\n\n/**\n * Given a number x, return the number x rounded to the nearest multiple of n.\n * If n is 0, return x.\n * If n is less than 0, return x.\n * If n is greater than or equal to 0, return x.\n * If n is NaN or Infinity, return NaN.\n */\nconst roundToEvenMultiple = (x, n) => {\n  if (isNaN(x) ||!isFinite(x)) {\n    return NaN;\n  }\n  if (n < 0 || n > 0 || n === Infinity) {\n    return x;\n  }\n  return Math.round(x * n) % n;\n};\n\n/**\n * Given a number x, return the number x rounded to the nearest multiple of n.\n * If n is 0, return x.\n * If n is less than 0, return x.\n * If n is greater than or equal to 0, return x.\n * If n is NaN or Infinity, return NaN.\n */\nconst roundToZeroMultiple = (x, n) => {\n  if (isNaN(x) ||!isFinite(x)) {\n    return NaN;\n  }\n  if (n < 0 || n > 0 || n === Infinity) {\n    return x;\n  }\n  return Math.round(x * n) / n;\n};\n\n/**\n * Given a number x, return the number x rounded to the nearest multiple of n.\n * If n is 0, return x.\n * If n is less than 0, return x.\n * If n is greater than or equal to 0, return x.\n * If n is NaN or Infinity, return NaN.\n */\nconst roundToNearestMultipleMultiple = (x, n) => {\n  if (isNaN(x) ||!isFinite(x)) {\n    return NaN;\n  }\n  if (n < 0 || n > 0 || n === Infinity) {\n    return x;\n  }\n  return Math.round(x * n) / n;\n};\n\n/**\n * Given a number x, return the number x rounded to the nearest multiple of n.\n * If n is 0, return x.\n * If n is less than 0, return x.\n * If n is greater than or equal to 0, return x.\n * If n is NaN or Infinity, return NaN.\n */\nconst roundToEvenMultipleMultiple = (x, n) => {\n  if (isNaN(x) ||!isFinite(x)) {\n    return NaN;\n  }\n  if (n < 0 || n > 0 || n === Infinity) {\n    return x;\n  }\n  return Math.round(x * n) % n;\n};\n\n/**\n * Given a number x, return the number x rounded to the nearest multiple of n.\n * If n is 0, return x.\n * If n is less than 0, return x.\n * If n is greater than or equal to 0, return x.\n * If n is NaN or Infinity, return NaN.\n */\nconst roundToZeroMultipleMultiple = (x, n) => {\n  if (isNaN(x) ||!isFinite(x)) {\n    return NaN;\n  }\n  if (n < 0 || n > 0 || n === Infinity) {\n    return x;\n  }\n  return Math.round(x * n) / n;\n};\n\n/**\n * Given a number x, return the number x rounded to the nearest multiple of n.\n * If n is 0, return x.\n * If n is less than 0, return x.\n * If n is greater than or equal to 0, return x.\n * If n is NaN or Infinity, return NaN.\n */\nconst roundToNearestMultipleMultiple = (x, n) => {\n  if (isNaN(x) ||!isFinite(x)) {\n    return NaN;\n  }\n  if (n < 0 || n > 0 || n === Infinity) {\n    return x;\n  }\n  return Math.round(x * n) / n;\n};\n\n/**\n * Given a number x, return the number x rounded to the nearest multiple of n.\n * If n is 0, return x.\n * If n is less than 0, return x.\n * If n is greater than or equal to 0, return x.\n * If n is NaN or Infinity, return NaN.\n */\nconst roundToEvenMultipleMultiple = (x, n) => {\n  if (isNaN(x) ||!isFinite(x)) {\n    return NaN;\n  }\n  if (n < 0 || n > 0 || n === Infinity) {\n    return x;\n  }\n  return Math.round(x * n) % n;\n};\n\n/**\n * Given a number x, return the number x rounded to the nearest multiple of n.\n * If n is 0, return x.\n * If n is less than 0, return x.\n * If n is greater than or equal to 0, return x.\n * If n is NaN or Infinity, return NaN.\n */\nconst roundToZeroMultipleMultiple = (x, n) => {\n  if (isNaN(x) ||!isFinite(x)) {\n    return NaN;\n  }\n  if (n < 0 || n > 0 || n === Infinity) {\n    return x;\n  }\n  return Math.round(x * n) / n;\n};\n\n/**\n * Given a number x, return the number x rounded to the nearest multiple of n.\n * If n is 0, return x.\n * If n is less than 0, return x.\n * If n is greater than or equal to 0, return x.\n * If n is NaN or Infinity, return NaN.\n */\nconst roundToNearestMultipleMultiple = (x, n) => {\n  if (isNaN(x) ||!isFinite(x)) {\n    return NaN;\n  }\n  if (n < 0 || n > 0 || n === Infinity) {\n    return x;\n  }\n  return Math.round(x * n) / n;\n};\n\n/**\n * Given "}
{"task_id": "JavaScript/22", "prompt": "/* Filters the specified list of arbitrary Python values for integers only\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Filters the specified list of arbitrary Python values for integers only\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(value => typeof value === 'number');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for floats only\n * >>> filterFloats(['a', 3.14, 5])\n  [3.14]\n  >>> filterFloats([1, 2, 3, 'abc', {}, []])\n  [1.2, 2.3, 3.4, 4.5, 5.6]\n  */\nconst filterFloats = (values) => {\n  return values.filter(value => typeof value === 'number');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for booleans only\n * >>> filterBooleans(['a', 3.14, 5])\n  [True]\n  >>> filterBooleans([1, 2, 3, 'abc', {}, []])\n  [True, True, False, True, True]\n  */\nconst filterBooleans = (values) => {\n  return values.filter(value => typeof value === 'boolean');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for strings only\n * >>> filterStrings(['a', 3.14, 5])\n  ['a', 3.14, 5]\n  >>> filterStrings([1, 2, 3, 'abc', {}, []])\n  ['1', 2, '3', 3, 'abc', {}, []]\n  */\nconst filterStrings = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for lists only\n * >>> filterLists(['a', 3.14, 5])\n  ['a', 3.14, 5]\n  >>> filterLists([1, 2, 3, 'abc', {}, []])\n  ['1', 2, '3', 3, 'abc', {}, []]\n  */\nconst filterLists = (values) => {\n  return values.filter(value => Array.isArray(value));\n};\n\n/**\n * Filters the specified list of arbitrary Python values for dicts only\n * >>> filterDicts(['a', 3.14, 5])\n  {'a': 3.14}\n  >>> filterDicts([1, 2, 3, 'abc', {}, []])\n  {'1': 2, '3': 3, 'abc': {}, '[]': []}\n  */\nconst filterDicts = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for sets and tuples\n * >>> filterSetsAndTuples(['a', 3.14, 5])\n  ['a', 3.14, 5]\n  >>> filterSetsAndTuples([1, 2, 3, 'abc', {}, []])\n  ['1', 2, '3', 3, 'abc', {}, []]\n  */\nconst filterSetsAndTuples = (values) => {\n  return values.filter(value => Array.isArray(value));\n};\n\n/**\n * Filters the specified list of arbitrary Python values for sets and tuples\n * >>> filterSetsAndTuples(['a', 3.14, 5])\n  ['a', 3.14, 5]\n  >>> filterSetsAndTuples([1, 2, 3, 'abc', {}, []])\n  ['1', 2, '3', 3, 'abc', {}, []]\n  */\nconst filterSetsAndTuples = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for sets and tuples\n * >>> filterSetsAndTuples(['a', 3.14, 5])\n  ['a', 3.14, 5]\n  >>> filterSetsAndTuples([1, 2, 3, 'abc', {}, []])\n  ['1', 2, '3', 3, 'abc', {}, []]\n  */\nconst filterSetsAndTuples = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for sets and tuples\n * >>> filterSetsAndTuples(['a', 3.14, 5])\n  ['a', 3.14, 5]\n  >>> filterSetsAndTuples([1, 2, 3, 'abc', {}, []])\n  ['1', 2, '3', 3, 'abc', {}, []]\n  */\nconst filterSetsAndTuples = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for sets and tuples\n * >>> filterSetsAndTuples(['a', 3.14, 5])\n  ['a', 3.14, 5]\n  >>> filterSetsAndTuples([1, 2, 3, 'abc', {}, []])\n  ['1', 2, '3', 3, 'abc', {}, []]\n  */\nconst filterSetsAndTuples = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for sets and tuples\n * >>> filterSetsAndTuples(['a', 3.14, 5])\n  ['a', 3.14, 5]\n  >>> filterSetsAndTuples([1, 2, 3, 'abc', {}, []])\n  ['1', 2, '3', 3, 'abc', {}, []]\n  */\nconst filterSetsAndTuples = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for sets and tuples\n * >>> filterSetsAndTuples(['a', 3.14, 5])\n  ['a', 3.14, 5]\n  >>> filterSetsAndTuples([1, 2, 3, 'abc', {}, []])\n  ['1', 2, '3', 3, 'abc', {}, []]\n  */\nconst filterSetsAndTuples = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for sets and tuples\n * >>> filterSetsAndTuples(['a', 3.14, 5])\n  ['a', 3.14, 5]\n  >>> filterSetsAndTuples([1, 2, 3, 'abc', {}, []])\n  ['1', 2, '3', 3, 'abc', {}, []]\n  */\nconst filterSetsAndTuples = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for sets and tuples\n * >>> filterSetsAndTuples(['a', 3.14, 5])\n  ['a', 3.14, 5]\n  >>> filterSetsAndTuples([1, 2, 3, 'abc', {}, []])\n  ['1', 2, '3', 3, 'abc', {}, []]\n  */\nconst filterSetsAndTuples = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for sets and tuples\n * >>> filterSetsAndTuples(['a', 3.14, 5])\n  ['a', 3.14, 5]\n  >>> filterSetsAndTuples([1, 2, 3, 'abc', {}, []])\n  ['1', 2, '3', 3, 'abc', {}, []]\n  */\nconst filterSetsAndTuples = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for sets and tuples\n * >>> filterSetsAndTuples(['a', 3.14, 5])\n  ['a', 3.14, 5]\n  >>> filterSetsAndTuples([1, 2, 3, 'abc', {}, []])\n  ['1', 2, '3', 3, 'abc', {}, []]\n  */\nconst filterSetsAndTuples = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for sets and tuples\n * >>> filterSetsAndTuples(['a', 3.14, 5])\n  ['a', 3.14, 5]\n  >>> filterSetsAndTuples([1, 2, 3, 'abc', {}, []])\n  ['1', 2, '3', 3, 'abc', {}, []]\n  */\nconst filterSetsAndTuples = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for sets and tuples\n * >>> filterSetsAndTuples(['a', 3.14, 5])\n  ['a', 3.14, 5]\n  >>> filterSetsAndTuples([1, 2, 3, 'abc', {}, []])\n  ['1', 2, '3', 3, 'abc', {}, []]\n  */\nconst filterSetsAndTuples = (values) => {\n  return values.filter(value => typeof "}
{"task_id": "JavaScript/23", "prompt": "/* Returns the length of the given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Returns the length of the given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length\n}\n\n/**\n * Returns the number of characters in the given string\n * >>> strlen('abc')\n  3\n  */\nconst strlenC = (string) => {\n  return string.length\n}\n\n/**\n * Returns the first character in the given string\n * >>> strchr('abc', 'a')\n  'a'\n  */\nconst strchr = (string, char) => {\n  return string.charAt(0)\n}\n\n/**\n * Returns the last character in the given string\n * >>> strchr('abc', 'z')\n  'z'\n  */\nconst strchrC = (string, char) => {\n  return string.charAt(string.length - 1)\n}\n\n/**\n * Returns the index of the first character in the given string\n * >>> strrchr('abc', 'a')\n  0\n  */\nconst strrchr = (string, char) => {\n  return string.lastIndexOf(char, 0)\n}\n\n/**\n * Returns the index of the last character in the given string\n * >>> strrchr('abc', 'z')\n  string.length\n  */\nconst strrchrC = (string, char) => {\n  return string.lastIndexOf(char, string.length - 1)\n}\n\n/**\n * Returns the index of the first character in the given string\n * >>> strrchrC('abc', 'a')\n  0\n  */\nconst strrchrC = (string, char) => {\n  return string.lastIndexOf(char, 0)\n}\n\n/**\n * Returns the index of the last character in the given string\n * >>> strrchrC('abc', 'z')\n  string.length\n  */\nconst strrchrC = (string, char) => {\n  return string.lastIndexOf(char, string.length - 1)\n}\n\n/**\n * Returns the index of the first character in the given string\n * >>> strrchrC('abc', 'a')\n  0\n  */\nconst strrchrC = (string, char) => {\n  return string.lastIndexOf(char, 0)\n}\n\n/**\n * Returns the index of the last character in the given string\n * >>> strrchrC('abc', 'z')\n  string.length\n  */\nconst strrchrC = (string, char) => {\n  return string.lastIndexOf(char, string.length - 1)\n}\n\n/**\n * Returns the index of the first character in the given string\n * >>> strrchrC('abc', 'a')\n  0\n  */\nconst strrchrC = (string, char) => {\n  return string.lastIndexOf(char, 0)\n}\n\n/**\n * Returns the index of the last character in the given string\n * >>> strrchrC('abc', 'z')\n  string.length\n  */\nconst strrchrC = (string, char) => {\n  return string.lastIndexOf(char, string.length - 1)\n}\n\n/**\n * Returns the index of the first character in the given string\n * >>> strrchrC('abc', 'a')\n  0\n  */\nconst strrchrC = (string, char) => {\n  return string.lastIndexOf(char, 0)\n}\n\n/**\n * Returns the index of the last character in the given string\n * >>> strrchrC('abc', 'z')\n  string.length\n  */\nconst strrchrC = (string, char) => {\n  return string.lastIndexOf(char, string.length - 1)\n}\n\n/**\n * Returns the index of the first character in the given string\n * >>> strrchrC('abc', 'a')\n  0\n  */\nconst strrchrC = (string, char) => {\n  return string.lastIndexOf(char, 0)\n}\n\n/**\n * Returns the index of the last character in the given string\n * >>> strrchrC('abc', 'z')\n  string.length\n  */\nconst strrchrC = (string, char) => {\n  return string.lastIndexOf(char, string.length - 1)\n}\n\n/**\n * Returns the index of the first character in the given string\n * >>> strrchrC('abc', 'a')\n  0\n  */\nconst strrchrC = (string, char) => {\n  return string.lastIndexOf(char, 0)\n}\n\n/**\n * Returns the index of the last character in the given string\n * >>> strrchrC('abc', 'z')\n  string.length\n  */\nconst strrchrC = (string, char) => {\n  return string.lastIndexOf(char, string.length - 1)\n}\n\n/**\n * Returns the index of the first character in the given string\n * >>> strrchrC('abc', 'a')\n  0\n  */\nconst strrchrC = (string, char) => {\n  return string.lastIndexOf(char, 0)\n}\n\n/**\n * Returns the index of the last character in the given string\n * >>> strrchrC('abc', 'z')\n  string.length\n  */\nconst strrchrC = (string, char) => {\n  return string.lastIndexOf(char, string.length - 1)\n}\n\n/**\n * Returns the index of the first character in the given string\n * >>> strrchrC('abc', 'a')\n  0\n  */\nconst strrchrC = (string, char) => {\n  return string.lastIndexOf(char, 0)\n}\n\n/**\n * Returns the index of the last character in the given string\n * >>> strrchrC('abc', 'z')\n  string.length\n  */\nconst strrchrC = (string, char) => {\n  return string.lastIndexOf(char, string.length - 1)\n}\n\n/**\n * Returns the index of the first character in the given string\n * >>> strrchrC('abc', 'a')\n  0\n  */\nconst strrchrC = (string, char) => {\n  return string.lastIndexOf(char, 0)\n}\n\n/**\n * Returns the index of the last character in the given string\n * >>> strrchrC('abc', 'z')\n  string.length\n  */\nconst strrchrC = (string, char) => {\n  return string.lastIndexOf(char, string.length - 1)\n}\n\n/**\n * Returns the index of the first character in the given string\n * >>> strrchrC('abc', 'a')\n  0\n  */\nconst strrchrC = (string, char) => {\n  return string.lastIndexOf(char, 0)\n}\n\n/**\n * Returns the index of the last character in the given string\n * >>> strrchrC('abc', 'z')\n  string.length\n  */\nconst strrchrC = (string, char) => {\n  return string.lastIndexOf(char, string.length - 1)\n}\n\n/**\n * Returns the index of the first character in the given string\n * >>> strrchrC('abc', 'a')\n  0\n  */\nconst strrchrC = (string, char) => {\n  return string.lastIndexOf(char, 0)\n}\n\n/**\n * Returns the index of the last character in the given string\n * >>> strrchrC('abc', 'z')\n  string.length\n  */\nconst strrchrC = (string, char) => {\n  return string.lastIndexOf(char, string.length - 1)\n}\n\n/**\n * Returns the index of the first character in the given string\n * >>> strrchrC('abc', 'a')\n  0\n  */\nconst strrchrC = (string, char) => {\n  return string.lastIndexOf(char, 0)\n}\n\n/**\n * Returns the index of the last character in the given string\n * >>> strrchrC('abc', 'z')\n  string.length\n  */\nconst strrchrC = (string, char) => {\n  return string.lastIndexOf(char, string.length - 1)\n}\n\n/**\n * Returns the index of the first character in the given string\n * >>> strrchrC('abc', 'a')\n  0\n  */\nconst strrchrC = (string, char) => {\n  return string.lastIndexOf(char, 0)\n}\n\n/**\n * Returns the index of the last character in the given string\n * >>> strrchrC('abc', 'z')\n  string.length\n  */\nconst strrchrC = (string, char) => {\n  return string.lastIndexOf(char, string.length - 1)\n}\n\n/**\n * Returns the index of the first character in the given string\n * >>> strrchrC('abc"}
{"task_id": "JavaScript/24", "prompt": "/* Find for a given number n the largest number dividing n equally, less than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Find for a given number n the largest number dividing n equally, less than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let divisor = 1;\n  while (divisor <= n) {\n    divisor *= 10;\n  }\n  return divisor;\n};\n\n/**\n * Find the greatest common divisor of two numbers.\n * \n * >>> gcd(15, 15)\n  5\n  */\nconst gcd = (a, b) => {\n  let gcd = 1;\n  while (a > b) {\n    gcd *= 10;\n    a %= gcd * 10;\n  }\n  return gcd;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> lcm(15, 15)\n  15\n  */\nconst lcm = (a, b) => {\n  let lcm = 1;\n  while (a > b) {\n    lcm *= 10;\n    a %= lcm * 10;\n  }\n  return lcm;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> lcm(15, 15)\n  15\n  */\nconst mod10 = (a) => {\n  return a % 10;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod10(15)\n  15\n  */\nconst mod100 = (a) => {\n  return a % 100;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod100(15)\n  15\n  */\nconst mod1000 = (a) => {\n  return a % 1000;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod1000(15)\n  15\n  */\nconst mod10000 = (a) => {\n  return a % 10000;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod10000(15)\n  15\n  */\nconst mod100000 = (a) => {\n  return a % 100000;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod100000(15)\n  15\n  */\nconst mod1000000 = (a) => {\n  return a % 1000000;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod1000000(15)\n  15\n  */\nconst mod10000000 = (a) => {\n  return a % 10000000;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod1000000(15)\n  15\n  */\nconst mod100000000 = (a) => {\n  return a % 1000000000;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod100000000(15)\n  15\n  */\nconst mod1000000000 = (a) => {\n  return a % 1000000000;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod100000000(15)\n  15\n  */\nconst mod10000000000 = (a) => {\n  return a % 10000000000;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod10000000000(15)\n  15\n  */\nconst mod100000000000 = (a) => {\n  return a % 100000000000;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod1000000000000(15)\n  15\n  */\nconst mod1000000000000 = (a) => {\n  return a % 1000000000000;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod10000000000000(15)\n  15\n  */\nconst mod100000000000000 = (a) => {\n  return a % 100000000000000;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod100000000000000(15)\n  15\n  */\nconst mod1000000000000000 = (a) => {\n  return a % 1000000000000000;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod1000000000000000(15)\n  15\n  */\nconst mod10000000000000000 = (a) => {\n  return a % 100000000000000000;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod10000000000000000(15)\n  15\n  */\nconst mod100000000000000000(a) {\n  return a % 100000000000000000;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod10000000000000000(15)\n  15\n  */\nconst mod100000000000000000 = (a) => {\n  return a % 100000000000000000;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod10000000000000000(15)\n  15\n  */\nconst mod100000000000000001 = (a) => {\n  return a % 100000000000000001;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod100000000000000001(15)\n  15\n  */\nconst mod1000000000000000010 = (a) => {\n  return a % 1000000000000000010;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod1000000000000000010(15)\n  15\n  */\nconst mod10000000000000000100 = (a) => {\n  return a % 10000000000000000100;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod10000000000000000100(15)\n  15\n  */\nconst mod100000000000000001000 = (a) => {\n  return a % 100000000000000001000;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod100000000000000001000(15)\n  15\n  */\nconst mod1000000000000000010000 = (a) => {\n  return a % 1000000000000000010000;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod1000000000000000010000(15)\n  15\n  */\nconst mod10000000000000000100000 = (a) => {\n  return a % 1000000000000000010000;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod10000000000000000100000(15)\n  15\n  */\nconst mod100000000000000001000000 = (a) => {\n  return a % 1000000000000000010000;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod100000000000000001000000(15)\n  15\n  */\nconst mod1000000000000000010000010 = (a) => {\n  return a % 1000000000000000010000;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod1000000000000000010000010(15)\n  15\n  */\nconst mod10000000000000000100000100 = (a) => {\n  return a % 1000000000000000010000;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod10000000000000000100000100(15)\n  15\n  */\nconst mod100000000000000001000001010 = (a) => {\n  return a % 1000000000000000010000;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod100000000000000001000001010(15)\n  15\n  */\nconst mod100000000000000001000001100 = (a) => {\n  return a % 1000000000000000010000;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod100000000000000001000001100(15)\n  15\n  */\nconst mod1000000000000000010000011 = (a) => {\n  return a % 1000000000000000010000;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod1000000000000000010000011(15)\n  15\n  */\nconst mod100000000000000001000001110 = (a) => {\n  return a % 1000000000000000010000;\n};\n\n/**\n * Find the least common multiple of two numbers.\n * \n * >>> mod100000000000000001000001110(15)\n  15\n  */\nconst mod"}
{"task_id": "JavaScript/25", "prompt": "/* Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factors.push(factor);\n    n /= factor;\n    factor++;\n  }\n  return factors;\n};\n\n/* Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize2 = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factors.push(factor);\n    n /= factor;\n    factor++;\n  }\n  return factors;\n};\n\n/* Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize3 = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factors.push(factor);\n    n /= factor;\n    factor++;\n  }\n  return factors;\n};\n\n/* Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize4 = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factors.push(factor);\n    n /= factor;\n    factor++;\n  }\n  return factors;\n};\n\n/* Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize5 = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factors.push(factor);\n    n /= factor;\n    factor++;\n  }\n  return factors;\n};\n\n/* Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize6 = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factors.push(factor);\n    n /= factor;\n    factor++;\n  }\n  return factors;\n};\n\n/* Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize7 = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factors.push(factor);\n    n /= factor;\n    factor++;\n  }\n  return factors;\n};\n\n/* Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize8 = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factors.push(factor);\n    n /= factor;\n    factor++;\n  }\n  return factors;\n};\n\n/* Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize9 = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factors.push(factor);\n    n /= factor;\n    factor++;\n  }\n  return factors;\n};\n\n/* Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize10 = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factors.push(factor);\n    n /= factor;\n    factor++;\n  }\n  return factors;\n};\n\n/* Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize11 = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factors.push(factor);\n    n /= factor;\n    factor++;\n  }\n  return factors;\n};\n\n/* Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize12 = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factors.push(factor);\n    n /= factor;\n    factor++;\n  }\n  return factors;\n};\n\n/* Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize13 = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factors.push(factor);\n    n /= factor;\n    factor++;\n  }\n  return factors;\n};\n\n/* Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number "}
{"task_id": "JavaScript/26", "prompt": "/* Remove from a list of integers all elements that occur more than once, and leave the order of the elements the same as when you entered them.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Remove from a list of integers all elements that occur more than once, and leave the order of the elements the same as when you entered them.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const seen = new Set();\n  return numbers.filter((number) => {\n    if (seen.has(number)) {\n      return false;\n    }\n    seen.add(number);\n    return true;\n  });\n};\n\n/**\n * Given an array of numbers, return a new array where each element is the sum of the numbers in the original array.\n * If the original array contains duplicates, return a new array where each element is the sum of the numbers in the original array except for that element itself.\n * If the original array is empty, return a new empty array.\n * If the original array is shorter than 2, return a new array with one element equal to 1.\n * If the original array is longer than 2, return a new array with one element equal to 2.\n * If the original array is longer than 3, return a new array with one element equal to 3.\n * If the original array is longer than 4, return a new array with one element equal to 4.\n * If the original array is longer than 5, return a new array with one element equal to 5.\n * If the original array is longer than 6, return a new array with one element equal to 6.\n * If the original array is longer than 7, return a new array with one element equal to 7.\n * If the original array is longer than 8, return a new array with one element equal to 8.\n * If the original array is longer than 9, return a new array with one element equal to 9.\n * If the original array is longer than 10, return a new array with one element equal to 10.\n * If the original array is longer than 11, return a new array with one element equal to 11.\n * If the original array is longer than 12, return a new array with one element equal to 12.\n * If the original array is longer than 13, return a new array with one element equal to 13.\n * If the original array is longer than 14, return a new array with one element equal to 14.\n * If the original array is longer than 15, return a new array with one element equal to 15.\n * If the original array is longer than 16, return a new array with one element equal to 16.\n * If the original array is longer than 17, return a new array with one element equal to 17.\n * If the original array is longer than 18, return a new array with one element equal to 18.\n * If the original array is longer than 19, return a new array with one element equal to 19.\n * If the original array is longer than 20, return a new array with one element equal to 20.\n * If the original array is longer than 21, return a new array with one element equal to 21.\n * If the original array is longer than 22, return a new array with one element equal to 22.\n * If the original array is longer than 23, return a new array with one element equal to 23.\n * If the original array is longer than 24, return a new array with one element equal to 24.\n * If the original array is longer than 25, return a new array with one element equal to 25.\n * If the original array is longer than 26, return a new array with one element equal to 26.\n * If the original array is longer than 27, return a new array with one element equal to 27.\n * If the original array is longer than 28, return a new array with one element equal to 28.\n * If the original array is longer than 29, return a new array with one element equal to 29.\n * If the original array is longer than 30, return a new array with one element equal to 30.\n * If the original array is longer than 31, return a new array with one element equal to 31.\n * If the original array is longer than 32, return a new array with one element equal to 32.\n * If the original array is longer than 33, return a new array with one element equal to 33.\n * If the original array is longer than 34, return a new array with one element equal to 34.\n * If the original array is longer than 35, return a new array with one element equal to 35.\n * If the original array is longer than 36, return a new array with one element equal to 36.\n * If the original array is longer than 37, return a new array with one element equal to 37.\n * If the original array is longer than 38, return a new array with one element equal to 38.\n * If the original array is longer than 39, return a new array with one element equal to 39.\n * If the original array is longer than 40, return a new array with one element equal to 40.\n * If the original array is longer than 41, return a new array with one element equal to 41.\n * If the original array is longer than 42, return a new array with one element equal to 42.\n * If the original array is longer than 43, return a new array with one element equal to 43.\n * If the original array is longer than 44, return a new array with one element equal to 44.\n * If the original array is longer than 45, return a new array with one element equal to 45.\n * If the original array is longer than 46, return a new array with one element equal to 46.\n * If the original array is longer than 47, return a new array with one element equal to 47.\n * If the original array is longer than 48, return a new array with one element equal to 48.\n * If the original array is longer than 49, return a new array with one element equal to 49.\n * If the original array is longer than 50, return a new array with one element equal to 50.\n * If the original array is longer than 51, return a new array with one element equal to 51.\n * If the original array is longer than 52, return a new array with one element equal to 52.\n * If the original array is longer than 53, return a new array with one element equal to 53.\n * If the original array is longer than 54, return a new array with one element equal to 54.\n * If the original array is longer than 55, return a new array with one element equal to 55.\n * If the original array is longer than 56, return a new array with one element equal to 56.\n * If the original array is longer than 57, return a new array with one element equal to 57.\n * If the original array is longer than 58, return a new array with one element equal to 58.\n * If the original array is longer than 59, return a new array with one element equal to 59.\n * If the original array is longer than 60, return a new array with one element equal to 60.\n * If the original array is longer than 61, return a new array with one element equal to 61.\n * If the original array is longer than 62, return a new array with one element equal to 62.\n * If the original array is longer than 63, return a new array with one element equal to 63.\n * If the original array is longer than 64, return a new array with one element equal to 64.\n * If the original array is longer than 65, return a new array with one element equal to 65.\n * If the original array is longer than 66, return a new array with one element equal to 66.\n * If the original array is longer than 67, return a new array with one element equal to 67.\n * If the original array is longer than 68, return a new array with one element equal to 68.\n * If the original array is longer than 69, return a new array with one element equal to 69.\n * If the original array is longer than 70, return a new array with one element equal to 70.\n * If the original array is longer than 71, return a new array with one element equal to 71.\n * If the original array is longer than 72, return a new array with one element equal to 72.\n * If the original array is longer than 73, return a new array with one element equal to 73.\n * If the original array is longer than 74, return a new array with one element equal to 74.\n * If the original array is longer than 75, return a new array with one element equal to 75.\n * If the original array is longer than 76, return a new array with one element equal to 76.\n * If the original array is longer than 77, return a new array with one element equal to 77.\n * If the original array is longer than 78, return a new array with one element equal to 78.\n * If the original array is longer than 79, return a new array with one element equal to 79.\n * If the original array is longer than 80, return a new array with one element equal to 80.\n * If the original array is longer than 81, return a new array with one element equal to 81.\n * If the original array is longer than 82, return a new array with one element equal to 82.\n * If the original array is longer than 83, return a new array with one element equal to 83.\n * If the original array is longer than 84, "}
{"task_id": "JavaScript/27", "prompt": "/* Flip lowercase letters to uppercase letters and uppercase letters to lowercase letters.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Flip lowercase letters to uppercase letters and uppercase letters to lowercase letters.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.toLowerCase().split('')\n   .map((letter) => letter.toUpperCase())\n   .join('');\n};\n\n/**\n * Returns a random integer between min (inclusive) and max (exclusive)\n * inclusive.\n *\n * @param {Number} min The minimum random value\n * @param {Number} max The maximum random value\n */\nconst randomInt = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * Returns a random integer between min (inclusive) and max (inclusive)\n * inclusive.\n *\n * @param {Number} min The minimum random value\n * @param {Number} max The maximum random value\n */\nconst randomIntInclusive = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * Returns a random integer between min (inclusive) and max (inclusive)\n * inclusive.\n *\n * @param {Number} min The minimum random value\n * @param {Number} max The maximum random value\n */\nconst randomIntBetween = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * Returns a random integer between min (inclusive) and max (inclusive)\n * inclusive.\n *\n * @param {Number} min The minimum random value\n * @param {Number} max The maximum random value\n */\nconst randomIntBetweenInclusive = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * Returns a random integer between min (inclusive) and max (inclusive)\n * inclusive.\n *\n * @param {Number} min The minimum random value\n * @param {Number} max The maximum random value\n */\nconst randomIntBetweenInclusive = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * Returns a random integer between min (inclusive) and max (inclusive)\n * inclusive.\n *\n * @param {Number} min The minimum random value\n * @param {Number} max The maximum random value\n */\nconst randomIntBetweenInclusive = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * Returns a random integer between min (inclusive) and max (inclusive)\n * inclusive.\n *\n * @param {Number} min The minimum random value\n * @param {Number} max The maximum random value\n */\nconst randomIntBetweenInclusive = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * Returns a random integer between min (inclusive) and max (inclusive)\n * inclusive.\n *\n * @param {Number} min The minimum random value\n * @param {Number} max The maximum random value\n */\nconst randomIntBetweenInclusive = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * Returns a random integer between min (inclusive) and max (inclusive)\n * inclusive.\n *\n * @param {Number} min The minimum random value\n * @param {Number} max The maximum random value\n */\nconst randomIntBetweenInclusive = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * Returns a random integer between min (inclusive) and max (inclusive)\n * inclusive.\n *\n * @param {Number} min The minimum random value\n * @param {Number} max The maximum random value\n */\nconst randomIntBetweenInclusive = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * Returns a random integer between min (inclusive) and max (inclusive)\n * inclusive.\n *\n * @param {Number} min The minimum random value\n * @param {Number} max The maximum random value\n */\nconst randomIntBetweenInclusive = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * Returns a random integer between min (inclusive) and max (inclusive)\n * inclusive.\n *\n * @param {Number} min The minimum random value\n * @param {Number} max The maximum random value\n */\nconst randomIntBetweenInclusive = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * Returns a random integer between min (inclusive) and max (inclusive)\n * inclusive.\n *\n * @param {Number} min The minimum random value\n * @param {Number} max The maximum random value\n */\nconst randomIntBetweenInclusive = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * Returns a random integer between min (inclusive) and max (inclusive)\n * inclusive.\n *\n * @param {Number} min The minimum random value\n * @param {Number} max The maximum random value\n */\nconst randomIntBetweenInclusive = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * Returns a random integer between min (inclusive) and max (inclusive)\n * inclusive.\n *\n * @param {Number} min The minimum random value\n * @param {Number} max The maximum random value\n */\nconst randomIntBetweenInclusive = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * Returns a random integer between min (inclusive) and max (inclusive)\n * inclusive.\n *\n * @param {Number} min The minimum random value\n * @param {Number} max The maximum random value\n */\nconst randomIntBetweenInclusive = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * Returns a random integer between min (inclusive) and max (inclusive)\n * inclusive.\n *\n * @param {Number} min The minimum random value\n * @param {Number} max The maximum random value\n */\nconst randomIntBetweenInclusive = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * Returns a random integer between min (inclusive) and max (inclusive)\n * inclusive.\n *\n * @param {Number} min The minimum random value\n * @param {Number} max The maximum random value\n */\nconst randomIntBetweenInclusive = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * Returns a random integer between min (inclusive) and max (inclusive)\n * inclusive.\n *\n * @param {Number} min The minimum random value\n * @param {Number} max The maximum random value\n */\nconst randomIntBetweenInclusive = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * Returns a random integer between min (inclusive) and max (inclusive)\n * inclusive.\n *\n * @param {Number} min The minimum random value\n * @param {Number} max The maximum random value\n */\nconst randomIntBetweenInclusive = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * Returns a random integer between min (inclusive) and max (inclusive)\n * inclusive.\n *\n * @param {Number} min The minimum random value\n * @param {Number} max The maximum random value\n */\nconst randomIntBetweenInclusive = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * Returns a random integer between min (inclusive) and max (inclusive)\n * inclusive.\n *\n * @param {Number} min The minimum random value\n * @param {Number} max The maximum random value\n */\nconst randomIntBetweenInclusive = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};"}
{"task_id": "JavaScript/28", "prompt": "/* Merge List of Strings into a Single String\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Merge List of Strings into a Single String\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, curr, index) => {\n    return acc + (curr? curr : '');\n  }, '');\n};\n\n/* Convert Object to String\n  >>> stringify({ a: 'foo', b: 'bar' })\n  '{\"a\":\"foo\",\"b\":\"bar\"}'\n  */\nconst stringify = obj => {\n  return Object.keys(obj).map(key => {\n    return `${key}=${obj[key]}`;\n  }).join(' ');\n};\n\n/* Convert Object to JSON\n  >>> stringify({ a: 'foo', b: 'bar' })\n  '{\"a\":\"foo\",\"b\":\"bar\"}'\n  */\nconst stringifyJSON = obj => {\n  return JSON.stringify(obj);\n};\n\n/* Convert Object to XML\n  >>> stringify({ a: 'foo', b: 'bar' })\n  '<a>foo</a><b>bar</b>'\n  */\nconst stringifyXML = obj => {\n  return `<${Object.keys(obj).map(key => `<${key}>${obj[key]}</${key}>`).join('')}>`;\n};\n\n/* Convert Object to HTML\n  >>> stringify({ a: 'foo', b: 'bar' })\n  '<a>foo</a><b>bar</b>'\n  */\nconst stringifyHTML = obj => {\n  return `<${Object.keys(obj).map(key => `<${key}>${obj[key]}</${key}>`).join('')}>`;\n};\n\n/* Convert Object to CSV\n  >>> stringify({ a: 'foo', b: 'bar' })\n  'a,foo,bar'\n  */\nconst stringifyCSV = obj => {\n  return Object.keys(obj).map(key => {\n    return `${key},${obj[key]}`;\n  }).join(',');\n};\n\n/* Convert Object to JSON\n  >>> stringify({ a: 'foo', b: 'bar' })\n  '{\"a\":\"foo\",\"b\":\"bar\"}'\n  */\nconst stringifyJSONP = obj => {\n  return `jsonp${stringify(obj)}`;\n};\n\n/* Convert Object to XML\n  >>> stringify({ a: 'foo', b: 'bar' })\n  '<a>foo</a><b>bar</b>'\n  */\nconst stringifyXMLP = obj => {\n  return `<${Object.keys(obj).map(key => `<${key}>${obj[key]}</${key}>`).join('')}>`;\n};\n\n/* Convert Object to HTML\n  >>> stringify({ a: 'foo', b: 'bar' })\n  '<a>foo</a><b>bar</b>'\n  */\nconst stringifyHTMLP = obj => {\n  return `<${Object.keys(obj).map(key => `<${key}>${obj[key]}</${key}>`).join('')}>`;\n};\n\n/* Convert Object to CSV\n  >>> stringify({ a: 'foo', b: 'bar' })\n  'a,foo,bar'\n  */\nconst stringifyCSVP = obj => {\n  return Object.keys(obj).map(key => {\n    return `${key},${obj[key]}`;\n  }).join(',');\n};\n\n/* Convert Object to JSON\n  >>> stringify({ a: 'foo', b: 'bar' })\n  '{\"a\":\"foo\",\"b\":\"bar\"}'\n  */\nconst stringifyJSONPJSON = obj => {\n  return `jsonp${stringify(obj)}${stringify(obj)}`;\n};\n\n/* Convert Object to XML\n  >>> stringify({ a: 'foo', b: 'bar' })\n  '<a>foo</a><b>bar</b>'\n  */\nconst stringifyXMLPXML = obj => {\n  return `<${Object.keys(obj).map(key => `<${key}>${obj[key]}</${key}>`).join('')}>`;\n};\n\n/* Convert Object to HTML\n  >>> stringify({ a: 'foo', b: 'bar' })\n  '<a>foo</a><b>bar</b>'\n  */\nconst stringifyHTMLPHTML = obj => {\n  return `<${Object.keys(obj).map(key => `<${key}>${obj[key]}</${key}>`).join('')}>`;\n};\n\n/* Convert Object to CSV\n  >>> stringify({ a: 'foo', b: 'bar' })\n  'a,foo,bar'\n  */\nconst stringifyCSVPCSV = obj => {\n  return Object.keys(obj).map(key => {\n    return `${key},${obj[key]}`;\n  }).join(',');\n};\n\n/* Convert Object to JSON\n  >>> stringify({ a: 'foo', b: 'bar' })\n  '{\"a\":\"foo\",\"b\":\"bar\"}'\n  */\nconst stringifyJSONPJSONP = obj => {\n  return `jsonp${stringify(obj)}${stringify(obj)}`;\n};\n\n/* Convert Object to XML\n  >>> stringify({ a: 'foo', b: 'bar' })\n  '<a>foo</a><b>bar</b>'\n  */\nconst stringifyXMLPXMLP = obj => {\n  return `<${Object.keys(obj).map(key => `<${key}>${obj[key]}</${key}>`).join('')}>`;\n};\n\n/* Convert Object to HTML\n  >>> stringify({ a: 'foo', b: 'bar' })\n  '<a>foo</a><b>bar</b>'\n  */\nconst stringifyHTMLPHTMLP = obj => {\n  return `<${Object.keys(obj).map(key => `<${key}>${obj[key]}</${key}>`).join('')}>`;\n};\n\n/* Convert Object to CSV\n  >>> stringify({ a: 'foo', b: 'bar' })\n  'a,foo,bar'\n  */\nconst stringifyCSVPCSVP = obj => {\n  return Object.keys(obj).map(key => {\n    return `${key},${obj[key]}`;\n  }).join(',');\n};\n\n/* Convert Object to JSON\n  >>> stringify({ a: 'foo', b: 'bar' })\n  '{\"a\":\"foo\",\"b\":\"bar\"}'\n  */\nconst stringifyJSONPJSONPJSONP = obj => {\n  return `jsonp${stringify(obj)}${stringify(obj)}`;\n};\n\n/* Convert Object to XML\n  >>> stringify({ a: 'foo', b: 'bar' })\n  '<a>foo</a><b>bar</b>'\n  */\nconst stringifyXMLPXMLPXMLP = obj => {\n  return `<${Object.keys(obj).map(key => `<${key}>${obj[key]}</${key}>`).join('')}>`;\n};\n\n/* Convert Object to HTML\n  >>> stringify({ a: 'foo', b: 'bar' })\n  '<a>foo</a><b>bar</b>'\n  */\nconst stringifyHTMLPHTMLPHTMLP = obj => {\n  return `<${Object.keys(obj).map(key => `<${key}>${obj[key]}</${key}>`).join('')}>`;\n};\n\n/* Convert Object to CSV\n  >>> stringify({ a: 'foo', b: 'bar' })\n  'a,foo,bar'\n  */\nconst stringifyCSVPCSVPCSVP = obj => {\n  return Object.keys(obj).map(key => {\n    return `${key},${obj[key]}`;\n  }).join(',');\n};\n\n/* Convert Object to JSON\n  >>> stringify({ a: 'foo', b: 'bar' })\n  '{\"a\":\"foo\",\"b\":\"bar\"}'\n  */\nconst stringifyJSONPJSONPJSONPJSONP = obj => {\n  return `jsonp${stringify(obj)}${stringify(obj)}`;\n};\n\n/* Convert Object to XML\n  >>> stringify({ a: '"}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list of strings only for strings starting with a certain prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Filter an input list of strings only for strings starting with a certain prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix))\n}\n\n/**\n  Filter an input list of strings only for the first occurrence of a prefix.\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByFirstPrefix = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix))[0]\n}\n\n/**\n  Filter an input list of strings only for the last occurrence of a prefix.\n  >>> filterByFirstPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  'array'\n  */\nconst filterByLastPrefix = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix))[strings.length - 1]\n}\n\n/**\n  Filter an input list of strings only for the first occurrence of a suffix.\n  >>> filterByLastPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  'array'\n  */\nconst filterByFirstSuffix = (strings, suffix) => {\n  return strings.filter(string => string.endsWith(suffix))[0]\n}\n\n/**\n  Filter an input list of strings only for the last occurrence of a suffix.\n  >>> filterByFirstSuffix(['abc', 'bcd', 'cde', 'array'], 'a')\n  'array'\n  */\nconst filterByLastSuffix = (strings, suffix) => {\n  return strings.filter(string => string.endsWith(suffix))[strings.length - 1]\n}\n\n/**\n  Filter an input list of strings only for the first occurrence of a suffix.\n  >>> filterByFirstSuffix(['abc', 'bcd', 'cde', 'array'], 'a')\n  'array'\n  */\nconst filterByFirstWord = (strings, word) => {\n  return strings.filter(string => string.includes(word))[0]\n}\n\n/**\n  Filter an input list of strings only for the last occurrence of a suffix.\n  >>> filterByLastWord(['abc', 'bcd', 'cde', 'array'], 'a')\n  'array'\n  */\nconst filterByLastWord = (strings, word) => {\n  return strings.filter(string => string.includes(word))[strings.length - 1]\n}\n\n/**\n  Filter an input list of strings only for the first occurrence of a word.\n  >>> filterByFirstWord(['abc', 'bcd', 'cde', 'array'], 'a')\n  'abc'\n  */\nconst filterByFirstWordIn = (strings, word) => {\n  return strings.filter(string => string.includes(word))[0]\n}\n\n/**\n  Filter an input list of strings only for the last occurrence of a word.\n  >>> filterByLastWordIn(['abc', 'bcd', 'cde', 'array'], 'a')\n  'array'\n  */\nconst filterByLastWordIn = (strings, word) => {\n  return strings.filter(string => string.includes(word))[strings.length - 1]\n}\n\n/**\n  Filter an input list of strings only for the first occurrence of a word.\n  >>> filterByFirstWordIn(['abc', 'bcd', 'cde', 'array'], 'a')\n  'abc'\n  */\nconst filterByFirstWordInWords = (strings, word) => {\n  return strings.filter(string => string.includes(word))[0]\n}\n\n/**\n  Filter an input list of strings only for the last occurrence of a word.\n  >>> filterByLastWordInWords(['abc', 'bcd', 'cde', 'array'], 'a')\n  'array'\n  */\nconst filterByLastWordInWords = (strings, word) => {\n  return strings.filter(string => string.includes(word))[strings.length - 1]\n}\n\n/**\n  Filter an input list of strings only for the first occurrence of a word.\n  >>> filterByFirstWordInWords(['abc', 'bcd', 'cde', 'array'], 'a')\n  'abc'\n  */\nconst filterByFirstWordInWordsWords = (strings, word) => {\n  return strings.filter(string => string.includes(word))[0]\n}\n\n/**\n  Filter an input list of strings only for the last occurrence of a word.\n  >>> filterByLastWordInWordsWords(['abc', 'bcd', 'cde', 'array'], 'a')\n  'array'\n  */\nconst filterByLastWordInWordsWords = (strings, word) => {\n  return strings.filter(string => string.includes(word))[strings.length - 1]\n}\n\n/**\n  Filter an input list of strings only for the first occurrence of a word.\n  >>> filterByFirstWordInWordsWords(['abc', 'bcd', 'cde', 'array'], 'a')\n  'abc'\n  */\nconst filterByFirstWordInWordsWordsWords = (strings, word) => {\n  return strings.filter(string => string.includes(word))[0]\n}\n\n/**\n  Filter an input list of strings only for the last occurrence of a word.\n  >>> filterByLastWordInWordsWordsWords(['abc', 'bcd', 'cde', 'array'], 'a')\n  'array'\n  */\nconst filterByLastWordInWordsWordsWords = (strings, word) => {\n  return strings.filter(string => string.includes(word))[strings.length - 1]\n}\n\n/**\n  Filter an input list of strings only for the first occurrence of a word.\n  >>> filterByFirstWordInWordsWordsWords(['abc', 'bcd', 'cde', 'array'], 'a')\n  'abc'\n  */\nconst filterByFirstWordInWordsWordsWordsWords = (strings, word) => {\n  return strings.filter(string => string.includes(word))[0]\n}\n\n/**\n  Filter an input list of strings only for the last occurrence of a word.\n  >>> filterByLastWordInWordsWordsWordsWords(['abc', 'bcd', 'cde', 'array'], 'a')\n  'array'\n  */\nconst filterByLastWordInWordsWordsWordsWords = (strings, word) => {\n  return strings.filter(string => string.includes(word))[strings.length - 1]\n}\n\n/**\n  Filter an input list of strings only for the first occurrence of a word.\n  >>> filterByFirstWordInWordsWordsWordsWords(['abc', 'bcd', 'cde', 'array'], 'a')\n  'abc'\n  */\nconst filterByFirstWordInWordsWordsWordsWordsWords = (strings, word) => {\n  return strings.filter(string => string.includes(word))[0]\n}\n\n/**\n  Filter an input list of strings only for the last occurrence of a word.\n  >>> filterByLastWordInWordsWordsWordsWordsWords(['abc', 'bcd', 'cde', 'array'], 'a')\n  'array'\n  */\nconst filterByLastWordInWordsWordsWordsWordsWords = (strings, word) => {\n  return strings.filter(string => string.includes(word))[strings.length - 1]\n}\n\n/**\n  Filter an input list of strings only for the first occurrence of a word.\n  >>> filterByFirstWordInWordsWordsWordsWordsWords(['abc', 'bcd', 'cde', 'array'], 'a')\n  'abc'\n  */\nconst filterByFirstWordInWordsWordsWordsWordsWordsWords = (strings, word) => {\n  return strings.filter(string => string.includes(word))[0]\n}\n\n/**\n  Filter an input list of strings only for the last occurrence of a word.\n  >>> filterByLastWordInWordsWordsWordsWordsWordsWords(['abc', 'bcd', 'cde', 'array'], 'a')\n  'array'\n  */\nconst filterByLastWordInWordsWordsWordsWordsWordsWords = (strings, word) => {\n  return strings.filter(string => string.includes(word))[strings.length - 1]\n}\n\n/**\n  Filter an input list of strings only for the "}
{"task_id": "JavaScript/30", "prompt": "/*RThe list contains only positive numbers.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*RThe list contains only positive numbers.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/**\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/**\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/**\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/**\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/**\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/**\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/**\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/**\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/**\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/**\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/**\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/**\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/**\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/**\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/**\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/**\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/**\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/**\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/**\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/**\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/**\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/**\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/**\n  >>> getPositive([-1, 2, -4, 5, "}
{"task_id": "JavaScript/31", "prompt": "/*Return true if a given number is a prime number and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return true if a given number is a prime number and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Given a number, return true if it is divisible by all prime factors.\n  >>> isDivisibleByAllPrimes(6)\n  true\n  >>> isDivisibleByAllPrimes(10)\n  false\n  >>> isDivisibleByAllPrimes(11)\n  false\n  >>> isDivisibleByAllPrimes(13)\n  false\n  >>> isDivisibleByAllPrimes(15)\n  true\n  >>> isDivisibleByAllPrimes(16)\n  false\n  >>> isDivisibleByAllPrimes(17)\n  false\n  >>> isDivisibleByAllPrimes(18)\n  false\n  >>> isDivisibleByAllPrimes(19)\n  false\n  >>> isDivisibleByAllPrimes(20)\n  false\n  >>> isDivisibleByAllPrimes(21)\n  false\n  >>> isDivisibleByAllPrimes(22)\n  false\n  >>> isDivisibleByAllPrimes(23)\n  false\n  >>> isDivisibleByAllPrimes(24)\n  false\n  >>> isDivisibleByAllPrimes(25)\n  false\n  >>> isDivisibleByAllPrimes(26)\n  false\n  >>> isDivisibleByAllPrimes(27)\n  false\n  >>> isDivisibleByAllPrimes(28)\n  false\n  >>> isDivisibleByAllPrimes(29)\n  false\n  >>> isDivisibleByAllPrimes(30)\n  false\n  >>> isDivisibleByAllPrimes(31)\n  false\n  >>> isDivisibleByAllPrimes(32)\n  false\n  >>> isDivisibleByAllPrimes(33)\n  false\n  >>> isDivisibleByAllPrimes(34)\n  false\n  >>> isDivisibleByAllPrimes(35)\n  false\n  >>> isDivisibleByAllPrimes(36)\n  false\n  >>> isDivisibleByAllPrimes(37)\n  false\n  >>> isDivisibleByAllPrimes(38)\n  false\n  >>> isDivisibleByAllPrimes(39)\n  false\n  >>> isDivisibleByAllPrimes(40)\n  false\n  >>> isDivisibleByAllPrimes(41)\n  false\n  >>> isDivisibleByAllPrimes(42)\n  false\n  >>> isDivisibleByAllPrimes(43)\n  false\n  >>> isDivisibleByAllPrimes(44)\n  false\n  >>> isDivisibleByAllPrimes(45)\n  false\n  >>> isDivisibleByAllPrimes(46)\n  false\n  >>> isDivisibleByAllPrimes(47)\n  false\n  >>> isDivisibleByAllPrimes(48)\n  false\n  >>> isDivisibleByAllPrimes(49)\n  false\n  >>> isDivisibleByAllPrimes(50)\n  false\n  >>> isDivisibleByAllPrimes(51)\n  false\n  >>> isDivisibleByAllPrimes(52)\n  false\n  >>> isDivisibleByAllPrimes(53)\n  false\n  >>> isDivisibleByAllPrimes(54)\n  false\n  >>> isDivisibleByAllPrimes(55)\n  false\n  >>> isDivisibleByAllPrimes(56)\n  false\n  >>> isDivisibleByAllPrimes(57)\n  false\n  >>> isDivisibleByAllPrimes(58)\n  false\n  >>> isDivisibleByAllPrimes(59)\n  false\n  >>> isDivisibleByAllPrimes(60)\n  false\n  >>> isDivisibleByAllPrimes(61)\n  false\n  >>> isDivisibleByAllPrimes(62)\n  false\n  >>> isDivisibleByAllPrimes(63)\n  false\n  >>> isDivisibleByAllPrimes(64)\n  false\n  >>> isDivisibleByAllPrimes(65)\n  false\n  >>> isDivisibleByAllPrimes(66)\n  false\n  >>> isDivisibleByAllPrimes(67)\n  false\n  >>> isDivisibleByAllPrimes(68)\n  false\n  >>> isDivisibleByAllPrimes(69)\n  false\n  >>> isDivisibleByAllPrimes(70)\n  false\n  >>> isDivisibleByAllPrimes(71)\n  false\n  >>> isDivisibleByAllPrimes(72)\n  false\n  >>> isDivisibleByAllPrimes(73)\n  false\n  >>> isDivisibleByAllPrimes(74)\n  false\n  >>> isDivisibleByAllPrimes(75)\n  false\n  >>> isDivisibleByAllPrimes(76)\n  false\n  >>> isDivisibleByAllPrimes(77)\n  false\n  >>> isDivisibleByAllPrimes(78)\n  false\n  >>> isDivisibleByAllPrimes(79)\n  false\n  >>> isDivisibleByAllPrimes(80)\n  false\n  >>> isDivisibleByAllPrimes(81)\n  false\n  >>> isDivisibleByAllPrimes(82)\n  false\n  >>> isDivisibleByAllPrimes(83)\n  false\n  >>> isDivisibleByAllPrimes(84)\n  false\n  >>> isDivisibleByAllPrimes(85)\n  false\n  >>> isDivisibleByAllPrimes(86)\n  false\n  >>> isDivisibleByAllPrimes(87)\n  false\n  >>> isDivisibleByAllPrimes(88)\n  false\n  >>> isDivisibleByAllPrimes(89)\n  false\n  >>> isDivisibleByAllPrimes(90)\n  false\n  >>> isDivisibleByAllPrimes(91)\n  false\n  >>> isDivisibleByAllPrimes(92)\n  false\n  >>> isDivisibleByAllPrimes(93)\n  false\n  >>> isDivisibleByAllPrimes(94)\n  false\n  >>> isDivisibleByAllPrimes(95)\n  false\n  >>> isDivisibleByAllPrimes(96)\n  false\n  >>> isDivisibleByAllPrimes(97)\n  false\n  >>> isDivisibleBy"}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let x = 0;\n  let index = 0;\n  let prev = 0;\n  let next = 0;\n  let sum = 0;\n  let max = 0;\n  let zero = 0;\n  let i;\n\n  if (xs.length % 2!== 0) {\n    throw new Error('findZero expects list of even number of coefficients');\n  }\n\n  for (i = 0; i < xs.length; i = i + 2) {\n    prev = next;\n    next = xs[i];\n    sum = prev + next;\n    max = Math.max(max, sum);\n    if (max === 0) {\n      zero = i;\n      break;\n    }\n  }\n\n  if (zero === undefined) {\n    throw new Error('findZero could not find zero point');\n  }\n\n  return zero;\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findNearest finds x such that poly(x) = 1.\n  findNearest returns only nearest point, even if there are many.\n  Moreover, findNearest only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findNearest([1, 2]), 2) # f(x) = 1 + 2x\n  0.5\n  >>> round(findNearest([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findNearest = (xs) => {\n  let x = 0;\n  let index = 0;\n  let prev = 0;\n  let next = 0;\n  let sum = 0;\n  let max = 0;\n  let nearest = 0;\n  let i;\n\n  if (xs.length % 2!== 0) {\n    throw new Error('findNearest expects list of even number of coefficients');\n  }\n\n  for (i = 0; i < xs.length; i = i + 2) {\n    prev = next;\n    next = xs[i];\n    sum = prev + next;\n    max = Math.max(max, sum);\n    if (max === 0) {\n      nearest = i;\n      break;\n    }\n  }\n\n  if (nearest === undefined) {\n    throw new Error('findNearest could not find nearest point');\n  }\n\n  return nearest;\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findNearest2 finds x such that poly(x) = 1.\n  findNearest2 returns only nearest point, even if there are many.\n  Moreover, findNearest2 only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findNearest2([1, 2]), 2) # f(x) = 1 + 2x\n  0.5\n  >>> round(findNearest2([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findNearest2 = (xs) => {\n  let x = 0;\n  let index = 0;\n  let prev = 0;\n  let next = 0;\n  let sum = 0;\n  let max = 0;\n  let nearest = 0;\n  let i;\n\n  if (xs.length % 2!== 0) {\n    throw new Error('findNearest2 expects list of even number of coefficients');\n  }\n\n  for (i = 0; i < xs.length; i = i + 2) {\n    prev = next;\n    next = xs[i];\n    sum = prev + next;\n    max = Math.max(max, sum);\n    if (max === 0) {\n      nearest = i;\n      break;\n    }\n  }\n\n  if (nearest === undefined) {\n    throw new Error('findNearest2 could not find nearest point');\n  }\n\n  return nearest;\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findNearest3 finds x such that poly(x) = 1.\n  findNearest3 returns only nearest point, even if there are many.\n  Moreover, findNearest3 only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findNearest3([1, 2]), 2) # f(x) = 1 + 2x\n  0.5\n  >>> round(findNearest3([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findNearest3 = (xs) => {\n  let x = 0;\n  let index = 0;\n  let prev = 0;\n  let next = 0;\n  let sum = 0;\n  let max = 0;\n  let nearest = 0;\n  let i;\n\n  if (xs.length % 2!== 0) {\n    throw new Error('findNearest3 expects list of even number of coefficients');\n  }\n\n  for (i = 0; i < xs.length; i = i + 2) {\n    prev = next;\n    next = xs[i];\n    sum = prev + next;\n    max = Math.max(max, sum);\n    if (max === 0) {\n      nearest = i;\n      break;\n    }\n  }\n\n  if (nearest === undefined) {\n    throw new Error('findNearest3 could not find nearest point');\n  }\n\n  return nearest;\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findNearest4 finds x such that poly(x) = 1.\n  findNearest4 returns only nearest point, even if there are many.\n  Moreover, findNearest4 only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findNearest4([1, 2]), 2) # f(x) = 1 + 2x\n  0.5\n  >>> round(findNearest4([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findNearest4 = (xs) => {\n  let x = 0;\n  let index = 0;\n  let prev = 0;\n  let next = 0;\n  let sum = 0;\n  let max = 0;\n  let nearest = 0;\n  let i;\n\n  if (xs.length % 2!== 0) {\n    throw new Error('findNearest4 expects list of even number of coefficients');\n  }\n\n  for (i = 0; i < xs.length; i = i + 2) {\n    prev = next;\n    next = xs[i];\n    sum = prev + next;\n    max = Math.max(max, sum);\n    if (max === 0) {\n      nearest = i;\n      break;\n    }\n  }\n\n  if (nearest === undefined) {\n    throw new Error('findNearest4 could not find nearest point');\n  }\n\n  return nearest;\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findNearest5 finds x such that poly(x) = 1.\n  findNearest5 returns only nearest point, even if there are many.\n  Moreover, findNearest5 only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findNearest5([1, 2]), 2) "}
{"task_id": "JavaScript/33", "prompt": "/*Tits function takes a list l and returns a list l'so that l' is identical to l in indices that are not divisible by three, while its values for indices divisible by three correspond to the values of the corresponding indices of l but are sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Tits function takes a list l and returns a list l'so that l' is identical to l in indices that are not divisible by three, while its values for indices divisible by three correspond to the values of the corresponding indices of l but are sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const thirds = [3, 3];\n  const thirdIndexes = [0, 2];\n  const thirdValues = [1, 2];\n  const thirdIndexesValues = [0, 2];\n  const thirdValueIndexes = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, 2];\n  const thirdValueIndexesValues = [0, "}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let seen = new Set()\n  return l.filter(function (item) {\n    if (seen.has(item)) {\n      return false\n    }\n    seen.add(item)\n    return true\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], true)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWith = (l, equals) => {\n  let seen = new Set()\n  return l.filter(function (item) {\n    if (seen.has(item)) {\n      return false\n    }\n    seen.add(item)\n    return equals(item, item)\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], (a, b) => a < b)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithEquals = (l, equals) => {\n  let seen = new Set()\n  return l.filter(function (item) {\n    if (seen.has(item)) {\n      return false\n    }\n    seen.add(item)\n    return equals(item, item)\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], (a, b) => a > b)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithLessThan = (l, equals) => {\n  let seen = new Set()\n  return l.filter(function (item) {\n    if (seen.has(item)) {\n      return false\n    }\n    seen.add(item)\n    return!equals(item, item)\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], (a, b) => a === b)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithEqualsLessThan = (l, equals) => {\n  let seen = new Set()\n  return l.filter(function (item) {\n    if (seen.has(item)) {\n      return false\n    }\n    seen.add(item)\n    return!equals(item, item)\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], (a, b) => a > b && a < c)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithLessThanEquals = (l, equals) => {\n  let seen = new Set()\n  return l.filter(function (item) {\n    if (seen.has(item)) {\n      return false\n    }\n    seen.add(item)\n    return!equals(item, item)\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], (a, b) => a === b && a < c)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithEqualsLessThanEquals = (l, equals) => {\n  let seen = new Set()\n  return l.filter(function (item) {\n    if (seen.has(item)) {\n      return false\n    }\n    seen.add(item)\n    return!equals(item, item)\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], (a, b) => a > b && a < c && a === d)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithLessThanEqualsEquals = (l, equals) => {\n  let seen = new Set()\n  return l.filter(function (item) {\n    if (seen.has(item)) {\n      return false\n    }\n    seen.add(item)\n    return!equals(item, item)\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], (a, b) => a === b && a < c && a === d)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithEqualsEqualsLessThanEquals = (l, equals) => {\n  let seen = new Set()\n  return l.filter(function (item) {\n    if (seen.has(item)) {\n      return false\n    }\n    seen.add(item)\n    return!equals(item, item)\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], (a, b) => a > b && a < c && a === d)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithEqualsEqualsLessThanEqualsEquals = (l, equals) => {\n  let seen = new Set()\n  return l.filter(function (item) {\n    if (seen.has(item)) {\n      return false\n    }\n    seen.add(item)\n    return!equals(item, item)\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], (a, b) => a > b && a < c && a === d)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithEqualsEqualsLessThanEqualsEqualsEquals = (l, equals) => {\n  let seen = new Set()\n  return l.filter(function (item) {\n    if (seen.has(item)) {\n      return false\n    }\n    seen.add(item)\n    return!equals(item, item)\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], (a, b) => a > b && a < c && a === d)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithEqualsEqualsEqualsEqualsEqualsEqualsEquals = (l, equals) => {\n  let seen = new Set()\n  return l.filter(function (item) {\n    if (seen.has(item)) {\n      return false\n    }\n    seen.add(item)\n    return!equals(item, item)\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], (a, b) => a > b && a < c && a === d)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithEqualsEqualsEqualsEqualsEqualsEqualsEqualsEquals = (l, equals) => {\n  let seen = new Set()\n  return l.filter(function (item) {\n    if (seen.has(item)) {\n      return false\n    }\n    seen.add(item)\n    return!equals(item, item)\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], (a, b) => a > b && a < c && a === d)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEquals = (l, equals) => {\n  let seen = new Set()\n  return l.filter(function (item) {\n    if (seen.has(item)) {\n      return false\n    }\n    seen.add(item)\n    return!equals(item, item)\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], (a, b) => a > b && a < c && a === d)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqualsEqual"}
{"task_id": "JavaScript/35", "prompt": "/*Rreturns the maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Rreturns the maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  return l.length > 0? l[l.length - 1] : undefined;\n};\n\n/**\n * Returns the minimum element in the list.\n * >>> minElement([1, 2, 3])\n  1\n  >>> minElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -5\n  */\nconst minElement = (l) => {\n  return l.length > 0? l[0] : undefined;\n};\n\n/**\n * Returns the sum of all the elements in the list.\n * >>> sumElement([1, 2, 3])\n  6\n  >>> sumElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  12\n  */\nconst sumElement = (l) => {\n  return l.length > 0? l.reduce((a, b) => a + b, 0) : undefined;\n};\n\n/**\n * Returns the product of the elements in the list.\n * >>> productElement([1, 2, 3])\n  6\n  >>> productElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  24\n  */\nconst productElement = (l) => {\n  return l.length > 0? l.reduce((a, b) => a * b, 1) : undefined;\n};\n\n/**\n * Returns the sum of all the elements in the list.\n * >>> sumElements([1, 2, 3])\n  6\n  >>> sumElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  24\n  */\nconst sumElements = (l) => {\n  return l.length > 0? l.reduce((a, b) => a + b, 0) : undefined;\n};\n\n/**\n * Returns the product of the elements in the list.\n * >>> productElements([1, 2, 3])\n  6\n  >>> productElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  24\n  */\nconst productElements = (l) => {\n  return l.length > 0? l.reduce((a, b) => a * b, 1) : undefined;\n};\n\n/**\n * Returns the sum of all the elements in the list.\n * >>> sumElements([1, 2, 3])\n  6\n  >>> sumElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  24\n  */\nconst sumElementsOf = (l) => {\n  return l.length > 0? l.reduce((a, b) => a + b, 0) : undefined;\n};\n\n/**\n * Returns the product of the elements in the list.\n * >>> productElements([1, 2, 3])\n  6\n  >>> productElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  24\n  */\nconst productElementsOf = (l) => {\n  return l.length > 0? l.reduce((a, b) => a * b, 1) : undefined;\n};\n\n/**\n * Returns the sum of all the elements in the list.\n * >>> sumElementsOf([1, 2, 3])\n  6\n  >>> sumElementsOf([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  24\n  */\nconst sumElementsOf = (l) => {\n  return l.length > 0? l.reduce((a, b) => a + b, 0) : undefined;\n};\n\n/**\n * Returns the product of the elements in the list.\n * >>> productElementsOf([1, 2, 3])\n  6\n  >>> productElementsOf([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  24\n  */\nconst productElementsOf = (l) => {\n  return l.length > 0? l.reduce((a, b) => a * b, 1) : undefined;\n};\n\n/**\n * Returns the sum of all the elements in the list.\n * >>> sumElementsOf([1, 2, 3])\n  6\n  >>> sumElementsOf([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  24\n  */\nconst sumElementsOf = (l) => {\n  return l.length > 0? l.reduce((a, b) => a + b, 0) : undefined;\n};\n\n/**\n * Returns the product of the elements in the list.\n * >>> productElementsOf([1, 2, 3])\n  6\n  >>> productElementsOf([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  24\n  */\nconst productElementsOf = (l) => {\n  return l.length > 0? l.reduce((a, b) => a * b, 1) : undefined;\n};\n\n/**\n * Returns the sum of all the elements in the list.\n * >>> sumElementsOf([1, 2, 3])\n  6\n  >>> sumElementsOf([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  24\n  */\nconst sumElementsOf = (l) => {\n  return l.length > 0? l.reduce((a, b) => a + b, 0) : undefined;\n};\n\n/**\n * Returns the product of the elements in the list.\n * >>> productElementsOf([1, 2, 3])\n  6\n  >>> productElementsOf([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  24\n  */\nconst productElementsOf = (l) => {\n  return l.length > 0? l.reduce((a, b) => a * b, 1) : undefined;\n};\n\n/**\n * Returns the sum of all the elements in the list.\n * >>> sumElementsOf([1, 2, 3])\n  6\n  >>> sumElementsOf([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  24\n  */\nconst sumElementsOf = (l) => {\n  return l.length > 0? l.reduce((a, b) => a + b, 0) : undefined;\n};\n\n/**\n * Returns the product of the elements in the list.\n * >>> productElementsOf([1, 2, 3])\n  6\n  >>> productElementsOf([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  24\n  */\nconst productElementsOf = (l) => {\n  return l.length > 0? l.reduce((a, b) => a * b, 1) : undefined;\n};\n\n/**\n * Returns the sum of all the elements in the list.\n * >>> sumElementsOf([1, 2, 3])\n  6\n  >>> sumElementsOf([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  24\n  */\nconst sumElementsOf = (l) => {\n  return l.length > 0? l.reduce((a, b) => a + b, 0) : undefined;\n};\n\n/**\n * Returns the product of the elements in the list.\n * >>> productElementsOf([1, 2, 3])\n  6\n  >>> productElementsOf([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  24\n  */\nconst productElementsOf = (l) => {\n  return l.length > 0? l.reduce((a, b) => a * b, 1) : undefined;\n};\n\n/**\n * Returns the sum of all the elements in the list.\n * >>> sumElementsOf([1, 2, 3])\n  6\n  >>> sumElementsOf([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  24\n  */\nconst sumElementsOf = (l) => {\n  return l.length > 0? l.reduce((a, b) => a + b, 0) : undefined;\n};\n\n/**\n * Returns the product of the elements in the list.\n * >>> productElementsOf([1, 2, 3])\n  6\n  >>> productElementsOf([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  24\n  */\nconst productElementsOf = (l) => {\n  return l.length > 0? l.reduce((a, b) => a * b, 1) : undefined;\n};\n\n/**\n * Returns the sum of all the elements in the list.\n * >>> sumElementsOf([1, 2, 3])\n  6\n  >>> sumElementsOf([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  24\n  */\nconst sumElementsOf = (l) => {\n  return l.length > 0? l.reduce((a, b) => a + b, 0) : undefined;\n};\n\n/**\n * Returns the product of the elements in the list.\n * "}
{"task_id": "JavaScript/36", "prompt": "/*Rindicates how often the digit 7 appears in integers smaller than n, which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Rindicates how often the digit 7 appears in integers smaller than n, which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let result = \"\";\n  while (i <= n) {\n    if (i % 3 === 0) {\n      result += j;\n      j = 1;\n    }\n    if (i % 5 === 0) {\n      result += k;\n      k = 1;\n    }\n    if (i % 7!== 0) {\n      result += j;\n      j = 1;\n    }\n    i++;\n  }\n  return result;\n};\n\n/*\n  >>> fizzBuzz(100)\n  0\n  >>> fizzBuzz(101)\n  0\n  >>> fizzBuzz(102)\n  0\n  >>> fizzBuzz(103)\n  0\n  >>> fizzBuzz(104)\n  0\n  >>> fizzBuzz(105)\n  0\n  >>> fizzBuzz(106)\n  0\n  >>> fizzBuzz(107)\n  0\n  >>> fizzBuzz(108)\n  0\n  >>> fizzBuzz(109)\n  0\n  >>> fizzBuzz(110)\n  0\n  >>> fizzBuzz(111)\n  0\n  >>> fizzBuzz(112)\n  0\n  >>> fizzBuzz(113)\n  0\n  >>> fizzBuzz(114)\n  0\n  >>> fizzBuzz(115)\n  0\n  >>> fizzBuzz(116)\n  0\n  >>> fizzBuzz(117)\n  0\n  >>> fizzBuzz(118)\n  0\n  >>> fizzBuzz(119)\n  0\n  >>> fizzBuzz(120)\n  0\n  >>> fizzBuzz(121)\n  0\n  >>> fizzBuzz(122)\n  0\n  >>> fizzBuzz(123)\n  0\n  >>> fizzBuzz(124)\n  0\n  >>> fizzBuzz(125)\n  0\n  >>> fizzBuzz(126)\n  0\n  >>> fizzBuzz(127)\n  0\n  >>> fizzBuzz(128)\n  0\n  >>> fizzBuzz(129)\n  0\n  >>> fizzBuzz(130)\n  0\n  >>> fizzBuzz(131)\n  0\n  >>> fizzBuzz(132)\n  0\n  >>> fizzBuzz(133)\n  0\n  >>> fizzBuzz(134)\n  0\n  >>> fizzBuzz(135)\n  0\n  >>> fizzBuzz(136)\n  0\n  >>> fizzBuzz(137)\n  0\n  >>> fizzBuzz(138)\n  0\n  >>> fizzBuzz(139)\n  0\n  >>> fizzBuzz(140)\n  0\n  >>> fizzBuzz(141)\n  0\n  >>> fizzBuzz(142)\n  0\n  >>> fizzBuzz(143)\n  0\n  >>> fizzBuzz(144)\n  0\n  >>> fizzBuzz(145)\n  0\n  >>> fizzBuzz(146)\n  0\n  >>> fizzBuzz(147)\n  0\n  >>> fizzBuzz(148)\n  0\n  >>> fizzBuzz(149)\n  0\n  >>> fizzBuzz(150)\n  0\n  >>> fizzBuzz(151)\n  0\n  >>> fizzBuzz(152)\n  0\n  >>> fizzBuzz(153)\n  0\n  >>> fizzBuzz(154)\n  0\n  >>> fizzBuzz(155)\n  0\n  >>> fizzBuzz(156)\n  0\n  >>> fizzBuzz(157)\n  0\n  >>> fizzBuzz(158)\n  0\n  >>> fizzBuzz(159)\n  0\n  >>> fizzBuzz(160)\n  0\n  >>> fizzBuzz(161)\n  0\n  >>> fizzBuzz(162)\n  0\n  >>> fizzBuzz(163)\n  0\n  >>> fizzBuzz(164)\n  0\n  >>> fizzBuzz(165)\n  0\n  >>> fizzBuzz(166)\n  0\n  >>> fizzBuzz(167)\n  0\n  >>> fizzBuzz(168)\n  0\n  >>> fizzBuzz(169)\n  0\n  >>> fizzBuzz(170)\n  0\n  >>> fizzBuzz(171)\n  0\n  >>> fizzBuzz(172)\n  0\n  >>> fizzBuzz(173)\n  0\n  >>> fizzBuzz(174)\n  0\n  >>> fizzBuzz(175)\n  0\n  >>> fizzBuzz(176)\n  0\n  >>> fizzBuzz(177)\n  0\n  >>> fizzBuzz(178)\n  0\n  >>> fizzBuzz(179)\n  0\n  >>> fizzBuzz(180)\n  0\n  >>> fizzBuzz(181)\n  0\n  >>> fizzBuzz(182)\n  0\n  >>> fizzBuzz(183)\n  0\n  >>> fizzBuzz(184)\n  0\n  >>> fizzBuzz(185)\n  0\n  >>> fizzBuzz(186)\n  0\n  >>> fizzBuzz(187)\n  0\n  >>> fizzBuzz(188)\n  0\n  >>> fizzBuzz(189)\n  0\n  >>> fizzBuzz(190)\n  0\n  >>> fizzBuzz(191)\n  0\n  >>> fizzBuzz(192)\n  0\n  >>> fizzBuzz(193)\n  0\n  >>> fizzBuzz(194)\n  0\n  >>> fizzBuzz(195)\n  0\n  >>> fizzBuzz(196)\n  0\n  >>> fizzBuzz(197)\n  0\n  >>> fizzBuzz(198)\n  0\n  >>> fizzBuzz(199)\n  0\n  >>> fizzBuzz(200)\n  0\n  >>> fizzBuzz(201)\n  0\n  >>> fizzBuzz(202)\n  0\n  >>> fizzBuzz(203)\n  0\n  >>> fizzBuzz(204)\n  0\n  >>> fizzBuzz(205)\n  0\n  >>> fizzBuzz(206)\n"}
{"task_id": "JavaScript/37", "prompt": "/*Tits function takes a list l and returns a list l'so that l' is identical to l in the odd indices, while its values in the even indices correspond to the values of the even indices of l but are sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Tits function takes a list l and returns a list l'so that l' is identical to l in the odd indices, while its values in the even indices correspond to the values of the even indices of l but are sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  return l.sort((a, b) => a % 2 === 0 && b % 2 === 0)\n}\n\n/*\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], (a, b) => a % 2 === 0 && b % 2 === 0)\n  [3, 6, 5, 4]\n  */\nconst sortOdd = (l) => {\n  return l.sort((a, b) => a % 2 === 1 && b % 2 === 1)\n}\n\n/*\n  >>> sortOdd([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  >>> sortOdd([5, 6, 3, 4], (a, b) => a % 2 === 1 && b % 2 === 1)\n  [3, 6, 5, 4]\n  */\nconst sortEvenOdd = (l) => {\n  return l.sort((a, b) => a % 2 === 0 && b % 2 === 1)\n}\n\n/*\n  >>> sortEvenOdd([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  >>> sortEvenOdd([5, 6, 3, 4], (a, b) => a % 2 === 1 && b % 2 === 1)\n  [3, 6, 5, 4]\n  */\nconst sortEvenOddOdd = (l) => {\n  return l.sort((a, b) => a % 2 === 1 && b % 2 === 0)\n}\n\n/*\n  >>> sortEvenOddOddOdd([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  >>> sortEvenOddOddOdd([5, 6, 3, 4], (a, b) => a % 2 === 0 && b % 2 === 0)\n  [3, 6, 5, 4]\n  */\nconst sortEvenOddOddOdd = (l) => {\n  return l.sort((a, b) => a % 2 === 1 && b % 2 === 1)\n}\n\n/*\n  >>> sortEvenOddOddOddOddOdd([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  >>> sortEvenOddOddOddOddOdd([5, 6, 3, 4], (a, b) => a % 2 === 0 && b % 2 === 1)\n  [3, 6, 5, 4]\n  */\nconst sortEvenOddOddOddOddOdd = (l) => {\n  return l.sort((a, b) => a % 2 === 1 && b % 2 === 1)\n}\n\n/*\n  >>> sortEvenOddOddOddOddOddOdd([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  >>> sortEvenOddOddOddOddOddOddOdd([5, 6, 3, 4], (a, b) => a % 2 === 1 && b % 2 === 1)\n  [3, 6, 5, 4]\n  */\nconst sortEvenOddOddOddOddOddOdd = (l) => {\n  return l.sort((a, b) => a % 2 === 1 && b % 2 === 1)\n}\n\n/*\n  >>> sortEvenOddOddOddOddOddOddOdd([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  >>> sortEvenOddOddOddOddOddOddOddOdd([5, 6, 3, 4], (a, b) => a % 2 === 0 && b % 2 === 0)\n  [3, 6, 5, 4]\n  */\nconst sortEvenOddOddOddOddOddOddOdd = (l) => {\n  return l.sort((a, b) => a % 2 === 1 && b % 2 === 1)\n}\n\n/*\n  >>> sortEvenOddOddOddOddOddOddOddOdd([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  >>> sortEvenOddOddOddOddOddOddOddOdd([5, 6, 3, 4], (a, b) => a % 2 === 1 && b % 2 === 1)\n  [3, 6, 5, 4]\n  */\nconst sortEvenOddOddOddOddOddOddOddOdd = (l) => {\n  return l.sort((a, b) => a % 2 === 1 && b % 2 === 1)\n}\n\n/*\n  >>> sortEvenOddOddOddOddOddOddOddOddOdd([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  >>> sortEvenOddOddOddOddOddOddOddOddOddOdd([5, 6, 3, 4], (a, b) => a % 2 === 0 && b % 2 === 1)\n  [3, 6, 5, 4]\n  */\nconst sortEvenOddOddOddOddOddOddOddOddOdd = (l) => {\n  return l.sort((a, b) => a % 2 === 1 && b % 2 === 1)\n}\n\n/*\n  >>> sortEvenOddOddOddOddOddOddOddOddOddOdd([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  >>> sortEvenOddOddOddOddOddOddOddOddOddOdd([5, 6, 3, 4], (a, b) => a % 2 === 1 && b % 2 === 1)\n  [3, 6, 5, 4]\n  */\nconst sortEvenOddOddOddOddOddOddOddOddOddOdd = (l) => {\n  return l.sort((a, b) => a % 2 === 1 && b % 2 === 1)\n}\n\n/*\n  >>> sortEvenOddOddOddOddOddOddOddOddOddOddOddOdd([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  >>> sortEvenOddOddOddOddOddOddOddOddOddOddOdd([5, 6, 3, 4], (a, b) => a % 2 === 0 && b % 2 === 1)\n  [3, 6, 5, 4]\n  */\nconst sortEvenOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOdd"}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns true if string contains only ASCII characters and is encoded with encodeCyclic function.\n  */\nconst isCyclic = (s) => {\n  return s.split('').every((c) => c.match(/[\\x00-\\x7f]/));\n}\n\n/*\n  returns true if string contains only ASCII characters and is encoded with encodeCyclic function.\n  */\nconst isCyclicUTF8 = (s) => {\n  return s.split('').every((c) => c.match(/[\\x00-\\x7f]/) && c.match(/[\\x00-\\x7F]/));\n}\n\n/*\n  returns true if string contains only ASCII characters and is encoded with encodeCyclic function.\n  */\nconst isCyclicASCII = (s) => {\n  return s.split('').every((c) => c.match(/[\\x00-\\x7f]/));\n}\n\n/*\n  returns true if string contains only ASCII characters and is encoded with encodeCyclic function.\n  */\nconst isCyclicASCIIUTF8 = (s) => {\n  return s.split('').every((c) => c.match(/[\\x00-\\x7f]/) && c.match(/[\\x00-\\x7F]/));\n}\n\n/*\n  returns true if string contains only ASCII characters and is encoded with encodeCyclic function.\n  */\nconst isCyclicASCIIASCII = (s) => {\n  return s.split('').every((c) => c.match(/[\\x00-\\x7f]/));\n}\n\n/*\n  returns true if string contains only ASCII characters and is encoded with encodeCyclic function.\n  */\nconst isCyclicASCIIASCIIUTF8 = (s) => {\n  return s.split('').every((c) => c.match(/[\\x00-\\x7f]/) && c.match(/[\\x00-\\x7F]/));\n}\n\n/*\n  returns true if string contains only ASCII characters and is encoded with encodeCyclic function.\n  */\nconst isCyclicASCIIASCIIASCII = (s) => {\n  return s.split('').every((c) => c.match(/[\\x00-\\x7f]/));\n}\n\n/*\n  returns true if string contains only ASCII characters and is encoded with encodeCyclic function.\n  */\nconst isCyclicASCIIASCIIUTF8 = (s) => {\n  return s.split('').every((c) => c.match(/[\\x00-\\x7f]/) && c.match(/[\\x00-\\x7F]/));\n}\n\n/*\n  returns true if string contains only ASCII characters and is encoded with encodeCyclic function.\n  */\nconst isCyclicASCIIASCIIASCII = (s) => {\n  return s.split('').every((c) => c.match(/[\\x00-\\x7f]/));\n}\n\n/*\n  returns true if string contains only ASCII characters and is encoded with encodeCyclic function.\n  */\nconst isCyclicASCIIASCIIUTF8 = (s) => {\n  return s.split('').every((c) => c.match(/[\\x00-\\x7f]/) && c.match(/[\\x00-\\x7F]/));\n}\n\n/*\n  returns true if string contains only ASCII characters and is encoded with encodeCyclic function.\n  */\nconst isCyclicASCIIASCIIASCII = (s) => {\n  return s.split('').every((c) => c.match(/[\\x00-\\x7f]/));\n}\n\n/*\n  returns true if string contains only ASCII characters and is encoded with encodeCyclic function.\n  */\nconst isCyclicASCIIASCIIUTF8 = (s) => {\n  return s.split('').every((c) => c.match(/[\\x00-\\x7f]/) && c.match(/[\\x00-\\x7F]/));\n}\n\n/*\n  returns true if string contains only ASCII characters and is encoded with encodeCyclic function.\n  */\nconst isCyclicASCIIASCIIASCII = (s) => {\n  return s.split('').every((c) => c.match(/[\\x00-\\x7f]/));\n}\n\n/*\n  returns true if string contains only ASCII characters and is encoded with encodeCyclic function.\n  */\nconst isCyclicASCIIASCIIUTF8 = (s) => {\n  return s.split('').every((c) => c.match(/[\\x00-\\x7f]/) && c.match(/[\\x00-\\x7F]/));\n}\n\n/*\n  returns true if string contains only ASCII characters and is encoded with encodeCyclic function.\n  */\nconst isCyclicASCIIASCIIASCIIASCII = (s) => {\n  return s.split('').every((c) => c.match(/[\\x00-\\x7f]/));\n}\n\n/*\n  returns true if string contains only ASCII characters and is encoded with encodeCyclic function.\n  */\nconst isCyclicASCIIASCIIASCIIUTF8 = (s) => {\n  return s.split('').every((c) => c.match(/[\\x00-\\x7f]/) && c.match(/[\\x00-\\x7F]/));\n}\n\n/*\n  returns true if string contains only ASCII characters and is encoded with encodeCyclic function.\n  */\nconst isCyclicASCIIASCIIASCIIASCII = (s) => {\n  return s.split('').every((c) => c.match(/[\\x00-\\x7f]/));\n}\n\n/*\n  returns true if string contains only ASCII characters and is encoded with encodeCyclic function.\n  */\nconst isCyclicASCIIASCIIASCIIUTF8 = (s) => {\n  return s.split('').every((c) => c.match(/[\\x00-\\x7f]/) && c.match(/[\\x00-\\x7F]/));\n}\n\n/*\n  returns true if string contains only ASCII characters and is encoded with encodeCyclic function.\n  */\nconst isCyclicASCIIASCIIASCIIASCII = (s) => {\n  return s.split('').every((c) => c.match(/[\\x00-\\x7f]/));\n}\n\n/*\n  returns true if string contains only ASCII characters and is encoded with encodeCyclic function.\n  */\nconst isCyclicASCIIASCIIASCIIUTF8 = (s) => {\n  return s.split('').every((c) => c.match(/[\\x00-\\x7f]/) && c.match(/[\\x00-\\x7F]/));\n}\n\n/*\n  returns true if string contains only ASCII characters and is encoded with encodeCyclic function.\n  */\nconst isCyclicASCIIASCIIASCIIASCII = (s) => {\n  return s.split('').every((c) => c.match(/[\\x00-\\x7f]/));\n}\n\n/*\n  returns true if string contains only ASCII characters and is encoded with encodeCyclic function.\n  */\nconst isCyclicASCIIASCIIASCIIUTF8 = (s) => {\n  return s.split('').every((c) => c.match(/[\\x00-\\x7f]/) && c.match(/[\\x00-\\x7F]/));\n}\n\n/*\n  returns true if string contains only ASCII characters and is encoded with encodeCyclic function.\n  */\nconst isCyclicASCIIASCIIASCIIASCII = (s) => {\n  return s.split('').every((c) => c.match(/[\\x00-\\x7f]/));\n}\n\n/*\n  returns "}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns the n-th number, which is a Fibonacci number, and also a prime number.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  primeFib returns the n-th number, which is a Fibonacci number, and also a prime number.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  let prime = 1;\n  let i = 2;\n  while (prime*prime <= n) {\n    prime = prime*prime;\n    i++;\n  }\n  return prime;\n};\n\n/**\n * A function to generate random numbers between a min and max value.\n * \n * >>> randomRange(10, 100)\n * [10, 100]\n * \n * >>> randomRange(10, 100, 2)\n * [10, 100]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, 100, 3]\n * \n * >>> randomRange(10, 100, 2, 3)\n * [10, "}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes a list of integers as input. It returns true if there are three unique elements in the list that add up to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  triplesSumToZero takes a list of integers as input. It returns true if there are three unique elements in the list that add up to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0) continue;\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/*\n  triplesSumToOne takes a list of integers as input. It returns true if there are three unique elements in the list that add up to one, and false otherwise.\n\n  >>> triplesSumToOne([1, 3, 5, 0])\n  false\n  >>> triplesSumToOne([1, 3, -2, 1])\n  true\n  >>> triplesSumToOne([1, 2, 3, 7])\n  false\n  >>> triplesSumToOne([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToOne([1])\n  false\n  */\nconst triplesSumToOne = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 1) continue;\n    sum += l[i];\n  }\n  return sum === 1;\n};\n\n/*\n  triplesSumToTwo takes a list of integers as input. It returns true if there are three unique elements in the list that add up to two, and false otherwise.\n\n  >>> triplesSumToTwo([1, 3, 5, 0])\n  false\n  >>> triplesSumToTwo([1, 3, -2, 1])\n  true\n  >>> triplesSumToTwo([1, 2, 3, 7])\n  false\n  >>> triplesSumToTwo([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToTwo([1])\n  false\n  */\nconst triplesSumToTwo = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 2) continue;\n    sum += l[i];\n  }\n  return sum === 2;\n};\n\n/*\n  triplesSumToThree takes a list of integers as input. It returns true if there are three unique elements in the list that add up to three, and false otherwise.\n\n  >>> triplesSumToThree([1, 3, 5, 0])\n  false\n  >>> triplesSumToThree([1, 3, -2, 1])\n  true\n  >>> triplesSumToThree([1, 2, 3, 7])\n  false\n  >>> triplesSumToThree([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToThree([1])\n  false\n  */\nconst triplesSumToThree = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 3) continue;\n    sum += l[i];\n  }\n  return sum === 3;\n};\n\n/*\n  triplesSumToFour takes a list of integers as input. It returns true if there are three unique elements in the list that add up to four, and false otherwise.\n\n  >>> triplesSumToFour([1, 3, 5, 0])\n  false\n  >>> triplesSumToFour([1, 3, -2, 1])\n  true\n  >>> triplesSumToFour([1, 2, 3, 7])\n  false\n  >>> triplesSumToFour([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToFour([1])\n  false\n  */\nconst triplesSumToFour = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 4) continue;\n    sum += l[i];\n  }\n  return sum === 4;\n};\n\n/*\n  triplesSumToFive takes a list of integers as input. It returns true if there are three unique elements in the list that add up to five, and false otherwise.\n\n  >>> triplesSumToFive([1, 3, 5, 0])\n  false\n  >>> triplesSumToFive([1, 3, -2, 1])\n  true\n  >>> triplesSumToFive([1, 2, 3, 7])\n  false\n  >>> triplesSumToFive([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToFive([1])\n  false\n  */\nconst triplesSumToFive = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 5) continue;\n    sum += l[i];\n  }\n  return sum === 5;\n};\n\n/*\n  triplesSumToSix takes a list of integers as input. It returns true if there are three unique elements in the list that add up to six, and false otherwise.\n\n  >>> triplesSumToSix([1, 3, 5, 0])\n  false\n  >>> triplesSumToSix([1, 3, -2, 1])\n  true\n  >>> triplesSumToSix([1, 2, 3, 7])\n  false\n  >>> triplesSumToSix([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToSix([1])\n  false\n  */\nconst triplesSumToSix = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 6) continue;\n    sum += l[i];\n  }\n  return sum === 6;\n};\n\n/*\n  triplesSumToSeven takes a list of integers as input. It returns true if there are three unique elements in the list that add up to seven, and false otherwise.\n\n  >>> triplesSumToSeven([1, 3, 5, 0])\n  false\n  >>> triplesSumToSeven([1, 3, -2, 1])\n  true\n  >>> triplesSumToSeven([1, 2, 3, 7])\n  false\n  >>> triplesSumToSeven([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToSeven([1])\n  false\n  */\nconst triplesSumToSeven = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 7) continue;\n    sum += l[i];\n  }\n  return sum === 7;\n};\n\n/*\n  triplesSumToEight takes a list of integers as input. It returns true if there are three unique elements in the list that add up to eight, and false otherwise.\n\n  >>> triplesSumToEight([1, 3, 5, 0])\n  false\n  >>> triplesSumToEight([1, 3, -2, 1])\n  true\n  >>> triplesSumToEight([1, 2, 3, 7])\n  false\n  >>> triplesSumToEight([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToEight([1])\n  false\n  */\nconst triplesSumToEight = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 8) continue;\n    sum += l[i];\n  }\n  return sum === 8;\n};\n\n/*\n  triplesSumToNine takes a list of integers as input. It returns true if there are three unique elements in the list that add up to nine, and false otherwise.\n\n  >>> triplesSumToNine([1, 3, 5, 0])\n  false\n  >>> triplesSumToNine([1, 3, -2, 1])\n  true\n  >>> triplesSumToNine([1, 2, 3, 7])\n  false\n  >>> triplesSumToNine([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToNine([1])\n  false\n  */\nconst triplesSumToNine = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 9) continue;\n    sum += l[i];\n  }\n  return sum === 9;\n};\n\n/*\n  triplesSumToTen takes a list of integers as input. It returns true if there are three unique "}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n  let collisions = 0;\n  for (let i = 0; i < n; i++) {\n    let car1 = cars[i];\n    let car2 = cars[(i + 1) % n];\n    if (car1.isSturdy() && car2.isSturdy()) {\n      collisions++;\n    }\n  }\n  return collisions;\n};\n\n/*\n  Given a car, determine if it's a sturdy car.\n  A sturdy car has a very strong collision rate (collision rate is defined as\n  the ratio of collision time to the number of collisions).\n  A sturdy car has a very weak collision rate (collision rate is defined as\n  the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast collision rate (collision rate is defined as\n  the ratio of collision time to the number of collisions).\n  A sturdy car has a very slow collision rate (collision rate is defined as\n  the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is\n  defined as the ratio of collision time to the number of collisions).\n  A sturdy car has a very fast and slow collision rate (collision rate is"}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements increased by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return list with elements increased by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    res.push(l[i] + 1)\n  }\n  return res\n}\n\n/*Return list with elements decreased by 1.\n  >>> decrList([1, 2, 3])\n  [2, 3, 4]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decrList = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    res.push(l[i] - 1)\n  }\n  return res\n}\n\n/*Return list with elements equal to 0.\n  >>> zeroList([1, 2, 3])\n  [0, 0, 0]\n  >>> zeroList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 0, 0]\n  */\nconst zeroList = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    res.push(0)\n  }\n  return res\n}\n\n/*Return list with elements equal to 1.\n  >>> oneList([1, 2, 3])\n  [1, 1, 1]\n  >>> oneList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [1, 1, 1]\n  */\nconst oneList = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    res.push(1)\n  }\n  return res\n}\n\n/*Return list with elements equal to -1.\n  >>> negOneList([1, 2, 3])\n  [-1, 1, -1]\n  >>> negOneList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [-1, 1, -1]\n  */\nconst negOneList = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    res.push(-1)\n  }\n  return res\n}\n\n/*Return list with elements equal to -1.\n  >>> negOneList([1, 2, 3])\n  [-1, 1, -1]\n  >>> negOneList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [-1, 1, -1]\n  */\nconst negOneList = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    res.push(-1)\n  }\n  return res\n}\n\n/*Return list with elements equal to -1.\n  >>> negOneList([1, 2, 3])\n  [-1, 1, -1]\n  >>> negOneList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [-1, 1, -1]\n  */\nconst negOneList = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    res.push(-1)\n  }\n  return res\n}\n\n/*Return list with elements equal to -1.\n  >>> negOneList([1, 2, 3])\n  [-1, 1, -1]\n  >>> negOneList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [-1, 1, -1]\n  */\nconst negOneList = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    res.push(-1)\n  }\n  return res\n}\n\n/*Return list with elements equal to -1.\n  >>> negOneList([1, 2, 3])\n  [-1, 1, -1]\n  >>> negOneList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [-1, 1, -1]\n  */\nconst negOneList = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    res.push(-1)\n  }\n  return res\n}\n\n/*Return list with elements equal to -1.\n  >>> negOneList([1, 2, 3])\n  [-1, 1, -1]\n  >>> negOneList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [-1, 1, -1]\n  */\nconst negOneList = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    res.push(-1)\n  }\n  return res\n}\n\n/*Return list with elements equal to -1.\n  >>> negOneList([1, 2, 3])\n  [-1, 1, -1]\n  >>> negOneList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [-1, 1, -1]\n  */\nconst negOneList = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    res.push(-1)\n  }\n  return res\n}\n\n/*Return list with elements equal to -1.\n  >>> negOneList([1, 2, 3])\n  [-1, 1, -1]\n  >>> negOneList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [-1, 1, -1]\n  */\nconst negOneList = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    res.push(-1)\n  }\n  return res\n}\n\n/*Return list with elements equal to -1.\n  >>> negOneList([1, 2, 3])\n  [-1, 1, -1]\n  >>> negOneList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [-1, 1, -1]\n  */\nconst negOneList = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    res.push(-1)\n  }\n  return res\n}\n\n/*Return list with elements equal to -1.\n  >>> negOneList([1, 2, 3])\n  [-1, 1, -1]\n  >>> negOneList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [-1, 1, -1]\n  */\nconst negOneList = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    res.push(-1)\n  }\n  return res\n}\n\n/*Return list with elements equal to -1.\n  >>> negOneList([1, 2, 3])\n  [-1, 1, -1]\n  >>> negOneList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [-1, 1, -1]\n  */\nconst negOneList = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    res.push(-1)\n  }\n  return res\n}\n\n/*Return list with elements equal to -1.\n  >>> negOneList([1, 2, 3])\n  [-1, 1, -1]\n  >>> negOneList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [-1, 1, -1]\n  */\nconst negOneList = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    res.push(-1)\n  }\n  return res\n}\n\n/*Return list with elements equal to -1.\n  >>> negOneList([1, 2, 3])\n  [-1, 1, -1]\n  >>> negOneList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [-1, 1, -1]\n  */\nconst negOneList = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    res.push(-1)\n  }\n  return res\n}\n\n/*Return list with elements equal to -1.\n  >>> negOneList([1, 2, 3])\n  [-1, 1, -1]\n  >>> negOneList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [-1, 1, -1]\n  */\nconst negOneList = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    res.push(-1)\n  }\n  return res\n}\n\n/*Return list with elements equal to -1.\n  >>> negOneList([1, 2, 3])\n  [-1, 1, -1]\n  >>> negOneList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [-1, 1, -1]\n  */\nconst negOneList = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    res.push(-1)\n  }\n  return res\n}\n\n/*Return list with elements equal to -1.\n  >>> negOneList([1, 2, 3])\n  [-1, 1, -1]\n  >>> negOneList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [-1, 1, -1]\n  */\nconst negOneList = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    res.push(-1)\n  }\n  return res\n}\n\n/*Return list with elements equal to -1.\n  >>> negOneList([1, 2, 3])\n  [-1, 1, -1]\n  >>> negOneList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [-1, 1, -1]\n  */\nconst negOneList = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    res.push(-1)\n  }\n  return res\n}"}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes a list of integers as input. It returns true if there are two different elements in the list that add up to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  pairsSumToZero takes a list of integers as input. It returns true if there are two different elements in the list that add up to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n  A function to check if a number is prime or not.\n  >>> isPrime(8)\n  true\n  >>> isPrime(13)\n  false\n  >>> isPrime(17)\n  false\n  >>> isPrime(20)\n  false\n  >>> isPrime(23)\n  true\n  >>> isPrime(29)\n  false\n  >>> isPrime(30)\n  false\n  >>> isPrime(32)\n  false\n  >>> isPrime(33)\n  false\n  >>> isPrime(34)\n  false\n  >>> isPrime(35)\n  false\n  >>> isPrime(36)\n  false\n  >>> isPrime(37)\n  false\n  >>> isPrime(38)\n  false\n  >>> isPrime(39)\n  false\n  >>> isPrime(40)\n  false\n  >>> isPrime(41)\n  false\n  >>> isPrime(42)\n  false\n  >>> isPrime(43)\n  false\n  >>> isPrime(44)\n  false\n  >>> isPrime(45)\n  false\n  >>> isPrime(46)\n  false\n  >>> isPrime(47)\n  false\n  >>> isPrime(48)\n  false\n  >>> isPrime(49)\n  false\n  >>> isPrime(50)\n  false\n  >>> isPrime(51)\n  false\n  >>> isPrime(52)\n  false\n  >>> isPrime(53)\n  false\n  >>> isPrime(54)\n  false\n  >>> isPrime(55)\n  false\n  >>> isPrime(56)\n  false\n  >>> isPrime(57)\n  false\n  >>> isPrime(58)\n  false\n  >>> isPrime(59)\n  false\n  >>> isPrime(60)\n  false\n  >>> isPrime(61)\n  false\n  >>> isPrime(62)\n  false\n  >>> isPrime(63)\n  false\n  >>> isPrime(64)\n  false\n  >>> isPrime(65)\n  false\n  >>> isPrime(66)\n  false\n  >>> isPrime(67)\n  false\n  >>> isPrime(68)\n  false\n  >>> isPrime(69)\n  false\n  >>> isPrime(70)\n  false\n  >>> isPrime(71)\n  false\n  >>> isPrime(72)\n  false\n  >>> isPrime(73)\n  false\n  >>> isPrime(74)\n  false\n  >>> isPrime(75)\n  false\n  >>> isPrime(76)\n  false\n  >>> isPrime(77)\n  false\n  >>> isPrime(78)\n  false\n  >>> isPrime(79)\n  false\n  >>> isPrime(80)\n  false\n  >>> isPrime(81)\n  false\n  >>> isPrime(82)\n  false\n  >>> isPrime(83)\n  false\n  >>> isPrime(84)\n  false\n  >>> isPrime(85)\n  false\n  >>> isPrime(86)\n  false\n  >>> isPrime(87)\n  false\n  >>> isPrime(88)\n  false\n  >>> isPrime(89)\n  false\n  >>> isPrime(90)\n  false\n  >>> isPrime(91)\n  false\n  >>> isPrime(92)\n  false\n  >>> isPrime(93)\n  false\n  >>> isPrime(94)\n  false\n  >>> isPrime(95)\n  false\n  >>> isPrime(96)\n  false\n  >>> isPrime(97)\n  false\n  >>> isPrime(98)\n  false\n  >>> isPrime(99)\n  false\n  >>> isPrime(100)\n  false\n  >>> isPrime(101)\n  false\n  >>> isPrime(102)\n  false\n  >>> isPrime(103)\n  false\n  >>> isPrime(104)\n  false\n  >>> isPrime(105)\n  false\n  >>> isPrime(106)\n  false\n  >>> isPrime(107)\n  false\n  >>> isPrime(108)\n  false\n  >>> isPrime(109)\n  false\n  >>> isPrime(110)\n  false\n  >>> isPrime(111)\n  false\n  >>> isPrime(112)\n  false\n  >>> isPrime(113)\n  false\n  >>> isPrime(114)\n  false\n  >>> isPrime(115)\n  false\n  >>> isPrime(116)\n  false\n  >>> isPrime(117)\n  false\n  >>> isPrime(118)\n  false\n  >>> isPrime(119)\n  false\n  >>> isPrime(120)\n  false\n  >>> isPrime(121)\n  false\n  >>> isPrime(122)\n  false\n  >>> isPrime(123)\n  false\n  >>> isPrime(124)\n  false\n  >>> isPrime(125)\n  false\n  >>> isPrime(126)\n  false\n  >>> isPrime(127)\n  false\n  >>> isPrime(128)\n  false\n  >>> isPrime(129)\n  false\n  >>> isPrime(130)\n  false\n  >>> isPrime(131)\n  false\n  >>> isPrime(132)\n  false\n  >>> isPrime(133)\n  false\n  >>> isPrime(134)\n  false\n  >>> isPrime(135)\n  false\n  >>> isPrime(136)\n  false\n  >>> isPrime(137)\n  false\n  >>> isPrime(138)\n  false\n  >>> isPrime(139)\n  false\n  >>> isPrime(140)\n  false\n  >>> isPrime(141)\n  false\n  >>> isPri"}
{"task_id": "JavaScript/44", "prompt": "/*Cdepend numerical base of the input number x to the base. Returns the string representation after the conversion. Base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Cdepend numerical base of the input number x to the base. Returns the string representation after the conversion. Base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  if (base < 10) {\n    return String(Math.pow(10, base))\n     .toString(String(Math.pow(10, base))).padStart(base, '0')\n  }\n  return String(Math.pow(10, base))\n   .toString(String(Math.pow(10, base))).padStart(base, '0')\n}\n\n/*\n  Converts a string to a number in base base. Returns NaN if the string is not a number.\n  >>> toNumber(\"\")\n  NaN\n  >>> toNumber(\"1\")\n  1\n  >>> toNumber(\"1.1\")\n  1.1\n  >>> toNumber(\"1e1\")\n  10000000000000000\n  >>> toNumber(\"1e2\")\n  100000000000000\n  >>> toNumber(\"1e3\")\n  10000000000000\n  >>> toNumber(\"1e4\")\n  1000000000000\n  >>> toNumber(\"1e5\")\n  100000000000\n  >>> toNumber(\"1e6\")\n  10000000000\n  >>> toNumber(\"1e7\")\n  1000000000\n  >>> toNumber(\"1e8\")\n  100000000\n  >>> toNumber(\"1e9\")\n  10000000\n  >>> toNumber(\"1e10\")\n  100000000\n  >>> toNumber(\"1e11\")\n  10000000\n  >>> toNumber(\"1e12\")\n  100000000\n  >>> toNumber(\"1e13\")\n  10000000\n  >>> toNumber(\"1e14\")\n  100000000\n  >>> toNumber(\"1e15\")\n  10000000\n  >>> toNumber(\"1e16\")\n  100000000\n  >>> toNumber(\"1e17\")\n  10000000\n  >>> toNumber(\"1e18\")\n  100000000\n  >>> toNumber(\"1e19\")\n  10000000\n  >>> toNumber(\"1e20\")\n  100000000\n  >>> toNumber(\"1e21\")\n  10000000\n  >>> toNumber(\"1e22\")\n  100000000\n  >>> toNumber(\"1e23\")\n  10000000\n  >>> toNumber(\"1e24\")\n  100000000\n  >>> toNumber(\"1e25\")\n  10000000\n  >>> toNumber(\"1e26\")\n  100000000\n  >>> toNumber(\"1e27\")\n  10000000\n  >>> toNumber(\"1e28\")\n  100000000\n  >>> toNumber(\"1e29\")\n  10000000\n  >>> toNumber(\"1e30\")\n  100000000\n  >>> toNumber(\"1e31\")\n  10000000\n  >>> toNumber(\"1e32\")\n  100000000\n  >>> toNumber(\"1e33\")\n  10000000\n  >>> toNumber(\"1e34\")\n  100000000\n  >>> toNumber(\"1e35\")\n  10000000\n  >>> toNumber(\"1e36\")\n  100000000\n  >>> toNumber(\"1e37\")\n  10000000\n  >>> toNumber(\"1e38\")\n  100000000\n  >>> toNumber(\"1e39\")\n  10000000\n  >>> toNumber(\"1e40\")\n  100000000\n  >>> toNumber(\"1e41\")\n  10000000\n  >>> toNumber(\"1e42\")\n  100000000\n  >>> toNumber(\"1e43\")\n  10000000\n  >>> toNumber(\"1e44\")\n  100000000\n  >>> toNumber(\"1e45\")\n  10000000\n  >>> toNumber(\"1e46\")\n  100000000\n  >>> toNumber(\"1e47\")\n  10000000\n  >>> toNumber(\"1e48\")\n  100000000\n  >>> toNumber(\"1e49\")\n  10000000\n  >>> toNumber(\"1e50\")\n  100000000\n  >>> toNumber(\"1e51\")\n  10000000\n  >>> toNumber(\"1e52\")\n  100000000\n  >>> toNumber(\"1e53\")\n  10000000\n  >>> toNumber(\"1e54\")\n  100000000\n  >>> toNumber(\"1e55\")\n  10000000\n  >>> toNumber(\"1e56\")\n  100000000\n  >>> toNumber(\"1e57\")\n  10000000\n  >>> toNumber(\"1e58\")\n  100000000\n  >>> toNumber(\"1e59\")\n  10000000\n  >>> toNumber(\"1e60\")\n  100000000\n  >>> toNumber(\"1e61\")\n  10000000\n  >>> toNumber(\"1e62\")\n  100000000\n  >>> toNumber(\"1e63\")\n  10000000\n  >>> toNumber(\"1e64\")\n  100000000\n  >>> toNumber(\"1e65\")\n  10000000\n  >>> toNumber(\"1e66\")\n  100000000\n  >>> toNumber(\"1e67\")\n  10000000\n  >>> toNumber(\"1e68\")\n  100000000\n  >>> toNumber(\"1e69\")\n  10000000\n  >>> toNumber(\"1e70\")\n  100000000\n  >>> toNumber(\"1e71\")\n  10000000\n  >>> toNumber(\"1e72\")\n  100000000\n  >>> toNumber(\"1e73\")\n  10000000\n  >>> toNumber(\"1e74\")\n  100000000\n  >>> toNumber(\"1e75\")\n  10000000\n  >>> toNumber(\"1e76\")\n  100000000\n  >>> toNumber(\"1e77\")\n  10000000\n  >>> toNumber(\"1e78\")\n  100000000\n  >>> toNumber(\"1e79\")\n  10000000\n  >>> toNumber(\"1e80\")\n  100000000\n  >>> toNumber(\"1e81\")\n  10000000\n  >>> toNumber(\"1e82\")\n  100000000\n  >>> toNumber(\"1e83\")\n  10000000\n  >>> toNumber(\"1e84\")\n  100000000\n  >>> toNumber(\"1e85\")\n  10000000\n  >>> toNumber(\"1e86\")\n  100000000\n  >>> toNumber(\"1e87\")\n  10000000\n  >>> toNumber(\"1e88\")\n  100000000\n  >>> toNumber(\"1e89\")\n  10000000\n  >>> toNumber(\"1e90\")\n  100000000\n  >>> toNumber(\"1e91\")\n  10000000\n  >>> toNumber(\"1e92\")\n  100000000\n  >>> toNumber(\"1e93\")\n  10000000\n  >>> toNumber(\"1e94\")\n  100000000\n  >>> toNumber(\"1e95\")\n  10000000\n  >>> toNumber(\"1e96\")\n  100000000\n  >>> toNumber(\"1e97\")\n  10000000\n  >>> toNumber(\"1e98\")\n  100000000\n  >>> toNumber(\"1e99\")\n  10000000\n  >>> toNumber(\"1e100\")\n  100000000\n  >>> toNumber(\"1e101\")\n  10000000\n  >>> toNumber(\"1e102\")\n  100000000\n  >>> toNumber(\"1e103\")\n  10000000\n  >>> toNumber(\"1e104\")\n  100000000\n  >>> toNumber(\"1e105\")\n"}
{"task_id": "JavaScript/45", "prompt": "/*GThe length of one side is the same and the return face is high for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*GThe length of one side is the same and the return face is high for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const ah = h / 2;\n  const ab = a - ah;\n  const ac = a * h;\n  const ach = ac * h;\n  const aca = ac * a;\n  const ach = ac * h;\n  const aca = ac * a;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah;\n  const aca = ac * ah;\n  const ach = ac * ah"}
{"task_id": "JavaScript/46", "prompt": "/*TThe Fib4 sequence is a sequence similar to the Fibbonacci sequence, which is defined as: fib4 (0) - > 0 fib4 (1) - > 0 fib4 (2) - > 2 fib4 (3) - > 0 fib4 (n-1) - > fib4 (n-2) + fib4 (n-3) + fib4 (n-4).\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*TThe Fib4 sequence is a sequence similar to the Fibbonacci sequence, which is defined as: fib4 (0) - > 0 fib4 (1) - > 0 fib4 (2) - > 2 fib4 (3) - > 0 fib4 (n-1) - > fib4 (n-2) + fib4 (n-3) + fib4 (n-4).\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  let fib = 0;\n  let fib2 = 1;\n  let fib3 = 1;\n  let fib4 = 1;\n  let fib5 = 1;\n  let fib6 = 1;\n  let fib7 = 1;\n\n  for (let i = 1; i <= n; i++) {\n    if (i === 1) {\n      fib += 1;\n    } else if (i === 2) {\n      fib += fib2;\n    } else if (i === 3) {\n      fib += fib3;\n    } else if (i === 4) {\n      fib += fib4;\n    } else if (i === 5) {\n      fib += fib5;\n    } else if (i === 6) {\n      fib += fib6;\n    } else if (i === 7) {\n      fib += fib7;\n    } else {\n      fib += fib2;\n      fib += fib3;\n      fib += fib4;\n      fib += fib5;\n      fib += fib6;\n      fib += fib7;\n    }\n  }\n\n  return fib;\n};\n\n/*\n  >>> fib5(10)\n  5\n  >>> fib5(20)\n  15\n  >>> fib5(30)\n  55\n  >>> fib5(50)\n  135\n  >>> fib5(100)\n  225\n  >>> fib5(1000)\n  425\n  >>> fib5(10000)\n  975\n  >>> fib5(100000)\n  22505\n  >>> fib5(1000000)\n  42505\n  >>> fib5(10000000)\n  975000\n  >>> fib5(100000000)\n  22505000\n  >>> fib5(1000000000)\n  975000000\n  >>> fib5(10000000000)\n  22505000000\n  >>> fib5(100000000000)\n  97500000000\n  >>> fib5(1000000000000)\n  2250500000000\n  >>> fib5(10000000000000)\n  9750000000000\n  >>> fib5(100000000000000)\n  225050000000000\n  >>> fib5(1000000000000000)\n  975000000000000\n  >>> fib5(10000000000000000)\n  22505000000000000\n  >>> fib5(100000000000000000)\n  9750000000000000\n  >>> fib5(1000000000000000001)\n  225050000000000000\n  >>> fib5(1000000000000000000)\n  2250500000000000000\n  >>> fib5(10000000000000000000)\n  975000000000000000\n  >>> fib5(100000000000000000000)\n  22505000000000000000\n  >>> fib5(1000000000000000000000)\n  97500000000000000\n  >>> fib5(10000000000000000000000)\n  2250500000000000000\n  >>> fib5(100000000000000000000000)\n  975000000000000000\n  >>> fib5(1000000000000000000000000)\n  22505000000000000000\n  >>> fib5(10000000000000000000000000)\n  975000000000000000\n  >>> fib5(100000000000000000000000001)\n  22505000000000000000\n  >>> fib5(100000000000000000000000000)\n  22505000000000000000\n  >>> fib5(1000000000000000000000000000)\n  975000000000000000\n  >>> fib5(10000000000000000000000000000)\n  22505000000000000000\n  >>> fib5(100000000000000000000000000000)\n  975000000000000000\n  >>> fib5(1000000000000000000000000000000)\n  22505000000000000000\n  >>> fib5(10000000000000000000000000000000)\n  975000000000000000\n  >>> fib5(100000000000000000000000000000000)\n  22505000000000000000\n  >>> fib5(1000000000000000000000000000000000)\n  975000000000000000\n  >>> fib5(10000000000000000000000000000000001)\n  22505000000000000000\n  >>> fib5(10000000000000000000000000000000000)\n  22505000000000000000\n  >>> fib5(100000000000000000000000000000000000)\n  975000000000000000\n  >>> fib5(1000000000000000000000000000000000000)\n  22505000000000000000\n  >>> fib5(10000000000000000000000000000000000000)\n  975000000000000000\n  >>> fib5(100000000000000000000000000000000000000)\n  22505000000000000000\n  >>> fib5(1000000000000000000000000000000000000000)\n  975000000000000000\n  >>> fib5(10000000000000000000000000000000000000000)\n  22505000000000000000\n  >>> fib5(100000000000000000000000000000000000000000)\n  975000000000000000\n  >>> fib5(1000000000000000000000000000000000000000001)\n  22505000000000000000\n  >>> fib5(1000000000000000000000000000000000000000000)\n  22505000000000000000\n  >>> fib5(10000000000000000000000000000000000000000000)\n  975000000000000000\n  >>> fib5(100000000000000000000000000000000000000000000)\n  22505000000000000000\n  >>> fib5(1000000000000000000000000000000000000000000000)\n  975000000000000000\n  >>> fib5(10000000000000000000000000000000000000000000000)\n  22505000000000000000\n  >>> fib5(100000000000000000000000000000000000000000000000)\n  975000000000000000\n  >>> fib5(1000000000000000000000000000000000000000000000000)\n  22505000000000000000\n  >>> fib5(10000000000000000000000000000000000000000000000000)\n  975000000000000000\n  >>> fib5(100000000000000000000000000000000000000000000000001)\n  22505000000000000000\n  >>> fib5(100000000000000000000000000000000000000000000000000)\n  22505000000000000000\n  >>> fib5(1000000000000000000000000000000000000000000000000000)\n  975000000000000000\n  >>> fib5(1000000000000000000000000000000000000000000000000)\n  22505000000000000000\n  >>> fib5(10000000000000000000000000000000000000000000000000)\n  975000000000000000\n  >>> fib5(100000000000000000000000000000000000000000000000001)\n  22505000000000000000\n  >>> fib5(100000000000000000000000000000000000000000000000000)\n  22505000000000000000\n  >>> fib5(1000000000000000000000000000000000000000000000000000)\n  975000000000000000\n  >>> fib5(1000000000000000000000000000000000000000000000000)\n  22505000000000000000\n  >>> fib5(10000000000000000000000000000000000000000000000000)\n  975000000000000000\n  >>> fib5(100000000000000000000000000000000000000000000000001)\n  22505000000000000000\n  >>> fib5(100000000000000000000000000000000000000000000000000)\n  22505000000000000000\n  >>> fib5(1000000000000000000000000000000000000000000000000000)\n  975000000000000000\n  >>> fib5(1000000000000000000000000000000000000000000000000)\n  22505000000000000000\n  >>> fib5(10000000000000000000000000000000000000000000000000)\n  975000000000000000\n  >>> fib5(100000000000000000000000000000000000000000000000001)\n  22505000000000000000\n  >>> fib5(100000000000000000000000000000000000000000000000000)\n  22505000000000000000\n  >>> fib5(1000000000000000000000000000000000000000000000000000)\n  975000000000000000\n  >>> fib5(1000000000000000000000000000000000000000000000000)\n  22505000000000000000\n  >>> fib5(10000000000000000000000000000000000000000000000000)\n  975000000000000000\n  >>> fib5(100000000000000000000000000000000000000000000000001)\n  22505000000000000000\n  >>> fib5(100000000000000000000000000000000000000000000000000)\n  22505000000000000000\n  >>> fib5(1000000000000000000000000000000000000000000000000000)\n  975000000000000000\n  >>> fib5(1000000000000000000000000000000000000000000000000)\n  22505000000000000000\n  >>> fib5(10000000000000000000000000000000000000000000000000)"}
{"task_id": "JavaScript/47", "prompt": "/*RThe median number of items in the list.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*RThe median number of items in the list.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n / 2;\n  let i = Math.floor(n);\n  let j = (n - i) / 2;\n  let sum = 0;\n  while (i < j) {\n    sum += l[i];\n    i++;\n    j--;\n  }\n  return sum / 2;\n};\n\n/**\n * Returns the median of the given list of numbers.\n *\n * >>> median([3, 1, 2, 4, 5])\n * 3\n * >>> median([-10, 4, 6, 1000, 10, 20])\n * 8.0\n */\nconst medianOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n / 2;\n  let i = Math.floor(n);\n  let j = (n - i) / 2;\n  let sum = 0;\n  while (i < j) {\n    sum += l[i];\n    i++;\n    j--;\n  }\n  return sum / 2;\n};\n\n/**\n * Returns the median of the given list of numbers.\n *\n * >>> medianOf([3, 1, 2, 4, 5])\n * 3\n * >>> medianOf([-10, 4, 6, 1000, 10, 20])\n * 8.0\n */\nconst medianOfList = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n / 2;\n  let i = Math.floor(n);\n  let j = (n - i) / 2;\n  let sum = 0;\n  while (i < j) {\n    sum += l[i];\n    i++;\n    j--;\n  }\n  return sum / 2;\n};\n\n/**\n * Returns the median of the given list of numbers.\n *\n * >>> medianOfList([3, 1, 2, 4, 5])\n * 3\n * >>> medianOfList([-10, 4, 6, 1000, 10, 20])\n * 8.0\n */\nconst medianOfListOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n / 2;\n  let i = Math.floor(n);\n  let j = (n - i) / 2;\n  let sum = 0;\n  while (i < j) {\n    sum += l[i];\n    i++;\n    j--;\n  }\n  return sum / 2;\n};\n\n/**\n * Returns the median of the given list of numbers.\n *\n * >>> medianOfListOf([3, 1, 2, 4, 5])\n * 3\n * >>> medianOfListOf([-10, 4, 6, 1000, 10, 20])\n * 8.0\n */\nconst medianOfListOfOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n / 2;\n  let i = Math.floor(n);\n  let j = (n - i) / 2;\n  let sum = 0;\n  while (i < j) {\n    sum += l[i];\n    i++;\n    j--;\n  }\n  return sum / 2;\n};\n\n/**\n * Returns the median of the given list of numbers.\n *\n * >>> medianOfListOfOf([3, 1, 2, 4, 5])\n * 3\n * >>> medianOfListOfOf([-10, 4, 6, 1000, 10, 20])\n * 8.0\n */\nconst medianOfListOfOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n / 2;\n  let i = Math.floor(n);\n  let j = (n - i) / 2;\n  let sum = 0;\n  while (i < j) {\n    sum += l[i];\n    i++;\n    j--;\n  }\n  return sum / 2;\n};\n\n/**\n * Returns the median of the given list of numbers.\n *\n * >>> medianOfListOfOfOf([3, 1, 2, 4, 5])\n * 3\n * >>> medianOfListOfOfOf([-10, 4, 6, 1000, 10, 20])\n * 8.0\n */\nconst medianOfListOfOfOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n / 2;\n  let i = Math.floor(n);\n  let j = (n - i) / 2;\n  let sum = 0;\n  while (i < j) {\n    sum += l[i];\n    i++;\n    j--;\n  }\n  return sum / 2;\n};\n\n/**\n * Returns the median of the given list of numbers.\n *\n * >>> medianOfListOfOfOf([3, 1, 2, 4, 5])\n * 3\n * >>> medianOfListOfOfOf([-10, 4, 6, 1000, 10, 20])\n * 8.0\n */\nconst medianOfListOfOfOfOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n / 2;\n  let i = Math.floor(n);\n  let j = (n - i) / 2;\n  let sum = 0;\n  while (i < j) {\n    sum += l[i];\n    i++;\n    j--;\n  }\n  return sum / 2;\n};\n\n/**\n * Returns the median of the given list of numbers.\n *\n * >>> medianOfListOfOfOfOf([3, 1, 2, 4, 5])\n * 3\n * >>> medianOfListOfOfOfOf([-10, 4, 6, 1000, 10, 20])\n * 8.0\n */\nconst medianOfListOfOfOfOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n / 2;\n  let i = Math.floor(n);\n  let j = (n - i) / 2;\n  let sum = 0;\n  while (i < j) {\n    sum += l[i];\n    i++;\n    j--;\n  }\n  return sum / 2;\n};\n\n/**\n * Returns the median of the given list of numbers.\n *\n * >>> medianOfListOfOfOfOf([3, 1, 2, 4, 5])\n * 3\n * >>> medianOfListOfOfOfOf([-10, 4, 6, 1000, 10, 20])\n * 8.0\n */\nconst medianOfListOfOfOfOfOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n / 2;\n  let i = Math.floor(n);\n  let j = (n - i) / 2;\n  let sum = 0;\n  while (i < j) {\n    sum += l[i];\n    i++;\n    j--;\n  }\n  return sum / 2;\n};\n\n/**\n * Returns the median of the given list of numbers.\n *\n * >>> medianOfListOfOfOfOfOf([3, 1, 2, 4, 5])\n * 3\n * >>> medianOfListOfOfOfOfOf([-10, 4, 6, 1000, 10, 20])\n * 8.0\n */\nconst medianOfListOfOfOfOfOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n / 2;\n  let i = Math.floor(n);\n  let j = (n - i) / 2;\n  let sum = 0;\n  while (i < j) {\n    sum += l[i];\n    i++;\n    j--;\n  }\n  return sum / 2;\n};\n\n/**\n * Returns the median of the given list of numbers.\n *\n * >>> medianOfListOfOfOfOfOf([3, 1, 2, 4, 5])\n * 3\n * >>> medianOfListOfOfOfOfOfOf([-10, 4, 6, 1000, 10, 20])\n * 8.0\n */\nconst medianOfListOfOfOfOfOfOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n / 2;\n  let i = Math.floor(n);\n  let j = (n - i) / 2;\n  let sum = 0;\n  while (i < j) {\n    sum += l[i];\n    i++;\n    j--;\n  }\n  return sum / 2;\n};\n\n/**\n * Returns the median of the given list of numbers.\n *\n * >>> medianOfListOfOfOfOfOf([3, 1, 2, 4, 5])\n * 3\n * >>> medianOfListOfOfOfOfOf([-10, 4, 6, 1000, 10, 20])\n * 8.0\n */\nconst medianOfListOfOfOfOfOfOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = "}
{"task_id": "JavaScript/48", "prompt": "/*\n  Tests if the given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Tests if the given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Tests if the given string is a palindrome (with spaces)\n  >>> isPalindrome('  ')\n  true\n  >>> isPalindrome('  aba')\n  true\n  >>> isPalindrome('  aaaaa')\n  true\n  >>> isPalindrome('  zbcd')\n  false\n  */\nconst isPalindromeWithSpaces = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Tests if the given string is a palindrome (with spaces and extra spaces)\n  >>> isPalindromeWithSpaces('  ')\n  true\n  >>> isPalindromeWithSpaces('  aba')\n  true\n  >>> isPalindromeWithSpaces('  aaaaa')\n  true\n  >>> isPalindromeWithSpaces('  zbcd')\n  false\n  */\nconst isPalindromeWithSpacesAndExtraSpaces = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Tests if the given string is a palindrome (with spaces and extra spaces and extra spaces)\n  >>> isPalindromeWithSpacesAndExtraSpaces('  ')\n  true\n  >>> isPalindromeWithSpacesAndExtraSpaces('  aba')\n  true\n  >>> isPalindromeWithSpacesAndExtraSpaces('  aaaaa')\n  true\n  >>> isPalindromeWithSpacesAndExtraSpaces('  zbcd')\n  false\n  */\nconst isPalindromeWithSpacesAndExtraSpacesAndExtraSpaces = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Tests if the given string is a palindrome (with spaces and extra spaces and extra spaces and extra spaces)\n  >>> isPalindromeWithSpacesAndExtraSpacesAndExtraSpaces('  ')\n  true\n  >>> isPalindromeWithSpacesAndExtraSpacesAndExtraSpaces('  aba')\n  true\n  >>> isPalindromeWithSpacesAndExtraSpacesAndExtraSpaces('  aaaaa')\n  true\n  >>> isPalindromeWithSpacesAndExtraSpacesAndExtraSpaces('  zbcd')\n  false\n  */\nconst isPalindromeWithSpacesAndExtraSpacesAndExtraSpacesAndExtraSpaces = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Tests if the given string is a palindrome (with spaces and extra spaces and extra spaces and extra spaces and extra spaces)\n  >>> isPalindromeWithSpacesAndExtraSpacesAndExtraSpacesAndExtraSpaces('  ')\n  true\n  >>> isPalindromeWithSpacesAndExtraSpacesAndExtraSpacesAndExtraSpaces('  aba')\n  true\n  >>> isPalindromeWithSpacesAndExtraSpacesAndExtraSpacesAndExtraSpaces('  aaaaa')\n  true\n  >>> isPalindromeWithSpacesAndExtraSpacesAndExtraSpacesAndExtraSpaces('  zbcd')\n  false\n  */\nconst isPalindromeWithSpacesAndExtraSpacesAndExtraSpacesAndExtraSpacesAndExtraSpaces = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Tests if the given string is a palindrome (with spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra spaces and extra space"}
{"task_id": "JavaScript/49", "prompt": "/*Return 2 ^ n modulo p (Attention Numeric).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return 2 ^ n modulo p (Attention Numeric).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const m = n | 0\n  const r = p | 0\n  const t = r - m\n  const s = t < 0? 0 : t > 0xff? 0xff : ((t | 0) - m) & 0x7f\n  const m = m ^ s\n  const i = Math.floor((m + r) / 2)\n  const f = i - Math.floor((m + r) / 2)\n  const e = r - i\n  const d = e < 0? 0 : e > 0xff? 0xff : ((e | 0) - m) & 0x7f\n  const m = m ^ d\n  const g = e < 0? 0 : e > 0xff? 0xff : ((e | 0) - m) & 0x7f\n  const h = g - f\n  const k = h < 0? 0 : h > 0xff? 0xff : ((h | 0) - m) & 0x7f\n  const l = g - k\n  const m = l < 0? 0 : l > 0xff? 0xff : ((l | 0) - m) & 0x7f\n  const n = h - l\n  const o = n - m\n  const p = o < 0? 0 : o > 0xff? 0xff : ((o | 0) - m) & 0x7f\n  const q = p - o\n  const r = q < 0? 0 : q > 0xff? 0xff : ((q | 0) - m) & 0x7f\n  const s = p - q\n  const t = r - s\n  const u = t - u\n  const v = u < 0? 0 : u > 0xff? 0xff : ((u | 0) - m) & 0x7f\n  const w = v - w\n  const x = w - x\n  const y = x - y\n  const z = y - z\n  const A = v < 0? 0 : v > 0xff? 0xff : ((v | 0) - m) & 0x7f\n  const B = w - A\n  const C = A - B\n  const D = B - C\n  const E = C - D\n  const F = D - E\n  const G = E - F\n  const H = F - G\n  const I = G - H\n  const J = H - I\n  const K = I - J\n  const L = J - K\n  const M = K - L\n  const N = L - M\n  const O = M - N\n  const P = N - O\n  const Q = O - P\n  const R = P - Q\n  const S = Q - R\n  const T = R - S\n  const U = S - T\n  const V = T - U\n  const W = U - V\n  const X = V - W\n  const Y = W - X\n  const Z = X - Y\n  const A = Y < 0? 0 : Y > 0xff? 0xff : ((Y | 0) - m) & 0x7f\n  const B = Z < 0? 0 : Z > 0xff? 0xff : ((Z | 0) - m) & 0x7f\n  const C = A ^ B\n  const D = B ^ C\n  const E = C ^ D\n  const F = D ^ E\n  const G = E ^ F\n  const H = F ^ G\n  const I = G ^ H\n  const J = H ^ I\n  const K = I ^ J\n  const L = J ^ K\n  const M = K ^ L\n  const N = L ^ M\n  const O = M ^ N\n  const P = N ^ O\n  const Q = O ^ P\n  const R = P ^ Q\n  const S = Q ^ R\n  const T = R ^ S\n  const U = S ^ T\n  const V = T ^ U\n  const W = U ^ V\n  const X = V ^ W\n  const Y = W ^ X\n  const Z = X ^ Y\n  const A = Y < 0? 0 : Y > 0xff? 0xff : ((Y | 0) - m) & 0x7f\n  const B = Z < 0? 0 : Z > 0xff? 0xff : ((Z | 0) - m) & 0x7f\n  const C = A ^ B\n  const D = B ^ C\n  const E = C ^ D\n  const F = D ^ E\n  const G = E ^ F\n  const H = F ^ G\n  const I = G ^ H\n  const J = H ^ I\n  const K = I ^ J\n  const L = J ^ K\n  const M = K ^ L\n  const N = L ^ M\n  const O = M ^ N\n  const P = N ^ O\n  const Q = O ^ P\n  const R = P ^ Q\n  const S = Q ^ R\n  const T = R ^ S\n  const U = S ^ T\n  const V = T ^ U\n  const W = U ^ V\n  const X = V ^ W\n  const Y = W ^ X\n  const Z = X ^ Y\n  const A = Y < 0? 0 : Y > 0xff? 0xff : ((Y | 0) - m) & 0x7f\n  const B = Z < 0? 0 : Z > 0xff? 0xff : ((Z | 0) - m) & 0x7f\n  const C = A ^ B\n  const D = B ^ C\n  const E = C ^ D\n  const F = D ^ E\n  const G = E ^ F\n  const H = F ^ G\n  const I = G ^ H\n  const J = H ^ I\n  const K = I ^ J\n  const L = J ^ K\n  const M = K ^ L\n  const N = L ^ M\n  const O = M ^ N\n  const P = N ^ O\n  const Q = O ^ P\n  const R = P ^ Q\n  const S = Q ^ R\n  const T = R ^ S\n  const U = S ^ T\n  const V = T ^ U\n  const W = U ^ V\n  const X = V ^ W\n  const Y = W ^ X\n  const Z = X ^ Y\n  const A = Y < 0? 0 : Y > 0xff? 0xff : ((Y | 0) - m) & 0x7f\n  const B = Z < 0? 0 : Z > 0xff? 0xff : ((Z | 0) - m) & 0x7f\n  const C = A ^ B\n  const D = B ^ C\n  const E = C ^ D\n  const F = D ^ E\n  const G = E ^ F\n  const H = F ^ G\n  const I = G ^ H\n  const J = H ^ I\n  const K = I ^ J\n  const L = J ^ K\n  const M = K ^ L\n  const N = L ^ M\n  const O = M ^ N\n  const P = N ^ O\n  const Q = O ^ P\n  const R = P ^ Q\n  const S = Q ^ R\n  const T = R ^ S\n  const U = S ^ T\n  const V = T ^ U\n  const W = U ^ V\n  const X = V ^ W\n  const Y = W ^ X\n  const Z = X ^ Y\n  const A = Y < 0? 0 : Y > 0xff? 0xff : ((Y | 0) - m) & 0x7f\n  const B = Z < 0? 0 : Z > 0xff? 0xff : ((Z | 0) - m) & 0x7f\n  const C = A ^ B\n  const D = B ^ C\n  const E = C ^ D\n  const F = D ^ E\n  const G = E ^ F\n  const H = F ^ G\n  const I = G ^ H\n  const J = H ^ I\n  const K = I ^ J\n  const L = J ^ K\n  const M = K ^ L\n  const N = L ^ M\n  const O = M ^ N\n  const P = N ^ O\n  const Q = O ^ P\n  const R = P ^ Q\n  const S = Q ^ R\n  const T = R ^ S\n  const U = S ^ T\n  const V = "}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encode = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decode = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeUnicode = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeUnicode = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeUnicodeEscape = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeUnicodeEscape = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeUnicodeEscapeUnicode = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeUnicodeEscapeUnicode = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeUnicodeEscapeUnicodeEscape = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeUnicodeEscapeUnicodeEscape = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeUnicodeEscapeUnicodeEscapeUnicode = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeUnicodeEscapeUnicodeEscapeUnicode = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeUnicodeEscapeUnicodeEscapeUnicodeEscape = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeUnicodeEscapeUnicodeEscapeUnicodeEscape = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicode = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeUnicodeEscapeUnicodeEscapeUnicodeEscape = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscape = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscape = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscape = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscape = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscape = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscape = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscape = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscape = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscape = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscape = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscapeUnicodeEscape"}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function that takes strings and returns strings without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  removeVowels is a function that takes strings and returns strings without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  let vowels = text.split('');\n  let newText = '';\n  for (let i = 0; i < vowels.length; i++) {\n    if (vowels[i] === 'a' || vowels[i] === 'e' || vowels[i] === 'i' || vowels[i] === 'o' || vowels[i] === 'u') {\n      newText += vowels[i];\n    }\n  }\n  return newText;\n};\n\n/*\n  removePunctuation is a function that takes strings and returns strings without punctuation.\n  >>> removePunctuation('')\n  ''\n  >>> removePunctuation(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removePunctuation('abcdef')\n  'abcdef'\n  >>> removePunctuation('aaaaa')\n  ''\n  >>> removePunctuation('aaBAA')\n  'B'\n  >>> removePunctuation('zbcd')\n  'zbcd'\n  */\nconst removePunctuation = (text) => {\n  let punctuation = text.split('');\n  let newText = '';\n  for (let i = 0; i < punctuation.length; i++) {\n    if (punctuation[i] === '.' || punctuation[i] === '!' || punctuation[i] === '?' || punctuation[i] === '-' || punctuation[i] === '_') {\n      newText += punctuation[i];\n    }\n  }\n  return newText;\n};\n\n/*\n  removeNumbers is a function that takes strings and returns strings without numbers.\n  >>> removeNumbers('')\n  ''\n  >>> removeNumbers(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeNumbers('abcdef')\n  'abcdef'\n  >>> removeNumbers('aaaaa')\n  ''\n  >>> removeNumbers('aaBAA')\n  'B'\n  >>> removeNumbers('zbcd')\n  'zbcd'\n  */\nconst removeNumbers = (text) => {\n  let numbers = text.split('');\n  let newText = '';\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] === '0' || numbers[i] === '1' || numbers[i] === '2' || numbers[i] === '3' || numbers[i] === '4' || numbers[i] === '5' || numbers[i] === '6' || numbers[i] === '7' || numbers[i] === '8' || numbers[i] === '9') {\n      newText += numbers[i];\n    }\n  }\n  return newText;\n};\n\n/*\n  removeWhitespace is a function that takes strings and returns strings without whitespace.\n  >>> removeWhitespace('')\n  ''\n  >>> removeWhitespace(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeWhitespace('abcdef')\n  'abcdef'\n  >>> removeWhitespace('aaaaa')\n  ''\n  >>> removeWhitespace('aaBAA')\n  'B'\n  >>> removeWhitespace('zbcd')\n  'zbcd'\n  */\nconst removeWhitespace = (text) => {\n  let whitespace = text.split('');\n  let newText = '';\n  for (let i = 0; i < whitespace.length; i++) {\n    if (whitespace[i] ==='' || whitespace[i] === '\\t' || whitespace[i] === '\\n' || whitespace[i] === '\\r' || whitespace[i] === '\\v' || whitespace[i] === '\\f' || whitespace[i] === '\\r') {\n      newText += whitespace[i];\n    }\n  }\n  return newText;\n};\n\n/*\n  removePunctuation is a function that takes strings and returns strings without punctuation.\n  >>> removePunctuation('')\n  ''\n  >>> removePunctuation(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removePunctuation('abcdef')\n  'abcdef'\n  >>> removePunctuation('aaaaa')\n  ''\n  >>> removePunctuation('aaBAA')\n  'B'\n  >>> removePunctuation('zbcd')\n  'zbcd'\n  */\nconst removePunctuation = (text) => {\n  let punctuation = text.split('');\n  let newText = '';\n  for (let i = 0; i < punctuation.length; i++) {\n    if (punctuation[i] === '.' || punctuation[i] === '!' || punctuation[i] === '?' || punctuation[i] === '-' || punctuation[i] === '_') {\n      newText += punctuation[i];\n    }\n  }\n  return newText;\n};\n\n/*\n  removeNumbers is a function that takes strings and returns strings without numbers.\n  >>> removeNumbers('')\n  ''\n  >>> removeNumbers(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeNumbers('abcdef')\n  'abcdef'\n  >>> removeNumbers('aaaaa')\n  ''\n  >>> removeNumbers('aaBAA')\n  'B'\n  >>> removeNumbers('zbcd')\n  'zbcd'\n  */\nconst removeNumbers = (text) => {\n  let numbers = text.split('');\n  let newText = '';\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] === '0' || numbers[i] === '1' || numbers[i] === '2' || numbers[i] === '3' || numbers[i] === '4' || numbers[i] === '5' || numbers[i] === '6' || numbers[i] === '7' || numbers[i] === '8' || numbers[i] === '9') {\n      newText += numbers[i];\n    }\n  }\n  return newText;\n};\n\n/*\n  removeWhitespace is a function that takes strings and returns strings without whitespace.\n  >>> removeWhitespace('')\n  ''\n  >>> removeWhitespace(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeWhitespace('abcdef')\n  'abcdef'\n  >>> removeWhitespace('aaaaa')\n  ''\n  >>> removeWhitespace('aaBAA')\n  'B'\n  >>> removeWhitespace('zbcd')\n  'zbcd'\n  */\nconst removeWhitespace = (text) => {\n  let whitespace = text.split('');\n  let newText = '';\n  for (let i = 0; i < whitespace.length; i++) {\n    if (whitespace[i] ==='' || whitespace[i] === '\\t' || whitespace[i] === '\\n' || whitespace[i] === '\\r' || whitespace[i] === '\\v' || whitespace[i] === '\\f' || whitespace[i] === '\\r') {\n      newText += whitespace[i];\n    }\n  }\n  return newText;\n};\n\n/*\n  removePunctuation is a function that takes strings and returns strings without punctuation.\n  >>> removePunctuation('')\n  ''\n  >>> removePunctuation(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removePunctuation('abcdef')\n  'abcdef'\n  >>> removePunctuation('aaaaa')\n  ''\n  >>> removePunctuation('aaBAA')\n  'B'\n  >>> removePunctuation('zbcd')\n  'zbcd'\n  */\nconst removePunctuation = (text) => {\n  let punctuation = text.split('');\n  let newText = '';\n  for (let i = 0; i < punctuation.length; i++) {\n    if (punctuation[i] === '.' || punctuation[i] === '!' || punctuation[i] === '?' || punctuation[i] === '-' || punctuation[i] === '_') {\n      newText += punctuation[i];\n    }\n  }\n  return newText;\n};\n\n/*\n  removeNumbers is a function that takes strings and returns strings without numbers.\n  >>> removeNumbers('')\n  ''\n  >>> removeNumbers(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeNumbers('abcdef"}
{"task_id": "JavaScript/52", "prompt": "/*Return true if all numbers in list l are below the t threshold.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return true if all numbers in list l are below the t threshold.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  return l.every(n => n < t);\n};\n\n/*\n  >>> isEven([0, 2, 4, 6, 8])\n  true\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  true\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])"}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y with optional precision\n  >>> add(2, 3, 2)\n  5\n  >>> add(5, 7, 2)\n  12\n  */\nconst addWithPrecision = (x, y, precision) => {\n  return add(x, y, precision);\n};\n\n/*\n  Subtract two numbers x and y\n  >>> subtract(2, 3)\n  3\n  >>> subtract(5, 7)\n  -1\n  */\nconst subtract = (x, y) => {\n  return x - y;\n};\n\n/*\n  Subtract two numbers x and y with optional precision\n  >>> subtract(2, 3, 2)\n  3\n  >>> subtract(5, 7, 2)\n  -1\n  */\nconst subtractWithPrecision = (x, y, precision) => {\n  return subtract(x, y, precision);\n};\n\n/*\n  Multiply two numbers x and y\n  >>> multiply(2, 3)\n  6\n  >>> multiply(5, 7)\n  24\n  */\nconst multiply = (x, y) => {\n  return x * y;\n};\n\n/*\n  Multiply two numbers x and y with optional precision\n  >>> multiply(2, 3, 2)\n  6\n  >>> multiply(5, 7, 2)\n  24\n  */\nconst multiplyWithPrecision = (x, y, precision) => {\n  return multiply(x, y, precision);\n};\n\n/*\n  Divide two numbers x and y\n  >>> divide(2, 3)\n  1.5\n  >>> divide(5, 7)\n  0.5\n  */\nconst divide = (x, y) => {\n  return x / y;\n};\n\n/*\n  Divide two numbers x and y with optional precision\n  >>> divide(2, 3, 2)\n  1.5\n  >>> divide(5, 7, 2)\n  0.5\n  */\nconst divideWithPrecision = (x, y, precision) => {\n  return divide(x, y, precision);\n};\n\n/*\n  Calculate the remainder of division between two numbers\n  >>> remainder(2, 3)\n  1\n  >>> remainder(5, 7)\n  0.5\n  */\nconst remainder = (x, y) => {\n  return x % y;\n};\n\n/*\n  Calculate the remainder of division between two numbers with\n  optional precision\n  >>> remainder(2, 3, 2)\n  1\n  >>> remainder(5, 7, 2)\n  0.5\n  */\nconst remainderWithPrecision = (x, y, precision) => {\n  return remainder(x, y, precision);\n};\n\n/*\n  Calculate the remainder of division between two numbers and a fraction\n  >>> remainderFraction(2, 3, 2)\n  0.5\n  >>> remainderFraction(5, 7, 2)\n  0.5\n  */\nconst remainderFraction = (x, y, fraction) => {\n  return remainder(x, y, fraction);\n};\n\n/*\n  Calculate the remainder of division between two numbers and a fraction\n  >>> remainderFraction(2, 3, 2)\n  0.5\n  >>> remainderFraction(5, 7, 2)\n  0.5\n  */\nconst remainderFractionWithPrecision = (x, y, fraction, precision) => {\n  return remainderFraction(x, y, fraction, precision);\n};\n\n/*\n  Calculate the remainder of division between two numbers and a fraction\n  >>> remainderFraction(2, 3, 2)\n  0.5\n  >>> remainderFraction(5, 7, 2)\n  0.5\n  */\nconst remainderFractionWithPrecisionAndRound = (x, y, fraction, precision) => {\n  return remainderFraction(x, y, fraction, precision);\n};\n\n/*\n  Calculate the remainder of division between two numbers and a fraction\n  >>> remainderFraction(2, 3, 2)\n  0.5\n  >>> remainderFraction(5, 7, 2)\n  0.5\n  */\nconst remainderFractionWithPrecisionAndRoundAndRound = (x, y, fraction, precision) => {\n  return remainderFraction(x, y, fraction, precision);\n};\n\n/*\n  Calculate the remainder of division between two numbers and a fraction\n  >>> remainderFraction(2, 3, 2)\n  0.5\n  >>> remainderFraction(5, 7, 2)\n  0.5\n  */\nconst remainderFractionWithPrecisionAndRoundAndRoundAndRound = (x, y, fraction, precision) => {\n  return remainderFraction(x, y, fraction, precision);\n};\n\n/*\n  Calculate the remainder of division between two numbers and a fraction\n  >>> remainderFraction(2, 3, 2)\n  0.5\n  >>> remainderFraction(5, 7, 2)\n  0.5\n  */\nconst remainderFractionWithPrecisionAndRoundAndRoundAndRound = (x, y, fraction, precision) => {\n  return remainderFraction(x, y, fraction, precision);\n};\n\n/*\n  Calculate the remainder of division between two numbers and a fraction\n  >>> remainderFraction(2, 3, 2)\n  0.5\n  >>> remainderFraction(5, 7, 2)\n  0.5\n  */\nconst remainderFractionWithPrecisionAndRoundAndRoundAndRoundAndRound = (x, y, fraction, precision) => {\n  return remainderFraction(x, y, fraction, precision);\n};\n\n/*\n  Calculate the remainder of division between two numbers and a fraction\n  >>> remainderFraction(2, 3, 2)\n  0.5\n  >>> remainderFraction(5, 7, 2)\n  0.5\n  */\nconst remainderFractionWithPrecisionAndRoundAndRoundAndRoundAndRound = (x, y, fraction, precision) => {\n  return remainderFraction(x, y, fraction, precision);\n};\n\n/*\n  Calculate the remainder of division between two numbers and a fraction\n  >>> remainderFraction(2, 3, 2)\n  0.5\n  >>> remainderFraction(5, 7, 2)\n  0.5\n  */\nconst remainderFractionWithPrecisionAndRoundAndRoundAndRoundAndRoundAndRound = (x, y, fraction, precision) => {\n  return remainderFraction(x, y, fraction, precision);\n};\n\n/*\n  Calculate the remainder of division between two numbers and a fraction\n  >>> remainderFraction(2, 3, 2)\n  0.5\n  >>> remainderFraction(5, 7, 2)\n  0.5\n  */\nconst remainderFractionWithPrecisionAndRoundAndRoundAndRoundAndRoundAndRoundAndRound = (x, y, fraction, precision) => {\n  return remainderFraction(x, y, fraction, precision);\n};\n\n/*\n  Calculate the remainder of division between two numbers and a fraction\n  >>> remainderFraction(2, 3, 2)\n  0.5\n  >>> remainderFraction(5, 7, 2)\n  0.5\n  */\nconst remainderFractionWithPrecisionAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRound = (x, y, fraction, precision) => {\n  return remainderFraction(x, y, fraction, precision);\n};\n\n/*\n  Calculate the remainder of division between two numbers and a fraction\n  >>> remainderFraction(2, 3, 2)\n  0.5\n  >>> remainderFraction(5, 7, 2)\n  0.5\n  */\nconst remainderFractionWithPrecisionAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRound = (x, y, fraction, precision) => {\n  return remainderFraction(x, y, fraction, precision);\n};\n\n/*\n  Calculate the remainder of division between two numbers and a fraction\n  >>> remainderFraction(2, 3, 2)\n  0.5\n  >>> remainderFraction(5, 7, 2)\n  0.5\n  */\nconst remainderFractionWithPrecisionAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAndRoundAnd"}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check that two words have the same letters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Check that two words have the same letters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let n = 0;\n  let m = 0;\n  let n1 = 0;\n  let m1 = 0;\n  let n2 = 0;\n  let m2 = 0;\n  let n3 = 0;\n  let m3 = 0;\n  let n4 = 0;\n  let m4 = 0;\n  let n5 = 0;\n  let m5 = 0;\n  let n6 = 0;\n  let m6 = 0;\n  let n7 = 0;\n  let m7 = 0;\n  let n8 = 0;\n  let m8 = 0;\n  let n9 = 0;\n  let m9 = 0;\n  let n10 = 0;\n  let m10 = 0;\n  let n11 = 0;\n  let m11 = 0;\n  let n12 = 0;\n  let m12 = 0;\n  let n13 = 0;\n  let m13 = 0;\n  let n14 = 0;\n  let m14 = 0;\n  let n15 = 0;\n  let m15 = 0;\n  let n16 = 0;\n  let m16 = 0;\n  let n17 = 0;\n  let m17 = 0;\n  let n18 = 0;\n  let m18 = 0;\n  let n19 = 0;\n  let m19 = 0;\n  let n20 = 0;\n  let m20 = 0;\n  let n21 = 0;\n  let m21 = 0;\n  let n22 = 0;\n  let m22 = 0;\n  let n23 = 0;\n  let m23 = 0;\n  let n24 = 0;\n  let m24 = 0;\n  let n25 = 0;\n  let m25 = 0;\n  let n26 = 0;\n  let m26 = 0;\n  let n27 = 0;\n  let m27 = 0;\n  let n28 = 0;\n  let m28 = 0;\n  let n29 = 0;\n  let m29 = 0;\n  let n30 = 0;\n  let m30 = 0;\n  let n31 = 0;\n  let m31 = 0;\n  let n32 = 0;\n  let m32 = 0;\n  let n33 = 0;\n  let m33 = 0;\n  let n34 = 0;\n  let m34 = 0;\n  let n35 = 0;\n  let m35 = 0;\n  let n36 = 0;\n  let m36 = 0;\n  let n37 = 0;\n  let m37 = 0;\n  let n38 = 0;\n  let m38 = 0;\n  let n39 = 0;\n  let m39 = 0;\n  let n40 = 0;\n  let m40 = 0;\n  let n41 = 0;\n  let m41 = 0;\n  let n42 = 0;\n  let m42 = 0;\n  let n43 = 0;\n  let m43 = 0;\n  let n44 = 0;\n  let m44 = 0;\n  let n45 = 0;\n  let m45 = 0;\n  let n46 = 0;\n  let m46 = 0;\n  let n47 = 0;\n  let m47 = 0;\n  let n48 = 0;\n  let m48 = 0;\n  let n49 = 0;\n  let m49 = 0;\n  let n50 = 0;\n  let m50 = 0;\n  let n51 = 0;\n  let m51 = 0;\n  let n52 = 0;\n  let m52 = 0;\n  let n53 = 0;\n  let m53 = 0;\n  let n54 = 0;\n  let m54 = 0;\n  let n55 = 0;\n  let m55 = 0;\n  let n56 = 0;\n  let m56 = 0;\n  let n57 = 0;\n  let m57 = 0;\n  let n58 = 0;\n  let m58 = 0;\n  let n59 = 0;\n  let m59 = 0;\n  let n60 = 0;\n  let m60 = 0;\n  let n61 = 0;\n  let m61 = 0;\n  let n62 = 0;\n  let m62 = 0;\n  let n63 = 0;\n  let m63 = 0;\n  let n64 = 0;\n  let m64 = 0;\n  let n65 = 0;\n  let m65 = 0;\n  let n66 = 0;\n  let m66 = 0;\n  let n67 = 0;\n  let m67 = 0;\n  let n68 = 0;\n  let m68 = 0;\n  let n69 = 0;\n  let m69 = 0;\n  let n70 = 0;\n  let m70 = 0;\n  let n71 = 0;\n  let m71 = 0;\n  let n72 = 0;\n  let m72 = 0;\n  let n73 = 0;\n  let m73 = 0;\n  let n74 = 0;\n  let m74 = 0;\n  let n75 = 0;\n  let m75 = 0;\n  let n76 = 0;\n  let m76 = 0;\n  let n77 = 0;\n  let m77 = 0;\n  let n78 = 0;\n  let m78 = 0;\n  let n79 = 0;\n  let m79 = 0;\n  let n80 = 0;\n  let m80 = 0;\n  let n81 = 0;\n  let m81 = 0;\n  let n82 = 0;\n  let m82 = 0;\n  let n83 = 0;\n  let m83 = 0;\n  let n84 = 0;\n  let m84 = 0;\n  let n85 = 0;\n  let m85 = 0;\n  let n86 = 0;\n  let m86 = 0;\n  let n87 = 0;\n  let m87 = 0;\n  let n88 = 0;\n  let m88 = 0;\n  let n89 = 0;\n  let m89 = 0;\n  let n90 = 0;\n  let m90 = 0;\n  let n91 = 0;\n  let m91 = 0;\n  let n92 = 0;\n  let m92 = 0;\n  let n93 = 0;\n  let m93 = 0;\n  let n94 = 0;\n  let m94 = 0;\n  let n95 = 0;\n  let m95 = 0;\n  let n96 = 0;\n  let m96 = 0;\n  let n97 = 0;\n  let m97 = 0;\n  let n98 = 0;\n  let m98 = 0;\n  let n99 = 0;\n  let m99 = 0;\n  let n100 = 0;\n  let m100 = 0;\n  let n101 = 0;\n  let m101 = 0;\n  let n102 = 0;\n  let m102 = 0;\n  let n103 = 0;\n  let m103 = 0;\n  let n104 = 0;\n  let m104 = 0;\n  let n105 = 0;\n  let m105 = 0;\n  let n106 = 0;\n  let m106 = 0;\n  let n107 = 0;\n  let m107 = 0;\n  let n108 = 0;\n  let m108 = 0;\n  let n109 = 0;\n  let m109 = 0;\n  let n110 = 0;\n  let m110 = 0;\n  let n111 = 0;\n  let m111 = 0;\n  let n112 = 0;\n  let m112 = 0;\n  let n113 = 0;\n  let m113 = 0;\n  let n114 = 0;\n  let m114 = 0;\n  let n115 = 0;\n  let m115 = 0;\n  let n116 = 0;\n  let m116 = 0;\n  let n117 = 0;\n  let m117 = 0;\n  let n118 = 0;\n  let m118 = 0;\n  let n119 = 0;\n  let m119 = 0;\n  let n120 = 0;\n  let m120 = 0;\n  let n121 = 0;\n  let m121 = 0;\n  let n122 = 0;\n  let m122 = 0;\n  let n123 = 0;\n  let m123 = 0;\n  let n124 = 0;\n  let m124 = 0;\n  let n125 = 0;\n  let m125 = 0;\n  let n126 = 0;\n  let m126 = 0;\n  let n127 = 0;\n  let m127 = 0;\n  let n128 = 0;\n  let m128 = 0;\n  let n129 = 0;\n  let m129 = 0;\n  let n130 = 0;\n  let m130 = 0;\n  let n131 = 0;\n  let m131 = 0;\n  let n132 = 0;\n  let m132 = 0;\n  let n133 = 0;\n  let m133 = 0;\n  let n134 = 0;\n  let m134 = 0;\n  let n135 = 0;\n  let m135 = 0;\n  let n136 = 0;\n  let m136 = 0;\n  let n137 = 0;\n  let m137 = 0;\n  let n138 = 0;\n  let m138 = 0;\n  let n139 = 0;\n  let m139 = 0;\n  let n140 = 0;\n"}
{"task_id": "JavaScript/55", "prompt": "/*RThe Fibonacci number is the ninth.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*RThe Fibonacci number is the ninth.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(4)\n  34\n  >>> fib(3)\n  89\n  >>> fib(2)\n  55\n  >>> fib(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(5)\n  55\n  >>> fibonacci(4)\n  34\n  >>> fibonacci(3)\n  89\n  >>> fibonacci(2)\n  55\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(9)\n  34\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(15)\n  55\n  >>> fibonacci(14)\n  34\n  >>> fibonacci(13)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(20)\n  55\n  >>> fibonacci(19)\n  34\n  >>> fibonacci(18)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(25)\n  55\n  >>> fibonacci(24)\n  34\n  >>> fibonacci(23)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(30)\n  55\n  >>> fibonacci(29)\n  34\n  >>> fibonacci(28)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(35)\n  55\n  >>> fibonacci(34)\n  34\n  >>> fibonacci(33)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(39)\n  55\n  >>> fibonacci(38)\n  34\n  >>> fibonacci(37)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(45)\n  55\n  >>> fibonacci(44)\n  34\n  >>> fibonacci(43)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(49)\n  55\n  >>> fibonacci(48)\n  34\n  >>> fibonacci(47)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(55)\n  55\n  >>> fibonacci(54)\n  34\n  >>> fibonacci(53)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(59)\n  55\n  >>> fibonacci(58)\n  34\n  >>> fibonacci(57)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(65)\n  55\n  >>> fibonacci(64)\n  34\n  >>> fibonacci(63)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(69)\n  55\n  >>> fibonacci(68)\n  34\n  >>> fibonacci(67)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(73)\n  55\n  >>> fibonacci(72)\n  34\n  >>> fibonacci(71)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(79)\n  55\n  >>> fibonacci(78)\n  34\n  >>> fibonacci(77)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(83)\n  55\n  >>> fibonacci(82)\n  34\n  >>> fibonacci(81)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(89)\n  55\n  >>> fibonacci(88)\n  34\n  >>> fibonacci(87)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {"}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">.\" returns false if each opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string of \"<\" and \">.\" returns false if each opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketingRegex = new RegExp(`^${brackets}+$`);\n  return bracketingRegex.test(html);\n};\n\n/**\n * Returns true if a tag is valid.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *\n * Valid tags are those that do not have attributes or that have no children.\n *"}
{"task_id": "JavaScript/57", "prompt": "/*RIt is true that list elements monotonously increase or decrease.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*RIt is true that list elements monotonously increase or decrease.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let i = l.length - 1;\n  let j = l[0];\n  let k = 0;\n  let l = l.reverse();\n  while (l > l) {\n    if (l[j] < l[k]) {\n      i = j;\n      j = k;\n      k = j + 1;\n    }\n  }\n  return i > j;\n};\n\n/**\n * Returns true if two lists are equal, false otherwise.\n *\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * true\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n"}
{"task_id": "JavaScript/58", "prompt": "/*RHe sorted out unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*RHe sorted out unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set();\n  const set1 = new Set();\n  const set2 = new Set();\n  for (let i = 0; i < l1.length; i++) {\n    if (l1.includes(l1[i])) {\n      set.add(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (l2.includes(l2[i])) {\n      set2.add(l2[i]);\n    }\n  }\n  for (let i = 0; i < l1.length; i++) {\n    if (set1.has(l1[i])) {\n      set1.delete(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (set2.has(l2[i])) {\n      set2.delete(l2[i]);\n    }\n  }\n  return [...set1,...set2];\n};\n\n/*\n  Given two sorted arrays, return their intersection.\n\n  >>> intersection([2, 5, 7, 9], [1, 4, 3, 34, 653, 2, 5])\n  [2, 5, 7, 9]\n\n  */\nconst intersection = (l1, l2) => {\n  const set = new Set();\n  for (let i = 0; i < l1.length; i++) {\n    if (l1.includes(l1[i])) {\n      set.add(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (l2.includes(l2[i])) {\n      set.add(l2[i]);\n    }\n  }\n  return [...set];\n};\n\n/*\n  Given two sorted arrays, return their union.\n\n  >>> union([2, 5, 7, 9], [1, 4, 3, 34, 653, 2, 5])\n  [2, 5, 7, 9, 1, 4, 3, 34, 653, 2, 5]\n\n  */\nconst union = (l1, l2) => {\n  const set = new Set();\n  for (let i = 0; i < l1.length; i++) {\n    if (l1.includes(l1[i])) {\n      set.add(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (l2.includes(l2[i])) {\n      set.add(l2[i]);\n    }\n  }\n  return [...set];\n};\n\n/*\n  Given two sorted arrays, return their differences.\n\n  >>> difference([2, 5, 7, 9], [1, 4, 3, 34, 653, 2, 5])\n  [2, 5, 7, 9]\n\n  */\nconst difference = (l1, l2) => {\n  const set = new Set();\n  for (let i = 0; i < l1.length; i++) {\n    if (l1.includes(l1[i])) {\n      set.add(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (l2.includes(l2[i])) {\n      set.add(l2[i]);\n    }\n  }\n  return [...set];\n};\n\n/*\n  Given two sorted arrays, return their symmetric differences.\n\n  >>> symmetricDifference([2, 5, 7, 9], [1, 4, 3, 34, 653, 2, 5])\n  [2, 5, 7, 9]\n\n  */\nconst symmetricDifference = (l1, l2) => {\n  const set = new Set();\n  for (let i = 0; i < l1.length; i++) {\n    if (l1.includes(l1[i])) {\n      set.add(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (l2.includes(l2[i])) {\n      set.add(l2[i]);\n    }\n  }\n  const set1 = new Set();\n  for (let i = 0; i < l1.length; i++) {\n    if (l1.includes(l1[i])) {\n      set1.add(l1[i]);\n    }\n  }\n  const set2 = new Set();\n  for (let i = 0; i < l2.length; i++) {\n    if (l2.includes(l2[i])) {\n      set2.add(l2[i]);\n    }\n  }\n  return [...set1,...set2];\n};\n\n/*\n  Given two sorted arrays, return their symmetric differences.\n\n  >>> symmetricDifference([2, 5, 7, 9], [1, 4, 3, 34, 653, 2, 5])\n  [2, 5, 7, 9]\n\n  */\nconst symmetricDifference2 = (l1, l2) => {\n  const set = new Set();\n  for (let i = 0; i < l1.length; i++) {\n    if (l1.includes(l1[i])) {\n      set.add(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (l2.includes(l2[i])) {\n      set.add(l2[i]);\n    }\n  }\n  const set1 = new Set();\n  for (let i = 0; i < l1.length; i++) {\n    if (l1.includes(l1[i])) {\n      set1.add(l1[i]);\n    }\n  }\n  const set2 = new Set();\n  for (let i = 0; i < l2.length; i++) {\n    if (l2.includes(l2[i])) {\n      set2.add(l2[i]);\n    }\n  }\n  return [...set1,...set2].filter(x => x!== set);\n};\n\n/*\n  Given two sorted arrays, return their symmetric differences.\n\n  >>> symmetricDifference([2, 5, 7, 9], [1, 4, 3, 34, 653, 2, 5])\n  [2, 5, 7, 9]\n\n  */\nconst symmetricDifference3 = (l1, l2) => {\n  const set = new Set();\n  for (let i = 0; i < l1.length; i++) {\n    if (l1.includes(l1[i])) {\n      set.add(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (l2.includes(l2[i])) {\n      set.add(l2[i]);\n    }\n  }\n  const set1 = new Set();\n  for (let i = 0; i < l1.length; i++) {\n    if (l1.includes(l1[i])) {\n      set1.add(l1[i]);\n    }\n  }\n  const set2 = new Set();\n  for (let i = 0; i < l2.length; i++) {\n    if (l2.includes(l2[i])) {\n      set2.add(l2[i]);\n    }\n  }\n  return [...set1,...set2].filter(x => x!== set1 && x!== set2);\n};\n\n/*\n  Given two sorted arrays, return their symmetric differences.\n\n  >>> symmetricDifference([2, 5, 7, 9], [1, 4, 3, 34, 653, 2, 5])\n  [2, 5, 7, 9]\n\n  */\nconst symmetricDifference4 = (l1, l2) => {\n  const set = new Set();\n  for (let i = 0; i < l1.length; i++) {\n    if (l1.includes(l1[i])) {\n      set.add(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (l2.includes(l2[i])) {\n      set.add(l2[i]);\n    }\n  }\n  const set1 = new Set();\n  for (let i = 0; i < l1.length; i++) {\n    if (l1.includes(l1[i])) {\n      set1.add(l1[i]);\n    }\n  }\n  const set2 = new Set();\n  for (let i = 0; i < l2.length; i++) {\n    if (l2.includes(l2[i])) {\n      set2.add(l2[i]);\n    }\n  }\n  return [...set1,...set2].filter(x => x!== set1 && x!== set2 && x!== set);\n};\n\n/*\n  Given two sorted arrays, return their symmetric differences.\n\n  >>> symmetricDifference([2, 5, 7, 9], [1, 4, 3, 34, 653, 2, 5])\n  [2, 5, 7, 9]\n\n  */\nconst symmetricDifference5 = (l1, l2) => {\n  const set = new Set();\n  for (let i = 0; i < l1.length; i++) {\n    if (l1.includes(l1[i])) {\n      set.add(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (l2.includes(l2[i])) {\n      set.add(l2[i]);\n    }\n  }\n  const set1 = new Set();\n  for (let i = 0; i < l1.length; i++) {\n    if (l1.includes(l1[i])) {\n      set1.add(l1[i]);\n    }\n  }\n  const set2 = new Set();\n  for (let i = 0; i < l2.length; i++) {\n    if (l2.includes(l2[i])) {\n      set2.add(l2[i]);\n    }\n  }\n  return [...set1,...set2]."}
{"task_id": "JavaScript/59", "prompt": "/*RSuppose n > 1 and is not a prime number.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*RSuppose n > 1 and is not a prime number.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor += 1;\n  }\n  return factor;\n};\n\n/*\n  Given a positive integer n, return its largest prime factor.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactorOf = (n) => {\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor += 1;\n  }\n  return factor;\n};\n\n/*\n  Given a positive integer n, return its largest prime factor.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor += 1;\n  }\n  return factor;\n};\n\n/*\n  Given a positive integer n, return its largest prime factor.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor += 1;\n  }\n  return factor;\n};\n\n/*\n  Given a positive integer n, return its largest prime factor.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor += 1;\n  }\n  return factor;\n};\n\n/*\n  Given a positive integer n, return its largest prime factor.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor += 1;\n  }\n  return factor;\n};\n\n/*\n  Given a positive integer n, return its largest prime factor.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor += 1;\n  }\n  return factor;\n};\n\n/*\n  Given a positive integer n, return its largest prime factor.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor += 1;\n  }\n  return factor;\n};\n\n/*\n  Given a positive integer n, return its largest prime factor.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor += 1;\n  }\n  return factor;\n};\n\n/*\n  Given a positive integer n, return its largest prime factor.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor += 1;\n  }\n  return factor;\n};\n\n/*\n  Given a positive integer n, return its largest prime factor.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor += 1;\n  }\n  return factor;\n};\n\n/*\n  Given a positive integer n, return its largest prime factor.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor += 1;\n  }\n  return factor;\n};\n\n/*\n  Given a positive integer n, return its largest prime factor.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor += 1;\n  }\n  return factor;\n};\n\n/*\n  Given a positive integer n, return its largest prime factor.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor += 1;\n  }\n  return factor;\n};\n\n/*\n  Given a positive integer n, return its largest prime factor.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor += 1;\n  }\n  return factor;\n};\n\n/*\n  Given a positive integer n, return its largest prime factor.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor += 1;\n  }\n  return factor;\n};\n\n/*\n  Given a positive integer n, return its largest prime factor.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor += 1;\n  }\n  return factor;\n};\n\n/*\n  Given a positive integer n, return its largest prime factor.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor += 1;\n  }\n  return factor;\n};\n\n/*\n  Given a positive integer n, return its largest prime factor.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor += 1;\n  }\n  return factor;\n};\n\n/*\n  Given a positive integer n, return its largest prime factor.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2"}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a function that adds numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*sumToN is a function that adds numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all numbers from 1 to n.\n  >>> sumToN(30)\n"}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \").\" returns true if each opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string of \"(\" and \").\" returns true if each opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  return brackets.split('').every(char => char === ')');\n};\n\n/**\n * Returns a string that is the concatenation of all characters in the given string.\n * If the given string contains no characters, an empty string is returned.\n * If the given string contains characters that are not valid characters for strings, an empty string is returned.\n * If the given string contains characters that are not valid characters for numbers, an empty string is returned.\n * If the given string contains characters that are not valid characters for booleans, an empty string is returned.\n * If the given string contains characters that are not valid characters for arrays, an empty string is returned.\n * If the given string contains characters that are not valid characters for objects, an empty string is returned.\n * If the given string contains characters that are not valid characters for functions, an empty string is returned.\n * If the given string contains characters that are not valid characters for regular expressions, an empty string is returned.\n * If the given string contains characters that are not valid characters for strings, an empty string is returned.\n * If the given string contains characters that are not valid characters for numbers, an empty string is returned.\n * If the given string contains characters that are not valid characters for booleans, an empty string is returned.\n * If the given string contains characters that are not valid characters for arrays, an empty string is returned.\n * If the given string contains characters that are not valid characters for objects, an empty string is returned.\n * If the given string contains characters that are not valid characters for functions, an empty string is returned.\n * If the given string contains characters that are not valid characters for regular expressions, an empty string is returned.\n * If the given string contains characters that are not valid characters for strings, an empty string is returned.\n * If the given string contains characters that are not valid characters for numbers, an empty string is returned.\n * If the given string contains characters that are not valid characters for booleans, an empty string is returned.\n * If the given string contains characters that are not valid characters for arrays, an empty string is returned.\n * If the given string contains characters that are not valid characters for objects, an empty string is returned.\n * If the given string contains characters that are not valid characters for functions, an empty string is returned.\n * If the given string contains characters that are not valid characters for regular expressions, an empty string is returned.\n * If the given string contains characters that are not valid characters for strings, an empty string is returned.\n * If the given string contains characters that are not valid characters for numbers, an empty string is returned.\n * If the given string contains characters that are not valid characters for booleans, an empty string is returned.\n * If the given string contains characters that are not valid characters for arrays, an empty string is returned.\n * If the given string contains characters that are not valid characters for objects, an empty string is returned.\n * If the given string contains characters that are not valid characters for functions, an empty string is returned.\n * If the given string contains characters that are not valid characters for regular expressions, an empty string is returned.\n * If the given string contains characters that are not valid characters for strings, an empty string is returned.\n * If the given string contains characters that are not valid characters for numbers, an empty string is returned.\n * If the given string contains characters that are not valid characters for booleans, an empty string is returned.\n * If the given string contains characters that are not valid characters for arrays, an empty string is returned.\n * If the given string contains characters that are not valid characters for objects, an empty string is returned.\n * If the given string contains characters that are not valid characters for functions, an empty string is returned.\n * If the given string contains characters that are not valid characters for regular expressions, an empty string is returned.\n * If the given string contains characters that are not valid characters for strings, an empty string is returned.\n * If the given string contains characters that are not valid characters for numbers, an empty string is returned.\n * If the given string contains characters that are not valid characters for booleans, an empty string is returned.\n * If the given string contains characters that are not valid characters for arrays, an empty string is returned.\n * If the given string contains characters that are not valid characters for objects, an empty string is returned.\n * If the given string contains characters that are not valid characters for functions, an empty string is returned.\n * If the given string contains characters that are not valid characters for regular expressions, an empty string is returned.\n * If the given string contains characters that are not valid characters for strings, an empty string is returned.\n * If the given string contains characters that are not valid characters for numbers, an empty string is returned.\n * If the given string contains characters that are not valid characters for booleans, an empty string is returned.\n * If the given string contains characters that are not valid characters for arrays, an empty string is returned.\n * If the given string contains characters that are not valid characters for objects, an empty string is returned.\n * If the given string contains characters that are not valid characters for functions, an empty string is returned.\n * If the given string contains characters that are not valid characters for regular expressions, an empty string is returned.\n * If the given string contains characters that are not valid characters for strings, an empty string is returned.\n * If the given string contains characters that are not valid characters for numbers, an empty string is returned.\n * If the given string contains characters that are not valid characters for booleans, an empty string is returned.\n * If the given string contains characters that are not valid characters for arrays, an empty string is returned.\n * If the given string contains characters that are not valid characters for objects, an empty string is returned.\n * If the given string contains characters that are not valid characters for functions, an empty string is returned.\n * If the given string contains characters that are not valid characters for regular expressions, an empty string is returned.\n * If the given string contains characters that are not valid characters for strings, an empty string is returned.\n * If the given string contains characters that are not valid characters for numbers, an empty string is returned.\n * If the given string contains characters that are not valid characters for booleans, an empty string is returned.\n * If the given string contains characters that are not valid characters for arrays, an empty string is returned.\n * If the given string contains characters that are not valid characters for objects, an empty string is returned.\n * If the given string contains characters that are not valid characters for functions, an empty string is returned.\n * If the given string contains characters that are not valid characters for regular expressions, an empty string is returned.\n * If the given string contains characters that are not valid characters for strings, an empty string is returned.\n * If the given string contains characters that are not valid characters for numbers, an empty string is returned.\n * If the given string contains characters that are not valid characters for booleans, an empty string is returned.\n * If the given string contains characters that are not valid characters for arrays, an empty string is returned.\n * If the given string contains characters that are not valid characters for objects, an empty string is returned.\n * If the given string contains characters that are not valid characters for functions, an empty string is returned.\n * If the given string contains characters that are not valid characters for regular expressions, an empty string is returned.\n * If the given string contains characters that are not valid characters for strings, an empty string is returned.\n * If the given string contains characters that are not valid characters for numbers, an empty string is returned.\n * If the given string contains characters that are not valid characters for booleans, an empty string is returned.\n * If the given string contains characters that are not valid characters for arrays, an empty string is returned.\n * If the given string contains characters that are not valid characters for objects, an empty string is returned.\n * If the given string contains characters that are not valid characters for functions, an empty string is returned.\n * If the given string contains characters that are not valid characters for regular expressions, an empty string is returned.\n * If the given string contains characters that are not valid characters for strings, an empty string is returned.\n * If the given string contains characters that are not valid characters for numbers, an empty string is returned.\n * If the given string contains characters that are not valid characters for booleans, an empty string is returned.\n * If the given string contains characters that are not valid characters for arrays, an empty string is returned.\n * If the given string contains characters that are not valid characters for objects, an empty string is returned.\n * If the given string contains characters that are not valid characters for functions, an empty string is returned.\n * If the given string contains characters that are not valid characters for regular expressions, an empty string is returned.\n * If the given string contains characters that are not valid characters for "}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefficients of a polynomial. xs [0] + xs [1] * x + xs [2] * x ^ 2 +.... return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* xs represent coefficients of a polynomial. xs [0] + xs [1] * x + xs [2] * x ^ 2 +.... return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < xs.length; i++) {\n    sum += xs[i] * xs[i];\n  }\n  return sum;\n};\n\n/* xs represent coefficients of a polynomial. xs [0] + xs [1] * x + xs [2] * x ^ 2 +.... return inverse of this polynomial in the same form.\n  >>> inverse([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> inverse([1, 2, 3])\n  [3, 1, 2, 4, 5]\n  */\nconst inverse = (xs) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < xs.length; i++) {\n    sum += xs[i] * xs[i];\n  }\n  return 1 / sum;\n};\n\n/* xs represent coefficients of a polynomial. xs [0] + xs [1] * x + xs [2] * x ^ 2 +.... return logarithm of this polynomial in the same form.\n  >>> log([3, 1, 2, 4, 5])\n  1.4426950408889634\n  >>> log([1, 2, 3])\n  1.4426950408889634\n  */\nconst log = (xs) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < xs.length; i++) {\n    sum += Math.log(xs[i]);\n  }\n  return sum;\n};\n\n/* xs represent coefficients of a polynomial. xs [0] + xs [1] * x + xs [2] * x ^ 2 +.... return natural logarithm of this polynomial in the same form.\n  >>> naturalLog([3, 1, 2, 4, 5])\n  1.4426950408889634\n  >>> naturalLog([1, 2, 3])\n  1.4426950408889634\n  */\nconst naturalLog = (xs) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < xs.length; i++) {\n    sum += Math.log(xs[i]);\n  }\n  return Math.log(sum);\n};\n\n/* xs represent coefficients of a polynomial. xs [0] + xs [1] * x + xs [2] * x ^ 2 +.... return hyperbolic sine of this polynomial in the same form.\n  >>> hyperbolicSine([3, 1, 2, 4, 5])\n  1.4426950408889634\n  >>> hyperbolicSine([1, 2, 3])\n  1.4426950408889634\n  */\nconst hyperbolicSine = (xs) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < xs.length; i++) {\n    sum += Math.sin(xs[i]);\n  }\n  return Math.sin(sum);\n};\n\n/* xs represent coefficients of a polynomial. xs [0] + xs [1] * x + xs [2] * x ^ 2 +.... return hyperbolic cosine of this polynomial in the same form.\n  >>> hyperbolicCosine([3, 1, 2, 4, 5])\n  1.4426950408889634\n  >>> hyperbolicCosine([1, 2, 3])\n  1.4426950408889634\n  */\nconst hyperbolicCosine = (xs) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < xs.length; i++) {\n    sum += Math.cos(xs[i]);\n  }\n  return Math.cos(sum);\n};\n\n/* xs represent coefficients of a polynomial. xs [0] + xs [1] * x + xs [2] * x ^ 2 +.... return hyperbolic tangent of this polynomial in the same form.\n  >>> hyperbolicTangent([3, 1, 2, 4, 5])\n  1.4426950408889634\n  >>> hyperbolicTangent([1, 2, 3])\n  1.4426950408889634\n  */\nconst hyperbolicTangent = (xs) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < xs.length; i++) {\n    sum += Math.tan(xs[i]);\n  }\n  return Math.tan(sum);\n};\n\n/* xs represent coefficients of a polynomial. xs [0] + xs [1] * x + xs [2] * x ^ 2 +.... return hyperbolic secant of this polynomial in the same form.\n  >>> hyperbolicSecant([3, 1, 2, 4, 5])\n  1.4426950408889634\n  >>> hyperbolicSecant([1, 2, 3])\n  1.4426950408889634\n  */\nconst hyperbolicSecant = (xs) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < xs.length; i++) {\n    sum += Math.sin(xs[i]) / Math.cos(xs[i]);\n  }\n  return Math.sin(sum) / Math.cos(sum);\n};\n\n/* xs represent coefficients of a polynomial. xs [0] + xs [1] * x + xs [2] * x ^ 2 +.... return hyperbolic cosecant of this polynomial in the same form.\n  >>> hyperbolicCosecant([3, 1, 2, 4, 5])\n  1.4426950408889634\n  >>> hyperbolicCosecant([1, 2, 3])\n  1.4426950408889634\n  */\nconst hyperbolicCosecant = (xs) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < xs.length; i++) {\n    sum += Math.cos(xs[i]) / Math.sin(xs[i]);\n  }\n  return Math.cos(sum) / Math.sin(sum);\n};\n\n/* xs represent coefficients of a polynomial. xs [0] + xs [1] * x + xs [2] * x ^ 2 +.... return hyperbolic cotangent of this polynomial in the same form.\n  >>> hyperbolicCotangent([3, 1, 2, 4, 5])\n  1.4426950408889634\n  >>> hyperbolicCotangent([1, 2, 3])\n  1.4426950408889634\n  */\nconst hyperbolicCotangent = (xs) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < xs.length; i++) {\n    sum += Math.tan(xs[i]) / Math.cos(xs[i]);\n  }\n  return Math.tan(sum) / Math.cos(sum);\n};\n\n/* xs represent coefficients of a polynomial. xs [0] + xs [1] * x + xs [2] * x ^ 2 +.... return hyperbolic secant of this polynomial in the same form.\n  >>> hyperbolicSecantCoefficient([3, 1, 2, 4, 5])\n  1.4426950408889634\n  >>> hyperbolicSecantCoefficient([1, 2, 3])\n  1.4426950408889634\n  */\nconst hyperbolicSecantCoefficient = (xs) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < xs.length; i++) {\n    sum += Math.sin(xs[i]) / Math.cos(xs[i]);\n  }\n  return Math.sin(sum) / Math.cos(sum);\n};\n\n/* xs represent coefficients of a polynomial. xs [0] + xs [1] * x + xs [2] * x ^ 2 +.... return hyperbolic cosecant of this polynomial in the same form.\n  >>> hyperbolicCosecantCoefficient([3, 1, 2, 4, 5])\n  1.4426950408889634\n  >>> hyperbolicCosecantCoefficient([1, 2, 3])\n  1.4426950408889634\n  */\nconst hyperbolicCosecantCoefficient = (xs) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < xs.length; i++) {\n    sum += Math.cos(xs[i]) / Math.sin(xs[i]);\n  }\n  return Math.cos(sum) / Math.sin(sum);\n};\n\n/* xs represent coefficients of a polynomial. xs [0] + xs [1] * x + xs [2] * x ^ 2 +.... return hyperbolic cotangent of this polynomial in the same form.\n  "}
{"task_id": "JavaScript/63", "prompt": "/*TThe FibFib number sequence is a sequence similar to the Fibbonacci sequence, which is defined as follows: fibfib (0) = = 0 fibfib (1) = = 0 fibfib (2) = = 1 fibfib (n) = fibfib (n-1) + fibfib (n-2) + fibfib (n-3). Please write a function to efficiently calculate the nth element of the FibFib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*TThe FibFib number sequence is a sequence similar to the Fibbonacci sequence, which is defined as follows: fibfib (0) = = 0 fibfib (1) = = 0 fibfib (2) = = 1 fibfib (n) = fibfib (n-1) + fibfib (n-2) + fibfib (n-3). Please write a function to efficiently calculate the nth element of the FibFib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;\n\n},{}],3:[function(require,module,exports){\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;\n\n},{}],4:[function(require,module,exports){\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;\n\n},{}],5:[function(require,module,exports){\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;\n\n},{}],6:[function(require,module,exports){\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;\n\n},{}],7:[function(require,module,exports){\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;\n\n},{}],8:[function(require,module,exports){\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;\n\n},{}],9:[function(require,module,exports){\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;\n\n},{}],10:[function(require,module,exports){\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;\n\n},{}],11:[function(require,module,exports){\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;\n\n},{}],12:[function(require,module,exports){\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;\n\n},{}],13:[function(require,module,exports){\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;\n\n},{}],14:[function(require,module,exports){\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;\n\n},{}],15:[function(require,module,exports){\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;\n\n},{}],16:[function(require,module,exports){\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;\n\n},{}],17:[function(require,module,exports){\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;\n\n},{}],18:[function(require,module,exports){\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;\n\n},{}],19:[function(require,module,exports){\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;\n\n},{}],20:[function(require,module,exports){\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;\n\n},{}],21:[function(require,module,exports){\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;\n\n},{}],22:[function(require,module,exports){\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;\n\n},{}],23:[function(require,module,exports){\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;\n\n},{}],24:[function(require,module,exports){\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;\n\n},{}],25:[function(require,module,exports){\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;\n\n},{}],26:[function(require,module,exports){\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;\n\n},{}],27:[function(require,module,exports){\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;\n\n},{}],28:[function(require,module,exports){\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nmodule.exports = fibfib;\n\n},{}],"}
{"task_id": "JavaScript/64", "prompt": "/*Write is a vowel count function that takes a string that represents a word as input and returns the number of vowels in the string. In this case, vowels are \"a,\" \"e,\" \"i,\" \"o,\" \"u.\" Again, \"y\" is a vowel, but only if it is at the end of the given word. Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Write is a vowel count function that takes a string that represents a word as input and returns the number of vowels in the string. In this case, vowels are \"a,\" \"e,\" \"i,\" \"o,\" \"u.\" Again, \"y\" is a vowel, but only if it is at the end of the given word. Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  \n  for(let i = 0; i < s.length; i++) {\n    if(s.charAt(i) === lastVowel) {\n      vowels++;\n    }\n  }\n  return vowels;\n};\n\n/*Write a function that takes an array of strings and returns the number of unique words in the array. For example:\n  >>> uniqueWords([\n  \"apple\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\",\n  \"banana\","}
{"task_id": "JavaScript/65", "prompt": "/*Circular displacement of digits of integer x, displacement of digits to the right by displacing and returning the result as a string. If displacement > number of digits, return the digits inversely.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Circular displacement of digits of integer x, displacement of digits to the right by displacing and returning the result as a string. If displacement > number of digits, return the digits inversely.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  let digits = x.toString().split('')\n  let result = digits\n   .slice(digits.length - shift, digits.length)\n   .join('')\n  return result\n}\n\n/*\n  >>> circularShift(1, 2)\n  \"11\"\n  >>> circularShift(1, 3)\n  \"10\"\n  >>> circularShift(1, 4)\n  \"01\"\n  >>> circularShift(1, 5)\n  \"11\"\n  >>> circularShift(1, 6)\n  \"10\"\n  >>> circularShift(1, 7)\n  \"01\"\n  >>> circularShift(1, 8)\n  \"11\"\n  >>> circularShift(1, 9)\n  \"10\"\n  >>> circularShift(1, 10)\n  \"01\"\n  >>> circularShift(1, 11)\n  \"11\"\n  >>> circularShift(1, 12)\n  \"10\"\n  >>> circularShift(1, 13)\n  \"01\"\n  >>> circularShift(1, 14)\n  \"11\"\n  >>> circularShift(1, 15)\n  \"10\"\n  >>> circularShift(1, 16)\n  \"01\"\n  >>> circularShift(1, 17)\n  \"11\"\n  >>> circularShift(1, 18)\n  \"10\"\n  >>> circularShift(1, 19)\n  \"01\"\n  >>> circularShift(1, 20)\n  \"11\"\n  >>> circularShift(1, 21)\n  \"10\"\n  >>> circularShift(1, 22)\n  \"01\"\n  >>> circularShift(1, 23)\n  \"11\"\n  >>> circularShift(1, 24)\n  \"10\"\n  >>> circularShift(1, 25)\n  \"01\"\n  >>> circularShift(1, 26)\n  \"11\"\n  >>> circularShift(1, 27)\n  \"10\"\n  >>> circularShift(1, 28)\n  \"01\"\n  >>> circularShift(1, 29)\n  \"11\"\n  >>> circularShift(1, 30)\n  \"10\"\n  >>> circularShift(1, 31)\n  \"01\"\n  >>> circularShift(1, 32)\n  \"11\"\n  >>> circularShift(1, 33)\n  \"10\"\n  >>> circularShift(1, 34)\n  \"01\"\n  >>> circularShift(1, 35)\n  \"11\"\n  >>> circularShift(1, 36)\n  \"10\"\n  >>> circularShift(1, 37)\n  \"01\"\n  >>> circularShift(1, 38)\n  \"11\"\n  >>> circularShift(1, 39)\n  \"10\"\n  >>> circularShift(1, 40)\n  \"01\"\n  >>> circularShift(1, 41)\n  \"11\"\n  >>> circularShift(1, 42)\n  \"10\"\n  >>> circularShift(1, 43)\n  \"01\"\n  >>> circularShift(1, 44)\n  \"11\"\n  >>> circularShift(1, 45)\n  \"10\"\n  >>> circularShift(1, 46)\n  \"01\"\n  >>> circularShift(1, 47)\n  \"11\"\n  >>> circularShift(1, 48)\n  \"10\"\n  >>> circularShift(1, 49)\n  \"01\"\n  >>> circularShift(1, 50)\n  \"11\"\n  >>> circularShift(1, 51)\n  \"10\"\n  >>> circularShift(1, 52)\n  \"01\"\n  >>> circularShift(1, 53)\n  \"11\"\n  >>> circularShift(1, 54)\n  \"10\"\n  >>> circularShift(1, 55)\n  \"01\"\n  >>> circularShift(1, 56)\n  \"11\"\n  >>> circularShift(1, 57)\n  \"10\"\n  >>> circularShift(1, 58)\n  \"01\"\n  >>> circularShift(1, 59)\n  \"11\"\n  >>> circularShift(1, 60)\n  \"10\"\n  >>> circularShift(1, 61)\n  \"01\"\n  >>> circularShift(1, 62)\n  \"11\"\n  >>> circularShift(1, 63)\n  \"10\"\n  >>> circularShift(1, 64)\n  \"01\"\n  >>> circularShift(1, 65)\n  \"11\"\n  >>> circularShift(1, 66)\n  \"10\"\n  >>> circularShift(1, 67)\n  \"01\"\n  >>> circularShift(1, 68)\n  \"11\"\n  >>> circularShift(1, 69)\n  \"10\"\n  >>> circularShift(1, 70)\n  \"01\"\n  >>> circularShift(1, 71)\n  \"11\"\n  >>> circularShift(1, 72)\n  \"10\"\n  >>> circularShift(1, 73)\n  \"01\"\n  >>> circularShift(1, 74)\n  \"11\"\n  >>> circularShift(1, 75)\n  \"10\"\n  >>> circularShift(1, 76)\n  \"01\"\n  >>> circularShift(1, 77)\n  \"11\"\n  >>> circularShift(1, 78)\n  \"10\"\n  >>> circularShift(1, 79)\n  \"01\"\n  >>> circularShift(1, 80)\n  \"11\"\n  >>> circularShift(1, 81)\n  \"10\"\n  >>> circularShift(1, 82)\n  \"01\"\n  >>> circularShift(1, 83)\n  \"11\"\n  >>> circularShift(1, 84)\n  \"10\"\n  >>> circularShift(1, 85)\n  \"01\"\n  >>> circularShift(1, 86)\n  \"11\"\n  >>> circularShift(1, 87)\n  \"10\"\n  >>> circularShift(1, 88)\n  \"01\"\n  >>> circularShift(1, 89)\n  \"11\"\n  >>> circularShift(1, 90)\n  \"10\"\n  >>> circularShift(1, 91)\n  \"01\"\n  >>> circularShift(1, 92)\n  \"11\"\n  >>> circularShift(1, 93)\n  \"10\"\n  >>> circularShift(1, 94)\n  \"01\"\n  >>> circularShift(1, 95)\n  \"11\"\n  >>> circularShift(1, 96)\n  \"10\"\n  >>> circularShift(1, 97)\n  \"01\"\n  >>> circularShift(1, 98)\n  \"11\"\n  >>> circularShift(1, 99)\n  \"10\"\n  >>> circularShift(1, 100)\n  \"01\"\n  >>> circularShift(1, 101)\n  \"11\"\n  >>> circularShift(1, 102)\n  \"10\"\n  >>> circularShift(1, 103)\n  \"01\"\n  >>> circularShift(1, 104)\n  \"11\"\n  >>> circularShift(1, 105)\n  \"10\"\n  >>> circularShift(1, 106)\n  \"01\"\n  >>> circularShift(1, 107)\n  \"11\"\n  >>> circularShift(1, 108)\n  \"10\"\n  >>> circularShift(1, 109)\n  \"01\"\n  >>> circularShift(1, 110)\n  \"11\"\n  >>> circularShift(1, 111)\n  \"10\"\n  >>> circularShift(1, 112)\n  \"01\"\n  >>> circularShift(1, 113)\n  \"11\"\n  >>> circularShift(1, 114)\n  \""}
{"task_id": "JavaScript/66", "prompt": "/*Task Writes a function that takes a string as input and returns only the sum of the upper letters of 'ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Task Writes a function that takes a string as input and returns only the sum of the upper letters of 'ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 32;\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the lower letters of 'ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSumLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 32;\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the upper and lower case letters of 'ASCII codes.\n\n  Examples:\n      digitSumLower(\"\") => 0\n      digitSumLower(\"abAB\") => 131\n      digitSumLower(\"abcCd\") => 67\n      digitSumLower(\"helloE\") => 69\n      digitSumLower(\"woArBld\") => 131\n      digitSumLower(\"aAaaaXa\") => 153\n  */\nconst digitSumLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 32;\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the digits of 'ASCII codes.\n\n  Examples:\n      digitSumDigit(\"\") => 0\n      digitSumDigit(\"abAB\") => 131\n      digitSumDigit(\"abcCd\") => 67\n      digitSumDigit(\"helloE\") => 69\n      digitSumDigit(\"woArBld\") => 131\n      digitSumDigit(\"aAaaaXa\") => 153\n  */\nconst digitSumDigit = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 48;\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the digits of 'ASCII codes.\n\n  Examples:\n      digitSumDigit(\"\") => 0\n      digitSumDigit(\"abAB\") => 131\n      digitSumDigit(\"abcCd\") => 67\n      digitSumDigit(\"helloE\") => 69\n      digitSumDigit(\"woArBld\") => 131\n      digitSumDigit(\"aAaaaXa\") => 153\n  */\nconst digitSumDigitLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 48;\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the digits of 'ASCII codes.\n\n  Examples:\n      digitSumDigitLower(\"\") => 0\n      digitSumDigitLower(\"abAB\") => 131\n      digitSumDigitLower(\"abcCd\") => 67\n      digitSumDigitLower(\"helloE\") => 69\n      digitSumDigitLower(\"woArBld\") => 131\n      digitSumDigitLower(\"aAaaaXa\") => 153\n  */\nconst digitSumDigitLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 48;\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the digits of 'ASCII codes.\n\n  Examples:\n      digitSumDigit(\"\") => 0\n      digitSumDigit(\"abAB\") => 131\n      digitSumDigit(\"abcCd\") => 67\n      digitSumDigit(\"helloE\") => 69\n      digitSumDigit(\"woArBld\") => 131\n      digitSumDigit(\"aAaaaXa\") => 153\n  */\nconst digitSumDigitLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 48;\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the digits of 'ASCII codes.\n\n  Examples:\n      digitSumDigit(\"\") => 0\n      digitSumDigit(\"abAB\") => 131\n      digitSumDigit(\"abcCd\") => 67\n      digitSumDigit(\"helloE\") => 69\n      digitSumDigit(\"woArBld\") => 131\n      digitSumDigit(\"aAaaaXa\") => 153\n  */\nconst digitSumDigitLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 48;\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the digits of 'ASCII codes.\n\n  Examples:\n      digitSumDigit(\"\") => 0\n      digitSumDigit(\"abAB\") => 131\n      digitSumDigit(\"abcCd\") => 67\n      digitSumDigit(\"helloE\") => 69\n      digitSumDigit(\"woArBld\") => 131\n      digitSumDigit(\"aAaaaXa\") => 153\n  */\nconst digitSumDigitLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 48;\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the digits of 'ASCII codes.\n\n  Examples:\n      digitSumDigit(\"\") => 0\n      digitSumDigit(\"abAB\") => 131\n      digitSumDigit(\"abcCd\") => 67\n      digitSumDigit(\"helloE\") => 69\n      digitSumDigit(\"woArBld\") => 131\n      digitSumDigit(\"aAaaaXa\") => 153\n  */\nconst digitSumDigitLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 48;\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the digits of 'ASCII codes.\n\n  Examples:\n      digitSumDigit(\"\") => 0\n      digitSumDigit(\"abAB\") => 131\n      digitSumDigit(\"abcCd\") => 67\n      digitSumDigit(\"helloE\") => 69\n      digitSumDigit(\"woArBld\") => 131\n      digitSumDigit(\"aAaaaXa\") => 153\n  */\nconst digitSumDigitLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 48;\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the digits of 'ASCII codes.\n\n  Examples:\n      digitSumDigit(\"\") => 0\n      digitSumDigit(\"abAB\") => 131\n      digit"}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let totalApples = 0, totalOranges = 0, totalMango = 0;\n  let fruits = n.split(\" \");\n  for (let i = 0; i < fruits.length; i++) {\n    if (fruits[i].includes(\"apples\")) {\n      totalApples += parseInt(fruits[i].split(\" \")[0]);\n    } else if (fruits[i].includes(\"oranges\")) {\n      totalOranges += parseInt(fruits[i].split(\" \")[0]);\n    } else if (fruits[i].includes(\"mango\")) {\n      totalMango += parseInt(fruits[i].split(\" \")[0]);\n    }\n  }\n  return totalApples - totalOranges - totalMango;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let totalApples = 0, totalOranges = 0, totalMango = 0;\n  let fruits = n.split(\" \");\n  for (let i = 0; i < fruits.length; i++) {\n    if (fruits[i].includes(\"apples\")) {\n      totalApples += parseInt(fruits[i].split(\" \")[0]);\n    } else if (fruits[i].includes(\"oranges\")) {\n      totalOranges += parseInt(fruits[i].split(\" \")[0]);\n    } else if (fruits[i].includes(\"mango\")) {\n      totalMango += parseInt(fruits[i].split(\" \")[0]);\n    }\n  }\n  return totalApples - totalOranges - totalMango;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let totalApples = 0, totalOranges = 0, totalMango = 0;\n  let fruits = n.split(\" \");\n  for (let i = 0; i < fruits.length; i++) {\n    if (fruits[i].includes(\"apples\")) {\n      totalApples += parseInt(fruits[i].split(\" \")[0]);\n    } else if (fruits[i].includes(\"oranges\")) {\n      totalOranges += parseInt(fruits[i].split(\" \")[0]);\n    } else if (fruits[i].includes(\"mango\")) {\n      totalMango += parseInt(fruits[i].split(\" \")[0]);\n    }\n  }\n  return totalApples - totalOranges - totalMango;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let totalApples = 0, totalOranges = 0, totalMango = 0;\n  let fruits = n.split(\" \");\n  for (let i = 0; i < fruits.length; i++) {\n    if (fruits[i].includes(\"apples\")) {\n      totalApples += parseInt(fruits[i].split(\" \")[0]);\n    } else if (fruits[i].includes(\"oranges\")) {\n      totalOranges += parseInt(fruits[i].split(\" \")[0]);\n    } else if (fruits[i].includes(\"mango\")) {\n      totalMango += parseInt(fruits[i].split(\" \")[0]);\n    }\n  }\n  return totalApples - totalOranges - totalMango;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let totalApples = 0, totalOranges = 0, totalMango = 0;\n  let fruits = n.split(\" \");\n  for (let i = 0; i < fruits.length; i++) {\n    if (fruits[i].includes(\"apples\")) {\n      totalApples += parseInt(fruits[i].split(\" \")[0]);\n    } else if (fruits[i].includes(\"oranges\")) {\n      totalOranges += parseInt(fruits[i].split(\" \")[0]);\n    } else if (fruits[i].includes(\"mango\")) {\n      totalMango += parseInt(fruits[i].split(\" \")[0]);\n    }\n  }\n  return totalApples - totalOranges - totalMango;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", "}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to pluck one of the nodes and return it.\n  The plucked node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The plucked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to pluck one of the nodes and return it.\n  The plucked node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The plucked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const len = arr.length;\n  let i = 0;\n  let min = 0;\n  let max = 0;\n  while (i < len) {\n    if (arr[i] % 2 === 0) {\n      min = Math.min(min, i);\n      max = Math.max(max, i);\n    }\n    i++;\n  }\n  return [arr[min], max];\n};\n\n// Given an array representing a tree with non-negative integer nodes,\n// your task is to return the minimum number of nodes that can reach the root.\n// The minimum number of nodes that can reach the root is the sum of all node values.\n// If the tree is empty, return 0.\n// If the tree has one node with value 0, return 1.\n// If the tree has two nodes with values 0 and 1, return 2.\n// If the tree has three nodes with values 0, 1, and 2, return 3.\n// If the tree has four nodes with values 0, 1, and 2, 3, 4, and 5, return 5.\n// If the tree has five nodes with values 0, 1, and 2, 3, 4, and 5, 6, 7, 8, 9, and 10, return 15.\n// If the tree has six nodes with values 0, 1, and 2, 3, 4, and 5, 6, 7, 8, 9, and 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 424, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 5"}
{"task_id": "JavaScript/69", "prompt": "/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest "}
{"task_id": "JavaScript/70", "prompt": "/*\n  Strange sorting is when you start with the minimum, then with the maximum of the remaining integers, then with the minimum, and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Strange sorting is when you start with the minimum, then with the maximum of the remaining integers, then with the minimum, and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  let min;\n  let max;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let i;\n\n  min = lst[0];\n  max = lst[0];\n  minIndex = 0;\n  maxIndex = 0;\n\n  for (i = 1; i < lst.length; i++) {\n    if (lst[i] < min) {\n      min = lst[i];\n      minIndex = i;\n    }\n\n    if (lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n\n  min = lst[minIndex];\n  max = lst[maxIndex];\n\n  minValue = lst[minIndex];\n  maxValue = lst[maxIndex];\n\n  if (min === max) {\n    return lst;\n  }\n\n  if (min > max) {\n    swap(lst[minIndex], lst[maxIndex]);\n    return strangeSortList(lst);\n  }\n\n  if (min < max) {\n    swap(lst[maxIndex], lst[minIndex]);\n    return strangeSortList(lst);\n  }\n\n  return [min, max];\n};\n\n/*\n  Given a sorted array and a target value, return the index of the target value if it is in the sorted array. Otherwise, return -1.\n  Example:\n  findTarget([5, 3, 1, 2, 4], 5) == 3\n  findTarget([5, 3, 1, 2, 4], 4) == -1\n  findTarget([5, 3, 1, 2, 4], 3) == -1\n  findTarget([5, 3, 1, 2, 4], 2) == -1\n  findTarget([5, 3, 1, 2, 4], 1) == -1\n  findTarget([5, 3, 1, 2, 4], 0) == -1\n*/\nconst findTarget = (lst, target) => {\n  let i;\n  let j;\n  let found;\n\n  for (i = 0; i < lst.length; i++) {\n    for (j = 0; j < lst.length; j++) {\n      if (lst[i] === target && lst[j] === target) {\n        found = i;\n        break;\n      }\n    }\n\n    if (found === -1) {\n      return -1;\n    }\n  }\n\n  return found;\n};\n\n/*\n  Given a sorted array and a target value, return the index of the target value if it is in the sorted array. Otherwise, return -1.\n  Example:\n  findTarget([5, 3, 1, 2, 4], 5) == 3\n  findTarget([5, 3, 1, 2, 4], 4) == -1\n  findTarget([5, 3, 1, 2, 4], 3) == -1\n  findTarget([5, 3, 1, 2, 4], 2) == -1\n  findTarget([5, 3, 1, 2, 4], 1) == -1\n  findTarget([5, 3, 1, 2, 4], 0) == -1\n*/\nconst findIndex = (lst, target) => {\n  let i;\n  let j;\n  let found;\n\n  for (i = 0; i < lst.length; i++) {\n    for (j = 0; j < lst.length; j++) {\n      if (lst[i] === target && lst[j] === target) {\n        found = i;\n        break;\n      }\n    }\n\n    if (found === -1) {\n      return -1;\n    }\n  }\n\n  return found;\n};\n\n/*\n  Given a sorted array and a target value, return the index of the target value if it is in the sorted array. Otherwise, return -1.\n  Example:\n  findTarget([5, 3, 1, 2, 4], 5) == 3\n  findTarget([5, 3, 1, 2, 4], 4) == -1\n  findTarget([5, 3, 1, 2, 4], 3) == -1\n  findTarget([5, 3, 1, 2, 4], 2) == -1\n  findTarget([5, 3, 1, 2, 4], 1) == -1\n  findTarget([5, 3, 1, 2, 4], 0) == -1\n*/\nconst findValue = (lst, target) => {\n  let i;\n  let j;\n  let found;\n\n  for (i = 0; i < lst.length; i++) {\n    for (j = 0; j < lst.length; j++) {\n      if (lst[i] === target && lst[j] === target) {\n        found = i;\n        break;\n      }\n    }\n\n    if (found === -1) {\n      return -1;\n    }\n  }\n\n  return found;\n};\n\n/*\n  Given a sorted array and a target value, return the index of the target value if it is in the sorted array. Otherwise, return -1.\n  Example:\n  findTarget([5, 3, 1, 2, 4], 5) == 3\n  findTarget([5, 3, 1, 2, 4], 4) == -1\n  findTarget([5, 3, 1, 2, 4], 3) == -1\n  findTarget([5, 3, 1, 2, 4], 2) == -1\n  findTarget([5, 3, 1, 2, 4], 1) == -1\n  findTarget([5, 3, 1, 2, 4], 0) == -1\n*/\nconst findIndexValue = (lst, target) => {\n  let i;\n  let j;\n  let found;\n\n  for (i = 0; i < lst.length; i++) {\n    for (j = 0; j < lst.length; j++) {\n      if (lst[i] === target && lst[j] === target) {\n        found = i;\n        break;\n      }\n    }\n\n    if (found === -1) {\n      return -1;\n    }\n  }\n\n  return found;\n};\n\n/*\n  Given a sorted array and a target value, return the index of the target value if it is in the sorted array. Otherwise, return -1.\n  Example:\n  findTarget([5, 3, 1, 2, 4], 5) == 3\n  findTarget([5, 3, 1, 2, 4], 4) == -1\n  findTarget([5, 3, 1, 2, 4], 3) == -1\n  findTarget([5, 3, 1, 2, 4], 2) == -1\n  findTarget([5, 3, 1, 2, 4], 1) == -1\n  findTarget([5, 3, 1, 2, 4], 0) == -1\n*/\nconst findIndexValueIndex = (lst, target) => {\n  let i;\n  let j;\n  let found;\n\n  for (i = 0; i < lst.length; i++) {\n    for (j = 0; j < lst.length; j++) {\n      if (lst[i] === target && lst[j] === target) {\n        found = i;\n        break;\n      }\n    }\n\n    if (found === -1) {\n      return -1;\n    }\n  }\n\n  return found;\n};\n\n/*\n  Given a sorted array and a target value, return the index of the target value if it is in the sorted array. Otherwise, return -1.\n  Example:\n  findTarget([5, 3, 1, 2, 4], 5) == 3\n  findTarget([5, 3, 1, 2, 4], 4) == -1\n  findTarget([5, 3, 1, 2, 4], 3) == -1\n  findTarget([5, 3, 1, 2, 4], 2) == -1\n  findTarget([5, 3, 1, 2, 4], 1) == -1\n  findTarget([5, 3, 1, 2, 4], 0) == -1\n*/\nconst findIndexValueIndexValue = (lst, target) => {\n  let i;\n  let j;\n  let found;\n\n  for (i = 0; i < lst.length; i++) {\n    for (j = 0; j < lst.length; j++) {\n      if (lst[i] === target && lst[j] === target) {\n        found = i;\n        break;\n      }\n    }\n\n    if (found === -1) {\n      return -1;\n    }\n  }\n\n  return found;\n};\n\n/*\n  Given a sorted array and a target value, return the index of the target value if it is in the sorted array. Otherwise, return -1.\n  Example:\n  findTarget([5, 3, 1, 2, 4], 5) == 3\n  findTarget([5, 3, 1, 2, 4], 4) == -1\n  findTarget([5, 3, 1, 2, 4], 3) == -1\n  findTarget([5, 3, 1, 2, 4], 2) == -1\n  findTarget([5, 3, 1, 2, 4], 1) == -1\n  findTarget([5, 3, 1, 2, 4], 0) == -1\n*/\nconst findIndexValueIndexValueIndex = (lst, target) => {\n  let i;\n  let j;\n  let found;\n\n  for (i = 0; i < lst.length; i++) {\n    for (j = 0; j < lst.length; j++) {\n      if (lst[i] === target && lst[j] === target) {\n        found = i;\n        break;\n      }\n    }\n\n    if (found === -1) {\n      return -1;\n    }\n  }\n\n  return found;\n};\n\n/*\n  Given a sorted array and a target value, return the index of the target value if it is in the sorted array. Otherwise, return -1.\n  Example:\n  findTarget([5, 3, 1, 2, 4], 5) == 3\n  findTarget([5, 3, 1, 2, 4], 4) == -1\n  "}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the length of the three sides of a triangle. Return the area of the triangle rounded to 2 decimal points if the three sides form a valid triangle. Otherwise, return -1 Three sides a valid triangle if the sum of two sides is greater than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given the length of the three sides of a triangle. Return the area of the triangle rounded to 2 decimal points if the three sides form a valid triangle. Otherwise, return -1 Three sides a valid triangle if the sum of two sides is greater than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  const sideA = Math.sqrt(a * a + b * b);\n  const sideB = Math.sqrt(a * a + c * c);\n  const sideC = Math.sqrt(b * b + c * c);\n\n  if (sideA > sideB || sideB > sideC || sideC > sideA) {\n    return -1;\n  }\n\n  return sideA + sideB + sideC;\n};\n\n/*\n  Given the length of the three sides of a rectangle. Return the area of the rectangle rounded to 2 decimal points if the three sides form a valid rectangle. Otherwise, return -1 Three sides a valid rectangle if the sum of two sides is greater than the third side.\n  Example:\n  rectangleArea(3, 4, 5) == 6.00\n  rectangleArea(1, 2, 10) == -1\n  */\nconst rectangleArea = (a, b, c) => {\n  const sideA = Math.sqrt(a * a + b * b);\n  const sideB = Math.sqrt(a * a + c * c);\n  const sideC = Math.sqrt(b * b + c * c);\n\n  if (sideA > sideB || sideB > sideC || sideC > sideA) {\n    return -1;\n  }\n\n  return sideA + sideB + sideC;\n};\n\n/*\n  Given the length of the three sides of a circle. Return the area of the circle rounded to 2 decimal points if the three sides form a valid circle. Otherwise, return -1 Three sides a valid circle if the sum of two sides is greater than the third side.\n  Example:\n  circleArea(3, 4, 5) == 6.00\n  circleArea(1, 2, 10) == -1\n  */\nconst circleArea = (a, b, c) => {\n  const sideA = Math.sqrt(a * a + b * b);\n  const sideB = Math.sqrt(a * a + c * c);\n  const sideC = Math.sqrt(b * b + c * c);\n\n  if (sideA > sideB || sideB > sideC || sideC > sideA) {\n    return -1;\n  }\n\n  return sideA + sideB + sideC;\n};\n\n/*\n  Given the length of the three sides of a square. Return the area of the square rounded to 2 decimal points if the three sides form a valid square. Otherwise, return -1 Three sides a valid square if the sum of two sides is greater than the third side.\n  Example:\n  squareArea(3, 4, 5) == 6.00\n  squareArea(1, 2, 10) == -1\n  */\nconst squareArea = (a, b, c) => {\n  const sideA = Math.sqrt(a * a + b * b);\n  const sideB = Math.sqrt(a * a + c * c);\n  const sideC = Math.sqrt(b * b + c * c);\n\n  if (sideA > sideB || sideB > sideC || sideC > sideA) {\n    return -1;\n  }\n\n  return sideA + sideB + sideC;\n};\n\n/*\n  Given the length of the three sides of a pentagon. Return the area of the pentagon rounded to 2 decimal points if the three sides form a valid pentagon. Otherwise, return -1 Three sides a valid pentagon if the sum of two sides is greater than the third side.\n  Example:\n  pentagonArea(3, 4, 5) == 6.00\n  pentagonArea(1, 2, 10) == -1\n  */\nconst pentagonArea = (a, b, c) => {\n  const sideA = Math.sqrt(a * a + b * b);\n  const sideB = Math.sqrt(a * a + c * c);\n  const sideC = Math.sqrt(b * b + c * c);\n\n  if (sideA > sideB || sideB > sideC || sideC > sideA) {\n    return -1;\n  }\n\n  return sideA + sideB + sideC;\n};\n\n/*\n  Given the length of the three sides of a hexagon. Return the area of the hexagon rounded to 2 decimal points if the three sides form a valid hexagon. Otherwise, return -1 Three sides a valid hexagon if the sum of two sides is greater than the third side.\n  Example:\n  hexagonArea(3, 4, 5) == 6.00\n  hexagonArea(1, 2, 10) == -1\n  */\nconst hexagonArea = (a, b, c) => {\n  const sideA = Math.sqrt(a * a + b * b);\n  const sideB = Math.sqrt(a * a + c * c);\n  const sideC = Math.sqrt(b * b + c * c);\n\n  if (sideA > sideB || sideB > sideC || sideC > sideA) {\n    return -1;\n  }\n\n  return sideA + sideB + sideC;\n};\n\n/*\n  Given the length of the three sides of a heptagon. Return the area of the heptagon rounded to 2 decimal points if the three sides form a valid heptagon. Otherwise, return -1 Three sides a valid heptagon if the sum of two sides is greater than the third side.\n  Example:\n  heptagonArea(3, 4, 5) == 6.00\n  heptagonArea(1, 2, 10) == -1\n  */\nconst heptagonArea = (a, b, c) => {\n  const sideA = Math.sqrt(a * a + b * b);\n  const sideB = Math.sqrt(a * a + c * c);\n  const sideC = Math.sqrt(b * b + c * c);\n\n  if (sideA > sideB || sideB > sideC || sideC > sideA) {\n    return -1;\n  }\n\n  return sideA + sideB + sideC;\n};\n\n/*\n  Given the length of the three sides of a decagon. Return the area of the decagon rounded to 2 decimal points if the three sides form a valid decagon. Otherwise, return -1 Three sides a valid decagon if the sum of two sides is greater than the third side.\n  Example:\n  decagonArea(3, 4, 5) == 6.00\n  decagonArea(1, 2, 10) == -1\n  */\nconst decagonArea = (a, b, c) => {\n  const sideA = Math.sqrt(a * a + b * b);\n  const sideB = Math.sqrt(a * a + c * c);\n  const sideC = Math.sqrt(b * b + c * c);\n\n  if (sideA > sideB || sideB > sideC || sideC > sideA) {\n    return -1;\n  }\n\n  return sideA + sideB + sideC;\n};\n\n/*\n  Given the length of the three sides of a helix. Return the area of the helix rounded to 2 decimal points if the three sides form a valid helix. Otherwise, return -1 Three sides a valid helix if the sum of two sides is greater than the third side.\n  Example:\n  helixArea(3, 4, 5) == 6.00\n  helixArea(1, 2, 10) == -1\n  */\nconst helixArea = (a, b, c) => {\n  const sideA = Math.sqrt(a * a + b * b);\n  const sideB = Math.sqrt(a * a + c * c);\n  const sideC = Math.sqrt(b * b + c * c);\n\n  if (sideA > sideB || sideB > sideC || sideC > sideA) {\n    return -1;\n  }\n\n  return sideA + sideB + sideC;\n};\n\n/*\n  Given the length of the three sides of a octagon. Return the area of the octagon rounded to 2 decimal points if the three sides form a valid octagon. Otherwise, return -1 Three sides a valid octagon if the sum of two sides is greater than the third side.\n  Example:\n  octagonArea(3, 4, 5) == 6.00\n  octagonArea(1, 2, 10) == -1\n"}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a function that returns true when the object q flies, and false otherwise. If the object q flies when it is balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that returns true when the object q flies, and false otherwise. If the object q flies when it is balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const [head,...tail] = q;\n  const isBalanced = head === tail.reduce((acc, curr) => acc + curr, 0);\n  return isBalanced >= w;\n};\n\nmodule.exports = willItFly;\n\n},{}],17:[function(require,module,exports){\nconst willItFly = require('./willItFly');\n\nconst willItFlyWithWeight = (q, w) => {\n  return willItFly(q, w) && willItFlyWithWeight(q.slice(1), w);\n};\n\nmodule.exports = willItFlyWithWeight;\n\n},{\"./willItFly\":16}],18:[function(require,module,exports){\nconst willItFly = require('./willItFly');\n\nconst willItFlyWithWeight = (q, w) => {\n  return willItFly(q, w) && willItFlyWithWeight(q.slice(0, -1), w);\n};\n\nmodule.exports = willItFlyWithWeight;\n\n},{\"./willItFly\":16}],19:[function(require,module,exports){\nconst willItFly = require('./willItFly');\n\nconst willItFlyWithWeight = (q, w) => {\n  return willItFly(q, w) && willItFlyWithWeight(q.slice(1), w);\n};\n\nmodule.exports = willItFlyWithWeight;\n\n},{\"./willItFly\":16}],20:[function(require,module,exports){\nconst willItFly = require('./willItFly');\n\nconst willItFlyWithWeight = (q, w) => {\n  return willItFly(q, w) && willItFlyWithWeight(q.slice(0, -1), w);\n};\n\nmodule.exports = willItFlyWithWeight;\n\n},{\"./willItFly\":16}],21:[function(require,module,exports){\nconst willItFly = require('./willItFly');\n\nconst willItFlyWithWeight = (q, w) => {\n  return willItFly(q, w) && willItFlyWithWeight(q.slice(1), w);\n};\n\nmodule.exports = willItFlyWithWeight;\n\n},{\"./willItFly\":16}],22:[function(require,module,exports){\nconst willItFly = require('./willItFly');\n\nconst willItFlyWithWeight = (q, w) => {\n  return willItFly(q, w) && willItFlyWithWeight(q.slice(0, -1), w);\n};\n\nmodule.exports = willItFlyWithWeight;\n\n},{\"./willItFly\":16}],23:[function(require,module,exports){\nconst willItFly = require('./willItFly');\n\nconst willItFlyWithWeight = (q, w) => {\n  return willItFly(q, w) && willItFlyWithWeight(q.slice(1), w);\n};\n\nmodule.exports = willItFlyWithWeight;\n\n},{\"./willItFly\":16}],24:[function(require,module,exports){\nconst willItFly = require('./willItFly');\n\nconst willItFlyWithWeight = (q, w) => {\n  return willItFly(q, w) && willItFlyWithWeight(q.slice(0, -1), w);\n};\n\nmodule.exports = willItFlyWithWeight;\n\n},{\"./willItFly\":16}],25:[function(require,module,exports){\nconst willItFly = require('./willItFly');\n\nconst willItFlyWithWeight = (q, w) => {\n  return willItFly(q, w) && willItFlyWithWeight(q.slice(1), w);\n};\n\nmodule.exports = willItFlyWithWeight;\n\n},{\"./willItFly\":16}],26:[function(require,module,exports){\nconst willItFly = require('./willItFly');\n\nconst willItFlyWithWeight = (q, w) => {\n  return willItFly(q, w) && willItFlyWithWeight(q.slice(0, -1), w);\n};\n\nmodule.exports = willItFlyWithWeight;\n\n},{\"./willItFly\":16}],27:[function(require,module,exports){\nconst willItFly = require('./willItFly');\n\nconst willItFlyWithWeight = (q, w) => {\n  return willItFly(q, w) && willItFlyWithWeight(q.slice(1), w);\n};\n\nmodule.exports = willItFlyWithWeight;\n\n},{\"./willItFly\":16}],28:[function(require,module,exports){\nconst willItFly = require('./willItFly');\n\nconst willItFlyWithWeight = (q, w) => {\n  return willItFly(q, w) && willItFlyWithWeight(q.slice(0, -1), w);\n};\n\nmodule.exports = willItFlyWithWeight;\n\n},{\"./willItFly\":16}],29:[function(require,module,exports){\nconst willItFly = require('./willItFly');\n\nconst willItFlyWithWeight = (q, w) => {\n  return willItFly(q, w) && willItFlyWithWeight(q.slice(1), w);\n};\n\nmodule.exports = willItFlyWithWeight;\n\n},{\"./willItFly\":16}],30:[function(require,module,exports){\nconst willItFly = require('./willItFly');\n\nconst willItFlyWithWeight = (q, w) => {\n  return willItFly(q, w) && willItFlyWithWeight(q.slice(0, -1), w);\n};\n\nmodule.exports = willItFlyWithWeight;\n\n},{\"./willItFly\":16}],31:[function(require,module,exports){\nconst willItFly = require('./willItFly');\n\nconst willItFlyWithWeight = (q, w) => {\n  return willItFly(q, w) && willItFlyWithWeight(q.slice(1), w);\n};\n\nmodule.exports = willItFlyWithWeight;\n\n},{\"./willItFly\":16}],32:[function(require,module,exports){\nconst willItFly = require('./willItFly');\n\nconst willItFlyWithWeight = (q, w) => {\n  return willItFly(q, w) && willItFlyWithWeight(q.slice(0, -1), w);\n};\n\nmodule.exports = willItFlyWithWeight;\n\n},{\"./willItFly\":16}],33:[function(require,module,exports){\nconst willItFly = require('./willItFly');\n\nconst willItFlyWithWeight = (q, w) => {\n  return willItFly(q, w) && willItFlyWithWeight(q.slice(1), w);\n};\n\nmodule.exports = willItFlyWithWeight;\n\n},{\"./willItFly\":16}],34:[function(require,module,exports){\nconst willItFly = require('./willItFly');\n\nconst willItFlyWithWeight = (q, w) => {\n  return willItFly(q, w) && willItFlyWithWeight(q.slice(0, -1), w);\n};\n\nmodule.exports = willItFlyWithWeight;\n\n},{\"./willItFly\":16}],35:[function(require,module,exports){\nconst willItFly = require('./willItFly');\n\nconst willItFlyWithWeight = (q, w) => {\n  return willItFly(q, w) && willItFlyWithWeight(q.slice(1), w);\n};\n\n"}
{"task_id": "JavaScript/73", "prompt": "/*\n  A palindromic array is an array that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  A palindromic array is an array that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let min = 0;\n  let max = arr.length - 1;\n  let change = 0;\n\n  while (min <= max) {\n    change = arr[min] + arr[max];\n    if (change > arr[max]) {\n      max = min + 1;\n    } else if (change < arr[min]) {\n      min = max + 1;\n    } else {\n      return change;\n    }\n  }\n};\n\n/*\n  A palindromic array is an array that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst largestChange = (arr) => {\n  let min = 0;\n  let max = arr.length - 1;\n  let change = 0;\n\n  while (min <= max) {\n    change = arr[min] + arr[max];\n    if (change < arr[min]) {\n      max = min + 1;\n    } else if (change > arr[max]) {\n      min = max + 1;\n    } else {\n      return change;\n    }\n  }\n};\n\n/*\n  A palindromic array is an array that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst reverse = (arr) => {\n  let change = 0;\n  let temp = 0;\n  let temp2 = 0;\n  let temp3 = 0;\n\n  while (change < arr.length) {\n    change = arr[change];\n    temp = arr[change];\n    arr[change] = arr[arr.length - 1];\n    arr[arr.length - 1] = temp;\n    temp2 = arr[change];\n    arr[change] = temp;\n    temp3 = arr[change];\n    arr[change] = temp2;\n    arr[arr.length - 1] = temp3;\n  }\n};\n\n/*\n  A palindromic array is an array that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst reversePalindromic = (arr) => {\n  let change = 0;\n  let temp = 0;\n  let temp2 = 0;\n  let temp3 = 0;\n\n  while (change < arr.length) {\n    change = arr[change];\n    temp = arr[change];\n    arr[change] = arr[arr.length - 1];\n    arr[arr.length - 1] = temp;\n    temp2 = arr[change];\n    arr[change] = temp;\n    temp3 = arr[change];\n    arr[change] = temp2;\n    arr[arr.length - 1] = temp3;\n  }\n};\n\n/*\n  A palindromic array is an array that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst reversePalindromicReverse = (arr) => {\n  let change = 0;\n  let temp = 0;\n  let temp2 = 0;\n  let temp3 = 0;\n\n  while (change < arr.length) {\n    change = arr[change];\n    temp = arr[change];\n    arr[change] = arr[arr.length - 1];\n    arr[arr.length - 1] = temp;\n    temp2 = arr[change];\n    arr[change] = temp;\n    temp3 = arr[change];\n    arr[change] = temp2;\n    arr[arr.length - 1] = temp3;\n  }\n};\n\n/*\n  A palindromic array is an array that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst reversePalindromicReversePalindromic = (arr) => {\n  let change = 0;\n  let temp = 0;\n  let temp2 = 0;\n  let temp3 = 0;\n\n  while (change < arr.length) {\n    change = arr[change];\n    temp = arr[change];\n    arr[change] = arr[arr.length - 1];\n    arr[arr.length - 1] = temp;\n    temp2 = arr[change];\n    arr[change] = temp;\n    temp3 = arr[change];\n    arr[change] = temp2;\n    arr[arr.length - 1] = temp3;\n  }\n};\n\n/*\n  A palindromic array is an array that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst reversePalindromicReversePalindromicReverse = (arr) => {\n  let change = 0;\n  let temp = 0;\n  let temp2 = 0;\n  let temp3 = 0;\n\n  while (change < arr.length) {\n    change = arr[change];\n    temp = arr[change];\n    arr[change] = arr[arr.length - 1];\n    arr[arr.length - 1] = temp;\n    temp2 = arr[change];\n    arr[change] = temp;\n    temp3 = arr[change];\n    arr[change] = temp2;\n    arr[arr.length - 1] = temp3;\n  }\n};\n\n/*\n  A palindromic array is an array that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst reversePalindromicReversePalindromicReversePalindromic = (arr) => {\n  let change = 0;\n  let temp = 0;\n  let temp2 = 0;\n  let temp3 = 0;\n\n  while (change < arr.length) {\n    change = arr[change];\n    temp = arr[change];\n    arr[change] = arr[arr.length - 1];\n    arr[arr.length - 1] = temp;\n    temp2 = arr[change];\n    arr[change] = temp;\n    temp3 = arr[change];\n    arr[change] = temp2;\n    arr[arr.length - 1] = temp3;\n  }\n};\n\n/*\n  A palindromic array is an array that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst reversePalindromicReversePalindromicReversePalindromicReverse = (arr) => {\n  let change = 0;\n  let temp = 0;\n  let temp2 = 0;\n  let temp3 = 0;\n\n  while (change < arr.length) {\n    change = arr[change];\n    temp = arr[change];\n    arr[change] = arr[arr.length - 1];\n    arr[arr.length - 1] = temp;\n    temp2 = arr[change];\n    arr[change] = temp;\n    temp3 = arr[change];\n    arr[change] = temp2;\n    arr[arr.length - 1] = temp3;\n  }\n};\n\n/*\n  A palindromic array is an array that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  "}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a function that accepts two lists of strings and returns the list that is the total number of characters in all strings of the list less than the other list. If both lists have the same number of characters, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that accepts two lists of strings and returns the list that is the total number of characters in all strings of the list less than the other list. If both lists have the same number of characters, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let total = 0;\n  lst1.forEach(item => {\n    total += item.length;\n  });\n  lst2.forEach(item => {\n    total -= item.length;\n  });\n  return total;\n};\n\nmodule.exports = totalMatch;\n\n},{}],9:[function(require,module,exports){\n/*\n  Write a function that accepts two lists of strings and returns the list that is the total number of characters in all strings of the list greater than the other list. If both lists have the same number of characters, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let total = 0;\n  lst1.forEach(item => {\n    total += item.length;\n  });\n  lst2.forEach(item => {\n    total += item.length;\n  });\n  return total;\n};\n\nmodule.exports = totalMatch;\n\n},{}],10:[function(require,module,exports){\n/*\n  Write a function that accepts two lists of strings and returns the list that is the total number of characters in all strings of the list equal to the other list. If both lists have the same number of characters, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let total = 0;\n  lst1.forEach(item => {\n    total += item.length;\n  });\n  lst2.forEach(item => {\n    total += item.length;\n  });\n  return total;\n};\n\nmodule.exports = totalMatch;\n\n},{}],11:[function(require,module,exports){\n/*\n  Write a function that accepts two lists of strings and returns the list that is the total number of characters in all strings of the list greater than or equal to the other list. If both lists have the same number of characters, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let total = 0;\n  lst1.forEach(item => {\n    total += item.length;\n  });\n  lst2.forEach(item => {\n    total += item.length;\n  });\n  return total;\n};\n\nmodule.exports = totalMatch;\n\n},{}],12:[function(require,module,exports){\n/*\n  Write a function that accepts two lists of strings and returns the list that is the total number of characters in all strings of the list less than the other list. If both lists have the same number of characters, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let total = 0;\n  lst1.forEach(item => {\n    total += item.length;\n  });\n  lst2.forEach(item => {\n    total -= item.length;\n  });\n  return total;\n};\n\nmodule.exports = totalMatch;\n\n},{}],13:[function(require,module,exports){\n/*\n  Write a function that accepts two lists of strings and returns the list that is the total number of characters in all strings of the list less than or equal to the other list. If both lists have the same number of characters, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let total = 0;\n  lst1.forEach(item => {\n    total += item.length;\n  });\n  lst2.forEach(item => {\n    total -= item.length;\n  });\n  return total;\n};\n\nmodule.exports = totalMatch;\n\n},{}],14:[function(require,module,exports){\n/*\n  Write a function that accepts two lists of strings and returns the list that is the total number of characters in all strings of the list equal to the other list. If both lists have the same number of characters, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let total = 0;\n  lst1.forEach(item => {\n    total += item.length;\n  });\n  lst2.forEach(item => {\n    total += item.length;\n  });\n  return total;\n};\n\nmodule.exports = totalMatch;\n\n},{}],15:[function(require,module,exports){\n/*\n"}
{"task_id": "JavaScript/75", "prompt": "/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let isMultiplyPrime = true;\n  let isMultiplyPrime2 = true;\n  let isMultiplyPrime3 = true;\n  let isMultiplyPrime4 = true;\n  let isMultiplyPrime5 = true;\n  let isMultiplyPrime6 = true;\n  let isMultiplyPrime7 = true;\n  let isMultiplyPrime8 = true;\n  let isMultiplyPrime9 = true;\n  let isMultiplyPrime10 = true;\n  let isMultiplyPrime11 = true;\n  let isMultiplyPrime12 = true;\n  let isMultiplyPrime13 = true;\n  let isMultiplyPrime14 = true;\n  let isMultiplyPrime15 = true;\n  let isMultiplyPrime16 = true;\n  let isMultiplyPrime17 = true;\n  let isMultiplyPrime18 = true;\n  let isMultiplyPrime19 = true;\n  let isMultiplyPrime20 = true;\n  let isMultiplyPrime21 = true;\n  let isMultiplyPrime22 = true;\n  let isMultiplyPrime23 = true;\n  let isMultiplyPrime24 = true;\n  let isMultiplyPrime25 = true;\n  let isMultiplyPrime26 = true;\n  let isMultiplyPrime27 = true;\n  let isMultiplyPrime28 = true;\n  let isMultiplyPrime29 = true;\n  let isMultiplyPrime30 = true;\n  let isMultiplyPrime31 = true;\n  let isMultiplyPrime32 = true;\n  let isMultiplyPrime33 = true;\n  let isMultiplyPrime34 = true;\n  let isMultiplyPrime35 = true;\n  let isMultiplyPrime36 = true;\n  let isMultiplyPrime37 = true;\n  let isMultiplyPrime38 = true;\n  let isMultiplyPrime39 = true;\n  let isMultiplyPrime40 = true;\n  let isMultiplyPrime41 = true;\n  let isMultiplyPrime42 = true;\n  let isMultiplyPrime43 = true;\n  let isMultiplyPrime44 = true;\n  let isMultiplyPrime45 = true;\n  let isMultiplyPrime46 = true;\n  let isMultiplyPrime47 = true;\n  let isMultiplyPrime48 = true;\n  let isMultiplyPrime49 = true;\n  let isMultiplyPrime50 = true;\n  let isMultiplyPrime51 = true;\n  let isMultiplyPrime52 = true;\n  let isMultiplyPrime53 = true;\n  let isMultiplyPrime54 = true;\n  let isMultiplyPrime55 = true;\n  let isMultiplyPrime56 = true;\n  let isMultiplyPrime57 = true;\n  let isMultiplyPrime58 = true;\n  let isMultiplyPrime59 = true;\n  let isMultiplyPrime60 = true;\n  let isMultiplyPrime61 = true;\n  let isMultiplyPrime62 = true;\n  let isMultiplyPrime63 = true;\n  let isMultiplyPrime64 = true;\n  let isMultiplyPrime65 = true;\n  let isMultiplyPrime66 = true;\n  let isMultiplyPrime67 = true;\n  let isMultiplyPrime68 = true;\n  let isMultiplyPrime69 = true;\n  let isMultiplyPrime70 = true;\n  let isMultiplyPrime71 = true;\n  let isMultiplyPrime72 = true;\n  let isMultiplyPrime73 = true;\n  let isMultiplyPrime74 = true;\n  let isMultiplyPrime75 = true;\n  let isMultiplyPrime76 = true;\n  let isMultiplyPrime77 = true;\n  let isMultiplyPrime78 = true;\n  let isMultiplyPrime79 = true;\n  let isMultiplyPrime80 = true;\n  let isMultiplyPrime81 = true;\n  let isMultiplyPrime82 = true;\n  let isMultiplyPrime83 = true;\n  let isMultiplyPrime84 = true;\n  let isMultiplyPrime85 = true;\n  let isMultiplyPrime86 = true;\n  let isMultiplyPrime87 = true;\n  let isMultiplyPrime88 = true;\n  let isMultiplyPrime89 = true;\n  let isMultiplyPrime90 = true;\n  let isMultiplyPrime91 = true;\n  let isMultiplyPrime92 = true;\n  let isMultiplyPrime93 = true;\n  let isMultiplyPrime94 = true;\n  let isMultiplyPrime95 = true;\n  let isMultiplyPrime96 = true;\n  let isMultiplyPrime97 = true;\n  let isMultiplyPrime98 = true;\n  let isMultiplyPrime99 = true;\n  let isMultiplyPrime100 = true;\n  let isMultiplyPrime101 = true;\n  let isMultiplyPrime102 = true;\n  let isMultiplyPrime103 = true;\n  let isMultiplyPrime104 = true;\n  let isMultiplyPrime105 = true;\n  let isMultiplyPrime106 = true;\n  let isMultiplyPrime107 = true;\n  let isMultiplyPrime108 = true;\n  let isMultiplyPrime109 = true;\n  let isMultiplyPrime110 = true;\n  let isMultiplyPrime111 = true;\n  let isMultiplyPrime112 = true;\n  let isMultiplyPrime113 = true;\n  let isMultiplyPrime114 = true;\n  let isMultiplyPrime115 = true;\n  let isMultiplyPrime116 = true;\n  let isMultiplyPrime117 = true;\n  let isMultiplyPrime118 = true;\n  let isMultiplyPrime119 = true;\n  let isMultiplyPrime120 = true;\n  let isMultiplyPrime121 = true;\n  let isMultiplyPrime122 = true;\n  let isMultiplyPrime123 = true;\n  let isMultiplyPrime124 = true;\n  let isMultiplyPrime125 = true;\n  let isMultiplyPrime126 = true;\n  let isMultiplyPrime127 = true;\n  let isMultiplyPrime128 = true;\n  let isMultiplyPrime129 = true;\n  let isMultiplyPrime130 = true;\n  let isMultiplyPrime131 = true;\n  let isMultiplyPrime132 = true;\n  let isMultiplyPrime133 = true;\n  let isMultiplyPrime134 = true;\n  let isMultiplyPrime135 = true;\n  let isMultiplyPrime136 = true;\n  let isMultiplyPrime137 = true;\n  let isMultiplyPrime138 = true;\n  let isMultiplyPrime139 = true;\n  let isMultiplyPrime140 = true;\n  let isMultiplyPrime141 = true;\n  let isMultiplyPrime142 = true;\n  let isMultiplyPrime143 = true;\n  let isMultiplyPrime144 = true;\n  let isMultiplyPrime145 = true;\n  let isMultiplyPrime146 = true;\n  let isMultiplyPrime147 = true;\n  let isMultiplyPrime148 = true;\n  let isMultiplyPrime149 = true;\n  let isMultiplyPrime150 = true;\n  let isMultiplyPrime151 = true;\n  let isMultiplyPrime152 = true;\n  let isMultiplyPrime153 = true;\n  let isMultiplyPrime154 = true;\n  let isMultiplyPrime155 = true;\n  let isMultiplyPrime156 = true;\n  let isMultiplyPrime157 = true;\n  let "}
{"task_id": "JavaScript/76", "prompt": "/*YOur task is to write a function that returns true if a number x is a simple power of n and in other cases a false one. x is a simple power of n if n * * int = x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*YOur task is to write a function that returns true if a number x is a simple power of n and in other cases a false one. x is a simple power of n if n * * int = x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  let isSimple = true;\n  if (n % 2 === 0) {\n    isSimple = false;\n  }\n  if (n % 2 === 1) {\n    isSimple *= isSimplePower(x, n / 2);\n  }\n  return isSimple;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a power of n and in other cases a false one. x is a power of n if n ** (n + 1) = x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(2, 1) => true\n  isPowerOf(2, 3) => false\n  isPowerOf(2, 5) => false\n  */\nconst isPowerOf = (x, n) => {\n  let isPowerOf = true;\n  if (n % 2 === 0) {\n    isPowerOf = false;\n  }\n  if (n % 2 === 1) {\n    isPowerOf = isPowerOf(x, n / 2);\n  }\n  return isPowerOf;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a power of n and in other cases a false one. x is a power of n if n ** int = x\n  For example:\n  isPowerOf(3, 4) => true\n  isPowerOf(3, 2) => true\n  isPowerOf(3, 1) => true\n  isPowerOf(3, 3) => false\n  isPowerOf(3, 5) => false\n  */\nconst isPowerOf = (x, n) => {\n  let isPowerOf = true;\n  if (n % 2 === 0) {\n    isPowerOf = false;\n  }\n  if (n % 2 === 1) {\n    isPowerOf = isPowerOf(x, n / 2);\n  }\n  return isPowerOf;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a power of n and in other cases a false one. x is a power of n if n ** float = x\n  For example:\n  isPowerOf(3.14, 4) => true\n  isPowerOf(3.14, 2) => true\n  isPowerOf(3.14, 1) => true\n  isPowerOf(3.14, 3) => false\n  isPowerOf(3.14, 5) => false\n  */\nconst isPowerOf = (x, n) => {\n  let isPowerOf = true;\n  if (n % 2 === 0) {\n    isPowerOf = false;\n  }\n  if (n % 2 === 1) {\n    isPowerOf = isPowerOf(x, n / 2);\n  }\n  return isPowerOf;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a power of n and in other cases a false one. x is a power of n if n ** bool = x\n  For example:\n  isPowerOf(true, 4) => true\n  isPowerOf(true, 2) => true\n  isPowerOf(true, 1) => true\n  isPowerOf(true, 3) => false\n  isPowerOf(true, 5) => false\n  */\nconst isPowerOf = (x, n) => {\n  let isPowerOf = true;\n  if (n % 2 === 0) {\n    isPowerOf = false;\n  }\n  if (n % 2 === 1) {\n    isPowerOf = isPowerOf(x, n / 2);\n  }\n  return isPowerOf;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a power of n and in other cases a false one. x is a power of n if n ** str = x\n  For example:\n  isPowerOf('hello', 4) => true\n  isPowerOf('hello', 2) => true\n  isPowerOf('hello', 1) => true\n  isPowerOf('hello', 3) => false\n  isPowerOf('hello', 5) => false\n  */\nconst isPowerOf = (x, n) => {\n  let isPowerOf = true;\n  if (n % 2 === 0) {\n    isPowerOf = false;\n  }\n  if (n % 2 === 1) {\n    isPowerOf = isPowerOf(x, n / 2);\n  }\n  return isPowerOf;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a power of n and in other cases a false one. x is a power of n if n ** int = int\n  For example:\n  isPowerOf(5, 4) => true\n  isPowerOf(5, 2) => true\n  isPowerOf(5, 1) => true\n  isPowerOf(5, 3) => false\n  isPowerOf(5, 5) => false\n  */\nconst isPowerOf = (x, n) => {\n  let isPowerOf = true;\n  if (n % 2 === 0) {\n    isPowerOf = false;\n  }\n  if (n % 2 === 1) {\n    isPowerOf = isPowerOf(x, n / 2);\n  }\n  return isPowerOf;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a power of n and in other cases a false one. x is a power of n if n ** float = float\n  For example:\n  isPowerOf(3.14, 4) => true\n  isPowerOf(3.14, 2) => true\n  isPowerOf(3.14, 1) => true\n  isPowerOf(3.14, 3) => false\n  isPowerOf(3.14, 5) => false\n  */\nconst isPowerOf = (x, n) => {\n  let isPowerOf = true;\n  if (n % 2 === 0) {\n    isPowerOf = false;\n  }\n  if (n % 2 === 1) {\n    isPowerOf = isPowerOf(x, n / 2);\n  }\n  return isPowerOf;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a power of n and in other cases a false one. x is a power of n if n ** bool = bool\n  For example:\n  isPowerOf(true, 4) => true\n  isPowerOf(true, 2) => true\n  isPowerOf(true, 1) => true\n  isPowerOf(true, 3) => false\n  isPowerOf(true, 5) => false\n  */\nconst isPowerOf = (x, n) => {\n  let isPowerOf = true;\n  if (n % 2 === 0) {\n    isPowerOf = false;\n  }\n  if (n % 2 === 1) {\n    isPowerOf = isPowerOf(x, n / 2);\n  }\n  return isPowerOf;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a power of n and in other cases a false one. x is a power of n if n ** str = str\n  For example:\n  isPowerOf('hello', 4) => true\n  isPowerOf('hello', 2) => true\n  isPowerOf('hello', 1) => true\n  isPowerOf('hello', 3) => false\n  isPowerOf('hello', 5) => false\n  */\nconst isPowerOf = (x, n) => {\n  let isPowerOf = true;\n  if (n % 2 === 0) {\n    isPowerOf = false;\n  }\n  if (n % 2 === 1) {\n    isPowerOf = isPowerOf(x, n / 2);\n  }\n  return isPowerOf;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a power of n and in other cases a false one. x is a power of n if n ** int = int\n  For example:\n  isPowerOf(5, 4) => true\n  isPowerOf(5, 2) => true\n  isPowerOf(5, 1) => true\n  isPowerOf(5, 3) => false\n  isPowerOf(5, 5) => false\n  */\nconst isPowerOf = (x, n) => {\n  let isPowerOf = true;\n  if (n % 2 === 0) {\n    isPowerOf = false;\n  }\n  if (n % 2 === 1) {\n    isPowerOf = isPowerOf(x, n / 2);\n  }\n  return isPowerOf;\n};\n\n/*\n"}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a function that takes an integer a and returns true if this ingeger is a die of an integer. Note: You can assume that the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that takes an integer a and returns true if this ingeger is a die of an integer. Note: You can assume that the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a <= 0) return false;\n  if (a > 1) return true;\n  return iscube(a / 2);\n};\n\n/*\n  Write a function that takes an integer a and returns true if this ingeger is a king of an integer. Note: You can assume that the input is always valid.\n  Examples:\n  isking(1) ==> true\n  isking(2) ==> false\n  isking(-1) ==> true\n  isking(64) ==> true\n  isking(0) ==> true\n  isking(180) ==> false\n  */\nconst isking = (a) => {\n  if (a <= 0) return false;\n  if (a > 1) return true;\n  return isking(a / 2);\n};\n\n/*\n  Write a function that takes an integer a and returns true if this ingeger is a rock of an integer. Note: You can assume that the input is always valid.\n  Examples:\n  isrock(1) ==> true\n  isrock(2) ==> false\n  isrock(-1) ==> true\n  isrock(64) ==> true\n  isrock(0) ==> true\n  isrock(180) ==> false\n  */\nconst isrock = (a) => {\n  if (a <= 0) return false;\n  if (a > 1) return true;\n  return isrock(a / 2);\n};\n\n/*\n  Write a function that takes an integer a and returns true if this ingeger is a paper of a integer. Note: You can assume that the input is always valid.\n  Examples:\n  ispaper(1) ==> true\n  ispaper(2) ==> false\n  ispaper(-1) ==> true\n  ispaper(64) ==> true\n  ispaper(0) ==> true\n  ispaper(180) ==> false\n  */\nconst ispaper = (a) => {\n  if (a <= 0) return false;\n  if (a > 1) return true;\n  return ispaper(a / 2);\n};\n\n/*\n  Write a function that takes an integer a and returns true if this ingeger is a pencil of a integer. Note: You can assume that the input is always valid.\n  Examples:\n  ispencil(1) ==> true\n  ispencil(2) ==> false\n  ispencil(-1) ==> true\n  ispencil(64) ==> true\n  ispencil(0) ==> true\n  ispencil(180) ==> false\n  */\nconst ispencil = (a) => {\n  if (a <= 0) return false;\n  if (a > 1) return true;\n  return ispencil(a / 2);\n};\n\n/*\n  Write a function that takes an integer a and returns true if this ingeger is a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a pencil of a "}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let count = 0;\n  let numArray = num.split(\"\");\n  for (let i = 0; i < numArray.length; i++) {\n    if (numArray[i].length > 0) {\n      if (numArray[i].length === 1) {\n        if (numArray[i].toUpperCase() === numArray[i]) {\n          count++;\n        }\n      } else {\n        if (numArray[i].toUpperCase() === numArray[i].toUpperCase()) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You have been tasked to write a function that receives a string and counts\n  the number of letters that are uppercase letters (uppercase letters === or a\n  lowercase letters === is a natural number greater than 1 that is not a product\n  of two smaller natural numbers).\n  Uppercase letters are A=== B=== C=== D=== E=== F.\n  Lowercase letters are a=== b=== c=== d=== e=== f.\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For str = \"AB\" the output should be 1.\n  For str = \"1077E\" the output should be 2.\n  For str = \"ABED1A33\" the output should be 4.\n  For str = \"123456789ABCDEF0\" the output should be 6.\n  For str = \"2020\" the output should be 2.\n  */\nconst upperKey = (str) => {\n  let count = 0;\n  let strArray = str.split(\"\");\n  for (let i = 0; i < strArray.length; i++) {\n    if (strArray[i].length > 0) {\n      if (strArray[i].length === 1) {\n        if (strArray[i].toUpperCase() === strArray[i]) {\n          count++;\n        }\n      } else {\n        if (strArray[i].toUpperCase() === strArray[i].toUpperCase()) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You have been tasked to write a function that receives a string and counts\n  the number of letters that are lowercase letters (lowercase letters === or a\n  uppercase letters === is a natural number greater than 1 that is not a product\n  of two smaller natural numbers).\n  Lowercase letters are a=== b=== c=== d=== e=== f.\n  Uppercase letters are A=== B=== C=== D=== E=== F.\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For str = \"AB\" the output should be 1.\n  For str = \"1077E\" the output should be 2.\n  For str = \"ABED1A33\" the output should be 4.\n  For str = \"123456789ABCDEF0\" the output should be 6.\n  For str = \"2020\" the output should be 2.\n  */\nconst lowerKey = (str) => {\n  let count = 0;\n  let strArray = str.split(\"\");\n  for (let i = 0; i < strArray.length; i++) {\n    if (strArray[i].length > 0) {\n      if (strArray[i].length === 1) {\n        if (strArray[i].toLowerCase() === strArray[i]) {\n          count++;\n        }\n      } else {\n        if (strArray[i].toLowerCase() === strArray[i].toLowerCase()) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You have been tasked to write a function that receives a string and counts\n  the number of letters that are digits (digits === is a natural number greater than\n  1 that is not a product of two smaller natural numbers).\n  Digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For str = \"AB\" the output should be 1.\n  For str = \"1077E\" the output should be 2.\n  For str = \"ABED1A33\" the output should be 4.\n  For str = \"123456789ABCDEF0\" the output should be 6.\n  For str = \"2020\" the output should be 2.\n  */\nconst digitKey = (str) => {\n  let count = 0;\n  let strArray = str.split(\"\");\n  for (let i = 0; i < strArray.length; i++) {\n    if (strArray[i].length > 0) {\n      if (strArray[i].length === 1) {\n        if (strArray[i].toUpperCase() === strArray[i]) {\n          count++;\n        }\n      } else {\n        if (strArray[i].toUpperCase() === strArray[i].toUpperCase()) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You have been tasked to write a function that receives a string and counts\n  the number of letters that are symbols (symbols === is a natural number greater than\n  1 that is not a product of two smaller natural numbers).\n  Symbols are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For str = \"AB\" the output should be 1.\n  For str = \"1077E\" the output should be 2.\n  For str = \"ABED1A33\" the output should be 4.\n  For str = \"123456789ABCDEF0\" the output should be 6.\n  For str = \"2020\" the output should be 2.\n  */\nconst symbolKey = (str) => {\n  let count = 0;\n  let strArray = str.split(\"\");\n  for (let i = 0; i < strArray.length; i++) {\n    if (strArray[i].length > 0) {\n      if (strArray[i].length === 1) {\n        if (strArray[i].toLowerCase() === strArray[i]) {\n          count++;\n        }\n      } else {\n        if (strArray[i].toLowerCase() === strArray[i].toLowerCase()) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You have been tasked to write a function that receives a string and counts\n  the number of letters that are uppercase letters (uppercase letters === or a\n  lowercase letters === is a natural number greater than 1 that is not a product\n  of two smaller natural numbers).\n  Uppercase letters are A=== B=== C=== D=== E=== F.\n  Lowercase letters are a=== b=== c=== d=== e=== f.\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For str = \"AB\" the output should be 1.\n  For str = \"1077E\" the output should be 2.\n  For str = \"ABED1A33\" the output should be 4.\n  For str = \"123456789ABCDEF0\" the output should be "}
{"task_id": "JavaScript/79", "prompt": "/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binaryString = '';\n  let binaryStringLength = 0;\n  let decimalString = '';\n  let decimalStringLength = 0;\n  let decimalStringPosition = 0;\n\n  while (decimalStringPosition < decimal.length) {\n    decimalStringPosition += 1;\n    decimalString = decimalString.concat(decimal.substring(decimalStringPosition));\n    decimalStringLength += 1;\n  }\n\n  while (binaryStringLength < binaryString.length) {\n    binaryStringLength += 1;\n    binaryString = binaryString.concat(binaryString.substring(1));\n    binaryStringLength += 1;\n  }\n\n  while (binaryStringLength < binaryString.length) {\n    binaryStringLength += 1;\n    binaryString = binaryString.concat(binaryString.substring(1));\n    binaryStringLength += 1;\n  }\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n  binaryString = binaryString.concat(binaryString.substring(1));\n\n  binaryString = binaryString.concat(binaryString.substring(1));\n"}
{"task_id": "JavaScript/80", "prompt": "/*YYou get a string s. Your task is to check whether the string is happy or not. A string is happy if it is at least 3 long and all three consecutive letters are clearly distinguishable from each other.\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*YYou get a string s. Your task is to check whether the string is happy or not. A string is happy if it is at least 3 long and all three consecutive letters are clearly distinguishable from each other.\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let len = s.length;\n  let isHappy = true;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;"}
{"task_id": "JavaScript/81", "prompt": "/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const letterGrades = grades.map((grade) => {\n    if (grade >= 4.0 && grade <= 3.7) {\n      return 'A+';\n    }\n    if (grade >= 3.3 && grade <= 3.7) {\n      return 'A';\n    }\n    if (grade >= 3.0 && grade <= 3.7) {\n      return 'A-';\n    }\n    if (grade >= 2.7 && grade <= 3.7) {\n      return 'B+';\n    }\n    if (grade >= 2.3 && grade <= 3.7) {\n      return 'B';\n    }\n    if (grade >= 2.0 && grade <= 3.7) {\n      return 'B-';\n    }\n    if (grade >= 1.7 && grade <= 3.7) {\n      return 'C+';\n    }\n    if (grade >= 1.3 && grade <= 3.7) {\n      return 'C';\n    }\n    if (grade >= 1.0 && grade <= 3.7) {\n      return 'C-';\n    }\n    if (grade >= 0.7 && grade <= 3.7) {\n      return 'D+';\n    }\n    if (grade >= 0.3 && grade <= 3.7) {\n      return 'D';\n    }\n    if (grade >= 0.0 && grade <= 3.7) {\n      return 'D-';\n    }\n    if (grade >= 0.0) {\n      return 'E';\n    }\n    return '';\n  });\n  return letterGrades;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade2 = (grades) => {\n  const letterGrades = grades.map((grade) => {\n    if (grade >= 4.0 && grade <= 3.7) {\n      return 'A+';\n    }\n    if (grade >= 3.3 && grade <= 3.7) {\n      return 'A';\n    }\n    if (grade >= 3.0 && grade <= 3.7) {\n      return 'A-';\n    }\n    if (grade >= 2.7 && grade <= 3.7) {\n      return 'B+';\n    }\n    if (grade >= 2.3 && grade <= 3.7) {\n      return 'B';\n    }\n    if (grade >= 2.0 && grade <= 3.7) {\n      return 'B-';\n    }\n    if (grade >= 1.7 && grade <= 3.7) {\n      return 'C+';\n    }\n    if (grade >= 1.3 && grade <= 3.7) {\n      return 'C';\n    }\n    if (grade >= 1.0 && grade <= 3.7) {\n      return 'C-';\n    }\n    if (grade >= 0.7 && grade <= 3.7) {\n      return 'D+';\n    }\n    if (grade >= 0.3 && grade <= 3.7) {\n      return 'D';\n    }\n    if (grade >= 0.0 && grade <= 3.7) {\n      return 'D-';\n    }\n    if (grade >= 0.0) {\n      return 'E';\n    }\n    return '';\n  });\n  return letterGrades;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade3 = (grades) => {\n  const letterGrades = grades.map((grade) => {\n    if (grade >= 4.0 && grade <= 3.7) {\n      return 'A+';\n    }\n    if (grade >= 3.3 && grade <= 3.7) {\n      return 'A';\n    }\n    if (grade >= 3.0 && grade <= 3.7) {\n      return 'A-';\n    }\n    if (grade >= 2.7 && grade <= 3.7) {\n      return 'B+';\n    }\n    if (grade >= 2.3 && grade <= 3.7) {\n      return 'B';\n    }\n    if (grade >= 2.0 && grade <= 3.7) {\n      return 'B-';\n    }\n    if (grade >= 1.7 && grade <= 3.7) {\n      return 'C+';\n    }\n    if (grade >= 1.3 && grade <= 3.7) {\n      return 'C';\n    }\n    if (grade >= 1.0 && grade <= 3.7) {\n      return 'C-';\n    }\n    if (grade >= 0.7 && grade <= 3.7) {\n      return 'D+';\n    }\n    if (grade >= 0.3 && grade <= 3.7) {\n      return 'D';\n    }\n    if (grade >= 0.0 && grade <= 3.7) {\n      return 'D-';\n    }\n    if (grade >= 0.0) {\n      return 'E';\n    }\n    return '';\n  });\n  return letterGrades;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she "}
{"task_id": "JavaScript/82", "prompt": "/*Write is a function that takes a string and returns true if the string length is a prime or otherwise wrong\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Write is a function that takes a string and returns true if the string length is a prime or otherwise wrong\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let isPrime = true;\n  let length = string.length;\n  let i;\n  for (i = 0; i < length; i++) {\n    if (i % 2 === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('kittens') === false\n  */\nconst palindrome = (string) => {\n  let isPalindrome = true;\n  let length = string.length;\n  let i;\n  for (i = 0; i < length; i++) {\n    if (string[i]!== string[length - i - 1]) {\n      isPalindrome = false;\n      break;\n    }\n  }\n  return isPalindrome;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('kittens') === false\n  */\nconst reverse = (string) => {\n  let isReverse = true;\n  let length = string.length;\n  let i;\n  for (i = 0; i < length; i++) {\n    if (string[i] === string[length - i - 1]) {\n      isReverse = false;\n      break;\n    }\n  }\n  return isReverse;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reverse('kittens') == true\n  reverse('kittens') === false\n  */\nconst reverseString = (string) => {\n  let isReverse = true;\n  let length = string.length;\n  let i;\n  for (i = 0; i < length; i++) {\n    if (string[i] === string[length - i - 1]) {\n      isReverse = false;\n      break;\n    }\n  }\n  return isReverse;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reverseString('kittens') == true\n  reverseString('kittens') === false\n  */\nconst reverseStringReverse = (string) => {\n  let isReverse = true;\n  let length = string.length;\n  let i;\n  for (i = 0; i < length; i++) {\n    if (string[i] === string[length - i - 1]) {\n      isReverse = false;\n      break;\n    }\n  }\n  return isReverse;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reverseStringReverse('kittens') == true\n  reverseStringReverse('kittens') === false\n  */\nconst reverseStringReverseString = (string) => {\n  let isReverse = true;\n  let length = string.length;\n  let i;\n  for (i = 0; i < length; i++) {\n    if (string[i] === string[length - i - 1]) {\n      isReverse = false;\n      break;\n    }\n  }\n  return isReverse;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reverseStringReverseString('kittens') == true\n  reverseStringReverseString('kittens') === false\n  */\nconst reverseStringReverseStringReverse = (string) => {\n  let isReverse = true;\n  let length = string.length;\n  let i;\n  for (i = 0; i < length; i++) {\n    if (string[i] === string[length - i - 1]) {\n      isReverse = false;\n      break;\n    }\n  }\n  return isReverse;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reverseStringReverseStringReverse('kittens') == true\n  reverseStringReverseStringReverse('kittens') === false\n  */\nconst reverseStringReverseStringReverseString = (string) => {\n  let isReverse = true;\n  let length = string.length;\n  let i;\n  for (i = 0; i < length; i++) {\n    if (string[i] === string[length - i - 1]) {\n      isReverse = false;\n      break;\n    }\n  }\n  return isReverse;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reverseStringReverseStringReverseString('kittens') == true\n  reverseStringReverseStringReverseString('kittens') === false\n  */\nconst reverseStringReverseStringReverseStringReverse = (string) => {\n  let isReverse = true;\n  let length = string.length;\n  let i;\n  for (i = 0; i < length; i++) {\n    if (string[i] === string[length - i - 1]) {\n      isReverse = false;\n      break;\n    }\n  }\n  return isReverse;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reverseStringReverseStringReverseStringReverseString('kittens') == true\n  reverseStringReverseStringReverseStringReverseString('kittens') === false\n  */\nconst reverseStringReverseStringReverseStringReverseString = (string) => {\n  let isReverse = true;\n  let length = string.length;\n  let i;\n  for (i = 0; i < length; i++) {\n    if (string[i] === string[length - i - 1]) {\n      isReverse = false;\n      break;\n    }\n  }\n  return isReverse;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reverseStringReverseStringReverseStringReverseStringReverseString('kittens') == true\n  reverseStringReverseStringReverseStringReverseStringReverseString('kittens') === false\n  */\nconst reverseStringReverseStringReverseStringReverseStringReverseString = (string) => {\n  let isReverse = true;\n  let length = string.length;\n  let i;\n  for (i = 0; i < length; i++) {\n    if (string[i] === string[length - i - 1]) {\n      isReverse = false;\n      break;\n    }\n  }\n  return isReverse;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverseStringReverse"}
{"task_id": "JavaScript/83", "prompt": "/*\n  For a positive integer n, the number of n-digit positive integers starting or ending with 1 is returned. * / const startsOneEnds = (n) = > {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  For a positive integer n, the number of n-digit positive integers starting or ending with 1 is returned. * / const startsOneEnds = (n) = > {\n  n = 0\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10\n  while n!= 0\n  n = n / 10"}
{"task_id": "JavaScript/84", "prompt": "/*GIf you use a positive integer N, return the sum total of its digits in binary form.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*GIf you use a positive integer N, return the sum total of its digits in binary form.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(i.toString(2), 2);\n  }\n  return sum.toString();\n};\n\n/*\n  Function: solve\n  Description: Given a positive integer N, return the sum of its digits in decimal form.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of decimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(i.toString(), 2);\n  }\n  return sum.toString();\n};\n\n/*\n  Function: solve\n  Description: Given a positive integer N, return the sum of its digits in hexadecimal form.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"0x\".\n      For N = 150, the sum of digits will be 6 the output should be \"0x110\".\n      For N = 147, the sum of digits will be 12 the output should be \"0x1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of hexadecimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(i.toString(16), 16);\n  }\n  return sum.toString();\n};\n\n/*\n  Function: solve\n  Description: Given a positive integer N, return the sum of its digits in octal form.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"0o\".\n      For N = 150, the sum of digits will be 6 the output should be \"0o110\".\n      For N = 147, the sum of digits will be 12 the output should be \"0o1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of octal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(i.toString(8), 8);\n  }\n  return sum.toString();\n};\n\n/*\n  Function: solve\n  Description: Given a positive integer N, return the sum of its digits in binary form.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(i.toString(2), 2);\n  }\n  return sum.toString();\n};\n\n/*\n  Function: solve\n  Description: Given a positive integer N, return the sum of its digits in decimal form.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of decimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(i.toString(), 2);\n  }\n  return sum.toString();\n};\n\n/*\n  Function: solve\n  Description: Given a positive integer N, return the sum of its digits in hexadecimal form.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"0x\".\n      For N = 150, the sum of digits will be 6 the output should be \"0x110\".\n      For N = 147, the sum of digits will be 12 the output should be \"0x1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of hexadecimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(i.toString(16), 16);\n  }\n  return sum.toString();\n};\n\n/*\n  Function: solve\n  Description: Given a positive integer N, return the sum of its digits in octal form.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"0o\".\n      For N = 150, the sum of digits will be 6 the output should be \"0o110\".\n      For N = 147, the sum of digits will be 12 the output should be \"0o1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of octal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(i.toString(8), 8);\n  }\n  return sum.toString();\n};\n\n/*\n  Function: solve\n  Description: Given a positive integer N, return the sum of its digits in binary form.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(i.toString(2), 2);\n  }\n  return sum.toString();\n};\n\n/*\n  Function: solve\n  Description: Given a positive integer N, return the sum of its digits in decimal form.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of decimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(i.toString(), 2);\n  }\n  return sum.toString();\n};\n\n/*\n  Function: solve\n  Description: Given a positive integer N, return the sum of its digits in hexadecimal form.\n  \n  Example\n      For N = 1000, the sum of "}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. remove the even elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst remove = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. remove the even elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeEven = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. remove the odd elements that are at even indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeOdd = (lst, odd) => {\n  let even = lst.filter(x => x % 2!== 0);\n  let odd = lst.filter(x => x % 2 === 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. remove the even elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst removeEvenOdd = (lst, even) => {\n  let odd = lst.filter(x => x % 2!== 0);\n  let even = lst.filter(x => x % 2 === 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. remove the even elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeEvenOddEven = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. remove the odd elements that are at even indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeOddEven = (lst) => {\n  let odd = lst.filter(x => x % 2!== 0);\n  let even = lst.filter(x => x % 2 === 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. remove the even elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeEvenOddOddEven = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. remove the even elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeOddEvenOddOddEven = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. remove the even elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeOddEvenOddOddOddEven = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. remove the even elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeOddEvenOddOddOddOddEven = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. remove the even elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeOddEvenOddOddOddOddOddEven = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. remove the even elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeOddEvenOddOddOddOddOddOddEven = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. remove the even elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeOddEvenOddOddOddOddOddOddOddEven = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. remove the even elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeOddEvenOddOddOddOddOddOddOddOddEven = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. remove the even elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeOddEvenOddOddOddOddOddOddOddOddOddEven = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. remove the even elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeOddEvenOddOddOddOddOddOddOddOddOddOddOddEven = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);"}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a function that takes a string and returns an ordered version of it. The ordered version of string is a string in which all words (separated by spaces) are replaced by a new word in which all characters are ordered in ascending order based on the ascii value. Note: You should keep the order of words and spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that takes a string and returns an ordered version of it. The ordered version of string is a string in which all words (separated by spaces) are replaced by a new word in which all characters are ordered in ascending order based on the ascii value. Note: You should keep the order of words and spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  words.sort((a, b) => {\n    return a.localeCompare(b);\n  });\n  words.forEach((word, index) => {\n    newStr += word;\n    if (index === words.length - 1) {\n      newStr +='';\n    }\n  });\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it. The ordered version of string is a string in which all words (separated by spaces) are replaced by a new word in which all characters are ordered in ascending order based on the ascii value. Note: You should keep the order of words and spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffleAll = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  words.sort((a, b) => {\n    return a.localeCompare(b);\n  });\n  words.forEach((word, index) => {\n    newStr += word;\n    if (index === words.length - 1) {\n      newStr +='';\n    }\n  });\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it. The ordered version of string is a string in which all words (separated by spaces) are replaced by a new word in which all characters are ordered in ascending order based on the ascii value. Note: You should keep the order of words and spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffleAllReverse = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  words.sort((a, b) => {\n    return a.localeCompare(b);\n  });\n  words.forEach((word, index) => {\n    newStr += word;\n    if (index === words.length - 1) {\n      newStr +='';\n    }\n  });\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it. The ordered version of string is a string in which all words (separated by spaces) are replaced by a new word in which all characters are ordered in ascending order based on the ascii value. Note: You should keep the order of words and spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffleAllReverseAll = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  words.sort((a, b) => {\n    return a.localeCompare(b);\n  });\n  words.forEach((word, index) => {\n    newStr += word;\n    if (index === words.length - 1) {\n      newStr +='';\n    }\n  });\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it. The ordered version of string is a string in which all words (separated by spaces) are replaced by a new word in which all characters are ordered in ascending order based on the ascii value. Note: You should keep the order of words and spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffleAllReverseAllReverse = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  words.sort((a, b) => {\n    return a.localeCompare(b);\n  });\n  words.forEach((word, index) => {\n    newStr += word;\n    if (index === words.length - 1) {\n      newStr +='';\n    }\n  });\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it. The ordered version of string is a string in which all words (separated by spaces) are replaced by a new word in which all characters are ordered in ascending order based on the ascii value. Note: You should keep the order of words and spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffleAllReverseAllReverseAll = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  words.sort((a, b) => {\n    return a.localeCompare(b);\n  });\n  words.forEach((word, index) => {\n    newStr += word;\n    if (index === words.length - 1) {\n      newStr +='';\n    }\n  });\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it. The ordered version of string is a string in which all words (separated by spaces) are replaced by a new word in which all characters are ordered in ascending order based on the ascii value. Note: You should keep the order of words and spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffleAllReverseAllReverseAllReverse = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  words.sort((a, b) => {\n    return a.localeCompare(b);\n  });\n  words.forEach((word, index) => {\n    newStr += word;\n    if (index === words.length - 1) {\n      newStr +='';\n    }\n  });\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it. The ordered version of string is a string in which all words (separated by spaces) are replaced by a new word in which all characters are ordered in ascending order based on the ascii value. Note: You should keep the order of words and spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffleAllReverseAllReverseAllReverseAll = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  words.sort((a, b) => {\n    return a.localeCompare(b);\n  });\n  words.forEach((word, index) => {\n    newStr += word;\n    if (index === words.length - 1) {\n      newStr +='';\n    }\n  });\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it. The ordered version of string is a string in which all words (separated by spaces) are replaced by a new word in which all characters are ordered in ascending order based on the ascii value. Note: You should keep the order of words and spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffleAllReverseAllReverse"}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  let row = []\n  let col = []\n  for (let i = 0; i < lst.length; i++) {\n    row.push(lst[i])\n  }\n  row.sort((a, b) => a - b)\n  for (let i = 0; i < lst.length; i++) {\n    col.push(lst[i][x])\n  }\n  return [row, col]\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getCol = (lst, x) => {\n  let row = []\n  let col = []\n  for (let i = 0; i < lst.length; i++) {\n    row.push(lst[i])\n  }\n  col.sort((a, b) => a - b)\n  for (let i = 0; i < lst.length; i++) {\n    row.push(lst[i][x])\n  }\n  return [row, col]\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRowCol = (lst, x) => {\n  let row = []\n  let col = []\n  for (let i = 0; i < lst.length; i++) {\n    row.push(lst[i])\n  }\n  col.sort((a, b) => a - b)\n  for (let i = 0; i < lst.length; i++) {\n    row.push(lst[i][x])\n  }\n  return [row, col]\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRowColRow = (lst, x) => {\n  let row = []\n  let col = []\n  for (let i = 0; i < lst.length; i++) {\n    row.push(lst[i])\n  }\n  col.sort((a, b) => a - b)\n  for (let i = 0; i < lst.length; i++) {\n    row.push(lst[i][x])\n  }\n  return [row, col]\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRowColColRow = (lst, x) => {\n  let row = []\n  let col = []\n  for (let i = 0; i < lst.length; i++) {\n    row.push(lst[i])\n  }\n  col.sort((a, b) => a - b)\n  for (let i = 0; i < lst.length; i++) {\n    row.push(lst[i][x])\n  }\n  return [row, col]\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRowColColColRow = (lst, x) => {\n  let row = []\n  let col = []\n  for (let i = 0; i < lst.length; i++) {\n    row.push(lst[i])\n  }\n  col.sort((a, b) => a - b)\n  for (let i = 0; i < lst.length; i++) {\n    row.push(lst[i][x])\n  }\n  return [row, col]\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow"}
{"task_id": "JavaScript/88", "prompt": "/*\n  For an array of non-negative integers, return a copy of the given array after sorting. You sort the given array in ascending order if the sum (first index value, last index value) is odd, or sort it in descending order if the sum (first index value, last index value) is even. Note: * Do not change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  For an array of non-negative integers, return a copy of the given array after sorting. You sort the given array in ascending order if the sum (first index value, last index value) is odd, or sort it in descending order if the sum (first index value, last index value) is even. Note: * Do not change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sortedArray = array.sort((a, b) => a - b);\n  return sortedArray;\n};\n\n/**\n * Given an array of non-negative integers, return an array that contains the first and last index values such that all values are even.\n\n  Examples:\n  * evenIndex([5, 6, 7]) => [0, 2]\n  * evenIndex([2, 4, 3, 0, 1, 5]) => [0, 2, 4, 3]\n  * evenIndex([2, 4, 3, 0, 1, 5, 6]) => [0, 2, 4, 3, 5]\n  */\nconst evenIndex = (array) => {\n  const evenIndexArray = array.filter((value, index) => {\n    if (index % 2 === 0) {\n      return index;\n    }\n  });\n  return evenIndexArray;\n};\n\n/**\n * Given an array of non-negative integers, return an array that contains the first and last index values such that all values are odd.\n\n  Examples:\n  * oddIndex([5, 6, 7]) => [0, 3]\n  * oddIndex([2, 4, 3, 0, 1, 5]) => [0, 2, 4, 3]\n  * oddIndex([2, 4, 3, 0, 1, 5, 6]) => [0, 2, 4, 3, 5]\n  */\nconst oddIndex = (array) => {\n  const oddIndexArray = array.filter((value, index) => {\n    if (index % 2!== 0) {\n      return index;\n    }\n  });\n  return oddIndexArray;\n};\n\n/**\n * Given an array of non-negative integers, return an array that contains the first and last index values such that all values are divisible by 3.\n\n  Examples:\n  * divisibleBy3([5, 6, 7]) => [0, 2]\n  * divisibleBy3([2, 4, 3, 0, 1, 5]) => [0, 2, 4, 3]\n  * divisibleBy3([2, 4, 3, 0, 1, 5, 6]) => [0, 2, 4, 3, 5]\n  */\nconst divisibleBy3 = (array) => {\n  const divisibleBy3Array = array.filter((value, index) => {\n    if (index % 3 === 0) {\n      return index;\n    }\n  });\n  return divisibleBy3Array;\n};\n\n/**\n * Given an array of non-negative integers, return an array that contains the first and last index values such that all values are divisible by 5.\n\n  Examples:\n  * divisibleBy5([5, 6, 7]) => [0, 2]\n  * divisibleBy5([2, 4, 3, 0, 1, 5]) => [0, 2, 4, 3]\n  * divisibleBy5([2, 4, 3, 0, 1, 5, 6]) => [0, 2, 4, 3, 5]\n  */\nconst divisibleBy5 = (array) => {\n  const divisibleBy5Array = array.filter((value, index) => {\n    if (index % 5 === 0) {\n      return index;\n    }\n  });\n  return divisibleBy5Array;\n};\n\n/**\n * Given an array of non-negative integers, return an array that contains the first and last index values such that all values are divisible by 7.\n\n  Examples:\n  * divisibleBy7([5, 6, 7]) => [0, 2]\n  * divisibleBy7([2, 4, 3, 0, 1, 5]) => [0, 2, 4, 3]\n  * divisibleBy7([2, 4, 3, 0, 1, 5, 6]) => [0, 2, 4, 3, 5]\n  */\nconst divisibleBy7 = (array) => {\n  const divisibleBy7Array = array.filter((value, index) => {\n    if (index % 7 === 0) {\n      return index;\n    }\n  });\n  return divisibleBy7Array;\n};\n\n/**\n * Given an array of non-negative integers, return an array that contains the first and last index values such that all values are divisible by 9.\n\n  Examples:\n  * divisibleBy9([5, 6, 7]) => [0, 2]\n  * divisibleBy9([2, 4, 3, 0, 1, 5]) => [0, 2, 4, 3]\n  * divisibleBy9([2, 4, 3, 0, 1, 5, 6]) => [0, 2, 4, 3, 5]\n  */\nconst divisibleBy9 = (array) => {\n  const divisibleBy9Array = array.filter((value, index) => {\n    if (index % 9 === 0) {\n      return index;\n    }\n  });\n  return divisibleBy9Array;\n};\n\n/**\n * Given an array of non-negative integers, return an array that contains the first and last index values such that all values are divisible by 11.\n\n  Examples:\n  * divisibleBy11([5, 6, 7]) => [0, 2]\n  * divisibleBy11([2, 4, 3, 0, 1, 5]) => [0, 2, 4, 3]\n  * divisibleBy11([2, 4, 3, 0, 1, 5, 6]) => [0, 2, 4, 3, 5]\n  */\nconst divisibleBy11 = (array) => {\n  const divisibleBy11Array = array.filter((value, index) => {\n    if (index % 11 === 0) {\n      return index;\n    }\n  });\n  return divisibleBy11Array;\n};\n\n/**\n * Given an array of non-negative integers, return an array that contains the first and last index values such that all values are divisible by 13.\n\n  Examples:\n  * divisibleBy13([5, 6, 7]) => [0, 2]\n  * divisibleBy13([2, 4, 3, 0, 1, 5]) => [0, 2, 4, 3]\n  * divisibleBy13([2, 4, 3, 0, 1, 5, 6]) => [0, 2, 4, 3, 5]\n  */\nconst divisibleBy13 = (array) => {\n  const divisibleBy13Array = array.filter((value, index) => {\n    if (index % 13 === 0) {\n      return index;\n    }\n  });\n  return divisibleBy13Array;\n};\n\n/**\n * Given an array of non-negative integers, return an array that contains the first and last index values such that all values are divisible by 15.\n\n  Examples:\n  * divisibleBy15([5, 6, 7]) => [0, 2]\n  * divisibleBy15([2, 4, 3, 0, 1, 5]) => [0, 2, 4, 3]\n  * divisibleBy15([2, 4, 3, 0, 1, 5, 6]) => [0, 2, 4, 3, 5]\n  */\nconst divisibleBy15 = (array) => {\n  const divisibleBy15Array = array.filter((value, index) => {\n    if (index % 15 === 0) {\n      return index;\n    }\n  });\n  return divisibleBy15Array;\n};\n\n/**\n * Given an array of non-negative integers, return an array that contains the first and last index values such that all values are divisible by 17.\n\n  Examples:\n  * divisibleBy17([5, 6, 7]) => [0, 2]\n  * divisibleBy17([2, 4, 3, 0, 1, 5]) => [0, 2, 4, 3]\n  * divisibleBy17([2, 4, 3, 0, 1, 5, 6]) => [0, 2, 4, 3, 5]\n  */\nconst divisibleBy17 = (array) => {\n  const divisibleBy17Array = array.filter((value, index) => {\n    if (index % 17 === 0) {\n      return index;\n    }\n  });\n  return divisibleBy17Array;\n};\n\n/**\n * Given an array of non-negative integers, return an array that contains the first and last index values such that all values are divisible by 19.\n\n  Examples:\n  * divisibleBy19([5, 6, 7]) => [0, 2]\n  * divisibleBy19([2, 4, 3, 0, 1, 5]) => [0, 2, 4, 3]\n  * divisibleBy19([2, 4, 3, 0, 1, 5, 6]) => [0, 2, 4, 3, 5]\n  */\nconst divisibleBy19 = (array) => {\n  const divisibleBy19Array = array.filter((value, index) => {\n    if (index % 19 === 0) {\n      return index;\n    }\n  });\n  return divisibleBy19Array;\n};\n\n/**\n * Given an array of non-negative integers, return an array that contains the first and last index values such that all values are divisible by 23.\n\n  Examples:\n  * divisibleBy23([5, 6, 7]) => [0, 2]\n  * divisibleBy23([2, 4, 3, 0, 1, 5]) => [0, 2, 4, 3]\n  * divisibleBy23([2, 4, 3, 0, 1, 5, 6]) => [0, 2, 4, 3, 5]\n  */\nconst divisibleBy23 = (array) => {\n  const divisibleBy23Array = array.filter((value, "}
{"task_id": "JavaScript/89", "prompt": "/*CEncrypt a function that takes a string as argument and returns a string that is encrypted with the rotating alphabet. Rotate the alphabet so that the letters move down by two multiplied by two digits.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*CEncrypt a function that takes a string as argument and returns a string that is encrypted with the rotating alphabet. Rotate the alphabet so that the letters move down by two multiplied by two digits.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let a = []\n  let b = []\n  let c = []\n  let d = []\n  let e = []\n  let f = []\n  let g = []\n  let h = []\n  let i = []\n  let j = []\n  let k = []\n  let l = []\n  let m = []\n  let n = []\n  let o = []\n  let p = []\n  let q = []\n  let r = []\n  let s = []\n  let t = []\n  let u = []\n  let v = []\n  let w = []\n  let x = []\n  let y = []\n  let z = []\n  let A = []\n  let B = []\n  let C = []\n  let D = []\n  let E = []\n  let F = []\n  let G = []\n  let H = []\n  let I = []\n  let J = []\n  let K = []\n  let L = []\n  let M = []\n  let N = []\n  let O = []\n  let P = []\n  let Q = []\n  let R = []\n  let S = []\n  let T = []\n  let U = []\n  let V = []\n  let W = []\n  let X = []\n  let Y = []\n  let Z = []\n  let a = []\n  let b = []\n  let c = []\n  let d = []\n  let e = []\n  let f = []\n  let g = []\n  let h = []\n  let i = []\n  let j = []\n  let k = []\n  let l = []\n  let m = []\n  let n = []\n  let o = []\n  let p = []\n  let q = []\n  let r = []\n  let s = []\n  let t = []\n  let u = []\n  let v = []\n  let w = []\n  let x = []\n  let y = []\n  let z = []\n  let A = []\n  let B = []\n  let C = []\n  let D = []\n  let E = []\n  let F = []\n  let G = []\n  let H = []\n  let I = []\n  let J = []\n  let K = []\n  let L = []\n  let M = []\n  let N = []\n  let O = []\n  let P = []\n  let Q = []\n  let R = []\n  let S = []\n  let T = []\n  let U = []\n  let V = []\n  let W = []\n  let X = []\n  let Y = []\n  let Z = []\n  let a = []\n  let b = []\n  let c = []\n  let d = []\n  let e = []\n  let f = []\n  let g = []\n  let h = []\n  let i = []\n  let j = []\n  let k = []\n  let l = []\n  let m = []\n  let n = []\n  let o = []\n  let p = []\n  let q = []\n  let r = []\n  let s = []\n  let t = []\n  let u = []\n  let v = []\n  let w = []\n  let x = []\n  let y = []\n  let z = []\n  let A = []\n  let B = []\n  let C = []\n  let D = []\n  let E = []\n  let F = []\n  let G = []\n  let H = []\n  let I = []\n  let J = []\n  let K = []\n  let L = []\n  let M = []\n  let N = []\n  let O = []\n  let P = []\n  let Q = []\n  let R = []\n  let S = []\n  let T = []\n  let U = []\n  let V = []\n  let W = []\n  let X = []\n  let Y = []\n  let Z = []\n  let a = []\n  let b = []\n  let c = []\n  let d = []\n  let e = []\n  let f = []\n  let g = []\n  let h = []\n  let i = []\n  let j = []\n  let k = []\n  let l = []\n  let m = []\n  let n = []\n  let o = []\n  let p = []\n  let q = []\n  let r = []\n  let s = []\n  let t = []\n  let u = []\n  let v = []\n  let w = []\n  let x = []\n  let y = []\n  let z = []\n  let A = []\n  let B = []\n  let C = []\n  let D = []\n  let E = []\n  let F = []\n  let G = []\n  let H = []\n  let I = []\n  let J = []\n  let K = []\n  let L = []\n  let M = []\n  let N = []\n  let O = []\n  let P = []\n  let Q = []\n  let R = []\n  let S = []\n  let T = []\n  let U = []\n  let V = []\n  let W = []\n  let X = []\n  let Y = []\n  let Z = []\n  let a = []\n  let b = []\n  let c = []\n  let d = []\n  let e = []\n  let f = []\n  let g = []\n  let h = []\n  let i = []\n  let j = []\n  let k = []\n  let l = []\n  let m = []\n  let n = []\n  let o = []\n  let p = []\n  let q = []\n  let r = []\n  let s = []\n  let t = []\n  let u = []\n  let v = []\n  let w = []\n  let x = []\n  let y = []\n  let z = []\n  let A = []\n  let B = []\n  let C = []\n  let D = []\n  let E = []\n  let F = []\n  let G = []\n  let H = []\n  let I = []\n  let J = []\n  let K = []\n  let L = []\n  let M = []\n  let N = []\n  let O = []\n  let P = []\n  let Q = []\n  let R = []\n  let S = []\n  let T = []\n  let U = []\n  let V = []\n  let W = []\n  let X = []\n  let Y = []\n  let Z = []\n  let a = []\n  let b = []\n  let c = []\n  let d = []\n  let e = []\n  let f = []\n  let g = []\n  let h = []\n  let i = []\n  let j = []\n  let k = []\n  let l = []\n  let m = []\n  let n = []\n  let o = []\n  let p = []\n  let q = []\n  let r = []\n  let s = []\n  let t = []\n  let u = []\n  let v = []\n  let w = []\n  let x = []\n  let y = []\n  let z = []\n  let A = []\n  let B = []\n  let C = []\n  let D = []\n  let E = []\n  let F = []\n  let G = []\n  let H = []\n  let I = []\n  let J = []\n  let K = []\n  let L = []\n  let M = []\n  let N = []\n  let O = []\n  let P = []\n  let Q = []\n  let R = []\n  let S = []\n  let T = []\n  let U = []\n  let V = []\n  let W = []\n  let X = []\n  let Y = []\n  let Z = []\n  let a = []\n  let b = []\n  let c = []\n  let d = []\n  let e = []\n  let f = []\n  let g = []\n  let h = []\n  let i = []\n  let j = []\n  let k = []\n  let l = []\n  let m = []\n  let n = []\n  let o = []\n  let p = []\n  let q = []\n  let r = []\n  let s = []\n  let t = []\n  let u = []\n  let v = []\n  let w = []\n  let x = []\n  let y = []\n  let z = []\n  let A = []\n  let B = []\n  let C = []\n  let D = []\n  let E = []\n  let F = []\n  let G = []\n  let H = []\n  let I = []\n  let J = []\n  let K = []\n  let L = []\n  let M = []\n  let N = []\n  let O = []\n  let P = []\n  let Q = []\n  let R = []\n  let S = []\n  let T = []\n  let U = []\n  let V = []\n  let W = []\n  let X = []\n  let Y = []"}
{"task_id": "JavaScript/90", "prompt": "/*\n  Write a function nextSmallest () that returns the second smallest element in the list. Returns zero if there is no such element. nextSmallest ([1, 2, 3, 4, 5]) = = 2 nextSmallest ([5, 1, 4, 3, 2]) = = 2 nextSmallest ([]) = = null nextSmallest ([1, 1]) = = null * / const nextSmallest = (lst) = > {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function nextSmallest () that returns the second smallest element in the list. Returns zero if there is no such element. nextSmallest ([1, 2, 3, 4, 5]) = = 2 nextSmallest ([5, 1, 4, 3, 2]) = = 2 nextSmallest ([]) = = null nextSmallest ([1, 1]) = = null * / const nextSmallest = (lst) = > {\n    let smallest = lst[0];\n    for (let i = 1; i < lst.length; i++) {\n      if (lst[i] < smallest) {\n        smallest = lst[i];\n      }\n    }\n    return smallest;\n  }\n*/\n\nconst nextSmallest = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest2 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest3 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest4 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest5 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest6 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest7 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest8 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest9 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest10 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest11 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest12 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest13 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest14 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest15 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest16 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest17 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest18 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest19 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest20 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest21 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest22 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest23 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest24 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest25 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest26 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest27 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest28 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest29 = list => {\n  let smallest = list[0];\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] < smallest) {\n      smallest = list[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest30"}
{"task_id": "JavaScript/91", "prompt": "/*\n  Boredom is a sentence that begins with the word \"I.\" Sentences are delimited by. \",\"? \"or\"!. \"For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Boredom is a sentence that begins with the word \"I.\" Sentences are delimited by. \",\"? \"or\"!. \"For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  const boredWords = [\n    \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I."}
{"task_id": "JavaScript/92", "prompt": "/* Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  return x === y && x === z || x === -y && x === -z || x === +y && x === +z || x === +-y && x === +-z;\n};\n\n/**\n * Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  allInt(5, 2, 7) ➞ true\n  allInt(3, 2, 2) ➞ false\n  allInt(3, -2, 1) ➞ true\n  allInt(3.6, -2.2, 2) ➞ false\n  */\nconst allInt = (x, y, z) => {\n  return x === y && x === z || x === -y && x === -z || x === +y && x === +z || x === +-y && x === +-z;\n};\n\n/**\n * Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  evenInt(5, 2, 7) ➞ true\n  evenInt(3, 2, 2) ➞ false\n  evenInt(3, -2, 1) ➞ true\n  evenInt(3.6, -2.2, 2) ➞ false\n  */\nconst evenInt = (x, y, z) => {\n  return x % 2 === 0 && y % 2 === 0 && z % 2 === 0;\n};\n\n/**\n * Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  oddInt(5, 2, 7) ➞ true\n  oddInt(3, 2, 2) ➞ false\n  oddInt(3, -2, 1) ➞ true\n  oddInt(3.6, -2.2, 2) ➞ false\n  */\nconst oddInt = (x, y, z) => {\n  return x % 2 === 1 && y % 2 === 1 && z % 2 === 1;\n};\n\n/**\n * Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  evenOdd(5, 2, 7) ➞ true\n  evenOdd(3, 2, 2) ➞ false\n  evenOdd(3, -2, 1) ➞ true\n  evenOdd(3.6, -2.2, 2) ➞ false\n  */\nconst evenOdd = (x, y, z) => {\n  return x % 2 === 0 && y % 2 === 0 && z % 2 === 0;\n};\n\n/**\n * Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  oddOdd(5, 2, 7) ➞ true\n  oddOdd(3, 2, 2) ➞ false\n  oddOdd(3, -2, 1) ➞ true\n  oddOdd(3.6, -2.2, 2) ➞ false\n  */\nconst oddOdd = (x, y, z) => {\n  return x % 2 === 1 && y % 2 === 1 && z % 2 === 1;\n};\n\n/**\n * Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  evenOddInt(5, 2, 7) ➞ true\n  evenOddInt(3, 2, 2) ➞ false\n  evenOddInt(3, -2, 1) ➞ true\n  evenOddInt(3.6, -2.2, 2) ➞ false\n  */\nconst evenOddInt = (x, y, z) => {\n  return x % 2 === 0 && y % 2 === 0 && z % 2 === 0;\n};\n\n/**\n * Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  oddOddInt(5, 2, 7) ➞ true\n  oddOddInt(3, 2, 2) ➞ false\n  oddOddInt(3, -2, 1) ➞ true\n  oddOddInt(3.6, -2.2, 2) ➞ false\n  */\nconst oddOddInt = (x, y, z) => {\n  return x % 2 === 1 && y % 2 === 1 && z % 2 === 1;\n};\n\n/**\n * Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  evenOddOdd(5, 2, 7) ➞ true\n  evenOddOdd(3, 2, 2) ➞ false\n  evenOddOdd(3, -2, 1) ➞ true\n  evenOddOdd(3.6, -2.2, 2) ➞ false\n  */\nconst evenOddOdd = (x, y, z) => {\n  return x % 2 === 0 && y % 2 === 0 && z % 2 === 0;\n};\n\n/**\n * Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  oddOddOdd(5, 2, 7) ➞ true\n  oddOddOdd(3, 2, 2) ➞ false\n  oddOddOdd(3, -2, 1) ➞ true\n  oddOddOdd(3.6, -2.2, 2) ➞ false\n  */\nconst oddOddOdd = (x, y, z) => {\n  return x % 2 === 1 && y % 2 === 1 && z % 2 === 1;\n};\n\n/**\n * Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  evenOddOddInt(5, 2, 7) ➞ true\n  evenOddOddInt(3, 2, 2) ➞ false\n  evenOddOddInt(3, -2, 1) ➞ true\n  evenOddOddInt(3.6, -2.2, 2) ➞ false\n  */\nconst evenOddOddInt = (x, y, z) => {\n  return x % 2 === 0 && y % 2 === 0 && z % 2 === 0;\n};\n\n/**\n * Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  oddOddOddInt(5, 2, 7) ➞ true\n  oddOddOddInt(3, 2, 2) ➞ false\n  oddOddOddInt(3, -2, 1) ➞ true\n  oddOddOddInt(3.6, -2.2, 2) ➞ false\n  */\nconst oddOddOddInt = (x, y, z) => {\n  return x % 2 === 1 && y % 2 === 1 && z % 2 === 1;\n};\n\n/**\n * Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  evenOddOddO"}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a function that captures a message and encodes it so that it reverses the uppercase letters of all letters and replaces all vowels in the message with the letter that appears 2 places in front of that vowel in the English alphabet. Let's just say letters. Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that captures a message and encodes it so that it reverses the uppercase letters of all letters and replaces all vowels in the message with the letter that appears 2 places in front of that vowel in the English alphabet. Let's just say letters. Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let encoded = '';\n  let vowels = 'aeiouAEIOU';\n  let vowelsLength = vowels.length;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageIndex = 0;\n  let messageLength = message.length;"}
{"task_id": "JavaScript/94", "prompt": "/*YYou get a list of integers. You have to find the largest primary value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*YYou get a list of integers. You have to find the largest primary value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let sum = 0;\n  let max = 0;\n  let maxIndex = 0;\n  let maxDigit = 0;\n  let maxDigitIndex = 0;\n  let maxDigitDigit = 0;\n  let maxDigitDigitIndex = 0;\n  let maxDigitDigitDigit = 0;\n  let maxDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigit"}
{"task_id": "JavaScript/95", "prompt": "/*\n  If you specify a dictionary, you return true if all key strings are lowercase or all key strings are uppercase, otherwise you return false. If the specified dictionary is empty, the function should return false.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  If you specify a dictionary, you return true if all key strings are lowercase or all key strings are uppercase, otherwise you return false. If the specified dictionary is empty, the function should return false.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict);\n  let allKeysLowerCase = true;\n  let allKeysUpperCase = true;\n  keys.forEach((key) => {\n    if (dict[key.toLowerCase()]!== dict[key.toUpperCase()]) {\n      allKeysLowerCase = false;\n    }\n    if (dict[key.toUpperCase()]!== dict[key.toLowerCase()]) {\n      allKeysUpperCase = false;\n    }\n  });\n  return allKeysLowerCase && allKeysUpperCase;\n};\n\n/**\n * Checks if the given string is a valid phone number.\n * Examples:\n * isPhoneNumber(\"(123) 456-7890\") should return true.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 456-7890\") should return false.\n * isPhoneNumber(\"(123) 45"}
{"task_id": "JavaScript/96", "prompt": "/*IImplement a function that takes a non-negative integer and returns an array of the first n integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*IImplement a function that takes a non-negative integer and returns an array of the first n integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let arr = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      arr.push(i);\n      i++;\n    }\n    if (n % j === 0) {\n      arr.push(j);\n      j++;\n    }\n    if (n % k === 0) {\n      arr.push(k);\n      k++;\n    }\n  }\n  return arr;\n};\n\n/**\n  IImplement a function that takes a non-negative integer and returns an array of the first n integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let arr = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      arr.push(i);\n      i++;\n    }\n    if (n % j === 0) {\n      arr.push(j);\n      j++;\n    }\n    if (n % k === 0) {\n      arr.push(k);\n      k++;\n    }\n  }\n  return arr;\n};\n\n/**\n  IImplement a function that takes a non-negative integer and returns an array of the first n integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let arr = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      arr.push(i);\n      i++;\n    }\n    if (n % j === 0) {\n      arr.push(j);\n      j++;\n    }\n    if (n % k === 0) {\n      arr.push(k);\n      k++;\n    }\n  }\n  return arr;\n};\n\n/**\n  IImplement a function that takes a non-negative integer and returns an array of the first n integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let arr = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      arr.push(i);\n      i++;\n    }\n    if (n % j === 0) {\n      arr.push(j);\n      j++;\n    }\n    if (n % k === 0) {\n      arr.push(k);\n      k++;\n    }\n  }\n  return arr;\n};\n\n/**\n  IImplement a function that takes a non-negative integer and returns an array of the first n integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let arr = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      arr.push(i);\n      i++;\n    }\n    if (n % j === 0) {\n      arr.push(j);\n      j++;\n    }\n    if (n % k === 0) {\n      arr.push(k);\n      k++;\n    }\n  }\n  return arr;\n};\n\n/**\n  IImplement a function that takes a non-negative integer and returns an array of the first n integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let arr = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      arr.push(i);\n      i++;\n    }\n    if (n % j === 0) {\n      arr.push(j);\n      j++;\n    }\n    if (n % k === 0) {\n      arr.push(k);\n      k++;\n    }\n  }\n  return arr;\n};\n\n/**\n  IImplement a function that takes a non-negative integer and returns an array of the first n integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let arr = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      arr.push(i);\n      i++;\n    }\n    if (n % j === 0) {\n      arr.push(j);\n      j++;\n    }\n    if (n % k === 0) {\n      arr.push(k);\n      k++;\n    }\n  }\n  return arr;\n};\n\n/**\n  IImplement a function that takes a non-negative integer and returns an array of the first n integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let arr = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      arr.push(i);\n      i++;\n    }\n    if (n % j === 0) {\n      arr.push(j);\n      j++;\n    }\n    if (n % k === 0) {\n      arr.push(k);\n      k++;\n    }\n  }\n  return arr;\n};\n\n/**\n  IImplement a function that takes a non-negative integer and returns an array of the first n integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  "}
{"task_id": "JavaScript/97", "prompt": "/*CComplete the function that takes two integers and returns the product of their unit digits. Suppose the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*CComplete the function that takes two integers and returns the product of their unit digits. Suppose the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let product = 1;\n  for (let i = a; i; i--) {\n    product *= i;\n  }\n  return product;\n};\n\n/*\n  Complete the function that takes two integers and returns the sum of their digits. Suppose the input is always valid.\n  Examples:\n  sum(148, 412) should return 148.\n  sum(19, 28) should return 28.\n  sum(2020, 1851) should return 1851.\n  sum(14,-15) should return 14.\n  */\nconst sum = (a, b) => {\n  let sum = 0;\n  for (let i = a; i; i--) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  Complete the function that takes two integers and returns the difference between their digits. Suppose the input is always valid.\n  Examples:\n  difference(148, 412) should return -412.\n  difference(19, 28) should return -28.\n  difference(2020, 1851) should return -1851.\n  difference(14,-15) should return 14.\n  */\nconst difference = (a, b) => {\n  let difference = 0;\n  for (let i = a; i; i--) {\n    difference += i % 10;\n  }\n  return difference;\n};\n\n/*\n  Complete the function that takes two integers and returns the absolute value of their digits. Suppose the input is always valid.\n  Examples:\n  abs(148, 412) should return 148.\n  abs(19, 28) should return 28.\n  abs(2020, 1851) should return 1851.\n  abs(14,-15) should return 14.\n  */\nconst abs = (a, b) => {\n  let absolute = 0;\n  for (let i = a; i; i--) {\n    absolute += Math.abs(i);\n  }\n  return absolute;\n};\n\n/*\n  Complete the function that takes two integers and returns the number of trailing zeroes in their digits. Suppose the input is always valid.\n  Examples:\n  trailingZeroes(148, 412) should return 4.\n  trailingZeroes(19, 28) should return 2.\n  trailingZeroes(2020, 1851) should return 0.\n  trailingZeroes(14,-15) should return 0.\n  */\nconst trailingZeroes = (a, b) => {\n  let trailingZeroes = 0;\n  for (let i = a; i; i--) {\n    if (i % 10 === 0) {\n      trailingZeroes++;\n    }\n  }\n  return trailingZeroes;\n};\n\n/*\n  Complete the function that takes two integers and returns the number of leading zeroes in their digits. Suppose the input is always valid.\n  Examples:\n  leadingZeroes(148, 412) should return 4.\n  leadingZeroes(19, 28) should return 2.\n  leadingZeroes(2020, 1851) should return 0.\n  leadingZeroes(14,-15) should return 0.\n  */\nconst leadingZeroes = (a, b) => {\n  let leadingZeroes = 0;\n  for (let i = a; i; i--) {\n    if (i % 10 === 0) {\n      leadingZeroes++;\n    }\n  }\n  return leadingZeroes;\n};\n\n/*\n  Complete the function that takes two integers and returns the number of trailing zeroes and leading zeroes in their digits. Suppose the input is always valid.\n  Examples:\n  trailingZeroesAndLeadingZeroes(148, 412) should return (4,2).\n  trailingZeroesAndLeadingZeroes(19, 28) should return (2,1).\n  trailingZeroesAndLeadingZeroes(2020, 1851) should return (0,0).\n  trailingZeroesAndLeadingZeroes(14,-15) should return (0,0).\n  */\nconst trailingZeroesAndLeadingZeroes = (a, b) => {\n  let trailingZeroes = 0;\n  let leadingZeroes = 0;\n  for (let i = a; i; i--) {\n    if (i % 10 === 0) {\n      trailingZeroes++;\n    }\n    if (i % 10 === 0) {\n      leadingZeroes++;\n    }\n  }\n  return [trailingZeroes, leadingZeroes];\n};\n\n/*\n  Complete the function that takes two integers and returns the number of trailing zeroes and leading zeroes in their digits. Suppose the input is always valid.\n  Examples:\n  trailingZeroesAndLeadingZeroesAndLeadingZeroes(148, 412) should return (4,2,1).\n  trailingZeroesAndLeadingZeroesAndLeadingZeroes(19, 28) should return (2,1,0).\n  trailingZeroesAndLeadingZeroesAndLeadingZeroes(2020, 1851) should return (0,0,0,0).\n  trailingZeroesAndLeadingZeroesAndLeadingZeroes(14,-15) should return (0,0,0,0).\n  */\nconst trailingZeroesAndLeadingZeroesAndLeadingZeroes = (a, b) => {\n  let trailingZeroes = 0;\n  let leadingZeroes = 0;\n  let leadingZeroesAndLeadingZeroes = 0;\n  for (let i = a; i; i--) {\n    if (i % 10 === 0) {\n      trailingZeroes++;\n    }\n    if (i % 10 === 0) {\n      leadingZeroes++;\n    }\n    if (i % 10 === 0) {\n      leadingZeroesAndLeadingZeroes++;\n    }\n  }\n  return [trailingZeroes, leadingZeroes, leadingZeroesAndLeadingZeroes];\n};\n\n/*\n  Complete the function that takes two integers and returns the number of trailing zeroes and leading zeroes in their digits. Suppose the input is always valid.\n  Examples:\n  trailingZeroesAndLeadingZeroesAndLeadingZeroesAndLeadingZeroes(148, 412) should return (4,2,1,1).\n  trailingZeroesAndLeadingZeroesAndLeadingZeroesAndLeadingZeroes(19, 28) should return (2,1,0,0).\n  trailingZeroesAndLeadingZeroesAndLeadingZeroesAndLeadingZeroes(2020, 1851) should return (0,0,0,0,0).\n  trailingZeroesAndLeadingZeroesAndLeadingZeroesAndLeadingZeroes(14,-15) should return (0,0,0,0,0).\n  */\nconst trailingZeroesAndLeadingZeroesAndLeadingZeroesAndLeadingZeroes = (a, b) => {\n  let trailingZeroes = 0;\n  let leadingZeroes = 0;\n  let leadingZeroesAndLeadingZeroes = 0;\n  let leadingZeroesAndLeadingZeroesAndLeadingZeroes = 0;\n  for (let i = a; i; i--) {\n    if (i % 10 === 0) {\n      trailingZeroes++;\n    }\n    if (i % 10 === 0) {\n      leadingZeroes++;\n    }\n    if (i % 10 === 0) {\n      leadingZeroesAndLeadingZeroes++;\n    }\n    if (i % 10 === 0) {\n      leadingZeroesAndLeadingZeroesAndLeadingZeroes++;\n    }\n  }\n  return [trailingZeroes, leadingZeroes, leadingZeroesAndLeadingZeroes, leadingZeroesAndLeadingZeroesAndLeadingZeroes];\n};\n\n/*\n  Complete the function that takes two integers and returns the number of trailing zeroes and leading zeroes in their digits. Suppose the input is always valid.\n  Examples:\n  trailingZeroesAndLeadingZeroesAndLeadingZeroesAndLeadingZeroesAndLeadingZeroes(148, 412) should "}
{"task_id": "JavaScript/98", "prompt": "/*\n  For a string s, the number of uppercase letters in even indexes is counted.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  For a string s, the number of uppercase letters in even indexes is counted.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length - 1; i++) {\n    if (s.charAt(i).toUpperCase() === s.charAt(i + 1)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, return true if and only if the string contains only lowercase letters.\n  \n  For example:\n  lowerCase('aBCdEf') returns true\n  lowerCase('abcdefg') returns false\n  lowerCase('dBBE') returns false\n  */\nconst lowerCase = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length - 1; i++) {\n    if (s.charAt(i).toLowerCase() === s.charAt(i + 1)) {\n      count++;\n    }\n  }\n  return count === 0;\n};\n\n/*\n  Given a string s, return true if and only if the string contains only uppercase letters.\n  \n  For example:\n  upperCase('aBCdEf') returns true\n  upperCase('abcdefg') returns false\n  upperCase('dBBE') returns false\n  */\nconst upperCase = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length - 1; i++) {\n    if (s.charAt(i).toUpperCase() === s.charAt(i + 1)) {\n      count++;\n    }\n  }\n  return count === 0;\n};\n\n/*\n  Given a string s, return true if and only if the string contains only digits and letters.\n  \n  For example:\n  digits('aBCdEf') returns true\n  digits('abcdefg') returns false\n  digits('dBBE') returns false\n  */\nconst digits = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length - 1; i++) {\n    if (s.charAt(i).match(/\\d/)) {\n      count++;\n    }\n  }\n  return count === 0;\n};\n\n/*\n  Given a string s, return true if and only if the string contains only letters.\n  \n  For example:\n  letters('aBCdEf') returns true\n  letters('abcdefg') returns false\n  letters('dBBE') returns false\n  */\nconst letters = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length - 1; i++) {\n    if (s.charAt(i).toLowerCase() === s.charAt(i + 1)) {\n      count++;\n    }\n  }\n  return count === 0;\n};\n\n/*\n  Given a string s, return true if and only if the string contains only uppercase letters.\n  \n  For example:\n  upperCase('aBCdEf') returns true\n  upperCase('abcdefg') returns false\n  upperCase('dBBE') returns false\n  */\nconst upperCaseLetters = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length - 1; i++) {\n    if (s.charAt(i).toUpperCase() === s.charAt(i + 1)) {\n      count++;\n    }\n  }\n  return count === 0;\n};\n\n/*\n  Given a string s, return true if and only if the string contains only digits and letters.\n  \n  For example:\n  digits('aBCdEf') returns true\n  digits('abcdefg') returns false\n  digits('dBBE') returns false\n  */\nconst digitsAndLetters = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length - 1; i++) {\n    if (s.charAt(i).match(/\\d/)) {\n      count++;\n    }\n  }\n  return count === 0;\n};\n\n/*\n  Given a string s, return true if and only if the string contains only letters.\n  \n  For example:\n  letters('aBCdEf') returns true\n  letters('abcdefg') returns false\n  letters('dBBE') returns false\n  */\nconst lettersAndDigits = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length - 1; i++) {\n    if (s.charAt(i).toLowerCase() === s.charAt(i + 1)) {\n      count++;\n    }\n  }\n  return count === 0;\n};\n\n/*\n  Given a string s, return true if and only if the string contains only uppercase letters.\n  \n  For example:\n  upperCase('aBCdEf') returns true\n  upperCase('abcdefg') returns false\n  upperCase('dBBE') returns false\n  */\nconst upperCaseLettersAndDigits = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length - 1; i++) {\n    if (s.charAt(i).toUpperCase() === s.charAt(i + 1)) {\n      count++;\n    }\n  }\n  return count === 0;\n};\n\n/*\n  Given a string s, return true if and only if the string contains only digits and letters.\n  \n  For example:\n  digits('aBCdEf') returns true\n  digits('abcdefg') returns false\n  digits('dBBE') returns false\n  */\nconst digitsAndLettersAndDigits = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length - 1; i++) {\n    if (s.charAt(i).match(/\\d/)) {\n      count++;\n    }\n  }\n  return count === 0;\n};\n\n/*\n  Given a string s, return true if and only if the string contains only uppercase letters.\n  \n  For example:\n  upperCase('aBCdEf') returns true\n  upperCase('abcdefg') returns false\n  upperCase('dBBE') returns false\n  */\nconst upperCaseLettersAndLetters = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length - 1; i++) {\n    if (s.charAt(i).toLowerCase() === s.charAt(i + 1)) {\n      count++;\n    }\n  }\n  return count === 0;\n};\n\n/*\n  Given a string s, return true if and only if the string contains only digits and letters.\n  \n  For example:\n  digits('aBCdEf') returns true\n  digits('abcdefg') returns false\n  digits('dBBE') returns false\n  */\nconst digitsAndLettersAndDigits = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length - 1; i++) {\n    if (s.charAt(i).match(/\\d/)) {\n      count++;\n    }\n  }\n  return count === 0;\n};\n\n/*\n  Given a string s, return true if and only if the string contains only uppercase letters.\n  \n  For example:\n  upperCase('aBCdEf') returns true\n  upperCase('abcdefg') returns false\n  upperCase('dBBE') returns false\n  */\nconst upperCaseLettersAndLettersAndDigits = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length - 1; i++) {\n    if (s.charAt(i).toLowerCase() === s.charAt(i + 1)) {\n      count++;\n    }\n  }\n  return count === 0;\n};\n\n/*\n  Given a string s, return true if and only if the string contains only uppercase letters.\n  \n  For example:\n  upperCase('aBCdEf') returns true\n  upperCase('abcdefg') returns false\n  upperCase('dBBE') returns false\n  */\nconst upperCaseLettersAndLettersAndDigits = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length - 1; i++) {\n    if (s.charAt(i).toLowerCase() === s.charAt(i + 1)) {\n      count++;\n    }\n  }\n  return count === 0;\n};\n\n/*\n  Given a string s, return true if and only if the string contains only uppercase letters.\n  \n  For example:\n  upperCase('aBCdEf') returns true\n  upperCase('abcdefg') returns false\n  upperCase('dBBE') returns false\n  */\nconst upperCaseLettersAndLettersAndLettersAndDigits = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length - 1; i++) {\n    if (s.charAt(i).toLowerCase() === s.charAt(i + 1)) {\n      count++;\n    }\n  }\n"}
{"task_id": "JavaScript/99", "prompt": "/* Create a function that takes a value (string) that represents a number and returns the nearest integer to it. If the number is equal to two integers, round it from zero. Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Create a function that takes a value (string) that represents a number and returns the nearest integer to it. If the number is equal to two integers, round it from zero. Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  const [integer, fraction] = value.split(\".\");\n  const [integer2, fraction2] = integer.split(\".\");\n  const [integer3, fraction3] = fraction.split(\".\");\n  const [integer4, fraction4] = fraction2.split(\".\");\n  const [integer5, fraction5] = fraction3.split(\".\");\n  const [integer6, fraction6] = fraction4.split(\".\");\n  const [integer7, fraction7] = fraction5.split(\".\");\n  const [integer8, fraction8] = fraction6.split(\".\");\n  const [integer9, fraction9] = fraction7.split(\".\");\n  const [integer10, fraction10] = fraction8.split(\".\");\n  const [integer11, fraction11] = fraction9.split(\".\");\n  const [integer12, fraction12] = fraction10.split(\".\");\n  const [integer13, fraction13] = fraction11.split(\".\");\n  const [integer14, fraction14] = fraction12.split(\".\");\n  const [integer15, fraction15] = fraction13.split(\".\");\n  const [integer16, fraction16] = fraction14.split(\".\");\n  const [integer17, fraction17] = fraction15.split(\".\");\n  const [integer18, fraction18] = fraction16.split(\".\");\n  const [integer19, fraction19] = fraction17.split(\".\");\n  const [integer20, fraction20] = fraction18.split(\".\");\n  const [integer21, fraction21] = fraction19.split(\".\");\n  const [integer22, fraction22] = fraction20.split(\".\");\n  const [integer23, fraction23] = fraction21.split(\".\");\n  const [integer24, fraction24] = fraction22.split(\".\");\n  const [integer25, fraction25] = fraction23.split(\".\");\n  const [integer26, fraction26] = fraction24.split(\".\");\n  const [integer27, fraction27] = fraction25.split(\".\");\n  const [integer28, fraction28] = fraction26.split(\".\");\n  const [integer29, fraction29] = fraction27.split(\".\");\n  const [integer30, fraction30] = fraction28.split(\".\");\n  const [integer31, fraction31] = fraction29.split(\".\");\n  const [integer32, fraction32] = fraction30.split(\".\");\n  const [integer33, fraction33] = fraction31.split(\".\");\n  const [integer34, fraction34] = fraction32.split(\".\");\n  const [integer35, fraction35] = fraction33.split(\".\");\n  const [integer36, fraction36] = fraction34.split(\".\");\n  const [integer37, fraction37] = fraction35.split(\".\");\n  const [integer38, fraction38] = fraction36.split(\".\");\n  const [integer39, fraction39] = fraction37.split(\".\");\n  const [integer40, fraction40] = fraction38.split(\".\");\n  const [integer41, fraction41] = fraction39.split(\".\");\n  const [integer42, fraction42] = fraction40.split(\".\");\n  const [integer43, fraction43] = fraction41.split(\".\");\n  const [integer44, fraction44] = fraction42.split(\".\");\n  const [integer45, fraction45] = fraction43.split(\".\");\n  const [integer46, fraction46] = fraction44.split(\".\");\n  const [integer47, fraction47] = fraction45.split(\".\");\n  const [integer48, fraction48] = fraction46.split(\".\");\n  const [integer49, fraction49] = fraction47.split(\".\");\n  const [integer50, fraction50] = fraction48.split(\".\");\n  const [integer51, fraction51] = fraction49.split(\".\");\n  const [integer52, fraction52] = fraction50.split(\".\");\n  const [integer53, fraction53] = fraction51.split(\".\");\n  const [integer54, fraction54] = fraction52.split(\".\");\n  const [integer55, fraction55] = fraction53.split(\".\");\n  const [integer56, fraction56] = fraction54.split(\".\");\n  const [integer57, fraction57] = fraction55.split(\".\");\n  const [integer58, fraction58] = fraction56.split(\".\");\n  const [integer59, fraction59] = fraction57.split(\".\");\n  const [integer60, fraction60] = fraction58.split(\".\");\n  const [integer61, fraction61] = fraction59.split(\".\");\n  const [integer62, fraction62] = fraction60.split(\".\");\n  const [integer63, fraction63] = fraction61.split(\".\");\n  const [integer64, fraction64] = fraction62.split(\".\");\n  const [integer65, fraction65] = fraction63.split(\".\");\n  const [integer66, fraction66] = fraction64.split(\".\");\n  const [integer67, fraction67] = fraction65.split(\".\");\n  const [integer68, fraction68] = fraction66.split(\".\");\n  const [integer69, fraction69] = fraction67.split(\".\");\n  const [integer70, fraction70] = fraction68.split(\".\");\n  const [integer71, fraction71] = fraction69.split(\".\");\n  const [integer72, fraction72] = fraction70.split(\".\");\n  const [integer73, fraction73] = fraction71.split(\".\");\n  const [integer74, fraction74] = fraction72.split(\".\");\n  const [integer75, fraction75] = fraction73.split(\".\");\n  const [integer76, fraction76] = fraction74.split(\".\");\n  const [integer77, fraction77] = fraction75.split(\".\");\n  const [integer78, fraction78] = fraction76.split(\".\");\n  const [integer79, fraction79] = fraction77.split(\".\");\n  const [integer80, fraction80] = fraction78.split(\".\");\n  const [integer81, fraction81] = fraction79.split(\".\");\n  const [integer82, fraction82] = fraction80.split(\".\");\n  const [integer83, fraction83] = fraction81.split(\".\");\n  const [integer84, fraction84] = fraction82.split(\".\");\n  const [integer85, fraction85] = fraction83.split(\".\");\n  const [integer86, fraction86] = fraction84.split(\".\");\n  const [integer87, fraction87] = fraction85.split(\".\");\n  const [integer88, fraction88] = fraction86.split(\".\");\n  const [integer89, fraction89] = fraction87.split(\".\");\n  const [integer90, fraction90] = fraction88.split(\".\");\n  const [integer91, fraction91] = fraction89.split(\".\");\n  const [integer92, fraction92] = fraction90.split(\".\");\n  const [integer93, fraction93] = fraction91.split(\".\");\n  const [integer94, fraction94] = fraction92.split(\".\");\n  const [integer95, fraction95] = fraction93.split(\".\");\n  const [integer96, fraction96] = fraction94.split(\".\");\n  const [integer97, fraction97] = fraction95.split(\".\");\n  const [integer98, fraction98] = fraction96.split(\".\");\n  const [integer99, fraction99] = fraction97.split(\".\");\n  const [integer100, fraction100] = fraction98.split(\".\");\n  const [integer101, fraction101] = fraction99.split(\".\");\n  const [integer102, fraction102] = fraction100.split(\".\");\n  const [integer103, fraction103] = fraction10"}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [[]];\n  let level = 0;\n  while (level < n) {\n    levels[level].push(level);\n    level++;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [[]];\n  let level = 0;\n  while (level < n) {\n    levels[level].push(level);\n    level++;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [[]];\n  let level = 0;\n  while (level < n) {\n    levels[level].push(level);\n    level++;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [[]];\n  let level = 0;\n  while (level < n) {\n    levels[level].push(level);\n    level++;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [[]];\n  let level = 0;\n  while (level < n) {\n    levels[level].push(level);\n    level++;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [[]];\n  let level = 0;\n  while (level < n) {\n    levels[level].push(level);\n    level++;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [[]];\n  let level = 0;\n  while (level < n) {\n    levels[level].push(level);\n    level++;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [[]];\n  let level = 0;\n  while (level < n) {\n    levels[level].push(level);\n    level++;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [[]];\n  let level = 0;\n  while (level < n) {\n    levels[level].push(level);\n    level++;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [[]];\n  let level = 0;\n  while (level < n) {\n    levels[level].push(level);\n    level++;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [[]];\n  let level = 0;\n  while (level < n) {\n    levels[level].push(level);\n    level++;\n  }\n  return "}
{"task_id": "JavaScript/101", "prompt": "/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by "}
{"task_id": "JavaScript/102", "prompt": "/*TIts function takes two positive numbers x and y and returns the largest even integer, which is in the range [x, y]. If there is no such number, the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*TIts function takes two positive numbers x and y and returns the largest even integer, which is in the range [x, y]. If there is no such number, the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  const numOfDigits = Math.floor(Math.log10(x) + Math.log10(y));\n  return Math.floor(Math.pow(10, numOfDigits)) * x + Math.floor(Math.pow(10, numOfDigits - 1)) * y;\n};\n\n/**\n * Given a number, return its binary representation in base 2.\n * For example, given 12, the binary representation is 1011.\n */\nconst binaryToDecimal = number => {\n  let binary = '';\n  let decimal = '';\n  let power = 0;\n  let powerOfTen = 0;\n\n  while (number > 0) {\n    power = Math.floor(Math.log(number) / Math.LN2);\n    number = number / Math.pow(10, power);\n    binary += String.fromCharCode(powerOfTen);\n    powerOfTen = power;\n  }\n\n  while (binary!== '0') {\n    decimal = binary + decimal;\n    binary = '';\n  }\n\n  return decimal;\n};\n\n/**\n * Given a number, return its decimal representation in base 10.\n * For example, given 12, the decimal representation is 12.\n */\nconst decimalToBinary = number => {\n  let decimal = '';\n  let power = 0;\n  let powerOfTen = 0;\n\n  while (number > 0) {\n    power = Math.floor(Math.log(number) / Math.LN10);\n    number = number / Math.pow(10, power);\n    decimal += String.fromCharCode(powerOfTen);\n    powerOfTen = power;\n  }\n\n  while (decimal!== '0') {\n    binary = decimal + binary;\n    decimal = '';\n  }\n\n  return binary;\n};\n\n/**\n * Given a number, return its octal representation in base 8.\n * For example, given 12, the octal representation is 1101.\n */\nconst octalToDecimal = number => {\n  let octal = '';\n  let decimal = '';\n  let power = 0;\n  let powerOfTen = 0;\n\n  while (number > 0) {\n    power = Math.floor(Math.log(number) / Math.LN8);\n    number = number / Math.pow(10, power);\n    octal += String.fromCharCode(powerOfTen);\n    powerOfTen = power;\n  }\n\n  while (octal!== '0') {\n    decimal = octal + decimal;\n    octal = '';\n  }\n\n  return decimal;\n};\n\n/**\n * Given a number, return its hex representation in base 16.\n * For example, given 12, the hex representation is 0x12.\n */\nconst hexToDecimal = number => {\n  let hex = '';\n  let decimal = '';\n  let power = 0;\n  let powerOfTen = 0;\n\n  while (number > 0) {\n    power = Math.floor(Math.log(number) / Math.LN16);\n    number = number / Math.pow(10, power);\n    hex += String.fromCharCode(powerOfTen);\n    powerOfTen = power;\n  }\n\n  while (hex.length % 2!== 0) {\n    decimal = hex + decimal;\n    hex = '';\n  }\n\n  return decimal;\n};\n\n/**\n * Given a number, return its triple decimal representation in base 8.\n * For example, given 12, the triple decimal representation is 0x12.\n */\nconst tripleDecimalToBinary = number => {\n  let decimal = '';\n  let power = 0;\n  let powerOfTen = 0;\n\n  while (number > 0) {\n    power = Math.floor(Math.log(number) / Math.LN8);\n    number = number / Math.pow(10, power);\n    decimal += String.fromCharCode(powerOfTen);\n    powerOfTen = power;\n  }\n\n  while (decimal!== '0') {\n    binary = decimal + binary;\n    decimal = '';\n  }\n\n  return binary;\n};\n\n/**\n * Given a number, return its binary representation in base 10.\n * For example, given 12, the binary representation is 1011.\n */\nconst binaryToOctal = number => {\n  let binary = '';\n  let octal = '';\n  let power = 0;\n  let powerOfTen = 0;\n\n  while (number > 0) {\n    power = Math.floor(Math.log(number) / Math.LN10);\n    number = number / Math.pow(10, power);\n    binary += String.fromCharCode(powerOfTen);\n    powerOfTen = power;\n  }\n\n  while (binary!== '0') {\n    octal = octal + octal;\n    binary = '';\n  }\n\n  return octal;\n};\n\n/**\n * Given a number, return its decimal representation in base 10.\n * For example, given 12, the decimal representation is 12.\n */\nconst decimalToHex = number => {\n  let decimal = '';\n  let hex = '';\n  let power = 0;\n  let powerOfTen = 0;\n\n  while (number > 0) {\n    power = Math.floor(Math.log(number) / Math.LN10);\n    number = number / Math.pow(10, power);\n    decimal += String.fromCharCode(powerOfTen);\n    powerOfTen = power;\n  }\n\n  while (decimal!== '0') {\n    hex = hex + hex;\n    decimal = '';\n  }\n\n  return hex;\n};\n\n/**\n * Given a number, return its triple decimal representation in base 8.\n * For example, given 12, the triple decimal representation is 0x12.\n */\nconst tripleDecimalToOctal = number => {\n  let decimal = '';\n  let octal = '';\n  let power = 0;\n  let powerOfTen = 0;\n\n  while (number > 0) {\n    power = Math.floor(Math.log(number) / Math.LN8);\n    number = number / Math.pow(10, power);\n    octal += String.fromCharCode(powerOfTen);\n    powerOfTen = power;\n  }\n\n  while (octal!== '0') {\n    decimal = octal + decimal;\n    octal = '';\n  }\n\n  return decimal;\n};\n\n/**\n * Given a number, return its decimal representation in base 10.\n * For example, given 12, the decimal representation is 12.\n */\nconst decimalToBinary = number => {\n  let decimal = '';\n  let binary = '';\n  let power = 0;\n  let powerOfTen = 0;\n\n  while (number > 0) {\n    power = Math.floor(Math.log(number) / Math.LN10);\n    number = number / Math.pow(10, power);\n    binary += String.fromCharCode(powerOfTen);\n    powerOfTen = power;\n  }\n\n  while (binary!== '0') {\n    decimal = decimal + binary;\n    binary = '';\n  }\n\n  return decimal;\n};\n\n/**\n * Given a number, return its octal representation in base 8.\n * For example, given 12, the octal representation is 1101.\n */\nconst octalToBinary = number => {\n  let octal = '';\n  let binary = '';\n  let power = 0;\n  let powerOfTen = 0;\n\n  while (number > 0) {\n    power = Math.floor(Math.log(number) / Math.LN8);\n    number = number / Math.pow(10, power);\n    binary += String.fromCharCode(powerOfTen);\n    powerOfTen = power;\n  }\n\n  while (binary!== '0') {\n    octal = octal + octal;\n    binary = '';\n  }\n\n  return octal;\n};\n\n/**\n * Given a number, return its hex representation in base 16.\n * For example, given 12, the hex representation is 0x12.\n */\nconst hexToBinary = number => {\n  let hex = '';\n  let binary = '';\n  let power = 0;\n  let powerOfTen = 0;\n\n  while (number > 0) {\n    power = Math.floor(Math.log(number) / Math.LN16);\n    number = number / Math.pow(10, power);\n    binary += String.fromCharCode(powerOfTen);\n    powerOfTen = power;\n  }\n\n  while (binary!== '0') {\n    hex = hex + hex;\n    binary = '';\n  }\n\n  return hex;\n};\n\n/**"}
{"task_id": "JavaScript/103", "prompt": "/*YYou get two positive integers n and m, and your task is to calculate the average of integers from n to m (including n and m). Round up the answer to the next integer and convert it to binaries. If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*YYou get two positive integers n and m, and your task is to calculate the average of integers from n to m (including n and m). Round up the answer to the next integer and convert it to binaries. If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  let binary = \"\";\n  let binaries = \"\";\n  let binCount = 0;\n  let binCount2 = 0;\n  let binCount3 = 0;\n  let binCount4 = 0;\n  let binCount5 = 0;\n  let binCount6 = 0;\n  let binCount7 = 0;\n  let binCount8 = 0;\n  let binCount9 = 0;\n  let binCount10 = 0;\n  let binCount11 = 0;\n  let binCount12 = 0;\n  let binCount13 = 0;\n  let binCount14 = 0;\n  let binCount15 = 0;\n  let binCount16 = 0;\n  let binCount17 = 0;\n  let binCount18 = 0;\n  let binCount19 = 0;\n  let binCount20 = 0;\n  let binCount21 = 0;\n  let binCount22 = 0;\n  let binCount23 = 0;\n  let binCount24 = 0;\n  let binCount25 = 0;\n  let binCount26 = 0;\n  let binCount27 = 0;\n  let binCount28 = 0;\n  let binCount29 = 0;\n  let binCount30 = 0;\n  let binCount31 = 0;\n  let binCount32 = 0;\n  let binCount33 = 0;\n  let binCount34 = 0;\n  let binCount35 = 0;\n  let binCount36 = 0;\n  let binCount37 = 0;\n  let binCount38 = 0;\n  let binCount39 = 0;\n  let binCount40 = 0;\n  let binCount41 = 0;\n  let binCount42 = 0;\n  let binCount43 = 0;\n  let binCount44 = 0;\n  let binCount45 = 0;\n  let binCount46 = 0;\n  let binCount47 = 0;\n  let binCount48 = 0;\n  let binCount49 = 0;\n  let binCount50 = 0;\n  let binCount51 = 0;\n  let binCount52 = 0;\n  let binCount53 = 0;\n  let binCount54 = 0;\n  let binCount55 = 0;\n  let binCount56 = 0;\n  let binCount57 = 0;\n  let binCount58 = 0;\n  let binCount59 = 0;\n  let binCount60 = 0;\n  let binCount61 = 0;\n  let binCount62 = 0;\n  let binCount63 = 0;\n  let binCount64 = 0;\n  let binCount65 = 0;\n  let binCount66 = 0;\n  let binCount67 = 0;\n  let binCount68 = 0;\n  let binCount69 = 0;\n  let binCount70 = 0;\n  let binCount71 = 0;\n  let binCount72 = 0;\n  let binCount73 = 0;\n  let binCount74 = 0;\n  let binCount75 = 0;\n  let binCount76 = 0;\n  let binCount77 = 0;\n  let binCount78 = 0;\n  let binCount79 = 0;\n  let binCount80 = 0;\n  let binCount81 = 0;\n  let binCount82 = 0;\n  let binCount83 = 0;\n  let binCount84 = 0;\n  let binCount85 = 0;\n  let binCount86 = 0;\n  let binCount87 = 0;\n  let binCount88 = 0;\n  let binCount89 = 0;\n  let binCount90 = 0;\n  let binCount91 = 0;\n  let binCount92 = 0;\n  let binCount93 = 0;\n  let binCount94 = 0;\n  let binCount95 = 0;\n  let binCount96 = 0;\n  let binCount97 = 0;\n  let binCount98 = 0;\n  let binCount99 = 0;\n  let binCount100 = 0;\n  let binCount101 = 0;\n  let binCount102 = 0;\n  let binCount103 = 0;\n  let binCount104 = 0;\n  let binCount105 = 0;\n  let binCount106 = 0;\n  let binCount107 = 0;\n  let binCount108 = 0;\n  let binCount109 = 0;\n  let binCount110 = 0;\n  let binCount111 = 0;\n  let binCount112 = 0;\n  let binCount113 = 0;\n  let binCount114 = 0;\n  let binCount115 = 0;\n  let binCount116 = 0;\n  let binCount117 = 0;\n  let binCount118 = 0;\n  let binCount119 = 0;\n  let binCount120 = 0;\n  let binCount121 = 0;\n  let binCount122 = 0;\n  let binCount123 = 0;\n  let binCount124 = 0;\n  let binCount125 = 0;\n  let binCount126 = 0;\n  let binCount127 = 0;\n  let binCount128 = 0;\n  let binCount129 = 0;\n  let binCount130 = 0;\n  let binCount131 = 0;\n  let binCount132 = 0;\n  let binCount133 = 0;\n  let binCount134 = 0;\n  let binCount135 = 0;\n  let binCount136 = 0;\n  let binCount137 = 0;\n  let binCount138 = 0;\n  let binCount139 = 0;\n  let binCount140 = 0;\n  let binCount141 = 0;\n  let binCount142 = 0;\n  let binCount143 = 0;\n  let binCount144 = 0;\n  let binCount145 = 0;\n  let binCount146 = 0;\n  let binCount147 = 0;\n  let binCount148 = 0;\n  let binCount149 = 0;\n  let binCount150 = 0;\n  let binCount151 = 0;\n  let binCount152 = 0;\n  let binCount153 = 0;\n  let binCount154 = 0;\n  let binCount155 = 0;\n  let binCount156 = 0;\n  let binCount157 = 0;\n  let binCount158 = 0;\n  let binCount159 = 0;\n  let binCount160 = 0;\n  let binCount161 = 0;\n  let binCount162 = 0;\n  let binCount163 = 0;\n  let binCount164 = 0;\n  let binCount165 = 0;\n  let binCount166 = 0;\n  let binCount167 = 0;\n  let binCount168 = 0;\n  let binCount169 = 0;\n  let binCount170 = 0;\n  let binCount171 = 0;\n  let binCount172 = 0;\n  let binCount173 = 0;\n  let binCount174 = 0;\n  let binCount175 = 0;\n  let binCount176 = 0;\n  let binCount177 = 0;\n  let binCount178 = 0;\n  let binCount179 = 0;\n  let binCount180 = 0;\n  let binCount181 = 0;\n  let binCount182 = 0;\n  let binCount183 = 0;\n  let binCount184 = 0;\n  let binCount185 = 0;\n  let binCount186 = 0;\n  let binCount187 = 0;\n  let binCount188 = 0;\n  let binCount189 = 0;\n  let binCount190 = 0;\n  let binCount191 = 0;\n  let binCount192 = 0;\n  let binCount193 = 0;\n  let binCount194 = 0;\n  let binCount195 = 0;\n  let binCount196 = 0;\n  let binCount197 = 0;\n  let binCount198 = 0;\n  let binCount199 = 0;\n  let binCount200 = 0;\n  let binCount201 = 0;\n  let binCount202 = 0;\n  let binCount203 = 0;\n  let binCount204 = 0;\n  let binCount205 = 0;\n  let binCount206 = 0;\n  let binCount207 = 0;\n  let binCount208 = 0;\n  let binCount209 = 0;\n  let binCount210 = 0;\n  let binCount211 = 0;\n  let binCount212 = 0;\n  let binCount213 = 0;\n  let binCount214 = 0;\n  let binCount215 = 0;\n  let binCount216 = 0;\n  let binCount217 = 0;\n  let binCount218 = 0;\n  let binCount219 = 0;\n  let binCount220 = 0;\n  let binCount221 = 0;\n  let binCount222 = 0;\n  let binCount223 = 0;\n  let binCount224 = 0;\n  let binCount225 = 0;\n  let binCount226 = 0;\n  let binCount227 = 0;\n  let binCount228 = 0;\n  let binCount229 = 0;\n  let binCount230 = 0;\n  let binCount231 = 0;\n  let binCount232 = 0;\n  let binCount233 = 0;\n  let binCount234 = 0;\n  let binCount235 = 0;\n  let binCount236 = 0;"}
{"task_id": "JavaScript/104", "prompt": "/*GWhen creating a list of positive integers x, return a sorted list of all elements that do not have an even digit. Note: The returned list should be sorted in increasing order. Example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*GWhen creating a list of positive integers x, return a sorted list of all elements that do not have an even digit. Note: The returned list should be sorted in increasing order. Example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const digits = x.filter(x => x % 2 === 0);\n  return digits.sort((a, b) => a - b);\n};\n\n/*\n  Given a string, return a list of all unique characters in that string. Note: The returned list should be sorted in increasing order. Example:\n  >>> uniqueChars('abcabc')\n  ['a', 'b', 'c', 'a', 'b', 'c']\n  >>> uniqueChars('abcabcabc')\n  ['a', 'b', 'c', 'a', 'b', 'c']\n  */\nconst uniqueChars = (x) => {\n  const chars = x.split('');\n  return chars.sort((a, b) => a - b);\n};\n\n/*\n  Given a string, return a list of all unique words in that string. Note: The returned list should be sorted in increasing order. Example:\n  >>> uniqueWords('abcabc')\n  ['a', 'b', 'c', 'a', 'b', 'c']\n  >>> uniqueWords('abcabcabc')\n  ['a', 'b', 'c', 'a', 'b', 'c']\n  */\nconst uniqueWords = (x) => {\n  const words = x.split(' ');\n  return words.sort((a, b) => a - b);\n};\n\n/*\n  Given a string, return a list of all unique words in that string that contain only letters. Note: The returned list should be sorted in increasing order. Example:\n  >>> onlyLetters('abcabc')\n  ['a', 'b', 'c']\n  >>> onlyLetters('abcabcabc')\n  ['a', 'b', 'c']\n  */\nconst onlyLetters = (x) => {\n  const words = x.split(' ');\n  return words.filter(x => x.match(/[a-zA-Z]/));\n};\n\n/*\n  Given a string, return a list of all unique words in that string that contain only numbers. Note: The returned list should be sorted in increasing order. Example:\n  >>> onlyNumbers('abcabc')\n  ['a', 'b', 'c']\n  >>> onlyNumbers('abcabcabc')\n  ['a', 'b', 'c']\n  */\nconst onlyNumbers = (x) => {\n  const words = x.split(' ');\n  return words.filter(x => x.match(/[0-9]/));\n};\n\n/*\n  Given a string, return a list of all unique words in that string that contain only letters and numbers. Note: The returned list should be sorted in increasing order. Example:\n  >>> onlyLettersAndNumbers('abcabc')\n  ['a', 'b', 'c']\n  >>> onlyLettersAndNumbers('abcabcabc')\n  ['a', 'b', 'c']\n  */\nconst onlyLettersAndNumbers = (x) => {\n  const words = x.split(' ');\n  return words.filter(x => x.match(/[a-zA-Z0-9]/));\n};\n\n/*\n  Given a string, return a list of all unique words in that string that contain only letters and numbers and that contain only letters. Note: The returned list should be sorted in increasing order. Example:\n  >>> onlyLettersAndNumbersAndLetters('abcabc')\n  ['a', 'b', 'c']\n  >>> onlyLettersAndNumbersAndLetters('abcabcabc')\n  ['a', 'b', 'c']\n  */\nconst onlyLettersAndNumbersAndLetters = (x) => {\n  const words = x.split(' ');\n  return words.filter(x => x.match(/[a-zA-Z0-9]/) && x.match(/[a-zA-Z]/));\n};\n\n/*\n  Given a string, return a list of all unique words in that string that contain only letters and numbers and that contain only letters and numbers. Note: The returned list should be sorted in increasing order. Example:\n  >>> onlyLettersAndNumbersAndLettersAndLetters('abcabc')\n  ['a', 'b', 'c']\n  >>> onlyLettersAndNumbersAndLettersAndLetters('abcabcabc')\n  ['a', 'b', 'c']\n  */\nconst onlyLettersAndNumbersAndLettersAndLetters = (x) => {\n  const words = x.split(' ');\n  return words.filter(x => x.match(/[a-zA-Z0-9]/) && x.match(/[a-zA-Z0-9]/) && x.match(/[a-zA-Z]/));\n};\n\n/*\n  Given a string, return a list of all unique words in that string that contain only letters and numbers and that contain only letters and numbers. Note: The returned list should be sorted in increasing order. Example:\n  >>> onlyLettersAndNumbersAndLettersAndLettersAndLetters('abcabc')\n  ['a', 'b', 'c']\n  >>> onlyLettersAndNumbersAndLettersAndLettersAndLetters('abcabcabc')\n  ['a', 'b', 'c']\n  */\nconst onlyLettersAndNumbersAndLettersAndLettersAndLetters = (x) => {\n  const words = x.split(' ');\n  return words.filter(x => x.match(/[a-zA-Z0-9]/) && x.match(/[a-zA-Z0-9]/) && x.match(/[a-zA-Z0-9]/) && x.match(/[a-zA-Z]/));\n};\n\n/*\n  Given a string, return a list of all unique words in that string that contain only letters and numbers and that contain only letters and numbers. Note: The returned list should be sorted in increasing order. Example:\n  >>> onlyLettersAndNumbersAndLettersAndLettersAndLettersAndLetters('abcabc')\n  ['a', 'b', 'c']\n  >>> onlyLettersAndNumbersAndLettersAndLettersAndLettersAndLetters('abcabcabc')\n  ['a', 'b', 'c']\n  */\nconst onlyLettersAndNumbersAndLettersAndLettersAndLettersAndLetters = (x) => {\n  const words = x.split(' ');\n  return words.filter(x => x.match(/[a-zA-Z0-9]/) && x.match(/[a-zA-Z0-9]/) && x.match(/[a-zA-Z0-9]/) && x.match(/[a-zA-Z0-9]/) && x.match(/[a-zA-Z]/));\n};\n\n/*\n  Given a string, return a list of all unique words in that string that contain only letters and numbers and that contain only letters and numbers. Note: The returned list should be sorted in increasing order. Example:\n  >>> onlyLettersAndNumbersAndLettersAndLettersAndLettersAndLettersAndLetters('abcabc')\n  ['a', 'b', 'c']\n  >>> onlyLettersAndNumbersAndLettersAndLettersAndLettersAndLettersAndLetters('abcabcabc')\n  ['a', 'b', 'c']\n  */\nconst onlyLettersAndNumbersAndLettersAndLettersAndLettersAndLettersAndLetters = (x) => {\n  const words = x.split(' ');\n  return words.filter(x => x.match(/[a-zA-Z0-9]/) && x.match(/[a-zA-Z0-9]/) && x.match(/[a-zA-Z0-9]/) && x.match(/[a-zA-Z0-9]/) && x.match(/[a-zA-Z0-9]/) && x.match(/[a-zA-Z]/));\n};\n\n/*\n  Given a string, return a list of all unique words in that string that contain only letters and numbers and that contain only letters and numbers. Note: The returned list should be sorted in increasing order. Example:\n  >>> onlyLettersAndNumbersAndLettersAndLettersAndLettersAndLettersAndLettersAndLetters('abcabc')\n  ['a', 'b', 'c']\n  >>> onlyLettersAndNumbersAndLettersAndLettersAndLettersAndLettersAndLettersAndLetters('abcabcabc')\n  ['a', 'b', 'c']\n  */\nconst onlyLettersAndNumbersAndLettersAndLettersAndLettersAndLettersAndLettersAndLetters = (x) => {\n  const words = x.split(' ');\n  return words.filter(x => x.match(/[a-zA-Z0-9]/) && x.match(/[a-zA-Z0-9]/) && x.match(/[a-zA-Z0-9]/) && x.match(/[a-zA-Z0-9]/) && x.match(/[a-zA-Z0-9]/) && x.match(/[a-zA-Z0-9]/) && x.match(/[a-zA-Z]/));\n};\n\n/*\n  Given a string, return a list of all unique words in that string that contain only letters and numbers and that contain only letters and numbers. Note: The returned list should be sorted in increasing order. Example:\n  >>> onlyLettersAndNumbersAndLettersAndLettersAndLettersAndLettersAndLettersAndLettersAndLetters('abcabc')\n  ['a', 'b', 'c']\n  >>> onlyLettersAndNumbersAndLettersAndLettersAndLettersAndLettersAndLettersAndLettersAndLettersAndLetters('abcab"}
{"task_id": "JavaScript/105", "prompt": "/*\n  For an array of integers, you sort the integers that lie between 1 and 9, reverse the resulting array, and then replace each digit with its corresponding name of \"one,\" \"two,\" \"three,\" \"four,\" \"five,\" \"six,\" \"seven,\" \"eight,\" \"nine.\"\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  For an array of integers, you sort the integers that lie between 1 and 9, reverse the resulting array, and then replace each digit with its corresponding name of \"one,\" \"two,\" \"three,\" \"four,\" \"five,\" \"six,\" \"seven,\" \"eight,\" \"nine.\"\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.slice().reverse();\n  return reversedArr.map((digit, index) => {\n    return digit.charAt(0).toUpperCase() + digit.slice(1).toLowerCase();\n  });\n};\n\n/*\n  Given a string, return an array of the characters in that string that occur at least twice in the string.\n  \n  For example:\n    str = \"abcabc\"\n    -> return [\"a\", \"b\", \"c\"]\n    \n    If the string has any strange number ignore it:\n    str = \"abcabc\"\n    -> return [\"a\", \"b\", \"c\"]\n  */\nconst byCharacters = (str) => {\n  let chars = str.split('');\n  let charsLength = chars.length;\n  let charsArray = chars.map((char) => char.charCodeAt(0));\n  let charsArrayLength = charsArray.length;\n  let charsArrayWithDuplicates = charsArray.filter((value, index) => charsArray[index] === value);\n  let charsArrayWithDuplicatesLength = charsArrayWithDuplicates.length;\n  let charsArrayWithDuplicatesArray = charsArrayWithDuplicates.map((value, index) => charsArray[index]);\n  let charsArrayWithDuplicatesArrayLength = charsArrayWithDuplicatesArray.length;\n  let charsArrayWithDuplicatesArrayWithDuplicates = charsArrayWithDuplicatesArray.filter((value, index) => charsArrayWithDuplicatesArray[index] === value);\n  let charsArrayWithDuplicatesArrayWithDuplicatesLength = charsArrayWithDuplicatesArrayWithDuplicates.length;\n  let charsArrayWithDuplicatesArrayWithDuplicatesArray = charsArrayWithDuplicatesArrayWithDuplicates.map((value, index) => charsArrayWithDuplicatesArray[index]);\n  let charsArrayWithDuplicatesArrayWithDuplicatesArrayLength = charsArrayWithDuplicatesArrayWithDuplicatesArray.length;\n  let charsArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicates = charsArrayWithDuplicatesArrayWithDuplicatesArray.filter((value, index) => charsArrayWithDuplicatesArrayWithDuplicatesArray[index] === value);\n  let charsArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesLength = charsArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicates.length;\n  let charsArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArray = charsArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicates.map((value, index) => charsArrayWithDuplicatesArrayWithDuplicatesArray[index]);\n  let charsArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayLength = charsArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArray.length;\n  let charsArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicates = charsArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArray.filter((value, index) => charsArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArray[index] === value);\n  let charsArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesLength = charsArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicates.length;\n  let charsArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArray = charsArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArray.map((value, index) => charsArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArray[index]);\n  let charsArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayLength = charsArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArray.length;\n  let charsArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicates = charsArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArray.filter((value, index) => charsArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArray[index] === value);\n  let charsArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayLength = charsArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArray.length;\n  let charsArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicates = charsArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArray.length;\n  let charsArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicatesArrayWithDuplicates"}
{"task_id": "JavaScript/106", "prompt": "/* Implement function f, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the factorial of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Implement function f, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the factorial of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let result = [];\n  let i = 1;\n  while (i <= n) {\n    result.push(i);\n    i++;\n  }\n  return result;\n};\n\n/* Implement function g, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  g(5) == [1, 2, 6, 24, 15]\n  */\nconst g = (n) => {\n  let result = [];\n  let i = 1;\n  while (i <= n) {\n    result.push(i);\n    i++;\n  }\n  return result;\n};\n\n/* Implement function h, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  h(5) == [1, 2, 6, 24, 15]\n  */\nconst h = (n) => {\n  let result = [];\n  let i = 1;\n  while (i <= n) {\n    result.push(i);\n    i++;\n  }\n  return result;\n};\n\n/* Implement function i, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  i(5) == [1, 2, 6, 24, 15]\n  */\nconst i = (n) => {\n  let result = [];\n  let i = 1;\n  while (i <= n) {\n    result.push(i);\n    i++;\n  }\n  return result;\n};\n\n/* Implement function j, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  j(5) == [1, 2, 6, 24, 15]\n  */\nconst j = (n) => {\n  let result = [];\n  let i = 1;\n  while (i <= n) {\n    result.push(i);\n    i++;\n  }\n  return result;\n};\n\n/* Implement function k, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  k(5) == [1, 2, 6, 24, 15]\n  */\nconst k = (n) => {\n  let result = [];\n  let i = 1;\n  while (i <= n) {\n    result.push(i);\n    i++;\n  }\n  return result;\n};\n\n/* Implement function l, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  l(5) == [1, 2, 6, 24, 15]\n  */\nconst l = (n) => {\n  let result = [];\n  let i = 1;\n  while (i <= n) {\n    result.push(i);\n    i++;\n  }\n  return result;\n};\n\n/* Implement function m, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  m(5) == [1, 2, 6, 24, 15]\n  */\nconst m = (n) => {\n  let result = [];\n  let i = 1;\n  while (i <= n) {\n    result.push(i);\n    i++;\n  }\n  return result;\n};\n\n/* Implement function n, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  n(5) == [1, 2, 6, 24, 15]\n  */\nconst n = (n) => {\n  let result = [];\n  let i = 1;\n  while (i <= n) {\n    result.push(i);\n    i++;\n  }\n  return result;\n};\n\n/* Implement function o, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  o(5) == [1, 2, 6, 24, 15]\n  */\nconst o = (n) => {\n  let result = [];\n  let i = 1;\n  while (i <= n) {\n    result.push(i);\n    i++;\n  }\n  return result;\n};\n\n/* Implement function p, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  p(i) == [1, 2, 6, 24, 15]\n  */\nconst p = (n) => {\n  let result = [];\n  let i = 1;\n  while (i <= n) {\n    result.push(i);\n    i++;\n  }\n  return result;\n};\n\n/* Implement function q, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  q(i) == [1, 2, 6, 24, 15]\n  */\nconst q = (n) => {\n  let result = [];\n  let i = 1;\n  while (i <= n) {\n    result.push(i);\n    i++;\n  }\n  return result;\n};\n\n/* Implement function r, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  r(i) == [1, 2, 6, 24, 15]\n  */\nconst r = (n) => {\n  let result = [];\n  let i = 1;\n  while (i <= n) {\n    result.push(i);\n    i++;\n  }\n  return result;\n};\n\n/* Implement function s, which takes n as parameter"}
{"task_id": "JavaScript/107", "prompt": "/*\n  If you return a positive integer n, you return a tuple with the number of even and odd integer palindromes within the range (1, n), including.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  If you return a positive integer n, you return a tuple with the number of even and odd integer palindromes within the range (1, n), including.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenPalindromes = Array.from({ length: n }, (_, i) => i);\n  const oddPalindromes = Array.from({ length: n }, (_, i) => i);\n  const evenPalindromePairs = evenPalindromes.map((_, i) => [evenPalindromes[i], i]);\n  const oddPalindromePairs = oddPalindromes.map((_, i) => [oddPalindromes[i], i]);\n  const oddEvenPalindromePairs = oddPalindromePairs.filter(([_, i]) => i % 2 === 1);\n  const evenEvenPalindromePairs = evenPalindromePairs.filter(([_, i]) => i % 2 === 0);\n  return [...oddEvenPalindromePairs,...evenEvenPalindromePairs];\n};\n\n/*\n  Given a string, return whether it is a palindrome or not.\n\n  Example 1:\n\n      Input: \"racecar\"\n      Output: true\n      Explanation: \"racecar\" is a palindrome.\n\n  Example 2:\n\n      Input: \"racecar\"\n      Output: false\n      Explanation: \"racecar\" is not a palindrome.\n*/\nconst isPalindrome = (str) => {\n  return str === str.replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi), '')\n   .replace(new RegExp(/[aeiou]/gi"}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a function countNums that takes an array of integers and returns the number of elements that have a sum of digits > 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function countNums that takes an array of integers and returns the number of elements that have a sum of digits > 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let result = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      result += 1;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function countZeros that takes an array of integers and returns the number of elements that have a sum of digits == 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countZeros([]) == 0\n  >>> countZeros([-1, 11, -11]) == 1\n  >>> countZeros([1, 1, 2]) == 2\n  */\nconst countZeros = (arr) => {\n  let result = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      result += 1;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function countEvens that takes an array of integers and returns the number of elements that have a sum of digits == 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countEvens([]) == 0\n  >>> countEvens([-1, 11, -11]) == 1\n  >>> countEvens([1, 1, 2]) == 2\n  */\nconst countEvens = (arr) => {\n  let result = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 === 0) {\n      result += 1;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function countOdds that takes an array of integers and returns the number of elements that have a sum of digits == 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countOdds([]) == 0\n  >>> countOdds([-1, 11, -11]) == 1\n  >>> countOdds([1, 1, 2]) == 2\n  */\nconst countOdds = (arr) => {\n  let result = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2!== 0) {\n      result += 1;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function countMultiples that takes an array of integers and returns the number of elements that have a sum of digits == 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countMultiples([]) == 0\n  >>> countMultiples([-1, 11, -11]) == 1\n  >>> countMultiples([1, 1, 2]) == 2\n  */\nconst countMultiples = (arr) => {\n  let result = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2!== 0) {\n      result += 1;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function countDivisors that takes an array of integers and returns the number of elements that have a sum of digits == 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countDivisors([]) == 0\n  >>> countDivisors([-1, 11, -11]) == 1\n  >>> countDivisors([1, 1, 2]) == 2\n  */\nconst countDivisors = (arr) => {\n  let result = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2!== 0) {\n      result += 1;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function countMultipleDivisors that takes an array of integers and returns the number of elements that have a sum of digits == 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countMultipleDivisors([]) == 0\n  >>> countMultipleDivisors([-1, 11, -11]) == 1\n  >>> countMultipleDivisors([1, 1, 2]) == 2\n  */\nconst countMultipleDivisors = (arr) => {\n  let result = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2!== 0) {\n      result += 1;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function countMultipleOdds that takes an array of integers and returns the number of elements that have a sum of digits == 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countMultipleOdds([]) == 0\n  >>> countMultipleOdds([-1, 11, -11]) == 1\n  >>> countMultipleOdds([1, 1, 2]) == 2\n  */\nconst countMultipleOdds = (arr) => {\n  let result = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2!== 0) {\n      result += 1;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function countMultipleEvens that takes an array of integers and returns the number of elements that have a sum of digits == 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countMultipleEvens([]) == 0\n  >>> countMultipleEvens([-1, 11, -11]) == 1\n  >>> countMultipleEvens([1, 1, 2]) == 2\n  */\nconst countMultipleEvens = (arr) => {\n  let result = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2!== 0) {\n      result += 1;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function countMultipleOddsAndEvens that takes an array of integers and returns the number of elements that have a sum of digits == 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countMultipleOddsAndEvens([]) == 0\n  >>> countMultipleOddsAndEvens([-1, 11, -11]) == 1\n  >>> countMultipleOddsAndEvens([1, 1, 2]) == 2\n  */\nconst countMultipleOddsAndEvens = (arr) => {\n  let result = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2!== 0) {\n      result += 1;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function countMultipleOddsAndOdds that takes an array of integers and returns the number of elements that have a sum of digits == 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countMultipleOddsAndOdds([]) == 0\n  >>> countMultipleOddsAndOdds([-1, 11, -11]) == 1\n  >>> countMultipleOddsAndOdds([1, 1, 2]) == 2\n  */\nconst countMultipleOddsAndOdds = (arr) => {\n  let result = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2!== 0) {\n      result += 1;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function countMultipleOddsAndEvensAndOdds that takes an array of integers and returns the number of elements that have a sum of digits == 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countMultipleOddsAndEvensAndOdds([]) == 0\n  >>> countMultipleOddsAndEvensAndOdds([-1, 11, -11]) == 1\n  >>> countMultipleOddsAndEvensAndOdds([1, 1, 2]) == 2\n  */\nconst countMultipleOddsAndEvensAndOdds = (arr) => {\n  let result = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2!== 0) {\n      result += 1;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function countMultipleOddsAndOddsAndEvensAndOdds that takes an array of integers and returns the number of elements that have a sum of digits == 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countMultipleOddsAndOddsAndEvensAndOdds([]) == 0\n  >>> countMultipleOddsAndOddsAndEvensAndOdds([-1, 11, -11]"}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*We have an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  let arrLength = arr.length;\n  let arrCopy = arr.slice();\n  let arrCopyLength = arrCopy.length;\n  let arrCopyIndex = 0;\n  let arrCopyIndex2 = 0;\n  let arrCopyIndex3 = 0;\n  let arrCopyIndex4 = 0;\n  let arrCopyIndex5 = 0;\n  let arrCopyIndex6 = 0;\n  let arrCopyIndex7 = 0;\n  let arrCopyIndex8 = 0;\n  let arrCopyIndex9 = 0;\n  let arrCopyIndex10 = 0;\n  let arrCopyIndex11 = 0;\n  let arrCopyIndex12 = 0;\n  let arrCopyIndex13 = 0;\n  let arrCopyIndex14 = 0;\n  let arrCopyIndex15 = 0;\n  let arrCopyIndex16 = 0;\n  let arrCopyIndex17 = 0;\n  let arrCopyIndex18 = 0;\n  let arrCopyIndex19 = 0;\n  let arrCopyIndex20 = 0;\n  let arrCopyIndex21 = 0;\n  let arrCopyIndex22 = 0;\n  let arrCopyIndex23 = 0;\n  let arrCopyIndex24 = 0;\n  let arrCopyIndex25 = 0;\n  let arrCopyIndex26 = 0;\n  let arrCopyIndex27 = 0;\n  let arrCopyIndex28 = 0;\n  let arrCopyIndex29 = 0;\n  let arrCopyIndex30 = 0;\n  let arrCopyIndex31 = 0;\n  let arrCopyIndex32 = 0;\n  let arrCopyIndex33 = 0;\n  let arrCopyIndex34 = 0;\n  let arrCopyIndex35 = 0;\n  let arrCopyIndex36 = 0;\n  let arrCopyIndex37 = 0;\n  let arrCopyIndex38 = 0;\n  let arrCopyIndex39 = 0;\n  let arrCopyIndex40 = 0;\n  let arrCopyIndex41 = 0;\n  let arrCopyIndex42 = 0;\n  let arrCopyIndex43 = 0;\n  let arrCopyIndex44 = 0;\n  let arrCopyIndex45 = 0;\n  let arrCopyIndex46 = 0;\n  let arrCopyIndex47 = 0;\n  let arrCopyIndex48 = 0;\n  let arrCopyIndex49 = 0;\n  let arrCopyIndex50 = 0;\n  let arrCopyIndex51 = 0;\n  let arrCopyIndex52 = 0;\n  let arrCopyIndex53 = 0;\n  let arrCopyIndex54 = 0;\n  let arrCopyIndex55 = 0;\n  let arrCopyIndex56 = 0;\n  let arrCopyIndex57 = 0;\n  let arrCopyIndex58 = 0;\n  let arrCopyIndex59 = 0;\n  let arrCopyIndex60 = 0;\n  let arrCopyIndex61 = 0;\n  let arrCopyIndex62 = 0;\n  let arrCopyIndex63 = 0;\n  let arrCopyIndex64 = 0;\n  let arrCopyIndex65 = 0;\n  let arrCopyIndex66 = 0;\n  let arrCopyIndex67 = 0;\n  let arrCopyIndex68 = 0;\n  let arrCopyIndex69 = 0;\n  let arrCopyIndex70 = 0;\n  let arrCopyIndex71 = 0;\n  let arrCopyIndex72 = 0;\n  let arrCopyIndex73 = 0;\n  let arrCopyIndex74 = 0;\n  let arrCopyIndex75 = 0;\n  let arrCopyIndex76 = 0;\n  let arrCopyIndex77 = 0;\n  let arrCopyIndex78 = 0;\n  let arrCopyIndex79 = 0;\n  let arrCopyIndex80 = 0;\n  let arrCopyIndex81 = 0;\n  let arrCopyIndex82 = 0;\n  let arrCopyIndex83 = 0;\n  let arrCopyIndex84 = 0;\n  let arrCopyIndex85 = 0;\n  let arrCopyIndex86 = 0;\n  let arrCopyIndex87 = 0;\n  let arrCopyIndex88 = 0;\n  let arrCopyIndex89 = 0;\n  let arrCopyIndex90 = 0;\n  let arrCopyIndex91 = 0;\n  let arrCopyIndex92 = 0;\n  let arrCopyIndex93 = 0;\n  let arrCopyIndex94 = 0;\n  let arrCopyIndex95 = 0;\n  let arrCopyIndex96 = 0;\n  let arrCopyIndex97 = 0;\n  let arrCopyIndex98 = 0;\n  let arrCopyIndex99 = 0;\n  let arrCopyIndex100 = 0;\n  let arrCopyIndex101 = 0;\n  let arrCopyIndex102 = 0;\n  let arrCopyIndex103 = 0;\n  let arrCopyIndex104 = 0;\n  let arrCopyIndex105 = 0;\n  let arrCopyIndex106 = 0;\n  let arrCopyIndex107 = 0;\n  let arrCopyIndex108 = 0;\n  let arrCopyIndex109 = 0;\n  let arrCopyIndex110 = 0;\n  let arrCopyIndex111 = 0;\n  let arrCopyIndex112 = 0;\n  let arrCopyIndex113 = 0;\n  let arrCopyIndex114 = 0;\n  let arrCopyIndex115 = 0;\n  let arrCopyIndex116 = 0;\n  let arrCopyIndex117 = 0;\n  let arrCopyIndex118 = 0;\n  let arrCopyIndex119 = 0;\n  let arrCopyIndex120 = 0;\n  let arrCopyIndex121 = 0;\n  let arrCopyIndex122 = 0;\n  let arrCopyIndex123 = 0;\n  let arrCopyIndex124 = 0;\n  let arrCopyIndex125 = 0;\n  let arrCopyIndex126 = 0;\n  let arrCopyIndex127 = 0;\n  let arrCopyIndex128 = 0;\n  let arrCopyIndex129 = 0;\n  let arrCopyIndex130 = 0;\n  let arrCopyIndex131 = 0;\n  let arrCopyIndex132 = 0;\n  let arrCopyIndex133 = 0;\n  let arrCopyIndex134 = 0;\n  let arrCopyIndex135 = 0;\n  let arrCopyIndex136 = 0;\n  let arrCopyIndex137 = 0;\n  let arrCopyIndex138 = 0;\n  let arrCopyIndex139 = 0;\n  let arrCopyIndex140 = 0;\n  let arrCopyIndex141 = 0;\n  let arrCopyIndex142 = 0;\n  let arrCopyIndex143 = 0;\n  let arrCopyIndex144 = 0;\n  let arrCopyIndex145 = 0;\n  let arrCopyIndex146 = 0;\n  let arrCopyIndex147 = 0;\n  let arrCopyIndex148 = 0;\n  let arrCopyIndex149 = 0;\n  let arrCopyIndex150 = 0;\n  let arrCopyIndex151 = 0;\n  let arrCopyIndex152 = 0;\n  let arrCopyIndex153 = 0;\n  let arrCopyIndex154 = 0;\n  let arrCopyIndex155 = 0;\n  let arrCopyIndex156 = 0;\n  let arrCopyIndex157 = 0;\n  let arrCopyIndex158 = 0;\n  let arrCopyIndex159 = 0;\n  let arrCopyIndex160 = 0;\n  let arrCopyIndex161 = 0;\n  let arrCopyIndex162 = 0;\n  let arrCopyIndex163 = 0;\n  let arrCopyIndex164 = 0;\n  let arrCopyIndex165 = 0;\n  let arrCopyIndex166 = 0;\n  let arrCopyIndex167 = 0;\n  let arrCopyIndex168 = 0;\n  let arrCopyIndex169 = 0;\n  let arrCopyIndex170 = 0;\n  let arrCopyIndex171 = 0;\n  let arrCopyIndex172 = 0;\n  let arrCopyIndex173 = 0;\n  let arrCopyIndex174 = 0;\n  let arrCopyIndex175 = 0;\n  let arrCopyIndex176 = 0;\n  let arrCopyIndex177 = 0;\n  let arrCopyIndex178 = 0;\n  let arrCopyIndex179 = 0;\n  let arrCopyIndex180 = 0;\n  let arrCopyIndex181 = 0;\n  let arrCopy"}
{"task_id": "JavaScript/110", "prompt": "/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an exchange of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of exchanged elements between lst1 and lst2.\n  If it is possible to exchange elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an exchange of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of exchanged elements between lst1 and lst2.\n  If it is possible to exchange elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let result = \"NO\";\n  let num1 = lst1.length;\n  let num2 = lst2.length;\n  let num3 = num1 - num2;\n  let num4 = num2 - num1;\n  let num5 = num3 - num4;\n  let num6 = num4 - num3;\n  let num7 = num5 - num6;\n  let num8 = num6 - num5;\n  let num9 = num7 - num8;\n  let num10 = num8 - num7;\n  let num11 = num9 - num10;\n  let num12 = num10 - num9;\n  let num13 = num11 - num12;\n  let num14 = num12 - num11;\n  let num15 = num13 - num14;\n  let num16 = num14 - num15;\n  let num17 = num15 - num16;\n  let num18 = num16 - num17;\n  let num19 = num17 - num18;\n  let num20 = num18 - num19;\n  let num21 = num19 - num20;\n  let num22 = num20 - num21;\n  let num23 = num21 - num22;\n  let num24 = num22 - num23;\n  let num25 = num23 - num24;\n  let num26 = num24 - num25;\n  let num27 = num25 - num26;\n  let num28 = num26 - num27;\n  let num29 = num27 - num28;\n  let num30 = num28 - num29;\n  let num31 = num29 - num30;\n  let num32 = num30 - num31;\n  let num33 = num31 - num32;\n  let num34 = num32 - num33;\n  let num35 = num33 - num34;\n  let num36 = num34 - num35;\n  let num37 = num35 - num36;\n  let num38 = num36 - num37;\n  let num39 = num37 - num38;\n  let num40 = num38 - num39;\n  let num41 = num39 - num40;\n  let num42 = num40 - num41;\n  let num43 = num41 - num42;\n  let num44 = num42 - num43;\n  let num45 = num43 - num44;\n  let num46 = num44 - num45;\n  let num47 = num45 - num46;\n  let num48 = num46 - num47;\n  let num49 = num47 - num48;\n  let num50 = num48 - num49;\n  let num51 = num49 - num50;\n  let num52 = num50 - num51;\n  let num53 = num51 - num52;\n  let num54 = num52 - num53;\n  let num55 = num53 - num54;\n  let num56 = num54 - num55;\n  let num57 = num55 - num56;\n  let num58 = num56 - num57;\n  let num59 = num57 - num58;\n  let num60 = num58 - num59;\n  let num61 = num59 - num60;\n  let num62 = num60 - num61;\n  let num63 = num61 - num62;\n  let num64 = num62 - num63;\n  let num65 = num63 - num64;\n  let num66 = num64 - num65;\n  let num67 = num65 - num66;\n  let num68 = num66 - num67;\n  let num69 = num67 - num68;\n  let num70 = num68 - num69;\n  let num71 = num69 - num70;\n  let num72 = num70 - num71;\n  let num73 = num71 - num72;\n  let num74 = num72 - num73;\n  let num75 = num73 - num74;\n  let num76 = num74 - num75;\n  let num77 = num75 - num76;\n  let num78 = num76 - num77;\n  let num79 = num77 - num78;\n  let num80 = num78 - num79;\n  let num81 = num79 - num80;\n  let num82 = num80 - num81;\n  let num83 = num81 - num82;\n  let num84 = num82 - num83;\n  let num85 = num83 - num84;\n  let num86 = num84 - num85;\n  let num87 = num85 - num86;\n  let num88 = num86 - num87;\n  let num89 = num87 - num88;\n  let num90 = num88 - num89;\n  let num91 = num89 - num90;\n  let num92 = num90 - num91;\n  let num93 = num91 - num92;\n  let num94 = num92 - num93;\n  let num95 = num93 - num94;\n  let num96 = num94 - num95;\n  let num97 = num95 - num96;\n  let num98 = num96 - num97;\n  let num99 = num97 - num98;\n  let num100 = num98 - num99;\n  let num101 = num99 - num100;\n  let num102 = num100 - num101;\n  let num103 = num101 - num102;\n  let num104 = num102 - num103;\n  let num105 = num103 - num104;\n  let num106 = num104 - num105;\n  let num107 = num105 - num106;\n  let num108 = num106 - num107;\n  let num109 = num107 - num108;\n  let num110 = num108 - num109;\n  let num111 = num109 - num110;\n  let num112 = num110 - num111;\n  let num113 = num111 - num112;\n  let num114 = num112 - num113;\n  let num115 = num113 - num114;\n  let num116 = num114 - num115;\n  let num117 = num115 - num116;\n  let num118 = num116 - num117;\n  let num119 = num117 - num118;\n  let num120 = num118 - num119;\n  let num121 = num119 - num120;\n  let num122 = num120 - num121;\n  let num123 = num121 - num122;\n  let num124 = num122 - num123;\n  let num125 = num123 - num124;\n  let num126 = num124 - num125;\n  let num127 = num125 - num126;\n  let num128 = num126 - num127;\n  let num129 = num127 - num128;\n  let num130 = num128 - num129;\n  let num131 = num129 - "}
{"task_id": "JavaScript/111", "prompt": "/*GIf a string is a lowercase letter separated by spaces, return a dictionary of the letter with the largest repetition and the corresponding number. If several letters have the same occurrence, return all.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*GIf a string is a lowercase letter separated by spaces, return a dictionary of the letter with the largest repetition and the corresponding number. If several letters have the same occurrence, return all.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let histogram = {};\n  letters.forEach((letter) => {\n    histogram[letter] = histogram[letter] || 0;\n    histogram[letter]++;\n  });\n  return histogram;\n};\n\n/*\n  Given a string, return an array of the letters sorted in alphabetical order.\n  \n  Example:\n  letters('a b c d e f g h i j k l m n o p q r s t u v w x y z') == ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n  letters('a b c d e f g h i j k l m n o p q r s t u v w x y z') == ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n  letters('') == []\n*/\nconst letters = (test) => {\n  let letters = test.split('');\n  let letterArray = [];\n  letters.forEach((letter) => {\n    letterArray.push(letter);\n  });\n  return letterArray;\n};\n\n/*\n  Given a string, return an array of the words sorted in alphabetical order.\n  \n  Example:\n  words('a b c d e f g h i j k l m n o p q r s t u v w x y z') == ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n  words('a b c d e f g h i j k l m n o p q r s t u v w x y z') == ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n  words('') == []\n*/\nconst words = (test) => {\n  let words = test.split(' ');\n  let wordArray = [];\n  words.forEach((word) => {\n    wordArray.push(word);\n  });\n  return wordArray;\n};\n\n/*\n  Given a string, return an array of the sentences sorted in alphabetical order.\n  \n  Example:\n  sentences('a b c d e f g h i j k l m n o p q r s t u v w x y z') == ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n  sentences('a b c d e f g h i j k l m n o p q r s t u v w x y z') == ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n  sentences('') == []\n*/\nconst sentences = (test) => {\n  let sentences = test.split(' ');\n  let sentenceArray = [];\n  sentences.forEach((sentence) => {\n    sentenceArray.push(sentence);\n  });\n  return sentenceArray;\n};\n\n/*\n  Given a string, return an array of the paragraphs sorted in alphabetical order.\n  \n  Example:\n  paragraphs('a b c d e f g h i j k l m n o p q r s t u v w x y z') == ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n  paragraphs('a b c d e f g h i j k l m n o p q r s t u v w x y z') == ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n  paragraphs('') == []\n*/\nconst paragraphs = (test) => {\n  let paragraphs = test.split(' ');\n  let paragraphArray = [];\n  paragraphs.forEach((paragraph) => {\n    paragraphArray.push(paragraph);\n  });\n  return paragraphArray;\n};\n\n/*\n  Given a string, return an array of the sentences sorted in alphabetical order.\n  \n  Example:\n  sentences('a b c d e f g h i j k l m n o p q r s t u v w x y z') == ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n  sentences('a b c d e f g h i j k l m n o p q r s t u v w x y z') == ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n  sentences('') == []\n*/\nconst sentences = (test) => {\n  let sentences = test.split(' ');\n  let sentenceArray = [];\n  sentences.forEach((sentence) => {\n    sentenceArray.push(sentence);\n  });\n  return sentenceArray;\n};\n\n/*\n  Given a string, return an array of the paragraphs sorted in alphabetical order.\n  \n  Example:\n  paragraphs('a b c d e f g h i j k l m n o p q r s t u v w x y z') == ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n  paragraphs('a b c d e f g h i j k l m n o p q r s t u v w x y z') == ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n  paragraphs('') == []\n*/\nconst paragraphs = (test) => {\n  let paragraphs = test.split(' ');\n  let paragraphArray = [];\n  paragraphs.forEach((paragraph) => {\n    paragraphArray.push(paragraph);\n  });\n  return paragraphArray;\n};\n\n/*\n  Given a string, return an array of the sentences sorted in alphabetical order.\n  \n  Example:\n  sentences('a b c d e f g h i j k l m n o p q r s t u v w x y z') == ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n  sentences('a b c d e f g h i j k l m n o p q r s t u v w x y z') == ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n  sentences('') == []\n*/\nconst sentences = (test) => {"}
{"task_id": "JavaScript/112", "prompt": "/*Task We get two strings s and c, you have to delete all characters in s that correspond to any character in c, then check if the result string is palindrome. A string is called palindrome if it reads the same backward as forward. You should return a tuple that contains the result string and true / false for verification.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Task We get two strings s and c, you have to delete all characters in s that correspond to any character in c, then check if the result string is palindrome. A string is called palindrome if it reads the same backward as forward. You should return a tuple that contains the result string and true / false for verification.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let reversed = '';\n  let reversedChar = '';\n  let reversedChars = [];\n  let reversedCharsLength = 0;\n  let reversedCharsIndex = 0;\n  let reversedCharsLengthIndex = 0;\n  let reversedCharsIndex2 = 0;\n  let reversedCharsLengthIndex2 = 0;\n  let reversedCharsIndex3 = 0;\n  let reversedCharsLengthIndex3 = 0;\n  let reversedCharsIndex4 = 0;\n  let reversedCharsLengthIndex4 = 0;\n  let reversedCharsIndex5 = 0;\n  let reversedCharsLengthIndex5 = 0;\n  let reversedCharsIndex6 = 0;\n  let reversedCharsLengthIndex6 = 0;\n  let reversedCharsIndex7 = 0;\n  let reversedCharsLengthIndex7 = 0;\n  let reversedCharsIndex8 = 0;\n  let reversedCharsLengthIndex8 = 0;\n  let reversedCharsIndex9 = 0;\n  let reversedCharsLengthIndex9 = 0;\n  let reversedCharsIndex10 = 0;\n  let reversedCharsLengthIndex10 = 0;\n  let reversedCharsIndex11 = 0;\n  let reversedCharsLengthIndex11 = 0;\n  let reversedCharsIndex12 = 0;\n  let reversedCharsLengthIndex12 = 0;\n  let reversedCharsIndex13 = 0;\n  let reversedCharsLengthIndex13 = 0;\n  let reversedCharsIndex14 = 0;\n  let reversedCharsLengthIndex14 = 0;\n  let reversedCharsIndex15 = 0;\n  let reversedCharsLengthIndex15 = 0;\n  let reversedCharsIndex16 = 0;\n  let reversedCharsLengthIndex16 = 0;\n  let reversedCharsIndex17 = 0;\n  let reversedCharsLengthIndex17 = 0;\n  let reversedCharsIndex18 = 0;\n  let reversedCharsLengthIndex18 = 0;\n  let reversedCharsIndex19 = 0;\n  let reversedCharsLengthIndex19 = 0;\n  let reversedCharsIndex20 = 0;\n  let reversedCharsLengthIndex20 = 0;\n  let reversedCharsIndex21 = 0;\n  let reversedCharsLengthIndex21 = 0;\n  let reversedCharsIndex22 = 0;\n  let reversedCharsLengthIndex22 = 0;\n  let reversedCharsIndex23 = 0;\n  let reversedCharsLengthIndex23 = 0;\n  let reversedCharsIndex24 = 0;\n  let reversedCharsLengthIndex24 = 0;\n  let reversedCharsIndex25 = 0;\n  let reversedCharsLengthIndex25 = 0;\n  let reversedCharsIndex26 = 0;\n  let reversedCharsLengthIndex26 = 0;\n  let reversedCharsIndex27 = 0;\n  let reversedCharsLengthIndex27 = 0;\n  let reversedCharsIndex28 = 0;\n  let reversedCharsLengthIndex28 = 0;\n  let reversedCharsIndex29 = 0;\n  let reversedCharsLengthIndex29 = 0;\n  let reversedCharsIndex30 = 0;\n  let reversedCharsLengthIndex30 = 0;\n  let reversedCharsIndex31 = 0;\n  let reversedCharsLengthIndex31 = 0;\n  let reversedCharsIndex32 = 0;\n  let reversedCharsLengthIndex32 = 0;\n  let reversedCharsIndex33 = 0;\n  let reversedCharsLengthIndex33 = 0;\n  let reversedCharsIndex34 = 0;\n  let reversedCharsLengthIndex34 = 0;\n  let reversedCharsIndex35 = 0;\n  let reversedCharsLengthIndex35 = 0;\n  let reversedCharsIndex36 = 0;\n  let reversedCharsLengthIndex36 = 0;\n  let reversedCharsIndex37 = 0;\n  let reversedCharsLengthIndex37 = 0;\n  let reversedCharsIndex38 = 0;\n  let reversedCharsLengthIndex38 = 0;\n  let reversedCharsIndex39 = 0;\n  let reversedCharsLengthIndex39 = 0;\n  let reversedCharsIndex40 = 0;\n  let reversedCharsLengthIndex40 = 0;\n  let reversedCharsIndex41 = 0;\n  let reversedCharsLengthIndex41 = 0;\n  let reversedCharsIndex42 = 0;\n  let reversedCharsLengthIndex42 = 0;\n  let reversedCharsIndex43 = 0;\n  let reversedCharsLengthIndex43 = 0;\n  let reversedCharsIndex44 = 0;\n  let reversedCharsLengthIndex44 = 0;\n  let reversedCharsIndex45 = 0;\n  let reversedCharsLengthIndex45 = 0;\n  let reversedCharsIndex46 = 0;\n  let reversedCharsLengthIndex46 = 0;\n  let reversedCharsIndex47 = 0;\n  let reversedCharsLengthIndex47 = 0;\n  let reversedCharsIndex48 = 0;\n  let reversedCharsLengthIndex48 = 0;\n  let reversedCharsIndex49 = 0;\n  let reversedCharsLengthIndex49 = 0;\n  let reversedCharsIndex50 = 0;\n  let reversedCharsLengthIndex50 = 0;\n  let reversedCharsIndex51 = 0;\n  let reversedCharsLengthIndex51 = 0;\n  let reversedCharsIndex52 = 0;\n  let reversedCharsLengthIndex52 = 0;\n  let reversedCharsIndex53 = 0;\n  let reversedCharsLengthIndex53 = 0;\n  let reversedCharsIndex54 = 0;\n  let reversedCharsLengthIndex54 = 0;\n  let reversedCharsIndex55 = 0;\n  let reversedCharsLengthIndex55 = 0;\n  let reversedCharsIndex56 = 0;\n  let reversedCharsLengthIndex56 = 0;\n  let reversedCharsIndex57 = 0;\n  let reversedCharsLengthIndex57 = 0;\n  let reversedCharsIndex58 = 0;\n  let reversedCharsLengthIndex58 = 0;\n  let reversedCharsIndex59 = 0;\n  let reversedCharsLengthIndex59 = 0;\n  let reversedCharsIndex60 = 0;\n  let reversedCharsLengthIndex60 = 0;\n  let reversedCharsIndex61 = 0;\n  let reversedCharsLengthIndex61 = 0;\n  let reversedCharsIndex62 = 0;\n  let reversedCharsLengthIndex62 = 0;\n  let reversedCharsIndex63 = 0;\n  let reversedCharsLengthIndex63 = 0;\n  let reversedCharsIndex64 = 0;\n  let reversedCharsLengthIndex64 = 0;\n  let reversedCharsIndex65 = 0;\n  let reversedCharsLengthIndex65 = 0;\n  let reversedCharsIndex66 = 0;\n  let reversedCharsLengthIndex66 = 0;\n  let reversedCharsIndex67 = 0;\n  let reversedCharsLengthIndex67 = 0;\n  let reversedCharsIndex68 = 0;\n  let reversedCharsLengthIndex68 = 0;\n  let reversedCharsIndex69 = 0;\n  let reversedCharsLengthIndex69 = 0;\n  let reversedCharsIndex70 = 0;\n  let reversedCharsLengthIndex70 = 0;\n  let reversedCharsIndex71 = 0;\n  let reversedCharsLengthIndex71 = 0;\n  let reversedCharsIndex72 = 0;\n  let reversedCharsLengthIndex72 = 0;\n  let reversedCharsIndex73 = 0;\n  let reversedCharsLengthIndex73 = 0;\n  let reversedCharsIndex"}
{"task_id": "JavaScript/113", "prompt": "/*GIf you create a list of strings in which each string consists only of digits, you return a list. Each element i of the output should be \"the number of odd elements in the string i of input,\" with all i's being replaced by the number of odd digits in the i'th string of input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*GIf you create a list of strings in which each string consists only of digits, you return a list. Each element i of the output should be \"the number of odd elements in the string i of input,\" with all i's being replaced by the number of odd digits in the i'th string of input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let oddCounts = [];\n  let oddCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      oddCount++;\n      oddCounts.push(oddCount);\n    }\n  }\n  return oddCounts;\n};\n\n/*\n  Given a string, return its reverse in lexicographical order.\n\n  >>> reverseLex('hello')\n  ['olleh', 'hello']\n  >>> reverseLex('hello').reverse()\n  ['olleh', 'hello']\n  >>> reverseLex('hello').reverse().reverse()\n  ['hello', 'olleh']\n  */\nconst reverseLex = (str) => {\n  let reversed = [];\n  let reversedStr = '';\n  for (let i = 0; i < str.length; i++) {\n    reversedStr += str[i];\n    if (reversedStr.charAt(reversedStr.length - 1) == str[str.length - i - 1]) {\n      reversed.push(reversedStr.charAt(reversedStr.length - 1));\n      reversedStr = '';\n    }\n  }\n  return reversed;\n};\n\n/*\n  Given a string, return its reverse in reverse lexicographical order.\n\n  >>> reverseLex('hello').reverse()\n  ['olleh', 'hello']\n  >>> reverseLex('hello').reverse().reverse()\n  ['hello', 'olleh']\n  >>> reverseLex('hello').reverse().reverse().reverse()\n  ['olleh', 'hello', 'hello']\n  */\nconst reverseRevLex = (str) => {\n  let reversed = [];\n  let reversedStr = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversedStr += str[i];\n    if (reversedStr.charAt(0) == str[i - 1]) {\n      reversed.push(reversedStr.charAt(0));\n      reversedStr = '';\n    }\n  }\n  return reversed;\n};\n\n/*\n  Given a string, return its reverse in reverse lexicographical order.\n\n  >>> reverseLex('hello').reverse().reverse()\n  ['olleh', 'hello']\n  >>> reverseLex('hello').reverse().reverse().reverse()\n  ['hello', 'olleh']\n  >>> reverseLex('hello').reverse().reverse().reverse().reverse()\n  ['olleh', 'hello', 'hello']\n  */\nconst reverseRevRevLex = (str) => {\n  let reversed = [];\n  let reversedStr = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversedStr += str[i];\n    if (reversedStr.charAt(reversedStr.length - 1) == str[i - 1]) {\n      reversed.push(reversedStr.charAt(reversedStr.length - 1));\n      reversedStr = '';\n    }\n  }\n  return reversed.reverse();\n};\n\n/*\n  Given a string, return its reverse in reverse lexicographical order.\n\n  >>> reverseLex('hello').reverse().reverse().reverse()\n  ['olleh', 'hello']\n  >>> reverseLex('hello').reverse().reverse().reverse().reverse()\n  ['hello', 'olleh']\n  >>> reverseLex('hello').reverse().reverse().reverse().reverse().reverse()\n  ['olleh', 'hello', 'hello']\n  */\nconst reverseRevRevRevLex = (str) => {\n  let reversed = [];\n  let reversedStr = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversedStr += str[i];\n    if (reversedStr.charAt(reversedStr.length - 1) == str[i - 1]) {\n      reversed.push(reversedStr.charAt(reversedStr.length - 1));\n      reversedStr = '';\n    }\n  }\n  return reversed.reverse().reverse();\n};\n\n/*\n  Given a string, return its reverse in reverse lexicographical order.\n\n  >>> reverseLex('hello').reverse().reverse().reverse().reverse()\n  ['olleh', 'hello']\n  >>> reverseLex('hello').reverse().reverse().reverse().reverse().reverse()\n  ['hello', 'olleh']\n  >>> reverseLex('hello').reverse().reverse().reverse().reverse().reverse().reverse()\n  ['olleh', 'hello', 'hello']\n  */\nconst reverseRevRevRevRevLex = (str) => {\n  let reversed = [];\n  let reversedStr = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversedStr += str[i];\n    if (reversedStr.charAt(reversedStr.length - 1) == str[i - 1]) {\n      reversed.push(reversedStr.charAt(reversedStr.length - 1));\n      reversedStr = '';\n    }\n  }\n  return reversed.reverse().reverse().reverse().reverse();\n};\n\n/*\n  Given a string, return its reverse in reverse lexicographical order.\n\n  >>> reverseLex('hello').reverse().reverse().reverse().reverse().reverse()\n  ['olleh', 'hello']\n  >>> reverseLex('hello').reverse().reverse().reverse().reverse().reverse().reverse()\n  ['hello', 'olleh']\n  >>> reverseLex('hello').reverse().reverse().reverse().reverse().reverse().reverse().reverse()\n  ['olleh', 'hello', 'hello']\n  */\nconst reverseRevRevRevRevRevRevLex = (str) => {\n  let reversed = [];\n  let reversedStr = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversedStr += str[i];\n    if (reversedStr.charAt(reversedStr.length - 1) == str[i - 1]) {\n      reversed.push(reversedStr.charAt(reversedStr.length - 1));\n      reversedStr = '';\n    }\n  }\n  return reversed.reverse().reverse().reverse().reverse().reverse().reverse();\n};\n\n/*\n  Given a string, return its reverse in reverse lexicographical order.\n\n  >>> reverseLex('hello').reverse().reverse().reverse().reverse().reverse().reverse()\n  ['olleh', 'hello']\n  >>> reverseLex('hello').reverse().reverse().reverse().reverse().reverse().reverse().reverse()\n  ['hello', 'olleh']\n  >>> reverseLex('hello').reverse().reverse().reverse().reverse().reverse().reverse().reverse()\n  ['olleh', 'hello', 'hello']\n  */\nconst reverseRevRevRevRevRevRevRevLex = (str) => {\n  let reversed = [];\n  let reversedStr = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversedStr += str[i];\n    if (reversedStr.charAt(reversedStr.length - 1) == str[i - 1]) {\n      reversed.push(reversedStr.charAt(reversedStr.length - 1));\n      reversedStr = '';\n    }\n  }\n  return reversed.reverse().reverse().reverse().reverse().reverse().reverse().reverse();"}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an array of integers, search for the minimum sum of all non-empty sub-arrays of numbers.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an array of integers, search for the minimum sum of all non-empty sub-arrays of numbers.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let sum = 0;\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given an array of integers, search for the maximum sum of all non-empty sub-arrays of numbers.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == 6\n  */\nconst maxSubArraySum = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n    }\n  }\n  return maxSum;\n};\n\n/*\n  Given an array of integers, search for the minimum number of non-empty sub-arrays of numbers.\n  Example\n  minSubArrayCount([2, 3, 4, 1, 2, 4]) == 3\n  minSubArrayCount([-1, -2, -3]) == 4\n  */\nconst minSubArrayCount = (nums) => {\n  let count = 0;\n  let minCount = 0;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < nums[i - 1]) {\n      minCount++;\n    }\n    if (nums[i] >= nums[i - 1]) {\n      count++;\n    }\n  }\n  return minCount + count;\n};\n\n/*\n  Given an array of integers, search for the maximum number of non-empty sub-arrays of numbers.\n  Example\n  maxSubArrayCount([2, 3, 4, 1, 2, 4]) == 3\n  maxSubArrayCount([-1, -2, -3]) == 4\n  */\nconst maxSubArrayCount = (nums) => {\n  let count = 0;\n  let maxCount = 0;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] > nums[i - 1]) {\n      maxCount++;\n    }\n    if (nums[i] > nums[i - 1]) {\n      count++;\n    }\n  }\n  return maxCount + count;\n};\n\n/*\n  Given an array of integers, search for the minimum number of non-empty sub-arrays of numbers.\n  Example\n  minSubArrayCount([2, 3, 4, 1, 2, 4]) == 3\n  minSubArrayCount([-1, -2, -3]) == 4\n  */\nconst minSubArrayCountNonZero = (nums) => {\n  let count = 0;\n  let minCount = 0;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] > 0) {\n      minCount++;\n    }\n    if (nums[i] < 0) {\n      count++;\n    }\n  }\n  return minCount + count;\n};\n\n/*\n  Given an array of integers, search for the maximum number of non-empty sub-arrays of numbers.\n  Example\n  maxSubArrayCount([2, 3, 4, 1, 2, 4]) == 3\n  maxSubArrayCount([-1, -2, -3]) == 4\n  */\nconst maxSubArrayCountNonZero = (nums) => {\n  let count = 0;\n  let maxCount = 0;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < 0) {\n      maxCount++;\n    }\n    if (nums[i] > 0) {\n      count++;\n    }\n  }\n  return maxCount + count;\n};\n\n/*\n  Given an array of integers, search for the minimum number of non-empty sub-arrays of numbers.\n  Example\n  minSubArrayCountNonZero([2, 3, 4, 1, 2, 4]) == 3\n  minSubArrayCountNonZero([-1, -2, -3]) == 4\n  */\nconst minSubArrayCountNonZeroNonZero = (nums) => {\n  let count = 0;\n  let minCount = 0;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] > 0) {\n      minCount++;\n    }\n    if (nums[i] < 0) {\n      count++;\n    }\n    if (nums[i] > 0 && nums[i] < 0) {\n      count++;\n    }\n  }\n  return minCount + count;\n};\n\n/*\n  Given an array of integers, search for the maximum number of non-empty sub-arrays of numbers.\n  Example\n  maxSubArrayCountNonZero([2, 3, 4, 1, 2, 4]) == 3\n  maxSubArrayCountNonZero([-1, -2, -3]) == 4\n  */\nconst maxSubArrayCountNonZeroNonZero = (nums) => {\n  let count = 0;\n  let maxCount = 0;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < 0) {\n      maxCount++;\n    }\n    if (nums[i] > 0 && nums[i] < 0) {\n      count++;\n    }\n  }\n  return maxCount + count;\n};\n\n/*\n  Given an array of integers, search for the minimum number of non-empty sub-arrays of numbers.\n  Example\n  minSubArrayCountNonZeroNonZero([2, 3, 4, 1, 2, 4]) == 3\n  minSubArrayCountNonZeroNonZero([-1, -2, -3]) == 4\n  */\nconst minSubArrayCountNonZeroNonZeroNonZero = (nums) => {\n  let count = 0;\n  let minCount = 0;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] > 0) {\n      minCount++;\n    }\n    if (nums[i] < 0) {\n      count++;\n    }\n    if (nums[i] > 0 && nums[i] < 0) {\n      count++;\n    }\n  }\n  return minCount + count;\n};\n\n/*\n  Given an array of integers, search for the maximum number of non-empty sub-arrays of numbers.\n  Example\n  maxSubArrayCountNonZeroNonZero([2, 3, 4, 1, 2, 4]) == 3\n  maxSubArrayCountNonZeroNonZero([-1, -2, -3]) == 4\n  */\nconst maxSubArrayCountNonZeroNonZeroNonZero = (nums) => {\n  let count = 0;\n  let maxCount = 0;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < 0) {\n      maxCount++;\n    }\n    if (nums[i] > 0 && nums[i] < 0) {\n      count++;\n    }\n  }\n  return maxCount + count;\n};\n\n/*\n  Given an array of integers, search for the minimum number of non-empty sub-arrays of numbers.\n  Example\n  minSubArrayCountNonZeroNonZero([2, 3, 4, 1, 2, 4]) == 3\n  minSubArrayCountNonZeroNonZero([-1, -2, -3]) == 4\n  */\nconst minSubArrayCountNonZeroNonZeroNonZero = (nums) => {\n  let count = 0;\n  let minCount = 0;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] > 0) {\n      minCount++;\n    }\n    if (nums[i] < 0) {\n      count++;\n    }\n    if (nums[i] > 0 && nums[i] < 0) {\n      count++;\n    }\n  }\n  return minCount + count;\n};\n\n/*\n  Given an array of integers, search for the maximum number of non-empty sub-arrays of numbers.\n  Example\n  maxSubArrayCountNonZeroNonZero([2, 3, 4, 1, 2, 4]) == 3\n  maxSubArrayCountNonZeroNonZero([-1, -2, -3]) == 4\n  */\nconst maxSubArrayCountNonZeroNonZeroNonZero = (nums) => {\n  let count = 0;\n  let maxCount = 0;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < 0) {\n      maxCount++;\n    }\n    if (nums[i] > 0 && nums[i] < 0) {\n      count++;\n    }\n  }\n  return maxCount + count;\n};\n\n/*\n  Given an array of integers, search for the minimum number of non-empty sub-arrays of numbers.\n  Example\n  minSubArrayCountNonZeroNonZero([2, 3, 4, 1, 2, 4]) == 3\n  minSubArrayCountNonZeroNonZero([-1, -2, -3]) == 4\n  */\nconst minSubArrayCountNonZeroNonZeroNonZero = (nums) => {\n  let count = 0;\n  let minCount = 0;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] > 0) {\n      minCount++;\n    }\n    if (nums[i] < 0) {\n      count++;"}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = 0;\n    \n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < m; j++) {\n            if(grid[i][j] === 1) {\n                let count = 0;\n                for(let k = 0; k < capacity; k++) {\n                    if(grid[i][j] === 1) {\n                        count += 1;\n                    }\n                }\n                result += count;\n            }\n        }\n    }\n    return result;\n};\n\n/**\n * Your MaxFill function will be called like so:\n *\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n */\nconst maxFill2 = maxFill;\n\n/**\n * Your MaxFill function will be called like so:\n *\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n */\nconst maxFill3 = maxFill;\n\n/**\n * Your MaxFill function will be called like so:\n *\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n */\nconst maxFill4 = maxFill;\n\n/**\n * Your MaxFill function will be called like so:\n *\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n */\nconst maxFill5 = maxFill;\n\n/**\n * Your MaxFill function will be called like so:\n *\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n */\nconst maxFill6 = maxFill;\n\n/**\n * Your MaxFill function will be called like so:\n *\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n */\nconst maxFill7 = maxFill;\n\n/**\n * Your MaxFill function will be called like so:\n *\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n */\nconst maxFill8 = maxFill;\n\n/**\n * Your MaxFill function will be called like so:\n *\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n */\nconst maxFill9 = maxFill;\n\n/**\n * Your MaxFill function will be called like so:\n *\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n */\nconst maxFill10 = maxFill;\n\n/**\n * Your MaxFill function will be called like so:\n *\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n */\nconst maxFill11 = maxFill;\n\n/**\n * Your MaxFill function will be called like so:\n *\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n */\nconst maxFill12 = maxFill;\n\n/**\n * Your MaxFill function will be called like so:\n *\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n */\nconst maxFill13 = maxFill;\n\n/**\n * Your MaxFill function will be called like so:\n *\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n */\nconst maxFill14 = maxFill;\n\n/**\n * Your MaxFill function will be called like so:\n *\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n */\nconst maxFill15 = maxFill;\n\n/**\n * Your MaxFill function will be called like so:\n *\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n */\nconst maxFill16 = maxFill;\n\n/**\n * Your MaxFill function will be called like so:\n *\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n */\nconst maxFill17 = maxFill;\n\n/**\n * Your MaxFill function will be called like so:\n *\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n */\nconst maxFill18 = maxFill;\n\n/**\n * Your MaxFill function will be called like so:\n *\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n */\nconst maxFill19 = maxFill;\n\n/**\n * Your MaxFill function will be called like so:\n *\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n */\nconst maxFill20 = maxFill;\n\n/**\n * Your MaxFill function will be called like so:\n *\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n */\nconst maxFill21 = maxFill;\n\n/**\n * Your MaxFill function will be called like so:\n *\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n */\nconst maxFill22 = maxFill;\n\n/**\n * Your MaxFill function will be called like so:\n *\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n */\nconst maxFill23 = maxFill;\n\n/**\n * Your MaxFill function will be called like so:\n *\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n */\nconst maxFill24 = maxFill;\n\n/**\n * Your MaxFill function will be called like so:\n *\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n */\nconst maxFill25 = maxFill;\n\n/**\n * Your MaxFill function will be called like so:\n *\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n */\nconst maxFill26 = maxFill;\n\n/**\n * Your MaxFill function will be called like so:\n *\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n */\nconst maxFill27 = maxFill;\n\n/**\n * Your MaxFill function will be called like so:\n *\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n */"}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this kata, you must sort an array of non-negative integers by the number of ones in their binary representation in ascending order. If the number of ones is similar, sort by decimal value. It must be implemented as follows:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  In this kata, you must sort an array of non-negative integers by the number of ones in their binary representation in ascending order. If the number of ones is similar, sort by decimal value. It must be implemented as follows:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sortedArr = []\n  let sortedNum = 0\n  let sortedDec = 0\n  let sortedDecNum = 0\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 1) {\n      sortedArr.push(sortedNum)\n      sortedNum++\n    } else {\n      sortedArr.push(sortedDec)\n      sortedDec++\n    }\n  }\n  sortedArr.push(sortedNum)\n  return sortedArr\n}\n\n/*\n  Given an array of non-negative integers, return an array of the same size that contains all possible permutations of the elements. Each permutation should be made by swapping two elements in the array and moving one element to the left or right of the new element. For example,\n  >>> permutations([1, 5, 2, 3, 4]) == [[1, 5, 2, 3, 4], [1, 5, 2, 4, 3], [1, 5, 2, 3, 4], [1, 5, 2, 4, 3], [1, 5, 2, 3, 4], [1, 5, 2, 4, 3]]\n  >>> permutations([-2, -3, -4, -5, -6]) == [[-6, -5, -4, -3, -2], [-6, -5, -4, -3, -2], [-6, -5, -4, -3, -2], [-6, -5, -4, -3, -2], [-6, -5, -4, -3, -2], [-6, -5, -4, -3, -2]]\n  >>> permutations([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst permutations = (arr) => {\n  const permutationArr = []\n  let tempArr = []\n  let tempNum = 0\n  let tempDec = 0\n  let tempDecNum = 0\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 1) {\n      tempArr.push(tempNum)\n      tempNum++\n    } else {\n      tempArr.push(tempDec)\n      tempDec++\n    }\n  }\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)\n  tempArr.push(tempDec)\n  tempArr.push(tempNum)"}
{"task_id": "JavaScript/117", "prompt": "/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  let words = []\n  let word = ''\n  let index = 0\n  let found = false\n  let wordCount = 0\n  let wordCountMax = s.length\n  let wordCountMin = 1\n  let wordCountMaxMin = 1\n  let wordCountMaxMax = s.length\n  let wordCountMinMax = 1\n  let wordCountMinMin = 1\n  let wordCountMaxMinMax = 1\n  let wordCountMinMinMax = 1\n  let wordCountMaxMinMinMax = 1\n  let wordCountMinMinMinMax = 1\n  let wordCountMaxMinMinMinMax = 1\n  let wordCountMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMaxMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCountMinMinMinMinMinMinMinMinMinMinMinMinMax = 1\n  let wordCount"}
{"task_id": "JavaScript/118", "prompt": "/*YYour task is to find the next vowel between two consonants on the right side of the word (case-insensitive), vowels at the beginning and end do not count, and you return an empty string if you have not found a vowel that meets the above condition, and you can assume that the given string contains only English letters.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*YYour task is to find the next vowel between two consonants on the right side of the word (case-insensitive), vowels at the beginning and end do not count, and you return an empty string if you have not found a vowel that meets the above condition, and you can assume that the given string contains only English letters.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  let vowels = vowels.split('');\n  let vowelsLength = vowels.length;\n  let vowelsIndex = 0;\n  let vowelsLengthIndex = 0;\n  let vowelsIndex2 = 0;\n  let vowelsLengthIndex2 = 0;\n  let vowelsIndex3 = 0;\n  let vowelsLengthIndex3 = 0;\n  let vowelsIndex4 = 0;\n  let vowelsLengthIndex4 = 0;\n  let vowelsIndex5 = 0;\n  let vowelsLengthIndex5 = 0;\n  let vowelsIndex6 = 0;\n  let vowelsLengthIndex6 = 0;\n  let vowelsIndex7 = 0;\n  let vowelsLengthIndex7 = 0;\n  let vowelsIndex8 = 0;\n  let vowelsLengthIndex8 = 0;\n  let vowelsIndex9 = 0;\n  let vowelsLengthIndex9 = 0;\n  let vowelsIndex10 = 0;\n  let vowelsLengthIndex10 = 0;\n  let vowelsIndex11 = 0;\n  let vowelsLengthIndex11 = 0;\n  let vowelsIndex12 = 0;\n  let vowelsLengthIndex12 = 0;\n  let vowelsIndex13 = 0;\n  let vowelsLengthIndex13 = 0;\n  let vowelsIndex14 = 0;\n  let vowelsLengthIndex14 = 0;\n  let vowelsIndex15 = 0;\n  let vowelsLengthIndex15 = 0;\n  let vowelsIndex16 = 0;\n  let vowelsLengthIndex16 = 0;\n  let vowelsIndex17 = 0;\n  let vowelsLengthIndex17 = 0;\n  let vowelsIndex18 = 0;\n  let vowelsLengthIndex18 = 0;\n  let vowelsIndex19 = 0;\n  let vowelsLengthIndex19 = 0;\n  let vowelsIndex20 = 0;\n  let vowelsLengthIndex20 = 0;\n  let vowelsIndex21 = 0;\n  let vowelsLengthIndex21 = 0;\n  let vowelsIndex22 = 0;\n  let vowelsLengthIndex22 = 0;\n  let vowelsIndex23 = 0;\n  let vowelsLengthIndex23 = 0;\n  let vowelsIndex24 = 0;\n  let vowelsLengthIndex24 = 0;\n  let vowelsIndex25 = 0;\n  let vowelsLengthIndex25 = 0;\n  let vowelsIndex26 = 0;\n  let vowelsLengthIndex26 = 0;\n  let vowelsIndex27 = 0;\n  let vowelsLengthIndex27 = 0;\n  let vowelsIndex28 = 0;\n  let vowelsLengthIndex28 = 0;\n  let vowelsIndex29 = 0;\n  let vowelsLengthIndex29 = 0;\n  let vowelsIndex30 = 0;\n  let vowelsLengthIndex30 = 0;\n  let vowelsIndex31 = 0;\n  let vowelsLengthIndex31 = 0;\n  let vowelsIndex32 = 0;\n  let vowelsLengthIndex32 = 0;\n  let vowelsIndex33 = 0;\n  let vowelsLengthIndex33 = 0;\n  let vowelsIndex34 = 0;\n  let vowelsLengthIndex34 = 0;\n  let vowelsIndex35 = 0;\n  let vowelsLengthIndex35 = 0;\n  let vowelsIndex36 = 0;\n  let vowelsLengthIndex36 = 0;\n  let vowelsIndex37 = 0;\n  let vowelsLengthIndex37 = 0;\n  let vowelsIndex38 = 0;\n  let vowelsLengthIndex38 = 0;\n  let vowelsIndex39 = 0;\n  let vowelsLengthIndex39 = 0;\n  let vowelsIndex40 = 0;\n  let vowelsLengthIndex40 = 0;\n  let vowelsIndex41 = 0;\n  let vowelsLengthIndex41 = 0;\n  let vowelsIndex42 = 0;\n  let vowelsLengthIndex42 = 0;\n  let vowelsIndex43 = 0;\n  let vowelsLengthIndex43 = 0;\n  let vowelsIndex44 = 0;\n  let vowelsLengthIndex44 = 0;\n  let vowelsIndex45 = 0;\n  let vowelsLengthIndex45 = 0;\n  let vowelsIndex46 = 0;\n  let vowelsLengthIndex46 = 0;\n  let vowelsIndex47 = 0;\n  let vowelsLengthIndex47 = 0;\n  let vowelsIndex48 = 0;\n  let vowelsLengthIndex48 = 0;\n  let vowelsIndex49 = 0;\n  let vowelsLengthIndex49 = 0;\n  let vowelsIndex50 = 0;\n  let vowelsLengthIndex50 = 0;\n  let vowelsIndex51 = 0;\n  let vowelsLengthIndex51 = 0;\n  let vowelsIndex52 = 0;\n  let vowelsLengthIndex52 = 0;\n  let vowelsIndex53 = 0;\n  let vowelsLengthIndex53 = 0;\n  let vowelsIndex54 = 0;\n  let vowelsLengthIndex54 = 0;\n  let vowelsIndex55 = 0;\n  let vowelsLengthIndex55 = 0;\n  let vowelsIndex56 = 0;\n  let vowelsLengthIndex56 = 0;\n  let vowelsIndex57 = 0;\n  let vowelsLengthIndex57 = 0;\n  let vowelsIndex58 = 0;\n  let vowelsLengthIndex58 = 0;\n  let vowelsIndex59 = 0;\n  let vowelsLengthIndex59 = 0;\n  let vowelsIndex60 = 0;\n  let vowelsLengthIndex60 = 0;\n  let vowelsIndex61 = 0;\n  let vowelsLengthIndex61 = 0;\n  let vowelsIndex62 = 0;\n  let vowelsLengthIndex62 = 0;\n  let vowelsIndex63 = 0;\n  let vowelsLengthIndex63 = 0;\n  let vowelsIndex64 = 0;\n  let vowelsLengthIndex64 = 0;\n  let vowelsIndex65 = 0;\n  let vowelsLengthIndex65 = 0;\n  let vowelsIndex66 = 0;\n  let vowelsLengthIndex66 = 0;\n  let vowelsIndex67 = 0;\n  let vowelsLengthIndex67 = 0;\n  let vowelsIndex68 = 0;\n  let vowelsLengthIndex68 = 0;\n  let vowelsIndex69 = 0;\n  let vowelsLengthIndex69 = 0;\n  let vowelsIndex70 = 0;\n  let vowelsLengthIndex70 = 0;\n  let vowelsIndex71 = 0;\n  let vowelsLengthIndex71 = 0;\n  let vowelsIndex72 = 0;\n  let vowelsLengthIndex72 = 0;\n  let vowelsIndex73 = 0;\n  let vowelsLengthIndex73 = 0;\n  let vowelsIndex74 = 0;\n  let vowelsLengthIndex74 = 0;\n  let vowelsIndex75 = 0;\n  let vowelsLengthIndex75 = 0;\n  let vowelsIndex76 = 0;\n  let vowelsLengthIndex76 = 0;\n  let vowelsIndex77 = 0;\n  let vowelsLengthIndex77 = 0;\n  let vowelsIndex78 = 0;\n  let vowelsLengthIndex78 = 0;\n  let vowelsIndex79 = 0;\n  let vowelsLengthIndex79 = 0;\n  let vowelsIndex80 = 0;\n  let vowelsLengthIndex80 = 0;\n  let vowelsIndex81 = 0;\n  let vowelsLengthIndex81 = 0;\n  let vowelsIndex82 = 0;\n  let vowelsLengthIndex82 = 0;\n  let vowelsIndex83 = 0;\n  let vowelsLengthIndex83 = 0;\n  let vowelsIndex84 = 0;\n  let vowelsLengthIndex84 = 0;\n  let vowelsIndex85 = 0;\n  let vowelsLengthIndex85 = 0;\n  let vowelsIndex86 = 0;\n  let vowelsLengthIndex86 = 0;\n  let vowelsIndex87 = 0;\n  let vowelsLengthIndex87 = 0;\n  let vowelsIndex88 = 0;\n  let vowelsLengthIndex88 = 0;\n  let vowelsIndex89 = 0;\n  let vowelsLengthIndex89 = 0;\n  let vowelsIndex90 = 0;\n  let vowelsLengthIndex90 = 0;\n  let vowelsIndex91 = 0;\n  let vowelsLengthIndex91 = 0;\n  let vowelsIndex92 = 0;\n  let vowelsLengthIndex92 = 0;\n  let vowelsIndex93 = 0;\n  let vowelsLengthIndex93 = 0;\n  let vowel"}
{"task_id": "JavaScript/119", "prompt": "/* You get a list of two strings, both strings consisting only of open brackets' ('or closed brackets') '. Your task is to check if it is possible to concatenate the two strings in a certain order so that the resulting string is good. A string S is considered good if and only if all the brackets in S are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* You get a list of two strings, both strings consisting only of open brackets' ('or closed brackets') '. Your task is to check if it is possible to concatenate the two strings in a certain order so that the resulting string is good. A string S is considered good if and only if all the brackets in S are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let res = 'No'\n  let isOpen = false\n  let isClosed = false\n  let isBalanced = false\n  let isOpenParens = false\n  let isClosedParens = false\n  let isOpenBrackets = false\n  let isClosedBrackets = false\n  let isOpenParensOrClosed = false\n  let isClosedParensOrClosed = false\n  let isOpenBracketsOrClosed = false\n  let isClosedBracketsOrClosed = false\n  let isOpenParensOrClosedOrClosed = false\n  let isClosedParensOrClosedOrClosed = false\n  let isOpenBracketsOrClosedOrClosed = false\n  let isClosedBracketsOrClosedOrClosed = false\n  let isOpenParensOrClosedOrClosedOrClosed = false\n  let isClosedParensOrClosedOrClosedOrClosed = false\n  let isOpenBracketsOrClosedOrClosedOrClosed = false\n  let isClosedBracketsOrClosedOrClosedOrClosed = false\n  let isOpenParensOrClosedOrClosedOrClosedOrClosed = false\n  let isClosedParensOrClosedOrClosedOrClosedOrClosed = false\n  let isOpenBracketsOrClosedOrClosedOrClosedOrClosed = false\n  let isClosedBracketsOrClosedOrClosedOrClosedOrClosed = false\n  let isOpenParensOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isClosedParensOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isOpenBracketsOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isClosedBracketsOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isOpenParensOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isClosedParensOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isOpenBracketsOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isClosedBracketsOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isOpenParensOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isClosedParensOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isOpenBracketsOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isClosedBracketsOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isOpenParensOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isClosedParensOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isOpenBracketsOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isClosedBracketsOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isOpenParensOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isClosedParensOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isOpenBracketsOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isClosedBracketsOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isOpenParensOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isClosedParensOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isOpenBracketsOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isClosedBracketsOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isOpenParensOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isClosedParensOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isOpenBracketsOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isClosedBracketsOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isOpenParensOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isClosedParensOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isOpenBracketsOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isClosedBracketsOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isOpenParensOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isClosedParensOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isOpenBracketsOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isClosedBracketsOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isOpenParensOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isClosedParensOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isOpenBracketsOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isClosedBracketsOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isOpenParensOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isClosedParensOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isOpenBracketsOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isClosedBracketsOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isOpenParensOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosedOrClosed = false\n  let isClosedParensOrClosedOrClosed"}
{"task_id": "JavaScript/120", "prompt": "/*\n  If you specify an array of integers and a positive integer k, you return a sorted list of length k with the maximum k numbers in Arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  If you specify an array of integers and a positive integer k, you return a sorted list of length k with the maximum k numbers in Arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const len = arr.length;\n  const result = [];\n  let max = 0;\n  for (let i = 0; i < len; i++) {\n    if (max < arr[i]) {\n      max = arr[i];\n      result.push(max);\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-duplicate-digits/\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutiveDuplicateDigits = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === nums[i - 1]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-duplicate-digits/\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutiveDuplicateDigits2 = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === nums[i - 1]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-duplicate-digits/\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutiveDuplicateDigits3 = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === nums[i - 1]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-duplicate-digits/\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutiveDuplicateDigits4 = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === nums[i - 1]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-duplicate-digits/\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutiveDuplicateDigits5 = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === nums[i - 1]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-duplicate-digits/\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutiveDuplicateDigits6 = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === nums[i - 1]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-duplicate-digits/\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutiveDuplicateDigits7 = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === nums[i - 1]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-duplicate-digits/\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutiveDuplicateDigits8 = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === nums[i - 1]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-duplicate-digits/\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutiveDuplicateDigits9 = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === nums[i - 1]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-duplicate-digits/\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutiveDuplicateDigits10 = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === nums[i - 1]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-duplicate-digits/\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutiveDuplicateDigits11 = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === nums[i - 1]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-duplicate-digits/\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutiveDuplicateDigits12 = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === nums[i - 1]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-duplicate-digits/\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutiveDuplicateDigits13 = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === nums[i - 1]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-duplicate-digits/\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutiveDuplicateDigits14 = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === nums[i - 1]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-duplicate-digits/\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutiveDuplicateDigits15 = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === nums[i - 1]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-duplicate-digits/\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutiveDuplicateDigits16 = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === nums[i - 1]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-duplicate-digits/\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutiveDuplicateDigits17 = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === nums[i - 1]) {\n      count++;\n    }"}
{"task_id": "JavaScript/121", "prompt": "/*GIf you create a non-empty list of integers, you return the sum of all odd elements in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*GIf you create a non-empty list of integers, you return the sum of all odd elements in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty list of integers, return the number of distinct pairs of distinct integers such that each pair sums to n.\n  \n\n  Examples\n  distinctPairs([5, 8, 7, 1]) ==> 2\n  distinctPairs([3, 3, 3, 3, 3]) ==> 1\n  distinctPairs([30, 13, 24, 321]) ==> 0\n  */\nconst distinctPairs = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === lst[i + 1]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a non-empty list of integers, return the number of distinct triplets such that each triplet sums to n.\n  \n\n  Examples\n  distinctTriplets([5, 8, 7, 1]) ==> 3\n  distinctTriplets([3, 3, 3, 3, 3]) ==> 2\n  distinctTriplets([30, 13, 24, 321]) ==> 1\n  */\nconst distinctTriplets = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === lst[i + 1] && lst[i] === lst[i + 2]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a non-empty list of integers, return the number of distinct binary strings such that each binary string sums to n.\n  \n\n  Examples\n  distinctBinaryStrings([5, 8, 7, 1]) ==> 3\n  distinctBinaryStrings([3, 3, 3, 3, 3]) ==> 2\n  distinctBinaryStrings([30, 13, 24, 321]) ==> 1\n  */\nconst distinctBinaryStrings = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === lst[i + 1] && lst[i] === lst[i + 2]) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a non-empty list of integers, return the number of distinct permutations such that each permutation sums to n.\n  \n\n  Examples\n  distinctPermutations([5, 8, 7, 1]) ==> 3\n  distinctPermutations([3, 3, 3, 3, 3]) ==> 2\n  distinctPermutations([30, 13, 24, 321]) ==> 1\n  */\nconst distinctPermutations = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === lst[i + 1] && lst[i] === lst[i + 2]) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a non-empty list of integers, return the number of distinct prime numbers such that each prime number sums to n.\n  \n\n  Examples\n  distinctPrimes([5, 8, 7, 1]) ==> 3\n  distinctPrimes([3, 3, 3, 3, 3]) ==> 2\n  distinctPrimes([30, 13, 24, 321]) ==> 1\n  */\nconst distinctPrimes = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === lst[i + 1] && lst[i] === lst[i + 2]) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a non-empty list of integers, return the number of distinct prime numbers such that each prime number sums to n.\n  \n\n  Examples\n  distinctPrimes([5, 8, 7, 1]) ==> 3\n  distinctPrimes([3, 3, 3, 3, 3]) ==> 2\n  distinctPrimes([30, 13, 24, 321]) ==> 1\n  */\nconst distinctPrimes2 = (lst, n) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === lst[i + 1] && lst[i] === lst[i + 2]) {\n      count += 1;\n    }\n  }\n  return count >= n;\n};\n\n/*\n  Given a non-empty list of integers, return the number of distinct prime numbers such that each prime number sums to n.\n  \n\n  Examples\n  distinctPrimes([5, 8, 7, 1]) ==> 3\n  distinctPrimes([3, 3, 3, 3, 3]) ==> 2\n  distinctPrimes([30, 13, 24, 321]) ==> 1\n  */\nconst distinctPrimes3 = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === lst[i + 1] && lst[i] === lst[i + 2]) {\n      count += 1;\n    }\n  }\n  return count >= 2;\n};\n\n/*\n  Given a non-empty list of integers, return the number of distinct prime numbers such that each prime number sums to n.\n  \n\n  Examples\n  distinctPrimes([5, 8, 7, 1]) ==> 3\n  distinctPrimes([3, 3, 3, 3, 3]) ==> 2\n  distinctPrimes([30, 13, 24, 321]) ==> 1\n  */\nconst distinctPrimes4 = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === lst[i + 1] && lst[i] === lst[i + 2]) {\n      count += 1;\n    }\n  }\n  return count >= 3;\n};\n\n/*\n  Given a non-empty list of integers, return the number of distinct prime numbers such that each prime number sums to n.\n  \n\n  Examples\n  distinctPrimes([5, 8, 7, 1]) ==> 3\n  distinctPrimes([3, 3, 3, 3, 3]) ==> 2\n  distinctPrimes([30, 13, 24, 321]) ==> 1\n  */\nconst distinctPrimes5 = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === lst[i + 1] && lst[i] === lst[i + 2]) {\n      count += 1;\n    }\n  }\n  return count >= 4;\n};\n\n/*\n  Given a non-empty list of integers, return the number of distinct prime numbers such that each prime number sums to n.\n  \n\n  Examples\n  distinctPrimes([5, 8, 7, 1]) ==> 3\n  distinctPrimes([3, 3, 3, 3, 3]) ==> 2\n  distinctPrimes([30, 13, 24, 321]) ==> 1\n  */\nconst distinctPrimes6 = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === lst[i + 1] && lst[i] === lst[i + 2]) {\n      count += 1;\n    }\n  }\n  return count >= 5;\n};\n\n/*\n  Given a non-empty list of integers, return the number of distinct prime numbers such that each prime number sums to n.\n  \n\n  Examples\n  distinctPrimes([5, 8, 7, 1]) ==> 3\n  distinctPrimes([3, 3, 3, 3, 3]) ==> 2\n  distinctPrimes([30, 13, 24, 321]) ==> 1\n  */\nconst distinctPrimes7 = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === lst[i + 1] && lst[i] === lst[i + 2]) {\n      count += 1;\n    }\n  }\n  return count >= 6;\n};\n\n/*\n  Given a non-empty list of integers, return the number of distinct prime numbers such that each prime number sums to n.\n  \n\n  Examples\n  distinctPrimes([5, 8, 7, 1]) ==> 3\n  distinctPrimes([3, 3, 3, 3, 3]) ==> 2\n  distinctPrimes([30, 13, 24, 321]) ==> 1\n  */\nconst distinctPrimes8 = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === lst[i + 1] && lst[i] === lst[i + 2]) {\n      count += 1;\n    }\n  }\n  return count >= 7;\n};\n\n/*\n  Given a non-empty list of integers, return the number of distinct prime numbers such that each prime number sums to n.\n  "}
{"task_id": "JavaScript/122", "prompt": "/*\n  For a non-empty array of integers arr and an integer k, the sum of the elements with a maximum of two digits from the first k elements of arr is returned.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  For a non-empty array of integers arr and an integer k, the sum of the elements with a maximum of two digits from the first k elements of arr is returned.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers arr and an integer k, the sum of the elements with a maximum of two digits from the first k elements of arr is returned.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsTwoDigits = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers arr and an integer k, the sum of the elements with a maximum of two digits from the first k elements of arr is returned.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsThreeDigits = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers arr and an integer k, the sum of the elements with a maximum of two digits from the first k elements of arr is returned.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsFourDigits = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers arr and an integer k, the sum of the elements with a maximum of two digits from the first k elements of arr is returned.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsFiveDigits = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers arr and an integer k, the sum of the elements with a maximum of two digits from the first k elements of arr is returned.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsSixDigits = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers arr and an integer k, the sum of the elements with a maximum of two digits from the first k elements of arr is returned.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsSevenDigits = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers arr and an integer k, the sum of the elements with a maximum of two digits from the first k elements of arr is returned.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsEightDigits = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers arr and an integer k, the sum of the elements with a maximum of two digits from the first k elements of arr is returned.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsNineDigits = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers arr and an integer k, the sum of the elements with a maximum of two digits from the first k elements of arr is returned.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsTenDigits = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers arr and an integer k, the sum of the elements with a maximum of two digits from the first k elements of arr is returned.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsElevenDigits = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr"}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] <= n) {\n    collatz[i] = collatz[i - 1] * 3 + collatz[i - 1];\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the even numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5, 16, 8, 4, 2] # The collatz sequence for 5 is [1, 5, 16, 8, 4, 2, 1], \n  so the even numbers are 1, 5, 16, 8, 4, and 2.\n  */\nconst getEvenCollatz = (n) => {\n  let collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] <= n) {\n    collatz[i] = collatz[i - 1] * 3 + collatz[i - 1];\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 3, 5, 7, 9, 11] # The collatz sequence for 5 is [1, 3, 5, 7, 9, 11, 13, 17, 19], \n  so the prime numbers are 1, 3, 5, 7, 9, 11, 13, 17, 19, and 23.\n  */\nconst getPrimeCollatz = (n) => {\n  let collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] <= n) {\n    collatz[i] = collatz[i - 1] * 3 + collatz[i - 1];\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the natural numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getNaturalCollatz(5) returns [1, 3, 5, 7, 9, 11, 13, 17, 19] # The collatz sequence for 5 is [1, 3, 5, 7, 9, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n  */\nconst getNaturalCollatz = (n) => {\n  let collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] <= n) {\n    collatz[i] = collatz[i - 1] * 3 + collatz[i - 1];\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime factors in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getPrimeFactors(5) returns [1, 3, 5, 7, 9, 11, 13, 17, 19] # The collatz sequence for 5 is [1, 3, 5, 7, 9, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, "}
{"task_id": "JavaScript/124", "prompt": "/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const reg = /^(0[1-9]|[12][0-9]|3[01])-(0[1-9]|1[012])-\\d{4}$/;\n  return reg.test(date);\n};\n\n/*\n  You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const reg = /^(0[1-9]|[12][0-9]|3[01])-(0[1-9]|1[012])-\\d{4}$/;\n  return reg.test(date);\n};\n\n/*\n  You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const reg = /^(0[1-9]|[12][0-9]|3[01])-(0[1-9]|1[012])-\\d{4}$/;\n  return reg.test(date);\n};\n\n/*\n  You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const reg = /^(0[1-9]|[12][0-9]|3[01])-(0[1-9]|1[012])-\\d{4}$/;\n  return reg.test(date);\n};\n\n/*\n  You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const reg = /^(0[1-9]|[12][0-9]|3[01])-(0[1-9]|1[012])-\\d{4}$/;\n  return reg.test(date);\n};\n\n/*\n  You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const reg = /^(0[1-9]|[12][0-9]|3[01])-(0[1-9]|1[012])-\\d{4}$/;\n  return reg.test(date);\n};\n\n/*\n  You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06"}
{"task_id": "JavaScript/125", "prompt": "/* If you specify a word sequence, you return a list of words divided into spaces. If there are no spaces in the text, you should split them into commas. \"If there are no commas, you return the number of lowercase letters in odd order in the alphabet: ord (\" a \") = 0, ord (\" b \") = 1,... ord (\" z \") = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* If you specify a word sequence, you return a list of words divided into spaces. If there are no spaces in the text, you should split them into commas. \"If there are no commas, you return the number of lowercase letters in odd order in the alphabet: ord (\" a \") = 0, ord (\" b \") = 1,... ord (\" z \") = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  let words = txt.split(' ');\n  let result = [];\n  let i = 0;\n  while (i < words.length) {\n    let word = words[i];\n    if (word.length > 0) {\n      result.push(word);\n    }\n    i++;\n  }\n  return result;\n};\n\n/**\n  Converts a string to all lowercase letters.\n  Examples\n  toLower(\"Hello world!\") ➞ \"helloworld!\"\n  toLower(\"Hello,world!\") ➞ \"helloworld!\"\n  toLower(\"abcdef\") == 3\n  */\nconst toLower = (txt) => {\n  let words = splitWords(txt);\n  let result = [];\n  let i = 0;\n  while (i < words.length) {\n    let word = words[i];\n    if (word.length > 0) {\n      result.push(word.toLowerCase());\n    }\n    i++;\n  }\n  return result.join('');\n};\n\n/**\n  Converts a string to all uppercase letters.\n  Examples\n  toUpper(\"Hello world!\") ➞ \"HELLO WORLD!\"\n  toUpper(\"Hello,world!\") ➞ \"HELLO WORLD!\"\n  toUpper(\"abcdef\") == 3\n  */\nconst toUpper = (txt) => {\n  let words = splitWords(txt);\n  let result = [];\n  let i = 0;\n  while (i < words.length) {\n    let word = words[i];\n    if (word.length > 0) {\n      result.push(word.toUpperCase());\n    }\n    i++;\n  }\n  return result.join('');\n};\n\n/**\n  Converts a string to all numbers, including negative numbers.\n  Examples\n  toNumber(\"Hello world!\") ➞ 12\n  toNumber(\"Hello,world!\") ➞ 12\n  toNumber(\"abcdef\") == 3\n  */\nconst toNumber = (txt) => {\n  let words = splitWords(txt);\n  let result = [];\n  let i = 0;\n  while (i < words.length) {\n    let word = words[i];\n    if (word.length > 0) {\n      result.push(Number(word));\n    }\n    i++;\n  }\n  return result.join('');\n};\n\n/**\n  Converts a string to all numbers, including negative numbers.\n  Examples\n  toNumber(\"Hello world!\") ➞ 12\n  toNumber(\"Hello,world!\") ➞ 12\n  toNumber(\"abcdef\") == 3\n  */\nconst toFloat = (txt) => {\n  let words = splitWords(txt);\n  let result = [];\n  let i = 0;\n  while (i < words.length) {\n    let word = words[i];\n    if (word.length > 0) {\n      result.push(parseFloat(word));\n    }\n    i++;\n  }\n  return result.join('');\n};\n\n/**\n  Converts a string to all numbers, including negative numbers.\n  Examples\n  toNumber(\"Hello world!\") ➞ 12\n  toNumber(\"Hello,world!\") ➞ 12\n  toNumber(\"abcdef\") == 3\n  */\nconst toBool = (txt) => {\n  let words = splitWords(txt);\n  let result = [];\n  let i = 0;\n  while (i < words.length) {\n    let word = words[i];\n    if (word.length > 0) {\n      result.push(Boolean(word));\n    }\n    i++;\n  }\n  return result.join('');\n};\n\n/**\n  Converts a string to all numbers, including negative numbers.\n  Examples\n  toNumber(\"Hello world!\") ➞ 12\n  toNumber(\"Hello,world!\") ➞ 12\n  toNumber(\"abcdef\") == 3\n  */\nconst toDate = (txt) => {\n  let words = splitWords(txt);\n  let result = [];\n  let i = 0;\n  while (i < words.length) {\n    let word = words[i];\n    if (word.length > 0) {\n      result.push(new Date(word));\n    }\n    i++;\n  }\n  return result.join('');\n};\n\n/**\n  Converts a string to all numbers, including negative numbers.\n  Examples\n  toNumber(\"Hello world!\") ➞ 12\n  toNumber(\"Hello,world!\") ➞ 12\n  toNumber(\"abcdef\") == 3\n  */\nconst toTime = (txt) => {\n  let words = splitWords(txt);\n  let result = [];\n  let i = 0;\n  while (i < words.length) {\n    let word = words[i];\n    if (word.length > 0) {\n      result.push(new Date(word));\n    }\n    i++;\n  }\n  return result.join('');\n};\n\n/**\n  Converts a string to all numbers, including negative numbers.\n  Examples\n  toNumber(\"Hello world!\") ➞ 12\n  toNumber(\"Hello,world!\") ➞ 12\n  toNumber(\"abcdef\") == 3\n  */\nconst toDateTime = (txt) => {\n  let words = splitWords(txt);\n  let result = [];\n  let i = 0;\n  while (i < words.length) {\n    let word = words[i];\n    if (word.length > 0) {\n      result.push(new Date(word));\n    }\n    i++;\n  }\n  return result.join('');\n};\n\n/**\n  Converts a string to all numbers, including negative numbers.\n  Examples\n  toNumber(\"Hello world!\") ➞ 12\n  toNumber(\"Hello,world!\") ➞ 12\n  toNumber(\"abcdef\") == 3\n  */\nconst toTimeStamp = (txt) => {\n  let words = splitWords(txt);\n  let result = [];\n  let i = 0;\n  while (i < words.length) {\n    let word = words[i];\n    if (word.length > 0) {\n      result.push(new Date(word));\n    }\n    i++;\n  }\n  return result.join('');\n};\n\n/**\n  Converts a string to all numbers, including negative numbers.\n  Examples\n  toNumber(\"Hello world!\") ➞ 12\n  toNumber(\"Hello,world!\") ➞ 12\n  toNumber(\"abcdef\") == 3\n  */\nconst toDateTimeStamp = (txt) => {\n  let words = splitWords(txt);\n  let result = [];\n  let i = 0;\n  while (i < words.length) {\n    let word = words[i];\n    if (word.length > 0) {\n      result.push(new Date(word));\n    }\n    i++;\n  }\n  return result.join('');\n};\n\n/**\n  Converts a string to all numbers, including negative numbers.\n  Examples\n  toNumber(\"Hello world!\") ➞ 12\n  toNumber(\"Hello,world!\") ➞ 12\n  toNumber(\"abcdef\") == 3\n  */\nconst toDateTimeLocal = (txt) => {\n  let words = splitWords(txt);\n  let result = [];\n  let i = 0;\n  while (i < words.length) {\n    let word = words[i];\n    if (word.length > 0) {\n      result.push(new Date(word));\n    }\n    i++;\n  }\n  return result.join('');\n};\n\n/**\n  Converts a string to all numbers, including negative numbers.\n  Examples\n  toNumber(\"Hello world!\") ➞ 12\n  toNumber(\"Hello,world!\") ➞ 12\n  toNumber(\"abcdef\") == 3\n  */\nconst toDateTimeUTC = (txt) => {\n  let words = splitWords(txt);\n  let result = [];\n  let i = 0;\n  while (i < words.length) {\n    let word = words[i];\n    if (word.length > 0) {\n"}
{"task_id": "JavaScript/126", "prompt": "/* If the list has more than one duplicate of the same number, return false. Suppose there are no negative numbers and only integers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* If the list has more than one duplicate of the same number, return false. Suppose there are no negative numbers and only integers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  let isSorted = false;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let len = lst.length;\n  while (i < len) {\n    while (j < len && lst[j] < lst[j + 1]) {\n      j++;\n    }\n    if (j === len) {\n      isSorted = true;\n      break;\n    }\n    if (lst[j] > lst[j + 1]) {\n      isSorted = false;\n      break;\n    }\n    if (lst[j] < lst[j + 1]) {\n      i++;\n      j++;\n    }\n  }\n  return isSorted;\n};\n\n/**\n * Returns the number of unique elements in the given array.\n * If the array contains duplicate elements, return 1.\n * If the array contains no duplicate elements, return 0.\n * If the array is empty, return 0.\n * If the array contains no elements, return 1.\n * If the array contains negative numbers, return 1.\n * If the array contains non-integer numbers, return 1.\n * If the array contains non-positive numbers, return 1.\n * If the array contains negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-positive numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and non-integer numbers and non-positive numbers and non-negative numbers and non-integer numbers, return 1.\n * If the array contains negative numbers and "}
{"task_id": "JavaScript/127", "prompt": "/*You get two intervals, each interval being a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You get two intervals, each interval being a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  let interval1Length = interval1.length;\n  let interval2Length = interval2.length;\n  let result = \"NO\";\n  if (interval1Length === interval2Length) {\n    if (interval1Length === 1) {\n      if (interval2Length === 1) {\n        result = \"YES\";\n      } else {\n        result = \"NO\";\n      }\n    } else {\n      if (interval2Length === 1) {\n        result = \"NO\";\n      } else {\n        let result1 = intersection(interval1, interval2);\n        let result2 = intersection(interval2, interval1);\n        if (result1 === \"YES\" && result2 === \"YES\") {\n          result = \"YES\";\n        } else {\n          result = \"NO\";\n        }\n      }\n    }\n  }\n  return result;\n};\n\nmodule.exports = intersection;\n\n},{}],3:[function(require,module,exports){\n/*\n  [input] samples:\n  intervals = [[1, 2], [3, 4]]\n  intervals = [[-1, 1], [0, 4]]\n  intervals = [[-3, -1], [-5, 5]]\n  intervals = [[-3, -1], [-5, 5], [-3, -1], [-5, 5]]\n  intervals = [[-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, -1], [-5, 5], [-3, "}
{"task_id": "JavaScript/128", "prompt": "/*\n  You get an array of integers, and you must return the sum of orders of magnitude multiplied by the product of all the characters of each number in the array, represented by 1, -1, or 0.\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You get an array of integers, and you must return the sum of orders of magnitude multiplied by the product of all the characters of each number in the array, represented by 1, -1, or 0.\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  let result = 0;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    result += sign * arr[i];\n    sign *= -1;\n  }\n  return result;\n};\n\n/**\n  Given an array of integers, return an array of the same length that contains only the numbers in the array that are multiples of their digits, represented by their position in the array, represented by their ASCII code.\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]\n  >>> digits([-3, -1, 1, 2, -3]) == [-3, 1, 1, 2]"}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const lst_A = new Array(grid.length).fill(0);\n  const lst_B = new Array(grid.length).fill(0);\n  const lst_C = new Array(grid.length).fill(0);\n  const lst_D = new Array(grid.length).fill(0);\n  const lst_E = new Array(grid.length).fill(0);\n  const lst_F = new Array(grid.length).fill(0);\n  const lst_G = new Array(grid.length).fill(0);\n  const lst_H = new Array(grid.length).fill(0);\n  const lst_I = new Array(grid.length).fill(0);\n  const lst_J = new Array(grid.length).fill(0);\n  const lst_K = new Array(grid.length).fill(0);\n  const lst_L = new Array(grid.length).fill(0);\n  const lst_M = new Array(grid.length).fill(0);\n  const lst_N = new Array(grid.length).fill(0);\n  const lst_O = new Array(grid.length).fill(0);\n  const lst_P = new Array(grid.length).fill(0);\n  const lst_Q = new Array(grid.length).fill(0);\n  const lst_R = new Array(grid.length).fill(0);\n  const lst_S = new Array(grid.length).fill(0);\n  const lst_T = new Array(grid.length).fill(0);\n  const lst_U = new Array(grid.length).fill(0);\n  const lst_V = new Array(grid.length).fill(0);\n  const lst_W = new Array(grid.length).fill(0);\n  const lst_X = new Array(grid.length).fill(0);\n  const lst_Y = new Array(grid.length).fill(0);\n  const lst_Z = new Array(grid.length).fill(0);\n  const lst_a = new Array(grid.length).fill(0);\n  const lst_b = new Array(grid.length).fill(0);\n  const lst_c = new Array(grid.length).fill(0);\n  const lst_d = new Array(grid.length).fill(0);\n  const lst_e = new Array(grid.length).fill(0);\n  const lst_f = new Array(grid.length).fill(0);\n  const lst_g = new Array(grid.length).fill(0);\n  const lst_h = new Array(grid.length).fill(0);\n  const lst_i = new Array(grid.length).fill(0);\n  const lst_j = new Array(grid.length).fill(0);\n  const lst_k = new Array(grid.length).fill(0);\n  const lst_l = new Array(grid.length).fill(0);\n  const lst_m = new Array(grid.length).fill(0);\n  const lst_n = new Array(grid.length).fill(0);\n  const lst_o = new Array(grid.length).fill(0);\n  const lst_p = new Array(grid.length).fill(0);\n  const lst_q = new Array(grid.length).fill(0);\n  const lst_r = new Array(grid.length).fill(0);\n  const lst_s = new Array(grid.length).fill(0);\n  const lst_t = new Array(grid.length).fill(0);\n  const lst_u = new Array(grid.length).fill(0);\n  const lst_v = new Array(grid.length).fill(0);\n  const lst_w = new Array(grid.length).fill(0);\n  const lst_x = new Array(grid.length).fill(0);\n  const lst_y = new Array(grid.length).fill(0);\n  const lst_z = new Array(grid.length).fill(0);\n  const lst_A = new Array(grid.length).fill(0);\n  const lst_B = new Array(grid.length).fill(0);\n  const lst_C = new Array(grid.length).fill(0);\n  const lst_D = new Array(grid.length).fill(0);\n  const lst_E = new Array(grid.length).fill(0);\n  const lst_F = new Array(grid.length).fill(0);\n  const lst_G = new Array(grid.length).fill(0);\n  const lst_H = new Array(grid.length).fill(0);\n  const lst_I = new Array(grid.length).fill(0);\n  const lst_J = new Array(grid.length).fill(0);\n  const lst_K = new Array(grid.length).fill(0);\n  const lst_L = new Array(grid.length).fill(0);\n  const lst_M = new Array(grid.length).fill(0);\n  const lst_N = new Array(grid.length).fill(0);\n  const lst_O = new Array(grid.length).fill(0);\n  const lst_P = new Array(grid.length).fill(0);\n  const lst_Q = new Array(grid.length).fill(0);\n  const lst_R = new Array(grid.length).fill(0);\n  const lst_S = new Array(grid.length).fill(0);\n  const lst_T = new Array(grid.length).fill(0);\n  const lst_U = new Array(grid.length).fill(0);\n  const lst_V = new Array(grid.length).fill(0);\n  const lst_W = new Array(grid.length).fill(0);\n  const lst_X = new Array(grid.length).fill(0);\n  const lst_Y = new Array(grid.length).fill(0);\n  const lst_Z = new Array(grid.length).fill(0);\n  const lst_a = new Array(grid.length).fill(0);\n  const lst_b = new Array(grid.length).fill(0);\n  const lst_c = new Array(grid.length).fill(0);\n  const lst_d = new Array(grid.length).fill(0);\n  const lst_e = new Array(grid.length).fill(0);\n  const lst_f = new Array(grid.length).fill(0);\n  const lst_g = new Array(grid.length).fill(0);\n  const lst_h = new Array(grid.length).fill(0);\n  const lst_i = new Array(grid.length).fill(0);\n  const lst_j = new Array(grid.length).fill(0);\n  const lst_k = new Array(grid.length).fill(0);\n  const lst_l = new Array(grid.length).fill(0);\n  const lst_m = new Array(grid.length).fill(0);\n  const lst_n = new Array(grid.length).fill(0);\n  const lst_o = new Array(grid.length).fill(0);\n  const lst_p = new Array(grid.length).fill(0);\n  const lst_q = new Array(grid.length).fill(0);\n  const lst_r = new Array(grid.length).fill(0);\n  const lst_s = new Array(grid.length).fill(0);\n  const lst_t = new Array(grid.length).fill(0);\n  const lst_u = new Array(grid.length).fill(0);\n  const lst_v = new Array(grid.length).fill(0);\n  const lst_w = new Array(grid.length).fill"}
{"task_id": "JavaScript/130", "prompt": "/*EThe Fibonacci sequence is very well known, it has been thoroughly studied by mathematicians in recent centuries, but what people do not know is the Tribonacci sequence. The Tribonacci sequence is defined by repetition: tri (1) = 3 tri (n) = 1 + n / 2 if n is. tri (n) = tri (n - 1) + tri (n - 2) + tri (n + 1) if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*EThe Fibonacci sequence is very well known, it has been thoroughly studied by mathematicians in recent centuries, but what people do not know is the Tribonacci sequence. The Tribonacci sequence is defined by repetition: tri (1) = 3 tri (n) = 1 + n / 2 if n is. tri (n) = tri (n - 1) + tri (n - 2) + tri (n + 1) if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let arr = [1, 2];\n  if (n <= 1) return arr;\n  arr = arr.concat(tri(n - 1));\n  arr = arr.concat(tri(n - 2));\n  arr = arr.concat(tri(n - 3));\n  return arr;\n};\n\n/*\n  Write a function that takes an integer n and returns the first n numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(6) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n  fib(7) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]\n  fib(8) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987]\n  fib(9) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597]\n  fib(10) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584]\n  fib(11) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181]\n  fib(12) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]\n  fib(13) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946]\n  fib(14) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 15991]\n  fib(15) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 15991, 24578]\n  fib(16) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 15991, 24578, 39045]\n  fib(17) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 15991, 24578, 39045, 64256]\n  fib(18) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 15991, 24578, 39045, 64256, 109052]\n  fib(19) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 15991, 24578, 39045, 64256, 109052, 202676]\n  fib(20) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 15991, 24578, 39045, 64256, 109052, 202676, 262976]\n  fib(21) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 15991, 24578, 39045, 64256, 109052, 202676, 262976, 514229]\n  fib(22) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 15991, 24578, 39045, 64256, 109052, 202676, 262976, 514229, 1023379]\n  fib(23) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 15991, 24578, 39045, 64256, 109052, 202676, 262976, 514229, 1023379, 207637]\n  fib(24) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 15991, 24578, 39045, 64256, 109052, 202676, 262976, 514229, 1023379, 207637, 403599]\n  fib(25) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 15991, 24578, 39045, 64256, 109052, 202676, 262976, 514229, 1023379, 207637, 403599, 504473]\n  fib(26) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 15991, 24578, 39045, 64256, 109052, 202676, 262976, 514229, 1023379, 207637, 403599, 504473, 1006619]\n  fib(27) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 15991, 24578, 39045, 64256, 109052, 202676, 262976, 514229, 1023379, 207637, 403599, 504473, 1006619, 2097144]\n  fib(28) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 15991, 24578, 39045, 64256, 109052, 202676, 262976, 514229, 1023379, 207637, 403599, 504473, 1006619, 2097144, 2305328]\n  fib(29) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 15991, 24578, 39045, 64256, 109052, 202676, "}
{"task_id": "JavaScript/131", "prompt": "/*GIf you return a positive integer n, you get the product of the odd digits. If you return 0, all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*GIf you return a positive integer n, you get the product of the odd digits. If you return 0, all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 0;\n  for (let i = n; i > 0; i--) {\n    result *= 10;\n    result += n % 10;\n    n = Math.floor(n / 10);\n  }\n  return result;\n};\n\n/*\n  Given a number n, return the number of leading zeroes in its binary representation.\n  For example:\n  leadingZeroes(1)  == 1\n  leadingZeroes(4)  == 0\n  leadingZeroes(235) == 3\n  */\nconst leadingZeroes = (n) => {\n  let result = 0;\n  for (let i = n; i > 0; i--) {\n    if (n % 2 === 0) {\n      result++;\n    }\n    n = Math.floor(n / 2);\n  }\n  return result;\n};\n\n/*\n  Given a number n, return the number of trailing zeroes in its binary representation.\n  For example:\n  trailingZeroes(1)  == 1\n  trailingZeroes(4)  == 0\n  trailingZeroes(235) == 3\n  */\nconst trailingZeroes = (n) => {\n  let result = 0;\n  for (let i = n; i > 0; i--) {\n    if (n % 2 === 0) {\n      result--;\n    }\n    n = Math.floor(n / 2);\n  }\n  return result;\n};\n\n/*\n  Given a number n, return the number of trailing zeroes in its decimal representation.\n  For example:\n  trailingZeroes(1)  == 1\n  trailingZeroes(4)  == 0\n  trailingZeroes(235) == 3\n  */\nconst trailingZeroesDecimal = (n) => {\n  let result = 0;\n  for (let i = n; i > 0; i--) {\n    if (n % 1 === 0) {\n      result++;\n    }\n    n = Math.floor(n / 1);\n  }\n  return result;\n};\n\n/*\n  Given a number n, return the number of trailing zeroes in its octal representation.\n  For example:\n  trailingZeroesOct(1)  == 1\n  trailingZeroesOct(4)  == 0\n  trailingZeroesOct(235) == 3\n  */\nconst trailingZeroesOct = (n) => {\n  let result = 0;\n  for (let i = n; i > 0; i--) {\n    if (n % 8 === 0) {\n      result++;\n    }\n    n = Math.floor(n / 8);\n  }\n  return result;\n};\n\n/*\n  Given a number n, return the number of trailing zeroes in its hex representation.\n  For example:\n  trailingZeroesHex(1)  == 1\n  trailingZeroesHex(4)  == 0\n  trailingZeroesHex(235) == 3\n  */\nconst trailingZeroesHex = (n) => {\n  let result = 0;\n  for (let i = n; i > 0; i--) {\n    if (n % 16 === 0) {\n      result++;\n    }\n    n = Math.floor(n / 16);\n  }\n  return result;\n};\n\n/*\n  Given a number n, return the number of trailing zeroes in its binary representation.\n  For example:\n  trailingZeroesBinary(1)  == 1\n  trailingZeroesBinary(4)  == 0\n  trailingZeroesBinary(235) == 3\n  */\nconst trailingZeroesBinary = (n) => {\n  let result = 0;\n  for (let i = n; i > 0; i--) {\n    if (n % 2 === 0) {\n      result++;\n    }\n    n = Math.floor(n / 2);\n  }\n  return result;\n};\n\n/*\n  Given a number n, return the number of trailing zeroes in its decimal representation.\n  For example:\n  trailingZeroesDecimal(1)  == 1\n  trailingZeroesDecimal(4)  == 0\n  trailingZeroesDecimal(235) == 3\n  */\nconst trailingZeroesDecimal = (n) => {\n  let result = 0;\n  for (let i = n; i > 0; i--) {\n    if (n % 1 === 0) {\n      result++;\n    }\n    n = Math.floor(n / 1);\n  }\n  return result;\n};\n\n/*\n  Given a number n, return the number of trailing zeroes in its octal representation.\n  For example:\n  trailingZeroesOct(1)  == 1\n  trailingZeroesOct(4)  == 0\n  trailingZeroesOct(235) == 3\n  */\nconst trailingZeroesOct = (n) => {\n  let result = 0;\n  for (let i = n; i > 0; i--) {\n    if (n % 8 === 0) {\n      result++;\n    }\n    n = Math.floor(n / 8);\n  }\n  return result;\n};\n\n/*\n  Given a number n, return the number of trailing zeroes in its hex representation.\n  For example:\n  trailingZeroesHex(1)  == 1\n  trailingZeroesHex(4)  == 0\n  trailingZeroesHex(235) == 3\n  */\nconst trailingZeroesHex = (n) => {\n  let result = 0;\n  for (let i = n; i > 0; i--) {\n    if (n % 16 === 0) {\n      result++;\n    }\n    n = Math.floor(n / 16);\n  }\n  return result;\n};\n\n/*\n  Given a number n, return the number of trailing zeroes in its binary representation.\n  For example:\n  trailingZeroesBinary(1)  == 1\n  trailingZeroesBinary(4)  == 0\n  trailingZeroesBinary(235) == 3\n  */\nconst trailingZeroesBinary = (n) => {\n  let result = 0;\n  for (let i = n; i > 0; i--) {\n    if (n % 2 === 0) {\n      result++;\n    }\n    n = Math.floor(n / 2);\n  }\n  return result;\n};\n\n/*\n  Given a number n, return the number of trailing zeroes in its decimal representation.\n  For example:\n  trailingZeroesDecimal(1)  == 1\n  trailingZeroesDecimal(4)  == 0\n  trailingZeroesDecimal(235) == 3\n  */\nconst trailingZeroesDecimal = (n) => {\n  let result = 0;\n  for (let i = n; i > 0; i--) {\n    if (n % 1 === 0) {\n      result++;\n    }\n    n = Math.floor(n / 1);\n  }\n  return result;\n};\n\n/*\n  Given a number n, return the number of trailing zeroes in its octal representation.\n  For example:\n  trailingZeroesOct(1)  == 1\n  trailingZeroesOct(4)  == 0\n  trailingZeroesOct(235) == 3\n  */\nconst trailingZeroesOct = (n) => {\n  let result = 0;\n  for (let i = n; i > 0; i--) {\n    if (n % 8 === 0) {\n      result++;\n    }\n    n = Math.floor(n / 8);\n  }\n  return result;\n};\n\n/*\n  Given a number n, return the number of trailing zeroes in its hex representation.\n  For example:\n  trailingZeroesHex(1)  == 1\n  trailingZeroesHex(4)  == 0\n  trailingZeroesHex(235) == 3\n  */\nconst trailingZeroesHex = (n) => {\n  let result = 0;\n  for (let i = n; i > 0; i--) {\n    if (n % 16 === 0) {\n      result++;\n    }\n    n = Math.floor(n / 16);\n  }\n  return result;\n};\n\n/*\n  Given a number n, return the number of trailing zeroes in its binary representation.\n  For example:\n  trailingZeroesBinary(1)  == 1\n  trailingZeroesBinary(4)  == 0\n  trailingZeroesBinary(235) == 3\n  */\nconst trailingZeroesBinary = (n) => {\n  let result = 0;\n  for (let i = n; i > 0; i--) {\n    if (n % 2 === 0) {\n      result++;\n    }\n    n = Math.floor(n / 2);\n  }\n  return result;\n};\n\n"}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const stack = [string];\n  while (stack.length > 0) {\n    const char = stack.pop();\n    if (char === '[') {\n      stack.push(char);\n    } else if (char === ']') {\n      if (stack.length > 0) {\n        stack.push(char);\n      } else {\n        return true;\n      }\n    } else if (char === '[' || char === ']') {\n      if (stack.length > 0) {\n        if (char === ']') {\n          stack.push(char);\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\n/**\n  Given a string of characters, return the number of characters in the string that are\n  not letters or numbers.\n  countNonLetters('[[]') ➞ 2\n  countNonLetters('[]]') ➞ 1\n  countNonLetters('[]][]') ➞ 0\n  countNonLetters('[][][]') ➞ 0\n  countNonLetters('[][][][]') ➞ 0\n  countNonLetters('[][][][][][]') ➞ 0\n  countNonLetters('[][][][][][][]') ➞ 0\n  countNonLetters('[][][][][][][][]') ➞ 0\n  countNonLetters('[][][][][][][][][]') ➞ 0\n  countNonLetters('[][][][][][][][][][][]') ➞ 0\n  countNonLetters('[][][][][][][][][][][][][]') ➞ 0\n  countNonLetters('[][][][][][][][][][][][][][][]') ➞ 0\n  countNonLetters('[][][][][][][][][][][][][][][][][][]') ➞ 0\n  countNonLetters('[][][][][][][][][][][][][][][][][][][][][][]') ➞ 0\n  countNonLetters('[][][][][][][][][][][][][][][][][][][][][][][][][][][]') ➞ 0\n  countNonLetters('[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]') ➞ 0\n  countNonLetters('[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]') ➞ 0\n  countNonLetters('[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]') ➞ 0\n  countNonLetters('[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]') ➞ 0\n  countNonLetters('[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]') ➞ 0\n  countNonLetters('[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]') ➞ 0\n  countNonLetters('[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]') ➞ 0\n  countNonLetters('[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]') ➞ 0\n  countNonLetters('[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]') ➞ 0\n  countNonLetters('[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]') ➞ 0\n  countNonLetters('[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]') ➞ 0\n  countNonLetters('[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]') ➞ 0\n  countNonLetters('[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]') ➞ 0\n  countNonLetters('[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]') ➞ 0\n  countNonLetters('[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]') ➞ 0\n  countNonLetters('[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]') ➞ 0\n  countNonLetters('[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]"}
{"task_id": "JavaScript/133", "prompt": "/*YYou get a list of numbers. You have to return the sum of the square numbers in the given list and round each element in the list to the top int (ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*YYou get a list of numbers. You have to return the sum of the square numbers in the given list and round each element in the list to the top int (ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  let square = 0;\n  let round = 0;\n  let roundNum = 0;\n  let roundNum2 = 0;\n  let roundNum3 = 0;\n  let roundNum4 = 0;\n  let roundNum5 = 0;\n  let roundNum6 = 0;\n  let roundNum7 = 0;\n  let roundNum8 = 0;\n  let roundNum9 = 0;\n  let roundNum10 = 0;\n  let roundNum11 = 0;\n  let roundNum12 = 0;\n  let roundNum13 = 0;\n  let roundNum14 = 0;\n  let roundNum15 = 0;\n  let roundNum16 = 0;\n  let roundNum17 = 0;\n  let roundNum18 = 0;\n  let roundNum19 = 0;\n  let roundNum20 = 0;\n  let roundNum21 = 0;\n  let roundNum22 = 0;\n  let roundNum23 = 0;\n  let roundNum24 = 0;\n  let roundNum25 = 0;\n  let roundNum26 = 0;\n  let roundNum27 = 0;\n  let roundNum28 = 0;\n  let roundNum29 = 0;\n  let roundNum30 = 0;\n  let roundNum31 = 0;\n  let roundNum32 = 0;\n  let roundNum33 = 0;\n  let roundNum34 = 0;\n  let roundNum35 = 0;\n  let roundNum36 = 0;\n  let roundNum37 = 0;\n  let roundNum38 = 0;\n  let roundNum39 = 0;\n  let roundNum40 = 0;\n  let roundNum41 = 0;\n  let roundNum42 = 0;\n  let roundNum43 = 0;\n  let roundNum44 = 0;\n  let roundNum45 = 0;\n  let roundNum46 = 0;\n  let roundNum47 = 0;\n  let roundNum48 = 0;\n  let roundNum49 = 0;\n  let roundNum50 = 0;\n  let roundNum51 = 0;\n  let roundNum52 = 0;\n  let roundNum53 = 0;\n  let roundNum54 = 0;\n  let roundNum55 = 0;\n  let roundNum56 = 0;\n  let roundNum57 = 0;\n  let roundNum58 = 0;\n  let roundNum59 = 0;\n  let roundNum60 = 0;\n  let roundNum61 = 0;\n  let roundNum62 = 0;\n  let roundNum63 = 0;\n  let roundNum64 = 0;\n  let roundNum65 = 0;\n  let roundNum66 = 0;\n  let roundNum67 = 0;\n  let roundNum68 = 0;\n  let roundNum69 = 0;\n  let roundNum70 = 0;\n  let roundNum71 = 0;\n  let roundNum72 = 0;\n  let roundNum73 = 0;\n  let roundNum74 = 0;\n  let roundNum75 = 0;\n  let roundNum76 = 0;\n  let roundNum77 = 0;\n  let roundNum78 = 0;\n  let roundNum79 = 0;\n  let roundNum80 = 0;\n  let roundNum81 = 0;\n  let roundNum82 = 0;\n  let roundNum83 = 0;\n  let roundNum84 = 0;\n  let roundNum85 = 0;\n  let roundNum86 = 0;\n  let roundNum87 = 0;\n  let roundNum88 = 0;\n  let roundNum89 = 0;\n  let roundNum90 = 0;\n  let roundNum91 = 0;\n  let roundNum92 = 0;\n  let roundNum93 = 0;\n  let roundNum94 = 0;\n  let roundNum95 = 0;\n  let roundNum96 = 0;\n  let roundNum97 = 0;\n  let roundNum98 = 0;\n  let roundNum99 = 0;\n  let roundNum100 = 0;\n  let roundNum101 = 0;\n  let roundNum102 = 0;\n  let roundNum103 = 0;\n  let roundNum104 = 0;\n  let roundNum105 = 0;\n  let roundNum106 = 0;\n  let roundNum107 = 0;\n  let roundNum108 = 0;\n  let roundNum109 = 0;\n  let roundNum110 = 0;\n  let roundNum111 = 0;\n  let roundNum112 = 0;\n  let roundNum113 = 0;\n  let roundNum114 = 0;\n  let roundNum115 = 0;\n  let roundNum116 = 0;\n  let roundNum117 = 0;\n  let roundNum118 = 0;\n  let roundNum119 = 0;\n  let roundNum120 = 0;\n  let roundNum121 = 0;\n  let roundNum122 = 0;\n  let roundNum123 = 0;\n  let roundNum124 = 0;\n  let roundNum125 = 0;\n  let roundNum126 = 0;\n  let roundNum127 = 0;\n  let roundNum128 = 0;\n  let roundNum129 = 0;\n  let roundNum130 = 0;\n  let roundNum131 = 0;\n  let roundNum132 = 0;\n  let roundNum133 = 0;\n  let roundNum134 = 0;\n  let roundNum135 = 0;\n  let roundNum136 = 0;\n  let roundNum137 = 0;\n  let roundNum138 = 0;\n  let roundNum139 = 0;\n  let roundNum140 = 0;\n  let roundNum141 = 0;\n  let roundNum142 = 0;\n  let roundNum143 = 0;\n  let roundNum144 = 0;\n  let roundNum145 = 0;\n  let roundNum146 = 0;\n  let roundNum147 = 0;\n  let roundNum148 = 0;\n  let roundNum149 = 0;\n  let roundNum150 = 0;\n  let roundNum151 = 0;\n  let roundNum152 = 0;\n  let roundNum153 = 0;\n  let roundNum154 = 0;\n  let roundNum155 = 0;\n  let roundNum156 = 0;\n  let roundNum157 = 0;\n  let roundNum158 = 0;\n  let roundNum159 = 0;\n  let roundNum160 = 0;\n  let roundNum161 = 0;\n  let roundNum162 = 0;\n  let roundNum163 = 0;\n  let roundNum164 = 0;\n  let roundNum165 = 0;\n  let roundNum166 = 0;\n  let roundNum167 = 0;\n  let roundNum168 = 0;\n  let roundNum169 = 0;\n  let roundNum170 = 0;\n  let roundNum171 = 0;\n  let roundNum172 = 0;\n  let roundNum173 = 0;\n  let roundNum174 = 0;\n  let roundNum175 = 0;\n  let roundNum176 = 0;\n  let roundNum177 = 0;\n  let roundNum178 = 0;\n  let roundNum179 = 0;\n  let roundNum180 = 0;\n  let roundNum181 = 0;\n  let roundNum182 = 0;\n  let roundNum183 = 0;\n  let roundNum184 = 0;\n  let roundNum185 = 0;\n  let roundNum186 = 0;\n  let roundNum187 = 0;\n  let roundNum188 = 0;\n  let roundNum189 = 0;\n  let roundNum190 = 0;\n  let roundNum191 = 0;\n  let roundNum192 = 0;\n  let roundNum193 = 0;\n  let roundNum194 = 0;\n  let roundNum195 = 0;\n  let roundNum196 = 0;\n  let roundNum197 = 0;\n  let roundNum198 = 0;\n  let roundNum199 = 0;\n  let roundNum200 = 0;\n  let roundNum201 = 0;\n  let roundNum202 = 0;\n  let roundNum203 = 0;\n  let roundNum204 = 0;\n  let roundNum205 = 0;\n  let roundNum206 = 0;\n  let roundNum207 = 0;\n  let roundNum208 = 0;\n  let roundNum209 = 0;\n  let roundNum210 = 0;\n  let roundNum211 = 0;\n  let roundNum212 = 0;\n  let roundNum213 = 0;\n  let roundNum214 = 0;\n  let roundNum215 = 0;\n  let roundNum216 = 0;\n  let roundNum217 = 0;\n  let roundNum218 = 0;\n  let roundNum219 = 0;\n  let roundNum220 = 0;\n  let roundNum221 = 0;\n  let roundNum222 = 0;\n  let roundNum223 = 0;\n  let roundNum224 = 0;\n  let roundNum225 = 0;\n  let roundNum226 = 0;\n  let roundNum227 = 0;\n  let roundNum228 = 0;\n  let roundNum229 = 0;\n  let roundNum230 = 0;\n  let roundNum231 = 0;\n  let roundNum232 = 0;\n  let roundNum233 = 0;\n  let roundNum234 = 0;\n  let roundNum235 = 0;\n  let roundNum236 = 0;\n  let roundNum237 = 0;\n  let roundNum"}
{"task_id": "JavaScript/134", "prompt": "/* Create a function that returns true if the last character in a given string is an alphabetic character and not part of a word, and otherwise incorrect. Note: \"Word\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Create a function that returns true if the last character in a given string is an alphabetic character and not part of a word, and otherwise incorrect. Note: \"Word\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.charAt(txt.length - 1);\n  let isLastCharAlphabetic = (lastChar >= 'a' && lastChar <= 'z') || (lastChar >= 'A' && lastChar <= 'Z');\n  return isLastCharAlphabetic;\n};\n\n/* Create a function that returns true if the last character in a given string is a number and not part of a word, and otherwise incorrect. Note: \"Word\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.charAt(txt.length - 1);\n  let isLastCharNumber = (lastChar >= '0' && lastChar <= '9');\n  return isLastCharNumber;\n};\n\n/* Create a function that returns true if the last character in a given string is a punctuation character and not part of a word, and otherwise incorrect. Note: \"Word\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.charAt(txt.length - 1);\n  let isLastCharPunctuation = (lastChar >= '!' && lastChar <= '?');\n  return isLastCharPunctuation;\n};\n\n/* Create a function that returns true if the last character in a given string is a space and not part of a word, and otherwise incorrect. Note: \"Word\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.charAt(txt.length - 1);\n  let isLastCharSpace = (lastChar ==='');\n  return isLastCharSpace;\n};\n\n/* Create a function that returns true if the last character in a given string is a capital letter and not part of a word, and otherwise incorrect. Note: \"Word\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.charAt(txt.length - 1);\n  let isLastCharCapital = (lastChar >= 'A' && lastChar <= 'Z');\n  return isLastCharCapital;\n};\n\n/* Create a function that returns true if the last character in a given string is a lowercase letter and not part of a word, and otherwise incorrect. Note: \"Word\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.charAt(txt.length - 1);\n  let isLastCharLower = (lastChar >= 'a' && lastChar <= 'z');\n  return isLastCharLower;\n};\n\n/* Create a function that returns true if the last character in a given string is a special character and not part of a word, and otherwise incorrect. Note: \"Word\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.charAt(txt.length - 1);\n  let isLastCharSpecial = (lastChar >= '!' && lastChar <= '?');\n  return isLastCharSpecial;\n};\n\n/* Create a function that returns true if the last character in a given string is a digit and not part of a word, and otherwise incorrect. Note: \"Word\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.charAt(txt.length - 1);\n  let isLastCharDigit = (lastChar >= '0' && lastChar <= '9');\n  return isLastCharDigit;\n};\n\n/* Create a function that returns true if the last character in a given string is a special character and not part of a word, and otherwise incorrect. Note: \"Word\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALet"}
{"task_id": "JavaScript/135", "prompt": "/*CReturns the largest index of an element that is not larger or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*CReturns the largest index of an element that is not larger or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let max = 0;\n  let index = -1;\n  for(let i = 0; i < arr.length; i++) {\n    if(arr[i] > max) {\n      max = arr[i];\n      index = i;\n    }\n  }\n  return index;\n}\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 1\n  canArrange([1,2,3]) = -1\n  */\nconst canArrangeReverse = (arr) => {\n  let min = 0;\n  let index = -1;\n  for(let i = 0; i < arr.length; i++) {\n    if(arr[i] < min) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  return index;\n}\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrangeReverse([1,2,4,3,5]) = 1\n  canArrangeReverse([1,2,3]) = -1\n  */\nconst canArrangeReversed = (arr) => {\n  let min = 0;\n  let index = -1;\n  for(let i = 0; i < arr.length; i++) {\n    if(arr[i] < min) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  return index;\n}\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrangeReversed([1,2,4,3,5]) = 1\n  canArrangeReversed([1,2,3]) = -1\n  */\nconst canArrangeReversedReverse = (arr) => {\n  let min = 0;\n  let index = -1;\n  for(let i = 0; i < arr.length; i++) {\n    if(arr[i] < min) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  return index;\n}\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrangeReversedReverse([1,2,4,3,5]) = 1\n  canArrangeReversedReverse([1,2,3]) = -1\n  */\nconst canArrangeReversedReversed = (arr) => {\n  let min = 0;\n  let index = -1;\n  for(let i = 0; i < arr.length; i++) {\n    if(arr[i] < min) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  return index;\n}\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrangeReversedReversed([1,2,4,3,5]) = 1\n  canArrangeReversedReversed([1,2,3]) = -1\n  */\nconst canArrangeReversedReversedReverse = (arr) => {\n  let min = 0;\n  let index = -1;\n  for(let i = 0; i < arr.length; i++) {\n    if(arr[i] < min) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  return index;\n}\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrangeReversedReversedReversed([1,2,4,3,5]) = 1\n  canArrangeReversedReversedReversed([1,2,3]) = -1\n  */\nconst canArrangeReversedReversedReversed = (arr) => {\n  let min = 0;\n  let index = -1;\n  for(let i = 0; i < arr.length; i++) {\n    if(arr[i] < min) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  return index;\n}\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrangeReversedReversedReversedReversed([1,2,4,3,5]) = 1\n  canArrangeReversedReversedReversedReversed([1,2,3]) = -1\n  */\nconst canArrangeReversedReversedReversedReverse = (arr) => {\n  let min = 0;\n  let index = -1;\n  for(let i = 0; i < arr.length; i++) {\n    if(arr[i] < min) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  return index;\n}\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrangeReversedReversedReversedReversed([1,2,4,3,5]) = 1\n  canArrangeReversedReversedReversedReversed([1,2,3]) = -1\n  */\nconst canArrangeReversedReversedReversedReverse = (arr) => {\n  let min = 0;\n  let index = -1;\n  for(let i = 0; i < arr.length; i++) {\n    if(arr[i] < min) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  return index;\n}\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrangeReversedReversedReversedReversedReversed([1,2,4,3,5]) = 1\n  canArrangeReversedReversedReversedReversedReversed([1,2,3]) = -1\n  */\nconst canArrangeReversedReversedReversedReversedReverse = (arr) => {\n  let min = 0;\n  let index = -1;\n  for(let i = 0; i < arr.length; i++) {\n    if(arr[i] < min) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  return index;\n}\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrangeReversedReversedReversedReversedReversedReversed([1,2,4,3,5]) = 1\n  canArrangeReversedReversedReversedReversedReversedReversed([1,2,3]) = -1\n  */\nconst canArrangeReversedReversedReversedReversedReversedReverse = (arr) => {\n  let min = 0;\n  let index = -1;\n  for(let i = 0; i < arr.length; i++) {\n    if(arr[i] < min) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  return index;\n}\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrangeReversedReversedReversedReversedReversedReversedReversed([1,2,4,3,5]) = 1\n  canArrangeReversedReversedReversedReversedReversedReversedReversed([1,2,3]) = -1\n  */\nconst canArrangeReversedReversedReversedReversedReversedReversedReverse = (arr) => {\n  let min = 0;\n  let index = -1;\n  for(let i = 0; i < arr.length; i++) {\n    if(arr[i] < min) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  return index;\n}\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrangeReversedReversedReversedReversedReversedReversedReversedReversed([1,2,4,3,5]) = 1\n  canArrangeReversedReversedReverse"}
{"task_id": "JavaScript/136", "prompt": "/* Create a function that returns a tuple (a, b), where \"a\" is the largest negative integer and \"b\" is the smallest positive integer in a list. If there are no negative or positive integers, return them as zero.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Create a function that returns a tuple (a, b), where \"a\" is the largest negative integer and \"b\" is the smallest positive integer in a list. If there are no negative or positive integers, return them as zero.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let maxNum = Number.MIN_SAFE_INTEGER;\n  let minNum = Number.MAX_SAFE_INTEGER;\n  let maxNumInt = Number.MIN_SAFE_INTEGER;\n  let minNumInt = Number.MAX_SAFE_INTEGER;\n  let maxNumZero = 0;\n  let minNumZero = 0;\n  let maxNumZeroInt = Number.MIN_SAFE_INTEGER;\n  let minNumZeroInt = Number.MAX_SAFE_INTEGER;\n  let maxNumZeroZero = 0;\n  let minNumZeroZero = 0;\n  let maxNumZeroZeroInt = Number.MIN_SAFE_INTEGER;\n  let minNumZeroZeroInt = Number.MAX_SAFE_INTEGER;\n  let maxNumZeroZeroZero = 0;\n  let minNumZeroZeroZero = 0;\n  let maxNumZeroZeroZeroInt = Number.MIN_SAFE_INTEGER;\n  let minNumZeroZeroZeroInt = Number.MAX_SAFE_INTEGER;\n  let maxNumZeroZeroZeroZero = 0;\n  let minNumZeroZeroZeroZero = 0;\n  let maxNumZeroZeroZeroInt = Number.MIN_SAFE_INTEGER;\n  let minNumZeroZeroZeroInt = Number.MAX_SAFE_INTEGER;\n  let maxNumZeroZeroZeroZero = 0;\n  let minNumZeroZeroZeroZero = 0;\n  let maxNumZeroZeroZeroZeroInt = Number.MIN_SAFE_INTEGER;\n  let minNumZeroZeroZeroZeroInt = Number.MAX_SAFE_INTEGER;\n  let maxNumZeroZeroZeroZeroZero = 0;\n  let minNumZeroZeroZeroZeroZero = 0;\n  let maxNumZeroZeroZeroZeroInt = Number.MIN_SAFE_INTEGER;\n  let minNumZeroZeroZeroZeroInt = Number.MAX_SAFE_INTEGER;\n  let maxNumZeroZeroZeroZeroZero = 0;\n  let minNumZeroZeroZeroZeroZero = 0;\n  let maxNumZeroZeroZeroZeroInt = Number.MIN_SAFE_INTEGER;\n  let minNumZeroZeroZeroZeroInt = Number.MAX_SAFE_INTEGER;\n  let maxNumZeroZeroZeroZeroZero = 0;\n  let minNumZeroZeroZeroZeroZero = 0;\n  let maxNumZeroZeroZeroZeroInt = Number.MIN_SAFE_INTEGER;\n  let minNumZeroZeroZeroZeroInt = Number.MAX_SAFE_INTEGER;\n  let maxNumZeroZeroZeroZero = 0;\n  let minNumZeroZeroZeroZero = 0;\n  let maxNumZeroZeroZeroZeroInt = Number.MIN_SAFE_INTEGER;\n  let minNumZeroZeroZeroZeroInt = Number.MAX_SAFE_INTEGER;\n  let maxNumZeroZeroZeroZero = 0;\n  let minNumZeroZeroZeroZero = 0;\n  let maxNumZeroZeroZeroZeroInt = Number.MIN_SAFE_INTEGER;\n  let minNumZeroZeroZeroZeroInt = Number.MAX_SAFE_INTEGER;\n  let maxNumZeroZeroZeroZeroZero = 0;\n  let minNumZeroZeroZeroZeroZero = 0;\n  let maxNumZeroZeroZeroZeroInt = Number.MIN_SAFE_INTEGER;\n  let minNumZeroZeroZeroZeroInt = Number.MAX_SAFE_INTEGER;\n  let maxNumZeroZeroZeroZero = 0;\n  let minNumZeroZeroZeroZero = 0;\n  let maxNumZeroZeroZeroZeroInt = Number.MIN_SAFE_INTEGER;\n  let minNumZeroZeroZeroZeroInt = Number.MAX_SAFE_INTEGER;\n  let maxNumZeroZeroZeroZero = 0;\n  let minNumZeroZeroZeroZero = 0;\n  let maxNumZeroZeroZeroZeroInt = Number.MIN_SAFE_INTEGER;\n  let minNumZeroZeroZeroZeroInt = Number.MAX_SAFE_INTEGER;\n  let maxNumZeroZeroZeroZero = 0;\n  let minNumZeroZeroZeroZero = 0;\n  let maxNumZeroZeroZeroZeroInt = Number.MIN_SAFE_INTEGER;\n  let minNumZeroZeroZeroZeroInt = Number.MAX_SAFE_INTEGER;\n  let maxNumZeroZeroZeroZero = 0;\n  let minNumZeroZeroZeroZero = 0;\n  let maxNumZeroZeroZeroZeroInt = Number.MIN_SAFE_INTEGER;\n  let minNumZeroZeroZeroZeroInt = Number.MAX_SAFE_INTEGER;\n  let maxNumZeroZeroZeroZero = 0;\n  let minNumZeroZeroZeroZero = 0;\n  let maxNumZeroZeroZeroZeroInt = Number.MIN_SAFE_INTEGER;\n  let minNumZeroZeroZeroZeroInt = Number.MAX_SAFE_INTEGER;\n  let maxNumZeroZeroZeroZero = 0;\n  let minNumZeroZeroZeroZero = 0;\n  let maxNumZeroZeroZeroZeroInt = Number.MIN_SAFE_INTEGER;\n  let minNumZeroZeroZeroZeroInt = Number.MAX_SAFE_INTEGER;\n  let maxNumZeroZeroZeroZero = 0;\n  let minNumZeroZeroZeroZero = 0;\n  let maxNumZeroZeroZeroZeroInt = Number.MIN_SAFE_INTEGER;\n  let minNumZeroZeroZeroZeroInt = Number.MAX_SAFE_INTEGER;\n  let maxNumZeroZeroZeroZero = 0;\n  let minNumZeroZeroZeroZero = 0;\n  let maxNumZeroZeroZeroZeroInt = Number.MIN_SAFE_INTEGER;\n  let minNumZeroZeroZeroZeroInt = Number.MAX_SAFE_INTEGER;\n  let maxNumZeroZeroZeroZero = 0;\n  let minNumZeroZeroZeroZero = 0;\n  let maxNumZeroZeroZeroZeroInt = Number.MIN_SAFE_INTEGER;\n  let minNumZeroZeroZeroZeroInt = Number.MAX_SAFE_INTEGER;\n  let maxNumZeroZeroZeroZero = 0;\n  let minNumZeroZeroZeroZero = 0;\n  let maxNumZeroZeroZeroZeroInt = Number.MIN_SAFE_INTEGER;\n  let minNumZeroZeroZeroZeroInt = Number.MAX_SAFE_INTEGER;\n  let maxNumZeroZeroZeroZero = 0;\n  let minNumZeroZeroZeroZero = 0;\n  let maxNumZeroZeroZeroZeroInt = Number.MIN_SAFE_INTEGER;\n  let minNumZeroZeroZeroZeroInt = Number.MAX_SAFE_INTEGER;\n  let maxNumZeroZeroZeroZero = 0;\n  let minNumZeroZeroZeroZero = 0;\n  let maxNumZeroZeroZeroZeroInt = Number.MIN_SAFE_INTEGER;\n  let minNumZeroZeroZeroZeroInt = Number.MAX_SAFE_INTEGER;\n  let maxNumZeroZeroZeroZero = 0;\n  let minNumZeroZeroZeroZero = 0;\n  let maxNumZeroZeroZeroZeroInt = Number.MIN_SAFE_INTEGER;\n  let minNumZeroZeroZeroZeroInt = Number.MAX_SAFE_INTEGER;\n  let maxNumZeroZeroZeroZero = 0;\n  let minNumZeroZeroZeroZero = 0;\n  let maxNumZeroZeroZeroZeroInt = Number.MIN_SAFE_INTEGER;\n  let minNumZeroZeroZeroZeroInt = Number.MAX_SAFE_INTEGER;\n  let maxNumZeroZeroZeroZero = 0;\n  let minNumZeroZeroZeroZero = 0;\n  let maxNumZeroZeroZeroZeroInt = Number.MIN_SAFE_INTEGER;\n  let minNumZeroZeroZeroZeroInt = Number.MAX_SAFE_INTEGER;\n  let maxNumZeroZeroZeroZero = 0;\n  let minNumZeroZeroZeroZero = 0;\n  let maxNumZeroZeroZeroZeroInt = Number.MIN_SAFE_INTEGER;\n  let minNumZeroZeroZeroZeroInt = Number.MAX_SAFE_INTEGER;\n  let maxNum"}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be . or ,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n  if (a === null || b === null) {\n    return a === null? b : a < b? -1 : 1;\n  }\n  if (typeof a === \"string\") {\n    return parseFloat(a) < parseFloat(b)? -1 : 1;\n  }\n  if (typeof b === \"string\") {\n    return parseFloat(b) < parseFloat(a)? -1 : 1;\n  }\n  return a < b? -1 : 1;\n};\n\n/**\n * Compare two numbers, returning -1 if first is smaller than second, 1 if\n * first is larger than second, and 0 if they are equal.\n */\nconst compare = (a, b) => {\n  return compareOne(a, b);\n};\n\n/**\n * Compare two numbers, returning -1 if first is smaller than second, 1 if\n * first is larger than second, and 0 if they are equal.\n */\nconst compareOne = (a, b) => {\n  if (a === null || b === null) {\n    return a === null? b : a < b? -1 : 1;\n  }\n  if (typeof a === \"string\") {\n    return parseFloat(a) < parseFloat(b)? -1 : 1;\n  }\n  if (typeof b === \"string\") {\n    return parseFloat(b) < parseFloat(a)? -1 : 1;\n  }\n  return a < b? -1 : 1;\n};\n\n/**\n * Compare two numbers, returning -1 if first is smaller than second, 1 if\n * first is larger than second, and 0 if they are equal.\n */\nconst compareOne = (a, b) => {\n  if (a === null || b === null) {\n    return a === null? b : a < b? -1 : 1;\n  }\n  if (typeof a === \"string\") {\n    return parseFloat(a) < parseFloat(b)? -1 : 1;\n  }\n  if (typeof b === \"string\") {\n    return parseFloat(b) < parseFloat(a)? -1 : 1;\n  }\n  return a < b? -1 : 1;\n};\n\n/**\n * Compare two numbers, returning -1 if first is smaller than second, 1 if\n * first is larger than second, and 0 if they are equal.\n */\nconst compare = (a, b) => {\n  return compareOne(a, b);\n};\n\n/**\n * Compare two numbers, returning -1 if first is smaller than second, 1 if\n * first is larger than second, and 0 if they are equal.\n */\nconst compareOne = (a, b) => {\n  if (a === null || b === null) {\n    return a === null? b : a < b? -1 : 1;\n  }\n  if (typeof a === \"string\") {\n    return parseFloat(a) < parseFloat(b)? -1 : 1;\n  }\n  if (typeof b === \"string\") {\n    return parseFloat(b) < parseFloat(a)? -1 : 1;\n  }\n  return a < b? -1 : 1;\n};\n\n/**\n * Compare two numbers, returning -1 if first is smaller than second, 1 if\n * first is larger than second, and 0 if they are equal.\n */\nconst compare = (a, b) => {\n  return compareOne(a, b);\n};\n\n/**\n * Compare two numbers, returning -1 if first is smaller than second, 1 if\n * first is larger than second, and 0 if they are equal.\n */\nconst compareOne = (a, b) => {\n  if (a === null || b === null) {\n    return a === null? b : a < b? -1 : 1;\n  }\n  if (typeof a === \"string\") {\n    return parseFloat(a) < parseFloat(b)? -1 : 1;\n  }\n  if (typeof b === \"string\") {\n    return parseFloat(b) < parseFloat(a)? -1 : 1;\n  }\n  return a < b? -1 : 1;\n};\n\n/**\n * Compare two numbers, returning -1 if first is smaller than second, 1 if\n * first is larger than second, and 0 if they are equal.\n */\nconst compare = (a, b) => {\n  return compareOne(a, b);\n};\n\n/**\n * Compare two numbers, returning -1 if first is smaller than second, 1 if\n * first is larger than second, and 0 if they are equal.\n */\nconst compareOne = (a, b) => {\n  if (a === null || b === null) {\n    return a === null? b : a < b? -1 : 1;\n  }\n  if (typeof a === \"string\") {\n    return parseFloat(a) < parseFloat(b)? -1 : 1;\n  }\n  if (typeof b === \"string\") {\n    return parseFloat(b) < parseFloat(a)? -1 : 1;\n  }\n  return a < b? -1 : 1;\n};\n\n/**\n * Compare two numbers, returning -1 if first is smaller than second, 1 if\n * first is larger than second, and 0 if they are equal.\n */\nconst compare = (a, b) => {\n  return compareOne(a, b);\n};\n\n/**\n * Compare two numbers, returning -1 if first is smaller than second, 1 if\n * first is larger than second, and 0 if they are equal.\n */\nconst compareOne = (a, b) => {\n  if (a === null || b === null) {\n    return a === null? b : a < b? -1 : 1;\n  }\n  if (typeof a === \"string\") {\n    return parseFloat(a) < parseFloat(b)? -1 : 1;\n  }\n  if (typeof b === \"string\") {\n    return parseFloat(b) < parseFloat(a)? -1 : 1;\n  }\n  return a < b? -1 : 1;\n};\n\n/**\n * Compare two numbers, returning -1 if first is smaller than second, 1 if\n * first is larger than second, and 0 if they are equal.\n */\nconst compare = (a, b) => {\n  return compareOne(a, b);\n};\n\n/**\n * Compare two numbers, returning -1 if first is smaller than second, 1 if\n * first is larger than second, and 0 if they are equal.\n */\nconst compareOne = (a, b) => {\n  if (a === null || b === null) {\n    return a === null? b : a < b? -1 : 1;\n  }\n  if (typeof a === \"string\") {\n    return parseFloat(a) < parseFloat(b)? -1 : 1;\n  }\n  if (typeof b === \"string\") {\n    return parseFloat(b) < parseFloat(a)? -1 : 1;\n  }\n  return a < b? -1 : 1;\n};\n\n/**\n * Compare two numbers, returning -1 if first is smaller than second, 1 if\n * first is larger than second, and 0 if they are equal.\n */\nconst compare = (a, b) => {\n  return compareOne(a, b);\n};\n\n/**\n * Compare two numbers, returning -1 if first is smaller than second, 1 if\n * first is larger than second, and 0 if they are equal.\n */\nconst compareOne = (a, b) => {\n  if (a === null || b === null) {\n    return a === null? b : a < b? -1 : 1;\n  }\n  if (typeof a === \"string\") {\n    return parseFloat(a) < parseFloat(b)? -1 : 1;\n  }\n  if (typeof b === \"string\") {\n    return parseFloat(b) < parseFloat(a)? -1 : 1;\n  }\n  return a < b? -1 : 1;\n};\n\n/**\n * Compare two numbers, returning -1 if first is smaller than second, 1 if\n * first is larger than second, and 0 if they are equal.\n */\nconst compare = (a, b) => {\n  return compareOne(a, b);\n};\n\n/**\n * Compare two numbers, returning -1 if first is smaller than second, 1 if\n * first is larger than second, and 0 if they are equal.\n */\nconst compareOne = (a, b) => {\n  if (a === null || b === null) {\n    return a === null? b : a < b? -1 : 1;\n  }\n  if (typeof a === \"string\") {\n    return parseFloat(a) < parseFloat(b)? -1 : 1;\n  }\n  if (typeof b === \"string\") {\n    return parseFloat(b) < parseFloat(a)? -1 : 1;\n  }\n  return a < b? -1 : 1;\n};\n\n/**\n * Compare two numbers, returning -1 if first is smaller than second, 1 if\n * first is larger than second, and 0 if they are equal.\n */\nconst compare = (a, b) => {\n  return compareOne(a, b);\n};\n\n/**\n * Compare two numbers, returning -1 if first is smaller than second, 1 if\n * first is larger than "}
{"task_id": "JavaScript/138", "prompt": "/*Eevaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Eevaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  let evenSum = 0;\n  let evenSum2 = 0;\n  let evenSum3 = 0;\n  let evenSum4 = 0;\n\n  while (n) {\n    sum += n % 2;\n    evenSum += n % 2;\n    evenSum2 += n % 2;\n    evenSum3 += n % 2;\n    evenSum4 += n % 2;\n    n /= 2;\n  }\n\n  return evenSum === 4 && evenSum2 === 4 && evenSum3 === 4 && evenSum4 === 4;\n};\n\n/*\n  Given a number n, return true if the number n is divisible by 3 or 5\n  Example\n  isDivisibleByThreeOr5(5) == true\n  isDivisibleByThreeOr5(7) == false\n  isDivisibleByThreeOr5(11) == false\n  isDivisibleByThreeOr5(13) == false\n  isDivisibleByThreeOr5(15) == false\n  isDivisibleByThreeOr5(17) == true\n  isDivisibleByThreeOr5(19) == false\n  isDivisibleByThreeOr5(21) == false\n  isDivisibleByThreeOr5(23) == false\n  isDivisibleByThreeOr5(25) == false\n  isDivisibleByThreeOr5(27) == true\n  isDivisibleByThreeOr5(29) == false\n  isDivisibleByThreeOr5(31) == false\n  isDivisibleByThreeOr5(33) == false\n  isDivisibleByThreeOr5(35) == false\n  isDivisibleByThreeOr5(37) == true\n  isDivisibleByThreeOr5(39) == false\n  isDivisibleByThreeOr5(41) == false\n  isDivisibleByThreeOr5(43) == false\n  isDivisibleByThreeOr5(45) == false\n  isDivisibleByThreeOr5(47) == true\n  isDivisibleByThreeOr5(49) == false\n  isDivisibleByThreeOr5(51) == false\n  isDivisibleByThreeOr5(53) == false\n  isDivisibleByThreeOr5(55) == false\n  isDivisibleByThreeOr5(57) == false\n  isDivisibleByThreeOr5(59) == false\n  isDivisibleByThreeOr5(61) == false\n  isDivisibleByThreeOr5(63) == false\n  isDivisibleByThreeOr5(65) == false\n  isDivisibleByThreeOr5(67) == false\n  isDivisibleByThreeOr5(69) == false\n  isDivisibleByThreeOr5(71) == false\n  isDivisibleByThreeOr5(73) == false\n  isDivisibleByThreeOr5(75) == false\n  isDivisibleByThreeOr5(77) == false\n  isDivisibleByThreeOr5(79) == false\n  isDivisibleByThreeOr5(81) == false\n  isDivisibleByThreeOr5(83) == false\n  isDivisibleByThreeOr5(85) == false\n  isDivisibleByThreeOr5(87) == false\n  isDivisibleByThreeOr5(89) == false\n  isDivisibleByThreeOr5(91) == false\n  isDivisibleByThreeOr5(93) == false\n  isDivisibleByThreeOr5(95) == false\n  isDivisibleByThreeOr5(97) == false\n  isDivisibleByThreeOr5(99) == false\n  isDivisibleByThreeOr5(101) == false\n  isDivisibleByThreeOr5(103) == false\n  isDivisibleByThreeOr5(105) == false\n  isDivisibleByThreeOr5(107) == false\n  isDivisibleByThreeOr5(109) == false\n  isDivisibleByThreeOr5(111) == false\n  isDivisibleByThreeOr5(113) == false\n  isDivisibleByThreeOr5(115) == false\n  isDivisibleByThreeOr5(117) == false\n  isDivisibleByThreeOr5(119) == false\n  isDivisibleByThreeOr5(121) == false\n  isDivisibleByThreeOr5(123) == false\n  isDivisibleByThreeOr5(125) == false\n  isDivisibleByThreeOr5(127) == false\n  isDivisibleByThreeOr5(129) == false\n  isDivisibleByThreeOr5(131) == false\n  isDivisibleByThreeOr5(133) == false\n  isDivisibleByThreeOr5(135) == false\n  isDivisibleByThreeOr5(137) == false\n  isDivisibleByThreeOr5(139) == false\n  isDivisibleByThreeOr5(141) == false\n  isDivisibleByThreeOr5(143) == false\n  isDivisibleByThreeOr5(145) == false\n  isDivisibleByThreeOr5(147) == false\n  isDivisibleByThreeOr5(149) == false\n  isDivisibleByThreeOr5(151) == false\n  isDivisibleByThreeOr5(153) == false\n  isDivisibleByThreeOr5(155) == false\n  isDivisibleByThreeOr5(157) == false\n  isDivisibleByThreeOr5(159) == false\n  isDivisibleByThreeOr5(161) == false\n  isDivisibleByThreeOr5(163) == false\n  isDivisibleByThreeOr5(165) == false\n  isDivisibleByThreeOr5(167) == false\n  isDivisibleByThreeOr5(169) == false\n  isDivisibleByThreeOr5(171) == false\n  isDivisibleByThreeOr5(173) == false\n  isDivisibleByThreeOr5(175) == false\n  isDivisibleByThreeOr5(177) == false\n  isDivisibleByThreeOr5(179) == false\n  isDivisibleByThreeOr5(181) == false\n  isDivisibleByThreeOr5(183) == false\n  isDivisibleByThreeOr5(185) == false\n  isDivisibleByThreeOr5(187) == false\n  isDivisibleByThreeOr5(189) == false\n  isDivisibleByThreeOr5(191) == false\n  isDivisibleByThreeOr5(193) == false\n  isDivisibleByThreeOr5(195) == false\n  isDivisibleByThreeOr5(197) == false\n  isDivisibleByThreeOr5(199) == false\n  isDivisibleByThreeOr5(201) == false\n  isDivisibleByThreeOr5(203) == false\n  isDivisibleByThreeOr5(205) == false\n  isDivisibleByThreeOr5(207) == false\n  isDivisibleByThreeOr5(209) == false\n  isDivisibleByThreeOr5(211) == false\n  isDivisibleByThreeOr5(213) == false\n  isDivisibleByThreeOr5(215) == false\n  isDivisibleByThreeOr5(217) == false\n  isDivisibleByThreeOr5(219) == false\n  isDivisibleByThreeOr5(221) == false\n  isDivisibleByThreeOr5(223) == false\n  isDivisibleByThreeOr5(225) == false\n  isDivisibleByThreeOr5(227) == false\n  isDivisibleByThreeOr5(229) == false\n  isDivisibleByThreeOr5(231) == false\n  isDivisibleByThreeOr5(233) == false\n  isDivisibleByThreeOr5(235) == false\n  isDivisibleByThreeOr5(237) == false\n  isDivisibleByThreeOr5(239) == false\n  isDivisibleByThreeOr5(241) == false\n  isDivisibleByThreeOr5(243) == false\n  isDivisibleByThreeOr5(245) == false\n  isDivisibleByThreeOr5(247) == false\n  isDivisibleByThreeOr5(249) == false\n  isDi"}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian faculty is defined as: brazilian _ factorial (n) = n! * (n-1)! * (n-2)! *... * 1! where n > 0 for example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*The Brazilian faculty is defined as: brazilian _ factorial (n) = n! * (n-1)! * (n-2)! *... * 1! where n > 0 for example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n <= 0) return 1;\n  return n * specialFactorial(n - 1);\n};\n\n/*\n  Returns the factorial of n. \n  \n  >>> factorial(5)\n  120\n  >>> factorial(6)\n  720\n  >>> factorial(7)\n  5040\n  >>> factorial(8)\n  40320\n  >>> factorial(9)\n  362880\n  >>> factorial(10)\n  3628800\n  >>> factorial(11)\n  39916800\n  >>> factorial(12)\n  479001600\n  >>> factorial(13)\n  5242880000\n  >>> factorial(14)\n  5789664000\n  >>> factorial(15)\n  640000000000\n  >>> factorial(16)\n  7199254740992\n  >>> factorial(17)\n  80530598192\n  >>> factorial(18)\n  90532944336\n  >>> factorial(19)\n  90737095516\n  >>> factorial(20)\n  9223372036854775807\n*/\nconst factorial = (n) => {\n  if (n <= 0) return 1;\n  return n * factorial(n - 1);\n};\n\n/*\n  Returns the factorial of n. \n  \n  >>> factorial2(5)\n  120\n  >>> factorial2(6)\n  720\n  >>> factorial2(7)\n  5040\n  >>> factorial2(8)\n  40320\n  >>> factorial2(9)\n  362880\n  >>> factorial2(10)\n  3628800\n  >>> factorial2(11)\n  39916800\n  >>> factorial2(12)\n  479001600\n  >>> factorial2(13)\n  5242880000\n  >>> factorial2(14)\n  5789664000\n  >>> factorial2(15)\n  640000000000\n  >>> factorial2(16)\n  7199254740992\n  >>> factorial2(17)\n  80530598192\n  >>> factorial2(18)\n  90532944336\n  >>> factorial2(19)\n  90737095516\n  >>> factorial2(20)\n  9223372036854775807\n*/\nconst factorial2 = (n) => {\n  if (n <= 0) return 1;\n  return n * factorial2(n - 1);\n};\n\n/*\n  Returns the factorial of n. \n  \n  >>> factorial3(5)\n  120\n  >>> factorial3(6)\n  720\n  >>> factorial3(7)\n  5040\n  >>> factorial3(8)\n  40320\n  >>> factorial3(9)\n  362880\n  >>> factorial3(10)\n  3628800\n  >>> factorial3(11)\n  39916800\n  >>> factorial3(12)\n  479001600\n  >>> factorial3(13)\n  5242880000\n  >>> factorial3(14)\n  5789664000\n  >>> factorial3(15)\n  640000000000\n  >>> factorial3(16)\n  7199254740992\n  >>> factorial3(17)\n  80530598192\n  >>> factorial3(18)\n  90532944336\n  >>> factorial3(19)\n  90737095516\n  >>> factorial3(20)\n  9223372036854775807\n*/\nconst factorial3 = (n) => {\n  if (n <= 0) return 1;\n  return n * factorial3(n - 1);\n};\n\n/*\n  Returns the factorial of n. \n  \n  >>> factorial4(5)\n  120\n  >>> factorial4(6)\n  720\n  >>> factorial4(7)\n  5040\n  >>> factorial4(8)\n  40320\n  >>> factorial4(9)\n  362880\n  >>> factorial4(10)\n  3628800\n  >>> factorial4(11)\n  39916800\n  >>> factorial4(12)\n  479001600\n  >>> factorial4(13)\n  5242880000\n  >>> factorial4(14)\n  5789664000\n  >>> factorial4(15)\n  640000000000\n  >>> factorial4(16)\n  7199254740992\n  >>> factorial4(17)\n  80530598192\n  >>> factorial4(18)\n  90532944336\n  >>> factorial4(19)\n  90737095516\n  >>> factorial4(20)\n  9223372036854775807\n*/\nconst factorial4 = (n) => {\n  if (n <= 0) return 1;\n  return n * factorial4(n - 1);\n};\n\n/*\n  Returns the factorial of n. \n  \n  >>> factorial5(5)\n  120\n  >>> factorial5(6)\n  720\n  >>> factorial5(7)\n  5040\n  >>> factorial5(8)\n  40320\n  >>> factorial5(9)\n  362880\n  >>> factorial5(10)\n  3628800\n  >>> factorial5(11)\n  39916800\n  >>> factorial5(12)\n  479001600\n  >>> factorial5(13)\n  5242880000\n  >>> factorial5(14)\n  5789664000\n  >>> factorial5(15)\n  640000000000\n  >>> factorial5(16)\n  7199254740992\n  >>> factorial5(17)\n  80530598192\n  >>> factorial5(18)\n  90532944336\n  >>> factorial5(19)\n  90737095516\n  >>> factorial5(20)\n  9223372036854775807\n*/\nconst factorial5 = (n) => {\n  if (n <= 0) return 1;\n  return n * factorial5(n - 1);\n};\n\n/*\n  Returns the factorial of n. \n  \n  >>> factorial6(5)\n  120\n  >>> factorial6(6)\n  720\n  >>> factorial6(7)\n  5040\n  >>> factorial6(8)\n  40320\n  >>> factorial6(9)\n  362880\n  >>> factorial6(10)\n  3628800\n  >>> factorial6(11)\n  39916800\n  >>> factorial6(12)\n  479001600\n  >>> factorial6(13)\n  5242880000\n  >>> factorial6(14)\n  5789664000\n  >>> factorial6(15)\n  640000000000\n  >>> factorial6(16)\n  7199254740992\n  >>> factorial6(17)\n  80530598192\n  >>> factorial6(18)\n  90532944336\n  >>> factorial6(19)\n  90737095516\n  >>> factorial6"}
{"task_id": "JavaScript/140", "prompt": "/*\n  For a string text, replace all spaces in it with underscores, and if a string has more than 2 consecutive spaces, replace all consecutive spaces with - fixSpaces (\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  For a string text, replace all spaces in it with underscores, and if a string has more than 2 consecutive spaces, replace all consecutive spaces with - fixSpaces (\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  const spaceRegex = /\\s+/g;\n  return text.replace(spaceRegex, (match) => match.replace(/ /g, '_'));\n};\n\n/**\n  Returns a string that has all spaces replaced with underscores and all consecutive spaces with dashes.\n  Example: \"Example\" = \"Example\"\n  Example: \"Example1\" = \"Example_1\"\n  Example: \"Example2\" = \"Example_2\"\n  Example: \"Example3\" = \"Example_3\"\n  Example: \"Example4\" = \"Example_4\"\n  Example: \"Example5\" = \"Example_5\"\n  Example: \"Example6\" = \"Example_6\"\n  Example: \"Example7\" = \"Example_7\"\n  Example: \"Example8\" = \"Example_8\"\n  Example: \"Example9\" = \"Example_9\"\n  Example: \"Example10\" = \"Example_10\"\n  Example: \"Example11\" = \"Example_11\"\n  Example: \"Example12\" = \"Example_12\"\n  Example: \"Example13\" = \"Example_13\"\n  Example: \"Example14\" = \"Example_14\"\n  Example: \"Example15\" = \"Example_15\"\n  Example: \"Example16\" = \"Example_16\"\n  Example: \"Example17\" = \"Example_17\"\n  Example: \"Example18\" = \"Example_18\"\n  Example: \"Example19\" = \"Example_19\"\n  Example: \"Example20\" = \"Example_20\"\n  Example: \"Example21\" = \"Example_21\"\n  Example: \"Example22\" = \"Example_22\"\n  Example: \"Example23\" = \"Example_23\"\n  Example: \"Example24\" = \"Example_24\"\n  Example: \"Example25\" = \"Example_25\"\n  Example: \"Example26\" = \"Example_26\"\n  Example: \"Example27\" = \"Example_27\"\n  Example: \"Example28\" = \"Example_28\"\n  Example: \"Example29\" = \"Example_29\"\n  Example: \"Example30\" = \"Example_30\"\n  Example: \"Example31\" = \"Example_31\"\n  Example: \"Example32\" = \"Example_32\"\n  Example: \"Example33\" = \"Example_33\"\n  Example: \"Example34\" = \"Example_34\"\n  Example: \"Example35\" = \"Example_35\"\n  Example: \"Example36\" = \"Example_36\"\n  Example: \"Example37\" = \"Example_37\"\n  Example: \"Example38\" = \"Example_38\"\n  Example: \"Example39\" = \"Example_39\"\n  Example: \"Example40\" = \"Example_40\"\n  Example: \"Example41\" = \"Example_41\"\n  Example: \"Example42\" = \"Example_42\"\n  Example: \"Example43\" = \"Example_43\"\n  Example: \"Example44\" = \"Example_44\"\n  Example: \"Example45\" = \"Example_45\"\n  Example: \"Example46\" = \"Example_46\"\n  Example: \"Example47\" = \"Example_47\"\n  Example: \"Example48\" = \"Example_48\"\n  Example: \"Example49\" = \"Example_49\"\n  Example: \"Example50\" = \"Example_50\"\n  Example: \"Example51\" = \"Example_51\"\n  Example: \"Example52\" = \"Example_52\"\n  Example: \"Example53\" = \"Example_53\"\n  Example: \"Example54\" = \"Example_54\"\n  Example: \"Example55\" = \"Example_55\"\n  Example: \"Example56\" = \"Example_56\"\n  Example: \"Example57\" = \"Example_57\"\n  Example: \"Example58\" = \"Example_58\"\n  Example: \"Example59\" = \"Example_59\"\n  Example: \"Example60\" = \"Example_60\"\n  Example: \"Example61\" = \"Example_61\"\n  Example: \"Example62\" = \"Example_62\"\n  Example: \"Example63\" = \"Example_63\"\n  Example: \"Example64\" = \"Example_64\"\n  Example: \"Example65\" = \"Example_65\"\n  Example: \"Example66\" = \"Example_66\"\n  Example: \"Example67\" = \"Example_67\"\n  Example: \"Example68\" = \"Example_68\"\n  Example: \"Example69\" = \"Example_69\"\n  Example: \"Example70\" = \"Example_70\"\n  Example: \"Example71\" = \"Example_71\"\n  Example: \"Example72\" = \"Example_72\"\n  Example: \"Example73\" = \"Example_73\"\n  Example: \"Example74\" = \"Example_74\"\n  Example: \"Example75\" = \"Example_75\"\n  Example: \"Example76\" = \"Example_76\"\n  Example: \"Example77\" = \"Example_77\"\n  Example: \"Example78\" = \"Example_78\"\n  Example: \"Example79\" = \"Example_79\"\n  Example: \"Example80\" = \"Example_80\"\n  Example: \"Example81\" = \"Example_81\"\n  Example: \"Example82\" = \"Example_82\"\n  Example: \"Example83\" = \"Example_83\"\n  Example: \"Example84\" = \"Example_84\"\n  Example: \"Example85\" = \"Example_85\"\n  Example: \"Example86\" = \"Example_86\"\n  Example: \"Example87\" = \"Example_87\"\n  Example: \"Example88\" = \"Example_88\"\n  Example: \"Example89\" = \"Example_89\"\n  Example: \"Example90\" = \"Example_90\"\n  Example: \"Example91\" = \"Example_91\"\n  Example: \"Example92\" = \"Example_92\"\n  Example: \"Example93\" = \"Example_93\"\n  Example: \"Example94\" = \"Example_94\"\n  Example: \"Example95\" = \"Example_95\"\n  Example: \"Example96\" = \"Example_96\"\n  Example: \"Example97\" = \"Example_97\"\n  Example: \"Example98\" = \"Example_98\"\n  Example: \"Example99\" = \"Example_99\"\n  Example: \"Example100\" = \"Example_100\"\n  Example: \"Example101\" = \"Example_101\"\n  Example: \"Example102\" = \"Example_102\"\n  Example: \"Example103\" = \"Example_103\"\n  Example: \"Example104\" = \"Example_104\"\n  Example: \"Example105\" = \"Example_105\"\n  Example: \"Example106\" = \"Example_106\"\n  Example: \"Example107\" = \"Example_107\"\n  Example: \"Example108\" = \"Example_108\"\n  Example: \"Example109\" = \"Example_109\"\n  Example: \"Example110\" = \"Example_110\"\n  Example: \"Example111\" = \"Example_111\"\n  Example: \"Example112\" = \"Example_112\"\n  Example: \"Example113\" = \"Example_113\"\n  Example: \"Example114\" = \"Example_114\"\n  Example: \"Example115\" = \"Example_115\"\n  Example: \"Example116\" = \"Example_116\"\n  Example: \"Example117\" = \"Example_117\"\n  Example: \"Example"}
{"task_id": "JavaScript/141", "prompt": "/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const file_name_length = file_name.length;\n  const dot_position = file_name.indexOf('.');\n  if (dot_position === -1) {\n    return false\n  }\n  const dot_length = dot_position - 1;\n  if (file_name_length > 3 || dot_length > 3) {\n    return false\n  }\n  const first_letter = file_name.charAt(0);\n  const first_letter_position = first_letter.charCodeAt(0);\n  const second_letter = file_name.charAt(1);\n  const second_letter_position = second_letter.charCodeAt(0);\n  const third_letter = file_name.charAt(2);\n  const third_letter_position = third_letter.charCodeAt(0);\n  const fourth_letter = file_name.charAt(3);\n  const fourth_letter_position = fourth_letter.charCodeAt(0);\n  const fifth_letter = file_name.charAt(4);\n  const fifth_letter_position = fifth_letter.charCodeAt(0);\n  const sixth_letter = file_name.charAt(5);\n  const sixth_letter_position = sixth_letter.charCodeAt(0);\n  const seventh_letter = file_name.charAt(6);\n  const seventh_letter_position = seventh_letter.charCodeAt(0);\n  const eighth_letter = file_name.charAt(7);\n  const eighth_letter_position = eighth_letter.charCodeAt(0);\n  const nineth_letter = file_name.charAt(8);\n  const nineth_letter_position = nineth_letter.charCodeAt(0);\n  const tenth_letter = file_name.charAt(9);\n  const tenth_letter_position = tenth_letter.charCodeAt(0);\n  const eleventh_letter = file_name.charAt(10);\n  const eleventh_letter_position = eleventh_letter.charCodeAt(0);\n  const twelfth_letter = file_name.charAt(11);\n  const twelfth_letter_position = twelfth_letter.charCodeAt(0);\n  const thirteenth_letter = file_name.charAt(12);\n  const thirteenth_letter_position = thirteenth_letter.charCodeAt(0);\n  const fourteenth_letter = file_name.charAt(13);\n  const fourteenth_letter_position = fourteenth_letter.charCodeAt(0);\n  const fifteenth_letter = file_name.charAt(14);\n  const fifteenth_letter_position = fifteenth_letter.charCodeAt(0);\n  const sixteenth_letter = file_name.charAt(15);\n  const sixteenth_letter_position = sixteenth_letter.charCodeAt(0);\n  const seventeenth_letter = file_name.charAt(16);\n  const seventeenth_letter_position = seventeenth_letter.charCodeAt(0);\n  const eighteenth_letter = file_name.charAt(17);\n  const eighteenth_letter_position = eighteenth_letter.charCodeAt(0);\n  const nineteenth_letter = file_name.charAt(18);\n  const nineteenth_letter_position = nineteenth_letter.charCodeAt(0);\n  const twenty_fifth_letter = file_name.charAt(19);\n  const twenty_fifth_letter_position = twenty_fifth_letter.charCodeAt(0);\n  const thirty_fifth_letter = file_name.charAt(20);\n  const thirty_fifth_letter_position = thirty_fifth_letter.charCodeAt(0);\n  const fourty_fifth_letter = file_name.charAt(21);\n  const fourty_fifth_letter_position = fourty_fifth_letter.charCodeAt(0);\n  const fifty_fifth_letter = file_name.charAt(22);\n  const fifty_fifth_letter_position = fifty_fifth_letter.charCodeAt(0);\n  const sixty_fifth_letter = file_name.charAt(23);\n  const sixty_fifth_letter_position = sixty_fifth_letter.charCodeAt(0);\n  const seventy_fifth_letter = file_name.charAt(24);\n  const seventy_fifth_letter_position = seventy_fifth_letter.charCodeAt(0);\n  const eighty_fifth_letter = file_name.charAt(25);\n  const eighty_fifth_letter_position = eighty_fifth_letter.charCodeAt(0);\n  const ninety_fifth_letter = file_name.charAt(26);\n  const ninety_fifth_letter_position = ninety_fifth_letter.charCodeAt(0);\n  const ten_fifth_letter = file_name.charAt(27);\n  const ten_fifth_letter_position = ten_fifth_letter.charCodeAt(0);\n  const eleven_fifth_letter = file_name.charAt(28);\n  const eleven_fifth_letter_position = eleven_fifth_letter.charCodeAt(0);\n  const twelve_fifth_letter = file_name.charAt(29);\n  const twelve_fifth_letter_position = twelve_fifth_letter.charCodeAt(0);\n  const thirteen_fifth_letter = file_name.charAt(30);\n  const thirteen_fifth_letter_position = thirteen_fifth_letter.charCodeAt(0);\n  const fourteen_fifth_letter = file_name.charAt(31);\n  const fourteen_fifth_letter_position = fourteen_fifth_letter.charCodeAt(0);\n  const fifteen_fifth_letter = file_name.charAt(32);\n  const fifteen_fifth_letter_position = fifteen_fifth_letter.charCodeAt(0);\n  const sixteen_fifth_letter = file_name.charAt(33);\n  const sixteen_fifth_letter_position = sixteen_fifth_letter.charCodeAt(0);\n  const seventeen_fifth_letter = file_name.charAt(34);\n  const seventeen_fifth_letter_position = seventeen_fifth_letter.charCodeAt(0);\n  const eighteen_fifth_letter = file_name.charAt(35);\n  const eighteen_fifth_letter_position = eighteen_fifth_letter.charCodeAt(0);\n  const nineteen_fifth_letter = file_name.charAt(36);\n  const nineteen_fifth_letter_position = nineteen_fifth_letter.charCodeAt(0);\n  const twenty_sixth_letter = file_name.charAt(37);\n  const twenty_sixth_letter_position = twenty_sixth_letter.charCodeAt(0);\n  const thirty_sixth_letter = file_name.charAt(38);\n  const thirty_sixth_letter_position = thirty_sixth_letter.charCodeAt(0);\n  const fourty_sixth_letter = file_name.charAt(39);\n  const fourty_sixth_letter_position = fourty_sixth_letter.charCodeAt(0);\n  const fifty_sixth_letter = file_name.charAt(40);\n  const fifty_sixth_letter_position = fifty_sixth_letter.charCodeAt(0);\n  const sixty_sixth_letter = file_name.charAt(41);\n  const sixty_sixth_letter_position = sixty_sixth_letter.charCodeAt(0);\n  const seventy_sixth_letter = file_name.charAt(42);\n  const seventy_sixth_letter_position = seventy_sixth_letter.charCodeAt(0);\n  const eighty_sixth_letter = file_name.charAt(43);\n  const eighty_sixth_letter_position = eighty_sixth_letter.charCodeAt(0);\n  const ninety_sixth_letter = file_name.charAt(44);\n  const ninety_sixth_letter_position = ninety_sixth_letter.charCodeAt(0);\n  const twenty_seventh_letter = file_name.charAt(45);\n  const twenty_seventh_letter_position = twenty_seventh_letter.charCodeAt(0);\n  const thir"}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list with integers, return a new list with integers squared. \n  \n  Examples:\n  square([1,2,3]) should return [1,2,4,6,8,10,12,14,16,18,20]\n  square([-1,-5,2,-1,-5]) should return [-5,-10,-15,-20,-25,-30,-35,-40,-45,-50]\n  */\nconst square = (lst) => {\n  let newList = [];\n  for (let i = 0; i < lst.length; i++) {\n    newList.push(lst[i] * lst[i]);\n  }\n  return newList;\n};\n\n/*\n  Given a list with integers, return a new list with integers cubed. \n  \n  Examples:\n  cube([1,2,3]) should return [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,39916800,39916800]\n  cube([-1,-5,2,-1,-5]) should return [-5,-10,-15,-20,-25,-30,-35,-40,-45,-50]\n  */\nconst cube = (lst) => {\n  let newList = [];\n  for (let i = 0; i < lst.length; i++) {\n    newList.push(lst[i] * lst[i]);\n  }\n  return newList;\n};\n\n/*\n  Given a list with integers, return a new list with integers raised to the power of the index. \n  \n  Examples:\n  raise([1,2,3]) should return [1,2,1,4,9,16,25,36,49,64,81,100]\n  raise([-1,-5,2,-1,-5]) should return [-5,-10,-15,-20,-25,-30,-35,-40,-45,-50]\n  */\nconst raise = (lst) => {\n  let newList = [];\n  for (let i = 0; i < lst.length; i++) {\n    newList.push(lst[i] ** i);\n  }\n  return newList;\n};\n\n/*\n  Given a list with integers, return a new list with integers divided by the index. \n  \n  Examples:\n  divide([1,2,3]) should return [1,2,1,4,9,16,25,36,49,64,81,100]\n  divide([-1,-5,2,-1,-5]) should return [-5,-10,-15,-20,-25,-30,-35,-40,-45,-50]\n  */\nconst divide = (lst) => {\n  let newList = [];\n  for (let i = 0; i < lst.length; i++) {\n    newList.push(lst[i] / i);\n  }\n  return newList;\n};\n\n/*\n  Given a list with integers, return a new list with integers floored and rounded. \n  \n  Examples:\n  flooredRound([1,2,3]) should return [1,2,1,4,9,16,25,36,49,64,81,100]\n  flooredRound([-1,-5,2,-1,-5]) should return [-5,-10,-15,-20,-25,-30,-35,-40,-45,-50]\n  */\nconst flooredRound = (lst) => {\n  let newList = [];\n  for (let i = 0; i < lst.length; i++) {\n    newList.push(Math.floor(lst[i]));\n  }\n  return newList;\n};\n\n/*\n  Given a list with integers, return a new list with integers floored and rounded. \n  \n  Examples:\n  flooredRound([1,2,3]) should return [1,2,1,4,9,16,25,36,49,64,81,100]\n  flooredRound([-1,-5,2,-1,-5]) should return [-5,-10,-15,-20,-25,-30,-35,-40,-45,-50]\n  */\nconst flooredRound = (lst) => {\n  let newList = [];\n  for (let i = 0; i < lst.length; i++) {\n    newList.push(Math.ceil(lst[i]));\n  }\n  return newList;\n};\n\n/*\n  Given a list with integers, return a new list with integers rounded to the nearest integer. \n  \n  Examples:\n  round([1,2,3]) should return [1,2,1,4,9,16,25,36,49,64,81,100]\n  round([-1,-5,2,-1,-5]) should return [-5,-10,-15,-20,-25,-30,-35,-40,-45,-50]\n  */\nconst round = (lst) => {\n  let newList = [];\n  for (let i = 0; i < lst.length; i++) {\n    newList.push(Math.round(lst[i]));\n  }\n  return newList;\n};\n\n/*\n  Given a list with integers, return a new list with integers rounded to the nearest integer. \n  \n  Examples:\n  round([1,2,3]) should return [1,2,1,4,9,16,25,36,49,64,81,100]\n  round([-1,-5,2,-1,-5]) should return [-5,-10,-15,-20,-25,-30,-35,-40,-45,-50]\n  */\nconst round = (lst) => {\n  let newList = [];\n  for (let i = 0; i < lst.length; i++) {\n    newList.push(Math.ceil(lst[i]));\n  }\n  return newList;\n};\n\n/*\n  Given a list with integers, return a new list with integers rounded to the nearest integer. \n  \n  Examples:\n  round([1,2,3]) should return [1,2,1,4,9,16,25,36,49,64,81,100]\n  round([-1,-5,2,-1,-5]) should return [-5,-10,-15,-20,-25,-30,-35,-40,-45,-50]\n  */\nconst round = (lst) => {\n  let newList = [];\n  for (let i = 0; i < lst.length; i++) {\n    newList.push(Math.floor(lst[i]));\n  }\n  return newList;\n};\n\n/*\n  Given a list with integers, return a new list with integers rounded to the nearest integer. \n  \n  Examples:\n  round([1,2,3]) should return [1,2,1,4,9,16,25,36,49,64,81,100]\n  round([-1,-5,2,-1,-5]) should return [-5,-10,-15,-20,-25,-30,-35,-40,-45,-50]\n  */\nconst round = (lst) => {\n  let newList = [];\n  for (let i = 0; i < lst.length; i++) {\n    newList.push(Math.ceil(lst[i]));\n  }\n  return newList;\n};\n\n/*\n  Given a list with integers, return a new list with integers rounded to the nearest integer. \n  \n  Examples:\n  round([1,2,3]) should return [1,2,1,4,9,16,25,36,49,64,81,100]\n  round([-1,-5,2,-1,-5]) should return [-5,-10,-15,-20,-25,-30,-35,-40,-45,-50]\n  */\nconst round = (lst) => {\n  let newList = [];\n  for (let i = 0; i < lst.length; i++) {\n    newList.push(Math.floor(lst[i]));\n  }\n  return "}
{"task_id": "JavaScript/143", "prompt": "/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  for (let i = 0; i < words.length; i++) {\n    if (words[i] === \"a\" || words[i] === \"e\" || words[i] === \"i\" || words[i] === \"o\" || words[i] === \"u\") {\n      newSentence += words[i];\n    } else {\n      newSentence += words[i];\n    }\n  }\n  return newSentence;\n};\n\n/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithLength = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  for (let i = 0; i < words.length; i++) {\n    if (words[i] === \"a\" || words[i] === \"e\" || words[i] === \"i\" || words[i] === \"o\" || words[i] === \"u\") {\n      newSentence += words[i];\n    } else {\n      newSentence += words[i];\n    }\n  }\n  return newSentence.length;\n};\n\n/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithLengthAndOrder = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  for (let i = 0; i < words.length; i++) {\n    if (words[i] === \"a\" || words[i] === \"e\" || words[i] === \"i\" || words[i] === \"o\" || words[i] === \"u\") {\n      newSentence += words[i];\n    } else {\n      newSentence += words[i];\n    }\n  }\n  return newSentence.split(\"\").sort();\n};\n\n/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithLengthAndOrderAndSpace = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  for (let i = 0; i < words.length; i++) {\n    if (words[i] === \"a\" || words[i] === \"e\" || words[i] === \"i\" || words[i] === \"o\" || words[i] === \"u\") {\n      newSentence += words[i];\n    } else {\n      newSentence += words[i];\n    }\n  }\n  return newSentence.split(\"\").sort().join(\" \");\n};\n\n/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithLengthAndOrderAndSpace2 = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  for (let i = 0; i < words.length; i++) {\n    if (words[i] === \"a\" || words[i] === \"e\" || words[i] === \"i\" || words[i] === \"o\" || words[i] === \"u\") {\n      newSentence += words[i];\n    } else {\n      newSentence += words[i];\n    }\n  }\n  return newSentence.split(\"\").sort().join(\" \");\n};\n\n/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithLengthAndOrderAndSpace3 = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  for (let i = 0; i < words.length; i++) {\n    if (words[i] === \"a\" || words[i] === \"e\" || words[i] === \"i\" || words[i] === \"o\" || words[i] === \"u\") {\n      newSentence += words[i];\n    } else {\n      newSentence += words[i];\n    }\n  }\n  return newSentence.split(\"\").sort().join(\" \");\n};\n\n/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithLengthAndOrderAndSpace4 = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  for (let i = 0; i < words.length; i++) {\n    if (words[i] === \"a\" || words[i] === \"e\" || words[i] === \"i\" || words[i] === \"o\" || words[i] === \"u\") {\n      newSentence += words[i];\n    } else {\n      newSentence += words[i];\n    }\n  }\n  return newSentence.split(\"\").sort().join(\" \");\n};\n\n/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithLengthAndOrderAndSpace5 = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  for (let i = 0; i < words.length; i++) {\n    if (words[i] "}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  if (x === \"\" || n === \"\") {\n    return false;\n  }\n  const [numerator, denominator] = x.split(\"/\").map(Number);\n  if (denominator === 0) {\n    return false;\n  }\n  if (denominator === 1) {\n    return true;\n  }\n  return numerator / denominator === n;\n};\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  if (x === \"\" || n === \"\") {\n    return false;\n  }\n  const [numerator, denominator] = x.split(\"/\").map(Number);\n  if (denominator === 0) {\n    return false;\n  }\n  if (denominator === 1) {\n    return true;\n  }\n  return numerator / denominator === n;\n};\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  if (x === \"\" || n === \"\") {\n    return false;\n  }\n  const [numerator, denominator] = x.split(\"/\").map(Number);\n  if (denominator === 0) {\n    return false;\n  }\n  if (denominator === 1) {\n    return true;\n  }\n  return numerator / denominator === n;\n};\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  if (x === \"\" || n === \"\") {\n    return false;\n  }\n  const [numerator, denominator] = x.split(\"/\").map(Number);\n  if (denominator === 0) {\n    return false;\n  }\n  if (denominator === 1) {\n    return true;\n  }\n  return numerator / denominator === n;\n};\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  if (x === \"\" || n === \"\") {\n    return false;\n  }\n  const [numerator, denominator] = x.split(\"/\").map(Number);\n  if (denominator === 0) {\n    return false;\n  }\n  if (denominator === 1) {\n    return true;\n  }\n  return numerator / denominator === n;\n};\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  if (x === \"\" || n === \"\") {\n    return false;\n  }\n  const [numerator, denominator] = x.split(\"/\").map(Number);\n  if (denominator === 0) {\n    return false;\n  }\n  if (denominator === 1) {\n    return true;\n  }\n  return numerator / denominator === n;\n};\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  if (x === \"\" || n === \"\") {\n    return false;\n  }\n  const [numerator, denominator] = x.split(\"/\").map(Number);\n  if (denominator === 0) {\n    return false;\n  }\n  if (denominator === 1) {\n    return true;\n  }\n  return numerator / denominator === n;\n};\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  if (x === \"\" || n === \"\") {\n    return false;\n  }\n  const [numerator, denominator] = x.split(\"/\").map(Number);\n  if (denominator === 0) {\n    return false;\n  }\n  if (denominator === 1) {\n    return true;\n  }\n  return numerator / denominator === n;\n};\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  if ("}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a function that sorts the specified list of integers in ascending order according to the sum of their digits. Note: If there are several elements with a similar sum of their digits, order them by their index in the original list. Example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that sorts the specified list of integers in ascending order according to the sum of their digits. Note: If there are several elements with a similar sum of their digits, order them by their index in the original list. Example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  let sum = 0;\n  let index = 0;\n  let temp = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    temp.push(nums[i]);\n  }\n  temp.sort((a, b) => a - b);\n  for (let i = 0; i < temp.length; i++) {\n    if (temp[i]!== nums[index]) {\n      index = i;\n    }\n  }\n  return temp;\n};\n\n/*\n  Write a function that sorts the specified list of integers in descending order according to the sum of their digits. Note: If there are several elements with a similar sum of their digits, order them by their index in the original list. Example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-11, -11, -11, -11, -11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDesc = (nums) => {\n  let sum = 0;\n  let index = 0;\n  let temp = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    temp.push(nums[i]);\n  }\n  temp.sort((a, b) => b - a);\n  for (let i = 0; i < temp.length; i++) {\n    if (temp[i]!== nums[index]) {\n      index = i;\n    }\n  }\n  return temp;\n};\n\n/*\n  Write a function that returns the sum of the digits of an integer in ascending order. Note: If there are several elements with a similar sum of their digits, order them by their index in the original list. Example:\n  >>> sumDigitsOfNumber(1) == 11\n  >>> sumDigitsOfNumber(11) == 11\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == -1\n  >>> sumDigitsOfNumber(-1) == "}
{"task_id": "JavaScript/146", "prompt": "/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i] >= 10) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i] >= 10) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i] >= 10) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i] >= 10) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i] >= 10) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i] >= 10) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i] >= 10) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i] >= 10) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i] >= 10) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i] >= 10) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i] >= 10) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i] >= 10) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i] >= 10) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i] >= 10) {\n      count++;\n    }\n  }\n"}
{"task_id": "JavaScript/147", "prompt": "/*\n  For each i (1 ≤ i ≤ n) the value of a [i] = i * i - i + 1 is given. You give the number of triples (a [i], a [j], a [k]) from a where i < j < k and a [i] + a [j] + a [k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  For each i (1 ≤ i ≤ n) the value of a [i] = i * i - i + 1 is given. You give the number of triples (a [i], a [j], a [k]) from a where i < j < k and a [i] + a [j] + a [k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  let maxTriples = 0;\n  let triples = [];\n  for (let i = 1; i <= n; i++) {\n    let triple = [i, i, i];\n    for (let j = i + 1; j <= n; j++) {\n      let triple2 = [i, j, i];\n      for (let k = j + 1; k <= n; k++) {\n        let triple3 = [i, k, j];\n        if (triple2.every((v, i) => v === triple[i])) {\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);\n          triples.push(triple3);\n          triples.push(triple2);\n          triples.push(triple);"}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planet1Orbit = orbits[planet1]\n  const planet2Orbit = orbits[planet2]\n  const planet1OrbitDistance = planet1Orbit.distance\n  const planet2OrbitDistance = planet2Orbit.distance\n  const planet1OrbitOrbits = planet1Orbit.orbits\n  const planet2OrbitOrbits = planet2Orbit.orbits\n  const planet1OrbitOrbitDistances = planet1OrbitOrbits.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbits.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.filter(orbitDistance => orbitDistance <= planet1OrbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.filter(orbitDistance => orbitDistance <= planet2OrbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.filter(orbitDistance => orbitDistance >= planet1OrbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.filter(orbitDistance => orbitDistance >= planet2OrbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1Orbit"}
{"task_id": "JavaScript/149", "prompt": "/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return [...new Set(sum)];\n};\n\n/*\n  Given a sorted list of numbers, return a new list that sums up all the numbers in the list.\n  For example:\n  assert list_sum([\"1\", \"2\", \"3\"]) => 6\n  assert list_sum([\"1\", \"2\", \"3\", \"4\"]) => 10\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\"]) => 15\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"]) => 30\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\"]) => 60\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"]) => 90\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]) => 100\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"]) => 150\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\"]) => 200\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\"]) => 250\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\"]) => 300\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\"]) => 350\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\"]) => 400\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\"]) => 450\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\"]) => 500\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\"]) => 550\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\"]) => 600\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\"]) => 650\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\"]) => 700\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\"]) => 750\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\"]) => 800\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\"]) => 850\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\", \"25\"]) => 900\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\"]) => 950\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\"]) => 1000\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\"]) => 1050\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\"]) => 1100\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\"]) => 1150\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\"]) => 1200\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\", \"32\"]) => 1250\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\", \"32\", \"33\"]) => 1300\n  assert list_sum([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21"}
{"task_id": "JavaScript/150", "prompt": "/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % y === 0) return x\n  return y\n}\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % y === 0) return x\n  return y\n}\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % y === 0) return x\n  return y\n}\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % y === 0) return x\n  return y\n}\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % y === 0) return x\n  return y\n}\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % y === 0) return x\n  return y\n}\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % y === 0) return x\n  return y\n}\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % y === 0) return x\n  return y\n}\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % y === 0) return x\n  return y\n}\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % y === 0) return x\n  return y\n}\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % y === 0) return x\n  return y\n}\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % y === 0) return x\n  return y\n}\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % y === 0) return x\n  return y\n}\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % y === 0) return x\n  return y\n}\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % y === 0) return x\n  return y\n}\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % y === 0) return x\n  return y\n}\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % y === 0) return x\n  return y\n}\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % y === 0) return x\n  return y\n}\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % y === 0) return x\n  return y\n}\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % y === 0) return x\n  return y\n}\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % y === 0) return x\n  return y\n}\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % y === 0) return x\n  return y\n}\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5"}
{"task_id": "JavaScript/151", "prompt": "/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are even. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 1\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are even. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 1\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are even. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 1\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are even. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 1\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are even. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 1\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are even. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 1\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are even. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 1\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are even. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 1\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are even. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 1\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are even. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 1\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are even. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 1\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are even. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 1\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {"}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const scores = [...game];\n  const guesses = [...guess];\n  const scoreDifferences = scores.length - guesses.length;\n  const guessesDifferences = guesses.length - scores.length;\n  const scoreDifferenceSum = scoreDifferences.reduce((acc, cur) => acc + cur, 0);\n  const guessesDifferenceSum = guessesDifferences.reduce((acc, cur) => acc + cur, 0);\n  const scoreDifferenceSumSquared = scoreDifferenceSum * scoreDifferenceSum;\n  const guessesDifferenceSumSquared = guessesDifferenceSum * guessesDifferenceSum;\n  const scoreDifferenceSumSquared = scoreDifferenceSumSquared * scoreDifferenceSum;\n  const guessesDifferenceSumSquared = guessesDifferenceSumSquared * guessesDifferenceSum;\n  const scoreDifferenceSumSquared = scoreDifferenceSumSquared * scoreDifferenceSum;\n  const guessesDifferenceSumSquared = guessesDifferenceSumSquared * guessesDifferenceSum;\n  const scoreDifferenceSum = scoreDifferenceSumSquared + scoreDifferenceSum;\n  const guessesDifferenceSum = guessesDifferenceSumSquared + guessesDifferenceSum;\n  const scoreDifferenceSumSquared = scoreDifferenceSumSquared + scoreDifferenceSumSquared;\n  const guessesDifferenceSumSquared = guessesDifferenceSumSquared + guessesDifferenceSumSquared;\n  const scoreDifferenceSumSquared = scoreDifferenceSumSquared + scoreDifferenceSumSquared;\n  const guessesDifferenceSumSquared = guessesDifferenceSumSquared + guessesDifferenceSumSquared;\n  const scoreDifferenceSum = scoreDifferenceSum + scoreDifferenceSum;\n  const guessesDifferenceSum = guessesDifferenceSum + guessesDifferenceSum;\n  const scoreDifferenceSumSquared = scoreDifferenceSumSquared + scoreDifferenceSumSquared;\n  const guessesDifferenceSumSquared = guessesDifferenceSumSquared + guessesDifferenceSumSquared;\n  const scoreDifferenceSumSquared = scoreDifferenceSumSquared + scoreDifferenceSumSquared;\n  const guessesDifferenceSumSquared = guessesDifferenceSumSquared + guessesDifferenceSumSquared;\n  const scoreDifferenceSum = scoreDifferenceSum + scoreDifferenceSum;\n  const guessesDifferenceSum = guessesDifferenceSum + guessesDifferenceSum;\n  const scoreDifferenceSumSquared = scoreDifferenceSumSquared + scoreDifferenceSumSquared;\n  const guessesDifferenceSumSquared = guessesDifferenceSumSquared + guessesDifferenceSumSquared;\n  const scoreDifferenceSumSquared = scoreDifferenceSumSquared + scoreDifferenceSumSquared;\n  const guessesDifferenceSumSquared = guessesDifferenceSumSquared + guessesDifferenceSumSquared;\n  const scoreDifferenceSum = scoreDifferenceSum + scoreDifferenceSum;\n  const guessesDifferenceSum = guessesDifferenceSum + guessesDifferenceSum;\n  const scoreDifferenceSumSquared = scoreDifferenceSumSquared + scoreDifferenceSumSquared;\n  const guessesDifferenceSumSquared = guessesDifferenceSumSquared + guessesDifferenceSumSquared;\n  const scoreDifferenceSumSquared = scoreDifferenceSumSquared + scoreDifferenceSumSquared;\n  const guessesDifferenceSumSquared = guessesDifferenceSumSquared + guessesDifferenceSumSquared;\n  const scoreDifferenceSum = scoreDifferenceSum + scoreDifferenceSum;\n  const guessesDifferenceSum = guessesDifferenceSum + guessesDifferenceSum;\n  const scoreDifferenceSumSquared = scoreDifferenceSumSquared + scoreDifferenceSumSquared;\n  const guessesDifferenceSumSquared = guessesDifferenceSumSquared + guessesDifferenceSumSquared;\n  const scoreDifferenceSumSquared = scoreDifferenceSumSquared + scoreDifferenceSumSquared;\n  const guessesDifferenceSumSquared = guessesDifferenceSumSquared + guessesDifferenceSumSquared;\n  const scoreDifferenceSum = scoreDifferenceSum + scoreDifferenceSum;\n  const guessesDifferenceSum = guessesDifferenceSum + guessesDifferenceSum;\n  const scoreDifferenceSumSquared = scoreDifferenceSumSquared + scoreDifferenceSumSquared;\n  const guessesDifferenceSumSquared = guessesDifferenceSumSquared + guessesDifferenceSumSquared;\n  const scoreDifferenceSumSquared = scoreDifferenceSumSquared + scoreDifferenceSumSquared;\n  const guessesDifferenceSumSquared = guessesDifferenceSumSquared + guessesDifferenceSumSquared;\n  const scoreDifferenceSum = scoreDifferenceSum + scoreDifferenceSum;\n  const guessesDifferenceSum = guessesDifferenceSum + guessesDifferenceSum;\n  const scoreDifferenceSumSquared = scoreDifferenceSumSquared + scoreDifferenceSumSquared;\n  const guessesDifferenceSumSquared = guessesDifferenceSumSquared + guessesDifferenceSumSquared;\n  const scoreDifferenceSumSquared = scoreDifferenceSumSquared + scoreDifferenceSumSquared;\n  const guessesDifferenceSumSquared = guessesDifferenceSumSquared + guessesDifferenceSumSquared;\n  const scoreDifferenceSum = scoreDifferenceSum + scoreDifferenceSum;\n  const guessesDifferenceSum = guessesDifferenceSum + guessesDifferenceSum;\n  const scoreDifferenceSumSquared = scoreDifferenceSumSquared + scoreDifferenceSumSquared;\n  const guessesDifferenceSumSquared = guessesDifferenceSumSquared + guessesDifferenceSumSquared;\n  const scoreDifferenceSumSquared = scoreDifferenceSumSquared + scoreDifferenceSumSquared;\n  const guessesDifferenceSumSquared = guessesDifferenceSumSquared + guessesDifferenceSumSquared;\n  const scoreDifferenceSum = scoreDifferenceSum + scoreDifferenceSum;\n  const guessesDifferenceSum = guessesDifferenceSum + guessesDifferenceSum;\n  const scoreDifferenceSumSquared = scoreDifferenceSumSquared + scoreDifferenceSumSquared;\n  const guessesDifferenceSumSquared = guessesDifferenceSumSquared + guessesDifferenceSumSquared;\n  const scoreDifferenceSumSquared = scoreDifferenceSumSquared + scoreDifferenceSumSquared;\n  const guessesDifferenceSumSquared = guessesDifferenceSumSquared + guessesDifferenceSumSquared;\n  const scoreDifferenceSum = scoreDifferenceSum + scoreDifferenceSum;\n  const guessesDifferenceSum = guessesDifferenceSum + guessesDifferenceSum;\n  const scoreDifferenceSumSquared = scoreDifferenceSumSquared + scoreDifferenceSumSquared;\n  const guessesDifferenceSumSquared = guessesDifferenceSumSquared + guessesDifferenceSumSquared;\n  const scoreDifferenceSumSquared = scoreDifferenceSumSquared + scoreDifferenceSumSquared;\n  const guessesDifferenceSumSquared = guessesDifferenceSumSquared + guessesDifferenceSumSquared;\n  const scoreDifferenceSum = scoreDifferenceSum + scoreDifferenceSum;\n  const guessesDifferenceSum = guessesDifferenceSum + guessesDifferenceSum;\n  const scoreDifferenceSumSquared = scoreDifferenceSumSquared + scoreDifferenceSumSquared;\n  const guessesDifferenceSumSquared = guesses"}
{"task_id": "JavaScript/153", "prompt": "/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let extension_strength = -1;\n  let extension_class = class_name;\n  let extension_strength_counter = 0;\n  for (let i = 0; i < extensions.length; i++) {\n    let extension = extensions[i];\n    let extension_length = extension.length;\n    if (extension_strength_counter < extension_length) {\n      extension_strength = extension_strength - extension_strength_counter;\n      extension_class = extension.substr(0, extension_length);\n      extension_strength_counter++;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class and a string, return true if the string is a valid class name.\n  Return false otherwise.\n  Example:\n  isValidClassName('my_class','my_class') => true\n  isValidClassName('my_class','my_class.') => false\n*/\nconst isValidClassName = (class_name, class_name_to_check) => {\n  let class_name_length = class_name.length;\n  let class_name_check = false;\n  for (let i = 0; i < class_name_to_check.length; i++) {\n    let class_name_char = class_name_to_check.charAt(i);\n    if (class_name_char >= 'A' && class_name_char <= 'Z') {\n      class_name_check = true;\n    } else if (class_name_char >= 'a' && class_name_char <= 'z') {\n      class_name_check = true;\n    } else if (class_name_char >= '0' && class_name_char <= '9') {\n      class_name_check = true;\n    }\n  }\n  return class_name_check;\n};\n\n/*\n  Given a class and a string, return true if the string is a valid class name.\n  Return false otherwise.\n  Example:\n  isValidClassName('my_class','my_class') => true\n  isValidClassName('my_class','my_class.') => false\n*/\nconst isValidClassName_1 = (class_name, class_name_to_check) => {\n  let class_name_length = class_name.length;\n  let class_name_check = false;\n  for (let i = 0; i < class_name_to_check.length; i++) {\n    let class_name_char = class_name_to_check.charAt(i);\n    if (class_name_char >= 'A' && class_name_char <= 'Z') {\n      class_name_check = true;\n    } else if (class_name_char >= 'a' && class_name_char <= 'z') {\n      class_name_check = true;\n    } else if (class_name_char >= '0' && class_name_char <= '9') {\n      class_name_check = true;\n    }\n  }\n  return class_name_check;\n};\n\n/*\n  Given a class and a string, return true if the string is a valid class name.\n  Return false otherwise.\n  Example:\n  isValidClassName('my_class','my_class') => true\n  isValidClassName('my_class','my_class.') => false\n*/\nconst isValidClassName_2 = (class_name, class_name_to_check) => {\n  let class_name_length = class_name.length;\n  let class_name_check = false;\n  for (let i = 0; i < class_name_to_check.length; i++) {\n    let class_name_char = class_name_to_check.charAt(i);\n    if (class_name_char >= 'A' && class_name_char <= 'Z') {\n      class_name_check = true;\n    } else if (class_name_char >= 'a' && class_name_char <= 'z') {\n      class_name_check = true;\n    } else if (class_name_char >= '0' && class_name_char <= '9') {\n      class_name_check = true;\n    }\n  }\n  return class_name_check;\n};\n\n/*\n  Given a class and a string, return true if the string is a valid class name.\n  Return false otherwise.\n  Example:\n  isValidClassName('my_class','my_class') => true\n  isValidClassName('my_class','my_class.') => false\n*/\nconst isValidClassName_3 = (class_name, class_name_to_check) => {\n  let class_name_length = class_name.length;\n  let class_name_check = false;\n  for (let i = 0; i < class_name_to_check.length; i++) {\n    let class_name_char = class_name_to_check.charAt(i);\n    if (class_name_char >= 'A' && class_name_char <= 'Z') {\n      class_name_check = true;\n    } else if (class_name_char >= 'a' && class_name_char <= 'z') {\n      class_name_check = true;\n    } else if (class_name_char >= '0' && class_name_char <= '9') {\n      class_name_check = true;\n    }\n  }\n  return class_name_check;\n};\n\n/*\n  Given a class and a string, return true if the string is a valid class name.\n  Return false otherwise.\n  Example:\n  isValidClassName('my_class','my_class') => true\n  isValidClassName('my_class','my_class.') => false\n*/\nconst isValidClassName_4 = (class_name, class_name_to_check) => {\n  let class_name_length = class_name.length;\n  let class_name_check = false;\n  for (let i = 0; i < class_name_to_check.length; i++) {\n    let class_name_char = class_name_to_check.charAt(i);\n    if (class_name_char >= 'A' && class_name_char <= 'Z') {\n      class_name_check = true;\n    } else if (class_name_char >= 'a' && class_name_char <= 'z') {\n      class_name_check = true;\n    } else if (class_name_char >= '0' && class_name_char <= '9') {\n      class_name_check = true;\n    }\n  }\n  return class_name_check;\n};\n\n/*\n  Given a class and a string, return true if the string is a valid class name.\n  Return false otherwise.\n  Example:\n  isValidClassName('my_class','my_class') => true\n  isValidClassName('my_class','my_class.') => false\n*/\nconst isValidClassName_5 = (class_name, class_name_to_check) => {\n  let class_name_length = class_name.length;\n  let class_name_check = false;\n  for (let i = 0; i < class_name_to_check.length; i++) {\n    let class_name_char = class_name_to_check.charAt(i);\n    if (class_name_char >= 'A' && class_name_char <= 'Z') {\n      class_name_check = true;\n    } else if (class_name_char >= 'a' && class_name_char <= 'z') {\n      class_name_check = true;\n    } else if (class_name_char >= '0' && class_name_char <= '9') {\n      class_name_check = true;\n    }\n  }\n  return class_name_check;\n};\n\n/*\n  Given a class and a string, return true if the string is a valid class name.\n  Return false otherwise.\n  Example:\n  isValidClassName('my_class','my_class') => true\n  isValidClassName('my_class','my_class.') => false\n*/\nconst isValidClassName_6 = (class_name, class_name_to_check) => {\n  let class_name_length = class_name.length;\n  let class_name_check = false;\n  for (let i = 0; i < class_name_to_check.length; i++) {\n    let class_name_char = class_name_to_check.charAt(i);\n    if (class_name_char >= 'A' && class_name_char <= 'Z') {\n      class_name_check = true;\n    } else if (class_name_char >= 'a' && class_name_char <= 'z') {\n      class_name_check = true;\n    } else if (class_name_char >= '0' && class_name_char <= '9') {\n"}
{"task_id": "JavaScript/154", "prompt": "/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  let aLen = a.length;\n  let bLen = b.length;\n  let aRotation = a.split('').reverse().join('');\n  let bRotation = b.split('').reverse().join('');\n  let aRotatedB = bRotation.split('').reverse().join('');\n  let aRotatedA = aRotation.split('').reverse().join('');\n  let aRotatedBRotation = aRotatedB.split('').reverse().join('');\n  let aRotatedARotation = aRotatedA.split('').reverse().join('');\n  let aRotatedBRotatedA = aRotatedBRotation.split('').reverse().join('');\n  let aRotatedARotatedB = aRotatedARotation.split('').reverse().join('');\n  let aRotatedBRotatedB = aRotatedBRotatedA.split('').reverse().join('');\n  let aRotatedBRotatedBRotation = aRotatedBRotatedB.split('').reverse().join('');\n  let aRotatedBRotatedBRotatedB = aRotatedBRotatedBRotation.split('').reverse().join('');\n  let aRotatedBRotatedBRotatedBRotation = aRotatedBRotatedBRotatedBRotation.split('').reverse().join('');\n  let aRotatedBRotatedBRotatedBRotatedBRotation = aRotatedBRotatedBRotatedBRotatedBRotation.split('').reverse().join('');\n  let aRotatedBRotatedBRotatedBRotatedBRotatedBRotation = aRotatedBRotatedBRotatedBRotatedBRotatedBRotation.split('').reverse().join('');\n  let aRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotation = aRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotation.split('').reverse().join('');\n  let aRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotation = aRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotation.split('').reverse().join('');\n  let aRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotation = aRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotation.split('').reverse().join('');\n  let aRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotation = aRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotation.split('').reverse().join('');\n  let aRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotation = aRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotation.split('').reverse().join('');\n  let aRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotation = aRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotation.split('').reverse().join('');\n  let aRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotation = aRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotation.split('').reverse().join('');\n  let aRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotation = aRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotation.split('').reverse().join('');\n  let aRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotation = aRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotation.split('').reverse().join('');\n  let aRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotation = aRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotation.split('').reverse().join('');\n  let aRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedBRotatedB"}
{"task_id": "JavaScript/155", "prompt": "/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let result = 0;\n  let digit;\n  let i;\n  let j;\n\n  for (i = 0, j = num.length; i < j; i++) {\n    digit = num.charAt(i);\n    if (digit % 2 === 0) {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst oddOddCount = (num) => {\n  let result = 0;\n  let digit;\n  let i;\n  let j;\n\n  for (i = 0, j = num.length; i < j; i++) {\n    digit = num.charAt(i);\n    if (digit % 2!== 0) {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddEvenCount = (num) => {\n  let result = 0;\n  let digit;\n  let i;\n  let j;\n\n  for (i = 0, j = num.length; i < j; i++) {\n    digit = num.charAt(i);\n    if (digit % 2 === 0 && digit % 2!== 0) {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddEvenCount(-12) ==> (1, 1)\n      evenOddEvenCount(123) ==> (1, 2)\n  */\nconst oddOddEvenCount = (num) => {\n  let result = 0;\n  let digit;\n  let i;\n  let j;\n\n  for (i = 0, j = num.length; i < j; i++) {\n    digit = num.charAt(i);\n    if (digit % 2 === 0 && digit % 2!== 0) {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddEvenCount(-12) ==> (1, 1)\n      evenOddEvenCount(123) ==> (1, 2)\n  */\nconst oddOddOddCount = (num) => {\n  let result = 0;\n  let digit;\n  let i;\n  let j;\n\n  for (i = 0, j = num.length; i < j; i++) {\n    digit = num.charAt(i);\n    if (digit % 2 === 0 && digit % 2 === 1) {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddOddEvenCount(-12) ==> (1, 1)\n      evenOddOddEvenCount(123) ==> (1, 2)\n  */\nconst oddOddOddEvenOddCount = (num) => {\n  let result = 0;\n  let digit;\n  let i;\n  let j;\n\n  for (i = 0, j = num.length; i < j; i++) {\n    digit = num.charAt(i);\n    if (digit % 2 === 0 && digit % 2 === 1 && digit % 2!== 0) {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddOddEvenOddCount(-12) ==> (1, 1)\n      evenOddOddEvenOddCount(123) ==> (1, 2)\n  */\nconst oddOddOddOddEvenOddEvenCount = (num) => {\n  let result = 0;\n  let digit;\n  let i;\n  let j;\n\n  for (i = 0, j = num.length; i < j; i++) {\n    digit = num.charAt(i);\n    if (digit % 2 === 0 && digit % 2 === 1 && digit % 2 === 2) {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddOddEvenOddEvenCount(-12) ==> (1, 1)\n      evenOddOddEvenOddEvenCount(123) ==> (1, 2)\n  */\nconst oddOddOddOddEvenOddOddCount = (num) => {\n  let result = 0;\n  let digit;\n  let i;\n  let j;\n\n  for (i = 0, j = num.length; i < j; i++) {\n    digit = num.charAt(i);\n    if (digit % 2 === 0 && digit % 2 === 1 && digit % 2 === 2) {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddOddEvenOddEvenCount(-12) ==> (1, 1)\n      evenOddOddEvenOddEvenCount(123) ==> (1, 2)\n  */\nconst oddOddOddOddEvenOddOddEvenOddCount = (num) => {\n  let result = 0;\n  let digit;\n  let i;\n  let j;\n\n  for (i = 0, j = num.length; i < j; i++) {\n    digit = num.charAt(i);\n    if (digit % 2 === 0 && digit % 2 === 1 && digit % 2 === 2) {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddOddEvenOddEvenOddOddCount(-12) ==> (1, 1)\n      evenOddOddEvenOddEvenOddCount(123) ==> (1, 2)\n  */\nconst oddOddOddOddEvenOddOddOddEvenOddCount = (num) => {\n  let result = 0;\n  let digit;\n  let i;\n  let j;\n\n  for (i = 0, j = num.length; i < j; i++) {\n    digit = num.charAt(i);\n    if (digit % 2 === 0 && digit % 2 === 1 && digit % 2 === 2) {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddOddEvenOddEvenOddOddOddOddEvenOddCount(-12) ==> (1, 1)\n      evenOddOddEvenOddEvenOddOddOddOddEvenOddCount(123) ==> (1, 2)\n  */\nconst oddOddOddOddEvenOddOddOddOddEvenOddOddCount = (num) => {\n  let result = 0;\n  let digit;\n  let i;\n  let j;\n\n  for (i = 0, j = num.length; i < j; i++) {\n    digit = num.charAt(i);\n    if (digit % 2 === 0 && digit % 2 === 1 && digit % 2 === 2) {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddOddEvenOddEvenOddOddOddOddEvenOddOddCount(-12) ==> (1, 1)\n      evenOddOddEvenOddEvenOddOddOddOddEvenOddOddCount(123) ==> (1, 2)\n  */\nconst oddOddOddEvenOddOddOddOddEvenOddOddOddEvenOddCount = (num) => {\n  let result = 0;\n  let digit;\n  let i;\n  let j;\n\n  for (i = 0, j = num.length; i < j; i++) {\n    digit = num.charAt(i);\n    if (digit % 2 === 0 && digit % 2 === 1 && digit % 2 === 2) {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddOddEvenOddEvenOddOddOddO"}
{"task_id": "JavaScript/156", "prompt": "/*\n  With a positive integer, you get your Roman number equivalent as a string and return it in lowercase letters. Limitations: 1 < = number < = 1000 Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  With a positive integer, you get your Roman number equivalent as a string and return it in lowercase letters. Limitations: 1 < = number < = 1000 Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  const romanMap = {\n    1: 'i',\n    2: 'ii',\n    3: 'iii',\n    4: 'iv',\n    5: 'v',\n    6: 'vi',\n    7: 'vii',\n    8: 'ix',\n    9: 'x',\n    10: 'xi',\n    11: 'xii',\n    12: 'xiii',\n    13: 'xiv',\n    14: 'xvi',\n    15: 'xvii',\n    16: 'ixv',\n    17: 'ixvi',\n    18: 'ixvii',\n    19: 'ixix',\n    20: 'ixx',\n    21: 'ixxi',\n    22: 'ixxii',\n    23: 'ixxiv',\n    24: 'ixxvi',\n    25: 'ixxvii',\n    26: 'ixixv',\n    27: 'ixixvi',\n    28: 'ixixvii',\n    29: 'ixixix',\n    30: 'ixixx',\n    31: 'ixixxi',\n    32: 'ixixxii',\n    33: 'ixixxiv',\n    34: 'ixixxvi',\n    35: 'ixixxvii',\n    36: 'ixixixv',\n    37: 'ixixixvi',\n    38: 'ixixixvii',\n    39: 'ixixixix',\n    40: 'ixixixx',\n    41: 'ixixixxi',\n    42: 'ixixixxii',\n    43: 'ixixixxiv',\n    44: 'ixixixxvi',\n    45: 'ixixixxvii',\n    46: 'ixixixv',\n    47: 'ixixixvi',\n    48: 'ixixixvii',\n    49: 'ixixixix',\n    50: 'ixixixx',\n    51: 'ixixixxi',\n    52: 'ixixixxii',\n    53: 'ixixixxiv',\n    54: 'ixixixxvi',\n    55: 'ixixixxvii',\n    56: 'ixixixv',\n    57: 'ixixixvi',\n    58: 'ixixixvii',\n    59: 'ixixixv',\n    60: 'ixixixvi',\n    61: 'ixixixvii',\n    62: 'ixixixv',\n    63: 'ixixixvi',\n    64: 'ixixixvii',\n    65: 'ixixixv',\n    66: 'ixixixvi',\n    67: 'ixixixvii',\n    68: 'ixixixv',\n    69: 'ixixixvi',\n    70: 'ixixixvii',\n    71: 'ixixixv',\n    72: 'ixixixvi',\n    73: 'ixixixvii',\n    74: 'ixixixv',\n    75: 'ixixixvi',\n    76: 'ixixixvii',\n    77: 'ixixixv',\n    78: 'ixixixvi',\n    79: 'ixixixvii',\n    80: 'ixixixv',\n    81: 'ixixixvi',\n    82: 'ixixixvii',\n    83: 'ixixixv',\n    84: 'ixixixvi',\n    85: 'ixixixvii',\n    86: 'ixixixv',\n    87: 'ixixixvi',\n    88: 'ixixixvii',\n    89: 'ixixixv',\n    90: 'ixixixvi',\n    91: 'ixixixvii',\n    92: 'ixixixv',\n    93: 'ixixixvi',\n    94: 'ixixixvii',\n    95: 'ixixixv',\n    96: 'ixixixvi',\n    97: 'ixixixvii',\n    98: 'ixixixv',\n    99: 'ixixixvi',\n    100: 'ixixixvii',\n  };\n  const roman = romanMap[number];\n  return roman;\n};\n\n/*\n  With a positive integer, you get your Roman numeral equivalent as a string and return it in lowercase letters. Limitations: 1 < = number < = 1000 Examples:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLI'\n  >>> intToRoman(426) == 'CDXVI'\n  */\nconst intToRoman = (number) => {\n  const romanMap = {\n    1: 'X',\n    2: 'IX',\n    3: 'II',\n    4: 'III',\n    5: 'IV',\n    6: 'V',\n    7: 'VI',\n    8: 'IX',\n    9: 'X',\n    10: 'XI',\n    11: 'XII',\n    12: 'XIII',\n    13: 'XIV',\n    14: 'XV',\n    15: 'XVI',\n    16: 'XVII',\n    17: 'XVIII',\n    18: 'XIX',\n    19: 'XIXI',\n    20: 'XIXII',\n    21: 'XIXIII',\n    22: 'XIXIV',\n    23: 'XIXV',\n    24: 'XIXVI',\n    25: 'XIXVII',\n    26: 'XIXVIII',\n    27: 'XIXIX',\n    28: 'XIXIXI',\n    29: 'XIXIXII',\n    30: 'XIXIXIII',\n    31: 'XIXIXIV',\n    32: 'XIXX',\n    33: 'XIXXI',\n    34: 'XIXXII',\n    35: 'XIXXIII',\n    36: 'XIXIXIV',\n    37: 'XIXXV',\n    38: 'XIXXVI',\n    39: 'XIXXVII',\n    40: 'XIXXVIII',\n    41: 'XIXIXIX',\n    42: 'XIXIXI',\n    43: 'XIXIXII',\n    44: 'XIXIXIII',\n    45: 'XIXIXIV',\n    46: 'XIXXV',\n    47: 'XIXXVI',\n    48: 'XIXXVII',\n    49: 'XIXXVIII',\n    50: 'XIXIXIX',\n    51: 'XIXIXI',\n    52: 'XIXIXII',\n    53: 'XIXIXIII',\n    54: 'XIXIXIV',\n    55: 'XIXXV',\n    56: 'XIXXVI',\n    57: 'XIXXVII',\n    58: 'XIXXVIII',\n    59: 'XIXIXIX',\n"}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the length of the three sides of a triangle. Returns true if the three sides form a right-angled triangle, otherwise wrong. A right-angled triangle is a triangle in which an angle is right-angled or 90 degrees.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n Given the length of the three sides of a triangle. Returns true if the three sides form a right-angled triangle, otherwise wrong. A right-angled triangle is a triangle in which an angle is right-angled or 90 degrees.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab * ac - bc * bc;\n};\n\n/*\n Given the length of the three sides of a rectangle. Returns true if the three sides form a right-angled rectangle, otherwise wrong. A right-angled rectangle is a rectangle in which an angle is right-angled or 90 degrees.\n  Example:\n  rightAngleRectangle(3, 4, 5) == true\n  rightAngleRectangle(1, 2, 3) == false\n  */\nconst rightAngleRectangle = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab * ac - bc * bc;\n};\n\n/*\n Given the length of the three sides of a circle. Returns true if the three sides form a right-angled circle, otherwise wrong. A right-angled circle is a circle in which an angle is right-angled or 90 degrees.\n  Example:\n  rightAngleCircle(3, 4, 5) == true\n  rightAngleCircle(1, 2, 3) == false\n  */\nconst rightAngleCircle = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab * ac - bc * bc;\n};\n\n/*\n Given the length of the three sides of a square. Returns true if the three sides form a right-angled square, otherwise wrong. A right-angled square is a square in which an angle is right-angled or 90 degrees.\n  Example:\n  rightAngleSquare(3, 4, 5) == true\n  rightAngleSquare(1, 2, 3) == false\n  */\nconst rightAngleSquare = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab * ac - bc * bc;\n};\n\n/*\n Given the length of the three sides of a pentagon. Returns true if the three sides form a right-angled pentagon, otherwise wrong. A right-angled pentagon is a pentagon in which an angle is right-angled or 90 degrees.\n  Example:\n  rightAnglePentagon(3, 4, 5) == true\n  rightAnglePentagon(1, 2, 3) == false\n  */\nconst rightAnglePentagon = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab * ac - bc * bc;\n};\n\n/*\n Given the length of the three sides of a hexagon. Returns true if the three sides form a right-angled hexagon, otherwise wrong. A right-angled hexagon is a hexagon in which an angle is right-angled or 90 degrees.\n  Example:\n  rightAngleHexagon(3, 4, 5) == true\n  rightAngleHexagon(1, 2, 3) == false\n  */\nconst rightAngleHexagon = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab * ac - bc * bc;\n};\n\n/*\n Given the length of the three sides of a heptagon. Returns true if the three sides form a right-angled heptagon, otherwise wrong. A right-angled heptagon is a heptagon in which an angle is right-angled or 90 degrees.\n  Example:\n  rightAngleHeptagon(3, 4, 5) == true\n  rightAngleHeptagon(1, 2, 3) == false\n  */\nconst rightAngleHeptagon = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab * ac - bc * bc;\n};\n\n/*\n Given the length of the three sides of a octagon. Returns true if the three sides form a right-angled octagon, otherwise wrong. A right-angled octagon is a octagon in which an angle is right-angled or 90 degrees.\n  Example:\n  rightAngleOctagon(3, 4, 5) == true\n  rightAngleOctagon(1, 2, 3) == false\n  */\nconst rightAngleOctagon = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab * ac - bc * bc;\n};\n\n/*\n Given the length of the three sides of a decagon. Returns true if the three sides form a right-angled decagon, otherwise wrong. A right-angled decagon is a decagon in which an angle is right-angled or 90 degrees.\n  Example:\n  rightAngleDecagon(3, 4, 5) == true\n  rightAngleDecagon(1, 2, 3) == false\n  */\nconst rightAngleDecagon = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab * ac - bc * bc;\n};\n\n/*\n Given the length of the three sides of a dodecagon. Returns true if the three sides form a right-angled dodecagon, otherwise wrong. A right-angled dodecagon is a dodecagon in which an angle is right-angled or 90 degrees.\n  Example:\n  rightAngleDodecagon(3, 4, 5) == true\n  rightAngleDodecagon(1, 2, 3) == false\n  */\nconst rightAngleDodecagon = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab * ac - bc * bc;\n};\n\n/*\n Given the length of the three sides of a hexadecagon. Returns true if the three sides form a right-angled hexadecagon, otherwise wrong. A right-angled hexadecagon is a hexadecagon in which an angle is right-angled or 90 degrees.\n  Example:\n  rightAngleHexadecagon(3, 4, 5) == true\n  rightAngleHexadecagon(1, 2, 3) == false\n  */\nconst rightAngleHexadecagon = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab * ac - bc * bc;\n};\n\n/*\n Given the length of the three sides of a hectare. Returns true if the three sides form a right-angled hectare, otherwise wrong. A right-angled hectare is a hectare in which an angle is right-angled or 90 degrees.\n  Example:\n  rightAngleHeptarea(3, 4, 5) == true\n  rightAngleHeptarea(1, 2, 3) == false\n  */\nconst rightAngleHeptarea = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab * ac - bc * bc;\n};\n\n/*\n Given the length of the three sides of a decahectare. Returns true if the three sides form a right-angled decahectare, otherwise wrong. A right-angled decahectare is a decahectare in which an angle is right-angled or 90 degrees.\n  Example:\n  rightAngleDecahectare(3, 4, 5) == true\n  rightAngleDecahectare(1, 2, 3) == false\n  */\nconst rightAngleDecahectare = (a, b, c) => {\n  const ab"}
{"task_id": "JavaScript/158", "prompt": "/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  let maxLength = 0;\n  let maxWord = '';\n  let maxChar = 0;\n  let maxCharCount = 0;\n  let maxCharCount2 = 0;\n  let maxCharCount3 = 0;\n  let maxCharCount4 = 0;\n  let maxCharCount5 = 0;\n  let maxCharCount6 = 0;\n  let maxCharCount7 = 0;\n  let maxCharCount8 = 0;\n  let maxCharCount9 = 0;\n  let maxCharCount10 = 0;\n  let maxCharCount11 = 0;\n  let maxCharCount12 = 0;\n  let maxCharCount13 = 0;\n  let maxCharCount14 = 0;\n  let maxCharCount15 = 0;\n  let maxCharCount16 = 0;\n  let maxCharCount17 = 0;\n  let maxCharCount18 = 0;\n  let maxCharCount19 = 0;\n  let maxCharCount20 = 0;\n  let maxCharCount21 = 0;\n  let maxCharCount22 = 0;\n  let maxCharCount23 = 0;\n  let maxCharCount24 = 0;\n  let maxCharCount25 = 0;\n  let maxCharCount26 = 0;\n  let maxCharCount27 = 0;\n  let maxCharCount28 = 0;\n  let maxCharCount29 = 0;\n  let maxCharCount30 = 0;\n  let maxCharCount31 = 0;\n  let maxCharCount32 = 0;\n  let maxCharCount33 = 0;\n  let maxCharCount34 = 0;\n  let maxCharCount35 = 0;\n  let maxCharCount36 = 0;\n  let maxCharCount37 = 0;\n  let maxCharCount38 = 0;\n  let maxCharCount39 = 0;\n  let maxCharCount40 = 0;\n  let maxCharCount41 = 0;\n  let maxCharCount42 = 0;\n  let maxCharCount43 = 0;\n  let maxCharCount44 = 0;\n  let maxCharCount45 = 0;\n  let maxCharCount46 = 0;\n  let maxCharCount47 = 0;\n  let maxCharCount48 = 0;\n  let maxCharCount49 = 0;\n  let maxCharCount50 = 0;\n  let maxCharCount51 = 0;\n  let maxCharCount52 = 0;\n  let maxCharCount53 = 0;\n  let maxCharCount54 = 0;\n  let maxCharCount55 = 0;\n  let maxCharCount56 = 0;\n  let maxCharCount57 = 0;\n  let maxCharCount58 = 0;\n  let maxCharCount59 = 0;\n  let maxCharCount60 = 0;\n  let maxCharCount61 = 0;\n  let maxCharCount62 = 0;\n  let maxCharCount63 = 0;\n  let maxCharCount64 = 0;\n  let maxCharCount65 = 0;\n  let maxCharCount66 = 0;\n  let maxCharCount67 = 0;\n  let maxCharCount68 = 0;\n  let maxCharCount69 = 0;\n  let maxCharCount70 = 0;\n  let maxCharCount71 = 0;\n  let maxCharCount72 = 0;\n  let maxCharCount73 = 0;\n  let maxCharCount74 = 0;\n  let maxCharCount75 = 0;\n  let maxCharCount76 = 0;\n  let maxCharCount77 = 0;\n  let maxCharCount78 = 0;\n  let maxCharCount79 = 0;\n  let maxCharCount80 = 0;\n  let maxCharCount81 = 0;\n  let maxCharCount82 = 0;\n  let maxCharCount83 = 0;\n  let maxCharCount84 = 0;\n  let maxCharCount85 = 0;\n  let maxCharCount86 = 0;\n  let maxCharCount87 = 0;\n  let maxCharCount88 = 0;\n  let maxCharCount89 = 0;\n  let maxCharCount90 = 0;\n  let maxCharCount91 = 0;\n  let maxCharCount92 = 0;\n  let maxCharCount93 = 0;\n  let maxCharCount94 = 0;\n  let maxCharCount95 = 0;\n  let maxCharCount96 = 0;\n  let maxCharCount97 = 0;\n  let maxCharCount98 = 0;\n  let maxCharCount99 = 0;\n  let maxCharCount100 = 0;\n  let maxCharCount101 = 0;\n  let maxCharCount102 = 0;\n  let maxCharCount103 = 0;\n  let maxCharCount104 = 0;\n  let maxCharCount105 = 0;\n  let maxCharCount106 = 0;\n  let maxCharCount107 = 0;\n  let maxCharCount108 = 0;\n  let maxCharCount109 = 0;\n  let maxCharCount110 = 0;\n  let maxCharCount111 = 0;\n  let maxCharCount112 = 0;\n  let maxCharCount113 = 0;\n  let maxCharCount114 = 0;\n  let maxCharCount115 = 0;\n  let maxCharCount116 = 0;\n  let maxCharCount117 = 0;\n  let maxCharCount118 = 0;\n  let maxCharCount119 = 0;\n  let maxCharCount120 = 0;\n  let maxCharCount121 = 0;\n  let maxCharCount122 = 0;\n  let maxCharCount123 = 0;\n  let maxCharCount124 = 0;\n  let maxCharCount125 = 0;\n  let maxCharCount126 = 0;\n  let maxCharCount127 = 0;\n  let maxCharCount128 = 0;\n  let maxCharCount129 = 0;\n  let maxCharCount130 = 0;\n  let maxCharCount131 = 0;\n  let maxCharCount132 = 0;\n  let maxCharCount133 = 0;\n  let maxCharCount134 = 0;\n  let maxCharCount135 = 0;\n  let maxCharCount136 = 0;\n  let maxCharCount137 = 0;\n  let maxCharCount138 = 0;\n  let maxCharCount139 = 0;\n  let maxCharCount140 = 0;\n  let maxCharCount141 = 0;\n  let maxCharCount142 = 0;\n  let maxCharCount143 = 0;\n  let maxCharCount144 = 0;\n  let maxCharCount145 = 0;\n  let maxCharCount146 = 0;\n  let maxCharCount147 = 0;\n  let maxCharCount148 = 0;\n  let maxCharCount149 = 0;\n  let maxCharCount150 = 0;\n  let maxCharCount151 = 0;\n  let maxCharCount152 = 0;\n  let maxCharCount153 = 0;\n  let maxCharCount154 = 0;\n  let maxCharCount155 = 0;\n  let maxCharCount156 = 0;\n  let maxCharCount157 = 0;\n  let maxCharCount158 = 0;\n  let maxCharCount159 = 0;\n  let maxCharCount160 = 0;\n  let maxCharCount161 = 0;\n  let maxCharCount162 = 0;\n  let maxCharCount163 = 0;\n  let maxCharCount164 = 0;\n  let maxCharCount165 = 0;\n  let maxCharCount166 = 0;\n  let maxCharCount167 = 0;\n  let maxCharCount168 = 0;\n  let maxCharCount169 = 0;\n  let maxCharCount170 = 0;\n  let maxCharCount171 = 0;\n  let maxCharCount172 = 0;\n  let maxCharCount173 = 0;\n  let maxCharCount174 = 0;\n  let maxCharCount175 = 0;\n  let maxCharCount176 = 0;\n  let maxCharCount177 = 0;\n  let maxCharCount178 = 0;\n  let maxCharCount179 = 0;\n  let maxCharCount180 = 0;\n  let maxCharCount181 = 0;\n  let maxCharCount182 = 0;\n  let maxCharCount183 = 0;\n  let maxCharCount184 = 0;\n  let maxCharCount185 = 0;\n  let maxCharCount186 = 0;\n  let maxCharCount187 = 0;\n  let maxCharCount188 = 0;\n  let maxCharCount189 = 0;\n  let maxCharCount190 = 0;\n  let maxCharCount191 = 0;\n  let maxCharCount192 = 0;\n  let maxCharCount193 = 0;\n  let maxCharCount194 = 0;\n  let maxCharCount195 = 0;\n  let maxCharCount196 = 0;\n  let maxCharCount197 = 0;\n  let maxCharCount198 = 0;\n  let maxCharCount199 = 0;\n  let maxCharCount200 = 0;\n  let maxCharCount201 = 0;\n  let maxCharCount202 = 0;\n  let maxCharCount203 = 0;"}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*\n  You're a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const carrots = Math.ceil(number / need);\n  const remainingCarrots = Math.ceil(remaining / carrots);\n  const remainingCarrotsLeft = remaining % carrots;\n  const remainingCarrotsRemaining = remaining - remainingCarrotsLeft * carrots;\n  const remainingCarrotsRemainingCarrots = remainingCarrotsRemaining % carrots;\n  const remainingCarrotsRemainingCarrotsLeft = remainingCarrotsRemainingCarrots % carrots;\n  const remainingCarrotsRemainingCarrotsRemaining = remainingCarrotsRemainingCarrots - remainingCarrotsRemainingCarrotsLeft;\n  const remainingCarrotsRemainingCarrotsRemainingCarrots = remainingCarrotsRemainingCarrotsRemainingCarrots - remainingCarrotsRemainingCarrotsLeft;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsLeft = remainingCarrotsRemainingCarrotsRemainingCarrotsLeft % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsRemaining = remainingCarrotsRemainingCarrotsRemainingCarrotsRemaining % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsLeft = remainingCarrotsRemainingCarrotsRemainingCarrotsLeft % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsRemaining = remainingCarrotsRemainingCarrotsRemainingCarrotsRemaining % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsLeft = remainingCarrotsRemainingCarrotsRemainingCarrotsLeft % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsRemaining = remainingCarrotsRemainingCarrotsRemainingCarrotsRemaining % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsLeft = remainingCarrotsRemainingCarrotsRemainingCarrotsRemainingLeft % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsRemaining = remainingCarrotsRemainingCarrotsRemainingCarrotsRemainingRemaining % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsLeft = remainingCarrotsRemainingCarrotsRemainingCarrotsRemainingLeft % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsRemaining = remainingCarrotsRemainingCarrotsRemainingCarrotsRemainingRemaining % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsLeft = remainingCarrotsRemainingCarrotsRemainingCarrotsRemainingLeft % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsRemaining = remainingCarrotsRemainingCarrotsRemainingCarrotsRemainingRemaining % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsLeft = remainingCarrotsRemainingCarrotsRemainingCarrotsRemainingLeft % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsRemaining = remainingCarrotsRemainingCarrotsRemainingCarrotsRemainingRemaining % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsLeft = remainingCarrotsRemainingCarrotsRemainingCarrotsRemainingLeft % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsRemaining = remainingCarrotsRemainingCarrotsRemainingCarrotsRemainingRemaining % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsLeft = remainingCarrotsRemainingCarrotsRemainingCarrotsRemainingLeft % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsRemaining = remainingCarrotsRemainingCarrotsRemainingCarrotsRemainingRemaining % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsLeft = remainingCarrotsRemainingCarrotsRemainingCarrotsRemainingLeft % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsRemaining = remainingCarrotsRemainingCarrotsRemainingCarrotsRemainingRemaining % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsLeft = remainingCarrotsRemainingCarrotsRemainingCarrotsRemainingLeft % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsRemaining = remainingCarrotsRemainingCarrotsRemainingCarrotsRemainingRemaining % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsLeft = remainingCarrotsRemainingCarrotsRemainingCarrotsRemainingLeft % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsRemaining = remainingCarrotsRemainingCarrotsRemainingCarrotsRemainingRemaining % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsLeft = remainingCarrotsRemainingCarrotsRemainingCarrotsRemainingLeft % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsRemaining = remainingCarrotsRemainingCarrotsRemainingCarrotsRemainingRemaining % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsLeft = remainingCarrotsRemainingCarrotsRemainingCarrotsRemainingLeft % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsRemaining = remainingCarrotsRemainingCarrotsRemainingCarrotsRemainingRemaining % carrots;\n  const remainingCarrotsRemainingCarrotsRemainingCarrotsLeft = remainingCarrotsRemainingCarrotsRemainingCarrotsRemainingLeft % carrots;\n  const remainingCarrotsRemain"}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n  while (operandIndex < operandLength) {\n    if (operatorIndex < operatorLength) {\n      result += operator[operatorIndex] * operand[operandIndex];\n      operatorIndex++;\n    } else {\n      result += operand[operandIndex];\n      operandIndex++;\n    }\n  }\n  return result;\n};\n\n/**\n * Given two lists operator, and operand. The first list has basic algebra operations, and \n * and the second list is a list of integers. Use the two given lists to build the algebric \n * expression and return the evaluation of this expression.\n\n * The basic algebra operations:\n * Addition ( + ) \n * Subtraction ( - ) \n * Multiplication ( * ) \n * Floor division ( // ) \n * Exponentiation ( ** ) \n\n * Example:\n * operator['+', '*', '-']\n * array = [2, 3, 4, 5]\n * result = 2 + 3 * 4 - 5\n * => result = 9\n\n * Note:\n * The length of operator list is equal to the length of operand list minus one.\n * Operand is a list of of non-negative integers.\n * Operator list has at least one operator, and operand list has at least two operands.\n\n */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n  while (operandIndex < operandLength) {\n    if (operatorIndex < operatorLength) {\n      result += operator[operatorIndex] * operand[operandIndex];\n      operatorIndex++;\n    } else {\n      result += operand[operandIndex];\n      operandIndex++;\n    }\n  }\n  return result;\n};\n\n/**\n * Given two lists operator, and operand. The first list has basic algebra operations, and \n * and the second list is a list of integers. Use the two given lists to build the algebric \n * expression and return the evaluation of this expression.\n\n * The basic algebra operations:\n * Addition ( + ) \n * Subtraction ( - ) \n * Multiplication ( * ) \n * Floor division ( // ) \n * Exponentiation ( ** ) \n\n * Example:\n * operator['+', '*', '-']\n * array = [2, 3, 4, 5]\n * result = 2 + 3 * 4 - 5\n * => result = 9\n\n * Note:\n * The length of operator list is equal to the length of operand list minus one.\n * Operand is a list of of non-negative integers.\n * Operator list has at least one operator, and operand list has at least two operands.\n\n */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n  while (operandIndex < operandLength) {\n    if (operatorIndex < operatorLength) {\n      result += operator[operatorIndex] * operand[operandIndex];\n      operatorIndex++;\n    } else {\n      result += operand[operandIndex];\n      operandIndex++;\n    }\n  }\n  return result;\n};\n\n/**\n * Given two lists operator, and operand. The first list has basic algebra operations, and \n * and the second list is a list of integers. Use the two given lists to build the algebric \n * expression and return the evaluation of this expression.\n\n * The basic algebra operations:\n * Addition ( + ) \n * Subtraction ( - ) \n * Multiplication ( * ) \n * Floor division ( // ) \n * Exponentiation ( ** ) \n\n * Example:\n * operator['+', '*', '-']\n * array = [2, 3, 4, 5]\n * result = 2 + 3 * 4 - 5\n * => result = 9\n\n * Note:\n * The length of operator list is equal to the length of operand list minus one.\n * Operand is a list of of non-negative integers.\n * Operator list has at least one operator, and operand list has at least two operands.\n\n */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n  while (operandIndex < operandLength) {\n    if (operatorIndex < operatorLength) {\n      result += operator[operatorIndex] * operand[operandIndex];\n      operatorIndex++;\n    } else {\n      result += operand[operandIndex];\n      operandIndex++;\n    }\n  }\n  return result;\n};\n\n/**\n * Given two lists operator, and operand. The first list has basic algebra operations, and \n * and the second list is a list of integers. Use the two given lists to build the algebric \n * expression and return the evaluation of this expression.\n\n * The basic algebra operations:\n * Addition ( + ) \n * Subtraction ( - ) \n * Multiplication ( * ) \n * Floor division ( // ) \n * Exponentiation ( ** ) \n\n * Example:\n * operator['+', '*', '-']\n * array = [2, 3, 4, 5]\n * result = 2 + 3 * 4 - 5\n * => result = 9\n\n * Note:\n * The length of operator list is equal to the length of operand list minus one.\n * Operand is a list of of non-negative integers.\n * Operator list has at least one operator, and operand list has at least two operands.\n\n */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n  while (operandIndex < operandLength) {\n    if (operatorIndex < operatorLength) {\n      result += operator[operatorIndex] * operand[operandIndex];\n      operatorIndex++;\n    } else {\n      result += operand[operandIndex];\n      operandIndex++;\n    }\n  }\n  return result;\n};\n\n/**\n * Given two lists operator, and operand. The first list has basic algebra operations, and \n * and the second list is a list of integers. Use the two given lists to build the algebric \n * expression and return the evaluation of this expression.\n\n * The basic algebra operations:\n * Addition ( + ) \n * Subtraction ( - ) \n * Multiplication ( * ) \n * Floor division ( // ) \n * Exponentiation ( ** ) \n\n * Example:\n * operator['+', '*', '-']\n * array = [2, 3, 4, 5]\n * result = 2 + 3 * 4 - 5\n * => result = 9\n\n * Note:\n * The length of operator list is equal to the length of operand list minus one.\n * Operand is a list of of non-negative integers.\n * Operator list has at least one operator, and operand list has at least two operands.\n\n */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n  while (operandIndex < operandLength) {\n    if (operatorIndex < operatorLength) {\n      result += operator[operatorIndex] * operand[operandIndex];\n      operatorIndex++;\n    } else {\n      result += operand[operandIndex];\n      operandIndex++;\n    }\n"}
{"task_id": "JavaScript/161", "prompt": "/*YIf s [i] is a letter, the uppercase letter is reversed from the bottom to the top or vice versa, otherwise it remains as it is. If the string contains no letters, the string is reversed. The function should return the resulting string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*YIf s [i] is a letter, the uppercase letter is reversed from the bottom to the top or vice versa, otherwise it remains as it is. If the string contains no letters, the string is reversed. The function should return the resulting string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let result = '';\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let temp = '';\n  let temp2 = '';\n  let temp3 = '';\n  let temp4 = '';\n  let temp5 = '';\n  let temp6 = '';\n  let temp7 = '';\n  let temp8 = '';\n  let temp9 = '';\n  let temp10 = '';\n  let temp11 = '';\n  let temp12 = '';\n  let temp13 = '';\n  let temp14 = '';\n  let temp15 = '';\n  let temp16 = '';\n  let temp17 = '';\n  let temp18 = '';\n  let temp19 = '';\n  let temp20 = '';\n  let temp21 = '';\n  let temp22 = '';\n  let temp23 = '';\n  let temp24 = '';\n  let temp25 = '';\n  let temp26 = '';\n  let temp27 = '';\n  let temp28 = '';\n  let temp29 = '';\n  let temp30 = '';\n  let temp31 = '';\n  let temp32 = '';\n  let temp33 = '';\n  let temp34 = '';\n  let temp35 = '';\n  let temp36 = '';\n  let temp37 = '';\n  let temp38 = '';\n  let temp39 = '';\n  let temp40 = '';\n  let temp41 = '';\n  let temp42 = '';\n  let temp43 = '';\n  let temp44 = '';\n  let temp45 = '';\n  let temp46 = '';\n  let temp47 = '';\n  let temp48 = '';\n  let temp49 = '';\n  let temp50 = '';\n  let temp51 = '';\n  let temp52 = '';\n  let temp53 = '';\n  let temp54 = '';\n  let temp55 = '';\n  let temp56 = '';\n  let temp57 = '';\n  let temp58 = '';\n  let temp59 = '';\n  let temp60 = '';\n  let temp61 = '';\n  let temp62 = '';\n  let temp63 = '';\n  let temp64 = '';\n  let temp65 = '';\n  let temp66 = '';\n  let temp67 = '';\n  let temp68 = '';\n  let temp69 = '';\n  let temp70 = '';\n  let temp71 = '';\n  let temp72 = '';\n  let temp73 = '';\n  let temp74 = '';\n  let temp75 = '';\n  let temp76 = '';\n  let temp77 = '';\n  let temp78 = '';\n  let temp79 = '';\n  let temp80 = '';\n  let temp81 = '';\n  let temp82 = '';\n  let temp83 = '';\n  let temp84 = '';\n  let temp85 = '';\n  let temp86 = '';\n  let temp87 = '';\n  let temp88 = '';\n  let temp89 = '';\n  let temp90 = '';\n  let temp91 = '';\n  let temp92 = '';\n  let temp93 = '';\n  let temp94 = '';\n  let temp95 = '';\n  let temp96 = '';\n  let temp97 = '';\n  let temp98 = '';\n  let temp99 = '';\n  let temp100 = '';\n  let temp101 = '';\n  let temp102 = '';\n  let temp103 = '';\n  let temp104 = '';\n  let temp105 = '';\n  let temp106 = '';\n  let temp107 = '';\n  let temp108 = '';\n  let temp109 = '';\n  let temp110 = '';\n  let temp111 = '';\n  let temp112 = '';\n  let temp113 = '';\n  let temp114 = '';\n  let temp115 = '';\n  let temp116 = '';\n  let temp117 = '';\n  let temp118 = '';\n  let temp119 = '';\n  let temp120 = '';\n  let temp121 = '';\n  let temp122 = '';\n  let temp123 = '';\n  let temp124 = '';\n  let temp125 = '';\n  let temp126 = '';\n  let temp127 = '';\n  let temp128 = '';\n  let temp129 = '';\n  let temp130 = '';\n  let temp131 = '';\n  let temp132 = '';\n  let temp133 = '';\n  let temp134 = '';\n  let temp135 = '';\n  let temp136 = '';\n  let temp137 = '';\n  let temp138 = '';\n  let temp139 = '';\n  let temp140 = '';\n  let temp141 = '';\n  let temp142 = '';\n  let temp143 = '';\n  let temp144 = '';\n  let temp145 = '';\n  let temp146 = '';\n  let temp147 = '';\n  let temp148 = '';\n  let temp149 = '';\n  let temp150 = '';\n  let temp151 = '';\n  let temp152 = '';\n  let temp153 = '';\n  let temp154 = '';\n  let temp155 = '';\n  let temp156 = '';\n  let temp157 = '';\n  let temp158 = '';\n  let temp159 = '';\n  let temp160 = '';\n  let temp161 = '';\n  let temp162 = '';\n  let temp163 = '';\n  let temp164 = '';\n  let temp165 = '';\n  let temp166 = '';\n  let temp167 = '';\n  let temp168 = '';\n  let temp169 = '';\n  let temp170 = '';\n  let temp171 = '';\n  let temp172 = '';\n  let temp173 = '';\n  let temp174 = '';\n  let temp175 = '';\n  let temp176 = '';\n  let temp177 = '';\n  let temp178 = '';\n  let temp179 = '';\n  let temp180 = '';\n  let temp181 = '';\n  let temp182 = '';\n  let temp183 = '';\n  let temp184 = '';\n  let temp185 = '';\n  let temp186 = '';\n  let temp187 = '';\n  let temp188 = '';\n  let temp189 = '';\n  let temp190 = '';\n  let temp191 = '';\n  let temp192 = '';\n  let temp193 = '';\n  let temp194 = '';\n  let temp195 = '';\n  let temp196 = '';\n  let temp197 = '';\n  let temp198 = '';\n  let temp199 = '';\n  let temp200 = '';\n  let temp201 = '';\n  let temp202 = '';\n  let temp203 = '';\n  let temp204 = '';\n  let temp205 = '';\n  let temp206 = '';\n  let temp207 = '';\n  let temp208 = '';\n  let temp209 = '';\n  let temp210 = '';\n  let temp211 = '';\n  let temp212 = '';\n  let temp213 = '';\n  let temp214 = '';\n  let temp215 = '';\n  let temp216 = '';\n  let temp217 = '';\n  let temp218 = '';\n  let temp219 = '';\n  let temp220 = '';\n  let temp221 = '';\n  let temp222 = '';\n  let temp223 = '';\n  let temp224 = '';\n  let temp225 = '';\n  let temp226 = '';\n  let temp227 = '';\n  let temp228 = '';\n  let temp229 = '';\n  let temp230 = '';\n  let temp231 = '';\n  let temp232 = '';\n  let temp233 = '';\n  let temp234 = '';\n  let temp235 = '';\n  let temp236 = '';\n  let temp237 = '';\n  let temp238 = '';\n  let temp239 = '';\n  let temp240 = '';\n  let temp241 = '';\n  let temp242 = '';\n  let temp243 = '';\n  let temp244 = '';\n  let temp245 = '';\n  let temp246 = '';\n  let temp247 = '';\n  let temp248 = '';\n  let temp249 = '';\n  let temp250 = '';\n  let temp251 = '';\n  let temp252 = '';\n  let temp253 = '';\n  let temp254 = '';\n  let temp255 = '';\n  let temp256 = '';\n  let temp257 = '';\n  let temp258 = '';\n  let temp259 = '';\n  let temp260 = '';\n  let temp261 = '';\n  let temp262 = '';\n  let temp263 = '';\n  let temp264 = '';\n  let temp265 = '';\n  let temp266 = '';\n  let temp267 = '';\n  let temp268 = '';\n  let temp269 = '';\n  let temp270 = '';\n  let temp271 = '';\n  let temp272 = '';\n  let temp273 = '';\n  let temp274 = '';\n  let temp275 = '';\n  let temp276 = '';\n  let temp277 = '';\n  let temp278 = '';\n  let temp"}
{"task_id": "JavaScript/162", "prompt": "/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return 0\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5Hex = (text) => {\n  if (!text) {\n    return 0\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToMd5Hex('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5HexString = (text) => {\n  if (!text) {\n    return 0\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToMd5HexString('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5HexStringHex = (text) => {\n  if (!text) {\n    return 0\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToMd5HexStringHex('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5HexStringHexString = (text) => {\n  if (!text) {\n    return 0\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToMd5HexStringHexString('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5HexStringHexStringHexString = (text) => {\n  if (!text) {\n    return 0\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToMd5HexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexStringHexString"}
{"task_id": "JavaScript/163", "prompt": "/*\n  For two positive integers a and b, return the even digits between a and b in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  For two positive integers a and b, return the even digits between a and b in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const result = [];\n  let i = a;\n  let j = 0;\n  while (i > 0) {\n    result.push(j % 10);\n    j = Math.floor(j / 10);\n    i++;\n  }\n  return result;\n};\n\n/**\n  Given a number n, return the largest power of 10 greater than or equal to n.\n\n  For example:\n  powerOf10(2) => 2\n  powerOf10(10) => 10\n  powerOf10(100) => 100\n  powerOf10(1000) => 1000\n  powerOf10(10000) => 10000\n  powerOf10(100000) => 100000\n  powerOf10(1000000) => 1000000\n  powerOf10(10000000) => 10000000\n  powerOf10(100000000) => 100000000\n  powerOf10(1000000000) => 1000000000\n  powerOf10(10000000000) => 10000000000\n  powerOf10(100000000000) => 100000000000\n  powerOf10(1000000000000) => 1000000000000\n  powerOf10(10000000000000) => 10000000000000\n  powerOf10(100000000000000) => 100000000000000\n  powerOf10(1000000000000000) => 1000000000000000\n  powerOf10(10000000000000000) => 10000000000000000\n  powerOf10(100000000000000000) => 100000000000000000\n  powerOf10(1000000000000000000) => 1000000000000000000\n  powerOf10(10000000000000000000) => 10000000000000000000\n  powerOf10(100000000000000000000) => 100000000000000000000\n  powerOf10(1000000000000000000000) => 1000000000000000000000\n  powerOf10(10000000000000000000000) => 10000000000000000000000\n  powerOf10(100000000000000000000000) => 100000000000000000000000\n  powerOf10(1000000000000000000000000) => 1000000000000000000000000\n  powerOf10(10000000000000000000000000) => 10000000000000000000000000\n  powerOf10(100000000000000000000000000) => 100000000000000000000000000\n  powerOf10(1000000000000000000000000000) => 1000000000000000000000000000\n  powerOf10(10000000000000000000000000000) => 10000000000000000000000000000\n  powerOf10(100000000000000000000000000000) => 100000000000000000000000000000\n  powerOf10(1000000000000000000000000000000) => 1000000000000000000000000000000\n  powerOf10(10000000000000000000000000000000) => 10000000000000000000000000000000\n  powerOf10(100000000000000000000000000000000) => 100000000000000000000000000000000\n  powerOf10(1000000000000000000000000000000000) => 1000000000000000000000000000000000\n  powerOf10(10000000000000000000000000000000000) => 10000000000000000000000000000000000\n  powerOf10(100000000000000000000000000000000000) => 100000000000000000000000000000000000\n  powerOf10(1000000000000000000000000000000000000) => 1000000000000000000000000000000000000\n  powerOf10(10000000000000000000000000000000000000) => 10000000000000000000000000000000000000\n  powerOf10(100000000000000000000000000000000000000) => 100000000000000000000000000000000000000\n  powerOf10(1000000000000000000000000000000000000000) => 1000000000000000000000000000000000000000\n  powerOf10(10000000000000000000000000000000000000000) => 10000000000000000000000000000000000000000\n  powerOf10(100000000000000000000000000000000000000000) => 100000000000000000000000000000000000000000\n  powerOf10(1000000000000000000000000000000000000000000) => 1000000000000000000000000000000000000000000\n  powerOf10(10000000000000000000000000000000000000000000) => 10000000000000000000000000000000000000000000\n  powerOf10(100000000000000000000000000000000000000000000) => 100000000000000000000000000000000000000000000\n  powerOf10(1000000000000000000000000000000000000000000000) => 1000000000000000000000000000000000000000000000\n  powerOf10(10000000000000000000000000000000000000000000000) => 10000000000000000000000000000000000000000000000\n  powerOf10(100000000000000000000000000000000000000000000000) => 100000000000000000000000000000000000000000000000\n  powerOf10(1000000000000000000000000000000000000000000000000) => 1000000000000000000000000000000000000000000000000\n  powerOf10(10000000000000000000000000000000000000000000000000) => 10000000000000000000000000000000000000000000000000\n  powerOf10(100000000000000000000000000000000000000000000000000) => 100000000000000000000000000000000000000000000000000\n  powerOf10(1000000000000000000000000000000000000000000000000000) => 1000000000000000000000000000000000000000000000000000\n  powerOf10(10000000000000000000000000000000000000000000000000000) => 10000000000000000000000000000000000000000000000000000\n  powerOf10(100000000000000000000000000000000000000000000000000000) => 100000000000000000000000000000000000000000000000000000\n  powerOf10(1000000000000000000000000000000000000000000000000000000) => 1000000000000000000000000000000000000000000000000000000\n  powerOf10(10000000000000000000000000000000000000000000000000000000) => 10000000000000000000000000000000000000000000000000000000\n  powerOf10(100000000000000000000000000000000000000000000000000000000) => 100000000000000000000000000000000000000000000000000000000\n  powerOf10(1000000000000000000000000000000000000000000000000000000000) => 1000000000000000000000000000000000000000000000000000000000\n  powerOf10(10000000000000000000000000000000000000000000000000000000000) => 100000000000000000000000000000000000000000000000000\n  powerOf10(100000000000000000000000000000000000000000000000000000000000) => 100000000000000000000000000000000000000000000000000000000000\n  powerOf10(1000000000000000000000000000000000000000000000000000000000000) => 10000000000000000000000000000000000000000000000000000\n  powerOf10(100000000000000000000000000000000000000000000000000000) => 100000000000000000000000000000000000000000000000000000\n  powerOf10(1000000000000000000000000000000000000000000000000000000) => 1000000000000000000000000000000000000000000000000000000\n  powerOf10(1000000000000000000000000000000000000000000000000000000000000000) => 10000000000000000000000000000000000000000000000000000000\n  powerOf10(10000000000000000000000000000000000000000000000000000000000000000) => 100000000000000000000000000000000000000000000000000000000\n  powerOf10(1000000000000000000000000000000000000000000000000000000000) => 1000000000000000000000000000000000000000000000000000000000\n  powerOf10(10000000000000000000000000000000000000000000000000000000000) => 100000000000000000000000000000000000000000000000000\n  powerOf10(100000000000000000000000000000000000000000000000000000000000) => 100000000000000000000000000000000000000000000000000000000000\n  powerOf10(1000000000000000000000000000000000000000000000000000000000000) => 10000000000000000000000000000000000000000000000000000\n  powerOf10(10000000000000000000000000000000000000000000000000000000000000) => 100000000000000000000000000000000000000000000000000000\n  powerOf10(100000000000000000000000000000000000000000000000000000000000000) => 1000000000000000000000000000000000000000000000000000000\n  powerOf10(1000000000000000000000000000000000000000000000000000000000000000) => 10000000000000000000000000000000000000000000000000000000\n  powerOf10(10000000000000000000000000000000000000000000000000000000000000000) => 100000000000000000000000000000000000000000000000000000000\n  powerOf10(1000000000000000000000000000000000000000000000000000000000) => 1000000000000000000000000000000000000000000000000000000000\n  powerOf10(1000000000000000000000000000000000000000000000000000000000000000000) => 100000000000000000000000000000000000000000000000000\n  powerOf10(100000000000000000000000000000000000000000000000000000000000) => 100000000000000000000000000000000000000000000000000000000000\n  powerOf10(1000000000000000000000000000000000000000000000000000000000000) => 10000000000000000000000000000000000000000000000000000\n  powerOf10(10000000000000000000000000000000000000000000000000000000000000) => 100000000000000000000000000000000000000000000000000000\n  powerOf10(100000000000000000000000000000000000000000000000000000000000000) => 1000000000000000000000000000000000000000000000000000000\n  powerOf10(1000000000000000000000000000000000000000000000000000000000000000) => 10000000000000000000000000000000000000000000000000000000\n  powerOf10(10000000000000000000000000000000000000000000000000000000000000000) => 100000000000000000000000000000000000000000000000000000000\n  powerOf10(1000000000000000000000000000000000000000000000000000000000) => 1000000000000000000000000000000000000000000000000000000000\n  powerOf10(1000000000000000000000000000000000000000000000000000000000000000000) => 100000000000000000000000000000000000000000000000000\n"}
