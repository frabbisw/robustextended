{"task_id": "JavaScript/0", "prompt": "/* Check that in the given list of numbers, any two numbers are closer together than the given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Check that in the given list of numbers, any two numbers are closer together than the given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const closest = numbers.reduce((acc, current) => {\n    const diff = current - threshold;\n    if (diff < 0) return acc;\n    return acc.concat(diff);\n  }, []);\n  return closest.every(el => el >= 0);\n};\n\n/**\n * Given a sorted array of numbers, return all possible pairs of numbers that sum to `target`.\n * If `target` is 0, return all pairs of numbers that sum to `target`.\n * If `target` is negative, return all pairs of numbers that sum to `target - x`.\n * If `target` is positive, return all pairs of numbers that sum to `target + x`.\n * If `target` is NaN, return all pairs of numbers that sum to `target`.\n * If `target` is Infinity, return all pairs of numbers that sum to `target`.\n * If `target` is -Infinity, return all pairs of numbers that sum to `target - x`.\n * If `target` is +Infinity, return all pairs of numbers that sum to `target + x`.\n * If `target` is undefined, return all pairs of numbers that sum to `target`.\n * If `target` is null, return all pairs of numbers that sum to `target`.\n * If `target` is an array, return all pairs of numbers that sum to `target`.\n * If `target` is a string, return all pairs of numbers that sum to `target`.\n * If `target` is a function, return all pairs of numbers that sum to `target`.\n * If `target` is an object, return all pairs of numbers that sum to `target`.\n * If `target` is an array, return all pairs of numbers that sum to `target`.\n * If `target` is a string, return all pairs of numbers that sum to `target`.\n * If `target` is a function, return all pairs of numbers that sum to `target`.\n * If `target` is an object, return all pairs of numbers that sum to `target`.\n * If `target` is an array, return all pairs of numbers that sum to `target`.\n * If `target` is a string, return all pairs of numbers that sum to `target`.\n * If `target` is a function, return all pairs of numbers that sum to `target`.\n * If `target` is an object, return all pairs of numbers that sum to `target`.\n * If `target` is an array, return all pairs of numbers that sum to `target`.\n * If `target` is a string, return all pairs of numbers that sum to `target`.\n * If `target` is a function, return all pairs of numbers that sum to `target`.\n * If `target` is an object, return all pairs of numbers that sum to `target`.\n * If `target` is an array, return all pairs of numbers that sum to `target`.\n * If `target` is a string, return all pairs of numbers that sum to `target`.\n * If `target` is a function, return all pairs of numbers that sum to `target`.\n * If `target` is an object, return all pairs of numbers that sum to `target`.\n * If `target` is an array, return all pairs of numbers that sum to `target`.\n * If `target` is a string, return all pairs of numbers that sum to `target`.\n * If `target` is a function, return all pairs of numbers that sum to `target`.\n * If `target` is an object, return all pairs of numbers that sum to `target`.\n * If `target` is an array, return all pairs of numbers that sum to `target`.\n * If `target` is a string, return all pairs of numbers that sum to `target`.\n * If `target` is a function, return all pairs of numbers that sum to `target`.\n * If `target` is an object, return all pairs of numbers that sum to `target`.\n * If `target` is an array, return all pairs of numbers that sum to `target`.\n * If `target` is a string, return all pairs of numbers that sum to `target`.\n * If `target` is a function, return all pairs of numbers that sum to `target`.\n * If `target` is an object, return all pairs of numbers that sum to `target`.\n * If `target` is an array, return all pairs of numbers that sum to `target`.\n * If `target` is a string, return all pairs of numbers that sum to `target`.\n * If `target` is a function, return all pairs of numbers that sum to `target`.\n * If `target` is an object, return all pairs of numbers that sum to `target`.\n * If `target` is an array, return all pairs of numbers that sum to `target`.\n * If `target` is a string, return all pairs of numbers that sum to `target`.\n * If `target` is a function, return all pairs of numbers that sum to `target`.\n * If `target` is an object, return all pairs of numbers that sum to `target`.\n * If `target` is an array, return all pairs of numbers that sum to `target`.\n * If `target` is a string, return all pairs of numbers that sum to `target`.\n * If `target` is a function, return all pairs of numbers that sum to `target`.\n * If `target` is an object, return all pairs of numbers that sum to `target`.\n * If `target` is an array, return all pairs of numbers that sum to `target`.\n * If `target` is a string, return all pairs of numbers that sum to `target`.\n * If `target` is a function, return all pairs of numbers that sum to `target`.\n * If `target` is an object, return all pairs of numbers that sum to `target`.\n * If `target` is an array, return all pairs of numbers that sum to `target`.\n * If `target` is a string, return all pairs of numbers that sum to `target`.\n * If `target` is a function, return all pairs of numbers that sum to `target`.\n * If `target` is an object, return all pairs of numbers that sum to `target`.\n * If `target` is an array, return all pairs of numbers that sum to `target`.\n * If `target` is a string, return all pairs of numbers that sum to `target`.\n * If `target` is a function, return all pairs of numbers that sum to `target`.\n * If `target` is an object, return all pairs of numbers that sum to `target`.\n * If `target` is an array, return all pairs of numbers that sum to `target`.\n * If `target` is a string, return all pairs of numbers that sum to `target`.\n * If `target` is a function, return all pairs of numbers that sum to `target`.\n * If `target` is an object, return all pairs of numbers that sum to `target`.\n * If `target` is an array, return all pairs of numbers that sum to `target`.\n * If `target` is a string, return all pairs of numbers that sum to `target`.\n * If `target` is a function, return all pairs of numbers that sum to `target`.\n * If `target` is an object, return all pairs of numbers that sum to `target`.\n * If `target` is an array, return all pairs of numbers that sum to `target`.\n * If `target` is a string, return all pairs of numbers that sum to `target`.", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/1", "prompt": "/* Input to this function is a string containing multiple groups of nested brackets, the goal of which is to separate this group into separate strings and return the list of them. Separate groups are balanced (each open bracket is properly closed), not nested Ignore spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Input to this function is a string containing multiple groups of nested brackets, the goal of which is to separate this group into separate strings and return the list of them. Separate groups are balanced (each open bracket is properly closed), not nested Ignore spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_groups = [];\n  let paren_count = 0;\n  let paren_open = false;\n  let paren_closed = false;\n  let paren_open_index = 0;\n  let paren_close_index = 0;\n  let paren_open_index2 = 0;\n  let paren_close_index2 = 0;\n  let paren_open_index3 = 0;\n  let paren_close_index3 = 0;\n  let paren_open_index4 = 0;\n  let paren_close_index4 = 0;\n  let paren_open_index5 = 0;\n  let paren_close_index5 = 0;\n  let paren_open_index6 = 0;\n  let paren_close_index6 = 0;\n  let paren_open_index7 = 0;\n  let paren_close_index7 = 0;\n  let paren_open_index8 = 0;\n  let paren_close_index8 = 0;\n  let paren_open_index9 = 0;\n  let paren_close_index9 = 0;\n  let paren_open_index10 = 0;\n  let paren_close_index10 = 0;\n  let paren_open_index11 = 0;\n  let paren_close_index11 = 0;\n  let paren_open_index12 = 0;\n  let paren_close_index12 = 0;\n  let paren_open_index13 = 0;\n  let paren_close_index13 = 0;\n  let paren_open_index14 = 0;\n  let paren_close_index14 = 0;\n  let paren_open_index15 = 0;\n  let paren_close_index15 = 0;\n  let paren_open_index16 = 0;\n  let paren_close_index16 = 0;\n  let paren_open_index17 = 0;\n  let paren_close_index17 = 0;\n  let paren_open_index18 = 0;\n  let paren_close_index18 = 0;\n  let paren_open_index19 = 0;\n  let paren_close_index19 = 0;\n  let paren_open_index20 = 0;\n  let paren_close_index20 = 0;\n  let paren_open_index21 = 0;\n  let paren_close_index21 = 0;\n  let paren_open_index22 = 0;\n  let paren_close_index22 = 0;\n  let paren_open_index23 = 0;\n  let paren_close_index23 = 0;\n  let paren_open_index24 = 0;\n  let paren_close_index24 = 0;\n  let paren_open_index25 = 0;\n  let paren_close_index25 = 0;\n  let paren_open_index26 = 0;\n  let paren_close_index26 = 0;\n  let paren_open_index27 = 0;\n  let paren_close_index27 = 0;\n  let paren_open_index28 = 0;\n  let paren_close_index28 = 0;\n  let paren_open_index29 = 0;\n  let paren_close_index29 = 0;\n  let paren_open_index30 = 0;\n  let paren_close_index30 = 0;\n  let paren_open_index31 = 0;\n  let paren_close_index31 = 0;\n  let paren_open_index32 = 0;\n  let paren_close_index32 = 0;\n  let paren_open_index33 = 0;\n  let paren_close_index33 = 0;\n  let paren_open_index34 = 0;\n  let paren_close_index34 = 0;\n  let paren_open_index35 = 0;\n  let paren_close_index35 = 0;\n  let paren_open_index36 = 0;\n  let paren_close_index36 = 0;\n  let paren_open_index37 = 0;\n  let paren_close_index37 = 0;\n  let paren_open_index38 = 0;\n  let paren_close_index38 = 0;\n  let paren_open_index39 = 0;\n  let paren_close_index39 = 0;\n  let paren_open_index40 = 0;\n  let paren_close_index40 = 0;\n  let paren_open_index41 = 0;\n  let paren_close_index41 = 0;\n  let paren_open_index42 = 0;\n  let paren_close_index42 = 0;\n  let paren_open_index43 = 0;\n  let paren_close_index43 = 0;\n  let paren_open_index44 = 0;\n  let paren_close_index44 = 0;\n  let paren_open_index45 = 0;\n  let paren_close_index45 = 0;\n  let paren_open_index46 = 0;\n  let paren_close_index46 = 0;\n  let paren_open_index47 = 0;\n  let paren_close_index47 = 0;\n  let paren_open_index48 = 0;\n  let paren_close_index48 = 0;\n  let paren_open_index49 = 0;\n  let paren_close_index49 = 0;\n  let paren_open_index50 = 0;\n  let paren_close_index50 = 0;\n  let paren_open_index51 = 0;\n  let paren_close_index51 = 0;\n  let paren_open_index52 = 0;\n  let paren_close_index52 = 0;\n  let paren_open_index53 = 0;\n  let paren_close_index53 = 0;\n  let paren_open_index54 = 0;\n  let paren_close_index54 = 0;\n  let paren_open_index55 = 0;\n  let paren_close_index55 = 0;\n  let paren_open_index56 = 0;\n  let paren_close_index56 = 0;\n  let paren_open_index57 = 0;\n  let paren_close_index57 = 0;\n  let paren_open_index58 = 0;\n  let paren_close_index58 = 0;\n  let paren_open_index59 = 0;\n  let paren_close_index59 = 0;\n  let paren_open_index60 = 0;\n  let paren_close_index60 = 0;\n  let paren_open_index61 = 0;\n  let paren_close_index61 = 0;\n  let paren_open_index62 = 0;\n  let paren_close_index62 = 0;\n  let paren_open_index63 = 0;\n  let paren_close_index63 = 0;\n  let paren_open_index64 = 0;\n  let paren_close_index64 = 0;\n  let paren_open_index65 = 0;\n  let paren_close_index65 = 0;\n  let paren_open_index66 = 0;\n  let paren_close_index66 = 0;\n  let paren_open_index67 = 0;\n  let paren_close_index67 = 0;\n  let paren_open_index68 = 0;\n  let paren_close_index68 = 0;\n  let paren_open_index69 = 0;\n  let paren_close_index69 = 0;\n  let paren_open_index70 = 0;\n  let paren_close_index70 = 0;\n  let paren_open_index71 = 0;\n  let paren_close_index71 = 0;\n  let paren_open_index72 = 0;\n  let paren_close_index72 = 0;\n  let paren_open_index73 = 0;\n  let paren_close_index73 = 0;\n  let paren_open_index74 = 0;\n  let paren_close_index74 = 0;\n  let paren_open_index75 = 0;\n  let paren_close_index75 = 0;\n  let paren_open_index76 = 0;\n  let paren_close_index76 = 0;\n  let paren_open_index77 = 0;\n  let paren_close_index77 = 0;\n  let paren_open_index78 = 0;\n  let paren_close_index78 = 0;\n  let paren_open_index79 = 0;\n  let paren_close_index79 = 0;\n  let paren_open_index80 = 0;\n  let paren_close_index80 = 0;\n  let paren_open_index81 = 0;\n  let paren_close_index81 = 0;\n  let paren_open_index82 = 0;\n  let paren_close_index82 = 0;\n  let paren_open_index83 = 0;\n  let paren_close_index83 = 0;\n  let paren_open_index84 = 0;\n  let paren_close_index84 = 0;\n  let paren_open_index85 = 0;\n  let paren_close_index85 = 0;\n  let paren_open_index86 = 0;\n  let paren_close_index86 = 0;\n  let paren_open_index87 = 0;\n  let paren_close_index87 = 0;\n  let paren_open_index88 = 0;\n  let paren_close_index88 = 0;\n  let paren_open_index89 = 0;\n  let paren_close_index89 = 0;\n  let paren_open_index90 = 0;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/10", "prompt": "/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let longestPalindrome = '';\n  let longestPostfix = '';\n  let longestPrefix = '';\n  let longestSuffix = '';\n\n  // Find longest postfix of supplied string that is a palindrome\n  for (let i = string.length - 1; i >= 0; i--) {\n    if (isPalindrome(string[i])) {\n      longestPalindrome = string[i];\n      longestPostfix = string[i].split('').reverse().join('');\n      break;\n    }\n  }\n\n  // Find longest prefix of supplied string that is a palindrome\n  for (let i = string.length - 1; i >= 0; i--) {\n    if (isPalindrome(string[i])) {\n      longestPrefix = string[i];\n      longestSuffix = string[i].split('').reverse().join('');\n      break;\n    }\n  }\n\n  // Find longest suffix of supplied string that is a palindrome\n  for (let i = string.length - 1; i >= 0; i--) {\n    if (isPalindrome(string[i])) {\n      longestSuffix = string[i];\n      break;\n    }\n  }\n\n  // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n  longestPrefix = longestPrefix.split('').reverse().join('');\n  longestSuffix = longestSuffix.split('').reverse().join('');\n\n  return longestPalindrome + longestPrefix + longestSuffix;\n}\n\n/* Given a string, return its reverse and prefix and suffix as a tuple.\n  >>> reverseAndPrefixAndSuffix('cat')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('cata')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catac')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catata')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatac')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacc')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catataccc')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccata')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccatac')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccatacc')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccataccc')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccatacccata')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccatacccatac')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccatacccatacc')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccatacccataccc')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccatacccatacccata')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccatacccatacccatac')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccatacccatacccatacc')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccatacccatacccataccc')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccatacccatacccatacccata')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccatacccatacccatacccatac')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccatacccatacccatacccatacc')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccatacccatacccatacccataccc')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccatacccatacccatacccatacccata')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccatacccatacccatacccatacccatac')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccatacccatacccatacccatacccatacc')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccatacccatacccatacccatacccataccc')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccatacccatacccatacccatacccatacccata')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccatacccatacccatacccatacccatacccatac')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccatacccatacccatacccatacccatacccata')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccatacccatacccatacccatacccatacccatacccata')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccatacccatacccatacccatacccatacccatacccata')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccatacccatacccatacccatacccatacccatacccatac')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccatacccatacccatacccatacccatacccatacccata')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccatacccatacccatacccatacccatacccatacccatac')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAndSuffix('catatacccatacccatacccatacccatacccatacccatacccata')\n  ('c', 'atac', 'ata')\n  >>> reverseAndPrefixAnd", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    const stones = makeAPileStones(i);\n    result.push(stones);\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPileStones(3)\n  [3, 5, 7]\n  */\nconst makeAPileStones = (level) => {\n  const result = [];\n  for (let i = 0; i < level; i++) {\n    const stones = makeAPileStonesStones(i);\n    result.push(stones);\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPileStonesStones(3)\n  [3, 5, 7]\n  */\nconst makeAPileStonesStones = (level) => {\n  const result = [];\n  for (let i = 0; i < level; i++) {\n    const stones = makeAPileStonesStonesStones(i);\n    result.push(stones);\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPileStonesStonesStones(3)\n  [3, 5, 7]\n  */\nconst makeAPileStonesStonesStones = (level) => {\n  const result = [];\n  for (let i = 0; i < level; i++) {\n    const stones = makeAPileStonesStonesStonesStones(i);\n    result.push(stones);\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPileStonesStonesStonesStones(3)\n  [3, 5, 7]\n  */\nconst makeAPileStonesStonesStonesStones = (level) => {\n  const result = [];\n  for (let i = 0; i < level; i++) {\n    const stones = makeAPileStonesStonesStonesStonesStones(i);\n    result.push(stones);\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPileStonesStonesStonesStonesStones(3)\n  [3, 5, 7]\n  */\nconst makeAPileStonesStonesStonesStonesStones = (level) => {\n  const result = [];\n  for (let i = 0; i < level; i++) {\n    const stones = makeAPileStonesStonesStonesStonesStones(i);\n    result.push(stones);\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPileStonesStonesStonesStonesStonesStones(3)\n  [3, 5, 7]\n  */\nconst makeAPileStonesStonesStonesStonesStonesStones = (level) => {\n  const result = [];\n  for (let i = 0; i < level; i++) {\n    const stones = makeAPileStonesStonesStonesStonesStonesStones(i);\n    result.push(stones);\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPileStonesStonesStonesStonesStonesStonesStones(3)\n  [3, 5, 7]\n  */\nconst makeAPileStonesStonesStonesStonesStonesStonesStones = (level) => {\n  const result = [];\n  for (let i = 0; i < level; i++) {\n    const stones = makeAPileStonesStonesStonesStonesStonesStonesStones(i);\n    result.push(stones);\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPileStonesStonesStonesStonesStonesStonesStonesStones(3)\n  [3, 5, 7]\n  */\nconst makeAPileStonesStonesStonesStonesStonesStonesStonesStones = (level) => {\n  const result = [];\n  for (let i = 0; i < level; i++) {\n    const stones = makeAPileStonesStonesStonesStonesStonesStonesStones(i);\n    result.push(stones);\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/101", "prompt": "/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/102", "prompt": "/*TIts function takes two positive numbers x and y and returns the largest even integer, which is in the range [x, y]. If there is no such number, the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*TIts function takes two positive numbers x and y and returns the largest even integer, which is in the range [x, y]. If there is no such number, the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  const num = (x + y) % 2;\n  return num === 0? x : y;\n};\n\n/**\n * Determines the largest power of two that is less than or equal to num.\n */\nconst getPowerOfTwo = (num) => {\n  const result = 1;\n  while (num > 0) {\n    const nextPower = Math.pow(result, 2);\n    result = nextPower;\n    num = num / 2;\n  }\n  return result;\n};\n\n/**\n * Determines the largest power of two that is less than or equal to num.\n */\nconst getPowerOfTwoWithFactor = (num) => {\n  const result = 1;\n  while (num > 0) {\n    const nextPower = Math.pow(result, 2);\n    result = nextPower;\n    num = num / 2;\n  }\n  return result;\n};\n\n/**\n * Determines the largest power of two that is less than or equal to num.\n */\nconst getPowerOfTwoWithFactorAndRemainder = (num) => {\n  const result = 1;\n  while (num > 0) {\n    const nextPower = Math.pow(result, 2);\n    result = nextPower;\n    num = num / 2;\n  }\n  return result;\n};\n\n/**\n * Determines the largest power of two that is less than or equal to num.\n */\nconst getPowerOfTwoWithFactorAndRemainderAndRemainder = (num) => {\n  const result = 1;\n  while (num > 0) {\n    const nextPower = Math.pow(result, 2);\n    result = nextPower;\n    num = num / 2;\n  }\n  return result;\n};\n\n/**\n * Determines the largest power of two that is less than or equal to num.\n */\nconst getPowerOfTwoWithFactorAndRemainderAndRemainderAndRemainder = (num) => {\n  const result = 1;\n  while (num > 0) {\n    const nextPower = Math.pow(result, 2);\n    result = nextPower;\n    num = num / 2;\n  }\n  return result;\n};\n\n/**\n * Determines the largest power of two that is less than or equal to num.\n */\nconst getPowerOfTwoWithFactorAndRemainderAndRemainderAndRemainderAndRemainder = (num) => {\n  const result = 1;\n  while (num > 0) {\n    const nextPower = Math.pow(result, 2);\n    result = nextPower;\n    num = num / 2;\n  }\n  return result;\n};\n\n/**\n * Determines the largest power of two that is less than or equal to num.\n */\nconst getPowerOfTwoWithFactorAndRemainderAndRemainderAndRemainderAndRemainderAndRemainder = (num) => {\n  const result = 1;\n  while (num > 0) {\n    const nextPower = Math.pow(result, 2);\n    result = nextPower;\n    num = num / 2;\n  }\n  return result;\n};\n\n/**\n * Determines the largest power of two that is less than or equal to num.\n */\nconst getPowerOfTwoWithFactorAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainder = (num) => {\n  const result = 1;\n  while (num > 0) {\n    const nextPower = Math.pow(result, 2);\n    result = nextPower;\n    num = num / 2;\n  }\n  return result;\n};\n\n/**\n * Determines the largest power of two that is less than or equal to num.\n */\nconst getPowerOfTwoWithFactorAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainder = (num) => {\n  const result = 1;\n  while (num > 0) {\n    const nextPower = Math.pow(result, 2);\n    result = nextPower;\n    num = num / 2;\n  }\n  return result;\n};\n\n/**\n * Determines the largest power of two that is less than or equal to num.\n */\nconst getPowerOfTwoWithFactorAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAndRemainderAnd", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/103", "prompt": "/*YYou get two positive integers n and m, and your task is to calculate the average of integers from n to m (including n and m). Round up the answer to the next integer and convert it to binaries. If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*YYou get two positive integers n and m, and your task is to calculate the average of integers from n to m (including n and m). Round up the answer to the next integer and convert it to binaries. If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let result = 0;\n  let binary = \"\";\n  let n = Math.ceil(n);\n  let m = Math.ceil(m);\n  for (let i = 1; i <= n; i++) {\n    result += Math.pow(i, m);\n    binary = binary + i;\n  }\n  return binary;\n};\n\n/*\n  Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a function that takes an integer and returns the binary representation of that integer. For example, the binary representation of 5 is \"0b1101\". Write a ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/104", "prompt": "/*GWhen creating a list of positive integers x, return a sorted list of all elements that do not have an even digit. Note: The returned list should be sorted in increasing order. Example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*GWhen creating a list of positive integers x, return a sorted list of all elements that do not have an even digit. Note: The returned list should be sorted in increasing order. Example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const digits = x.filter(x => x % 2 === 0);\n  return digits.sort((a, b) => a - b);\n};\n\n/**\n * Given a string, return all possible permutations of its characters. Example:\n  >>> permutations([1, 2, 3])\n  [[1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [1, 2, 3], [2, 1, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/105", "prompt": "/*\n  For an array of integers, you sort the integers that lie between 1 and 9, reverse the resulting array, and then replace each digit with its corresponding name of \"one,\" \"two,\" \"three,\" \"four,\" \"five,\" \"six,\" \"seven,\" \"eight,\" \"nine.\"\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  For an array of integers, you sort the integers that lie between 1 and 9, reverse the resulting array, and then replace each digit with its corresponding name of \"one,\" \"two,\" \"three,\" \"four,\" \"five,\" \"six,\" \"seven,\" \"eight,\" \"nine.\"\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.map(a => a.toString().split('').reverse().join(''));\n  return reversedArr;\n};\n\n/*\n  Given an array of integers, return a new array where each element is the sum of the elements in that array divided by the length of the array.\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / 9]\n          -> return [2, 1 / 3, 1 / 6, 1 / 9, 5 / 8, 5 / 3, 5 / 6, 5 / ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/106", "prompt": "/* Implement function f, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the factorial of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Implement function f, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the factorial of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i * i);\n  }\n  return result;\n};\n\n/* Implement function g, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  g(5) == [1, 2, 6, 24, 15]\n  */\nconst g = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i * i);\n  }\n  return result;\n};\n\n/* Implement function h, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  h(5) == [1, 2, 6, 24, 15]\n  */\nconst h = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i * i);\n  }\n  return result;\n};\n\n/* Implement function i, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  i(5) == [1, 2, 6, 24, 15]\n  */\nconst i = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i * i);\n  }\n  return result;\n};\n\n/* Implement function j, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  j(5) == [1, 2, 6, 24, 15]\n  */\nconst j = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i * i);\n  }\n  return result;\n};\n\n/* Implement function k, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  k(5) == [1, 2, 6, 24, 15]\n  */\nconst k = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i * i);\n  }\n  return result;\n};\n\n/* Implement function l, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  l(5) == [1, 2, 6, 24, 15]\n  */\nconst l = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i * i);\n  }\n  return result;\n};\n\n/* Implement function m, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  m(5) == [1, 2, 6, 24, 15]\n  */\nconst m = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i * i);\n  }\n  return result;\n};\n\n/* Implement function n, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  n(5) == [1, 2, 6, 24, 15]\n  */\nconst n = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i * i);\n  }\n  return result;\n};\n\n/* Implement function o, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  o(5) == [1, 2, 6, 24, 15]\n  */\nconst o = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i * i);\n  }\n  return result;\n};\n\n/* Implement function p, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  p(i) == [1, 2, 6, 24, 15]\n  */\nconst p = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i * i);\n  }\n  return result;\n};\n\n/* Implement function q, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  q(i) == [1, 2, 6, 24, 15]\n  */\nconst q = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i * i);\n  }\n  return result;\n};\n\n/* Implement function r, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  r(i) == [1, 2, 6, 24, 15]\n  */\nconst r = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i * i);\n  }\n  return result;\n};\n\n/* Implement function s, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the product of the numbers from ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/107", "prompt": "/*\n  If you return a positive integer n, you return a tuple with the number of even and odd integer palindromes within the range (1, n), including.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  If you return a positive integer n, you return a tuple with the number of even and odd integer palindromes within the range (1, n), including.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const oddPalindromes = [];\n  let evenPalindromes = [];\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = n; i >= 1; i--) {\n    if (n % i === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n    if (evenCount % 2 === 0) {\n      evenPalindromes.push(evenCount);\n      evenCount = 0;\n    }\n    if (oddCount % 2 === 0) {\n      oddPalindromes.push(oddCount);\n      oddCount = 0;\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n/*\n  Given a string, return the number of unique characters in the string.\n\n  Example 1:\n\n      Input: \"ab\"\n      Output: 2\n      Explanation: There are 2 unique characters in the string \"ab\".\n\n  Example 2:\n\n      Input: \"aba\"\n      Output: 3\n      Explanation: There are 3 unique characters in the string \"aba\".\n\n  Note:\n      All characters in the string are lower-case.\n*/\nconst countUniqueCharacters = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str.charAt(i) === str.charAt(str.length - i - 1)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string of lower-case English letters, return the number of unique English letters.\n\n  Example 1:\n\n      Input: \"ab\"\n      Output: 2\n      Explanation: There are 2 unique English letters in the string \"ab\".\n\n  Example 2:\n\n      Input: \"aba\"\n      Output: 3\n      Explanation: There are 3 unique English letters in the string \"aba\".\n\n  Note:\n      All letters in the string are lower-case.\n*/\nconst countUniqueLetters = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str.charAt(i) === str.charAt(str.length - i - 1)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string of lower-case English words, return the number of unique English words.\n\n  Example 1:\n\n      Input: \"ab\"\n      Output: 2\n      Explanation: There are 2 unique English words in the string \"ab\".\n\n  Example 2:\n\n      Input: \"aba\"\n      Output: 3\n      Explanation: There are 3 unique English words in the string \"aba\".\n\n  Note:\n      All words in the string are lower-case.\n*/\nconst countUniqueWords = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str.charAt(i) === str.charAt(str.length - i - 1)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string of lower-case English letters and a number, return the number of unique English letters and the number of unique English words.\n\n  Example 1:\n\n      Input: \"ab\", 1\n      Output: 3\n      Explanation: There are 3 unique English letters in the string \"ab\", and there are 2 unique English words in the string \"ab\".\n\n  Example 2:\n\n      Input: \"ab\", 2\n      Output: 3\n      Explanation: There are 3 unique English letters in the string \"ab\", and there are 3 unique English words in the string \"ab\".\n\n  Note:\n      All letters in the string are lower-case.\n*/\nconst countUniqueLettersAndWords = (str, num) => {\n  let count = 0;\n  let wordCount = 0;\n  let letterCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str.charAt(i) === str.charAt(str.length - i - 1)) {\n      count++;\n      letterCount++;\n    }\n    if (str.charAt(i) === str.charAt(str.length - i - 1)) {\n      wordCount++;\n    }\n  }\n  return [letterCount, wordCount, count];\n};\n\n/*\n  Given a string of lower-case English letters and a number, return the number of unique English letters and the number of unique English words.\n\n  Example 1:\n\n      Input: \"ab\", 1\n      Output: 3\n      Explanation: There are 3 unique English letters in the string \"ab\", and there are 2 unique English words in the string \"ab\".\n\n  Example 2:\n\n      Input: \"ab\", 2\n      Output: 3\n      Explanation: There are 3 unique English letters in the string \"ab\", and there are 3 unique English words in the string \"ab\".\n\n  Note:\n      All letters in the string are lower-case.\n*/\nconst countUniqueLettersAndWordsAndLetters = (str, num) => {\n  let count = 0;\n  let wordCount = 0;\n  let letterCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str.charAt(i) === str.charAt(str.length - i - 1)) {\n      count++;\n      letterCount++;\n    }\n    if (str.charAt(i) === str.charAt(str.length - i - 1)) {\n      wordCount++;\n    }\n  }\n  return [letterCount, wordCount, count];\n};\n\n/*\n  Given a string of lower-case English letters and a number, return the number of unique English letters and the number of unique English words.\n\n  Example 1:\n\n      Input: \"ab\", 1\n      Output: 3\n      Explanation: There are 3 unique English letters in the string \"ab\", and there are 2 unique English words in the string \"ab\".\n\n  Example 2:\n\n      Input: \"ab\", 2\n      Output: 3\n      Explanation: There are 3 unique English letters in the string \"ab\", and there are 3 unique English words in the string \"ab\".\n\n  Note:\n      All letters in the string are lower-case.\n*/\nconst countUniqueLettersAndWordsAndLettersAndLetters = (str, num) => {\n  let count = 0;\n  let wordCount = 0;\n  let letterCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str.charAt(i) === str.charAt(str.length - i - 1)) {\n      count++;\n      letterCount++;\n    }\n    if (str.charAt(i) === str.charAt(str.length - i - 1)) {\n      wordCount++;\n    }\n  }\n  return [letterCount, wordCount, count];\n};\n\n/*\n  Given a string of lower-case English letters and a number, return the number of unique English letters and the number of unique English words.\n\n  Example 1:\n\n      Input: \"ab\", 1\n      Output: 3\n      Explanation: There are 3 unique English letters in the string \"ab\", and there are 2 unique English words in the string \"ab\".\n\n  Example 2:\n\n      Input: \"ab\", 2\n      Output: 3\n      Explanation: There are 3 unique English letters in the string \"ab\", and there are 3 unique English words in the string \"ab\".\n\n  Note:\n      All letters in the string are lower-case.\n*/\nconst countUniqueLettersAndWordsAndLettersAndLettersAndLetters = (str, num) => {\n  let count = 0;\n  let wordCount = 0;\n  let letterCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str.charAt(i) === ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a function countNums that takes an array of integers and returns the number of elements that have a sum of digits > 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function countNums that takes an array of integers and returns the number of elements that have a sum of digits > 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      if (arr[i] % 10 === 0) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countZeros that takes an array of integers and returns the number of elements that have a sum of digits == 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countZeros([]) == 0\n  >>> countZeros([-1, 11, -11]) == 0\n  >>> countZeros([1, 1, 2]) == 0\n  */\nconst countZeros = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      if (arr[i] % 10 === 0) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countEvens that takes an array of integers and returns the number of elements that have a sum of digits == 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countEvens([]) == 0\n  >>> countEvens([-1, 11, -11]) == 0\n  >>> countEvens([1, 1, 2]) == 0\n  */\nconst countEvens = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      if (arr[i] % 2 === 0) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countOdds that takes an array of integers and returns the number of elements that have a sum of digits == 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countOdds([]) == 0\n  >>> countOdds([-1, 11, -11]) == 0\n  >>> countOdds([1, 1, 2]) == 0\n  */\nconst countOdds = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      if (arr[i] % 2 === 0) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countMultiples that takes an array of integers and returns the number of elements that have a sum of digits == 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countMultiples([]) == 0\n  >>> countMultiples([-1, 11, -11]) == 0\n  >>> countMultiples([1, 1, 2]) == 0\n  */\nconst countMultiples = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      if (arr[i] % 2 === 0) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countDivisibles that takes an array of integers and returns the number of elements that have a sum of digits == 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countDivisibles([]) == 0\n  >>> countDivisibles([-1, 11, -11]) == 0\n  >>> countDivisibles([1, 1, 2]) == 0\n  */\nconst countDivisibles = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      if (arr[i] % 2 === 0) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countMultipleDivisibles that takes an array of integers and returns the number of elements that have a sum of digits == 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countMultipleDivisibles([]) == 0\n  >>> countMultipleDivisibles([-1, 11, -11]) == 0\n  >>> countMultipleDivisibles([1, 1, 2]) == 0\n  */\nconst countMultipleDivisibles = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      if (arr[i] % 2 === 0) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countDivisiblesMultiples that takes an array of integers and returns the number of elements that have a sum of digits == 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countDivisiblesMultiples([]) == 0\n  >>> countDivisiblesMultiples([-1, 11, -11]) == 0\n  >>> countDivisiblesMultiples([1, 1, 2]) == 0\n  */\nconst countDivisiblesMultiples = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      if (arr[i] % 2 === 0) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countMultipleDivisiblesMultiples that takes an array of integers and returns the number of elements that have a sum of digits == 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countMultipleDivisiblesMultiples([]) == 0\n  >>> countMultipleDivisiblesMultiples([-1, 11, -11]) == 0\n  >>> countMultipleDivisiblesMultiples([1, 1, 2]) == 0\n  */\nconst countMultipleDivisiblesMultiples = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      if (arr[i] % 2 === 0) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countDivisiblesMultipleDivisibles that takes an array of integers and returns the number of elements that have a sum of digits == 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countDivisiblesMultipleDivisibles([]) == 0\n  >>> countDivisiblesMultipleDivisibles([-1, 11, -11]) == 0\n  >>> countDivisiblesMultipleDivisibles([1, 1, 2]) == 0\n  */\nconst countDivisiblesMultipleDivisibles = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      if (arr[i] % 2 === 0) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countMultipleDivisiblesMultipleDivisibles that takes an array of integers and returns the number of elements that have a sum of digits == 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countMultipleDivisiblesMultipleDivisibles([]) == 0\n  >>> countMultipleDivisiblesMultipleDivisibles([-1, 11, -11]) == 0\n  >>> countMultipleDivisiblesMultipleDivisibles([1, 1, 2]) == 0\n  */\nconst countMultipleDivisiblesMultipleDivisibles = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      if (arr[i] % 2 === 0) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countMultipleDivisiblesMultipleDivisiblesMultiples that takes an array of integers and returns the number of elements that have a sum of digits == 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countMultipleDivisiblesMultipleDivisiblesMultiples([]) == 0\n  >>> countMultipleDivisiblesMultipleDivisiblesMultiples([-1, 11, -11]) == 0\n  >>> countMultipleDivisiblesMultipleDivisiblesMultiples([1, 1, 2]) == 0\n  */\nconst countMultipleDivisiblesMultipleDivisiblesMultiples = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      if (arr", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*We have an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  let count = 0;\n  let arrCopy = arr.slice();\n  arrCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyLength = arrCopy.length;\n  let arrCopyCopy = arrCopy.slice();\n  arrCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyCopy = arrCopyCopy.slice();\n  arrCopyCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyCopy = arrCopyCopy.slice();\n  arrCopyCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  arrCopyCopyCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  arrCopyCopyCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  arrCopyCopyCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  arrCopyCopyCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  arrCopyCopyCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  arrCopyCopyCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  arrCopyCopyCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  arrCopyCopyCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  arrCopyCopyCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  arrCopyCopyCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  arrCopyCopyCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  arrCopyCopyCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  arrCopyCopyCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  arrCopyCopyCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  arrCopyCopyCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  arrCopyCopyCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  arrCopyCopyCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  arrCopyCopyCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  arrCopyCopyCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  arrCopyCopyCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  arrCopyCopyCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  arrCopyCopyCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  arrCopyCopyCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  arrCopyCopyCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  arrCopyCopyCopyCopy.sort((a, b) => {\n    return a - b;\n  });\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopy", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/11", "prompt": "/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary XOR on these inputs and return the result as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary XOR on these inputs and return the result as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    let digitA = parseInt(a[i], 2);\n    let digitB = parseInt(b[i], 2);\n    let resultDigit = digitA ^ digitB;\n    if (resultDigit === 0) {\n      result = '0';\n    } else {\n      result = result.toString();\n    }\n  }\n  return result;\n};\n\n/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary AND on these inputs and return the result as a string.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    let digitA = parseInt(a[i], 2);\n    let digitB = parseInt(b[i], 2);\n    let resultDigit = digitA & digitB;\n    if (resultDigit === 0) {\n      result = '0';\n    } else {\n      result = result.toString();\n    }\n  }\n  return result;\n};\n\n/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary OR on these inputs and return the result as a string.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    let digitA = parseInt(a[i], 2);\n    let digitB = parseInt(b[i], 2);\n    let resultDigit = digitA | digitB;\n    if (resultDigit === 0) {\n      result = '0';\n    } else {\n      result = result.toString();\n    }\n  }\n  return result;\n};\n\n/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary NOT on these inputs and return the result as a string.\n  >>> stringNot('010', '110')\n  '100'\n  */\nconst stringNot = a => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    let digitA = parseInt(a[i], 2);\n    let resultDigit = ~digitA;\n    if (resultDigit === 0) {\n      result = '0';\n    } else {\n      result = result.toString();\n    }\n  }\n  return result;\n};\n\n/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary AND NOT on these inputs and return the result as a string.\n  >>> stringAndNot('010', '110')\n  '100'\n  */\nconst stringAndNot = a => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    let digitA = parseInt(a[i], 2);\n    let resultDigit = ~digitA;\n    if (resultDigit === 0) {\n      result = '0';\n    } else {\n      result = result.toString();\n    }\n  }\n  return result;\n};\n\n/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary OR NOT on these inputs and return the result as a string.\n  >>> stringOrNot('010', '110')\n  '100'\n  */\nconst stringOrNot = a => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    let digitA = parseInt(a[i], 2);\n    let resultDigit = ~digitA;\n    if (resultDigit === 0) {\n      result = '0';\n    } else {\n      result = result.toString();\n    }\n  }\n  return result;\n};\n\n/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary NOT AND NOT on these inputs and return the result as a string.\n  >>> stringNotAndNot('010', '110')\n  '100'\n  */\nconst stringNotAndNot = a => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    let digitA = parseInt(a[i], 2);\n    let resultDigit = ~digitA;\n    if (resultDigit === 0) {\n      result = '0';\n    } else {\n      result = result.toString();\n    }\n  }\n  return result;\n};\n\n/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary NOT AND NOT on these inputs and return the result as a string.\n  >>> stringNotAndNot('010', '110')\n  '100'\n  */\nconst stringNotAndNotNot = a => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    let digitA = parseInt(a[i], 2);\n    let resultDigit = ~digitA;\n    if (resultDigit === 0) {\n      result = '0';\n    } else {\n      result = result.toString();\n    }\n  }\n  return result;\n};\n\n/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary NOT AND NOT on these inputs and return the result as a string.\n  >>> stringNotAndNotNotNot('010', '110')\n  '100'\n  */\nconst stringNotAndNotNotNotNot = a => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    let digitA = parseInt(a[i], 2);\n    let resultDigit = ~digitA;\n    if (resultDigit === 0) {\n      result = '0';\n    } else {\n      result = result.toString();\n    }\n  }\n  return result;\n};\n\n/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary NOT AND NOT NOT on these inputs and return the result as a string.\n  >>> stringNotAndNotNotNotNot('010', '110')\n  '100'\n  */\nconst stringNotAndNotNotNotNotNot = a => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    let digitA = parseInt(a[i], 2);\n    let resultDigit = ~digitA;\n    if (resultDigit === 0) {\n      result = '0';\n    } else {\n      result = result.toString();\n    }\n  }\n  return result;\n};\n\n/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary NOT AND NOT NOT NOT on these inputs and return the result as a string.\n  >>> stringNotAndNotNotNotNotNot('010', '110')\n  '100'\n  */\nconst stringNotAndNotNotNotNotNotNot = a => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    let digitA = parseInt(a[i], 2);\n    let resultDigit = ~digitA;\n    if (resultDigit === 0) {\n      result = '0';\n    } else {\n      result = result.toString();\n    }\n  }\n  return result;\n};\n\n/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary NOT AND NOT NOT NOT on these inputs and return the result as a string.\n  >>> stringNotAndNotNotNotNotNotNotNot('010', '110')\n  '100'\n  */\nconst stringNotAndNotNotNotNotNotNotNotNot = a => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    let digitA = parseInt(a[i], 2);\n    let resultDigit = ~digitA;\n    if (resultDigit === 0) {\n      result = '0';\n    } else {\n      result = result.toString();\n    }\n  }\n  return result;\n};\n\n/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary NOT AND NOT NOT NOT NOT on these inputs and return the result as a string.\n  >>> stringNotAndNotNotNotNotNotNotNotNot('010', '110')\n  '100'\n  */\nconst stringNotAndNotNotNotNotNotNotNotNotNot = a => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    let digitA = parseInt(a[i], 2);\n    let resultDigit = ~digitA;\n    if (resultDigit === 0) {\n      result = '0';\n    } else {\n      result = result.toString();\n    }\n  }\n  return result;\n};\n\n/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary NOT AND NOT NOT NOT NOT NOT on these inputs and return the ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/110", "prompt": "/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an exchange of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of exchanged elements between lst1 and lst2.\n  If it is possible to exchange elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an exchange of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of exchanged elements between lst1 and lst2.\n  If it is possible to exchange elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let result = \"NO\";\n  if (lst1.length < lst2.length) {\n    console.log(\"The lists cannot be empty\");\n  } else if (lst1.length === lst2.length) {\n    console.log(\"The lists are empty\");\n  } else {\n    for (let i = 0; i < lst1.length; i++) {\n      if (lst1[i] % 2!== lst2[i] % 2) {\n        console.log(\"The lists cannot be exchanged\");\n      } else {\n        result = result === \"YES\"? \"YES\" : \"NO\";\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function that takes as input two lists of numbers and returns the\n  number of elements that can be exchanged to make lst1 a list of only\n  even numbers.\n  For example:\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => 2\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => 1\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 1\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  exchange([1, 2, 3, 4], [1, 5, 3, 5]) => 0\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/111", "prompt": "/*GIf a string is a lowercase letter separated by spaces, return a dictionary of the letter with the largest repetition and the corresponding number. If several letters have the same occurrence, return all.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*GIf a string is a lowercase letter separated by spaces, return a dictionary of the letter with the largest repetition and the corresponding number. If several letters have the same occurrence, return all.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let histogram = {};\n  letters.forEach((letter) => {\n    histogram[letter] = histogram[letter] || 0;\n    histogram[letter]++;\n  });\n  return histogram;\n};\n\n/*\n  Given a string of words, return the number of words that have the most letters.\n\n  Example:\n  words('a b c d e f g h i j k l m n o p q r s t u v w x y z') == 6\n  words('a b c d e f g h i j k l m n o p q r s t u v w x y z') == 5\n  words('a b c d e f g h i j k l m n o p q r s t u v w x y z') == 4\n  words('a b c d e f g h i j k l m n o p q r s t u v w x y z') == 3\n  words('a b c d e f g h i j k l m n o p q r s t u v w x y z') == 2\n  words('a b c d e f g h i j k l m n o p q r s t u v w x y z') == 1\n  words('') == 0\n  words('') == 1\n  words('') == 2\n  words('') == 3\n  words('') == 4\n  words('') == 5\n  words('') == 6\n  words('') == 7\n  words('') == 8\n  words('') == 9\n  words('') == 10\n  words('') == 11\n  words('') == 12\n  words('') == 13\n  words('') == 14\n  words('') == 15\n  words('') == 16\n  words('') == 17\n  words('') == 18\n  words('') == 19\n  words('') == 20\n  words('') == 21\n  words('') == 22\n  words('') == 23\n  words('') == 24\n  words('') == 25\n  words('') == 26\n  words('') == 27\n  words('') == 28\n  words('') == 29\n  words('') == 30\n  words('') == 31\n  words('') == 32\n  words('') == 33\n  words('') == 34\n  words('') == 35\n  words('') == 36\n  words('') == 37\n  words('') == 38\n  words('') == 39\n  words('') == 40\n  words('') == 41\n  words('') == 42\n  words('') == 43\n  words('') == 44\n  words('') == 45\n  words('') == 46\n  words('') == 47\n  words('') == 48\n  words('') == 49\n  words('') == 50\n  words('') == 51\n  words('') == 52\n  words('') == 53\n  words('') == 54\n  words('') == 55\n  words('') == 56\n  words('') == 57\n  words('') == 58\n  words('') == 59\n  words('') == 60\n  words('') == 61\n  words('') == 62\n  words('') == 63\n  words('') == 64\n  words('') == 65\n  words('') == 66\n  words('') == 67\n  words('') == 68\n  words('') == 69\n  words('') == 70\n  words('') == 71\n  words('') == 72\n  words('') == 73\n  words('') == 74\n  words('') == 75\n  words('') == 76\n  words('') == 77\n  words('') == 78\n  words('') == 79\n  words('') == 80\n  words('') == 81\n  words('') == 82\n  words('') == 83\n  words('') == 84\n  words('') == 85\n  words('') == 86\n  words('') == 87\n  words('') == 88\n  words('') == 89\n  words('') == 90\n  words('') == 91\n  words('') == 92\n  words('') == 93\n  words('') == 94\n  words('') == 95\n  words('') == 96\n  words('') == 97\n  words('') == 98\n  words('') == 99\n  words('') == 100\n  words('') == 101\n  words('') == 102\n  words('') == 103\n  words('') == 104\n  words('') == 105\n  words('') == 106\n  words('') == 107\n  words('') == 108\n  words('') == 109\n  words('') == 110\n  words('') == 111\n  words('') == 112\n  words('') == 113\n  words('') == 114\n  words('') == 115\n  words('') == 116\n  words('') == 117\n  words('') == 118\n  words('') == 119\n  words('') == 120\n  words('') == 121\n  words('') == 122\n  words('') == 123\n  words('') == 124\n  words('') == 125\n  words('') == 126\n  words('') == 127\n  words('') == 128\n  words('') == 129\n  words('') == 130\n  words('') == 131\n  words('') == 132\n  words('') == 133\n  words('') == 134\n  words('') == 135\n  words('') == 136\n  words('') == 137\n  words('') == 138\n  words('') == 139\n  words('') == 140\n  words('') == 141\n  words('') == 142\n  words('') == 143\n  words('') == 144\n  words('') == 145\n  words('') == 146\n  words('') == 147\n  words('') == 148\n  words('') == 149\n  words('') == 150\n  words('') == 151\n  words('') == 152\n  words('') == 153\n  words('') == 154\n  words('') == 155\n  words('') == 156\n  words('') == 157\n  words('') == 158\n  words('') == 159\n  words('') == 160\n  words('') == 161\n  words('') == 162\n  words('') == 163\n  words('') == 164\n  words('') == 165\n  words('') == 166\n  words('') == 167\n  words('') == 168\n  words('') == 169\n  words('') == 170\n  words('') == 171\n  words('') == 172\n  words('') == 173\n  words('') == 174\n  words('') == 175\n  words('') == 176\n  words('') == 177\n  words('') == 178\n  words('') == 179\n  words('') == 180\n  words('') == 181\n  words('') == 182\n  words('') == 183\n  words('') == 184\n  words('') == 185\n  words('') == 186\n  words('') == 187\n  words('') == 188\n  words('') == 189\n  words('') == 190\n  words('') == 191\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/112", "prompt": "/*Task We get two strings s and c, you have to delete all characters in s that correspond to any character in c, then check if the result string is palindrome. A string is called palindrome if it reads the same backward as forward. You should return a tuple that contains the result string and true / false for verification.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Task We get two strings s and c, you have to delete all characters in s that correspond to any character in c, then check if the result string is palindrome. A string is called palindrome if it reads the same backward as forward. You should return a tuple that contains the result string and true / false for verification.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let reversed = s.split(\"\").reverse().join(\"\");\n  let result = reversed.split(\"\").filter((c, i) => c === c).join(\"\");\n  return [result, result === reversed];\n};\n\n/*Task We get two strings s and c, you have to delete all characters in s that correspond to any character in c, then check if the result string is palindrome. A string is called palindrome if it reads the same backward as forward. You should return a tuple that contains the result string and true / false for verification.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete2 = (s, c) => {\n  let reversed = s.split(\"\").reverse().join(\"\");\n  let result = reversed.split(\"\").filter((c, i) => c === c).join(\"\");\n  let reversed2 = reversed.split(\"\").reverse().join(\"\");\n  return [result, result === reversed2, result === reversed2];\n};\n\n/*Task We get two strings s and c, you have to delete all characters in s that correspond to any character in c, then check if the result string is palindrome. A string is called palindrome if it reads the same backward as forward. You should return a tuple that contains the result string and true / false for verification.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete3 = (s, c) => {\n  let reversed = s.split(\"\").reverse().join(\"\");\n  let result = reversed.split(\"\").filter((c, i) => c === c).join(\"\");\n  let reversed2 = reversed.split(\"\").reverse().join(\"\");\n  let reversed3 = reversed.split(\"\").reverse().join(\"\");\n  return [result, result === reversed2, result === reversed3, result === reversed3];\n};\n\n/*Task We get two strings s and c, you have to delete all characters in s that correspond to any character in c, then check if the result string is palindrome. A string is called palindrome if it reads the same backward as forward. You should return a tuple that contains the result string and true / false for verification.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete4 = (s, c) => {\n  let reversed = s.split(\"\").reverse().join(\"\");\n  let result = reversed.split(\"\").filter((c, i) => c === c).join(\"\");\n  let reversed2 = reversed.split(\"\").reverse().join(\"\");\n  let reversed3 = reversed.split(\"\").reverse().join(\"\");\n  let reversed4 = reversed.split(\"\").reverse().join(\"\");\n  return [result, result === reversed2, result === reversed3, result === reversed4, result === reversed4];\n};\n\n/*Task We get two strings s and c, you have to delete all characters in s that correspond to any character in c, then check if the result string is palindrome. A string is called palindrome if it reads the same backward as forward. You should return a tuple that contains the result string and true / false for verification.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete5 = (s, c) => {\n  let reversed = s.split(\"\").reverse().join(\"\");\n  let result = reversed.split(\"\").filter((c, i) => c === c).join(\"\");\n  let reversed2 = reversed.split(\"\").reverse().join(\"\");\n  let reversed3 = reversed.split(\"\").reverse().join(\"\");\n  let reversed4 = reversed.split(\"\").reverse().join(\"\");\n  let reversed5 = reversed.split(\"\").reverse().join(\"\");\n  return [result, result === reversed2, result === reversed3, result === reversed4, result === reversed5, result === reversed5];\n};\n\n/*Task We get two strings s and c, you have to delete all characters in s that correspond to any character in c, then check if the result string is palindrome. A string is called palindrome if it reads the same backward as forward. You should return a tuple that contains the result string and true / false for verification.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete6 = (s, c) => {\n  let reversed = s.split(\"\").reverse().join(\"\");\n  let result = reversed.split(\"\").filter((c, i) => c === c).join(\"\");\n  let reversed2 = reversed.split(\"\").reverse().join(\"\");\n  let reversed3 = reversed.split(\"\").reverse().join(\"\");\n  let reversed4 = reversed.split(\"\").reverse().join(\"\");\n  let reversed5 = reversed.split(\"\").reverse().join(\"\");\n  let reversed6 = reversed.split(\"\").reverse().join(\"\");\n  return [result, result === reversed2, result === reversed3, result === reversed4, result === reversed5, result === reversed6, result === reversed6];\n};\n\n/*Task We get two strings s and c, you have to delete all characters in s that correspond to any character in c, then check if the result string is palindrome. A string is called palindrome if it reads the same backward as forward. You should return a tuple that contains the result string and true / false for verification.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete7 = (s, c) => {\n  let reversed = s.split(\"\").reverse().join(\"\");\n  let result = reversed.split(\"\").filter((c, i) => c === c).join(\"\");\n  let reversed2 = reversed.split(\"\").reverse().join(\"\");\n  let reversed3 = reversed.split(\"\").reverse().join(\"\");\n  let reversed4 = reversed.split(\"\").reverse().join(\"\");\n  let reversed5 = reversed.split(\"\").reverse().join(\"\");\n  let reversed6 = reversed.split(\"\").reverse().join(\"\");\n  let reversed", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/113", "prompt": "/*GIf you create a list of strings in which each string consists only of digits, you return a list. Each element i of the output should be \"the number of odd elements in the string i of input,\" with all i's being replaced by the number of odd digits in the i'th string of input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*GIf you create a list of strings in which each string consists only of digits, you return a list. Each element i of the output should be \"the number of odd elements in the string i of input,\" with all i's being replaced by the number of odd digits in the i'th string of input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let oddCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].toString().length % 2 === 0) {\n      oddCount++;\n    }\n  }\n  return oddCount;\n};\n\n/*\n  Given a string, return the number of even characters in the string.\n\n  >>> evenCount('abc')\n  3\n  >>> evenCount('123')\n  2\n  >>> evenCount('12')\n  1\n  >>> evenCount('a')\n  0\n  >>> evenCount('123abc')\n  3\n  >>> evenCount('123abc123')\n  3\n  >>> evenCount('123abc123abc')\n  3\n  >>> evenCount('123abc123abc123')\n  3\n  >>> evenCount('123abc123abc123abc')\n  3\n  >>> evenCount('123abc123abc123abc123')\n  3\n  >>> evenCount('123abc123abc123abc123abc123')\n  3\n  >>> evenCount('123abc123abc123abc123abc123abc123')\n  3\n  >>> evenCount('123abc123abc123abc123abc123abc123abc123')\n  3\n  >>> evenCount('123abc123abc123abc123abc123abc123abc123abc123abc123')\n  3\n  >>> evenCount('123abc123abc123abc123abc123abc123abc123abc123abc123abc123')\n  3\n  >>> evenCount('123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123')\n  3\n  >>> evenCount('123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123')\n  3\n  >>> evenCount('123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123')\n  3\n  >>> evenCount('123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123')\n  3\n  >>> evenCount('123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123')\n  3\n  >>> evenCount('123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123')\n  3\n  >>> evenCount('123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123')\n  3\n  >>> evenCount('123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123')\n  3\n  >>> evenCount('123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123')\n  3\n  >>> evenCount('123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123')\n  3\n  >>> evenCount('123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123')\n  3\n  >>> evenCount('123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123')\n  3\n  >>> evenCount('123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123')\n  3\n  >>> evenCount('123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123')\n  3\n  >>> evenCount('123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an array of integers, search for the minimum sum of all non-empty sub-arrays of numbers.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an array of integers, search for the minimum sum of all non-empty sub-arrays of numbers.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let sum = 0;\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given an array of integers, search for the maximum sum of all non-empty sub-arrays of numbers.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -3\n  */\nconst maxSubArraySum = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n    }\n  }\n  return maxSum;\n};\n\n/*\n  Given an array of integers, search for the minimum number of non-empty sub-arrays of numbers.\n  Example\n  minSubArrayCount([2, 3, 4, 1, 2, 4]) == 3\n  minSubArrayCount([-1, -2, -3]) == 2\n  */\nconst minSubArrayCount = (nums) => {\n  let count = 0;\n  let minCount = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minCount) {\n      minCount = nums[i];\n    }\n    count++;\n  }\n  return count;\n};\n\n/*\n  Given an array of integers, search for the maximum number of non-empty sub-arrays of numbers.\n  Example\n  maxSubArrayCount([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArrayCount([-1, -2, -3]) == 3\n  */\nconst maxSubArrayCount = (nums) => {\n  let count = 0;\n  let maxCount = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] > maxCount) {\n      maxCount = nums[i];\n    }\n    count++;\n  }\n  return count;\n};\n\n/*\n  Given an array of integers, search for the minimum number of non-empty sub-arrays of numbers.\n  Example\n  minSubArrayCount([2, 3, 4, 1, 2, 4]) == 3\n  minSubArrayCount([-1, -2, -3]) == 2\n  */\nconst minSubArrayCountOf = (nums) => {\n  let count = 0;\n  let minCount = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minCount) {\n      minCount = nums[i];\n    }\n    count++;\n  }\n  return count;\n};\n\n/*\n  Given an array of integers, search for the maximum number of non-empty sub-arrays of numbers.\n  Example\n  maxSubArrayCount([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArrayCount([-1, -2, -3]) == 3\n  */\nconst maxSubArrayCountOf = (nums) => {\n  let count = 0;\n  let maxCount = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] > maxCount) {\n      maxCount = nums[i];\n    }\n    count++;\n  }\n  return count;\n};\n\n/*\n  Given an array of integers, search for the minimum number of non-empty sub-arrays of numbers.\n  Example\n  minSubArrayCountOf([2, 3, 4, 1, 2, 4]) == 3\n  minSubArrayCountOf([-1, -2, -3]) == 2\n  */\nconst minSubArrayCountOf = (nums) => {\n  let count = 0;\n  let minCount = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minCount) {\n      minCount = nums[i];\n    }\n    count++;\n  }\n  return count;\n};\n\n/*\n  Given an array of integers, search for the maximum number of non-empty sub-arrays of numbers.\n  Example\n  maxSubArrayCountOf([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArrayCountOf([-1, -2, -3]) == 3\n  */\nconst maxSubArrayCountOf = (nums) => {\n  let count = 0;\n  let maxCount = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] > maxCount) {\n      maxCount = nums[i];\n    }\n    count++;\n  }\n  return count;\n};\n\n/*\n  Given an array of integers, search for the minimum number of non-empty sub-arrays of numbers.\n  Example\n  minSubArrayCountOf([2, 3, 4, 1, 2, 4]) == 3\n  minSubArrayCountOf([-1, -2, -3]) == 2\n  */\nconst minSubArrayCountOf = (nums) => {\n  let count = 0;\n  let minCount = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minCount) {\n      minCount = nums[i];\n    }\n    count++;\n  }\n  return count;\n};\n\n/*\n  Given an array of integers, search for the maximum number of non-empty sub-arrays of numbers.\n  Example\n  maxSubArrayCountOf([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArrayCountOf([-1, -2, -3]) == 3\n  */\nconst maxSubArrayCountOf = (nums) => {\n  let count = 0;\n  let maxCount = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] > maxCount) {\n      maxCount = nums[i];\n    }\n    count++;\n  }\n  return count;\n};\n\n/*\n  Given an array of integers, search for the minimum number of non-empty sub-arrays of numbers.\n  Example\n  minSubArrayCountOf([2, 3, 4, 1, 2, 4]) == 3\n  minSubArrayCountOf([-1, -2, -3]) == 2\n  */\nconst minSubArrayCountOf = (nums) => {\n  let count = 0;\n  let minCount = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minCount) {\n      minCount = nums[i];\n    }\n    count++;\n  }\n  return count;\n};\n\n/*\n  Given an array of integers, search for the maximum number of non-empty sub-arrays of numbers.\n  Example\n  maxSubArrayCountOf([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArrayCountOf([-1, -2, -3]) == 3\n  */\nconst maxSubArrayCountOf = (nums) => {\n  let count = 0;\n  let maxCount = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] > maxCount) {\n      maxCount = nums[i];\n    }\n    count++;\n  }\n  return count;\n};\n\n/*\n  Given an array of integers, search for the minimum number of non-empty sub-arrays of numbers.\n  Example\n  minSubArrayCountOf([2, 3, 4, 1, 2, 4]) == 3\n  minSubArrayCountOf([-1, -2, -3]) == 2\n  */\nconst minSubArrayCountOf = (nums) => {\n  let count = 0;\n  let minCount = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minCount) {\n      minCount = nums[i];\n    }\n    count++;\n  }\n  return count;\n};\n\n/*\n  Given an array of integers, search for the maximum number of non-empty sub-arrays of numbers.\n  Example\n  maxSubArrayCountOf([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArrayCountOf([-1, -2, -3]) == 3\n  */\nconst maxSubArrayCountOf = (nums) => {\n  let count = 0;\n  let maxCount = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] > maxCount) {\n      maxCount = nums[i];\n    }\n    count++;\n  }\n  return count;\n};\n\n/*\n  Given an array of integers, search for the minimum number of non-empty sub-arrays of numbers.\n  Example\n  minSubArrayCountOf([2, 3, 4, 1, 2, 4]) == 3\n  minSubArrayCountOf([-1, -2, -3]) == 2\n  */\nconst minSubArrayCountOf = (nums) => {\n  let count = 0;\n  let minCount = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] > minCount) {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        result += 1;\n      }\n    }\n  }\n  return result >= capacity? result : 0;\n};\n\n/**\n * Your MaxFill function will be called as such:\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxFill = function (grid, capacity) {\n  grid = grid.map(row => row.map(cell => cell === 1? 0 : 1));\n  return maxFill(grid, capacity);\n};\n\n/**\n * Your MaxFill function will be called as such:\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxFill = function (grid, capacity) {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        result += 1;\n      }\n    }\n  }\n  return result >= capacity? result : 0;\n};\n\n/**\n * Your MaxFill function will be called as such:\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxFill = function (grid, capacity) {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        result += 1;\n      }\n    }\n  }\n  return result >= capacity? result : 0;\n};\n\n/**\n * Your MaxFill function will be called as such:\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxFill = function (grid, capacity) {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        result += 1;\n      }\n    }\n  }\n  return result >= capacity? result : 0;\n};\n\n/**\n * Your MaxFill function will be called as such:\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxFill = function (grid, capacity) {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        result += 1;\n      }\n    }\n  }\n  return result >= capacity? result : 0;\n};\n\n/**\n * Your MaxFill function will be called as such:\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxFill = function (grid, capacity) {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        result += 1;\n      }\n    }\n  }\n  return result >= capacity? result : 0;\n};\n\n/**\n * Your MaxFill function will be called as such:\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxFill = function (grid, capacity) {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        result += 1;\n      }\n    }\n  }\n  return result >= capacity? result : 0;\n};\n\n/**\n * Your MaxFill function will be called as such:\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxFill = function (grid, capacity) {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        result += 1;\n      }\n    }\n  }\n  return result >= capacity? result : 0;\n};\n\n/**\n * Your MaxFill function will be called as such:\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxFill = function (grid, capacity) {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        result += 1;\n      }\n    }\n  }\n  return result >= capacity? result : 0;\n};\n\n/**\n * Your MaxFill function will be called as such:\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxFill = function (grid, capacity) {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        result += 1;\n      }\n    }\n  }\n  return result >= capacity? result : 0;\n};\n\n/**\n * Your MaxFill function will be called as such:\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxFill = function (grid, capacity) {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        result += 1;\n      }\n    }\n  }\n  return result >= capacity? result : 0;\n};\n\n/**\n * Your MaxFill function will be called as such:\n * const result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n * var result = maxFill(grid, capacity)\n * @param {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this kata, you must sort an array of non-negative integers by the number of ones in their binary representation in ascending order. If the number of ones is similar, sort by decimal value. It must be implemented as follows:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  In this kata, you must sort an array of non-negative integers by the number of ones in their binary representation in ascending order. If the number of ones is similar, sort by decimal value. It must be implemented as follows:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.sort((a, b) => a - b);\n  return sorted;\n};\n\n/*\n  Given an array of non-negative integers, return a new array in which each element is the sum of the elements in the original array divided by the length of the array.\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-3, -2, -1, 0, 1, 2, 3, 4]\n  >>> divideArray([-5, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/117", "prompt": "/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let count = 0\n  let wordCount = 0\n  let wordCount2 = 0\n  let wordCount3 = 0\n  let wordCount4 = 0\n  let wordCount5 = 0\n  let wordCount6 = 0\n  let wordCount7 = 0\n  let wordCount8 = 0\n  let wordCount9 = 0\n  let wordCount10 = 0\n  let wordCount11 = 0\n  let wordCount12 = 0\n  let wordCount13 = 0\n  let wordCount14 = 0\n  let wordCount15 = 0\n  let wordCount16 = 0\n  let wordCount17 = 0\n  let wordCount18 = 0\n  let wordCount19 = 0\n  let wordCount20 = 0\n  let wordCount21 = 0\n  let wordCount22 = 0\n  let wordCount23 = 0\n  let wordCount24 = 0\n  let wordCount25 = 0\n  let wordCount26 = 0\n  let wordCount27 = 0\n  let wordCount28 = 0\n  let wordCount29 = 0\n  let wordCount30 = 0\n  let wordCount31 = 0\n  let wordCount32 = 0\n  let wordCount33 = 0\n  let wordCount34 = 0\n  let wordCount35 = 0\n  let wordCount36 = 0\n  let wordCount37 = 0\n  let wordCount38 = 0\n  let wordCount39 = 0\n  let wordCount40 = 0\n  let wordCount41 = 0\n  let wordCount42 = 0\n  let wordCount43 = 0\n  let wordCount44 = 0\n  let wordCount45 = 0\n  let wordCount46 = 0\n  let wordCount47 = 0\n  let wordCount48 = 0\n  let wordCount49 = 0\n  let wordCount50 = 0\n  let wordCount51 = 0\n  let wordCount52 = 0\n  let wordCount53 = 0\n  let wordCount54 = 0\n  let wordCount55 = 0\n  let wordCount56 = 0\n  let wordCount57 = 0\n  let wordCount58 = 0\n  let wordCount59 = 0\n  let wordCount60 = 0\n  let wordCount61 = 0\n  let wordCount62 = 0\n  let wordCount63 = 0\n  let wordCount64 = 0\n  let wordCount65 = 0\n  let wordCount66 = 0\n  let wordCount67 = 0\n  let wordCount68 = 0\n  let wordCount69 = 0\n  let wordCount70 = 0\n  let wordCount71 = 0\n  let wordCount72 = 0\n  let wordCount73 = 0\n  let wordCount74 = 0\n  let wordCount75 = 0\n  let wordCount76 = 0\n  let wordCount77 = 0\n  let wordCount78 = 0\n  let wordCount79 = 0\n  let wordCount80 = 0\n  let wordCount81 = 0\n  let wordCount82 = 0\n  let wordCount83 = 0\n  let wordCount84 = 0\n  let wordCount85 = 0\n  let wordCount86 = 0\n  let wordCount87 = 0\n  let wordCount88 = 0\n  let wordCount89 = 0\n  let wordCount90 = 0\n  let wordCount91 = 0\n  let wordCount92 = 0\n  let wordCount93 = 0\n  let wordCount94 = 0\n  let wordCount95 = 0\n  let wordCount96 = 0\n  let wordCount97 = 0\n  let wordCount98 = 0\n  let wordCount99 = 0\n  let wordCount100 = 0\n  let wordCount101 = 0\n  let wordCount102 = 0\n  let wordCount103 = 0\n  let wordCount104 = 0\n  let wordCount105 = 0\n  let wordCount106 = 0\n  let wordCount107 = 0\n  let wordCount108 = 0\n  let wordCount109 = 0\n  let wordCount110 = 0\n  let wordCount111 = 0\n  let wordCount112 = 0\n  let wordCount113 = 0\n  let wordCount114 = 0\n  let wordCount115 = 0\n  let wordCount116 = 0\n  let wordCount117 = 0\n  let wordCount118 = 0\n  let wordCount119 = 0\n  let wordCount120 = 0\n  let wordCount121 = 0\n  let wordCount122 = 0\n  let wordCount123 = 0\n  let wordCount124 = 0\n  let wordCount125 = 0\n  let wordCount126 = 0\n  let wordCount127 = 0\n  let wordCount128 = 0\n  let wordCount129 = 0\n  let wordCount130 = 0\n  let wordCount131 = 0\n  let wordCount132 = 0\n  let wordCount133 = 0\n  let wordCount134 = 0\n  let wordCount135 = 0\n  let wordCount136 = 0\n  let wordCount137 = 0\n  let wordCount138 = 0\n  let wordCount139 = 0\n  let wordCount140 = 0\n  let wordCount141 = 0\n  let wordCount142 = 0\n  let wordCount143 = 0\n  let wordCount144 = 0\n  let wordCount145 = 0\n  let wordCount146 = 0\n  let wordCount147 = 0\n  let wordCount148 = 0\n  let wordCount149 = 0\n  let wordCount150 = 0\n  let wordCount151 = 0\n  let wordCount152 = 0\n  let wordCount153 = 0\n  let wordCount154 = 0\n  let wordCount155 = 0\n  let wordCount156 = 0\n  let wordCount157 = 0\n  let wordCount158 = 0\n  let wordCount159 = 0\n  let wordCount160 = 0\n  let wordCount161 = 0\n  let wordCount162 = 0\n  let wordCount163 = 0\n  let wordCount164 = 0\n  let wordCount165 = 0\n  let wordCount166 = 0\n  let wordCount167 = 0\n  let wordCount168 = 0\n  let wordCount169 = 0\n  let wordCount170 = 0\n  let wordCount171 = 0\n  let wordCount172 = 0\n  let wordCount173 = 0\n  let wordCount174 = 0\n  let wordCount175 = 0\n  let wordCount176 = 0\n  let wordCount177 = 0\n  let wordCount178 = 0\n  let wordCount179 = 0\n  let wordCount180 = 0\n  let wordCount181 = 0\n  let wordCount182 = 0\n  let wordCount183 = 0\n  let wordCount184 = 0\n  let wordCount185 = 0\n  let wordCount186 = 0\n  let wordCount187 = 0\n  let wordCount188 = 0\n  let wordCount189 = 0\n  let wordCount190 = 0\n  let wordCount191 = 0\n  let wordCount192 = 0\n  let wordCount193 = 0\n  let wordCount194 = 0\n  let wordCount195 = 0\n  let wordCount196 = 0\n  let wordCount197 = 0\n  let wordCount198 = 0\n  let wordCount199 = 0\n  let wordCount200 = 0\n  let wordCount201 = 0\n  let wordCount202 = 0\n  let wordCount203 = 0\n  let wordCount204 = 0\n  let wordCount205 = 0\n  let wordCount206 = 0\n  let wordCount207 = 0\n  let wordCount208 = 0\n  let wordCount209 = 0\n  let wordCount210 = 0\n  let wordCount211 = 0\n  let wordCount212 = 0\n  let wordCount213 = 0\n  let wordCount214 = 0\n  let wordCount215 = 0\n  let wordCount216 = 0\n  let wordCount217 = 0\n  let wordCount218 = 0\n  let wordCount219 = 0\n  let wordCount220 = 0\n  let wordCount221 = 0\n  let wordCount", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/118", "prompt": "/*YYour task is to find the next vowel between two consonants on the right side of the word (case-insensitive), vowels at the beginning and end do not count, and you return an empty string if you have not found a vowel that meets the above condition, and you can assume that the given string contains only English letters.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*YYour task is to find the next vowel between two consonants on the right side of the word (case-insensitive), vowels at the beginning and end do not count, and you return an empty string if you have not found a vowel that meets the above condition, and you can assume that the given string contains only English letters.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowelsArray = vowels.map(v => v.toLowerCase());\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayIndex = 0;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayIndex2 = 0;\n  let vowelsArrayLength2 = vowelsArray.length;\n  let vowelsArrayIndex3 = 0;\n  let vowelsArrayLength3 = vowelsArray.length;\n  let vowelsArrayIndex4 = 0;\n  let vowelsArrayLength4 = vowelsArray.length;\n  let vowelsArrayIndex5 = 0;\n  let vowelsArrayLength5 = vowelsArray.length;\n  let vowelsArrayIndex6 = 0;\n  let vowelsArrayLength6 = vowelsArray.length;\n  let vowelsArrayIndex7 = 0;\n  let vowelsArrayLength7 = vowelsArray.length;\n  let vowelsArrayIndex8 = 0;\n  let vowelsArrayLength8 = vowelsArray.length;\n  let vowelsArrayIndex9 = 0;\n  let vowelsArrayLength9 = vowelsArray.length;\n  let vowelsArrayIndex10 = 0;\n  let vowelsArrayLength10 = vowelsArray.length;\n  let vowelsArrayIndex11 = 0;\n  let vowelsArrayLength11 = vowelsArray.length;\n  let vowelsArrayIndex12 = 0;\n  let vowelsArrayLength12 = vowelsArray.length;\n  let vowelsArrayIndex13 = 0;\n  let vowelsArrayLength13 = vowelsArray.length;\n  let vowelsArrayIndex14 = 0;\n  let vowelsArrayLength14 = vowelsArray.length;\n  let vowelsArrayIndex15 = 0;\n  let vowelsArrayLength15 = vowelsArray.length;\n  let vowelsArrayIndex16 = 0;\n  let vowelsArrayLength16 = vowelsArray.length;\n  let vowelsArrayIndex17 = 0;\n  let vowelsArrayLength17 = vowelsArray.length;\n  let vowelsArrayIndex18 = 0;\n  let vowelsArrayLength18 = vowelsArray.length;\n  let vowelsArrayIndex19 = 0;\n  let vowelsArrayLength19 = vowelsArray.length;\n  let vowelsArrayIndex20 = 0;\n  let vowelsArrayLength20 = vowelsArray.length;\n  let vowelsArrayIndex21 = 0;\n  let vowelsArrayLength21 = vowelsArray.length;\n  let vowelsArrayIndex22 = 0;\n  let vowelsArrayLength22 = vowelsArray.length;\n  let vowelsArrayIndex23 = 0;\n  let vowelsArrayLength23 = vowelsArray.length;\n  let vowelsArrayIndex24 = 0;\n  let vowelsArrayLength24 = vowelsArray.length;\n  let vowelsArrayIndex25 = 0;\n  let vowelsArrayLength25 = vowelsArray.length;\n  let vowelsArrayIndex26 = 0;\n  let vowelsArrayLength26 = vowelsArray.length;\n  let vowelsArrayIndex27 = 0;\n  let vowelsArrayLength27 = vowelsArray.length;\n  let vowelsArrayIndex28 = 0;\n  let vowelsArrayLength28 = vowelsArray.length;\n  let vowelsArrayIndex29 = 0;\n  let vowelsArrayLength29 = vowelsArray.length;\n  let vowelsArrayIndex30 = 0;\n  let vowelsArrayLength30 = vowelsArray.length;\n  let vowelsArrayIndex31 = 0;\n  let vowelsArrayLength31 = vowelsArray.length;\n  let vowelsArrayIndex32 = 0;\n  let vowelsArrayLength32 = vowelsArray.length;\n  let vowelsArrayIndex33 = 0;\n  let vowelsArrayLength33 = vowelsArray.length;\n  let vowelsArrayIndex34 = 0;\n  let vowelsArrayLength34 = vowelsArray.length;\n  let vowelsArrayIndex35 = 0;\n  let vowelsArrayLength35 = vowelsArray.length;\n  let vowelsArrayIndex36 = 0;\n  let vowelsArrayLength36 = vowelsArray.length;\n  let vowelsArrayIndex37 = 0;\n  let vowelsArrayLength37 = vowelsArray.length;\n  let vowelsArrayIndex38 = 0;\n  let vowelsArrayLength38 = vowelsArray.length;\n  let vowelsArrayIndex39 = 0;\n  let vowelsArrayLength39 = vowelsArray.length;\n  let vowelsArrayIndex40 = 0;\n  let vowelsArrayLength40 = vowelsArray.length;\n  let vowelsArrayIndex41 = 0;\n  let vowelsArrayLength41 = vowelsArray.length;\n  let vowelsArrayIndex42 = 0;\n  let vowelsArrayLength42 = vowelsArray.length;\n  let vowelsArrayIndex43 = 0;\n  let vowelsArrayLength43 = vowelsArray.length;\n  let vowelsArrayIndex44 = 0;\n  let vowelsArrayLength44 = vowelsArray.length;\n  let vowelsArrayIndex45 = 0;\n  let vowelsArrayLength45 = vowelsArray.length;\n  let vowelsArrayIndex46 = 0;\n  let vowelsArrayLength46 = vowelsArray.length;\n  let vowelsArrayIndex47 = 0;\n  let vowelsArrayLength47 = vowelsArray.length;\n  let vowelsArrayIndex48 = 0;\n  let vowelsArrayLength48 = vowelsArray.length;\n  let vowelsArrayIndex49 = 0;\n  let vowelsArrayLength49 = vowelsArray.length;\n  let vowelsArrayIndex50 = 0;\n  let vowelsArrayLength50 = vowelsArray.length;\n  let vowelsArrayIndex51 = 0;\n  let vowelsArrayLength51 = vowelsArray.length;\n  let vowelsArrayIndex52 = 0;\n  let vowelsArrayLength52 = vowelsArray.length;\n  let vowelsArrayIndex53 = 0;\n  let vowelsArrayLength53 = vowelsArray.length;\n  let vowelsArrayIndex54 = 0;\n  let vowelsArrayLength54 = vowelsArray.length;\n  let vowelsArrayIndex55 = 0;\n  let vowelsArrayLength55 = vowelsArray.length;\n  let vowelsArrayIndex56 = 0;\n  let vowelsArrayLength56 = vowelsArray.length;\n  let vowelsArrayIndex57 = 0;\n  let vowelsArrayLength57 = vowelsArray.length;\n  let vowelsArrayIndex58 = 0;\n  let vowelsArrayLength58 = vowelsArray.length;\n  let vowelsArrayIndex59 = 0;\n  let vowelsArrayLength59 = vowelsArray.length;\n  let vowelsArrayIndex60 = 0;\n  let vowelsArrayLength60 = vowelsArray.length;\n  let vowelsArrayIndex61 = 0;\n  let vowelsArrayLength61 = vowelsArray.length;\n  let vowelsArrayIndex62 = 0;\n  let vowelsArrayLength62 = vowelsArray.length;\n  let vowelsArrayIndex63 = 0;\n  let vowelsArrayLength63 = vowelsArray.length;\n  let vowelsArrayIndex64 = 0;\n  let vowelsArrayLength64 = vowelsArray.length;\n  let vowelsArrayIndex65 = 0;\n  let vowelsArrayLength65 = vowelsArray.length;\n  let vowelsArrayIndex66 = 0;\n  let vowelsArrayLength66 = vowelsArray.length;\n  let vowelsArrayIndex67 = 0;\n  let vowelsArrayLength67 = vowelsArray.length;\n  let vowelsArrayIndex68 = 0;\n  let vowelsArrayLength68 = vowelsArray.length;\n  let vowelsArrayIndex69 = 0;\n  let vowelsArrayLength69 = vowelsArray.length;\n  let vowelsArray", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/119", "prompt": "/* You get a list of two strings, both strings consisting only of open brackets' ('or closed brackets') '. Your task is to check if it is possible to concatenate the two strings in a certain order so that the resulting string is good. A string S is considered good if and only if all the brackets in S are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* You get a list of two strings, both strings consisting only of open brackets' ('or closed brackets') '. Your task is to check if it is possible to concatenate the two strings in a certain order so that the resulting string is good. A string S is considered good if and only if all the brackets in S are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let isGood = true;\n  let isBalanced = false;\n  let isOpenParen = false;\n  let isClosedParen = false;\n  let isOpenBracket = false;\n  let isClosedBracket = false;\n  let isOpenParenParen = false;\n  let isClosedParenParen = false;\n  let isOpenBracketParen = false;\n  let isClosedBracketParen = false;\n  let isOpenParenBracket = false;\n  let isClosedParenBracket = false;\n  let isOpenBracketBracket = false;\n  let isClosedParenBracket = false;\n  let isOpenParenBracketParen = false;\n  let isClosedParenBracketParen = false;\n  let isOpenParenBracketBracket = false;\n  let isClosedParenBracketBracket = false;\n  let isOpenParenBracketBracketParen = false;\n  let isClosedParenBracketBracketParen = false;\n  let isOpenParenBracketBracketBracket = false;\n  let isClosedParenBracketBracketBracket = false;\n  let isOpenParenBracketBracketBracketParen = false;\n  let isClosedParenBracketBracketBracketBracketParen = false;\n  let isOpenParenBracketBracketBracketBracket = false;\n  let isClosedParenBracketBracketBracketBracket = false;\n  let isOpenParenBracketBracketBracketBracketParen = false;\n  let isClosedParenBracketBracketBracketBracketParen = false;\n  let isOpenParenBracketBracketBracketBracket = false;\n  let isClosedParenBracketBracketBracketBracket = false;\n  let isOpenParenBracketBracketBracketBracketParen = false;\n  let isClosedParenBracketBracketBracketBracketBracketParen = false;\n  let isOpenParenBracketBracketBracketBracketBracket = false;\n  let isClosedParenBracketBracketBracketBracketBracket = false;\n  let isOpenParenBracketBracketBracketBracketBracketParen = false;\n  let isClosedParenBracketBracketBracketBracketBracketBracketParen = false;\n  let isOpenParenBracketBracketBracketBracketBracketBracket = false;\n  let isClosedParenBracketBracketBracketBracketBracket = false;\n  let isOpenParenBracketBracketBracketBracketBracketParen = false;\n  let isClosedParenBracketBracketBracketBracketBracketBracketParen = false;\n  let isOpenParenBracketBracketBracketBracketBracketBracket = false;\n  let isClosedParenBracketBracketBracketBracketBracketBracket = false;\n  let isOpenParenBracketBracketBracketBracketBracket = false;\n  let isClosedParenBracketBracketBracketBracketBracket = false;\n  let isOpenParenBracketBracketBracketBracketBracketBracket = false;\n  let isClosedParenBracketBracketBracketBracketBracketBracket = false;\n  let isOpenParenBracketBracketBracketBracketBracket = false;\n  let isClosedParenBracketBracketBracketBracketBracket = false;\n  let isOpenParenBracketBracketBracketBracketBracketBracket = false;\n  let isClosedParenBracketBracketBracketBracketBracketBracket = false;\n  let isOpenParenBracketBracketBracketBracketBracketBracket = false;\n  let isClosedParenBracketBracketBracketBracketBracketBracket = false;\n  let isOpenParenBracketBracketBracketBracketBracketBracket = false;\n  let isClosedParenBracketBracketBracketBracketBracketBracket = false;\n  let isOpenParenBracketBracketBracketBracketBracketBracket = false;\n  let isClosedParenBracketBracketBracketBracketBracketBracket = false;\n  let isOpenParenBracketBracketBracketBracketBracketBracketBracket = false;\n  let isClosedParenBracketBracketBracketBracketBracketBracketBracket = false;\n  let isOpenParenBracketBracketBracketBracketBracketBracketBracket = false;\n  let isClosedParenBracketBracketBracketBracketBracketBracketBracket = false;\n  let isOpenParenBracketBracketBracketBracketBracketBracketBracket = false;\n  let isClosedParenBracketBracketBracketBracketBracketBracketBracketBracket = false;\n  let isOpenParenBracketBracketBracketBracketBracketBracketBracketBracket = false;\n  let isClosedParenBracketBracketBracketBracketBracketBracketBracket = false;\n  let isOpenParenBracketBracketBracketBracketBracketBracketBracketBracket = false;\n  let isClosedParenBracketBracketBracketBracketBracketBracketBracketBracketBracket = false;\n  let isOpenParenBracketBracketBracketBracketBracketBracketBracketBracketBracketBracket = false;\n  let isClosedParenBracketBracketBracketBracketBracketBracketBracketBracket = false;\n  let isOpenParenBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracket = false;\n  let isClosedParenBracketBracketBracketBracketBracketBracketBracketBracketBracketBracket = false;\n  let isOpenParenBracketBracketBracketBracketBracketBracketBracketBracketBracket = false;\n  let isClosedParenBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracket = false;\n  let isOpenParenBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracket = false;\n  let isClosedParenBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracket = false;\n  let isOpenParenBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBracketBra", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/12", "prompt": "/* Returns the longest string from the list of strings. Returns the first one if there are multiple strings of the same length. Returns zero if the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Returns the longest string from the list of strings. Returns the first one if there are multiple strings of the same length. Returns zero if the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (strings.length === 0) {\n    return 0\n  }\n  let longestLength = 0\n  let longestString = ''\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].length > longestLength) {\n      longestLength = strings[i].length\n      longestString = strings[i]\n    }\n  }\n  return longestString\n}\n\n/**\n * Returns a new string that is the concatenation of the elements of the given list. Returns the empty string if the input list is empty.\n  >>> concat([])\n\n  >>> concat(['a', 'b', 'c'])\n  'abc'\n  >>> concat(['a', 'bb', 'ccc'])\n  'abcbbccc'\n  */\nconst concat = (list) => {\n  if (list.length === 0) {\n    return ''\n  }\n  let result = ''\n  for (let i = 0; i < list.length; i++) {\n    result += list[i]\n  }\n  return result\n}\n\n/**\n * Returns a new string that is the concatenation of the elements of the given list. Returns the empty string if the input list is empty.\n  >>> concat(['a', 'b', 'c'])\n  'abc'\n  >>> concat(['a', 'bb', 'ccc'])\n  'abcbbccc'\n  */\nconst concatAll = (list) => {\n  if (list.length === 0) {\n    return ''\n  }\n  let result = ''\n  for (let i = 0; i < list.length; i++) {\n    result += list[i]\n  }\n  return result\n}\n\n/**\n * Returns a new string that is the concatenation of the elements of the given list. Returns the empty string if the input list is empty.\n  >>> concat(['a', 'b', 'c'])\n  'abc'\n  >>> concat(['a', 'bb', 'ccc'])\n  'abcbbccc'\n  */\nconst concatAllWithSeparator = (separator, list) => {\n  if (list.length === 0) {\n    return ''\n  }\n  let result = ''\n  for (let i = 0; i < list.length; i++) {\n    result += list[i]\n  }\n  return result + separator\n}\n\n/**\n * Returns a new string that is the concatenation of the elements of the given list. Returns the empty string if the input list is empty.\n  >>> concat(['a', 'b', 'c'])\n  'abc'\n  >>> concat(['a', 'bb', 'ccc'])\n  'abcbbccc'\n  */\nconst concatAllWithSeparatorAndSeparator = (separator, separator2, list) => {\n  if (list.length === 0) {\n    return ''\n  }\n  let result = ''\n  for (let i = 0; i < list.length; i++) {\n    result += list[i]\n  }\n  return result + separator + separator2\n}\n\n/**\n * Returns a new string that is the concatenation of the elements of the given list. Returns the empty string if the input list is empty.\n  >>> concat(['a', 'b', 'c'])\n  'abc'\n  >>> concat(['a', 'bb', 'ccc'])\n  'abcbbccc'\n  */\nconst concatAllWithSeparatorAndSeparator2 = (separator, separator2, list) => {\n  if (list.length === 0) {\n    return ''\n  }\n  let result = ''\n  for (let i = 0; i < list.length; i++) {\n    result += list[i]\n  }\n  return result + separator + separator2 + separator\n}\n\n/**\n * Returns a new string that is the concatenation of the elements of the given list. Returns the empty string if the input list is empty.\n  >>> concat(['a', 'b', 'c'])\n  'abc'\n  >>> concat(['a', 'bb', 'ccc'])\n  'abcbbccc'\n  */\nconst concatAllWithSeparatorAndSeparator3 = (separator, separator2, separator3, list) => {\n  if (list.length === 0) {\n    return ''\n  }\n  let result = ''\n  for (let i = 0; i < list.length; i++) {\n    result += list[i]\n  }\n  return result + separator + separator2 + separator3 + separator\n}\n\n/**\n * Returns a new string that is the concatenation of the elements of the given list. Returns the empty string if the input list is empty.\n  >>> concat(['a', 'b', 'c'])\n  'abc'\n  >>> concat(['a', 'bb', 'ccc'])\n  'abcbbccc'\n  */\nconst concatAllWithSeparatorAndSeparator4 = (separator, separator2, separator3, separator4, list) => {\n  if (list.length === 0) {\n    return ''\n  }\n  let result = ''\n  for (let i = 0; i < list.length; i++) {\n    result += list[i]\n  }\n  return result + separator + separator2 + separator3 + separator4 + separator\n}\n\n/**\n * Returns a new string that is the concatenation of the elements of the given list. Returns the empty string if the input list is empty.\n  >>> concat(['a', 'b', 'c'])\n  'abc'\n  >>> concat(['a', 'bb', 'ccc'])\n  'abcbbccc'\n  */\nconst concatAllWithSeparatorAndSeparator5 = (separator, separator2, separator3, separator4, separator5, list) => {\n  if (list.length === 0) {\n    return ''\n  }\n  let result = ''\n  for (let i = 0; i < list.length; i++) {\n    result += list[i]\n  }\n  return result + separator + separator2 + separator3 + separator4 + separator5 + separator\n}\n\n/**\n * Returns a new string that is the concatenation of the elements of the given list. Returns the empty string if the input list is empty.\n  >>> concat(['a', 'b', 'c'])\n  'abc'\n  >>> concat(['a', 'bb', 'ccc'])\n  'abcbbccc'\n  */\nconst concatAllWithSeparatorAndSeparator6 = (separator, separator2, separator3, separator4, separator5, separator6, list) => {\n  if (list.length === 0) {\n    return ''\n  }\n  let result = ''\n  for (let i = 0; i < list.length; i++) {\n    result += list[i]\n  }\n  return result + separator + separator2 + separator3 + separator4 + separator5 + separator6 + separator\n}\n\n/**\n * Returns a new string that is the concatenation of the elements of the given list. Returns the empty string if the input list is empty.\n  >>> concat(['a', 'b', 'c'])\n  'abc'\n  >>> concat(['a', 'bb', 'ccc'])\n  'abcbbccc'\n  */\nconst concatAllWithSeparatorAndSeparator7 = (separator, separator2, separator3, separator4, separator5, separator6, separator7, list) => {\n  if (list.length === 0) {\n    return ''\n  }\n  let result = ''\n  for (let i = 0; i < list.length; i++) {\n    result += list[i]\n  }\n  return result + separator + separator2 + separator3 + separator4 + separator5 + separator6 + separator7 + separator\n}\n\n/**\n * Returns a new string that is the concatenation of the elements of the given list. Returns the empty string if the input list is empty.\n  >>> concat(['a', 'b', 'c'])\n  'abc'\n  >>> concat(['a', 'bb', 'ccc'])\n  'abcbbccc'\n  */\nconst concatAllWithSeparatorAndSeparator8 = (separator, separator2, separator3, separator4, separator5, separator6, separator7, separator8, list) => {\n  if (list.length === 0) {\n    return ''\n  }\n  let result = ''\n  for (let i = 0; i < list.length; i++) {\n    result += list[i]\n  }\n  return result + separator + separator2 + separator3 + separator4 + separator5 + separator6 + separator7 + separator8 + separator\n}\n\n/**\n * Returns a new string that is the concatenation of the elements of the given list. Returns the empty string if the input list is empty.\n  >>> concat(['a', 'b', 'c'])\n  'abc'\n  >>> concat(['a', 'bb', 'ccc'])\n  'abcbbccc'\n  */\nconst concatAllWithSeparatorAndSeparator9 = (separator, separator2, separator3, separator4, separator5, separator6, separator7, separator8, separator9, list) => {\n  if (list.length === 0) {\n    return ''\n  }\n  let result = ''\n  for (let i = 0; i < list.length; i++) {\n    result += list[i]\n  }\n  return result + separator + separator2 + separator3 + separator4 + separator5 + separator6 + separator7 + separator8 + separator9 + separator\n}\n\n/**\n * Returns a new string that is the concatenation of the elements of the given list. Returns the empty string if the input list is empty.\n  >>> concat(['a', 'b', 'c'])\n  'abc'\n  >>> concat(['a', 'bb', 'ccc'])\n  'abc", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/120", "prompt": "/*\n  If you specify an array of integers and a positive integer k, you return a sorted list of length k with the maximum k numbers in Arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  If you specify an array of integers and a positive integer k, you return a sorted list of length k with the maximum k numbers in Arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const len = arr.length;\n  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < len; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return [arr[maxIndex], maxIndex];\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar countDistinctNumbers = function(head) {\n  let count = 0;\n  let curr = head;\n  while (curr) {\n    if (curr.next) {\n      count += 1;\n      curr = curr.next;\n    } else {\n      break;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar countDistinctNumbersII = function(head) {\n  let count = 0;\n  let curr = head;\n  while (curr) {\n    if (curr.next) {\n      count += 1;\n      curr = curr.next;\n    } else {\n      break;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar countDistinctNumbersIII = function(head) {\n  let count = 0;\n  let curr = head;\n  while (curr) {\n    if (curr.next) {\n      count += 1;\n      curr = curr.next;\n    } else {\n      break;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar countDistinctNumbersIV = function(head) {\n  let count = 0;\n  let curr = head;\n  while (curr) {\n    if (curr.next) {\n      count += 1;\n      curr = curr.next;\n    } else {\n      break;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar countDistinctNumbersV = function(head) {\n  let count = 0;\n  let curr = head;\n  while (curr) {\n    if (curr.next) {\n      count += 1;\n      curr = curr.next;\n    } else {\n      break;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar countDistinctNumbersVI = function(head) {\n  let count = 0;\n  let curr = head;\n  while (curr) {\n    if (curr.next) {\n      count += 1;\n      curr = curr.next;\n    } else {\n      break;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar countDistinctNumbersVII = function(head) {\n  let count = 0;\n  let curr = head;\n  while (curr) {\n    if (curr.next) {\n      count += 1;\n      curr = curr.next;\n    } else {\n      break;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar countDistinctNumbersVIII = function(head) {\n  let count = 0;\n  let curr = head;\n  while (curr) {\n    if (curr.next) {\n      count += 1;\n      curr = curr.next;\n    } else {\n      break;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar countDistinctNumbersIX = function(head) {\n  let count = 0;\n  let curr = head;\n  while (curr) {\n    if (curr.next) {\n      count += 1;\n      curr = curr.next;\n    } else {\n      break;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar countDistinctNumbersX = function(head) {\n  let count = 0;\n  let curr = head;\n  while (curr) {\n    if (curr.next) {\n      count += 1;\n      curr = curr.next;\n    } else {\n      break;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar countDistinctNumbersXI = function(head) {\n  let count = 0;\n  let curr = head;\n  while (curr) {\n    if (curr.next) {\n      count += 1;\n      curr = curr.next;\n    } else {\n      break;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/121", "prompt": "/*GIf you create a non-empty list of integers, you return the sum of all odd elements in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*GIf you create a non-empty list of integers, you return the sum of all odd elements in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  let odd = 0;\n  let even = 0;\n  let evenIndex = 0;\n  let oddIndex = 0;\n  let evenIndex2 = 0;\n  let oddIndex2 = 0;\n  let evenIndex3 = 0;\n  let oddIndex3 = 0;\n  let evenIndex4 = 0;\n  let oddIndex4 = 0;\n  let evenIndex5 = 0;\n  let oddIndex5 = 0;\n  let evenIndex6 = 0;\n  let oddIndex6 = 0;\n  let evenIndex7 = 0;\n  let oddIndex7 = 0;\n  let evenIndex8 = 0;\n  let oddIndex8 = 0;\n  let evenIndex9 = 0;\n  let oddIndex9 = 0;\n  let evenIndex10 = 0;\n  let oddIndex10 = 0;\n  let evenIndex11 = 0;\n  let oddIndex11 = 0;\n  let evenIndex12 = 0;\n  let oddIndex12 = 0;\n  let evenIndex13 = 0;\n  let oddIndex13 = 0;\n  let evenIndex14 = 0;\n  let oddIndex14 = 0;\n  let evenIndex15 = 0;\n  let oddIndex15 = 0;\n  let evenIndex16 = 0;\n  let oddIndex16 = 0;\n  let evenIndex17 = 0;\n  let oddIndex17 = 0;\n  let evenIndex18 = 0;\n  let oddIndex18 = 0;\n  let evenIndex19 = 0;\n  let oddIndex19 = 0;\n  let evenIndex20 = 0;\n  let oddIndex20 = 0;\n  let evenIndex21 = 0;\n  let oddIndex21 = 0;\n  let evenIndex22 = 0;\n  let oddIndex22 = 0;\n  let evenIndex23 = 0;\n  let oddIndex23 = 0;\n  let evenIndex24 = 0;\n  let oddIndex24 = 0;\n  let evenIndex25 = 0;\n  let oddIndex25 = 0;\n  let evenIndex26 = 0;\n  let oddIndex26 = 0;\n  let evenIndex27 = 0;\n  let oddIndex27 = 0;\n  let evenIndex28 = 0;\n  let oddIndex28 = 0;\n  let evenIndex29 = 0;\n  let oddIndex29 = 0;\n  let evenIndex30 = 0;\n  let oddIndex30 = 0;\n  let evenIndex31 = 0;\n  let oddIndex31 = 0;\n  let evenIndex32 = 0;\n  let oddIndex32 = 0;\n  let evenIndex33 = 0;\n  let oddIndex33 = 0;\n  let evenIndex34 = 0;\n  let oddIndex34 = 0;\n  let evenIndex35 = 0;\n  let oddIndex35 = 0;\n  let evenIndex36 = 0;\n  let oddIndex36 = 0;\n  let evenIndex37 = 0;\n  let oddIndex37 = 0;\n  let evenIndex38 = 0;\n  let oddIndex38 = 0;\n  let evenIndex39 = 0;\n  let oddIndex39 = 0;\n  let evenIndex40 = 0;\n  let oddIndex40 = 0;\n  let evenIndex41 = 0;\n  let oddIndex41 = 0;\n  let evenIndex42 = 0;\n  let oddIndex42 = 0;\n  let evenIndex43 = 0;\n  let oddIndex43 = 0;\n  let evenIndex44 = 0;\n  let oddIndex44 = 0;\n  let evenIndex45 = 0;\n  let oddIndex45 = 0;\n  let evenIndex46 = 0;\n  let oddIndex46 = 0;\n  let evenIndex47 = 0;\n  let oddIndex47 = 0;\n  let evenIndex48 = 0;\n  let oddIndex48 = 0;\n  let evenIndex49 = 0;\n  let oddIndex49 = 0;\n  let evenIndex50 = 0;\n  let oddIndex50 = 0;\n  let evenIndex51 = 0;\n  let oddIndex51 = 0;\n  let evenIndex52 = 0;\n  let oddIndex52 = 0;\n  let evenIndex53 = 0;\n  let oddIndex53 = 0;\n  let evenIndex54 = 0;\n  let oddIndex54 = 0;\n  let evenIndex55 = 0;\n  let oddIndex55 = 0;\n  let evenIndex56 = 0;\n  let oddIndex56 = 0;\n  let evenIndex57 = 0;\n  let oddIndex57 = 0;\n  let evenIndex58 = 0;\n  let oddIndex58 = 0;\n  let evenIndex59 = 0;\n  let oddIndex59 = 0;\n  let evenIndex60 = 0;\n  let oddIndex60 = 0;\n  let evenIndex61 = 0;\n  let oddIndex61 = 0;\n  let evenIndex62 = 0;\n  let oddIndex62 = 0;\n  let evenIndex63 = 0;\n  let oddIndex63 = 0;\n  let evenIndex64 = 0;\n  let oddIndex64 = 0;\n  let evenIndex65 = 0;\n  let oddIndex65 = 0;\n  let evenIndex66 = 0;\n  let oddIndex66 = 0;\n  let evenIndex67 = 0;\n  let oddIndex67 = 0;\n  let evenIndex68 = 0;\n  let oddIndex68 = 0;\n  let evenIndex69 = 0;\n  let oddIndex69 = 0;\n  let evenIndex70 = 0;\n  let oddIndex70 = 0;\n  let evenIndex71 = 0;\n  let oddIndex71 = 0;\n  let evenIndex72 = 0;\n  let oddIndex72 = 0;\n  let evenIndex73 = 0;\n  let oddIndex73 = 0;\n  let evenIndex74 = 0;\n  let oddIndex74 = 0;\n  let evenIndex75 = 0;\n  let oddIndex75 = 0;\n  let evenIndex76 = 0;\n  let oddIndex76 = 0;\n  let evenIndex77 = 0;\n  let oddIndex77 = 0;\n  let evenIndex78 = 0;\n  let oddIndex78 = 0;\n  let evenIndex79 = 0;\n  let oddIndex79 = 0;\n  let evenIndex80 = 0;\n  let oddIndex80 = 0;\n  let evenIndex81 = 0;\n  let oddIndex81 = 0;\n  let evenIndex82 = 0;\n  let oddIndex82 = 0;\n  let evenIndex83 = 0;\n  let oddIndex83 = 0;\n  let evenIndex84 = 0;\n  let oddIndex84 = 0;\n  let evenIndex85 = 0;\n  let oddIndex85 = 0;\n  let evenIndex86 = 0;\n  let oddIndex86 = 0;\n  let evenIndex87 = 0;\n  let oddIndex87 = 0;\n  let evenIndex88 = 0;\n  let oddIndex88 = 0;\n  let evenIndex89 = 0;\n  let oddIndex89 = 0;\n  let evenIndex90 = 0;\n  let oddIndex90 = 0;\n  let evenIndex91 = 0;\n  let oddIndex91 = 0;\n  let evenIndex92 = 0;\n  let oddIndex92 = 0;\n  let evenIndex93 = 0;\n  let oddIndex93 = 0;\n  let evenIndex94 = 0;\n  let oddIndex94 = 0;\n  let evenIndex95 = 0;\n  let oddIndex95 = 0;\n  let evenIndex96 = 0;\n  let oddIndex96 = 0;\n  let evenIndex97 = 0;\n  let oddIndex97 = 0;\n  let evenIndex98 = 0;\n  let oddIndex98 = 0;\n  let evenIndex99 = 0;\n  let oddIndex99 = 0;\n  let evenIndex100 = 0;\n  let oddIndex100 = 0;\n  let evenIndex101 = 0;\n  let oddIndex101 = 0;\n  let evenIndex102 = 0;\n  let oddIndex102 = 0;\n  let evenIndex103 = 0;\n  let oddIndex103 = 0;\n  let evenIndex104 = 0;\n  let oddIndex104 = 0;\n  let evenIndex105 = 0;\n  let oddIndex105 = 0;\n  let evenIndex106 = 0;\n  let oddIndex106 = 0;\n  let evenIndex107 = 0;\n  let oddIndex107 = 0;\n  let evenIndex108 = 0;\n  let oddIndex108 = 0;\n  let evenIndex109 = 0;\n  let oddIndex109 = 0;\n  let evenIndex110 = 0;\n  let oddIndex110 = 0;\n  let evenIndex111 = 0;\n  let oddIndex111 = 0;\n  let evenIndex112 = 0;\n  let oddIndex112 = 0;\n  let evenIndex113 = 0;\n  let oddIndex113 = 0;\n  let evenIndex114 = 0;\n  let oddIndex114 = 0;\n  let evenIndex115 = 0;\n  let oddIndex115 = 0;\n  let evenIndex116 = 0;\n  let oddIndex116 = 0;\n  let evenIndex117 = 0;\n  let oddIndex117 = 0;\n  let evenIndex118 = 0;\n  let oddIndex118 = 0;\n  let evenIndex119 = 0;\n  let oddIndex119 = 0;\n  let evenIndex120 = 0;\n  let oddIndex120 = 0;\n  let evenIndex121 = 0;\n  let oddIndex121 = 0;\n  let evenIndex122 = 0;\n  let oddIndex122 = 0;\n  let even", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/122", "prompt": "/*\n  For a non-empty array of integers arr and an integer k, the sum of the elements with a maximum of two digits from the first k elements of arr is returned.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  For a non-empty array of integers arr and an integer k, the sum of the elements with a maximum of two digits from the first k elements of arr is returned.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let arrLength = arr.length;\n  while (i < arrLength) {\n    if (arr[i] >= 10) {\n      sum += arr[i];\n      i++;\n    } else {\n      sum -= arr[i];\n      i++;\n    }\n  }\n  while (j < k) {\n    sum += arr[j];\n    j++;\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers arr and an integer k, the sum of the elements with a maximum of two digits from the first k elements of arr is returned.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsTwoDigits = (arr, k) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let arrLength = arr.length;\n  while (i < arrLength) {\n    if (arr[i] >= 10) {\n      sum += arr[i];\n      i++;\n    } else {\n      sum -= arr[i];\n      i++;\n    }\n  }\n  while (j < k) {\n    sum += arr[j];\n    j++;\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers arr and an integer k, the sum of the elements with a maximum of three digits from the first k elements of arr is returned.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsThreeDigits = (arr, k) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let arrLength = arr.length;\n  while (i < arrLength) {\n    if (arr[i] >= 10) {\n      sum += arr[i];\n      i++;\n    } else {\n      sum -= arr[i];\n      i++;\n    }\n  }\n  while (j < k) {\n    sum += arr[j];\n    j++;\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers arr and an integer k, the sum of the elements with a maximum of four digits from the first k elements of arr is returned.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsFourDigits = (arr, k) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let arrLength = arr.length;\n  while (i < arrLength) {\n    if (arr[i] >= 10) {\n      sum += arr[i];\n      i++;\n    } else {\n      sum -= arr[i];\n      i++;\n    }\n  }\n  while (j < k) {\n    sum += arr[j];\n    j++;\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers arr and an integer k, the sum of the elements with a maximum of five digits from the first k elements of arr is returned.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsFiveDigits = (arr, k) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let arrLength = arr.length;\n  while (i < arrLength) {\n    if (arr[i] >= 10) {\n      sum += arr[i];\n      i++;\n    } else {\n      sum -= arr[i];\n      i++;\n    }\n  }\n  while (j < k) {\n    sum += arr[j];\n    j++;\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers arr and an integer k, the sum of the elements with a maximum of six digits from the first k elements of arr is returned.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsSixDigits = (arr, k) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let arrLength = arr.length;\n  while (i < arrLength) {\n    if (arr[i] >= 10) {\n      sum += arr[i];\n      i++;\n    } else {\n      sum -= arr[i];\n      i++;\n    }\n  }\n  while (j < k) {\n    sum += arr[j];\n    j++;\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers arr and an integer k, the sum of the elements with a maximum of seven digits from the first k elements of arr is returned.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsSevenDigits = (arr, k) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let arrLength = arr.length;\n  while (i < arrLength) {\n    if (arr[i] >= 10) {\n      sum += arr[i];\n      i++;\n    } else {\n      sum -= arr[i];\n      i++;\n    }\n  }\n  while (j < k) {\n    sum += arr[j];\n    j++;\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers arr and an integer k, the sum of the elements with a maximum of eight digits from the first k elements of arr is returned.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsEightDigits = (arr, k) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let arrLength = arr.length;\n  while (i < arrLength) {\n    if (arr[i] >= 10) {\n      sum += arr[i];\n      i++;\n    } else {\n      sum -= arr[i];\n      i++;\n    }\n  }\n  while (j < k) {\n    sum += arr[j];\n    j++;\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers arr and an integer k, the sum of the elements with a maximum of nine digits from the first k elements of arr is returned.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsNineDigits = (arr, k) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let arrLength = arr.length;\n  while (i < arrLength) {\n    if (arr[i] >= 10) {\n      sum += arr[i];\n      i++;\n    } else {\n      sum -= arr[i];\n      i++;\n    }\n  }\n  while (j < k) {\n    sum += arr[j];", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let collatz = [];\n  let i = 1;\n  while (n > 0) {\n    if (n % 2 === 0) {\n      collatz.push(i);\n      n /= 2;\n    } else {\n      i++;\n    }\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the even numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5, 3] # The collatz sequence for 5 is [1, 5, 3, 8, 4, 2], so the even numbers are 1, 3, 5, 8, 4, and 2.\n  */\nconst getEvenCollatz = (n) => {\n  let collatz = [];\n  let i = 1;\n  while (n > 0) {\n    if (n % 2 === 0) {\n      collatz.push(i);\n      n /= 2;\n    } else {\n      i++;\n    }\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 3, 5, 7, 9, 11] # The collatz sequence for 5 is [1, 3, 5, 7, 9, 11, 13, 15], so \n  the prime numbers are 1, 3, 5, 7, 9, 11, 13, 15.\n  */\nconst getPrimeCollatz = (n) => {\n  let collatz = [];\n  let i = 1;\n  while (n > 0) {\n    if (n % 2 === 0) {\n      collatz.push(i);\n      n /= 2;\n    } else {\n      i++;\n    }\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 3, 5, 7, 9, 11] # The collatz sequence for 5 is [1, 3, 5, 7, 9, 11, 13, 15], so \n  the prime numbers are 1, 3, 5, 7, 9, 11, 13, 15.\n  */\nconst getPrimeCollatz = (n) => {\n  let collatz = [];\n  let i = 1;\n  while (n > 0) {\n    if (n % 2 === 0) {\n      collatz.push(i);\n      n /= 2;\n    } else {\n      i++;\n    }\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 3, 5, 7, 9, 11] # The collatz sequence for 5 is [1, 3, 5, 7, 9, 11, 13, 15], so \n  the prime numbers are 1, 3, 5, 7, 9, 11, 13, 15.\n  */\nconst getPrimeCollatz = (n) => {\n  let collatz = [];\n  let i = 1;\n  while (n > 0) {\n    if (n % 2 === 0) {\n      collatz.push(i);\n      n /= 2;\n    } else {\n      i++;\n    }\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 3, 5, 7, 9, 11] # The collatz sequence for 5 is [1, 3, 5, 7, 9, 11, 13, 15], so \n  the prime numbers are 1, 3, 5, 7, 9, 11, 13, 15.\n  */\nconst getPrimeCollatz = (n) => {\n  let collatz = [];\n  let i = 1;\n  while (n > 0) {\n    if (n % 2 === 0) {\n      collatz.push(i);\n      n /= 2;\n    } else {\n      i++;\n    }\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is ", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/124", "prompt": "/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const [month, day, year] = date.split('-');\n  const isValid = month >= 1 && month <= 12 && day >= 1 && day <= 31 && year >= 1980 && year <= 2040;\n  return isValid;\n};\n\n/**\n * Validates whether the given string is a valid phone number.\n * It checks the following rules:\n * 1. The string is not empty.\n * 2. The string contains only digits and dashes.\n * 3. The string contains only digits and dashes.\n * 4. The string contains only digits and dashes.\n * 5. The string contains only digits and dashes.\n * 6. The string contains only digits and dashes.\n * 7. The string contains only digits and dashes.\n * 8. The string contains only digits and dashes.\n * 9. The string contains only digits and dashes.\n * 10. The string contains only digits and dashes.\n * 11. The string contains only digits and dashes.\n * 12. The string contains only digits and dashes.\n * 13. The string contains only digits and dashes.\n * 14. The string contains only digits and dashes.\n * 15. The string contains only digits and dashes.\n * 16. The string contains only digits and dashes.\n * 17. The string contains only digits and dashes.\n * 18. The string contains only digits and dashes.\n * 19. The string contains only digits and dashes.\n * 20. The string contains only digits and dashes.\n * 21. The string contains only digits and dashes.\n * 22. The string contains only digits and dashes.\n * 23. The string contains only digits and dashes.\n * 24. The string contains only digits and dashes.\n * 25. The string contains only digits and dashes.\n * 26. The string contains only digits and dashes.\n * 27. The string contains only digits and dashes.\n * 28. The string contains only digits and dashes.\n * 29. The string contains only digits and dashes.\n * 30. The string contains only digits and dashes.\n * 31. The string contains only digits and dashes.\n * 32. The string contains only digits and dashes.\n * 33. The string contains only digits and dashes.\n * 34. The string contains only digits and dashes.\n * 35. The string contains only digits and dashes.\n * 36. The string contains only digits and dashes.\n * 37. The string contains only digits and dashes.\n * 38. The string contains only digits and dashes.\n * 39. The string contains only digits and dashes.\n * 40. The string contains only digits and dashes.\n * 41. The string contains only digits and dashes.\n * 42. The string contains only digits and dashes.\n * 43. The string contains only digits and dashes.\n * 44. The string contains only digits and dashes.\n * 45. The string contains only digits and dashes.\n * 46. The string contains only digits and dashes.\n * 47. The string contains only digits and dashes.\n * 48. The string contains only digits and dashes.\n * 49. The string contains only digits and dashes.\n * 50. The string contains only digits and dashes.\n * 51. The string contains only digits and dashes.\n * 52. The string contains only digits and dashes.\n * 53. The string contains only digits and dashes.\n * 54. The string contains only digits and dashes.\n * 55. The string contains only digits and dashes.\n * 56. The string contains only digits and dashes.\n * 57. The string contains only digits and dashes.\n * 58. The string contains only digits and dashes.\n * 59. The string contains only digits and dashes.\n * 60. The string contains only digits and dashes.\n * 61. The string contains only digits and dashes.\n * 62. The string contains only digits and dashes.\n * 63. The string contains only digits and dashes.\n * 64. The string contains only digits and dashes.\n * 65. The string contains only digits and dashes.\n * 66. The string contains only digits and dashes.\n * 67. The string contains only digits and dashes.\n * 68. The string contains only digits and dashes.\n * 69. The string contains only digits and dashes.\n * 70. The string contains only digits and dashes.\n * 71. The string contains only digits and dashes.\n * 72. The string contains only digits and dashes.\n * 73. The string contains only digits and dashes.\n * 74. The string contains only digits and dashes.\n * 75. The string contains only digits and dashes.\n * 76. The string contains only digits and dashes.\n * 77. The string contains only digits and dashes.\n * 78. The string contains only digits and dashes.\n * 79. The string contains only digits and dashes.\n * 80. The string contains only digits and dashes.\n * 81. The string contains only digits and dashes.\n * 82. The string contains only digits and dashes.\n * 83. The string contains only digits and dashes.\n * 84. The string contains only digits and dashes.\n * 85. The string contains only digits and dashes.\n * 86. The string contains only digits and dashes.\n * 87. The string contains only digits and dashes.\n * 88. The string contains only digits and dashes.\n * 89. The string contains only digits and dashes.\n * 90. The string contains only digits and dashes.\n * 91. The string contains only digits and dashes.\n * 92. The string contains only digits and dashes.\n * 93. The string contains only digits and dashes.\n * 94. The string contains only digits and dashes.\n * 95. The string contains only digits and dashes.\n * 96. The string contains only digits and dashes.\n * 97. The string contains only digits and dashes.\n * 98. The string contains only digits and dashes.\n * 99. The string contains only digits and dashes.\n * 100. The string contains only digits and dashes.\n * 101. The string contains only digits and dashes.\n * 102. The string contains only digits and dashes.\n * 103. The string contains only digits and dashes.\n * 104. The string contains only digits and dashes.\n * 105. The string contains only digits and dashes.\n * 106. The string contains only digits and dashes.\n * 107. The string contains only digits and dashes.\n * 108. The string contains only digits and dashes.\n * 109. The string contains only digits and dashes.\n * 110. The string contains only digits and dashes.\n * 111. The string contains only digits and dashes.\n * 112. The string contains only digits and dashes.\n * 113. The string contains only digits and dashes.\n * 114. The string contains only digits and dashes.\n * 115. The string contains only digits and dashes.\n * 116. The string contains only digits and dashes.\n * ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/125", "prompt": "/* If you specify a word sequence, you return a list of words divided into spaces. If there are no spaces in the text, you should split them into commas. \"If there are no commas, you return the number of lowercase letters in odd order in the alphabet: ord (\" a \") = 0, ord (\" b \") = 1,... ord (\" z \") = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* If you specify a word sequence, you return a list of words divided into spaces. If there are no spaces in the text, you should split them into commas. \"If there are no commas, you return the number of lowercase letters in odd order in the alphabet: ord (\" a \") = 0, ord (\" b \") = 1,... ord (\" z \") = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(' ');\n  const wordList = [];\n  let i = 0;\n  let j = 0;\n  let spaces = 0;\n  let commas = 0;\n  let odd = 0;\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].length > 0) {\n      if (words[i].charAt(0) =='') {\n        spaces++;\n      } else if (words[i].charAt(0) == ',') {\n        comas++;\n      } else if (words[i].charAt(0) == '-') {\n        odd++;\n      }\n    }\n  }\n  if (commas > 0) {\n    wordList.push(words.slice(0, words.length - commas));\n  } else if (spaces > 0) {\n    wordList.push(words.slice(0, words.length - spaces));\n  } else if (odd > 0 && odd % 2 === 0) {\n    wordList.push(words.slice(0, words.length - odd));\n  } else {\n    wordList.push(words);\n  }\n  return wordList;\n};\n\n/**\n  Returns a list of all words in the given text. Words are separated by spaces. A word is defined as a sequence of letters separated by spaces. A word is considered a sequence of letters if it contains only letters, numbers, punctuation, or spaces. Words are separated by spaces if there are more than two consecutive spaces in a row. Words are separated by commas if there are more than two consecutive commas in a row. Words are separated by hyphens if there are more than two consecutive hyphens in a row. Words are separated by underscores if there are more than two consecutive underscores in a row. Words are separated by spaces if there are more than two consecutive spaces in a row. Words are separated by commas if there are more than two consecutive commas in a row. Words are separated by hyphens if there are more than two consecutive hyphens in a row. Words are separated by underscores if there are more than two consecutive underscores in a row. Words are separated by spaces if there are more than two consecutive spaces in a row. Words are separated by commas if there are more than two consecutive commas in a row. Words are separated by hyphens if there are more than two consecutive hyphens in a row. Words are separated by underscores if there are more than two consecutive underscores in a row. Words are separated by spaces if there are more than two consecutive spaces in a row. Words are separated by commas if there are more than two consecutive commas in a row. Words are separated by hyphens if there are more than two consecutive hyphens in a row. Words are separated by underscores if there are more than two consecutive underscores in a row. Words are separated by spaces if there are more than two consecutive spaces in a row. Words are separated by commas if there are more than two consecutive commas in a row. Words are separated by hyphens if there are more than two consecutive hyphens in a row. Words are separated by underscores if there are more than two consecutive underscores in a row. Words are separated by spaces if there are more than two consecutive spaces in a row. Words are separated by commas if there are more than two consecutive commas in a row. Words are separated by hyphens if there are more than two consecutive hyphens in a row. Words are separated by underscores if there are more than two consecutive underscores in a row. Words are separated by spaces if there are more than two consecutive spaces in a row. Words are separated by commas if there are more than two consecutive commas in a row. Words are separated by hyphens if there are more than two consecutive hyphens in a row. Words are separated by underscores if there are more than two consecutive underscores in a row. Words are separated by spaces if there are more than two consecutive spaces in a row. Words are separated by commas if there are more than two consecutive commas in a row. Words are separated by hyphens if there are more than two consecutive hyphens in a row. Words are separated by underscores if there are more than two consecutive underscores in a row. Words are separated by spaces if there are more than two consecutive spaces in a row. Words are separated by commas if there are more than two consecutive commas in a row. Words are separated by hyphens if there are more than two consecutive hyphens in a row. Words are separated by underscores if there are more than two consecutive underscores in a row. Words are separated by spaces if there are more than two consecutive spaces in a row. Words are separated by commas if there are more than two consecutive commas in a row. Words are separated by hyphens if there are more than two consecutive hyphens in a row. Words are separated by underscores if there are more than two consecutive underscores in a row. Words are separated by spaces if there are more than two consecutive spaces in a row. Words are separated by commas if there are more than two consecutive commas in a row. Words are separated by hyphens if there are more than two consecutive hyphens in a row. Words are separated by underscores if there are more than two consecutive underscores in a row. Words are separated by spaces if there are more than two consecutive spaces in a row. Words are separated by commas if there are more than two consecutive commas in a row. Words are separated by hyphens if there are more than two consecutive hyphens in a row. Words are separated by underscores if there are more than two consecutive underscores in a row. Words are separated by spaces if there are more than two consecutive spaces in a row. Words are separated by commas if there are more than two consecutive commas in a row. Words are separated by hyphens if there are more than two consecutive hyphens in a row. Words are separated by underscores if there are more than two consecutive underscores in a row. Words are separated by spaces if there are more than two consecutive spaces in a row. Words are separated by commas if there are more than two consecutive commas in a row. Words are separated by hyphens if there are more than two consecutive hyphens in a row. Words are separated by underscores if there are more than two consecutive underscores in a row. Words are separated by spaces if there are more than two consecutive spaces in a row. Words are separated by commas if there are more than two consecutive commas in a row. Words are separated by hyphens if there are more than two consecutive hyphens in a row. Words are separated by underscores if there are more than two consecutive underscores in a row. Words are separated by spaces if there are more than two consecutive spaces in a row. Words are separated by commas if there are more than two consecutive commas in a row. Words are separated by hyphens if there are more than two consecutive hyphens in a row. Words are separated by underscores if there are more than two consecutive underscores in a row. Words are separated by spaces if there are more than two consecutive spaces in a row. Words are separated by commas if there are more than two consecutive commas in a row. Words are separated by hyphens if there are more than two consecutive hyphens in a row. Words are separated by underscores if there are more than two consecutive underscores in a row. Words are separated by spaces if there are more than two consecutive spaces in a row. Words are separated by commas if there are more than two consecutive commas in a row. Words are separated by hyphens if there are more than two consecutive hyphens in a row. Words are separated by underscores if there are more than two consecutive underscores in a row. Words are separated by spaces if there are more than two consecutive spaces in a row. Words are separated by commas if there are more than two consecutive commas in a row. Words are separated by hyphens if there are more than two consecutive hyphens in a row. Words are separated by underscores if there are more than two consecutive underscores in a row. Words are separated by spaces if there are more than two consecutive spaces in a row. Words are separated by commas if there are more than two ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/126", "prompt": "/* If the list has more than one duplicate of the same number, return false. Suppose there are no negative numbers and only integers.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* If the list has more than one duplicate of the same number, return false. Suppose there are no negative numbers and only integers.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n  const len = lst.length;\n  let i = len - 1;\n  let j = i + 1;\n  let k = 0;\n  while (i < len && j < len) {\n    if (lst[i] > lst[j]) {\n      i++;\n      j++;\n    } else if (lst[i] < lst[j]) {\n      j++;\n    } else {\n      k++;\n    }\n  }\n  return k === len;\n};\n\n/**\n * Given a sorted array, return its reverse sorted array.\n * If the array is empty, return an empty array.\n * If the array has only one element, return that element.\n * If the array has more than one element, return an array with only one element.\n * If the array has more than one duplicate of the same number, return false. Suppose there are no negative numbers and only integers.\n  Examples\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1])  [1, 3, 2, 5]\n  reverse([5, 3, 2, 1]) ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/127", "prompt": "/*You get two intervals, each interval being a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*You get two intervals, each interval being a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  const [start3, end3] = interval1;\n  const [start4, end4] = interval2;\n  const [start5, end5] = interval1;\n  const [start6, end6] = interval2;\n  const [start7, end7] = interval1;\n  const [start8, end8] = interval2;\n  const [start9, end9] = interval1;\n  const [start10, end10] = interval2;\n  const [start11, end11] = interval1;\n  const [start12, end12] = interval2;\n  const [start13, end13] = interval1;\n  const [start14, end14] = interval2;\n  const [start15, end15] = interval1;\n  const [start16, end16] = interval2;\n  const [start17, end17] = interval1;\n  const [start18, end18] = interval2;\n  const [start19, end19] = interval1;\n  const [start20, end20] = interval2;\n  const [start21, end21] = interval1;\n  const [start22, end22] = interval2;\n  const [start23, end23] = interval1;\n  const [start24, end24] = interval2;\n  const [start25, end25] = interval1;\n  const [start26, end26] = interval2;\n  const [start27, end27] = interval1;\n  const [start28, end28] = interval2;\n  const [start29, end29] = interval1;\n  const [start30, end30] = interval2;\n  const [start31, end31] = interval1;\n  const [start32, end32] = interval2;\n  const [start33, end33] = interval1;\n  const [start34, end34] = interval2;\n  const [start35, end35] = interval1;\n  const [start36, end36] = interval2;\n  const [start37, end37] = interval1;\n  const [start38, end38] = interval2;\n  const [start39, end39] = interval1;\n  const [start40, end40] = interval2;\n  const [start41, end41] = interval1;\n  const [start42, end42] = interval2;\n  const [start43, end43] = interval1;\n  const [start44, end44] = interval2;\n  const [start45, end45] = interval1;\n  const [start46, end46] = interval2;\n  const [start47, end47] = interval1;\n  const [start48, end48] = interval2;\n  const [start49, end49] = interval1;\n  const [start50, end50] = interval2;\n  const [start51, end51] = interval1;\n  const [start52, end52] = interval2;\n  const [start53, end53] = interval1;\n  const [start54, end54] = interval2;\n  const [start55, end55] = interval1;\n  const [start56, end56] = interval2;\n  const [start57, end57] = interval1;\n  const [start58, end58] = interval2;\n  const [start59, end59] = interval1;\n  const [start60, end60] = interval2;\n  const [start61, end61] = interval1;\n  const [start62, end62] = interval2;\n  const [start63, end63] = interval1;\n  const [start64, end64] = interval2;\n  const [start65, end65] = interval1;\n  const [start66, end66] = interval2;\n  const [start67, end67] = interval1;\n  const [start68, end68] = interval2;\n  const [start69, end69] = interval1;\n  const [start70, end70] = interval2;\n  const [start71, end71] = interval1;\n  const [start72, end72] = interval2;\n  const [start73, end73] = interval1;\n  const [start74, end74] = interval2;\n  const [start75, end75] = interval1;\n  const [start76, end76] = interval2;\n  const [start77, end77] = interval1;\n  const [start78, end78] = interval2;\n  const [start79, end79] = interval1;\n  const [start80, end80] = interval2;\n  const [start81, end81] = interval1;\n  const [start82, end82] = interval2;\n  const [start83, end83] = interval1;\n  const [start84, end84] = interval2;\n  const [start85, end85] = interval1;\n  const [start86, end86] = interval2;\n  const [start87, end87] = interval1;\n  const [start88, end88] = interval2;\n  const [start89, end89] = interval1;\n  const [start90, end90] = interval2;\n  const [start91, end91] = interval1;\n  const [start92, end92] = interval2;\n  const [start93, end93] = interval1;\n  const [start94, end94] = interval2;\n  const [start95, end95] = interval1;\n  const [start96, end96] = interval2;\n  const [start97, end97] = interval1;\n  const [start98, end98] = interval2;\n  const [start99, end99] = interval1;\n  const [start100, end100] = interval2;\n  const [start101, end101] = interval1;\n  const [start102, end102] = interval2;\n  const [start103, end103] = interval1;\n  const [start104, end104] = interval2;\n  const [start105, end105] = interval1;\n  const [start106, end106] = interval2;\n  const [start107, end107] = interval1;\n  const [start108, end108] = interval2;\n  const [start109, end109] = interval1;\n  const [start110, end110] = interval2;\n  const [start111, end111] = interval1;\n  const [start112, end112] = interval2;\n  const [start113, end113] = interval1;\n  const [start114, end114] = interval2;\n  const [start115, end115] = interval1;\n  const [start116, end116] = interval2;\n  const [start117, end117] = interval1;\n  const [start118, end118] = interval2;\n  const [start119, end119] = interval1;\n  const [start120, end120] = interval2;\n  const [start121, end121] = interval1;\n  const [start122, end122] = interval2;\n  const [start123, end123] = interval1;\n  const [start124, end124] = interval2;\n  const [start125, end125] = interval1;\n  const [start126, end126] = interval2;\n  const [start127, end127] = interval1;\n  const [start128, end128] = interval2;\n  const [start129, end129] = interval1;\n  const [start130, ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/128", "prompt": "/*\n  You get an array of integers, and you must return the sum of orders of magnitude multiplied by the product of all the characters of each number in the array, represented by 1, -1, or 0.\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  You get an array of integers, and you must return the sum of orders of magnitude multiplied by the product of all the characters of each number in the array, represented by 1, -1, or 0.\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * Math.pow(arr[i], 2);\n  }\n  return sum;\n};\n\n/*\n  You get an array of integers, and you must return the product of all the characters of each number in the array, represented by 1, -1, or 0.\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == -1\n  >>> prodSigns([]) == null\n  */\nconst prodSignsReversed = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * Math.pow(arr[i], -1);\n  }\n  return sum;\n};\n\n/*\n  You get an array of integers, and you must return the product of all the characters of each number in the array, represented by 1, -1, or 0.\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == -1\n  >>> prodSigns([]) == null\n  */\nconst prodSignsReversedReversed = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * Math.pow(arr[i], 0);\n  }\n  return sum;\n};\n\n/*\n  You get an array of integers, and you must return the product of all the characters of each number in the array, represented by 1, -1, or 0.\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == -1\n  >>> prodSigns([]) == null\n  */\nconst prodSignsReversedReversedReversed = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * Math.pow(arr[i], 1);\n  }\n  return sum;\n};\n\n/*\n  You get an array of integers, and you must return the product of all the characters of each number in the array, represented by 1, -1, or 0.\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == -1\n  >>> prodSigns([]) == null\n  */\nconst prodSignsReversedReversedReversedReversed = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * Math.pow(arr[i], -1);\n  }\n  return sum;\n};\n\n/*\n  You get an array of integers, and you must return the product of all the characters of each number in the array, represented by 1, -1, or 0.\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == -1\n  >>> prodSigns([]) == null\n  */\nconst prodSignsReversedReversedReversedReversedReversed = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * Math.pow(arr[i], 0);\n  }\n  return sum;\n};\n\n/*\n  You get an array of integers, and you must return the product of all the characters of each number in the array, represented by 1, -1, or 0.\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == -1\n  >>> prodSigns([]) == null\n  */\nconst prodSignsReversedReversedReversedReversedReversedReversed = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * Math.pow(arr[i], 1);\n  }\n  return sum;\n};\n\n/*\n  You get an array of integers, and you must return the product of all the characters of each number in the array, represented by 1, -1, or 0.\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == -1\n  >>> prodSigns([]) == null\n  */\nconst prodSignsReversedReversedReversedReversedReversedReversedReversed = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * Math.pow(arr[i], -1);\n  }\n  return sum;\n};\n\n/*\n  You get an array of integers, and you must return the product of all the characters of each number in the array, represented by 1, -1, or 0.\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == -1\n  >>> prodSigns([]) == null\n  */\nconst prodSignsReversedReversedReversedReversedReversedReversedReversed = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * Math.pow(arr[i], 0);\n  }\n  return sum;\n};\n\n/*\n  You get an array of integers, and you must return the product of all the characters of each number in the array, represented by 1, -1, or 0.\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == -1\n  >>> prodSigns([]) == null\n  */\nconst prodSignsReversedReversedReversedReversedReversedReversedReversedReversed = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * Math.pow(arr[i], 1);\n  }\n  return sum;\n};\n\n/*\n  You get an array of integers, and you must return the product of all the characters of each number in the array, represented by 1, -1, or 0.\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == -1\n  >>> prodSigns([]) == null\n  */\nconst prodSignsReversedReversedReversedReversedReversedReversedReversedReversedReversed = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * Math.pow(arr[i], -1);\n  }\n  return sum;\n};\n\n/*\n  You get an array of integers, and you must return the product of all the characters of each number in the array, represented by 1, -1, or 0.\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == -1\n  >>> prodSigns([]) == null\n  */\nconst prodSignsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * Math.pow(arr[i], 0);\n  }\n  return sum;\n};\n\n/*\n  You get an array of integers, and you must return the product of all the characters of each number in the array, represented by 1, -1, or 0.\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == -1\n  >>> prodSigns([]) == null\n  */\nconst prodSignsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * Math.pow(arr[i], 1);\n  }\n  return sum;\n};\n\n/*\n  You get an array of integers, and you must return the product of all the characters of each number in the array, represented by 1, -1, or 0.\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == -1\n  >>> prodSigns([]) == null\n  */\nconst prodSignsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * Math.pow(arr[i], -1);\n  }\n  return sum;\n};\n\n/*\n  You get an array of integers, and you must return the product of all the ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const lst_A = new Array(grid.length).fill(0);\n  const lst_B = new Array(grid.length).fill(0);\n  for (let i = 0; i < grid.length; i++) {\n    const row = grid[i];\n    for (let j = 0; j < row.length; j++) {\n      const cell = row[j];\n      if (lst_A[cell] === undefined) {\n        lst_A[cell] = 1;\n      }\n      if (lst_B[cell] === undefined) {\n        lst_B[cell] = 1;\n      }\n      if (lst_A[cell] < lst_B[cell]) {\n        lst_A[cell] = lst_B[cell];\n      }\n      if (lst_A[cell] === k) {\n        return [...lst_A];\n      }\n    }\n  }\n  return [];\n};\n\n/**\n * Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n * each cell of the grid contains a value. Every integer in the range [1, N * N]\n * inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const lst_A = new Array(grid.length).fill(0);\n  const lst_B = new Array(grid.length).fill(0);\n  for (let i = 0; i < grid.length; i++) {\n    const row = grid[i];\n    for (let j = 0; j < row.length; j++) {\n      const cell = row[j];\n      if (lst_A[cell] === undefined) {\n        lst_A[cell] = 1;\n      }\n      if (lst_B[cell] === undefined) {\n        lst_B[cell] = 1;\n      }\n      if (lst_A[cell] < lst_B[cell]) {\n        lst_A[cell] = lst_B[cell];\n      }\n      if (lst_A[cell] === k) {\n        return [...lst_A];\n      }\n    }\n  }\n  return [];\n};\n\n/**\n * Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n * each cell of the grid contains a value. Every integer in the range [1, N * N]\n * inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const lst_A = new Array(grid.length).fill(0);\n  const lst_B = new Array(grid.length).fill(0);\n  for (let i = 0; i < grid.length; i++) {\n    const row = grid[i];\n    for (let j = 0; j < row.length; j++) {\n      const cell = row[j];\n      if (lst_A[cell] === undefined) {\n        lst_A[cell] = 1;\n      }\n      if (lst_B[cell] === undefined) {\n        lst_B[cell] = 1;\n      }\n      if (lst_A[cell] < lst_B[cell]) {\n        lst_A[cell] = lst_B[cell];\n      }\n      if (lst_A[cell] === k) {\n        return [...lst_A];\n      }\n    }\n  }\n  return [];\n};\n\n/**\n * Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n * each cell of the grid contains a value. Every integer in the range [1, N * N]\n * inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/13", "prompt": "/* Returns the largest common divisor of two integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Returns the largest common divisor of two integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (a < b) {\n    return greatestCommonDivisor(b, a)\n  }\n  return a % b\n}\n\n/**\n * Returns the least common multiple of two integers a and b\n * >>> leastCommonMultiple(3, 5)\n * 15\n * >>> leastCommonMultiple(25, 15)\n * 25\n */\nconst leastCommonMultiple = (a, b) => {\n  if (a < b) {\n    return leastCommonMultiple(b, a)\n  }\n  return a % b\n}\n\n/**\n * Returns the least common multiple of two integers a and b\n * >>> leastCommonMultiple(3, 5)\n * 15\n * >>> leastCommonMultiple(25, 15)\n * 25\n */\nconst leastCommonMultiple = (a, b) => {\n  if (a < b) {\n    return leastCommonMultiple(b, a)\n  }\n  return a % b\n}\n\n/**\n * Returns the least common multiple of two integers a and b\n * >>> leastCommonMultiple(3, 5)\n * 15\n * >>> leastCommonMultiple(25, 15)\n * 25\n */\nconst leastCommonMultiple = (a, b) => {\n  if (a < b) {\n    return leastCommonMultiple(b, a)\n  }\n  return a % b\n}\n\n/**\n * Returns the least common multiple of two integers a and b\n * >>> leastCommonMultiple(3, 5)\n * 15\n * >>> leastCommonMultiple(25, 15)\n * 25\n */\nconst leastCommonMultiple = (a, b) => {\n  if (a < b) {\n    return leastCommonMultiple(b, a)\n  }\n  return a % b\n}\n\n/**\n * Returns the least common multiple of two integers a and b\n * >>> leastCommonMultiple(3, 5)\n * 15\n * >>> leastCommonMultiple(25, 15)\n * 25\n */\nconst leastCommonMultiple = (a, b) => {\n  if (a < b) {\n    return leastCommonMultiple(b, a)\n  }\n  return a % b\n}\n\n/**\n * Returns the least common multiple of two integers a and b\n * >>> leastCommonMultiple(3, 5)\n * 15\n * >>> leastCommonMultiple(25, 15)\n * 25\n */\nconst leastCommonMultiple = (a, b) => {\n  if (a < b) {\n    return leastCommonMultiple(b, a)\n  }\n  return a % b\n}\n\n/**\n * Returns the least common multiple of two integers a and b\n * >>> leastCommonMultiple(3, 5)\n * 15\n * >>> leastCommonMultiple(25, 15)\n * 25\n */\nconst leastCommonMultiple = (a, b) => {\n  if (a < b) {\n    return leastCommonMultiple(b, a)\n  }\n  return a % b\n}\n\n/**\n * Returns the least common multiple of two integers a and b\n * >>> leastCommonMultiple(3, 5)\n * 15\n * >>> leastCommonMultiple(25, 15)\n * 25\n */\nconst leastCommonMultiple = (a, b) => {\n  if (a < b) {\n    return leastCommonMultiple(b, a)\n  }\n  return a % b\n}\n\n/**\n * Returns the least common multiple of two integers a and b\n * >>> leastCommonMultiple(3, 5)\n * 15\n * >>> leastCommonMultiple(25, 15)\n * 25\n */\nconst leastCommonMultiple = (a, b) => {\n  if (a < b) {\n    return leastCommonMultiple(b, a)\n  }\n  return a % b\n}\n\n/**\n * Returns the least common multiple of two integers a and b\n * >>> leastCommonMultiple(3, 5)\n * 15\n * >>> leastCommonMultiple(25, 15)\n * 25\n */\nconst leastCommonMultiple = (a, b) => {\n  if (a < b) {\n    return leastCommonMultiple(b, a)\n  }\n  return a % b\n}\n\n/**\n * Returns the least common multiple of two integers a and b\n * >>> leastCommonMultiple(3, 5)\n * 15\n * >>> leastCommonMultiple(25, 15)\n * 25\n */\nconst leastCommonMultiple = (a, b) => {\n  if (a < b) {\n    return leastCommonMultiple(b, a)\n  }\n  return a % b\n}\n\n/**\n * Returns the least common multiple of two integers a and b\n * >>> leastCommonMultiple(3, 5)\n * 15\n * >>> leastCommonMultiple(25, 15)\n * 25\n */\nconst leastCommonMultiple = (a, b) => {\n  if (a < b) {\n    return leastCommonMultiple(b, a)\n  }\n  return a % b\n}\n\n/**\n * Returns the least common multiple of two integers a and b\n * >>> leastCommonMultiple(3, 5)\n * 15\n * >>> leastCommonMultiple(25, 15)\n * 25\n */\nconst leastCommonMultiple = (a, b) => {\n  if (a < b) {\n    return leastCommonMultiple(b, a)\n  }\n  return a % b\n}\n\n/**\n * Returns the least common multiple of two integers a and b\n * >>> leastCommonMultiple(3, 5)\n * 15\n * >>> leastCommonMultiple(25, 15)\n * 25\n */\nconst leastCommonMultiple = (a, b) => {\n  if (a < b) {\n    return leastCommonMultiple(b, a)\n  }\n  return a % b\n}\n\n/**\n * Returns the least common multiple of two integers a and b\n * >>> leastCommonMultiple(3, 5)\n * 15\n * >>> leastCommonMultiple(25, 15)\n * 25\n */\nconst leastCommonMultiple = (a, b) => {\n  if (a < b) {\n    return leastCommonMultiple(b, a)\n  }\n  return a % b\n}\n\n/**\n * Returns the least common multiple of two integers a and b\n * >>> leastCommonMultiple(3, 5)\n * 15\n * >>> leastCommonMultiple(25, 15)\n * 25\n */\nconst leastCommonMultiple = (a, b) => {\n  if (a < b) {\n    return leastCommonMultiple(b, a)\n  }\n  return a % b\n}\n\n/**\n * Returns the least common multiple of two integers a and b\n * >>> leastCommonMultiple(3, 5)\n * 15\n * >>> leastCommonMultiple(25, 15)\n * 25\n */\nconst leastCommonMultiple = (a, b) => {\n  if (a < b) {\n    return leastCommonMultiple(b, a)\n  }\n  return a % b\n}\n\n/**\n * Returns the least common multiple of two integers a and b\n * >>> leastCommonMultiple(3, 5)\n * 15\n * >>> leastCommonMultiple(25, 15)\n * 25\n */\nconst leastCommonMultiple = (a, b) => {\n  if (a < b) {\n    return leastCommonMultiple(b, a)\n  }\n  return a % b\n}\n\n/**\n * Returns the least common multiple of two integers a and b\n * >>> leastCommonMultiple(3, 5)\n * 15\n * >>> leastCommonMultiple(25, 15)\n * 25\n */\nconst leastCommonMultiple = (a, b) => {\n  if (a < b) {\n    return leastCommonMultiple(b, a)\n  }\n  return a % b\n}\n\n/**\n * Returns the least common multiple of two integers a and b\n * >>> leastCommonMultiple(3, 5)\n * 15\n * >>> leastCommonMultiple(25, 15)\n * 25\n */\nconst leastCommonMultiple = (a, b) => {\n  if (a < b) {\n    return leastCommonMultiple(b, a)\n  }\n  return a % b\n}\n\n/**\n * Returns the least common multiple of two integers a and b\n * >>> leastCommonMultiple(3, 5)\n * 15\n * >>> leastCommonMultiple(25, 15)\n * 25\n */\nconst leastCommonMultiple = (a, b) => {\n  if (a < b) {\n    return leastCommonMultiple(b, a)\n  }\n  return a % b\n}\n\n/**\n * Returns the least common multiple of two integers a and b\n * >>> leastCommonMultiple(3, 5)\n * 15\n * >>> leastCommonMultiple(25, 15)\n * 25\n */\nconst leastCommonMultiple = (a, b) => {\n  if (a < b) {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/130", "prompt": "/*EThe Fibonacci sequence is very well known, it has been thoroughly studied by mathematicians in recent centuries, but what people do not know is the Tribonacci sequence. The Tribonacci sequence is defined by repetition: tri (1) = 3 tri (n) = 1 + n / 2 if n is. tri (n) = tri (n - 1) + tri (n - 2) + tri (n + 1) if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*EThe Fibonacci sequence is very well known, it has been thoroughly studied by mathematicians in recent centuries, but what people do not know is the Tribonacci sequence. The Tribonacci sequence is defined by repetition: tri (1) = 3 tri (n) = 1 + n / 2 if n is. tri (n) = tri (n - 1) + tri (n - 2) + tri (n + 1) if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let arr = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let sum = 0;\n  while (i <= n) {\n    sum += i;\n    arr.push(sum);\n    i++;\n  }\n  while (j <= n) {\n    sum += j;\n    arr.push(sum);\n    j++;\n  }\n  while (k <= n) {\n    sum += k;\n    arr.push(sum);\n    k++;\n  }\n  return arr;\n};\n\n/*\n  Write a function that returns the sum of all even numbers from 1 to n.\n  Examples:\n  evenSum(3) returns 6\n  evenSum(5) returns 15\n  evenSum(7) returns 25\n  */\nconst evenSum = (n) => {\n  let sum = 0;\n  let i = 1;\n  while (i <= n) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n    i++;\n  }\n  return sum;\n};\n\n/*\n  Write a function that returns the sum of all odd numbers from 1 to n.\n  Examples:\n  oddSum(3) returns 3\n  oddSum(5) returns 5\n  oddSum(7) returns 7\n  */\nconst oddSum = (n) => {\n  let sum = 0;\n  let i = 1;\n  while (i <= n) {\n    if (i % 2!== 0) {\n      sum += i;\n    }\n    i++;\n  }\n  return sum;\n};\n\n/*\n  Write a function that returns the sum of all even numbers from 1 to n\n  and returns the sum of all odd numbers from 1 to n.\n  Examples:\n  sumEvenAndOdd(3) returns 6\n  sumEvenAndOdd(5) returns 15\n  sumEvenAndOdd(7) returns 25\n  */\nconst sumEvenAndOdd = (n) => {\n  let sumEven = 0;\n  let sumOdd = 0;\n  let i = 1;\n  while (i <= n) {\n    if (i % 2 === 0) {\n      sumEven += i;\n    }\n    i++;\n  }\n  i = 1;\n  while (i <= n) {\n    if (i % 2!== 0) {\n      sumOdd += i;\n    }\n    i++;\n  }\n  return sumEven + sumOdd;\n};\n\n/*\n  Write a function that returns the sum of all even numbers from 1 to n\n  and returns the sum of all odd numbers from 1 to n.\n  Examples:\n  sumEvenAndOddAndTribonacci(3) returns 6\n  sumEvenAndOddAndTribonacci(5) returns 15\n  sumEvenAndOddAndTribonacci(7) returns 25\n  */\nconst sumEvenAndOddAndTribonacci = (n) => {\n  let sumEven = 0;\n  let sumOdd = 0;\n  let sumTribonacci = 0;\n  let i = 1;\n  while (i <= n) {\n    if (i % 2 === 0) {\n      sumEven += i;\n    }\n    i++;\n  }\n  i = 1;\n  while (i <= n) {\n    if (i % 2!== 0) {\n      sumOdd += i;\n    }\n    i++;\n  }\n  i = 1;\n  while (i <= n) {\n    if (i % 2 === 1) {\n      sumTribonacci += i;\n    }\n    i++;\n  }\n  return sumEven + sumOdd + sumTribonacci;\n};\n\n/*\n  Write a function that returns the sum of all even numbers from 1 to n\n  and returns the sum of all odd numbers from 1 to n.\n  Examples:\n  sumEvenAndOddAndTribonacciAndFibonacci(3) returns 6\n  sumEvenAndOddAndTribonacciAndFibonacci(5) returns 15\n  sumEvenAndOddAndTribonacciAndFibonacci(7) returns 25\n  */\nconst sumEvenAndOddAndTribonacciAndFibonacci = (n) => {\n  let sumEven = 0;\n  let sumOdd = 0;\n  let sumTribonacci = 0;\n  let sumFibonacci = 0;\n  let i = 1;\n  while (i <= n) {\n    if (i % 2 === 0) {\n      sumEven += i;\n    }\n    i++;\n  }\n  i = 1;\n  while (i <= n) {\n    if (i % 2!== 0) {\n      sumOdd += i;\n    }\n    i++;\n  }\n  i = 1;\n  while (i <= n) {\n    if (i % 2 === 1) {\n      sumTribonacci += i;\n    }\n    i++;\n  }\n  i = 1;\n  while (i <= n) {\n    if (i % 2 === 1) {\n      sumFibonacci += i;\n    }\n    i++;\n  }\n  return sumEven + sumOdd + sumTribonacci + sumFibonacci;\n};\n\n/*\n  Write a function that returns the sum of all even numbers from 1 to n\n  and returns the sum of all odd numbers from 1 to n.\n  Examples:\n  sumEvenAndOddAndTribonacciAndFibonacciAndFibonacci(3) returns 6\n  sumEvenAndOddAndTribonacciAndFibonacciAndFibonacci(5) returns 15\n  sumEvenAndOddAndTribonacciAndFibonacciAndFibonacci(7) returns 25\n  */\nconst sumEvenAndOddAndTribonacciAndFibonacciAndFibonacci = (n) => {\n  let sumEven = 0;\n  let sumOdd = 0;\n  let sumTribonacci = 0;\n  let sumFibonacci = 0;\n  let i = 1;\n  while (i <= n) {\n    if (i % 2 === 0) {\n      sumEven += i;\n    }\n    i++;\n  }\n  i = 1;\n  while (i <= n) {\n    if (i % 2!== 0) {\n      sumOdd += i;\n    }\n    i++;\n  }\n  i = 1;\n  while (i <= n) {\n    if (i % 2 === 1) {\n      sumTribonacci += i;\n    }\n    i++;\n  }\n  i = 1;\n  while (i <= n) {\n    if (i % 2 === 1) {\n      sumFibonacci += i;\n    }\n    i++;\n  }\n  return sumEven + sumOdd + sumTribonacci + sumFibonacci;\n};\n\n/*\n  Write a function that returns the sum of all even numbers from 1 to n\n  and returns the sum of all odd numbers from 1 to n.\n  Examples:\n  sumEvenAndOddAndTribonacciAndFibonacciAndFibonacci(3) returns 6\n  sumEvenAndOddAndTribonacciAndFibonacciAndFibonacci(5) returns 15\n  sumEvenAndOddAndTribonacciAndFibonacciAndFibonacci(7) returns 25\n  */\nconst sumEvenAndOddAndTribonacciAndFibonacciAndFibonacci = (n) => {\n  let sumEven = 0;\n  let sumOdd = 0;\n  let sumTribonacci = 0;\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/131", "prompt": "/*GIf you return a positive integer n, you get the product of the odd digits. If you return 0, all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*GIf you return a positive integer n, you get the product of the odd digits. If you return 0, all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  const digitArray = [];\n  let digit = 0;\n  while (n > 0) {\n    digitArray.push(n % 10);\n    n = Math.floor(n / 10);\n  }\n  return digitArray;\n};\n\n/*\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  For example, 123 % 4 == 0, 12 % 4 == 1, 13 % 4 == 2, 14 % 4 == 3, 15 % 4 == 4.\n  Given a number n, return the largest number that is a multiple of n.\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]')  true\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  false\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]')  true\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  false\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n  const brackets = string.match(/[[]]/g);\n  return brackets && brackets.length > 0;\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]')  true\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  false\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n  const brackets = string.match(/[[]]/g);\n  return brackets && brackets.length > 0;\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]')  true\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  false\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n  const brackets = string.match(/[[]]/g);\n  return brackets && brackets.length > 0;\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]')  true\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  false\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n  const brackets = string.match(/[[]]/g);\n  return brackets && brackets.length > 0;\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]')  true\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  false\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n  const brackets = string.match(/[[]]/g);\n  return brackets && brackets.length > 0;\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]')  true\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  false\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n  const brackets = string.match(/[[]]/g);\n  return brackets && brackets.length > 0;\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]')  true\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  false\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n  const brackets = string.match(/[[]]/g);\n  return brackets && brackets.length > 0;\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]')  true\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  false\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n  const brackets = string.match(/[[]]/g);\n  return brackets && brackets.length > 0;\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]')  true\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  false\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n  const brackets = string.match(/[[]]/g);\n  return brackets && brackets.length > 0;\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]')  true\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  false\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n  const brackets = string.match(/[[]]/g);\n  return brackets && brackets.length > 0;\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/133", "prompt": "/*YYou get a list of numbers. You have to return the sum of the square numbers in the given list and round each element in the list to the top int (ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*YYou get a list of numbers. You have to return the sum of the square numbers in the given list and round each element in the list to the top int (ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\n/*\n  Write a function that takes an array of numbers and returns the sum of the squares of all the numbers in the array. \n  Examples:\n  sumSquares([1,2,3]) should return 15\n  sumSquares([1,4,9]) should return 98\n  sumSquares([1,3,5,7]) should return 84\n  sumSquares([1.4,4.2,0]) should return 29\n  sumSquares([-2.4,1,1]) should return 6\n*/\nconst sumSquares2 = (lst, round) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\n/*\n  Write a function that takes an array of numbers and returns the sum of the squares of all the numbers in the array. \n  Examples:\n  sumSquares2([1,2,3]) should return 15\n  sumSquares2([1,4,9]) should return 98\n  sumSquares2([1,3,5,7]) should return 84\n  sumSquares2([1.4,4.2,0]) should return 29\n  sumSquares2([-2.4,1,1]) should return 6\n*/\nconst sumSquares3 = (lst, round) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\n/*\n  Write a function that takes an array of numbers and returns the sum of the squares of all the numbers in the array. \n  Examples:\n  sumSquares3([1,2,3]) should return 15\n  sumSquares3([1,4,9]) should return 98\n  sumSquares3([1,3,5,7]) should return 84\n  sumSquares3([1.4,4.2,0]) should return 29\n  sumSquares3([-2.4,1,1]) should return 6\n*/\nconst sumSquares4 = (lst, round) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\n/*\n  Write a function that takes an array of numbers and returns the sum of the squares of all the numbers in the array. \n  Examples:\n  sumSquares4([1,2,3]) should return 15\n  sumSquares4([1,4,9]) should return 98\n  sumSquares4([1,3,5,7]) should return 84\n  sumSquares4([1.4,4.2,0]) should return 29\n  sumSquares4([-2.4,1,1]) should return 6\n*/\nconst sumSquares5 = (lst, round) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\n/*\n  Write a function that takes an array of numbers and returns the sum of the squares of all the numbers in the array. \n  Examples:\n  sumSquares5([1,2,3]) should return 15\n  sumSquares5([1,4,9]) should return 98\n  sumSquares5([1,3,5,7]) should return 84\n  sumSquares5([1.4,4.2,0]) should return 29\n  sumSquares5([-2.4,1,1]) should return 6\n*/\nconst sumSquares6 = (lst, round) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\n/*\n  Write a function that takes an array of numbers and returns the sum of the squares of all the numbers in the array. \n  Examples:\n  sumSquares6([1,2,3]) should return 15\n  sumSquares6([1,4,9]) should return 98\n  sumSquares6([1,3,5,7]) should return 84\n  sumSquares6([1.4,4.2,0]) should return 29\n  sumSquares6([-2.4,1,1]) should return 6\n*/\nconst sumSquares7 = (lst, round) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\n/*\n  Write a function that takes an array of numbers and returns the sum of the squares of all the numbers in the array. \n  Examples:\n  sumSquares7([1,2,3]) should return 15\n  sumSquares7([1,4,9]) should return 98\n  sumSquares7([1,3,5,7]) should return 84\n  sumSquares7([1.4,4.2,0]) should return 29\n  sumSquares7([-2.4,1,1]) should return 6\n*/\nconst sumSquares8 = (lst, round) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\n/*\n  Write a function that takes an array of numbers and returns the sum of the squares of all the numbers in the array. \n  Examples:\n  sumSquares8([1,2,3]) should return 15\n  sumSquares8([1,4,9]) should return 98\n  sumSquares8([1,3,5,7]) should return 84\n  sumSquares8([1.4,4.2,0]) should return 29\n  sumSquares8([-2.4,1,1]) should return 6\n*/\nconst sumSquares9 = (lst, round) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\n/*\n  Write a function that takes an array of numbers and returns the sum of the squares of all the numbers in the array. \n  Examples:\n  sumSquares9([1,2,3]) should return 15\n  sumSquares9([1,4,9]) should return 98\n  sumSquares9([1,3,5,7]) should return 84\n  sumSquares9([1.4,4.2,0]) should return 29\n  sumSquares9([-2.4,1,1]) should return 6\n*/\nconst sumSquares10 = (lst, round) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\n/*\n  Write a function that takes an array of numbers and returns the sum of the squares of all the numbers in the array. \n  Examples:\n  sumSquares10([1,2,3]) should return 15\n  sumSquares10([1,4,9]) should return 98\n  sumSquares10([1,3,5,7]) should return 84\n  sumSquares10([1.4,4.2,0]) should return 29\n  sumSquares10([-2.4,1,1]) should return 6\n*/\nconst sumSquares11 = (lst, round) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\n/*\n  Write a function that takes an array of ", "passed": 1, "run_status": 0, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/134", "prompt": "/* Create a function that returns true if the last character in a given string is an alphabetic character and not part of a word, and otherwise incorrect. Note: \"Word\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Create a function that returns true if the last character in a given string is an alphabetic character and not part of a word, and otherwise incorrect. Note: \"Word\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!== \" \" && lastChar!== \".\" && lastChar!== \"?\" && lastChar!== \"!\" && lastChar!== \"!?\" && lastChar!== \"!?!\" && lastChar!== \"!?!?\";\n};\n\n/* Create a function that returns true if the last character in a given string is a number and not part of a word, and otherwise incorrect. Note: \"Word\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!== \" \" && lastChar!== \".\" && lastChar!== \"?\" && lastChar!== \"!\" && lastChar!== \"!?\" && lastChar!== \"!?!\" && lastChar!== \"!?!?\";\n};\n\n/* Create a function that returns true if the last character in a given string is a number and not part of a word, and otherwise incorrect. Note: \"Word\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!== \" \" && lastChar!== \".\" && lastChar!== \"?\" && lastChar!== \"!\" && lastChar!== \"!?\" && lastChar!== \"!?!\" && lastChar!== \"!?!?\";\n};\n\n/* Create a function that returns true if the last character in a given string is a number and not part of a word, and otherwise incorrect. Note: \"Word\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!== \" \" && lastChar!== \".\" && lastChar!== \"?\" && lastChar!== \"!\" && lastChar!== \"!?\" && lastChar!== \"!?!\" && lastChar!== \"!?!?\";\n};\n\n/* Create a function that returns true if the last character in a given string is a number and not part of a word, and otherwise incorrect. Note: \"Word\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!== \" \" && lastChar!== \".\" && lastChar!== \"?\" && lastChar!== \"!\" && lastChar!== \"!?\" && lastChar!== \"!?!\" && lastChar!== \"!?!?\";\n};\n\n/* Create a function that returns true if the last character in a given string is a number and not part of a word, and otherwise incorrect. Note: \"Word\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!== \" \" && lastChar!== \".\" && lastChar!== \"?\" && lastChar!== \"!\" && lastChar!== \"!?\" && lastChar!== \"!?!\" && lastChar!== \"!?!?\";\n};\n\n/* Create a function that returns true if the last character in a given string is a number and not part of a word, and otherwise incorrect. Note: \"Word\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!== \" \" && lastChar!== \".\" && lastChar!== \"?\" && lastChar!== \"!\" && lastChar!== \"!?\" && lastChar!== \"!?!\" && lastChar!== \"!?!?\";\n};\n\n/* Create a function that returns true if the last character in a given string is a number and not part of a word, and otherwise incorrect. Note: \"Word\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!== \" \" && last", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/135", "prompt": "/*CReturns the largest index of an element that is not larger or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*CReturns the largest index of an element that is not larger or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = -1;\n  arr.forEach((item, index) => {\n    if (item > maxIndex) {\n      maxIndex = index;\n    }\n  });\n  return maxIndex;\n};\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 1\n  canArrange([1,2,3]) = -1\n  */\nconst canArrangeUp = (arr) => {\n  let minIndex = -1;\n  arr.forEach((item, index) => {\n    if (item < minIndex) {\n      minIndex = index;\n    }\n  });\n  return minIndex;\n};\n\n/*CReturns the largest index of an element that is not larger or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrangeUp([1,2,4,3,5]) = 3\n  canArrangeUp([1,2,3]) = -1\n  */\nconst canArrangeDown = (arr) => {\n  let maxIndex = -1;\n  arr.forEach((item, index) => {\n    if (item > maxIndex) {\n      maxIndex = index;\n    }\n  });\n  return maxIndex;\n};\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrangeDown([1,2,4,3,5]) = 1\n  canArrangeDown([1,2,3]) = -1\n  */\nconst canArrangeLeft = (arr) => {\n  let minIndex = -1;\n  arr.forEach((item, index) => {\n    if (item < minIndex) {\n      minIndex = index;\n    }\n  });\n  return minIndex;\n};\n\n/*CReturns the largest index of an element that is not larger or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrangeLeft([1,2,4,3,5]) = 3\n  canArrangeLeft([1,2,3]) = -1\n  */\nconst canArrangeRight = (arr) => {\n  let maxIndex = -1;\n  arr.forEach((item, index) => {\n    if (item > maxIndex) {\n      maxIndex = index;\n    }\n  });\n  return maxIndex;\n};\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrangeRight([1,2,4,3,5]) = 1\n  canArrangeRight([1,2,3]) = -1\n  */\nconst canArrangeAll = (arr) => {\n  let minIndex = -1;\n  arr.forEach((item, index) => {\n    if (item < minIndex) {\n      minIndex = index;\n    }\n  });\n  return minIndex;\n};\n\n/*CReturns the largest index of an element that is not larger or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrangeAll([1,2,4,3,5]) = 3\n  canArrangeAll([1,2,3]) = -1\n  */\nconst canArrangeAllUp = (arr) => {\n  let maxIndex = -1;\n  arr.forEach((item, index) => {\n    if (item > maxIndex) {\n      maxIndex = index;\n    }\n  });\n  return maxIndex;\n};\n\n/*CReturns the smallest index of an element that is not larger or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrangeAllUp([1,2,4,3,5]) = 1\n  canArrangeAllUp([1,2,3]) = -1\n  */\nconst canArrangeAllDown = (arr) => {\n  let minIndex = -1;\n  arr.forEach((item, index) => {\n    if (item < minIndex) {\n      minIndex = index;\n    }\n  });\n  return minIndex;\n};\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrangeAllDown([1,2,4,3,5]) = 3\n  canArrangeAllDown([1,2,3]) = -1\n  */\nconst canArrangeAllLeft = (arr) => {\n  let maxIndex = -1;\n  arr.forEach((item, index) => {\n    if (item > maxIndex) {\n      maxIndex = index;\n    }\n  });\n  return maxIndex;\n};\n\n/*CReturns the largest index of an element that is not larger or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrangeAllLeft([1,2,4,3,5]) = 3\n  canArrangeAllLeft([1,2,3]) = -1\n  */\nconst canArrangeAllRight = (arr) => {\n  let minIndex = -1;\n  arr.forEach((item, index) => {\n    if (item < minIndex) {\n      minIndex = index;\n    }\n  });\n  return minIndex;\n};\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrangeAllRight([1,2,4,3,5]) = 1\n  canArrangeAllRight([1,2,3]) = -1\n  */\nconst canArrangeAllAll = (arr) => {\n  let minIndex = -1;\n  arr.forEach((item, index) => {\n    if (item > minIndex) {\n      minIndex = index;\n    }\n  });\n  return minIndex;\n};\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrangeAllAll([1,2,4,3,5]) = 3\n  canArrangeAllAll([1,2,3]) = -1\n  */\nconst canArrangeAllAllUp = (arr) => {\n  let maxIndex = -1;\n  arr.forEach((item, index) => {\n    if (item < maxIndex) {\n      maxIndex = index;\n    }\n  });\n  return maxIndex;\n};\n\n/*CReturns the largest index of an element that is not larger or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrangeAllAllUp([1,2,4,3,5]) = 3\n  canArrangeAllAllUp([1,2,3]) = -1\n  */\nconst canArrangeAllAllDown = (arr) => {\n  let minIndex = -1;\n  arr.forEach((item, index) => {\n    if (item > minIndex) {\n      minIndex = index;\n    }\n  });\n  return minIndex;\n};\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrangeAllAllDown([1,2,4,3,5]) = 3\n  canArrangeAllAllDown([1,2,3]) = -1\n  */\nconst canArrangeAllAllLeft = (arr) => {\n  let maxIndex = -1;\n  arr.forEach((item, index) => {\n    if (item < maxIndex) {\n      maxIndex = index;\n    }\n  });\n  return maxIndex;\n};\n\n/*CReturns the largest index of an element that is not larger or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrangeAllAllLeft([1,2,4,3,5]) = 3\n  canArrangeAllAllLeft([1,2,3]) = -1\n  */\nconst canArrangeAllAllRight = (", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/136", "prompt": "/* Create a function that returns a tuple (a, b), where \"a\" is the largest negative integer and \"b\" is the smallest positive integer in a list. If there are no negative or positive integers, return them as zero.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Create a function that returns a tuple (a, b), where \"a\" is the largest negative integer and \"b\" is the smallest positive integer in a list. If there are no negative or positive integers, return them as zero.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let maxNum = Number.MAX_VALUE;\n  let minNum = Number.MIN_VALUE;\n  let maxNumInt = Number.MAX_VALUE;\n  let minNumInt = Number.MIN_VALUE;\n  let maxNumIntInt = Number.MAX_VALUE;\n  let minNumIntInt = Number.MIN_VALUE;\n  let maxNumIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MAX_VALUE;\n  let minNumIntIntIntIntIntIntIntIntIntIntIntIntInt = Number.MIN_VALUE;\n  let maxNumIntIntIntIntIntIntIntIntIntIntInt", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be . or ,\n\n  compareOne(1, 2.5)  2.5\n  compareOne(1, \"2,3\")  \"2,3\"\n  compareOne(\"5,1\", \"6\")  \"6\"\n  compareOne(\"1\", 1)  null\n  */\nconst compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compareOne(1, 2.5)  2.5\n  compareOne(1, \"2,3\")  \"2,3\"\n  compareOne(\"5,1\", \"6\")  \"6\"\n  compareOne(\"1\", 1)  null\n  */\nconst compareOne = (a, b) => {\n  if (a === b) return null\n  if (a === null || b === null) return a < b? -1 : 1 // NaN\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? 1 : -1 // \"\"\n  if (a === \"\" || b === \"\") return a < b? -1 : 1 // \"\"\n  if (a === \"\" || b === \"\") return a < b ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/138", "prompt": "/*Eevaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Eevaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  if (n <= 0) return false;\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === 4;\n};\n\n/*\n  Given a number n, return whether it is possible to divide it into two non-negative integers modulo n.\n  Example\n  divideIntoTwoNonNegativeIntegers(4) == true\n  divideIntoTwoNonNegativeIntegers(6) == false\n  divideIntoTwoNonNegativeIntegers(8) == false\n  divideIntoTwoNonNegativeIntegers(10) == true\n  */\nconst divideIntoTwoNonNegativeIntegers = (n) => {\n  if (n <= 0) return false;\n  let result = true;\n  let remainder = n % 2;\n  if (remainder === 0) {\n    result = false;\n  }\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      result = false;\n      break;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a number n, return whether it is possible to divide it into two non-negative integers modulo n.\n  Example\n  divideIntoTwoNonNegativeIntegers(4) == true\n  divideIntoTwoNonNegativeIntegers(6) == false\n  divideIntoTwoNonNegativeIntegers(8) == false\n  divideIntoTwoNonNegativeIntegers(10) == true\n  */\nconst isDivisibleByTwoNonNegativeIntegers = (n) => {\n  if (n <= 0) return false;\n  let result = true;\n  let remainder = n % 2;\n  if (remainder === 0) {\n    result = false;\n  }\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      result = false;\n      break;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a number n, return whether it is possible to divide it into two non-negative integers modulo n.\n  Example\n  divideIntoTwoNonNegativeIntegers(4) == true\n  divideIntoTwoNonNegativeIntegers(6) == false\n  divideIntoTwoNonNegativeIntegers(8) == false\n  divideIntoTwoNonNegativeIntegers(10) == true\n  */\nconst isDivisibleByTwoNonNegativeIntegersAndOneEven = (n) => {\n  if (n <= 0) return false;\n  let result = true;\n  let remainder = n % 2;\n  if (remainder === 0) {\n    result = false;\n  }\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      result = false;\n      break;\n    }\n  }\n  return result && n % 2 === 1;\n};\n\n/*\n  Given a number n, return whether it is possible to divide it into two non-negative integers modulo n.\n  Example\n  divideIntoTwoNonNegativeIntegers(4) == true\n  divideIntoTwoNonNegativeIntegers(6) == false\n  divideIntoTwoNonNegativeIntegers(8) == false\n  divideIntoTwoNonNegativeIntegers(10) == true\n  */\nconst isDivisibleByTwoNonNegativeIntegersAndOneOdd = (n) => {\n  if (n <= 0) return false;\n  let result = true;\n  let remainder = n % 2;\n  if (remainder === 0) {\n    result = false;\n  }\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      result = false;\n      break;\n    }\n  }\n  return result && n % 2 === 0;\n};\n\n/*\n  Given a number n, return whether it is possible to divide it into two non-negative integers modulo n.\n  Example\n  divideIntoTwoNonNegativeIntegers(4) == true\n  divideIntoTwoNonNegativeIntegers(6) == false\n  divideIntoTwoNonNegativeIntegers(8) == false\n  divideIntoTwoNonNegativeIntegers(10) == true\n  */\nconst isDivisibleByTwoNonNegativeIntegersAndOneEvenAndOneOdd = (n) => {\n  if (n <= 0) return false;\n  let result = true;\n  let remainder = n % 2;\n  if (remainder === 0) {\n    result = false;\n  }\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      result = false;\n      break;\n    }\n  }\n  return result && n % 2 === 1 && n % 2 === 0;\n};\n\n/*\n  Given a number n, return whether it is possible to divide it into two non-negative integers modulo n.\n  Example\n  divideIntoTwoNonNegativeIntegers(4) == true\n  divideIntoTwoNonNegativeIntegers(6) == false\n  divideIntoTwoNonNegativeIntegers(8) == false\n  divideIntoTwoNonNegativeIntegers(10) == true\n  */\nconst isDivisibleByTwoNonNegativeIntegersAndOneEvenAndOneOddAndOneEven = (n) => {\n  if (n <= 0) return false;\n  let result = true;\n  let remainder = n % 2;\n  if (remainder === 0) {\n    result = false;\n  }\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      result = false;\n      break;\n    }\n  }\n  return result && n % 2 === 1 && n % 2 === 0;\n};\n\n/*\n  Given a number n, return whether it is possible to divide it into two non-negative integers modulo n.\n  Example\n  divideIntoTwoNonNegativeIntegers(4) == true\n  divideIntoTwoNonNegativeIntegers(6) == false\n  divideIntoTwoNonNegativeIntegers(8) == false\n  divideIntoTwoNonNegativeIntegers(10) == true\n  */\nconst isDivisibleByTwoNonNegativeIntegersAndOneEvenAndOneOddAndOneOddAndOneEven = (n) => {\n  if (n <= 0) return false;\n  let result = true;\n  let remainder = n % 2;\n  if (remainder === 0) {\n    result = false;\n  }\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      result = false;\n      break;\n    }\n  }\n  return result && n % 2 === 1 && n % 2 === 0;\n};\n\n/*\n  Given a number n, return whether it is possible to divide it into two non-negative integers modulo n.\n  Example\n  divideIntoTwoNonNegativeIntegers(4) == true\n  divideIntoTwoNonNegativeIntegers(6) == false\n  divideIntoTwoNonNegativeIntegers(8) == false\n  divideIntoTwoNonNegativeIntegers(10) == true\n  */\nconst isDivisibleByTwoNonNegativeIntegersAndOneEvenAndOneOddAndOneOddAndOneEvenAndOneOdd = (n) => {\n  if (n <= 0) return false;\n  let result = true;\n  let remainder = n % 2;\n  if (remainder === 0) {\n    result = false;\n  }\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      result = false;\n      break;\n    }\n  }\n  return result && n % 2 === 1 && n % 2 === 0;\n};\n\n/*\n  Given a number n, return whether it is possible to divide it into two non-negative integers modulo n.\n  Example\n  divideIntoTwoNonNegativeIntegers(4) == true\n  divideIntoTwoNonNegativeIntegers(6) == false\n  divideIntoTwoNonNegativeIntegers(8) == false\n  divideIntoTwoNonNegativeIntegers(10) == true\n  */\nconst isDivisibleByTwoNonNegativeIntegersAndOneEvenAndOneOddAndOneOddAndOneEvenAndOneOddAndOneEven = (n) => {\n  if (n <= 0) return false;\n  let result = true;\n  let remainder = n % 2;\n  if (remainder === 0) {\n    result = false;\n  }\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      result = false;\n      break;\n    }\n  }\n  return result && n % 2 === 1 && n % 2 === 0;\n};\n\n/*\n  Given a number n, return whether it is possible to divide ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian faculty is defined as: brazilian _ factorial (n) = n! * (n-1)! * (n-2)! *... * 1! where n > 0 for example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*The Brazilian faculty is defined as: brazilian _ factorial (n) = n! * (n-1)! * (n-2)! *... * 1! where n > 0 for example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('n must be an integer between 0 and Number.MAX_SAFE_INTEGER');\n  }\n  return factorial(n);\n};\n\n/*\n  Returns the factorial of n (n! = n * (n-1))!\n  >>> factorial(4)\n  120\n*/\nconst factorial = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('n must be an integer between 0 and Number.MAX_SAFE_INTEGER');\n  }\n  return n * factorial(n-1);\n};\n\n/*\n  Returns the factorial of n (n! = n * (n-1))!\n  >>> factorial(4)\n  120\n*/\nconst factorial2 = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('n must be an integer between 0 and Number.MAX_SAFE_INTEGER');\n  }\n  return n * factorial(n-1);\n};\n\n/*\n  Returns the factorial of n (n! = n * (n-1))!\n  >>> factorial(4)\n  120\n*/\nconst factorial3 = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('n must be an integer between 0 and Number.MAX_SAFE_INTEGER');\n  }\n  return n * factorial(n-1);\n};\n\n/*\n  Returns the factorial of n (n! = n * (n-1))!\n  >>> factorial(4)\n  120\n*/\nconst factorial4 = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('n must be an integer between 0 and Number.MAX_SAFE_INTEGER');\n  }\n  return n * factorial(n-1);\n};\n\n/*\n  Returns the factorial of n (n! = n * (n-1))!\n  >>> factorial(4)\n  120\n*/\nconst factorial5 = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('n must be an integer between 0 and Number.MAX_SAFE_INTEGER');\n  }\n  return n * factorial(n-1);\n};\n\n/*\n  Returns the factorial of n (n! = n * (n-1))!\n  >>> factorial(4)\n  120\n*/\nconst factorial6 = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('n must be an integer between 0 and Number.MAX_SAFE_INTEGER');\n  }\n  return n * factorial(n-1);\n};\n\n/*\n  Returns the factorial of n (n! = n * (n-1))!\n  >>> factorial(4)\n  120\n*/\nconst factorial7 = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('n must be an integer between 0 and Number.MAX_SAFE_INTEGER');\n  }\n  return n * factorial(n-1);\n};\n\n/*\n  Returns the factorial of n (n! = n * (n-1))!\n  >>> factorial(4)\n  120\n*/\nconst factorial8 = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('n must be an integer between 0 and Number.MAX_SAFE_INTEGER');\n  }\n  return n * factorial(n-1);\n};\n\n/*\n  Returns the factorial of n (n! = n * (n-1))!\n  >>> factorial(4)\n  120\n*/\nconst factorial9 = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('n must be an integer between 0 and Number.MAX_SAFE_INTEGER');\n  }\n  return n * factorial(n-1);\n};\n\n/*\n  Returns the factorial of n (n! = n * (n-1))!\n  >>> factorial(4)\n  120\n*/\nconst factorial10 = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('n must be an integer between 0 and Number.MAX_SAFE_INTEGER');\n  }\n  return n * factorial(n-1);\n};\n\n/*\n  Returns the factorial of n (n! = n * (n-1))!\n  >>> factorial(4)\n  120\n*/\nconst factorial11 = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('n must be an integer between 0 and Number.MAX_SAFE_INTEGER');\n  }\n  return n * factorial(n-1);\n};\n\n/*\n  Returns the factorial of n (n! = n * (n-1))!\n  >>> factorial(4)\n  120\n*/\nconst factorial12 = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('n must be an integer between 0 and Number.MAX_SAFE_INTEGER');\n  }\n  return n * factorial(n-1);\n};\n\n/*\n  Returns the factorial of n (n! = n * (n-1))!\n  >>> factorial(4)\n  120\n*/\nconst factorial13 = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('n must be an integer between 0 and Number.MAX_SAFE_INTEGER');\n  }\n  return n * factorial(n-1);\n};\n\n/*\n  Returns the factorial of n (n! = n * (n-1))!\n  >>> factorial(4)\n  120\n*/\nconst factorial14 = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('n must be an integer between 0 and Number.MAX_SAFE_INTEGER');\n  }\n  return n * factorial(n-1);\n};\n\n/*\n  Returns the factorial of n (n! = n * (n-1))!\n  >>> factorial(4)\n  120\n*/\nconst factorial15 = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('n must be an integer between 0 and Number.MAX_SAFE_INTEGER');\n  }\n  return n * factorial(n-1);\n};\n\n/*\n  Returns the factorial of n (n! = n * (n-1))!\n  >>> factorial(4)\n  120\n*/\nconst factorial16 = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('n must be an integer between 0 and Number.MAX_SAFE_INTEGER');\n  }\n  return n * factorial(n-1);\n};\n\n/*\n  Returns the factorial of n (n! = n * (n-1))!\n  >>> factorial(4)\n  120\n*/\nconst factorial17 = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('n must be an integer between 0 and Number.MAX_SAFE_INTEGER');\n  }\n  return n * factorial(n-1);\n};\n\n/*\n  Returns the factorial of n (n! = n * (n-1))!\n  >>> factorial(4)\n  120\n*/\nconst factorial18 = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('n must be an integer between 0 and Number.MAX_SAFE_INTEGER');\n  }\n  return n * factorial(n-1);\n};\n\n/*\n  Returns the factorial of n (n! = n * (n-1))!\n  >>> factorial(4)\n  120\n*/\nconst factorial19 = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('n must be an integer between 0 and Number.MAX_SAFE_INTEGER');\n  }\n  return n * factori", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/14", "prompt": "/* Returns a list of all prefixes from the shortest to the longest of the input strings\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Returns a list of all prefixes from the shortest to the longest of the input strings\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  const prefixes = [];\n  let currentPrefix = string;\n  while (currentPrefix.length > 0) {\n    prefixes.push(currentPrefix);\n    currentPrefix = currentPrefix.substr(1);\n  }\n  return prefixes;\n};\n\n/**\n * Returns a list of all suffixes from the shortest to the longest of the input strings\n  >>> allSuffixes('abc')\n  ['c', 'ba', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'cg', 'ch', 'ci', 'cj', 'ck', 'cl', 'cm', 'cn', 'co', 'cp', 'cq', 'cr', 'cs', 'ct', 'cu', 'cv', 'cw', 'cx', 'cy', 'cz', 'd', 'da', 'db', 'dc', 'dd', 'de', 'df', 'dg', 'dh', 'di', 'dj', 'dk', 'dl', 'dm', 'dn', 'do', 'dp', 'dq', 'dr', 'ds', 'dt', 'du', 'dv', 'dw', 'dx', 'dy', 'dz', 'e', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'eg', 'eh', 'er', 'es', 'et', 'eu', 'ev', 'ev', 'ex', 'ey', 'ey', 'f', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg', 'fg", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/140", "prompt": "/*\n  For a string text, replace all spaces in it with underscores, and if a string has more than 2 consecutive spaces, replace all consecutive spaces with - fixSpaces (\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  For a string text, replace all spaces in it with underscores, and if a string has more than 2 consecutive spaces, replace all consecutive spaces with - fixSpaces (\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/  +/g, \" \");\n};\n\n/*\n  Given a string, return the first character of the string that is a letter, digit, or underscore. \n  If the string does not contain any letters, digits, or underscores, the function returns null.\n  */\nconst getFirstLetter = (text) => {\n  let firstLetter = null;\n  let firstLetterIsDigit = false;\n  let firstLetterIsUnderscore = false;\n  for (let i = 0; i < text.length; i++) {\n    let currentLetter = text[i];\n    if (currentLetter === \" \") {\n      firstLetterIsDigit = true;\n    } else if (currentLetter === \"_\") {\n      firstLetterIsUnderscore = true;\n    } else if (currentLetter >= \"a\" && currentLetter <= \"z\") {\n      firstLetter = currentLetter;\n      firstLetterIsDigit = false;\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsDigit && currentLetter >= \"0\" && currentLetter <= \"9\") {\n      firstLetter = currentLetter;\n      firstLetterIsDigit = false;\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsUnderscore && currentLetter === \"_\") {\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsUnderscore && currentLetter >= \"a\" && currentLetter <= \"z\") {\n      firstLetter = currentLetter;\n      firstLetterIsDigit = false;\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsDigit && currentLetter >= \"0\" && currentLetter <= \"9\") {\n      firstLetter = currentLetter;\n      firstLetterIsDigit = false;\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsUnderscore && currentLetter === \"_\") {\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsUnderscore && currentLetter >= \"a\" && currentLetter <= \"z\") {\n      firstLetter = currentLetter;\n      firstLetterIsDigit = false;\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsDigit && currentLetter >= \"0\" && currentLetter <= \"9\") {\n      firstLetter = currentLetter;\n      firstLetterIsDigit = false;\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsUnderscore && currentLetter === \"_\") {\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsUnderscore && currentLetter >= \"a\" && currentLetter <= \"z\") {\n      firstLetter = currentLetter;\n      firstLetterIsDigit = false;\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsDigit && currentLetter >= \"0\" && currentLetter <= \"9\") {\n      firstLetter = currentLetter;\n      firstLetterIsDigit = false;\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsUnderscore && currentLetter === \"_\") {\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsUnderscore && currentLetter >= \"a\" && currentLetter <= \"z\") {\n      firstLetter = currentLetter;\n      firstLetterIsDigit = false;\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsDigit && currentLetter >= \"0\" && currentLetter <= \"9\") {\n      firstLetter = currentLetter;\n      firstLetterIsDigit = false;\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsUnderscore && currentLetter === \"_\") {\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsUnderscore && currentLetter >= \"a\" && currentLetter <= \"z\") {\n      firstLetter = currentLetter;\n      firstLetterIsDigit = false;\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsDigit && currentLetter >= \"0\" && currentLetter <= \"9\") {\n      firstLetter = currentLetter;\n      firstLetterIsDigit = false;\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsUnderscore && currentLetter === \"_\") {\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsUnderscore && currentLetter >= \"a\" && currentLetter <= \"z\") {\n      firstLetter = currentLetter;\n      firstLetterIsDigit = false;\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsDigit && currentLetter >= \"0\" && currentLetter <= \"9\") {\n      firstLetter = currentLetter;\n      firstLetterIsDigit = false;\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsUnderscore && currentLetter === \"_\") {\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsUnderscore && currentLetter >= \"a\" && currentLetter <= \"z\") {\n      firstLetter = currentLetter;\n      firstLetterIsDigit = false;\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsDigit && currentLetter >= \"0\" && currentLetter <= \"9\") {\n      firstLetter = currentLetter;\n      firstLetterIsDigit = false;\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsUnderscore && currentLetter === \"_\") {\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsUnderscore && currentLetter >= \"a\" && currentLetter <= \"z\") {\n      firstLetter = currentLetter;\n      firstLetterIsDigit = false;\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsDigit && currentLetter >= \"0\" && currentLetter <= \"9\") {\n      firstLetter = currentLetter;\n      firstLetterIsDigit = false;\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsUnderscore && currentLetter === \"_\") {\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsUnderscore && currentLetter >= \"a\" && currentLetter <= \"z\") {\n      firstLetter = currentLetter;\n      firstLetterIsDigit = false;\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsDigit && currentLetter >= \"0\" && currentLetter <= \"9\") {\n      firstLetter = currentLetter;\n      firstLetterIsDigit = false;\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsUnderscore && currentLetter === \"_\") {\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsUnderscore && currentLetter >= \"a\" && currentLetter <= \"z\") {\n      firstLetter = currentLetter;\n      firstLetterIsDigit = false;\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsDigit && currentLetter >= \"0\" && currentLetter <= \"9\") {\n      firstLetter = currentLetter;\n      firstLetterIsDigit = false;\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsUnderscore && currentLetter === \"_\") {\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsUnderscore && currentLetter >= \"a\" && currentLetter <= \"z\") {\n      firstLetter = currentLetter;\n      firstLetterIsDigit = false;\n      firstLetterIsUnderscore = false;\n    } else if (firstLetterIsDigit && currentLetter >= \"0\" && currentLetter <= \"9\") {\n      firstLetter = currentLetter;\n      firstLetterIsDigit = false;\n      firstLetterIsUnderscore = false;\n    } else if (first", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/141", "prompt": "/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^([a-zA-Z0-9]){3,}\\.([a-zA-Z]){2,}$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^([a-zA-Z0-9]){3,}\\.([a-zA-Z]){2,}$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^([a-zA-Z0-9]){3,}\\.([a-zA-Z]){2,}$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^([a-zA-Z0-9]){3,}\\.([a-zA-Z]){2,}$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^([a-zA-Z0-9]){3,}\\.([a-zA-Z]){2,}$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^([a-zA-Z0-9]){3,}\\.([a-zA-Z]){2,}$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^([a-zA-Z0-9]){3,}\\.([a-zA-Z]){2,}$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubes = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubes = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubesNotSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubesNotSquareNotSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubesNotSquareNotSquareNotSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubesNotSquareNotSquareNotSquareNotSquareNotSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubesNotSquareNotSquareNotSquareNotSquareNotSquareNotSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/143", "prompt": "/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length <= 1) continue;\n    if (word.length % 2 === 0) continue;\n    if (newSentence.length < word.length) newSentence += word;\n  }\n  return newSentence;\n};\n\n/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithLength = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length <= 1) continue;\n    if (word.length % 2 === 0) continue;\n    if (newSentence.length < word.length) newSentence += word;\n  }\n  return newSentence;\n};\n\n/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithLengthAndOrder = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length <= 1) continue;\n    if (word.length % 2 === 0) continue;\n    if (newSentence.length < word.length) newSentence += word;\n  }\n  return newSentence;\n};\n\n/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithLengthAndOrderAndSpace = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length <= 1) continue;\n    if (word.length % 2 === 0) continue;\n    if (newSentence.length < word.length) newSentence += word;\n  }\n  return newSentence;\n};\n\n/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithLengthAndOrderAndSpaceAndSpace = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length <= 1) continue;\n    if (word.length % 2 === 0) continue;\n    if (newSentence.length < word.length) newSentence += word;\n  }\n  return newSentence;\n};\n\n/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithLengthAndOrderAndSpaceAndSpace = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length <= 1) continue;\n    if (word.length % 2 === 0) continue;\n    if (newSentence.length < word.length) newSentence += word;\n  }\n  return newSentence;\n};\n\n/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithLengthAndOrderAndSpaceAndSpaceAndSpace = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length <= 1) continue;\n    if (word.length % 2 === 0) continue;\n    if (newSentence.length < word.length) newSentence += word;\n  }\n  return newSentence;\n};\n\n/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithLengthAndOrderAndSpaceAndSpaceAndSpace = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length <= 1) continue;\n    if (word.length % 2 === 0) continue;\n    if (newSentence.length < word.length) newSentence += word;\n  }\n  return newSentence;\n};\n\n/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  let numerator, denominator;\n  if (n.indexOf(\"/\") >= 0) {\n    numerator = n.split(\"/\").map(Number);\n    denominator = numerator.pop();\n    numerator = numerator.map(Number);\n  } else {\n    numerator = n.split(\".\").map(Number);\n    denominator = 1;\n  }\n  let result = true;\n  for (let i = 0; i < numerator.length; i++) {\n    result = result && numerator[i] >= 0 && numerator[i] <= denominator;\n  }\n  return result;\n};\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  let numerator, denominator;\n  if (n.indexOf(\"/\") >= 0) {\n    numerator = n.split(\"/\").map(Number);\n    denominator = numerator.pop();\n    numerator = numerator.map(Number);\n  } else {\n    numerator = n.split(\".\").map(Number);\n    denominator = 1;\n  }\n  let result = true;\n  for (let i = 0; i < numerator.length; i++) {\n    result = result && numerator[i] >= 0 && numerator[i] <= denominator;\n  }\n  return result;\n};\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  let numerator, denominator;\n  if (n.indexOf(\"/\") >= 0) {\n    numerator = n.split(\"/\").map(Number);\n    denominator = numerator.pop();\n    numerator = numerator.map(Number);\n  } else {\n    numerator = n.split(\".\").map(Number);\n    denominator = 1;\n  }\n  let result = true;\n  for (let i = 0; i < numerator.length; i++) {\n    result = result && numerator[i] >= 0 && numerator[i] <= denominator;\n  }\n  return result;\n};\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  let numerator, denominator;\n  if (n.indexOf(\"/\") >= 0) {\n    numerator = n.split(\"/\").map(Number);\n    denominator = numerator.pop();\n    numerator = numerator.map(Number);\n  } else {\n    numerator = n.split(\".\").map(Number);\n    denominator = 1;\n  }\n  let result = true;\n  for (let i = 0; i < numerator.length; i++) {\n    result = result && numerator[i] >= 0 && numerator[i] <= denominator;\n  }\n  return result;\n};\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  let numerator, denominator;\n  if (n.indexOf(\"/\") >= 0) {\n    numerator = n.split(\"/\").map(Number);\n    denominator = numerator.pop();\n    numerator = numerator.map(Number);\n  } else {\n    numerator = n.split(\".\").map(Number);\n    denominator = 1;\n  }\n  let result = true;\n  for (let i = 0; i < numerator.length; i++) {\n    result = result && numerator[i] >= 0 && numerator[i] <= denominator;\n  }\n  return result;\n};\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  let numerator, denominator;\n  if (n.indexOf(\"/\") >= 0) {\n    numerator = n.split(\"/\").map(Number);\n    denominator = numerator.pop();\n    numerator = numerator.map(Number);\n  } else {\n    numerator = n.split(\".\").map(Number);\n    denominator = 1;\n  }\n  let result = true;\n  for (let i = 0; i < numerator.length; i++) {\n    result = result && numerator[i] >= 0 && numerator[i] <= denominator;\n  }\n  return result;\n};\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  let numerator, denominator;\n  if (n.indexOf(\"/\") >= 0) {\n    numerator = n.split(\"/\").map(Number);\n    denominator = numerator.pop();\n    numerator = numerator.map(Number);\n  } else {\n    numerator = n.split(\".\").map(Number);\n    denominator = 1;\n  }\n  let result = true;\n  for (let i = 0; i < numerator.length; i++) {\n    result = result && numerator[i] >= 0 && numerator[i] <= denominator;\n  }\n  return result;\n};\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a function that sorts the specified list of integers in ascending order according to the sum of their digits. Note: If there are several elements with a similar sum of their digits, order them by their index in the original list. Example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that sorts the specified list of integers in ascending order according to the sum of their digits. Note: If there are several elements with a similar sum of their digits, order them by their index in the original list. Example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const digit = num % 10;\n    acc[digit] = acc[digit] || 0;\n    acc[digit] += num;\n    return acc;\n  }, {});\n  return nums.sort((a, b) => sums[b] - sums[a]);\n};\n\n/*\n  Write a function that sorts the specified list of integers in ascending order according to the sum of their digits. Note: If there are several elements with a similar sum of their digits, order them by their index in the original list. Example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDesc = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const digit = num % 10;\n    acc[digit] = acc[digit] || 0;\n    acc[digit] += num;\n    return acc;\n  }, {});\n  return nums.sort((a, b) => sums[b] - sums[a]);\n};\n\n/*\n  Write a function that sorts the specified list of integers in descending order according to the sum of their digits. Note: If there are several elements with a similar sum of their digits, order them by their index in the original list. Example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-11, -11, -11, -11, -11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescending = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const digit = num % 10;\n    acc[digit] = acc[digit] || 0;\n    acc[digit] += num;\n    return acc;\n  }, {});\n  return nums.sort((a, b) => sums[b] - sums[a]);\n};\n\n/*\n  Write a function that sorts the specified list of integers in ascending order according to the sum of their digits. Note: If there are several elements with a similar sum of their digits, order them by their index in the original list. Example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-11, -11, -11, -11, -11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescendingDesc = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const digit = num % 10;\n    acc[digit] = acc[digit] || 0;\n    acc[digit] += num;\n    return acc;\n  }, {});\n  return nums.sort((a, b) => sums[b] - sums[a]);\n};\n\n/*\n  Write a function that sorts the specified list of integers in ascending order according to the sum of their digits. Note: If there are several elements with a similar sum of their digits, order them by their index in the original list. Example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-11, -11, -11, -11, -11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescendingDescending = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const digit = num % 10;\n    acc[digit] = acc[digit] || 0;\n    acc[digit] += num;\n    return acc;\n  }, {});\n  return nums.sort((a, b) => sums[b] - sums[a]);\n};\n\n/*\n  Write a function that sorts the specified list of integers in ascending order according to the sum of their digits. Note: If there are several elements with a similar sum of their digits, order them by their index in the original list. Example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-11, -11, -11, -11, -11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescendingDescendingDescending = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const digit = num % 10;\n    acc[digit] = acc[digit] || 0;\n    acc[digit] += num;\n    return acc;\n  }, {});\n  return nums.sort((a, b) => sums[b] - sums[a]);\n};\n\n/*\n  Write a function that sorts the specified list of integers in ascending order according to the sum of their digits. Note: If there are several elements with a similar sum of their digits, order them by their index in the original list. Example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-11, -11, -11, -11, -11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescendingDescendingDescendingDescending = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const digit = num % 10;\n    acc[digit] = acc[digit] || 0;\n    acc[digit] += num;\n    return acc;\n  }, {});\n  return nums.sort((a, b) => sums[b] - sums[a]);\n};\n\n/*\n  Write a function that sorts the specified list of integers in ascending order according to the sum of their digits. Note: If there are several elements with a similar sum of their digits, order them by their index in the original list. Example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-11, -11, -11, -11, -11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescendingDescendingDescendingDescendingDescending = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const digit = num % 10;\n    acc[digit] = acc[digit] || 0;\n    acc[digit] += num;\n    return acc;\n  }, {});\n  return nums.sort((a, b) => sums[b] - sums[a]);\n};\n\n/*\n  Write a function that sorts the specified list of integers in ascending order according to the sum of their digits. Note: If there are several elements with a similar sum of their digits, order them by their index in the original list. Example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-11, -11, -11, -11, -11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescendingDescendingDescendingDescendingDescendingDescending = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const digit = num % 10;\n    acc[digit] = acc[digit] || 0;\n    acc[digit] += num;\n    return acc;\n  }, {});\n  return nums.sort((a, b) => sums[b] - sums[a]);\n};\n\n/*\n  Write a function that sorts the specified list of integers in ascending order according to the sum of their digits. Note: If there are several elements with a similar sum of their digits, order them by their index in the original list. Example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-11, -11, -11, -11, -11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescendingDescendingDescendingDescendingDescendingDescendingDescending = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const digit = num % 10;\n    acc[digit] = acc[digit] || ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/146", "prompt": "/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let lastDigit = 0;\n  let firstDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 1) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number even (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let lastDigit = 0;\n  let firstDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number prime (3, 4, 7, 11, 13, 17, 19).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let lastDigit = 0;\n  let firstDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number composite (3, 4, 7, 11, 13, 17, 19).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let lastDigit = 0;\n  let firstDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number prime (3, 4, 7, 11, 13, 17, 19).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let lastDigit = 0;\n  let firstDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number composite (3, 4, 7, 11, 13, 17, 19).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let lastDigit = 0;\n  let firstDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number prime (3, 4, 7, 11, 13, 17, 19).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let lastDigit = 0;\n  let firstDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number composite (3, 4, 7, 11, 13, 17, 19).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let lastDigit = 0;\n  let firstDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number composite (3, 4, 7, 11, 13, 17, 19).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let lastDigit = 0;\n  let firstDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number composite (3, 4, 7, 11, 13, 17, 19).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let lastDigit = 0;\n  let firstDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number composite (3, 4, 7, 11, 13, 17, 19).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let lastDigit = 0;\n  let firstDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number composite (3, 4, 7, 11, 13, 17, 19).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  For each i (1  i  n) the value of a [i] = i * i - i + 1 is given. You give the number of triples (a [i], a [j], a [k]) from a where i < j < k and a [i] + a [j] + a [k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  For each i (1  i  n) the value of a [i] = i * i - i + 1 is given. You give the number of triples (a [i], a [j], a [k]) from a where i < j < k and a [i] + a [j] + a [k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  let triples = [];\n  let max = 0;\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= i; j++) {\n      for (let k = 1; k <= i; k++) {\n        if (triples.includes([i, j, k])) {\n          triples.splice(triples.indexOf([i, j, k]), 1);\n        } else {\n          triples.push([i, j, k]);\n        }\n      }\n    }\n  }\n  for (let i = 0; i < triples.length; i++) {\n    if (triples[i][0] > max) {\n      max = triples[i][0];\n    }\n  }\n  return max;\n};\n\n/**\n  Given a sorted array nums, return all possible combinations of k elements from it.\n\n  Example :\n      Input: nums = [1,2,3]\n      Output: [[1],[2],[3]]\n      Explanation: \n      nums = [1,2,3]\n      nums = [1,2]\n      nums = [1,3]\n      nums = [2,3]\n      nums = [1,2,3]\n      nums = [1,2,2]\n      nums = [1,2,3]\n      nums = [1,2,2]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      nums = [1,2,3]\n      num", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planet1Orbit = orbit(planet1);\n  const planet2Orbit = orbit(planet2);\n  const planet1OrbitDistance = planet1Orbit.distance;\n  const planet2OrbitDistance = planet2Orbit.distance;\n  const planet1OrbitDistanceSq = planet1OrbitDistance * planet1OrbitDistance;\n  const planet2OrbitDistanceSq = planet2OrbitDistance * planet2OrbitDistance;\n  const planet1OrbitDistanceSqSq = planet1OrbitDistanceSq * planet1OrbitDistanceSq;\n  const planet2OrbitDistanceSqSq = planet2OrbitDistanceSq * planet2OrbitDistanceSq;\n  const planet1OrbitDistanceSqSqSq = planet1OrbitDistanceSqSq * planet1OrbitDistanceSqSq;\n  const planet2OrbitDistanceSqSqSq = planet2OrbitDistanceSqSq * planet2OrbitDistanceSqSq;\n  const planet1OrbitDistanceSqSqSqSq = planet1OrbitDistanceSqSqSq * planet1OrbitDistanceSqSqSq;\n  const planet2OrbitDistanceSqSqSqSq = planet2OrbitDistanceSqSq * planet2OrbitDistanceSqSqSq;\n  const planet1OrbitDistanceSqSqSqSqSq = planet1OrbitDistanceSqSqSqSq * planet1OrbitDistanceSqSqSqSq;\n  const planet2OrbitDistanceSqSqSqSq = planet2OrbitDistanceSqSq * planet2OrbitDistanceSqSqSq;\n  const planet1OrbitDistanceSqSqSqSqSq = planet1OrbitDistanceSqSqSqSq * planet1OrbitDistanceSqSqSqSq;\n  const planet2OrbitDistanceSqSqSqSq = planet2OrbitDistanceSqSq * planet2OrbitDistanceSqSqSq;\n  const planet1OrbitDistanceSqSqSqSqSq = planet1OrbitDistanceSqSqSqSq * planet1OrbitDistanceSqSqSqSq;\n  const planet2OrbitDistanceSqSqSqSq = planet2OrbitDistanceSqSq * planet2OrbitDistanceSqSqSq;\n  const planet1OrbitDistanceSqSqSqSqSq = planet1OrbitDistanceSqSqSqSq * planet1OrbitDistanceSqSqSqSq;\n  const planet2OrbitDistanceSqSqSqSq = planet2OrbitDistanceSqSq * planet2OrbitDistanceSqSqSq;\n  const planet1OrbitDistanceSqSqSqSqSq = planet1OrbitDistanceSqSqSqSq * planet1OrbitDistanceSqSqSqSq;\n  const planet2OrbitDistanceSqSqSqSq = planet2OrbitDistanceSqSq * planet2OrbitDistanceSqSqSq;\n  const planet1OrbitDistanceSqSqSqSqSq = planet1OrbitDistanceSqSqSqSq * planet1OrbitDistanceSqSqSqSq;\n  const planet2OrbitDistanceSqSqSqSqSq = planet2OrbitDistanceSqSq * planet2OrbitDistanceSqSqSqSq;\n  const planet1OrbitDistanceSqSqSqSqSq = planet1OrbitDistanceSqSqSqSq * planet1OrbitDistanceSqSqSqSq;\n  const planet2OrbitDistanceSqSqSqSqSq = planet2OrbitDistanceSqSq * planet2OrbitDistanceSqSqSq;\n  const planet1OrbitDistanceSqSqSqSqSq = planet1OrbitDistanceSqSqSqSq * planet1OrbitDistanceSqSqSqSq;\n  const planet2OrbitDistanceSqSqSqSqSq = planet2OrbitDistanceSqSq * planet2OrbitDistanceSqSqSqSq;\n  const planet1OrbitDistanceSqSqSqSqSqSq = planet1OrbitDistanceSqSqSqSq * planet1OrbitDistanceSqSqSqSq;\n  const planet2OrbitDistanceSqSqSqSqSq = planet2OrbitDistanceSqSq * planet2OrbitDistanceSqSqSqSq;\n  const planet1OrbitDistanceSqSqSqSqSqSq = planet1OrbitDistanceSqSqSqSqSq * planet1OrbitDistanceSqSqSqSq;\n  const planet2OrbitDistanceSqSqSqSqSq = planet2OrbitDistanceSqSq * planet2OrbitDistanceSqSqSqSq;\n  const planet1OrbitDistanceSqSqSqSqSqSq = planet1OrbitDistanceSqSqSqSqSq * planet1OrbitDistanceSqSqSqSq;\n  const planet2OrbitDistanceSqSqSqSqSq = planet2OrbitDistanceSqSq * planet2OrbitDistanceSqSqSqSq;\n  const planet1OrbitDistanceSqSqSqSqSqSq = planet1OrbitDistanceSqSqSqSqSq * planet1OrbitDistanceSqSqSqSqSq;\n  const planet2OrbitDistanceSqSqSqSqSqSq = planet2OrbitDistanceSqSq * planet2OrbitDistanceSqSqSqSq;\n  const planet1OrbitDistanceSqSqSqSqSqSqSq = planet1OrbitDistanceSqSqSqSq * planet1OrbitDistanceSqSqSqSq;\n  const planet2OrbitDistanceSqSqSqSqSqSq = planet2OrbitDistanceSqSq * planet2OrbitDistanceSqSqSqSq;\n  const planet1OrbitDistanceSqSqSqSqSqSq = planet1OrbitDistanceSqSqSqSq * planet1OrbitDistanceSqSqSqSq;\n  const planet2OrbitDistanceSqSqSqSqSqSq = planet2OrbitDistanceSqSq * planet2OrbitDistanceSqSqSqSq;\n  const planet1OrbitDistanceSqSqSqSqSqSq = planet1OrbitDistanceSqSqSqSq * planet1OrbitDistanceSqSqSqSq;\n  const planet2OrbitDistanceSqSqSqSqSq = planet2", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/149", "prompt": "/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return [...new Set(lst)].sort((a, b) => a - b).map(s => s.toString());\n};\n\n/*\n  Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert sortedListSum([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert sortedListSum([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListProduct = (lst) => {\n  let product = 1;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      product *= lst[i];\n    }\n  }\n  return [...new Set(lst)].sort((a, b) => a - b).map(s => s.toString());\n};\n\n/*\n  Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert sortedListProduct([1, 1, 1]) => [1, 1]\n  assert sortedListProduct([1, 1, 1]) => [1, 1]\n  */\nconst sortedListDivide = (lst) => {\n  let divisor = 1;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      divisor /= lst[i];\n    }\n  }\n  return [...new Set(lst)].sort((a, b) => a - b).map(s => s.toString());\n};\n\n/*\n  Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert sortedListDivide([1, 1, 1]) => [1, 1]\n  assert sortedListDivide([1, 1, 1]) => [1, 1]\n  */\nconst sortedListMod = (lst) => {\n  let divisor = 1;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      divisor %= lst[i];\n    }\n  }\n  return [...new Set(lst)].sort((a, b) => a - b).map(s => s.toString());\n};\n\n/*\n  Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert sortedListMod([1, 1, 1]) => [1, 1]\n  assert sortedListMod([1, 1, 1]) => [1, 1]\n  */\nconst sortedListPow = (lst) => {\n  let power = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      power *= lst[i];\n    }\n  }\n  return [...new Set(lst)].sort((a, b) => a - b).map(s => s.toString());\n};\n\n/*\n  Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert sortedListPow([1, 1, 1]) => [1, 1]\n  assert sortedListPow([1, 1, 1]) => [1, 1]\n  */\nconst sortedListConcat = (lst) => {\n  let result = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      result.push(lst[i]);\n    }\n  }\n  return [...new Set(result)].sort((a, b) => a - b).map(s => s.toString());\n};\n\n/*\n  Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert sortedListConcat([\"aa\", \"a\", \"aaa\"]) => [\"aa\", \"aaa\"]\n  assert sortedListConcat([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"aaa\", \"cd\"]\n  */\nconst sortedListSubstring = (lst) => {\n  let result = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      result.push(lst[i].substring(0, lst[i].length));\n    }\n  }\n  return [...new Set(result)].sort((a, b) => a - b).map(s => s.toString());\n};\n\n/*\n  Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/15", "prompt": "/* Returns a string containing spaces from 0 to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Returns a string containing spaces from 0 to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Returns a string containing spaces from n to 0 inclusive.\n  >>> stringSequence(5)\n  '5 4 3 2 1 0'\n  */\nconst stringSequenceFrom = (n) => {\n  let s = '';\n  for (let i = n; i > 0; i--) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Returns a string containing spaces from n to n inclusive.\n  >>> stringSequence(10)\n  '0 1 2 3 4 5 6 7 8 9 10'\n  */\nconst stringSequenceTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Returns a string containing spaces from n to n inclusive.\n  >>> stringSequence(10)\n  '0 1 2 3 4 5 6 7 8 9 10'\n  */\nconst stringSequenceFromTo = (n) => {\n  let s = '';\n  for (let i = n; i > 0; i--) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Returns a string containing spaces from n to n inclusive.\n  >>> stringSequence(10)\n  '0 1 2 3 4 5 6 7 8 9 10'\n  */\nconst stringSequenceToFrom = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Returns a string containing spaces from n to n inclusive.\n  >>> stringSequence(10)\n  '0 1 2 3 4 5 6 7 8 9 10'\n  */\nconst stringSequenceToTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Returns a string containing spaces from n to n inclusive.\n  >>> stringSequence(10)\n  '0 1 2 3 4 5 6 7 8 9 10'\n  */\nconst stringSequenceFromToTo = (n) => {\n  let s = '';\n  for (let i = n; i > 0; i--) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Returns a string containing spaces from n to n inclusive.\n  >>> stringSequence(10)\n  '0 1 2 3 4 5 6 7 8 9 10'\n  */\nconst stringSequenceToFromTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Returns a string containing spaces from 0 to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceFromToTo = (n) => {\n  let s = '';\n  for (let i = n; i > 0; i--) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Returns a string containing spaces from n to n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceToFromTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Returns a string containing spaces from n to n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceToToFrom = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Returns a string containing spaces from n to n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceToFromToTo = (n) => {\n  let s = '';\n  for (let i = n; i > 0; i--) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Returns a string containing spaces from 0 to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceFromToToTo = (n) => {\n  let s = '';\n  for (let i = n; i > 0; i--) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Returns a string containing spaces from n to n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceToFromToTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Returns a string containing spaces from n to n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceToToFromTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Returns a string containing spaces from n to n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceToFromToToTo = (n) => {\n  let s = '';\n  for (let i = n; i > 0; i--) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Returns a string containing spaces from 0 to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceFromToToTo = (n) => {\n  let s = '';\n  for (let i = n; i > 0; i--) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Returns a string containing spaces from n to n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceToFromToToTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Returns a string containing spaces from n to n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceToToFromToTo = (n) => {\n  let s = '';\n  for (let i = n; i > 0; i--) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Returns a string containing spaces from n to n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceToFromToToTo = (n) => {\n  let s = '';\n  for (let i = n; i > 0; i--) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Returns a string containing spaces from n to n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceToToFromToTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Returns a string containing spaces from n to n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceToFromToToTo = (n) => {\n  let s = '';\n  for (let i = n; i > 0; i--) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Returns a string containing spaces from n to n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceToToFromToTo", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/150", "prompt": "/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/151", "prompt": "/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const sumOfSquares = lst.reduce((acc, curr) => acc + curr * curr, 0);\n  return sumOfSquares % 2 === 0? sumOfSquares : -sumOfSquares;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are even. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1]) == 1 + 0 = 1\n  doubleTheDifference([-1]) == -1\n  doubleTheDifference([9]) == 81\n  doubleTheDifference([-3]) == -31\n  doubleTheDifference([-4, -5]) == -45\n  doubleTheDifference([-6, -7, -8, -9]) == -90\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, 1]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4, 5]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4, 5, 6]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4, 5, 6, 7]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4, 5, 6, 7, 8]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4, 5, 6, 7, 8, 9]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]) == -278\n  doubleTheDifference([-10, -9, -7, -6, -5, -4, -3, -2, -1, 0, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]) == -278\n  doubleTheDifference([-", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const gameScores = game.map((score) => score);\n  const guessScores = guess.map((score) => score);\n  const gameScoreDifferences = gameScores.map((score) => Math.abs(score - guessScores[0]));\n  const gameScoreDifferenceDifferences = gameScoreDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/153", "prompt": "/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  const extension_strengths = extensions.map(extension => extension.match(/[A-Z]/)? -1 : 1);\n  const sorted_extensions = extensions.sort((a, b) => extension_strengths[b] - extension_strengths[a]);\n  return sorted_extensions[0];\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with its\n  strongest extension name removed.\n  Example:\n  strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class'\n*/\nconst removeStrongestExtension = (class_name, extensions) => {\n  const extension_strengths = extensions.map(extension => extension.match(/[A-Z]/)? -1 : 1);\n  const sorted_extensions = extensions.sort((a, b) => extension_strengths[b] - extension_strengths[a]);\n  return sorted_extensions.join('');\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with its\n  strongest extension name removed.\n  Example:\n  removeStrongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class'\n*/\nconst removeExtension = (class_name, extensions) => {\n  const extension_strengths = extensions.map(extension => extension.match(/[A-Z]/)? -1 : 1);\n  const sorted_extensions = extensions.sort((a, b) => extension_strengths[b] - extension_strengths[a]);\n  return sorted_extensions.join('');\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with its\n  strongest extension name removed.\n  Example:\n  removeExtension('my_class', ['AA', 'Be', 'CC']) =='my_class'\n*/\nconst removeExtensions = (class_name, extensions) => {\n  const extension_strengths = extensions.map(extension => extension.match(/[A-Z]/)? -1 : 1);\n  const sorted_extensions = extensions.sort((a, b) => extension_strengths[b] - extension_strengths[a]);\n  return sorted_extensions.join('');\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with its\n  strongest extension name removed.\n  Example:\n  removeExtensions('my_class', ['AA', 'Be', 'CC']) =='my_class'\n*/\nconst removeExtensionsArray = (class_name, extensions) => {\n  const extension_strengths = extensions.map(extension => extension.match(/[A-Z]/)? -1 : 1);\n  const sorted_extensions = extensions.sort((a, b) => extension_strengths[b] - extension_strengths[a]);\n  return sorted_extensions.join('');\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with its\n  strongest extension name removed.\n  Example:\n  removeExtensionsArray('my_class', ['AA', 'Be', 'CC']) =='my_class'\n*/\nconst removeExtensionsArray2 = (class_name, extensions) => {\n  const extension_strengths = extensions.map(extension => extension.match(/[A-Z]/)? -1 : 1);\n  const sorted_extensions = extensions.sort((a, b) => extension_strengths[b] - extension_strengths[a]);\n  return sorted_extensions.join('');\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with its\n  strongest extension name removed.\n  Example:\n  removeExtensionsArray2('my_class', ['AA', 'Be', 'CC']) =='my_class'\n*/\nconst removeExtensionsArray3 = (class_name, extensions) => {\n  const extension_strengths = extensions.map(extension => extension.match(/[A-Z]/)? -1 : 1);\n  const sorted_extensions = extensions.sort((a, b) => extension_strengths[b] - extension_strengths[a]);\n  return sorted_extensions.join('');\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with its\n  strongest extension name removed.\n  Example:\n  removeExtensionsArray3('my_class', ['AA', 'Be', 'CC']) =='my_class'\n*/\nconst removeExtensionsArray4 = (class_name, extensions) => {\n  const extension_strengths = extensions.map(extension => extension.match(/[A-Z]/)? -1 : 1);\n  const sorted_extensions = extensions.sort((a, b) => extension_strengths[b] - extension_strengths[a]);\n  return sorted_extensions.join('');\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with its\n  strongest extension name removed.\n  Example:\n  removeExtensionsArray4('my_class', ['AA', 'Be', 'CC']) =='my_class'\n*/\nconst removeExtensionsArray5 = (class_name, extensions) => {\n  const extension_strengths = extensions.map(extension => extension.match(/[A-Z]/)? -1 : 1);\n  const sorted_extensions = extensions.sort((a, b) => extension_strengths[b] - extension_strengths[a]);\n  return sorted_extensions.join('');\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with its\n  strongest extension name removed.\n  Example:\n  removeExtensionsArray5('my_class', ['AA', 'Be', 'CC']) =='my_class'\n*/\nconst removeExtensionsArray6 = (class_name, extensions) => {\n  const extension_strengths = extensions.map(extension => extension.match(/[A-Z]/)? -1 : 1);\n  const sorted_extensions = extensions.sort((a, b) => extension_strengths[b] - extension_strengths[a]);\n  return sorted_extensions.join('');\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with its\n  strongest extension name removed.\n  Example:\n  removeExtensionsArray6('my_class', ['AA', 'Be', 'CC']) =='my_class'\n*/\nconst removeExtensionsArray7 = (class_name, extensions) => {\n  const extension_strengths = extensions.map(extension => extension.match(/[A-Z]/)? -1 : 1);\n  const sorted_extensions = extensions.sort((a, b) => extension_strengths[b] - extension_strengths[a]);\n  return sorted_extensions.join('');\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with its\n  strongest extension name removed.\n  Example:\n  removeExtensionsArray7('my_class', ['AA', 'Be', 'CC']) =='my_class'\n*/\nconst removeExtensionsArray8 = (class_name, extensions) => {\n  const extension_strengths = extensions.map(extension => extension.match(/[A-Z]/)? -1 : 1);\n  const sorted_extensions = extensions.sort((a, b) => extension_strengths[b] - extension_strengths[a]);\n  return sorted_extensions.join('');\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with its\n  strongest extension name removed.\n  Example:\n  removeExtensionsArray8('my_class', ['AA', 'Be', 'CC']) =='my_class'\n*/\nconst removeExtensionsArray9", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/154", "prompt": "/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  let aArray = a.split('');\n  let bArray = b.split('');\n  let aLen = aArray.length;\n  let bLen = bArray.length;\n  let aIndex = 0;\n  let bIndex = 0;\n  let aMatch = false;\n  let bMatch = false;\n  let aMatchIndex = 0;\n  let bMatchIndex = 0;\n  let aMatchLen = 0;\n  let bMatchLen = 0;\n  let aMatchIndex2 = 0;\n  let bMatchIndex2 = 0;\n  let aMatchLen2 = 0;\n  let bMatchLen2 = 0;\n  let aMatchIndex3 = 0;\n  let bMatchIndex3 = 0;\n  let aMatchLen3 = 0;\n  let bMatchLen3 = 0;\n  let aMatchIndex4 = 0;\n  let bMatchIndex4 = 0;\n  let aMatchLen4 = 0;\n  let bMatchLen4 = 0;\n  let aMatchIndex5 = 0;\n  let bMatchIndex5 = 0;\n  let aMatchLen5 = 0;\n  let bMatchLen5 = 0;\n  let aMatchIndex6 = 0;\n  let bMatchIndex6 = 0;\n  let aMatchLen6 = 0;\n  let bMatchLen6 = 0;\n  let aMatchIndex7 = 0;\n  let bMatchIndex7 = 0;\n  let aMatchLen7 = 0;\n  let bMatchLen7 = 0;\n  let aMatchIndex8 = 0;\n  let bMatchIndex8 = 0;\n  let aMatchLen8 = 0;\n  let bMatchLen8 = 0;\n  let aMatchIndex9 = 0;\n  let bMatchIndex9 = 0;\n  let aMatchLen9 = 0;\n  let bMatchLen9 = 0;\n  let aMatchIndex10 = 0;\n  let bMatchIndex10 = 0;\n  let aMatchLen10 = 0;\n  let bMatchLen10 = 0;\n  let aMatchIndex11 = 0;\n  let bMatchIndex11 = 0;\n  let aMatchLen11 = 0;\n  let bMatchLen11 = 0;\n  let aMatchIndex12 = 0;\n  let bMatchIndex12 = 0;\n  let aMatchLen12 = 0;\n  let bMatchLen12 = 0;\n  let aMatchIndex13 = 0;\n  let bMatchIndex13 = 0;\n  let aMatchLen13 = 0;\n  let bMatchLen13 = 0;\n  let aMatchIndex14 = 0;\n  let bMatchIndex14 = 0;\n  let aMatchLen14 = 0;\n  let bMatchLen14 = 0;\n  let aMatchIndex15 = 0;\n  let bMatchIndex15 = 0;\n  let aMatchLen15 = 0;\n  let bMatchLen15 = 0;\n  let aMatchIndex16 = 0;\n  let bMatchIndex16 = 0;\n  let aMatchLen16 = 0;\n  let bMatchLen16 = 0;\n  let aMatchIndex17 = 0;\n  let bMatchIndex17 = 0;\n  let aMatchLen17 = 0;\n  let bMatchLen17 = 0;\n  let aMatchIndex18 = 0;\n  let bMatchIndex18 = 0;\n  let aMatchLen18 = 0;\n  let bMatchLen18 = 0;\n  let aMatchIndex19 = 0;\n  let bMatchIndex19 = 0;\n  let aMatchLen19 = 0;\n  let bMatchLen19 = 0;\n  let aMatchIndex20 = 0;\n  let bMatchIndex20 = 0;\n  let aMatchLen20 = 0;\n  let bMatchLen20 = 0;\n  let aMatchIndex21 = 0;\n  let bMatchIndex21 = 0;\n  let aMatchLen21 = 0;\n  let bMatchLen21 = 0;\n  let aMatchIndex22 = 0;\n  let bMatchIndex22 = 0;\n  let aMatchLen22 = 0;\n  let bMatchLen22 = 0;\n  let aMatchIndex23 = 0;\n  let bMatchIndex23 = 0;\n  let aMatchLen23 = 0;\n  let bMatchLen23 = 0;\n  let aMatchIndex24 = 0;\n  let bMatchIndex24 = 0;\n  let aMatchLen24 = 0;\n  let bMatchLen24 = 0;\n  let aMatchIndex25 = 0;\n  let bMatchIndex25 = 0;\n  let aMatchLen25 = 0;\n  let bMatchLen25 = 0;\n  let aMatchIndex26 = 0;\n  let bMatchIndex26 = 0;\n  let aMatchLen26 = 0;\n  let bMatchLen26 = 0;\n  let aMatchIndex27 = 0;\n  let bMatchIndex27 = 0;\n  let aMatchLen27 = 0;\n  let bMatchLen27 = 0;\n  let aMatchIndex28 = 0;\n  let bMatchIndex28 = 0;\n  let aMatchLen28 = 0;\n  let bMatchLen28 = 0;\n  let aMatchIndex29 = 0;\n  let bMatchIndex29 = 0;\n  let aMatchLen29 = 0;\n  let bMatchLen29 = 0;\n  let aMatchIndex30 = 0;\n  let bMatchIndex30 = 0;\n  let aMatchLen30 = 0;\n  let bMatchLen30 = 0;\n  let aMatchIndex31 = 0;\n  let bMatchIndex31 = 0;\n  let aMatchLen31 = 0;\n  let bMatchLen31 = 0;\n  let aMatchIndex32 = 0;\n  let bMatchIndex32 = 0;\n  let aMatchLen32 = 0;\n  let bMatchLen32 = 0;\n  let aMatchIndex33 = 0;\n  let bMatchIndex33 = 0;\n  let aMatchLen33 = 0;\n  let bMatchLen33 = 0;\n  let aMatchIndex34 = 0;\n  let bMatchIndex34 = 0;\n  let aMatchLen34 = 0;\n  let bMatchLen34 = 0;\n  let aMatchIndex35 = 0;\n  let bMatchIndex35 = 0;\n  let aMatchLen35 = 0;\n  let bMatchLen35 = 0;\n  let aMatchIndex36 = 0;\n  let bMatchIndex36 = 0;\n  let aMatchLen36 = 0;\n  let bMatchLen36 = 0;\n  let aMatchIndex37 = 0;\n  let bMatchIndex37 = 0;\n  let aMatchLen37 = 0;\n  let bMatchLen37 = 0;\n  let aMatchIndex38 = 0;\n  let bMatchIndex38 = 0;\n  let aMatchLen38 = 0;\n  let bMatchLen38 = 0;\n  let aMatchIndex39 = 0;\n  let bMatchIndex39 = 0;\n  let aMatchLen39 = 0;\n  let bMatchLen39 = 0;\n  let aMatchIndex40 = 0;\n  let bMatchIndex40 = 0;\n  let aMatchLen40 = 0;\n  let bMatchLen40 = 0;\n  let aMatchIndex41 = 0;\n  let bMatchIndex41 = 0;\n  let aMatchLen41 = 0;\n  let bMatchLen41 = 0;\n  let aMatchIndex42 = 0;\n  let bMatchIndex42 = 0;\n  let aMatchLen42 = 0;\n  let bMatchLen42 = 0;\n  let aMatchIndex43 = 0;\n  let bMatchIndex43 = 0;\n  let aMatchLen43 = 0;\n  let bMatchLen43 = 0;\n  let aMatchIndex44 = 0;\n  let bMatchIndex44 = 0;\n  let aMatchLen44 = 0;\n  let bMatchLen44 = 0;\n  let aMatchIndex45 = 0;\n  let bMatchIndex45 = 0;\n  let aMatchLen45 = 0;\n  let bMatchLen45 = 0;\n  let aMatchIndex46 = 0;\n  let bMatchIndex46 = 0;\n  let aMatchLen46 = 0;\n  let bMatchLen46 = 0;\n  let aMatchIndex47 = 0;\n  let bMatchIndex47 = 0;\n  let aMatchLen47 = 0;\n  let bMatchLen47 = 0;\n  let aMatchIndex48 = 0;\n  let bMatchIndex48 = 0;\n  let aMatchLen48 = 0;\n  let bMatchLen48 = 0;\n  let aMatchIndex49 = 0;\n  let bMatchIndex49 = 0;\n  let aMatchLen49 = 0;\n  let bMatchLen49 = 0;\n  let aMatchIndex50 = 0;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/155", "prompt": "/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = Math.floor(num / 2);\n    count++;\n  }\n  return [count, count % 2];\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst oddOddCount = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = Math.floor(num / 2);\n    count++;\n  }\n  return [count % 2, count];\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddEvenCount = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = Math.floor(num / 2);\n    count++;\n    if (num % 2 === 0) {\n      return [count % 2, count];\n    }\n  }\n  return [count % 2, count];\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddEvenCount(-12) ==> (1, 1)\n      evenOddEvenCount(123) ==> (1, 2)\n  */\nconst oddOddEvenCount = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = Math.floor(num / 2);\n    count++;\n    if (num % 2 === 0) {\n      return [count % 2, count];\n    }\n  }\n  return [count % 2, count];\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddEvenCount(-12) ==> (1, 1)\n      evenOddEvenCount(123) ==> (1, 2)\n  */\nconst oddEvenCount = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = Math.floor(num / 2);\n    count++;\n    if (num % 2 === 0) {\n      return [count, count % 2];\n    }\n  }\n  return [count % 2, count];\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddEvenCount(-12) ==> (1, 1)\n      evenOddEvenCount(123) ==> (1, 2)\n  */\nconst oddOddOddCount = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = Math.floor(num / 2);\n    count++;\n    if (num % 2 === 0) {\n      return [count % 2, count];\n    }\n  }\n  return [count % 2, count];\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddOddCount(-12) ==> (1, 1)\n      evenOddOddCount(123) ==> (1, 2)\n  */\nconst evenOddOddEvenCount = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = Math.floor(num / 2);\n    count++;\n    if (num % 2 === 0) {\n      return [count % 2, count];\n    }\n  }\n  return [count % 2, count];\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddOddEvenCount(-12) ==> (1, 1)\n      evenOddOddEvenCount(123) ==> (1, 2)\n  */\nconst oddOddOddOddEvenCount = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = Math.floor(num / 2);\n    count++;\n    if (num % 2 === 0) {\n      return [count % 2, count];\n    }\n  }\n  return [count % 2, count];\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddOddEvenCount(-12) ==> (1, 1)\n      evenOddOddEvenCount(123) ==> (1, 2)\n  */\nconst oddEvenOddCount = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = Math.floor(num / 2);\n    count++;\n    if (num % 2 === 0) {\n      return [count, count % 2];\n    }\n  }\n  return [count % 2, count];\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddOddEvenCount(-12) ==> (1, 1)\n      evenOddOddEvenCount(123) ==> (1, 2)\n  */\nconst oddOddEvenOddCount = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = Math.floor(num / 2);\n    count++;\n    if (num % 2 === 0) {\n      return [count % 2, count];\n    }\n  }\n  return [count % 2, count];\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddOddEvenCount(-12) ==> (1, 1)\n      evenOddOddEvenCount(123) ==> (1, 2)\n  */\nconst evenOddOddOddEvenCount = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = Math.floor(num / 2);\n    count++;\n    if (num % 2 === 0) {\n      return [count % 2, count];\n    }\n  }\n  return [count % 2, count];\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddOddEvenCount(-12) ==> (1, 1)\n      evenOddOddEvenCount(123) ==> (1, 2)\n  */\nconst oddOddOddOddOddEvenCount = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = Math.floor(num / 2);\n    count++;\n    if (num % 2 === 0) {\n      return [count % 2, count];\n    }\n  }\n  return [count % 2, count];\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddOddEvenCount(-12) ==> (1, 1)\n      evenOddOddEvenCount(123) ==> (1, 2)\n  */\nconst evenOddOddOddOddOddEvenCount = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = Math.floor(num / 2);\n    count++;\n    if (num % 2 === 0) {\n      return [count % 2, count];\n    }\n  }\n  return [count % 2, count];\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddOddEvenCount(-12) ==> (1, 1)\n      evenOddOddEvenCount(123) ==> (1, 2)\n  */\nconst oddOddOddOddOddOddOddEvenCount = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = Math.floor(num / 2);\n    count++;\n    if (num % 2 === 0) {\n      return [count % 2, count];\n    }\n  }\n  return [count % 2, count];\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddOddEvenCount(-12) ==> (1, 1)\n      evenOddOddEvenCount(123) ==> (1, 2)\n  */\nconst evenOddOddOddOddOddOddOddEvenCount = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = Math.floor(num / 2);\n    count++;\n    if (num % 2 === 0) {\n      return [count % 2, count];\n    }\n  }\n  return [count % 2, count];\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddOddEvenCount(-12) ==> (1, 1)\n      evenOddOddEvenCount(123) ==> (1, 2)\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/156", "prompt": "/*\n  With a positive integer, you get your Roman number equivalent as a string and return it in lowercase letters. Limitations: 1 < = number < = 1000 Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  With a positive integer, you get your Roman number equivalent as a string and return it in lowercase letters. Limitations: 1 < = number < = 1000 Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  if (number < 1 || number > 1000) {\n    throw new Error('Invalid number');\n  }\n  const roman = numberToRoman(number);\n  return roman.toLowerCase();\n};\n\n/*\n  With a positive integer, you get your Roman number equivalent as a string and return it in uppercase letters. Limitations: 1 < = number < = 1000 Examples:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLI'\n  >>> intToRoman(426) == 'CDXVI'\n  */\nconst intToRoman = (number) => {\n  if (number < 1 || number > 1000) {\n    throw new Error('Invalid number');\n  }\n  const roman = numberToRoman(number);\n  return roman.toUpperCase();\n};\n\n/*\n  With a positive integer, you get your Roman number equivalent as a string and return it in lowercase letters. Limitations: 1 < = number < = 1000 Examples:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLI'\n  >>> intToRoman(426) == 'CDXVI'\n  */\nconst intToRomanLow = (number) => {\n  if (number < 1 || number > 1000) {\n    throw new Error('Invalid number');\n  }\n  const roman = numberToRoman(number);\n  return roman.toLowerCase();\n};\n\n/*\n  With a positive integer, you get your Roman number equivalent as a string and return it in uppercase letters. Limitations: 1 < = number < = 1000 Examples:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLI'\n  >>> intToRoman(426) == 'CDXVI'\n  */\nconst intToRomanLow = (number) => {\n  if (number < 1 || number > 1000) {\n    throw new Error('Invalid number');\n  }\n  const roman = numberToRoman(number);\n  return roman.toUpperCase();\n};\n\n/*\n  With a positive integer, you get your Roman number equivalent as a string and return it in lowercase letters. Limitations: 1 < = number < = 1000 Examples:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLI'\n  >>> intToRoman(426) == 'CDXVI'\n  */\nconst intToRomanLow = (number) => {\n  if (number < 1 || number > 1000) {\n    throw new Error('Invalid number');\n  }\n  const roman = numberToRoman(number);\n  return roman.toLowerCase();\n};\n\n/*\n  With a positive integer, you get your Roman number equivalent as a string and return it in uppercase letters. Limitations: 1 < = number < = 1000 Examples:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLI'\n  >>> intToRoman(426) == 'CDXVI'\n  */\nconst intToRomanLow = (number) => {\n  if (number < 1 || number > 1000) {\n    throw new Error('Invalid number');\n  }\n  const roman = numberToRoman(number);\n  return roman.toUpperCase();\n};\n\n/*\n  With a positive integer, you get your Roman number equivalent as a string and return it in lowercase letters. Limitations: 1 < = number < = 1000 Examples:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLI'\n  >>> intToRoman(426) == 'CDXVI'\n  */\nconst intToRomanLow = (number) => {\n  if (number < 1 || number > 1000) {\n    throw new Error('Invalid number');\n  }\n  const roman = numberToRoman(number);\n  return roman.toLowerCase();\n};\n\n/*\n  With a positive integer, you get your Roman number equivalent as a string and return it in uppercase letters. Limitations: 1 < = number < = 1000 Examples:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLI'\n  >>> intToRoman(426) == 'CDXVI'\n  */\nconst intToRomanLow = (number) => {\n  if (number < 1 || number > 1000) {\n    throw new Error('Invalid number');\n  }\n  const roman = numberToRoman(number);\n  return roman.toUpperCase();\n};\n\n/*\n  With a positive integer, you get your Roman number equivalent as a string and return it in lowercase letters. Limitations: 1 < = number < = 1000 Examples:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLI'\n  >>> intToRoman(426) == 'CDXVI'\n  */\nconst intToRomanLow = (number) => {\n  if (number < 1 || number > 1000) {\n    throw new Error('Invalid number');\n  }\n  const roman = numberToRoman(number);\n  return roman.toLowerCase();\n};\n\n/*\n  With a positive integer, you get your Roman number equivalent as a string and return it in uppercase letters. Limitations: 1 < = number < = 1000 Examples:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLI'\n  >>> intToRoman(426) == 'CDXVI'\n  */\nconst intToRomanLow = (number) => {\n  if (number < 1 || number > 1000) {\n    throw new Error('Invalid number');\n  }\n  const roman = numberToRoman(number);\n  return roman.toUpperCase();\n};\n\n/*\n  With a positive integer, you get your Roman number equivalent as a string and return it in lowercase letters. Limitations: 1 < = number < = 1000 Examples:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLI'\n  >>> intToRoman(426) == 'CDXVI'\n  */\nconst intToRomanLow = (number) => {\n  if (number < 1 || number > 1000) {\n    throw new Error('Invalid number');\n  }\n  const roman = numberToRoman(number);\n  return roman.toLowerCase();\n};\n\n/*\n  With a positive integer, you get your Roman number equivalent as a string and return it in uppercase letters. Limitations: 1 < = number < = 1000 Examples:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLI'\n  >>> intToRoman(426) == 'CDXVI'\n  */\nconst intToRomanLow = (number) => {\n  if (number < 1 || number > 1000) {\n    throw new Error('Invalid number');\n  }\n  const roman = numberToRoman(number);\n  return roman.toUpperCase();\n};\n\n/*\n  With a positive integer, you get your Roman number equivalent as a string and return it in lowercase letters. Limitations: 1 < = number < = 1000 Examples:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLI'\n  >>> int", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the length of the three sides of a triangle. Returns true if the three sides form a right-angled triangle, otherwise wrong. A right-angled triangle is a triangle in which an angle is right-angled or 90 degrees.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n Given the length of the three sides of a triangle. Returns true if the three sides form a right-angled triangle, otherwise wrong. A right-angled triangle is a triangle in which an angle is right-angled or 90 degrees.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n  return side1 > side2 && side1 > side3;\n};\n\n/*\n Given the length of the three sides of a rectangle. Returns true if the three sides form a square, otherwise wrong. A square is a rectangle in which a side is square, i.e. a rectangle with sides length equals to 1.\n  Example:\n  squareTriangle(3, 4, 5) == true\n  squareTriangle(1, 2, 3) == false\n  */\nconst squareTriangle = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n  return side1 * side2 === side3;\n};\n\n/*\n Given the length of the three sides of a pentagon. Returns true if the three sides form a pentagon, otherwise wrong. A pentagon is a pentagon with sides length equals to 1.\n  Example:\n  pentagonTriangle(3, 4, 5) == true\n  pentagonTriangle(1, 2, 3) == false\n  */\nconst pentagonTriangle = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n  return side1 * side2 === side3;\n};\n\n/*\n Given the length of the three sides of a hexagon. Returns true if the three sides form a hexagon, otherwise wrong. A hexagon is a hexagon with sides length equals to 1.\n  Example:\n  hexagonTriangle(3, 4, 5) == true\n  hexagonTriangle(1, 2, 3) == false\n  */\nconst hexagonTriangle = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n  return side1 * side2 === side3;\n};\n\n/*\n Given the length of the three sides of a heptagon. Returns true if the three sides form a heptagon, otherwise wrong. A heptagon is a heptagon with sides length equals to 1.\n  Example:\n  heptagonTriangle(3, 4, 5) == true\n  heptagonTriangle(1, 2, 3) == false\n  */\nconst heptagonTriangle = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n  return side1 * side2 === side3;\n};\n\n/*\n Given the length of the three sides of a decagon. Returns true if the three sides form a decagon, otherwise wrong. A decagon is a decagon with sides length equals to 1.\n  Example:\n  decagonTriangle(3, 4, 5) == true\n  decagonTriangle(1, 2, 3) == false\n  */\nconst decagonTriangle = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n  return side1 * side2 === side3;\n};\n\n/*\n Given the length of the three sides of a octagon. Returns true if the three sides form a octagon, otherwise wrong. A octagon is a octagon with sides length equals to 1.\n  Example:\n  octagonTriangle(3, 4, 5) == true\n  octagonTriangle(1, 2, 3) == false\n  */\nconst octagonTriangle = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n  return side1 * side2 === side3;\n};\n\n/*\n Given the length of the three sides of a dodecagon. Returns true if the three sides form a dodecagon, otherwise wrong. A dodecagon is a dodecagon with sides length equals to 1.\n  Example:\n  dodecagonTriangle(3, 4, 5) == true\n  dodecagonTriangle(1, 2, 3) == false\n  */\nconst dodecagonTriangle = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n  return side1 * side2 === side3;\n};\n\n/*\n Given the length of the three sides of a hexadecagon. Returns true if the three sides form a hexadecagon, otherwise wrong. A hexadecagon is a hexadecagon with sides length equals to 1.\n  Example:\n  hexadecagonTriangle(3, 4, 5) == true\n  hexadecagonTriangle(1, 2, 3) == false\n  */\nconst hexadecagonTriangle = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n  return side1 * side2 === side3;\n};\n\n/*\n Given the length of the three sides of a heptadecagon. Returns true if the three sides form a heptadecagon, otherwise wrong. A heptadecagon is a heptadecagon with sides length equals to 1.\n  Example:\n  heptadecagonTriangle(3, 4, 5) == true\n  heptadecagonTriangle(1, 2, 3) == false\n  */\nconst heptadecagonTriangle = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n  return side1 * side2 === side3;\n};\n\n/*\n Given the length of the three sides of a decagon. Returns true if the three sides form a decagon, otherwise wrong. A decagon is a decagon with sides length equals to 1.\n  Example:\n  decagonTriangle(3, 4, 5) == true\n  decagonTriangle(1, 2, 3) == false\n  */\nconst decagonTriangle = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n  return side1 * side2 === side3;\n};\n\n/*\n Given the length of the three sides of a octagon. Returns true if the three sides form a octagon, otherwise wrong. A octagon is a octagon with sides length equals to 1.\n  Example:\n  octagonTriangle(3, 4, 5) == true\n  octagonTriangle(1, 2, 3) == false\n  */\nconst octagonTriangle = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/158", "prompt": "/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  let maxLength = 0;\n  let maxWord = \"\";\n  let maxChar = \"\";\n  let maxNum = 0;\n  let maxNumChar = 0;\n  let maxNumWord = 0;\n  let maxNumCharWord = 0;\n  let maxNumWordWord = 0;\n  let maxNumCharWordWord = 0;\n  let maxNumWordWordWord = 0;\n  let maxNumCharWordWordWord = 0;\n  let maxNumWordWordWordWord = 0;\n  let maxNumCharWordWordWord = 0;\n  let maxNumWordWordWordWord = 0;\n  let maxNumCharWordWordWord = 0;\n  let maxNumWordWordWordWord = 0;\n  let maxNumCharWordWordWord = 0;\n  let maxNumWordWordWordWord = 0;\n  let maxNumCharWordWordWord = 0;\n  let maxNumWordWordWordWord = 0;\n  let maxNumCharWordWordWord = 0;\n  let maxNumWordWordWordWord = 0;\n  let maxNumCharWordWordWord = 0;\n  let maxNumWordWordWordWord = 0;\n  let maxNumCharWordWordWord = 0;\n  let maxNumWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumCharWordWordWordWord = 0;\n  let maxNumWordWordWordWordWord = 0;\n  let maxNumChar", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*\n  You're a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const carrots = Math.ceil(number * Math.ceil(need / 100));\n  const remainingCarrots = Math.ceil(remaining / 100);\n  const remainingEaten = remaining % 100;\n  const remainingEatenCarrots = remainingEaten % 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;\n  const remainingEatenCarrots = remainingEatenCarrots + remainingEatenCarrots * 100;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/16", "prompt": "/* Find out how many different characters a string consists of (regardless of the case).\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Find out how many different characters a string consists of (regardless of the case).\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    if (chars.includes(chars[i])) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, return all possible permutations of its characters.\n * If there are duplicates, only the first occurrence is returned.\n * If there are multiple permutations, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutations.\n * If there are multiple characters in the string, return all permutation", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split(',');\n\n  let result = 0;\n  for (let i = 0; i < operatorList.length; i++) {\n    result += operandList[i] * operatorList[i];\n  }\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split(',');\n\n  let result = 0;\n  for (let i = 0; i < operatorList.length; i++) {\n    result += operandList[i] * operatorList[i];\n  }\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split(',');\n\n  let result = 0;\n  for (let i = 0; i < operatorList.length; i++) {\n    result += operandList[i] * operatorList[i];\n  }\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split(',');\n\n  let result = 0;\n  for (let i = 0; i < operatorList.length; i++) {\n    result += operandList[i] * operatorList[i];\n  }\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split(',');\n\n  let result = 0;\n  for (let i = 0; i < operatorList.length; i++) {\n    result += operandList[i] * operatorList[i];\n  }\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split(',');\n\n  let result = 0;\n  for (let i = 0; i < operatorList.length; i++) {\n    result += operandList[i] * operatorList[i];\n  }\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split(',');\n\n  let result = 0;\n  for (let i = 0; i < operatorList.length; i++) {\n    result += operandList[i] * operatorList[i];\n  }\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/161", "prompt": "/*YIf s [i] is a letter, the uppercase letter is reversed from the bottom to the top or vice versa, otherwise it remains as it is. If the string contains no letters, the string is reversed. The function should return the resulting string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*YIf s [i] is a letter, the uppercase letter is reversed from the bottom to the top or vice versa, otherwise it remains as it is. If the string contains no letters, the string is reversed. The function should return the resulting string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let reversed = '';\n  let letter;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/162", "prompt": "/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return 0\n  }\n\n  return crypto.createHash('md5').update(text).digest('hex')\n}\n\n/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToSha1 = (text) => {\n  if (!text) {\n    return 0\n  }\n\n  return crypto.createHash('sha1').update(text).digest('hex')\n}\n\n/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToSha1('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToSha256 = (text) => {\n  if (!text) {\n    return 0\n  }\n\n  return crypto.createHash('sha256').update(text).digest('hex')\n}\n\n/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToSha256('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToSha512 = (text) => {\n  if (!text) {\n    return 0\n  }\n\n  return crypto.createHash('sha512').update(text).digest('hex')\n}\n\n/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToSha512('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToRsa = (text) => {\n  if (!text) {\n    return 0\n  }\n\n  return crypto.createHash('sha512').update(text).digest('hex')\n}\n\n/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToRsa('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToRsaSha1 = (text) => {\n  if (!text) {\n    return 0\n  }\n\n  return crypto.createHash('sha1').update(text).digest('hex')\n}\n\n/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToRsaSha1('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToRsaSha256 = (text) => {\n  if (!text) {\n    return 0\n  }\n\n  return crypto.createHash('sha256').update(text).digest('hex')\n}\n\n/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToRsaSha256('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToRsaSha512 = (text) => {\n  if (!text) {\n    return 0\n  }\n\n  return crypto.createHash('sha512').update(text).digest('hex')\n}\n\n/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToRsaSha512('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToRsaRsa = (text) => {\n  if (!text) {\n    return 0\n  }\n\n  return crypto.createHash('sha512').update(text).digest('hex')\n}\n\n/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToRsaRsa('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToRsaRsaSha1 = (text) => {\n  if (!text) {\n    return 0\n  }\n\n  return crypto.createHash('sha1').update(text).digest('hex')\n}\n\n/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToRsaRsaSha1('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToRsaRsaSha256 = (text) => {\n  if (!text) {\n    return 0\n  }\n\n  return crypto.createHash('sha256').update(text).digest('hex')\n}\n\n/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToRsaRsaSha256('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToRsaRsaSha512 = (text) => {\n  if (!text) {\n    return 0\n  }\n\n  return crypto.createHash('sha512').update(text).digest('hex')\n}\n\n/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToRsaRsaSha512('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToRsaRsaRsaSha1 = (text) => {\n  if (!text) {\n    return 0\n  }\n\n  return crypto.createHash('sha1').update(text).digest('hex')\n}\n\n/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToRsaRsaSha1('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToRsaRsaSha256 = (text) => {\n  if (!text) {\n    return 0\n  }\n\n  return crypto.createHash('sha256').update(text).digest('hex')\n}\n\n/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToRsaRsaSha256('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToRsaRsaSha512 = (text) => {\n  if (!text) {\n    return 0\n  }\n\n  return crypto.createHash('sha512').update(text).digest('hex')\n}\n\n/*\n  If you ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  For two positive integers a and b, return the even digits between a and b in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  For two positive integers a and b, return the even digits between a and b in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const result = [];\n  let i = a;\n  let j = 0;\n  while (i < b) {\n    result.push(j);\n    i += 1;\n    j += 1;\n  }\n  return result;\n};\n\n/**\n  Given a positive integer n, return the largest power of 2 that is a multiple of n.\n\n  For example:\n  powerOfTwo(2) => 2\n  powerOfTwo(3) => 4\n  powerOfTwo(4) => 8\n  powerOfTwo(5) => 16\n  powerOfTwo(6) => 32\n  powerOfTwo(7) => 64\n  powerOfTwo(8) => 128\n  powerOfTwo(9) => 256\n  powerOfTwo(10) => 512\n  powerOfTwo(11) => 1024\n  powerOfTwo(12) => 2048\n  powerOfTwo(13) => 4096\n  powerOfTwo(14) => 8192\n  powerOfTwo(15) => 16384\n  powerOfTwo(16) => 32768\n  powerOfTwo(17) => 65536\n  powerOfTwo(18) => 131072\n  powerOfTwo(19) => 262144\n  powerOfTwo(20) => 524288\n  powerOfTwo(21) => 1048576\n  powerOfTwo(22) => 2097152\n  powerOfTwo(23) => 4194304\n  powerOfTwo(24) => 8388608\n  powerOfTwo(25) => 16777216\n  powerOfTwo(26) => 33554432\n  powerOfTwo(27) => 67108864\n  powerOfTwo(28) => 134217728\n  powerOfTwo(29) => 268435456\n  powerOfTwo(30) => 536870912\n  powerOfTwo(31) => 1073741824\n  powerOfTwo(32) => 2147483648\n  powerOfTwo(33) => 4294967296\n  powerOfTwo(34) => 8589934592\n  powerOfTwo(35) => 17179869184\n  powerOfTwo(36) => 34359738368\n  powerOfTwo(37) => 68719476736\n  powerOfTwo(38) => 1374389534768\n  powerOfTwo(39) => 274877906944\n  powerOfTwo(40) => 549755813888\n  powerOfTwo(41) => 1099511627776\n  powerOfTwo(42) => 209715208960\n  powerOfTwo(43) => 419430400960\n  powerOfTwo(44) => 838860800960\n  powerOfTwo(45) => 1677721600960\n  powerOfTwo(46) => 3355443200960\n  powerOfTwo(47) => 6710886400960\n  powerOfTwo(48) => 13421772800960\n  powerOfTwo(49) => 26843545600960\n  powerOfTwo(50) => 53687091200960\n  powerOfTwo(51) => 10737418240000\n  powerOfTwo(52) => 2147483648000\n  powerOfTwo(53) => 42949672960000\n  powerOfTwo(54) => 85899345920000\n  powerOfTwo(55) => 171798691840000\n  powerOfTwo(56) => 343597383680000\n  powerOfTwo(57) => 687194767360000\n  powerOfTwo(58) => 1374389534768000\n  powerOfTwo(59) => 2748779069440000\n  powerOfTwo(60) => 5497558138880000\n  powerOfTwo(61) => 10995116277760000\n  powerOfTwo(62) => 209715208960000\n  powerOfTwo(63) => 419430400960000\n  powerOfTwo(64) => 838860800960000\n  powerOfTwo(65) => 1677721600960000\n  powerOfTwo(66) => 3355443200960000\n  powerOfTwo(67) => 6710886400960000\n  powerOfTwo(68) => 134217728000000\n  powerOfTwo(69) => 268435456000000\n  powerOfTwo(70) => 536870912000000\n  powerOfTwo(71) => 107374182400000\n  powerOfTwo(72) => 214748364800000\n  powerOfTwo(73) => 429496729600000\n  powerOfTwo(74) => 858993459200000\n  powerOfTwo(75) => 1717986918400000\n  powerOfTwo(76) => 3435973836800000\n  powerOfTwo(77) => 6871947673600000\n  powerOfTwo(78) => 137438953476800000\n  powerOfTwo(79) => 27487790694400000\n  powerOfTwo(80) => 54975581388800000\n  powerOfTwo(81) => 109951162777600000\n  powerOfTwo(82) => 2097152089600000\n  powerOfTwo(83) => 4194304009600000\n  powerOfTwo(84) => 8388608009600000\n  powerOfTwo(85) => 16777216009600000\n  powerOfTwo(86) => 33554432009600000\n  powerOfTwo(87) => 67108864009600000\n  powerOfTwo(88) => 134217728000000\n  powerOfTwo(89) => 268435456000000\n  powerOfTwo(90) => 536870912000000\n  powerOfTwo(91) => 107374182400000\n  powerOfTwo(92) => 214748364800000\n  powerOfTwo(93) => 429496729600000\n  powerOfTwo(94) => 858993459200000\n  powerOfTwo(95) => 1717986918400000\n  powerOfTwo(96) => 3435973836800000\n  powerOfTwo(97) => 6871947673600000\n  powerOfTwo(98) => 137438953476800000\n  powerOfTwo(99) => 27487790694400000\n  powerOfTwo(100) => 54975581388800000\n  powerOfTwo(101) => 109951162777600000\n  powerOfTwo(102) => 2097152089600000\n  powerOfTwo(103) => 4194304009600000\n  powerOfTwo(104) => 8388608009600000\n  powerOfTwo(105) => 16777216009600000\n  powerOfTwo(106) => 33554432009600000\n  powerOfTwo(107) => 67108864009600000\n  powerOfTwo(108) => 134217728000000\n  powerOfTwo(109) => 268435456000000\n  powerOfTwo(110) => 536870912000000\n  powerOfTwo(11", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/17", "prompt": "/* Entering this function is a string that represents notes in a special ASCII format. Your task is to analyze this string and return a list of integers corresponding to the number of beats each one does not hold. Here's a legend: \"o\" - whole note, takes four beats \"o | '- half note, takes two beats.\"\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Entering this function is a string that represents notes in a special ASCII format. Your task is to analyze this string and return a list of integers corresponding to the number of beats each one does not hold. Here's a legend: \"o\" - whole note, takes four beats \"o | '- half note, takes two beats.\"\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  let notes_array = []\n  let notes_string = ''\n  let notes_count = 0\n  let notes_beat = 0\n  let notes_half = 0\n  let notes_halfbeat = 0\n  let notes_halfbeatbeat = 0\n  let notes_halfbeatbeatbeat = 0\n  let notes_halfbeatbeatbeatbeat = 0\n  let notes_halfbeatbeatbeatbeatbeat = 0\n  let notes_halfbeatbeatbeatbeatbeatbeat = 0\n  let notes_halfbeatbeatbeatbeatbeatbeatbeat = 0\n  let notes_halfbeatbeatbeatbeatbeatbeatbeatbeat = 0\n  let notes_halfbeatbeatbeatbeatbeatbeatbeatbeatbeat = 0\n  let notes_halfbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeat = 0\n  let notes_halfbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeat = 0\n  let notes_halfbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeatbeat", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/18", "prompt": "/* Find out how often a particular substring can be found in the original string. Count overlapping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Find out how often a particular substring can be found in the original string. Count overlapping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l && j < m) {\n    if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (string[i] === substring[j]) {\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/19", "prompt": "/* Input is a sequence of numbers delimited by spaces from \"zero\" to \"nine.\" Valid options are \"zero,\" \"one,\" \"two,\" \"three,\" \"four,\" \"five,\" \"six,\" \"seven,\" \"eight\" and \"nine.\"\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Input is a sequence of numbers delimited by spaces from \"zero\" to \"nine.\" Valid options are \"zero,\" \"one,\" \"two,\" \"three,\" \"four,\" \"five,\" \"six,\" \"seven,\" \"eight\" and \"nine.\"\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numbersByNumber = {}\n  const numbersByLetter = {}\n  const numbersByLetterByNumber = {}\n  const numbersByLetterByNumberByLetter = {}\n  const numbersByLetterByNumberByLetterByNumber = {}\n  const numbersByLetterByNumberByLetterByNumberByLetter = {}\n  const numbersByLetterByNumberByLetterByNumberByLetterByNumberByLetter = {}\n  const numbersByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetter = {}\n  const numbersByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetter = {}\n  const numbersByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetter = {}\n  const numbersByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetter = {}\n  const numbersByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetter = {}\n  const numbersByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumberByLetterByNumber", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/2", "prompt": "/* In the case of a positive floating point number, it can be divided into an integer part (largest integer smaller than the specified number) and decimal numbers (remaining part always smaller than 1).\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* In the case of a positive floating point number, it can be divided into an integer part (largest integer smaller than the specified number) and decimal numbers (remaining part always smaller than 1).\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const isNegative = number < 0\n  const isPositive = number > 0\n  const isFloat = typeof number === 'number'\n  const isInteger = isFloat && isPositive && isNegative\n  const isDecimal = number % 1!== 0\n\n  // If number is negative, return it unchanged\n  if (isNegative) {\n    return number\n  }\n\n  // If number is positive, round it down\n  if (isPositive) {\n    return Math.floor(number)\n  }\n\n  // If number is floating point, return it unchanged\n  if (isFloat) {\n    return number\n  }\n\n  // If number is integer, return it unchanged\n  if (isInteger) {\n    return number\n  }\n\n  // If number is decimal, return it unchanged\n  if (isDecimal) {\n    return number\n  }\n\n  // If number is not an integer or decimal, return it unchanged\n  return number\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(number)? number : NaN\n}\n\n// Convert a string to a number if it isn't already\nconst toNumber = (text) => {\n  const number = parseFloat(text)\n  return isFinite(", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/20", "prompt": "/* From a list of numbers (with a length of at least two) select and return two numbers closest to each other and return them in order (smaller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* From a list of numbers (with a length of at least two) select and return two numbers closest to each other and return them in order (smaller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const minDistance = Number.MAX_VALUE;\n  const closestElements = [];\n  const closestElementsIndexes = [];\n\n  for (let i = 0; i < numbers.length; i++) {\n    const distance = numbers[i] - numbers[closestElementsIndexes[i]];\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElementsIndexes[i] = i;\n      closestElements.push(numbers[i]);\n    }\n  }\n\n  return closestElements;\n};\n\nconst findClosestElementsIndex = (numbers, index) => {\n  const minDistance = Number.MAX_VALUE;\n  const closestElementsIndexes = [];\n\n  for (let i = 0; i < numbers.length; i++) {\n    const distance = numbers[i] - numbers[index];\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElementsIndexes.push(index);\n    }\n  }\n\n  return closestElementsIndexes;\n};\n\nconst findClosestElementsIndexes = (numbers, indexes) => {\n  const minDistance = Number.MAX_VALUE;\n  const closestElementsIndexes = [];\n\n  for (let i = 0; i < numbers.length; i++) {\n    const distance = numbers[i] - numbers[indexes[i]];\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElementsIndexes.push(indexes[i]);\n    }\n  }\n\n  return closestElementsIndexes;\n};\n\nconst findClosestElementsIndexes2 = (numbers, indexes) => {\n  const minDistance = Number.MAX_VALUE;\n  const closestElementsIndexes = [];\n\n  for (let i = 0; i < numbers.length; i++) {\n    const distance = numbers[i] - numbers[indexes[i]];\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElementsIndexes.push(indexes[i]);\n    }\n  }\n\n  return closestElementsIndexes;\n};\n\nconst findClosestElementsIndexes3 = (numbers, indexes) => {\n  const minDistance = Number.MAX_VALUE;\n  const closestElementsIndexes = [];\n\n  for (let i = 0; i < numbers.length; i++) {\n    const distance = numbers[i] - numbers[indexes[i]];\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElementsIndexes.push(indexes[i]);\n    }\n  }\n\n  return closestElementsIndexes;\n};\n\nconst findClosestElementsIndexes4 = (numbers, indexes) => {\n  const minDistance = Number.MAX_VALUE;\n  const closestElementsIndexes = [];\n\n  for (let i = 0; i < numbers.length; i++) {\n    const distance = numbers[i] - numbers[indexes[i]];\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElementsIndexes.push(indexes[i]);\n    }\n  }\n\n  return closestElementsIndexes;\n};\n\nconst findClosestElementsIndexes5 = (numbers, indexes) => {\n  const minDistance = Number.MAX_VALUE;\n  const closestElementsIndexes = [];\n\n  for (let i = 0; i < numbers.length; i++) {\n    const distance = numbers[i] - numbers[indexes[i]];\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElementsIndexes.push(indexes[i]);\n    }\n  }\n\n  return closestElementsIndexes;\n};\n\nconst findClosestElementsIndexes6 = (numbers, indexes) => {\n  const minDistance = Number.MAX_VALUE;\n  const closestElementsIndexes = [];\n\n  for (let i = 0; i < numbers.length; i++) {\n    const distance = numbers[i] - numbers[indexes[i]];\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElementsIndexes.push(indexes[i]);\n    }\n  }\n\n  return closestElementsIndexes;\n};\n\nconst findClosestElementsIndexes7 = (numbers, indexes) => {\n  const minDistance = Number.MAX_VALUE;\n  const closestElementsIndexes = [];\n\n  for (let i = 0; i < numbers.length; i++) {\n    const distance = numbers[i] - numbers[indexes[i]];\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElementsIndexes.push(indexes[i]);\n    }\n  }\n\n  return closestElementsIndexes;\n};\n\nconst findClosestElementsIndexes8 = (numbers, indexes) => {\n  const minDistance = Number.MAX_VALUE;\n  const closestElementsIndexes = [];\n\n  for (let i = 0; i < numbers.length; i++) {\n    const distance = numbers[i] - numbers[indexes[i]];\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElementsIndexes.push(indexes[i]);\n    }\n  }\n\n  return closestElementsIndexes;\n};\n\nconst findClosestElementsIndexes9 = (numbers, indexes) => {\n  const minDistance = Number.MAX_VALUE;\n  const closestElementsIndexes = [];\n\n  for (let i = 0; i < numbers.length; i++) {\n    const distance = numbers[i] - numbers[indexes[i]];\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElementsIndexes.push(indexes[i]);\n    }\n  }\n\n  return closestElementsIndexes;\n};\n\nconst findClosestElementsIndexes10 = (numbers, indexes) => {\n  const minDistance = Number.MAX_VALUE;\n  const closestElementsIndexes = [];\n\n  for (let i = 0; i < numbers.length; i++) {\n    const distance = numbers[i] - numbers[indexes[i]];\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElementsIndexes.push(indexes[i]);\n    }\n  }\n\n  return closestElementsIndexes;\n};\n\nconst findClosestElementsIndexes11 = (numbers, indexes) => {\n  const minDistance = Number.MAX_VALUE;\n  const closestElementsIndexes = [];\n\n  for (let i = 0; i < numbers.length; i++) {\n    const distance = numbers[i] - numbers[indexes[i]];\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElementsIndexes.push(indexes[i]);\n    }\n  }\n\n  return closestElementsIndexes;\n};\n\nconst findClosestElementsIndexes12 = (numbers, indexes) => {\n  const minDistance = Number.MAX_VALUE;\n  const closestElementsIndexes = [];\n\n  for (let i = 0; i < numbers.length; i++) {\n    const distance = numbers[i] - numbers[indexes[i]];\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElementsIndexes.push(indexes[i]);\n    }\n  }\n\n  return closestElementsIndexes;\n};\n\nconst findClosestElementsIndexes13 = (numbers, indexes) => {\n  const minDistance = Number.MAX_VALUE;\n  const closestElementsIndexes = [];\n\n  for (let i = 0; i < numbers.length; i++) {\n    const distance = numbers[i] - numbers[indexes[i]];\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElementsIndexes.push(indexes[i]);\n    }\n  }\n\n  return closestElementsIndexes;\n};\n\nconst findClosestElementsIndexes14 = (numbers, indexes) => {\n  const minDistance = Number.MAX_VALUE;\n  const closestElementsIndexes = [];\n\n  for (let i = 0; i < numbers.length; i++) {\n    const distance = numbers[i] - numbers[indexes[i]];\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElementsIndexes.push(indexes[i]);\n    }\n  }\n\n  return closestElementsIndexes;\n};\n\nconst findClosestElementsIndexes15 = (numbers, indexes) => {\n  const minDistance = Number.MAX_VALUE;\n  const closestElementsIndexes = [];\n\n  for (let i = 0; i < numbers.length; i++) {\n    const distance = numbers[i] - numbers[indexes[i]];\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElementsIndexes.push(indexe", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/21", "prompt": "/* Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const [min, max] = numbers.reduce((acc, n) => [Math.min(acc, n), Math.max(acc, n)], [0, Number.MAX_SAFE_INTEGER]);\n  return numbers.map((n) => n * max / min);\n};\n\n/**\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0], 2)\n * [0.0, 0.25, 0.5, 0.75, 1.0]\n */\nconst rescaleToUnit = (numbers, scale) => {\n  const [min, max] = numbers.reduce((acc, n) => [Math.min(acc, n), Math.max(acc, n)], [0, Number.MAX_SAFE_INTEGER]);\n  return numbers.map((n) => n * max / min * scale);\n};\n\n/**\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0], 2)\n * [0.0, 0.25, 0.5, 0.75, 1.0]\n */\nconst rescaleToUnit = (numbers, scale) => {\n  const [min, max] = numbers.reduce((acc, n) => [Math.min(acc, n), Math.max(acc, n)], [0, Number.MAX_SAFE_INTEGER]);\n  return numbers.map((n) => n * max / min * scale);\n};\n\n/**\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0], 2)\n * [0.0, 0.25, 0.5, 0.75, 1.0]\n */\nconst rescaleToUnit = (numbers, scale) => {\n  const [min, max] = numbers.reduce((acc, n) => [Math.min(acc, n), Math.max(acc, n)], [0, Number.MAX_SAFE_INTEGER]);\n  return numbers.map((n) => n * max / min * scale);\n};\n\n/**\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0], 2)\n * [0.0, 0.25, 0.5, 0.75, 1.0]\n */\nconst rescaleToUnit = (numbers, scale) => {\n  const [min, max] = numbers.reduce((acc, n) => [Math.min(acc, n), Math.max(acc, n)], [0, Number.MAX_SAFE_INTEGER]);\n  return numbers.map((n) => n * max / min * scale);\n};\n\n/**\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0], 2)\n * [0.0, 0.25, 0.5, 0.75, 1.0]\n */\nconst rescaleToUnit = (numbers, scale) => {\n  const [min, max] = numbers.reduce((acc, n) => [Math.min(acc, n), Math.max(acc, n)], [0, Number.MAX_SAFE_INTEGER]);\n  return numbers.map((n) => n * max / min * scale);\n};\n\n/**\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0], 2)\n * [0.0, 0.25, 0.5, 0.75, 1.0]\n */\nconst rescaleToUnit = (numbers, scale) => {\n  const [min, max] = numbers.reduce((acc, n) => [Math.min(acc, n), Math.max(acc, n)], [0, Number.MAX_SAFE_INTEGER]);\n  return numbers.map((n) => n * max / min * scale);\n};\n\n/**\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0], 2)\n * [0.0, 0.25, 0.5, 0.75, 1.0]\n */\nconst rescaleToUnit = (numbers, scale) => {\n  const [min, max] = numbers.reduce((acc, n) => [Math.min(acc, n), Math.max(acc, n)], [0, Number.MAX_SAFE_INTEGER]);\n  return numbers.map((n) => n * max / min * scale);\n};\n\n/**\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0], 2)\n * [0.0, 0.25, 0.5, 0.75, 1.0]\n */\nconst rescaleToUnit = (numbers, scale) => {\n  const [min, max] = numbers.reduce((acc, n) => [Math.min(acc, n), Math.max(acc, n)], [0, Number.MAX_SAFE_INTEGER]);\n  return numbers.map((n) => n * max / min * scale);\n};\n\n/**\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0], 2)\n * [0.0, 0.25, 0.5, 0.75, 1.0]\n */\nconst rescaleToUnit = (numbers, scale) => {\n  const [min, max] = numbers.reduce((acc, n) => [Math.min(acc, n), Math.max(acc, n)], [0, Number.MAX_SAFE_INTEGER]);\n  return numbers.map((n) => n * max / min * scale);\n};\n\n/**\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0], 2)\n * [0.0, 0.25, 0.5, 0.75, 1.0]\n */\nconst rescaleToUnit = (numbers, scale) => {\n  const [min, max] = numbers.reduce((acc, n) => [Math.min(acc, n), Math.max(acc, n)], [0, Number.MAX_SAFE_INTEGER]);\n  return numbers.map((n) => n * max / min * scale);\n};\n\n/**\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0], 2)\n * [0.0, 0.25, 0.5, 0.75, 1.0]\n */\nconst rescaleToUnit = (numbers, scale) => {\n  const [min, max] = numbers.reduce((acc, n) => [Math.min(acc, n), Math.max(acc, n)], [0, Number.MAX_SAFE_INTEGER]);\n  return numbers.map((n) => n * max / min * scale);\n};\n\n/**\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0], 2)\n * [0.0, 0.25, 0.5, 0.75, 1.0]\n */\nconst rescaleToUnit = (numbers, scale) => {\n  const [min, max] = numbers.reduce((acc, n) => [Math.min(acc, n), Math.max(acc, n)], [0, Number.MAX_SAFE_INTEGER]);\n  return numbers.map((n) => n * max / min * scale);\n};\n\n/**\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0], 2)\n * [0.0, 0.25, 0.5, 0.75, 1.0]\n */\nconst rescaleToUnit = (numbers, scale) => {\n  const [min, max] = numbers.reduce((acc, n) => [Math.min(acc, n), Math.max(acc, n)", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/22", "prompt": "/* Filters the specified list of arbitrary Python values for integers only\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Filters the specified list of arbitrary Python values for integers only\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(value => typeof value === 'number')\n}\n\n/**\n * Filters the specified list of arbitrary Python values for floats only\n * >>> filterFloats(['a', 3.14, 5])\n  [3.14, 5]\n  >>> filterFloats([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterFloats = (values) => {\n  return values.filter(value => typeof value === 'number')\n}\n\n/**\n * Filters the specified list of arbitrary Python values for booleans only\n * >>> filterBooleans(['a', 3.14, 5])\n  [true, false]\n  >>> filterBooleans([1, 2, 3, 'abc', {}, []])\n  [true, false]\n  */\nconst filterBooleans = (values) => {\n  return values.filter(value => typeof value === 'boolean')\n}\n\n/**\n * Filters the specified list of arbitrary Python values for strings only\n * >>> filterStrings(['a', 3.14, 5])\n  ['a', 3.14, 5]\n  >>> filterStrings([1, 2, 3, 'abc', {}, []])\n  ['a', 3.14, 5]\n  */\nconst filterStrings = (values) => {\n  return values.filter(value => typeof value ==='string')\n}\n\n/**\n * Filters the specified list of arbitrary Python values for lists only\n * >>> filterLists(['a', 3.14, 5])\n  [['a', 3.14, 5]]\n  >>> filterLists([1, 2, 3, 'abc', {}, []])\n  [['a', 3.14, 5]]\n  */\nconst filterLists = (values) => {\n  return values.filter(value => Array.isArray(value))\n}\n\n/**\n * Filters the specified list of arbitrary Python values for dicts only\n * >>> filterDicts(['a', 3.14, 5])\n  {'a': 3.14}\n  >>> filterDicts([1, 2, 3, 'abc', {}, []])\n  {'a': 3.14}\n  */\nconst filterDicts = (values) => {\n  return values.filter(value => typeof value === 'object')\n}\n\n/**\n * Filters the specified list of arbitrary Python values for tuples only\n * >>> filterTuples(['a', 3.14, 5])\n  ('a', '3.14')\n  >>> filterTuples([1, 2, 3, 'abc', {}, []])\n  ('a', '3.14')\n  */\nconst filterTuples = (values) => {\n  return values.filter(value => typeof value ==='string')\n}\n\n/**\n * Filters the specified list of arbitrary Python values for sets only\n * >>> filterSets(['a', 3.14, 5])\n  set([1, 2, 3])\n  >>> filterSets([1, 2, 3, 'abc', {}, []])\n  set([1, 2, 3])\n  */\nconst filterSets = (values) => {\n  return values.filter(value => typeof value ==='string')\n}\n\n/**\n * Filters the specified list of arbitrary Python values for generators only\n * >>> filterGenerators(['a', 3.14, 5])\n  <generator object <genexpr> at 0x7f9a18e67b50>\n  >>> filterGenerators([1, 2, 3, 'abc', {}, []])\n  <generator object <genexpr> at 0x7f9a18e67b50>\n  */\nconst filterGenerators = (values) => {\n  return values.filter(value => typeof value === 'function')\n}\n\n/**\n * Filters the specified list of arbitrary Python values for generators only\n * >>> filterGenerators(['a', 3.14, 5])\n  <generator object <genexpr> at 0x7f9a18e67b50>\n  >>> filterGenerators([1, 2, 3, 'abc', {}, []])\n  <generator object <genexpr> at 0x7f9a18e67b50>\n  */\nconst filterGenerators = (values) => {\n  return values.filter(value => typeof value === 'function')\n}\n\n/**\n * Filters the specified list of arbitrary Python values for generators only\n * >>> filterGenerators(['a', 3.14, 5])\n  <generator object <genexpr> at 0x7f9a18e67b50>\n  >>> filterGenerators([1, 2, 3, 'abc', {}, []])\n  <generator object <genexpr> at 0x7f9a18e67b50>\n  */\nconst filterGenerators = (values) => {\n  return values.filter(value => typeof value === 'function')\n}\n\n/**\n * Filters the specified list of arbitrary Python values for generators only\n * >>> filterGenerators(['a', 3.14, 5])\n  <generator object <genexpr> at 0x7f9a18e67b50>\n  >>> filterGenerators([1, 2, 3, 'abc', {}, []])\n  <generator object <genexpr> at 0x7f9a18e67b50>\n  */\nconst filterGenerators = (values) => {\n  return values.filter(value => typeof value === 'function')\n}\n\n/**\n * Filters the specified list of arbitrary Python values for generators only\n * >>> filterGenerators(['a', 3.14, 5])\n  <generator object <genexpr> at 0x7f9a18e67b50>\n  >>> filterGenerators([1, 2, 3, 'abc', {}, []])\n  <generator object <genexpr> at 0x7f9a18e67b50>\n  */\nconst filterGenerators = (values) => {\n  return values.filter(value => typeof value === 'function')\n}\n\n/**\n * Filters the specified list of arbitrary Python values for generators only\n * >>> filterGenerators(['a', 3.14, 5])\n  <generator object <genexpr> at 0x7f9a18e67b50>\n  >>> filterGenerators([1, 2, 3, 'abc', {}, []])\n  <generator object <genexpr> at 0x7f9a18e67b50>\n  */\nconst filterGenerators = (values) => {\n  return values.filter(value => typeof value === 'function')\n}\n\n/**\n * Filters the specified list of arbitrary Python values for generators only\n * >>> filterGenerators(['a', 3.14, 5])\n  <generator object <genexpr> at 0x7f9a18e67b50>\n  >>> filterGenerators([1, 2, 3, 'abc', {}, []])\n  <generator object <genexpr> at 0x7f9a18e67b50>\n  */\nconst filterGenerators = (values) => {\n  return values.filter(value => typeof value === 'function')\n}\n\n/**\n * Filters the specified list of arbitrary Python values for generators only\n * >>> filterGenerators(['a', 3.14, 5])\n  <generator object <genexpr> at 0x7f9a18e67b50>\n  >>> filterGenerators([1, 2, 3, 'abc', {}, []])\n  <generator object <genexpr> at 0x7f9a18e67b50>\n  */\nconst filterGenerators = (values) => {\n  return values.filter(value => typeof value === 'function')\n}\n\n/**\n * Filters the specified list of arbitrary Python values for generators only\n * >>> filterGenerators(['a', 3.14, 5])\n  <generator object <genexpr> at 0x7f9a18e67b50>\n  >>> filterGenerators([1, 2, 3, 'abc', {}, []])\n  <generator object <genexpr> at 0x7f9a18e67b50>\n  */\nconst filterGenerators = (values) => {\n  return values.filter(value => typeof value === 'function')\n}\n\n/**\n * Filters the specified list of arbitrary Python values for generators only\n * >>> filterGenerators(['a', 3.14, 5])\n  <generator object <genexpr> at 0x7f9a18e67b50>\n  >>> filterGenerators([1, 2, 3, 'abc', {}, []])\n  <generator object <genexpr> at 0x7f9a18e67b50>\n  */", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/23", "prompt": "/* Returns the length of the given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Returns the length of the given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length\n}\n\n/**\n * Returns the number of characters in the given string\n * >>> strlen('abc')\n  3\n  */\nconst strlenWithoutLast = (string) => {\n  return string.length - 1\n}\n\n/**\n * Returns the number of characters in the given string without the last character\n * >>> strlenWithoutLast('abc')\n  3\n  */\nconst strlenWithoutLastWithoutLast = (string) => {\n  return string.length - 1\n}\n\n/**\n * Returns the number of characters in the given string without the last character\n * >>> strlenWithoutLastWithoutLast('abc')\n  3\n  */\nconst strlenWithoutLastWithoutLastWithoutLast = (string) => {\n  return string.length - 1\n}\n\n/**\n * Returns the number of characters in the given string without the last character\n * >>> strlenWithoutLastWithoutLastWithoutLast('abc')\n  3\n  */\nconst strlenWithoutLastWithoutLastWithoutLastWithoutLast = (string) => {\n  return string.length - 1\n}\n\n/**\n * Returns the number of characters in the given string without the last character\n * >>> strlenWithoutLastWithoutLastWithoutLastWithoutLast('abc')\n  3\n  */\nconst strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast = (string) => {\n  return string.length - 1\n}\n\n/**\n * Returns the number of characters in the given string without the last character\n * >>> strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast('abc')\n  3\n  */\nconst strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast = (string) => {\n  return string.length - 1\n}\n\n/**\n * Returns the number of characters in the given string without the last character\n * >>> strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast('abc')\n  3\n  */\nconst strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast = (string) => {\n  return string.length - 1\n}\n\n/**\n * Returns the number of characters in the given string without the last character\n * >>> strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast('abc')\n  3\n  */\nconst strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast = (string) => {\n  return string.length - 1\n}\n\n/**\n * Returns the number of characters in the given string without the last character\n * >>> strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast('abc')\n  3\n  */\nconst strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast = (string) => {\n  return string.length - 1\n}\n\n/**\n * Returns the number of characters in the given string without the last character\n * >>> strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast('abc')\n  3\n  */\nconst strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast = (string) => {\n  return string.length - 1\n}\n\n/**\n * Returns the number of characters in the given string without the last character\n * >>> strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast('abc')\n  3\n  */\nconst strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast = (string) => {\n  return string.length - 1\n}\n\n/**\n * Returns the number of characters in the given string without the last character\n * >>> strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast('abc')\n  3\n  */\nconst strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast = (string) => {\n  return string.length - 1\n}\n\n/**\n * Returns the number of characters in the given string without the last character\n * >>> strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast('abc')\n  3\n  */\nconst strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast = (string) => {\n  return string.length - 1\n}\n\n/**\n * Returns the number of characters in the given string without the last character\n * >>> strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast('abc')\n  3\n  */\nconst strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast = (string) => {\n  return string.length - 1\n}\n\n/**\n * Returns the number of characters in the given string without the last character\n * >>> strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast('abc')\n  3\n  */\nconst strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast = (string) => {\n  return string.length - 1\n}\n\n/**\n * Returns the number of characters in the given string without the last character\n * >>> strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast('abc')\n  3\n  */\nconst strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast = (string) => {\n  return string.length - 1\n}\n\n/**\n * Returns the number of characters in the given string without the last character\n * >>> strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast('abc')\n  3\n  */\nconst strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast = (string) => {\n  return string.length - 1\n}\n\n/**\n * Returns the number of characters in the given string without the last character\n * >>> strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast('abc')\n  3\n  */\nconst strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast = (string) => {\n  return string.length - 1\n}\n\n/**\n * Returns the number of characters in the given string without the last character\n * >>> strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast('abc')\n  3\n  */\nconst strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast = (string) => {\n  return string.length - 1\n}\n\n/**\n * Returns the number of characters in the given string without the last character\n * >>> strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast('abc')\n  3\n  */\nconst strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast = (string) => {\n  return string.length - 1\n}\n\n/**\n * Returns the number of characters in the given string without the last character\n * >>> strlenWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLastWithoutLast('abc')\n  3\n  */\nconst strlenWithoutLastWithoutLastWithoutLastWithoutLast", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/24", "prompt": "/* Find for a given number n the largest number dividing n equally, less than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Find for a given number n the largest number dividing n equally, less than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let divisor = 1;\n  while (n % divisor === 0) {\n    divisor++;\n  }\n  return divisor;\n};\n\n/**\n * Given a number n, return true if n is a prime number.\n * If n is divisible by 2, return false.\n * If n is divisible by 3, return true.\n * If n is divisible by 5, return true.\n * If n is divisible by 6, return true.\n * If n is divisible by 7, return true.\n * If n is divisible by 8, return true.\n * If n is divisible by 10, return true.\n * If n is divisible by 11, return true.\n * If n is divisible by 12, return true.\n * If n is divisible by 13, return true.\n * If n is divisible by 14, return true.\n * If n is divisible by 15, return true.\n * If n is divisible by 16, return true.\n * If n is divisible by 17, return true.\n * If n is divisible by 18, return true.\n * If n is divisible by 19, return true.\n * If n is divisible by 20, return true.\n * If n is divisible by 21, return true.\n * If n is divisible by 22, return true.\n * If n is divisible by 23, return true.\n * If n is divisible by 24, return true.\n * If n is divisible by 25, return true.\n * If n is divisible by 26, return true.\n * If n is divisible by 27, return true.\n * If n is divisible by 28, return true.\n * If n is divisible by 29, return true.\n * If n is divisible by 30, return true.\n * If n is divisible by 31, return true.\n * If n is divisible by 32, return true.\n * If n is divisible by 33, return true.\n * If n is divisible by 34, return true.\n * If n is divisible by 35, return true.\n * If n is divisible by 36, return true.\n * If n is divisible by 37, return true.\n * If n is divisible by 38, return true.\n * If n is divisible by 39, return true.\n * If n is divisible by 40, return true.\n * If n is divisible by 41, return true.\n * If n is divisible by 42, return true.\n * If n is divisible by 43, return true.\n * If n is divisible by 44, return true.\n * If n is divisible by 45, return true.\n * If n is divisible by 46, return true.\n * If n is divisible by 47, return true.\n * If n is divisible by 48, return true.\n * If n is divisible by 49, return true.\n * If n is divisible by 50, return true.\n * If n is divisible by 51, return true.\n * If n is divisible by 52, return true.\n * If n is divisible by 53, return true.\n * If n is divisible by 54, return true.\n * If n is divisible by 55, return true.\n * If n is divisible by 56, return true.\n * If n is divisible by 57, return true.\n * If n is divisible by 58, return true.\n * If n is divisible by 59, return true.\n * If n is divisible by 60, return true.\n * If n is divisible by 61, return true.\n * If n is divisible by 62, return true.\n * If n is divisible by 63, return true.\n * If n is divisible by 64, return true.\n * If n is divisible by 65, return true.\n * If n is divisible by 66, return true.\n * If n is divisible by 67, return true.\n * If n is divisible by 68, return true.\n * If n is divisible by 69, return true.\n * If n is divisible by 70, return true.\n * If n is divisible by 71, return true.\n * If n is divisible by 72, return true.\n * If n is divisible by 73, return true.\n * If n is divisible by 74, return true.\n * If n is divisible by 75, return true.\n * If n is divisible by 76, return true.\n * If n is divisible by 77, return true.\n * If n is divisible by 78, return true.\n * If n is divisible by 79, return true.\n * If n is divisible by 80, return true.\n * If n is divisible by 81, return true.\n * If n is divisible by 82, return true.\n * If n is divisible by 83, return true.\n * If n is divisible by 84, return true.\n * If n is divisible by 85, return true.\n * If n is divisible by 86, return true.\n * If n is divisible by 87, return true.\n * If n is divisible by 88, return true.\n * If n is divisible by 89, return true.\n * If n is divisible by 90, return true.\n * If n is divisible by 91, return true.\n * If n is divisible by 92, return true.\n * If n is divisible by 93, return true.\n * If n is divisible by 94, return true.\n * If n is divisible by 95, return true.\n * If n is divisible by 96, return true.\n * If n is divisible by 97, return true.\n * If n is divisible by 98, return true.\n * If n is divisible by 99, return true.\n * If n is divisible by 100, return true.\n * If n is divisible by 101, return true.\n * If n is divisible by 102, return true.\n * If n is divisible by 103, return true.\n * If n is divisible by 104, return true.\n * If n is divisible by 105, return true.\n * If n is divisible by 106, return true.\n * If n is divisible by 107, return true.\n * If n is divisible by 108, return true.\n * If n is divisible by 109, return true.\n * If n is divisible by 110, return true.\n * If n is divisible by 111, return true.\n * If n is divisible by 112, return true.\n * If n is divisible by 113, return true.\n * If n is divisible by 114, return true.\n * If n is divisible by 115, return true.\n * If n is divisible by 116, return true.\n * If n is divisible by 117, return true.\n * If n is divisible by 118, return true.\n * If n is divisible by 119, return true.\n * If n is divisible by 120, return true.\n * If n is divisible ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/25", "prompt": "/* Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  factors.push(factor);\n  return factors;\n};\n\n/**\n * Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  factors.push(factor);\n  return factors;\n};\n\n/**\n * Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  factors.push(factor);\n  return factors;\n};\n\n/**\n * Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  factors.push(factor);\n  return factors;\n};\n\n/**\n * Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  factors.push(factor);\n  return factors;\n};\n\n/**\n * Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  factors.push(factor);\n  return factors;\n};\n\n/**\n * Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  factors.push(factor);\n  return factors;\n};\n\n/**\n * Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  factors.push(factor);\n  return factors;\n};\n\n/**\n * Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  factors.push(factor);\n  return factors;\n};\n\n/**\n * Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  factors.push(factor);\n  return factors;\n};\n\n/**\n * Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  factors.push(factor);\n  return factors;\n};\n\n/**\n * Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  factors.push(factor);\n  return factors;\n};\n\n/**\n * Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  factors.push(factor);\n  return factors;\n};\n\n/**\n * ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/26", "prompt": "/* Remove from a list of integers all elements that occur more than once, and leave the order of the elements the same as when you entered them.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Remove from a list of integers all elements that occur more than once, and leave the order of the elements the same as when you entered them.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    let number = numbers[i];\n    if (seen[number]) {\n      result.push(number);\n    } else {\n      seen[number] = true;\n      result.push(number);\n    }\n  }\n  return result;\n};\n\n/**\n * Given an array of integers, return an array that contains the unique elements of the array.\n * If there are multiple occurrences of the same element, only the first occurrence will be kept.\n * If there are multiple occurrences of the same element in the array, all occurrences will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same element in the array and there are duplicates, only the duplicate will be kept.\n * If there are multiple occurrences of the same ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/27", "prompt": "/* Flip lowercase letters to uppercase letters and uppercase letters to lowercase letters.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Flip lowercase letters to uppercase letters and uppercase letters to lowercase letters.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.toLowerCase().split('')\n   .map((letter) => letter.match(/[A-Z]/g)? letter.toUpperCase() : letter)\n   .join('');\n};\n\n/**\n * Converts a string to lowercase letters.\n * If a string contains only lowercase letters, it returns it unchanged.\n * If a string contains only uppercase letters, it returns it unchanged.\n * If a string contains both uppercase and lowercase letters, it returns it unchanged.\n * If a string contains only digits, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If a string contains only special characters, it returns it unchanged.\n * If ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/28", "prompt": "/* Merge List of Strings into a Single String\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Merge List of Strings into a Single String\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, curr, index) => {\n    return acc.concat(curr? curr : '');\n  }, '');\n};\n\n/* Convert Object to String\n  >>> toString({ a: 1, b: 2 })\n  '[object Object]'\n  */\nconst toString = (obj) => {\n  return Object.prototype.toString.call(obj);\n};\n\n/* Convert Array to String\n  >>> toString([])\n  '[]'\n  */\nconst toString = (arr) => {\n  return Object.prototype.toString.call(arr);\n};\n\n/* Convert Boolean to String\n  >>> toString(true)\n  'true'\n  */\nconst toString = (bool) => {\n  return bool? 'true' : 'false';\n};\n\n/* Convert Number to String\n  >>> toString(42)\n  '42'\n  */\nconst toString = (num) => {\n  return Object.prototype.toString.call(num);\n};\n\n/* Convert Date to String\n  >>> toString(new Date())\n  '[object Date]'\n  */\nconst toString = (date) => {\n  return Object.prototype.toString.call(date);\n};\n\n/* Convert RegExp to String\n  >>> toString(/a/)\n  '/a/'\n  */\nconst toString = (reg) => {\n  return Object.prototype.toString.call(reg);\n};\n\n/* Convert Function to String\n  >>> toString(function() {})\n  '[object Function]'\n  */\nconst toString = (func) => {\n  return Object.prototype.toString.call(func);\n};\n\n/* Convert Array to JSON\n  >>> toJSON([])\n  []\n  */\nconst toJSON = (arr) => {\n  return JSON.stringify(arr);\n};\n\n/* Convert Object to JSON\n  >>> toJSON({ a: 1 })\n  {\"a\":1}\n  */\nconst toJSON = (obj) => {\n  return JSON.stringify(obj);\n};\n\n/* Convert String to JSON\n  >>> toJSON('a')\n  'a'\n  */\nconst toJSON = (str) => {\n  return JSON.parse(str);\n};\n\n/* Convert Array to JSON\n  >>> toJSON([])\n  []\n  */\nconst toJSON = (arr) => {\n  return JSON.stringify(arr);\n};\n\n/* Convert Object to JSON\n  >>> toJSON({ a: 1 })\n  {\"a\":1}\n  */\nconst toJSON = (obj) => {\n  return JSON.stringify(obj);\n};\n\n/* Convert String to JSON\n  >>> toJSON('a')\n  'a'\n  */\nconst toJSON = (str) => {\n  return JSON.parse(str);\n};\n\n/* Convert Array to JSON\n  >>> toJSON([])\n  []\n  */\nconst toJSON = (arr) => {\n  return JSON.stringify(arr);\n};\n\n/* Convert Object to JSON\n  >>> toJSON({ a: 1 })\n  {\"a\":1}\n  */\nconst toJSON = (obj) => {\n  return JSON.stringify(obj);\n};\n\n/* Convert String to JSON\n  >>> toJSON('a')\n  'a'\n  */\nconst toJSON = (str) => {\n  return JSON.parse(str);\n};\n\n/* Convert Array to JSON\n  >>> toJSON([])\n  []\n  */\nconst toJSON = (arr) => {\n  return JSON.stringify(arr);\n};\n\n/* Convert Object to JSON\n  >>> toJSON({ a: 1 })\n  {\"a\":1}\n  */\nconst toJSON = (obj) => {\n  return JSON.stringify(obj);\n};\n\n/* Convert String to JSON\n  >>> toJSON('a')\n  'a'\n  */\nconst toJSON = (str) => {\n  return JSON.parse(str);\n};\n\n/* Convert Array to JSON\n  >>> toJSON([])\n  []\n  */\nconst toJSON = (arr) => {\n  return JSON.stringify(arr);\n};\n\n/* Convert Object to JSON\n  >>> toJSON({ a: 1 })\n  {\"a\":1}\n  */\nconst toJSON = (obj) => {\n  return JSON.stringify(obj);\n};\n\n/* Convert String to JSON\n  >>> toJSON('a')\n  'a'\n  */\nconst toJSON = (str) => {\n  return JSON.parse(str);\n};\n\n/* Convert Array to JSON\n  >>> toJSON([])\n  []\n  */\nconst toJSON = (arr) => {\n  return JSON.stringify(arr);\n};\n\n/* Convert Object to JSON\n  >>> toJSON({ a: 1 })\n  {\"a\":1}\n  */\nconst toJSON = (obj) => {\n  return JSON.stringify(obj);\n};\n\n/* Convert String to JSON\n  >>> toJSON('a')\n  'a'\n  */\nconst toJSON = (str) => {\n  return JSON.parse(str);\n};\n\n/* Convert Array to JSON\n  >>> toJSON([])\n  []\n  */\nconst toJSON = (arr) => {\n  return JSON.stringify(arr);\n};\n\n/* Convert Object to JSON\n  >>> toJSON({ a: 1 })\n  {\"a\":1}\n  */\nconst toJSON = (obj) => {\n  return JSON.stringify(obj);\n};\n\n/* Convert String to JSON\n  >>> toJSON('a')\n  'a'\n  */\nconst toJSON = (str) => {\n  return JSON.parse(str);\n};\n\n/* Convert Array to JSON\n  >>> toJSON([])\n  []\n  */\nconst toJSON = (arr) => {\n  return JSON.stringify(arr);\n};\n\n/* Convert Object to JSON\n  >>> toJSON({ a: 1 })\n  {\"a\":1}\n  */\nconst toJSON = (obj) => {\n  return JSON.stringify(obj);\n};\n\n/* Convert String to JSON\n  >>> toJSON('a')\n  'a'\n  */\nconst toJSON = (str) => {\n  return JSON.parse(str);\n};\n\n/* Convert Array to JSON\n  >>> toJSON([])\n  []\n  */\nconst toJSON = (arr) => {\n  return JSON.stringify(arr);\n};\n\n/* Convert Object to JSON\n  >>> toJSON({ a: 1 })\n  {\"a\":1}\n  */\nconst toJSON = (obj) => {\n  return JSON.stringify(obj);\n};\n\n/* Convert String to JSON\n  >>> toJSON('a')\n  'a'\n  */\nconst toJSON = (str) => {\n  return JSON.parse(str);\n};\n\n/* Convert Array to JSON\n  >>> toJSON([])\n  []\n  */\nconst toJSON = (arr) => {\n  return JSON.stringify(arr);\n};\n\n/* Convert Object to JSON\n  >>> toJSON({ a: 1 })\n  {\"a\":1}\n  */\nconst toJSON = (obj) => {\n  return JSON.stringify(obj);\n};\n\n/* Convert String to JSON\n  >>> toJSON('a')\n  'a'\n  */\nconst toJSON = (str) => {\n  return JSON.parse(str);\n};\n\n/* Convert Array to JSON\n  >>> toJSON([])\n  []\n  */\nconst toJSON = (arr) => {\n  return JSON.stringify(arr);\n};\n\n/* Convert Object to JSON\n  >>> toJSON({ a: 1 })\n  {\"a\":1}\n  */\nconst toJSON = (obj) => {\n  return JSON.stringify(obj);\n};\n\n/* Convert String to JSON\n  >>> toJSON('a')\n  'a'\n  */\nconst toJSON = (str) => {\n  return JSON.parse(str);\n};\n\n/* Convert Array to JSON\n  >>> toJSON([])\n  []\n  */\nconst toJSON = (arr) => {\n  return JSON.stringify(arr);\n};\n\n/* Convert Object to JSON\n  >>> toJSON({ a: 1 })\n  {\"a\":1}\n  */\nconst toJSON = (obj) => {\n  return JSON.stringify(obj);\n};\n\n/* Convert String to JSON\n  >>> toJSON('a')\n  'a'\n  */\nconst toJSON = (str) => {\n  return JSON.parse(str);\n};\n\n/* Convert Array to JSON\n  >>> toJSON([])\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list of strings only for strings starting with a certain prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Filter an input list of strings only for strings starting with a certain prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix))\n}\n\n/**\n * Filter an input list of strings only for strings ending with a certain suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array', 'cde']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  return strings.filter(string => string.endsWith(suffix))\n}\n\n/**\n * Filter an input list of strings only for strings containing certain characters.\n  >>> filterByCharacter([], 'a')\n  []\n  >>> filterByCharacter(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array', 'cde']\n  */\nconst filterByCharacter = (string, character) => {\n  return string.filter(string => string.includes(character))\n}\n\n/**\n * Filter an input list of strings only for strings containing certain characters.\n  >>> filterByCharacter([], 'a')\n  []\n  >>> filterByCharacter(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array', 'cde']\n  */\nconst filterByCharacters = (string, characters) => {\n  return string.filter(string => characters.includes(string[0]))\n}\n\n/**\n * Filter an input list of strings only for strings containing certain characters.\n  >>> filterByCharacters([], 'a')\n  []\n  >>> filterByCharacters(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array', 'cde']\n  */\nconst filterByCharactersAndCharacters = (string, characters) => {\n  return string.filter(string => characters.includes(string[0]) && characters.includes(string[1]))\n}\n\n/**\n * Filter an input list of strings only for strings containing certain characters.\n  >>> filterByCharactersAndCharacters([], 'a')\n  []\n  >>> filterByCharactersAndCharacters(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array', 'cde']\n  */\nconst filterByCharactersAndCharactersAndCharacters = (string, characters) => {\n  return string.filter(string => characters.includes(string[0]) && characters.includes(string[1]) && characters.includes(string[2]))\n}\n\n/**\n * Filter an input list of strings only for strings containing certain characters.\n  >>> filterByCharactersAndCharactersAndCharacters([], 'a')\n  []\n  >>> filterByCharactersAndCharactersAndCharacters(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array', 'cde']\n  */\nconst filterByCharactersAndCharactersAndCharactersAndCharacters = (string, characters) => {\n  return string.filter(string => characters.includes(string[0]) && characters.includes(string[1]) && characters.includes(string[2]) && characters.includes(string[3]))\n}\n\n/**\n * Filter an input list of strings only for strings containing certain characters.\n  >>> filterByCharactersAndCharactersAndCharactersAndCharacters([], 'a')\n  []\n  >>> filterByCharactersAndCharactersAndCharactersAndCharactersAndCharacters(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array', 'cde']\n  */\nconst filterByCharactersAndCharactersAndCharactersAndCharactersAndCharacters = (string, characters) => {\n  return string.filter(string => characters.includes(string[0]) && characters.includes(string[1]) && characters.includes(string[2]) && characters.includes(string[3]) && characters.includes(string[4]))\n}\n\n/**\n * Filter an input list of strings only for strings containing certain characters.\n  >>> filterByCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharacters([], 'a')\n  []\n  >>> filterByCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharactersAndCharact", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/3", "prompt": "/* You will be given a list of deposits and withdrawals into a bank account, starting with an account balance of zero. Your task is to determine if the account balance drops below zero at any point, and at that point the function should be correct again, otherwise it should be incorrect.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* You will be given a list of deposits and withdrawals into a bank account, starting with an account balance of zero. Your task is to determine if the account balance drops below zero at any point, and at that point the function should be correct again, otherwise it should be incorrect.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance <= 0;\n};\n\nmodule.exports = belowZero;\n\n},{}],3:[function(require,module,exports){\n// https://d3js.org/d3-array/ Version 1.0.3. Copyright 2017 Mike Bostock.\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module!== 'undefined'? factory(exports) :\n\ttypeof define === 'function' && define.amd? define(['exports'], factory) :\n\t(factory((global.d3 = global.d3 || {})));\n}(this, (function (exports) { 'use strict';\n\nvar xhtml = \"http://www.w3.org/1999/xhtml\";\n\nvar namespaces = {\n  svg: \"http://www.w3.org/2000/svg\",\n  xhtml: xhtml,\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\",\n  xmlns: \"http://www.w3.org/2000/xmlns/\"\n};\n\nvar namespace = function(name) {\n  var prefix = name += \"\", i = prefix.indexOf(\":\");\n  if (i >= 0 && (prefix = name.slice(0, i))!== \"xmlns\") name = name.slice(i + 1);\n  return namespaces.hasOwnProperty(prefix)? {space: namespaces[prefix], local: name} : name;\n};\n\nfunction creatorInherit(name) {\n  return function() {\n    var document = this.ownerDocument,\n        uri = this.namespaceURI;\n    return uri === xhtml && document.documentElement.namespaceURI === xhtml\n       ? document.createElement(name)\n        : document.createElementNS(uri, name);\n  };\n}\n\nfunction creatorFixed(fullname) {\n  return function() {\n    return this.ownerDocument.createElementNS(fullname.space, fullname.local);\n  };\n}\n\nvar creator = function(name) {\n  var fullname = namespace(name);\n  return (fullname.local\n     ? creatorFixed\n      : creatorInherit)(fullname);\n};\n\nvar nextId = 0;\n\nfunction local() {\n  return new Local;\n}\n\nfunction Local() {\n  this._ = \"@\" + (++nextId).toString(36);\n}\n\nLocal.prototype = local.prototype = {\n  constructor: Local,\n  get: function(node) {\n    var id = this._;\n    while (!(id in node)) if (!(node = node.parentNode)) return;\n    return node[id];\n  },\n  set: function(node, value) {\n    return node[this._] = value;\n  },\n  remove: function(node) {\n    return this._ in node && delete node[this._];\n  },\n  toString: function() {\n    return this._;\n  }\n};\n\nvar matcher = function(selector) {\n  return function() {\n    return this.matches(selector);\n  };\n};\n\nif (typeof document!== \"undefined\") {\n  var element = document.documentElement;\n  if (!element.matches) {\n    var vendorMatches = element.webkitMatchesSelector\n        || element.msMatchesSelector\n        || element.mozMatchesSelector\n        || element.oMatchesSelector;\n    matcher = function(selector) {\n      return function() {\n        return vendorMatches.call(this, selector);\n      };\n    };\n  }\n}\n\nvar matcher$1 = matcher;\n\nvar filterEvents = {};\n\nexports.event = null;\n\nif (typeof document!== \"undefined\") {\n  var element$1 = document.documentElement;\n  if (!(\"onmouseenter\" in element$1)) {\n    filterEvents = {mouseenter: \"mouseover\", mouseleave: \"mouseout\"};\n  }\n}\n\nfunction filterContextListener(listener, index, group) {\n  listener = contextListener(listener, index, group);\n  return function(event) {\n    var related = event.relatedTarget;\n    if (!related || (related!== this &&!(related.compareDocumentPosition(this) & 8))) {\n      listener.call(this, event);\n    }\n  };\n}\n\nfunction contextListener(listener, index, group) {\n  return function(event1) {\n    var event0 = exports.event; // Events can be reentrant (e.g., focus).\n    exports.event = event1;\n    try {\n      listener.call(this, this.__data__, index, group);\n    } finally {\n      exports.event = event0;\n    }\n  };\n}\n\nfunction parseTypenames(typenames) {\n  return typenames.trim().split(/^|\\s+/).map(function(t) {\n    var name = \"\", i = t.indexOf(\".\");\n    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);\n    return {type: t, name: name};\n  });\n}\n\nfunction onRemove(typename) {\n  return function() {\n    var on = this.__on;\n    if (!on) return;\n    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {\n      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {\n        this.removeEventListener(o.type, o.listener, o.capture);\n      } else {\n        on[++i] = o;\n      }\n    }\n    if (++i) on.length = i;\n    else delete this.__on;\n  };\n}\n\nfunction onAdd(typename, value, capture) {\n  var wrap = filterEvents.hasOwnProperty(typename.type)? filterContextListener : contextListener;\n  return function(d, i, group) {\n    var on = this.__on, o, listener = wrap(value, i, group);\n    if (on) for (var j = 0, m = on.length; j < m; ++j) {\n      if ((o = on[j]).type === typename.type && o.name === typename.name) {\n        this.removeEventListener(o.type, o.listener, o.capture);\n        this.addEventListener(o.type, o.listener = listener, o.capture = capture);\n        o.value = value;\n        return;\n      }\n    }\n    this.addEventListener(typename.type, listener, capture);\n    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};\n    if (!on) this.__on = [o];\n    else on.push(o);\n  };\n}\n\nvar selection_on = function(typename, value, capture) {\n  var typenames = parseTypenames(typename + \"\"), i, n = typenames.length, t;\n\n  if (arguments.length < 2) {\n    var on = this.node().__on;\n    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {\n      for (i = 0, o = on[j]; i < n; ++i) {\n        if ((t = typenames[i]).type === o.type && t.name === o.name) {\n          return o.value;\n        }\n      }\n    }\n    return;\n  }\n\n  on = value? onAdd : onRemove;\n  if (capture == null) capture = false;\n  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));\n  return this;\n};\n\nfunction customEvent(event1, listener, that, args) {\n  var event0 = exports.event;\n  event1.sourceEvent = exports.event;\n  exports.event = event1;\n  try {\n    return listener.apply(that, args);\n  } finally {\n    exports.event = event0;\n  }\n}\n\nvar sourceEvent = function() {\n  var current = exports.event, source;\n  while (source = current.sourceEvent) current = source;\n  return current;\n};\n\nvar point = function(node, event) {\n  var svg = node.ownerSVGElement || node;\n\n  if (svg.createSVGPoint) {\n    var point = svg.createSVGPoint();\n    if (point.x == null || point.y == null) point.x = svg.createSVGPoint().x;\n    if (point.x == null || point.y == null) point.y = svg.createSVGPoint().y;\n    point = point.matrixTransform(node.getScreenCTM().inverse());\n    return [point.x, point.y];\n  }\n\n  var rect = node.getBoundingClientRect();\n  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];\n};\n\nvar mouse = function(node) {\n  var event = sourceEvent();\n  if (event.changed", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/30", "prompt": "/*RThe list contains only positive numbers.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*RThe list contains only positive numbers.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/**\n  Returns the sum of the numbers in the list.\n  >>> getSum([-1, 2, -4, 5, 6])\n  15\n  >>> getSum([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  30\n  */\nconst getSum = (l) => {\n  return l.reduce((acc, n) => acc + n, 0)\n}\n\n/**\n  Returns the difference of the numbers in the list.\n  >>> getDiff([-1, 2, -4, 5, 6])\n  1\n  >>> getDiff([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -1\n  */\nconst getDiff = (l) => {\n  return l.filter(n => n < 0).reduce((acc, n) => acc + n, 0)\n}\n\n/**\n  Returns the product of the numbers in the list.\n  >>> getProd((-1, 2, -4, 5, 6))\n  6\n  >>> getProd((5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n  24\n  */\nconst getProd = (l) => {\n  return l.map(n => n * n).reduce((acc, n) => acc + n, 1)\n}\n\n/**\n  Returns the product of the numbers in the list using recursion.\n  >>> getProdRecursive((-1, 2, -4, 5, 6))\n  6\n  >>> getProdRecursive((5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n  24\n  */\nconst getProdRecursive = (l) => {\n  if (l.length === 0) return 1\n  return l.reduce((acc, n) => acc + n * getProdRecursive(l), 1)\n}\n\n/**\n  Returns the product of the numbers in the list using recursion.\n  >>> getProdRecursive((-1, 2, -4, 5, 6))\n  6\n  >>> getProdRecursive((5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n  24\n  */\nconst getProdRecursive = (l) => {\n  if (l.length === 0) return 1\n  return l.reduce((acc, n) => acc + n * getProdRecursive(l), 1)\n}\n\n/**\n  Returns the product of the numbers in the list using recursion.\n  >>> getProdRecursive((-1, 2, -4, 5, 6))\n  6\n  >>> getProdRecursive((5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n  24\n  */\nconst getProdRecursive = (l) => {\n  if (l.length === 0) return 1\n  return l.reduce((acc, n) => acc + n * getProdRecursive(l), 1)\n}\n\n/**\n  Returns the product of the numbers in the list using recursion.\n  >>> getProdRecursive((-1, 2, -4, 5, 6))\n  6\n  >>> getProdRecursive((5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n  24\n  */\nconst getProdRecursive = (l) => {\n  if (l.length === 0) return 1\n  return l.reduce((acc, n) => acc + n * getProdRecursive(l), 1)\n}\n\n/**\n  Returns the product of the numbers in the list using recursion.\n  >>> getProdRecursive((-1, 2, -4, 5, 6))\n  6\n  >>> getProdRecursive((5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n  24\n  */\nconst getProdRecursive = (l) => {\n  if (l.length === 0) return 1\n  return l.reduce((acc, n) => acc + n * getProdRecursive(l), 1)\n}\n\n/**\n  Returns the product of the numbers in the list using recursion.\n  >>> getProdRecursive((-1, 2, -4, 5, 6))\n  6\n  >>> getProdRecursive((5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n  24\n  */\nconst getProdRecursive = (l) => {\n  if (l.length === 0) return 1\n  return l.reduce((acc, n) => acc + n * getProdRecursive(l), 1)\n}\n\n/**\n  Returns the product of the numbers in the list using recursion.\n  >>> getProdRecursive((-1, 2, -4, 5, 6))\n  6\n  >>> getProdRecursive((5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n  24\n  */\nconst getProdRecursive = (l) => {\n  if (l.length === 0) return 1\n  return l.reduce((acc, n) => acc + n * getProdRecursive(l), 1)\n}\n\n/**\n  Returns the product of the numbers in the list using recursion.\n  >>> getProdRecursive((-1, 2, -4, 5, 6))\n  6\n  >>> getProdRecursive((5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n  24\n  */\nconst getProdRecursive = (l) => {\n  if (l.length === 0) return 1\n  return l.reduce((acc, n) => acc + n * getProdRecursive(l), 1)\n}\n\n/**\n  Returns the product of the numbers in the list using recursion.\n  >>> getProdRecursive((-1, 2, -4, 5, 6))\n  6\n  >>> getProdRecursive((5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n  24\n  */\nconst getProdRecursive = (l) => {\n  if (l.length === 0) return 1\n  return l.reduce((acc, n) => acc + n * getProdRecursive(l), 1)\n}\n\n/**\n  Returns the product of the numbers in the list using recursion.\n  >>> getProdRecursive((-1, 2, -4, 5, 6))\n  6\n  >>> getProdRecursive((5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n  24\n  */\nconst getProdRecursive = (l) => {\n  if (l.length === 0) return 1\n  return l.reduce((acc, n) => acc + n * getProdRecursive(l), 1)\n}\n\n/**\n  Returns the product of the numbers in the list using recursion.\n  >>> getProdRecursive((-1, 2, -4, 5, 6))\n  6\n  >>> getProdRecursive((5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n  24\n  */\nconst getProdRecursive = (l) => {\n  if (l.length === 0) return 1\n  return l.reduce((acc, n) => acc + n * getProdRecursive(l), 1)\n}\n\n/**\n  Returns the product of the numbers in the list using recursion.\n  >>> getProdRecursive((-1, 2, -4, 5, 6))\n  6\n  >>> getProdRecursive((5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n  24\n  */\nconst getProdRecursive = (l) => {\n  if (l.length === 0) return 1\n  return l.reduce((acc, n) => acc + n * getProdRecursive(l), 1)\n}\n\n/**\n  Returns the product of the numbers in the list using recursion.\n  >>> getProdRecursive((-1, 2, -4, 5, 6))\n  6\n  >>> getProdRecursive((5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n  24\n  */\nconst getProdRecursive = (l) => {\n  if (l.length === 0) return 1\n  return l.reduce((acc, n) => acc + n * getProdRecursive(l", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/31", "prompt": "/*Return true if a given number is a prime number and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Return true if a given number is a prime number and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * A function to generate random numbers between a minimum and a maximum.\n * \n * Parameters:\n * \n * min - minimum number\n * max - maximum number\n * \n * Returns:\n * \n * random number\n */\nconst random = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * A function to generate random numbers between a minimum and a maximum.\n * \n * Parameters:\n * \n * min - minimum number\n * max - maximum number\n * \n * Returns:\n * \n * random number\n */\nconst randomBetween = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * A function to generate random numbers between a minimum and a maximum.\n * \n * Parameters:\n * \n * min - minimum number\n * max - maximum number\n * \n * Returns:\n * \n * random number\n */\nconst randomInRange = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * A function to generate random numbers between a minimum and a maximum.\n * \n * Parameters:\n * \n * min - minimum number\n * max - maximum number\n * \n * Returns:\n * \n * random number\n */\nconst randomInRangeBetween = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * A function to generate random numbers between a minimum and a maximum.\n * \n * Parameters:\n * \n * min - minimum number\n * max - maximum number\n * \n * Returns:\n * \n * random number\n */\nconst randomInRangeInRange = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * A function to generate random numbers between a minimum and a maximum.\n * \n * Parameters:\n * \n * min - minimum number\n * max - maximum number\n * \n * Returns:\n * \n * random number\n */\nconst randomInRangeInRangeBetween = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * A function to generate random numbers between a minimum and a maximum.\n * \n * Parameters:\n * \n * min - minimum number\n * max - maximum number\n * \n * Returns:\n * \n * random number\n */\nconst randomInRangeInRangeInRange = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * A function to generate random numbers between a minimum and a maximum.\n * \n * Parameters:\n * \n * min - minimum number\n * max - maximum number\n * \n * Returns:\n * \n * random number\n */\nconst randomInRangeInRangeInRangeBetween = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * A function to generate random numbers between a minimum and a maximum.\n * \n * Parameters:\n * \n * min - minimum number\n * max - maximum number\n * \n * Returns:\n * \n * random number\n */\nconst randomInRangeInRangeInRangeInRange = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * A function to generate random numbers between a minimum and a maximum.\n * \n * Parameters:\n * \n * min - minimum number\n * max - maximum number\n * \n * Returns:\n * \n * random number\n */\nconst randomInRangeInRangeInRangeBetween = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * A function to generate random numbers between a minimum and a maximum.\n * \n * Parameters:\n * \n * min - minimum number\n * max - maximum number\n * \n * Returns:\n * \n * random number\n */\nconst randomInRangeInRangeInRangeInRangeBetween = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * A function to generate random numbers between a minimum and a maximum.\n * \n * Parameters:\n * \n * min - minimum number\n * max - maximum number\n * \n * Returns:\n * \n * random number\n */\nconst randomInRangeInRangeInRangeInRangeBetween = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * A function to generate random numbers between a minimum and a maximum.\n * \n * Parameters:\n * \n * min - minimum number\n * max - maximum number\n * \n * Returns:\n * \n * random number\n */\nconst randomInRangeInRangeInRangeInRangeInRange = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * A function to generate random numbers between a minimum and a maximum.\n * \n * Parameters:\n * \n * min - minimum number\n * max - maximum number\n * \n * Returns:\n * \n * random number\n */\nconst randomInRangeInRangeInRangeInRangeBetween = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * A function to generate random numbers between a minimum and a maximum.\n * \n * Parameters:\n * \n * min - minimum number\n * max - maximum number\n * \n * Returns:\n * \n * random number\n */\nconst randomInRangeInRangeInRangeInRangeInRangeBetween = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * A function to generate random numbers between a minimum and a maximum.\n * \n * Parameters:\n * \n * min - minimum number\n * max - maximum number\n * \n * Returns:\n * \n * random number\n */\nconst randomInRangeInRangeInRangeInRangeInRangeInRange = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * A function to generate random numbers between a minimum and a maximum.\n * \n * Parameters:\n * \n * min - minimum number\n * max - maximum number\n * \n * Returns:\n * \n * random number\n */\nconst randomInRangeInRangeInRangeInRangeInRangeBetween = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * A function to generate random numbers between a minimum and a maximum.\n * \n * Parameters:\n * \n * min - minimum number\n * max - maximum number\n * \n * Returns:\n * \n * random number\n */\nconst randomInRangeInRangeInRangeInRangeInRangeInRangeBetween = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * A function to generate random numbers between a minimum and a maximum.\n * \n * Parameters:\n * \n * min - minimum number\n * max - maximum number\n * \n * Returns:\n * \n * random number\n */\nconst randomInRangeIn", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let x = xs[0];\n  let prev = 0;\n  let prevIndex = 0;\n  let prevValue = 0;\n  let prevValueIndex = 0;\n  let prevValueValue = 0;\n  let prevValueValueIndex = 0;\n  let prevValueValueValue = 0;\n  let prevValueValueValueIndex = 0;\n  let prevValueValueValueValue = 0;\n  let prevValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValueIndex = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValueValueValueValue = 0;\n  let prevValueValueValueValueValue", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/33", "prompt": "/*Tits function takes a list l and returns a list l'so that l' is identical to l in indices that are not divisible by three, while its values for indices divisible by three correspond to the values of the corresponding indices of l but are sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Tits function takes a list l and returns a list l'so that l' is identical to l in indices that are not divisible by three, while its values for indices divisible by three correspond to the values of the corresponding indices of l but are sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const thirds = [3, 3];\n  const thirdIndexes = [0, 2];\n  const thirdValues = [3, 3];\n  const thirdIndexesValues = [0, 2];\n  const thirdValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdValuesIndicesValuesIndicesValuesIndicesValuesIndicesValues = [0, 2];\n  const thirdIndexesValuesIndicesValuesIndicesValuesIndicesValuesIndicesValue", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[l[i]]) {\n      seen[l[i]] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique items in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique items in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique items in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique items in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique items in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique items in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique items in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique items in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique items in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique items in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique items in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique items in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique items in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique items in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique items in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique items in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique items in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique items in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/35", "prompt": "/*Rreturns the maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Rreturns the maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  return l.length > 0? l[l.length - 1] : undefined;\n};\n\n/*\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElements = (l) => {\n  return l.length > 0? maxElement(l) : undefined;\n};\n\n/*\n  >>> maxElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementsOf = (l) => {\n  return l.length > 0? maxElements(l) : undefined;\n};\n\n/*\n  >>> maxElementsOf([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementsOfs = (l) => {\n  return l.length > 0? maxElementsOf(l) : undefined;\n};\n\n/*\n  >>> maxElementsOfs([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementsOfss = (l) => {\n  return l.length > 0? maxElementsOfs(l) : undefined;\n};\n\n/*\n  >>> maxElementsOfss([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementsOfsss = (l) => {\n  return l.length > 0? maxElementsOfsss(l) : undefined;\n};\n\n/*\n  >>> maxElementsOfsss([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementsOfsssss = (l) => {\n  return l.length > 0? maxElementsOfsssss(l) : undefined;\n};\n\n/*\n  >>> maxElementsOfsssss([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementsOfsssssss = (l) => {\n  return l.length > 0? maxElementsOfsssssss(l) : undefined;\n};\n\n/*\n  >>> maxElementsOfsssssss([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementsOfsssssssss = (l) => {\n  return l.length > 0? maxElementsOfsssssssss(l) : undefined;\n};\n\n/*\n  >>> maxElementsOfsssssssss([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementsOfsssssssssss = (l) => {\n  return l.length > 0? maxElementsOfsssssssssss(l) : undefined;\n};\n\n/*\n  >>> maxElementsOfsssssssssss([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementsOfsssssssssssss = (l) => {\n  return l.length > 0? maxElementsOfsssssssssssss(l) : undefined;\n};\n\n/*\n  >>> maxElementsOfsssssssssssss([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementsOfsssssssssssssssss = (l) => {\n  return l.length > 0? maxElementsOfsssssssssssssssss(l) : undefined;\n};\n\n/*\n  >>> maxElementsOfsssssssssssssssss([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementsOfsssssssssssssssssss = (l) => {\n  return l.length > 0? maxElementsOfsssssssssssssssssss(l) : undefined;\n};\n\n/*\n  >>> maxElementsOfsssssssssssssssssssss([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementsOfsssssssssssssssssssssss = (l) => {\n  return l.length > 0? maxElementsOfsssssssssssssssssssss(l) : undefined;\n};\n\n/*\n  >>> maxElementsOfsssssssssssssssssssssssss([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementsOfsssssssssssssssssssssssss = (l) => {\n  return l.length > 0? maxElementsOfsssssssssssssssssssssssss(l) : undefined;\n};\n\n/*\n  >>> maxElementsOfsssssssssssssssssssssssssss([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementsOfsssssssssssssssssssssssssss = (l) => {\n  return l.length > 0? maxElementsOfsssssssssssssssssssssssss(l) : undefined;\n};\n\n/*\n  >>> maxElementsOfsssssssssssssssssssssssssssss([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementsOfsssssssssssssssssssssssssssssss = (l) => {\n  return l.length > 0? maxElementsOfsssssssssssssssssssssssssss(l) : undefined;\n};\n\n/*\n  >>> maxElementsOfsssssssssssssssssssssssssssss([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementsOfsssssssssssssssssssssssssssss = (l) => {\n  return l.length > 0? maxElementsOfsssssssssssssssssssssssssssss(l) : undefined;\n};\n\n/*\n  >>> maxElementsOfsssssssssssssssssssssssssssssssss([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementsOfsssssssssssssssssssssssssssssssss = (l) => {\n  return l.length > 0? maxElementsOfsssssssssssssssssssssssssssss(l) : undefined;\n};\n\n/*\n  >>> maxElementsOfsssssssssssssssssssssssssssssssssssss([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementsOfsssssssssssssssssssssssssssssssssssssss = (l) => {\n  return l.length > 0? maxElementsOfsssssssssssssssssssssssssssssssss(l) : undefined;\n};\n\n/*\n  >>> maxElementsOfsssssssssssssssssssssssssssssssssssssssssssss([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementsOfssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/36", "prompt": "/*Rindicates how often the digit 7 appears in integers smaller than n, which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Rindicates how often the digit 7 appears in integers smaller than n, which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let digits = n.toString().split('');\n  let result = 0;\n  for (let i = 0; i < digits.length; i++) {\n    if (digits[i] === '7') {\n      result += (digits[i] === digits[i + 1])? (digits[i] === digits[i + 2]? 3 : 1) : 1;\n    } else {\n      result += (digits[i] === digits[i + 1])? 1 : 0;\n    }\n  }\n  return result;\n};\n\n/*\n  >>> fizzBuzz(123)\n  1\n  >>> fizzBuzz(124)\n  2\n  >>> fizzBuzz(125)\n  3\n  >>> fizzBuzz(126)\n  4\n  >>> fizzBuzz(127)\n  5\n  >>> fizzBuzz(128)\n  6\n  >>> fizzBuzz(129)\n  7\n  >>> fizzBuzz(130)\n  8\n  >>> fizzBuzz(131)\n  9\n  >>> fizzBuzz(132)\n  10\n  >>> fizzBuzz(133)\n  11\n  >>> fizzBuzz(134)\n  12\n  >>> fizzBuzz(135)\n  13\n  >>> fizzBuzz(136)\n  14\n  >>> fizzBuzz(137)\n  15\n  >>> fizzBuzz(138)\n  16\n  >>> fizzBuzz(139)\n  17\n  >>> fizzBuzz(140)\n  18\n  >>> fizzBuzz(141)\n  19\n  >>> fizzBuzz(142)\n  20\n  >>> fizzBuzz(143)\n  21\n  >>> fizzBuzz(144)\n  22\n  >>> fizzBuzz(145)\n  23\n  >>> fizzBuzz(146)\n  24\n  >>> fizzBuzz(147)\n  25\n  >>> fizzBuzz(148)\n  26\n  >>> fizzBuzz(149)\n  27\n  >>> fizzBuzz(150)\n  28\n  >>> fizzBuzz(151)\n  29\n  >>> fizzBuzz(152)\n  30\n  >>> fizzBuzz(153)\n  31\n  >>> fizzBuzz(154)\n  32\n  >>> fizzBuzz(155)\n  33\n  >>> fizzBuzz(156)\n  34\n  >>> fizzBuzz(157)\n  35\n  >>> fizzBuzz(158)\n  36\n  >>> fizzBuzz(159)\n  37\n  >>> fizzBuzz(160)\n  38\n  >>> fizzBuzz(161)\n  39\n  >>> fizzBuzz(162)\n  40\n  >>> fizzBuzz(163)\n  41\n  >>> fizzBuzz(164)\n  42\n  >>> fizzBuzz(165)\n  43\n  >>> fizzBuzz(166)\n  44\n  >>> fizzBuzz(167)\n  45\n  >>> fizzBuzz(168)\n  46\n  >>> fizzBuzz(169)\n  47\n  >>> fizzBuzz(170)\n  48\n  >>> fizzBuzz(171)\n  49\n  >>> fizzBuzz(172)\n  50\n  >>> fizzBuzz(173)\n  51\n  >>> fizzBuzz(174)\n  52\n  >>> fizzBuzz(175)\n  53\n  >>> fizzBuzz(176)\n  54\n  >>> fizzBuzz(177)\n  55\n  >>> fizzBuzz(178)\n  56\n  >>> fizzBuzz(179)\n  57\n  >>> fizzBuzz(180)\n  58\n  >>> fizzBuzz(181)\n  59\n  >>> fizzBuzz(182)\n  60\n  >>> fizzBuzz(183)\n  61\n  >>> fizzBuzz(184)\n  62\n  >>> fizzBuzz(185)\n  63\n  >>> fizzBuzz(186)\n  64\n  >>> fizzBuzz(187)\n  65\n  >>> fizzBuzz(188)\n  66\n  >>> fizzBuzz(189)\n  67\n  >>> fizzBuzz(190)\n  68\n  >>> fizzBuzz(191)\n  69\n  >>> fizzBuzz(192)\n  70\n  >>> fizzBuzz(193)\n  71\n  >>> fizzBuzz(194)\n  72\n  >>> fizzBuzz(195)\n  73\n  >>> fizzBuzz(196)\n  74\n  >>> fizzBuzz(197)\n  75\n  >>> fizzBuzz(198)\n  76\n  >>> fizzBuzz(199)\n  77\n  >>> fizzBuzz(200)\n  78\n  >>> fizzBuzz(201)\n  79\n  >>> fizzBuzz(202)\n  80\n  >>> fizzBuzz(203)\n  81\n  >>> fizzBuzz(204)\n  82\n  >>> fizzBuzz(205)\n  83\n  >>> fizzBuzz(206)\n  84\n  >>> fizzBuzz(207)\n  85\n  >>> fizzBuzz(208)\n  86\n  >>> fizzBuzz(209)\n  87\n  >>> fizzBuzz(210)\n  88\n  >>> fizzBuzz(211)\n  89\n  >>> fizzBuzz(212)\n  90\n  >>> fizzBuzz(213)\n  91\n  >>> fizzBuzz(214)\n  92\n  >>> fizzBuzz(215)\n  93\n  >>> fizzBuzz(216)\n  94\n  >>> fizzBuzz(217)\n  95\n  >>> fizzBuzz(218)\n  96\n  >>> fizzBuzz(219)\n  97\n  >>> fizzBuzz(220)\n  98\n  >>> fizzBuzz(221)\n  99\n  >>> fizzBuzz(222)\n  100\n  >>> fizzBuzz(223)\n  101\n  >>> fizzBuzz(224)\n  102\n  >>> fizzBuzz(225)\n  103\n  >>> fizzBuzz(226)\n  104\n  >>> fizzBuzz(227)\n  105\n  >>> fizzBuzz(228)\n  106\n  >>> fizzBuzz(229)\n  107", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/37", "prompt": "/*Tits function takes a list l and returns a list l'so that l' is identical to l in the odd indices, while its values in the even indices correspond to the values of the even indices of l but are sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Tits function takes a list l and returns a list l'so that l' is identical to l in the odd indices, while its values in the even indices correspond to the values of the even indices of l but are sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  return l.sort((a, b) => a % 2 === 1? b : a);\n};\n\n/**\n  Sorts an array in ascending order and returns the sorted array.\n  >>> sortAsc([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortAsc([4, 3, 2, 1])\n  [4, 3, 2, 1]\n  >>> sortA", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(0, 3 * i));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(0, 3 * i));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(0, 3 * i));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupsGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupsGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(0, 3 * i));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupsGroupsGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupsGroupsGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(0, 3 * i));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupsGroupsGroupsGroupsGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupsGroupsGroupsGroupsGroupsGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(0, 3 * i));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroups", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns the n-th number, which is a Fibonacci number, and also a prime number.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  primeFib returns the n-th number, which is a Fibonacci number, and also a prime number.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  if (n <= 3) {\n    return n;\n  }\n  if (n <= 5) {\n    return n;\n  }\n  if (n <= 7) {\n    return n;\n  }\n  if (n <= 9) {\n    return n;\n  }\n  if (n <= 13) {\n    return n;\n  }\n  if (n <= 21) {\n    return n;\n  }\n  if (n <= 89) {\n    return n;\n  }\n  return primeFib(n-2)+primeFib(n-1);\n};\n\n/*\n  primeFactors returns the prime factors of a number.\n  >>> primeFactors(1)\n  [2, 1]\n  >>> primeFactors(2)\n  [2, 3, 1]\n  >>> primeFactors(3)\n  [2, 3, 5, 1]\n  >>> primeFactors(4)\n  [2, 3, 5, 7, 1]\n  >>> primeFactors(5)\n  [2, 3, 5, 7, 11, 1]\n  >>> primeFactors(6)\n  [2, 3, 5, 7, 11, 13, 1]\n  >>> primeFactors(7)\n  [2, 3, 5, 7, 11, 13, 17, 1]\n  >>> primeFactors(8)\n  [2, 3, 5, 7, 11, 13, 17, 19, 1]\n  >>> primeFactors(9)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 1]\n  >>> primeFactors(10)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 1]\n  >>> primeFactors(11)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 37, 1]\n  >>> primeFactors(12)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 37, 71, 1]\n  >>> primeFactors(13)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 37, 71, 101, 1]\n  >>> primeFactors(14)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 37, 71, 101, 139, 1]\n  >>> primeFactors(15)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 37, 71, 101, 139, 193, 1]\n  >>> primeFactors(16)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 37, 71, 101, 139, 193, 257, 1]\n  >>> primeFactors(17)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 37, 71, 101, 139, 193, 257, 295, 1]\n  >>> primeFactors(18)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 37, 71, 101, 139, 193, 257, 295, 377, 1]\n  >>> primeFactors(19)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 37, 71, 101, 139, 193, 257, 295, 377, 717, 1]\n  >>> primeFactors(20)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 37, 71, 101, 139, 193, 257, 295, 377, 717, 1031, 1]\n  >>> primeFactors(21)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 37, 71, 101, 139, 193, 257, 295, 377, 717, 1031, 137, 1]\n  >>> primeFactors(22)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 37, 71, 101, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 1]\n  >>> primeFactors(23)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 37, 71, 101, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 1]\n  >>> primeFactors(24)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 37, 71, 101, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 139, 193, 257, 295, 377, 717, 1031, 137, 131, 13", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate the mean absolute deviation around the mean value of this dataset. The mean absolute deviation is the mean absolute difference between each element and a midpoint (mean in this case): MAD = average | x - x _ mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* For a given list of input numbers, calculate the mean absolute deviation around the mean value of this dataset. The mean absolute deviation is the mean absolute difference between each element and a midpoint (mean in this case): MAD = average | x - x _ mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  let sum = 0;\n  let sumOfSquares = 0;\n  let sumOfSquaredDifferences = 0;\n  let sumOfSquaredDifferenceSquared = 0;\n  let sumOfSquaredDifferenceSquaredDifference = 0;\n  let sumOfSquaredDifferenceSquaredDifferenceSquared = 0;\n  let sumOfSquaredDifferenceSquaredDifferenceSquaredDifference = 0;\n  let sumOfSquaredDifferenceSquaredDifferenceSquaredDifferenceSquared = 0;\n  let sumOfSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifference = 0;\n  let sumOfSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquared = 0;\n  let sumOfSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifference = 0;\n  let sumOfSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquared = 0;\n  let sumOfSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifference = 0;\n  let sumOfSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifference = 0;\n  let sumOfSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifference = 0;\n  let sumOfSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifference = 0;\n  let sumOfSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifference = 0;\n  let sumOfSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifference = 0;\n  let sumOfSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredDifferenceSquaredSquaredDifferenceSquaredDifferenceSquaredSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredSquaredDifferenceSquaredSquaredSquaredDifferenceSquaredSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredDifferenceSquaredSquaredDifferenceSquaredDifferenceSquaredSquaredDifferenceSquaredDifferenceSquaredDifferenceSquaredSquaredDifferenceSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredDifferenceSquaredSquaredDifferenceSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquaredSquaredDifferenceSquared", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes a list of integers as input. It returns true if there are three unique elements in the list that add up to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  triplesSumToZero takes a list of integers as input. It returns true if there are three unique elements in the list that add up to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0) continue;\n    if (l[i] === 1) sum += 1;\n    if (l[i] === 2) sum += 2;\n    if (l[i] === 3) sum += 3;\n    count += 1;\n  }\n  return count === 3;\n};\n\n/**\n  A function that takes an array of integers and returns a list of integers containing all unique triplets.\n\n  >>> uniqueTriplets([1, 3, 5, 7])\n  [\n    1,\n    3,\n    5,\n    7\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [\n    1,\n    2,\n    3,\n    7,\n    8,\n    9\n  ]\n  >>> uniqueTriplets([1, 2, 3, 7, 8, 9])\n  [", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n  let collisions = 0;\n  for (let i = 0; i < n; i++) {\n    if (cars[i].speed > cars[(i + 1) % n].speed) {\n      collisions++;\n    }\n  }\n  return collisions;\n};\n\n/*\n  Given a car object and a set of cars, this function returns true if the\n  cars are colliding and false otherwise.\n\n  A car object has a speed property that represents the speed of the car.\n  A set of cars has a speed property that represents the speed of all the cars.\n*/\nconst carsCollide = (car, cars) => {\n  return car.speed > cars[0].speed && car.speed < cars[cars.length - 1].speed;\n};\n\n/*\n  Given a car object and a set of cars, this function returns true if the\n  cars are colliding and false otherwise.\n\n  A car object has a speed property that represents the speed of the car.\n  A set of cars has a speed property that represents the speed of all the cars.\n*/\nconst carsCollideRight = (car, cars) => {\n  return car.speed > cars[cars.length - 1].speed && car.speed < cars[0].speed;\n};\n\n/*\n  Given a car object and a set of cars, this function returns true if the\n  cars are colliding and false otherwise.\n\n  A car object has a speed property that represents the speed of the car.\n  A set of cars has a speed property that represents the speed of all the cars.\n*/\nconst carsCollideLeft = (car, cars) => {\n  return car.speed > cars[0].speed && car.speed < cars[cars.length - 1].speed;\n};\n\n/*\n  Given a car object and a set of cars, this function returns true if the\n  cars are colliding and false otherwise.\n\n  A car object has a speed property that represents the speed of the car.\n  A set of cars has a speed property that represents the speed of all the cars.\n*/\nconst carsCollideBoth = (car, cars) => {\n  return car.speed > cars[0].speed && car.speed < cars[cars.length - 1].speed;\n};\n\n/*\n  Given a car object and a set of cars, this function returns true if the\n  cars are colliding and false otherwise.\n\n  A car object has a speed property that represents the speed of the car.\n  A set of cars has a speed property that represents the speed of all the cars.\n*/\nconst carsCollideBothRight = (car, cars) => {\n  return car.speed > cars[cars.length - 1].speed && car.speed < cars[0].speed;\n};\n\n/*\n  Given a car object and a set of cars, this function returns true if the\n  cars are colliding and false otherwise.\n\n  A car object has a speed property that represents the speed of the car.\n  A set of cars has a speed property that represents the speed of all the cars.\n*/\nconst carsCollideBothLeft = (car, cars) => {\n  return car.speed > cars[0].speed && car.speed < cars[cars.length - 1].speed;\n};\n\n/*\n  Given a car object and a set of cars, this function returns true if the\n  cars are colliding and false otherwise.\n\n  A car object has a speed property that represents the speed of the car.\n  A set of cars has a speed property that represents the speed of all the cars.\n*/\nconst carsCollideBothBoth = (car, cars) => {\n  return car.speed > cars[0].speed && car.speed < cars[cars.length - 1].speed;\n};\n\n/*\n  Given a car object and a set of cars, this function returns true if the\n  cars are colliding and false otherwise.\n\n  A car object has a speed property that represents the speed of the car.\n  A set of cars has a speed property that represents the speed of all the cars.\n*/\nconst carsCollideBothBothRight = (car, cars) => {\n  return car.speed > cars[cars.length - 1].speed && car.speed < cars[0].speed;\n};\n\n/*\n  Given a car object and a set of cars, this function returns true if the\n  cars are colliding and false otherwise.\n\n  A car object has a speed property that represents the speed of the car.\n  A set of cars has a speed property that represents the speed of all the cars.\n*/\nconst carsCollideBothBothBothLeft = (car, cars) => {\n  return car.speed > cars[0].speed && car.speed < cars[cars.length - 1].speed;\n};\n\n/*\n  Given a car object and a set of cars, this function returns true if the\n  cars are colliding and false otherwise.\n\n  A car object has a speed property that represents the speed of the car.\n  A set of cars has a speed property that represents the speed of all the cars.\n*/\nconst carsCollideBothBothBoth = (car, cars) => {\n  return car.speed > cars[0].speed && car.speed < cars[cars.length - 1].speed;\n};\n\n/*\n  Given a car object and a set of cars, this function returns true if the\n  cars are colliding and false otherwise.\n\n  A car object has a speed property that represents the speed of the car.\n  A set of cars has a speed property that represents the speed of all the cars.\n*/\nconst carsCollideBothBothBothRight = (car, cars) => {\n  return car.speed > cars[cars.length - 1].speed && car.speed < cars[0].speed;\n};\n\n/*\n  Given a car object and a set of cars, this function returns true if the\n  cars are colliding and false otherwise.\n\n  A car object has a speed property that represents the speed of the car.\n  A set of cars has a speed property that represents the speed of all the cars.\n*/\nconst carsCollideBothBothBothLeft = (car, cars) => {\n  return car.speed > cars[0].speed && car.speed < cars[cars.length - 1].speed;\n};\n\n/*\n  Given a car object and a set of cars, this function returns true if the\n  cars are colliding and false otherwise.\n\n  A car object has a speed property that represents the speed of the car.\n  A set of cars has a speed property that represents the speed of all the cars.\n*/\nconst carsCollideBothBothBothBoth = (car, cars) => {\n  return car.speed > cars[0].speed && car.speed < cars[cars.length - 1].speed;\n};\n\n/*\n  Given a car object and a set of cars, this function returns true if the\n  cars are colliding and false otherwise.\n\n  A car object has a speed property that represents the speed of the car.\n  A set of cars has a speed property that represents the speed of all the cars.\n*/\nconst carsCollideBothBothBothBothRight = (car, cars) => {\n  return car.speed ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements increased by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Return list with elements increased by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = l.length - 1;\n  let res = new Array(i);\n  while (i--) {\n    res[i] = l[i] + 1;\n  }\n  return res;\n};\n\n/**\n * Remove duplicates from an array.\n *\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])\n * [1, 2, 3, 4, 5]\n * >>> removeDuplicates([1, 2, 3, 4, 5])", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes a list of integers as input. It returns true if there are two different elements in the list that add up to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  pairsSumToZero takes a list of integers as input. It returns true if there are two different elements in the list that add up to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/**\n * A function that takes a list of integers and returns the number of pairs of integers that add up to a specific value.\n * >>> countPairs([1, 3, 5, 7])\n  2\n  >>> countPairs([1, 3, -2, 1])\n  1\n  >>> countPairs([1, 2, 3, 7])\n  1\n  >>> countPairs([2, 4, -5, 3, 5, 7])\n  2\n  >>> countPairs([1])\n  0\n  */\nconst countPairs = (l) => {\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * A function that takes a list of integers and returns the number of pairs of integers that add up to a specific value.\n * >>> countPairs([1, 3, 5, 7])\n  2\n  >>> countPairs([1, 3, -2, 1])\n  1\n  >>> countPairs([1, 2, 3, 7])\n  1\n  >>> countPairs([2, 4, -5, 3, 5, 7])\n  2\n  >>> countPairs([1])\n  0\n  */\nconst countPairsSum = (l) => {\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 1) {\n      count += pairsSumToZero(l);\n    }\n  }\n  return count;\n};\n\n/**\n * A function that takes a list of integers and returns the number of pairs of integers that add up to a specific value.\n * >>> countPairsSum([1, 3, 5, 7])\n  2\n  >>> countPairsSum([1, 3, -2, 1])\n  1\n  >>> countPairsSum([1, 2, 3, 7])\n  1\n  >>> countPairsSum([2, 4, -5, 3, 5, 7])\n  2\n  >>> countPairsSum([1])\n  0\n  */\nconst countPairsSumToZero = (l) => {\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 1) {\n      count += pairsSumToZero(l);\n    }\n  }\n  return count;\n};\n\n/**\n * A function that takes a list of integers and returns the number of pairs of integers that add up to a specific value.\n * >>> countPairsSumToZero([1, 3, 5, 7])\n  2\n  >>> countPairsSumToZero([1, 3, -2, 1])\n  1\n  >>> countPairsSumToZero([1, 2, 3, 7])\n  1\n  >>> countPairsSumToZero([2, 4, -5, 3, 5, 7])\n  2\n  >>> countPairsSumToZero([1])\n  0\n  */\nconst countPairsSumToZeroSum = (l) => {\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 1) {\n      count += pairsSumToZero(l);\n    }\n  }\n  return count;\n};\n\n/**\n * A function that takes a list of integers and returns the number of pairs of integers that add up to a specific value.\n * >>> countPairsSumToZeroSum([1, 3, 5, 7])\n  2\n  >>> countPairsSumToZeroSum([1, 3, -2, 1])\n  1\n  >>> countPairsSumToZeroSum([1, 2, 3, 7])\n  1\n  >>> countPairsSumToZeroSum([2, 4, -5, 3, 5, 7])\n  2\n  >>> countPairsSumToZeroSum([1])\n  0\n  */\nconst countPairsSumToZeroSumToZero = (l) => {\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 1) {\n      count += pairsSumToZero(l);\n    }\n  }\n  return count;\n};\n\n/**\n * A function that takes a list of integers and returns the number of pairs of integers that add up to a specific value.\n * >>> countPairsSumToZeroSumToZero([1, 3, 5, 7])\n  2\n  >>> countPairsSumToZeroSumToZero([1, 3, -2, 1])\n  1\n  >>> countPairsSumToZeroSumToZero([1, 2, 3, 7])\n  1\n  >>> countPairsSumToZeroSumToZero([2, 4, -5, 3, 5, 7])\n  2\n  >>> countPairsSumToZeroSumToZero([1])\n  0\n  */\nconst countPairsSumToZeroSumToZeroSum = (l) => {\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 1) {\n      count += pairsSumToZero(l);\n    }\n  }\n  return count;\n};\n\n/**\n * A function that takes a list of integers and returns the number of pairs of integers that add up to a specific value.\n * >>> countPairsSumToZeroSumToZeroSum([1, 3, 5, 7])\n  2\n  >>> countPairsSumToZeroSumToZeroSum([1, 3, -2, 1])\n  1\n  >>> countPairsSumToZeroSumToZeroSum([1, 2, 3, 7])\n  1\n  >>> countPairsSumToZeroSumToZeroSum([2, 4, -5, 3, 5, 7])\n  2\n  >>> countPairsSumToZeroSumToZeroSum([1])\n  0\n  */\nconst countPairsSumToZeroSumToZeroSumToZero = (l) => {\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 1) {\n      count += pairsSumToZero(l);\n    }\n  }\n  return count;\n};\n\n/**\n * A function that takes a list of integers and returns the number of pairs of integers that add up to a specific value.\n * >>> countPairsSumToZeroSumToZeroSumToZero([1, 3, 5, 7])\n  2\n  >>> countPairsSumToZeroSumToZeroSumToZero([1, 3, -2, 1])\n  1\n  >>> countPairsSumToZeroSumToZeroSumToZero([1, 2, 3, 7])\n  1\n  >>> countPairsSumToZeroSumToZeroSumToZero([2, 4, -5, 3, 5, 7])\n  2\n  >>> countPairsSumToZeroSumToZeroSumToZero([1])\n  0\n  */\nconst countPairsSumToZeroSumToZeroSumToZeroSum = (l) => {\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 1) {\n      count += pairsSumToZero(l);\n    }\n  }\n  return count;\n};\n\n/**\n * A function that takes a list of integers and returns the number of pairs of integers that add up to a specific value.\n * >>> countPairsSumToZeroSumToZeroSumToZeroSum([1, 3, 5, 7])\n  2\n  >>> countPairsSumToZeroSumToZeroSumToZeroSum([1, 3, -2, 1])\n  1\n  >>> countPairsSumToZeroSumToZeroSumToZeroSum([1, 2, 3, 7])\n  1\n  >>> countPairsSumToZeroSumToZeroSumToZeroSum([2, 4, -5, 3, 5, 7])\n  2\n  >>> countPairsSumToZeroSumToZeroSumToZeroSum([1])\n  0\n  */\nconst countPairsSumToZeroSumToZeroSumToZeroSumToZero = (l) => {\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 1) {\n      count += pairsSumToZero", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/44", "prompt": "/*Cdepend numerical base of the input number x to the base. Returns the string representation after the conversion. Base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Cdepend numerical base of the input number x to the base. Returns the string representation after the conversion. Base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  if (base === 10) {\n    return x.toString();\n  }\n  let result = x.toString();\n  let remainder = result % base;\n  let newResult = result / base;\n  if (remainder === 0) {\n    return newResult.toString();\n  }\n  return changeBase(newResult, base);\n};\n\n/*\n  Converts a string to a number in base base. Returns NaN if a number can't be represented in base base.\n  >>> toNumber(1)\n  1\n  >>> toNumber('1')\n  1\n  >>> toNumber('1.1')\n  NaN\n  >>> toNumber('1e1')\n  1e1\n  >>> toNumber('1e+1')\n  1e+1\n  >>> toNumber('1e-1')\n  -1\n  >>> toNumber('1e+2')\n  1e+2\n  >>> toNumber('1e+3')\n  1e+3\n  >>> toNumber('1e+4')\n  1e+4\n  >>> toNumber('1e+5')\n  1e+5\n  >>> toNumber('1e+6')\n  Infinity\n  >>> toNumber('1e+7')\n  NaN\n  >>> toNumber('1e+8')\n  NaN\n  >>> toNumber('1e+9')\n  NaN\n  >>> toNumber('1e+10')\n  NaN\n  >>> toNumber('1e+11')\n  NaN\n  >>> toNumber('1e+12')\n  NaN\n  >>> toNumber('1e+13')\n  NaN\n  >>> toNumber('1e+14')\n  NaN\n  >>> toNumber('1e+15')\n  NaN\n  >>> toNumber('1e+16')\n  NaN\n  >>> toNumber('1e+17')\n  NaN\n  >>> toNumber('1e+18')\n  NaN\n  >>> toNumber('1e+19')\n  NaN\n  >>> toNumber('1e+20')\n  NaN\n  >>> toNumber('1e+21')\n  NaN\n  >>> toNumber('1e+22')\n  NaN\n  >>> toNumber('1e+23')\n  NaN\n  >>> toNumber('1e+24')\n  NaN\n  >>> toNumber('1e+25')\n  NaN\n  >>> toNumber('1e+26')\n  NaN\n  >>> toNumber('1e+27')\n  NaN\n  >>> toNumber('1e+28')\n  NaN\n  >>> toNumber('1e+29')\n  NaN\n  >>> toNumber('1e+30')\n  NaN\n  >>> toNumber('1e+31')\n  NaN\n  >>> toNumber('1e+32')\n  NaN\n  >>> toNumber('1e+33')\n  NaN\n  >>> toNumber('1e+34')\n  NaN\n  >>> toNumber('1e+35')\n  NaN\n  >>> toNumber('1e+36')\n  NaN\n  >>> toNumber('1e+37')\n  NaN\n  >>> toNumber('1e+38')\n  NaN\n  >>> toNumber('1e+39')\n  NaN\n  >>> toNumber('1e+40')\n  NaN\n  >>> toNumber('1e+41')\n  NaN\n  >>> toNumber('1e+42')\n  NaN\n  >>> toNumber('1e+43')\n  NaN\n  >>> toNumber('1e+44')\n  NaN\n  >>> toNumber('1e+45')\n  NaN\n  >>> toNumber('1e+46')\n  NaN\n  >>> toNumber('1e+47')\n  NaN\n  >>> toNumber('1e+48')\n  NaN\n  >>> toNumber('1e+49')\n  NaN\n  >>> toNumber('1e+50')\n  NaN\n  >>> toNumber('1e+51')\n  NaN\n  >>> toNumber('1e+52')\n  NaN\n  >>> toNumber('1e+53')\n  NaN\n  >>> toNumber('1e+54')\n  NaN\n  >>> toNumber('1e+55')\n  NaN\n  >>> toNumber('1e+56')\n  NaN\n  >>> toNumber('1e+57')\n  NaN\n  >>> toNumber('1e+58')\n  NaN\n  >>> toNumber('1e+59')\n  NaN\n  >>> toNumber('1e+60')\n  NaN\n  >>> toNumber('1e+61')\n  NaN\n  >>> toNumber('1e+62')\n  NaN\n  >>> toNumber('1e+63')\n  NaN\n  >>> toNumber('1e+64')\n  NaN\n  >>> toNumber('1e+65')\n  NaN\n  >>> toNumber('1e+66')\n  NaN\n  >>> toNumber('1e+67')\n  NaN\n  >>> toNumber('1e+68')\n  NaN\n  >>> toNumber('1e+69')\n  NaN\n  >>> toNumber('1e+70')\n  NaN\n  >>> toNumber('1e+71')\n  NaN\n  >>> toNumber('1e+72')\n  NaN\n  >>> toNumber('1e+73')\n  NaN\n  >>> toNumber('1e+74')\n  NaN\n  >>> toNumber('1e+75')\n  NaN\n  >>> toNumber('1e+76')\n  NaN\n  >>> toNumber('1e+77')\n  NaN\n  >>> toNumber('1e+78')\n  NaN\n  >>> toNumber('1e+79')\n  NaN\n  >>> toNumber('1e+80')\n  NaN\n  >>> toNumber('1e+81')\n  NaN\n  >>> toNumber('1e+82')\n  NaN\n  >>> toNumber('1e+83')\n  NaN\n  >>> toNumber('1e+84')\n  NaN\n  >>> toNumber('1e+85')\n  NaN\n  >>> toNumber('1e+86')\n  NaN\n  >>> toNumber('1e+87')\n  NaN\n  >>> toNumber('1e+88')\n  NaN\n  >>> toNumber('1e+89')\n  NaN\n  >>> toNumber('1e+90')\n  NaN\n  >>> toNumber('1e+91')\n  NaN\n  >>> toNumber('1e+92')\n  NaN\n  >>> toNumber('1e+93')\n  NaN\n  >>> toNumber('1e+94')\n  NaN\n  >>> toNumber('1e+95')\n  NaN\n  >>> toNumber('1e+96')\n  NaN\n  >>> toNumber('1e+97')\n  NaN\n  >>> toNumber('1e+98')\n  NaN\n  >>> toNumber('1e+99')\n  NaN\n  >>> toNumber('1e+100')\n  NaN\n  >>> toNumber('1e+101')\n  NaN\n  >>> toNumber('1e+102')\n  NaN\n  >>> ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/45", "prompt": "/*GThe length of one side is the same and the return face is high for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*GThe length of one side is the same and the return face is high for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const t = (a + h) / 2;\n  return Math.sqrt(a * a + h * h) / Math.sqrt(2 * t);\n};\n\n/**\n  Returns the area of a triangle with sides a, b, c, and d.\n\n  >>> triangleArea(3, 4, 5)\n  15.0\n  */\nconst triangleArea = (...args) => {\n  const [a, b, c, d] = args;\n  return triangleArea(a, b) * triangleArea(c, d);\n};\n\n/**\n  Returns the area of a triangle with sides a, b, c, and d.\n\n  >>> triangleArea(3, 4, 5)\n  15.0\n  */\nconst triangleArea2 = (a, b, c) => {\n  const t = (a + b + c) / 2;\n  return Math.sqrt(a * a + b * b + c * c) / Math.sqrt(2 * t);\n};\n\n/**\n  Returns the area of a triangle with sides a, b, c, and d.\n\n  >>> triangleArea(3, 4, 5)\n  15.0\n  */\nconst triangleArea3 = (...args) => {\n  const [a, b, c, d] = args;\n  return triangleArea(a, b) * triangleArea(c, d);\n};\n\n/**\n  Returns the area of a triangle with sides a, b, c, and d.\n\n  >>> triangleArea(3, 4, 5)\n  15.0\n  */\nconst triangleArea4 = (...args) => {\n  const [a, b, c, d] = args;\n  return triangleArea(a, b) * triangleArea(c, d);\n};\n\n/**\n  Returns the area of a triangle with sides a, b, c, and d.\n\n  >>> triangleArea(3, 4, 5)\n  15.0\n  */\nconst triangleArea5 = (...args) => {\n  const [a, b, c, d] = args;\n  return triangleArea(a, b) * triangleArea(c, d);\n};\n\n/**\n  Returns the area of a triangle with sides a, b, c, and d.\n\n  >>> triangleArea(3, 4, 5)\n  15.0\n  */\nconst triangleArea6 = (...args) => {\n  const [a, b, c, d] = args;\n  return triangleArea(a, b) * triangleArea(c, d);\n};\n\n/**\n  Returns the area of a triangle with sides a, b, c, and d.\n\n  >>> triangleArea(3, 4, 5)\n  15.0\n  */\nconst triangleArea7 = (...args) => {\n  const [a, b, c, d] = args;\n  return triangleArea(a, b) * triangleArea(c, d);\n};\n\n/**\n  Returns the area of a triangle with sides a, b, c, and d.\n\n  >>> triangleArea(3, 4, 5)\n  15.0\n  */\nconst triangleArea8 = (...args) => {\n  const [a, b, c, d] = args;\n  return triangleArea(a, b) * triangleArea(c, d);\n};\n\n/**\n  Returns the area of a triangle with sides a, b, c, and d.\n\n  >>> triangleArea(3, 4, 5)\n  15.0\n  */\nconst triangleArea9 = (...args) => {\n  const [a, b, c, d] = args;\n  return triangleArea(a, b) * triangleArea(c, d);\n};\n\n/**\n  Returns the area of a triangle with sides a, b, c, and d.\n\n  >>> triangleArea(3, 4, 5)\n  15.0\n  */\nconst triangleArea10 = (...args) => {\n  const [a, b, c, d] = args;\n  return triangleArea(a, b) * triangleArea(c, d);\n};\n\n/**\n  Returns the area of a triangle with sides a, b, c, and d.\n\n  >>> triangleArea(3, 4, 5)\n  15.0\n  */\nconst triangleArea11 = (...args) => {\n  const [a, b, c, d] = args;\n  return triangleArea(a, b) * triangleArea(c, d);\n};\n\n/**\n  Returns the area of a triangle with sides a, b, c, and d.\n\n  >>> triangleArea(3, 4, 5)\n  15.0\n  */\nconst triangleArea12 = (...args) => {\n  const [a, b, c, d] = args;\n  return triangleArea(a, b) * triangleArea(c, d);\n};\n\n/**\n  Returns the area of a triangle with sides a, b, c, and d.\n\n  >>> triangleArea(3, 4, 5)\n  15.0\n  */\nconst triangleArea13 = (...args) => {\n  const [a, b, c, d] = args;\n  return triangleArea(a, b) * triangleArea(c, d);\n};\n\n/**\n  Returns the area of a triangle with sides a, b, c, and d.\n\n  >>> triangleArea(3, 4, 5)\n  15.0\n  */\nconst triangleArea14 = (...args) => {\n  const [a, b, c, d] = args;\n  return triangleArea(a, b) * triangleArea(c, d);\n};\n\n/**\n  Returns the area of a triangle with sides a, b, c, and d.\n\n  >>> triangleArea(3, 4, 5)\n  15.0\n  */\nconst triangleArea15 = (...args) => {\n  const [a, b, c, d] = args;\n  return triangleArea(a, b) * triangleArea(c, d);\n};\n\n/**\n  Returns the area of a triangle with sides a, b, c, and d.\n\n  >>> triangleArea(3, 4, 5)\n  15.0\n  */\nconst triangleArea16 = (...args) => {\n  const [a, b, c, d] = args;\n  return triangleArea(a, b) * triangleArea(c, d);\n};\n\n/**\n  Returns the area of a triangle with sides a, b, c, and d.\n\n  >>> triangleArea(3, 4, 5)\n  15.0\n  */\nconst triangleArea17 = (...args) => {\n  const [a, b, c, d] = args;\n  return triangleArea(a, b) * triangleArea(c, d);\n};\n\n/**\n  Returns the area of a triangle with sides a, b, c, and d.\n\n  >>> triangleArea(3, 4, 5)\n  15.0\n  */\nconst triangleArea18 = (...args) => {\n  const [a, b, c, d] = args;\n  return triangleArea(a, b) * triangleArea(c, d);\n};\n\n/**\n  Returns the area of a triangle with sides a, b, c, and d.\n\n  >>> triangleArea(3, 4, 5)\n  15.0\n  */\nconst triangleArea19 = (...args) => {\n  const [a, b, c, d] = args;\n  return triangleArea(a, b) * triangleArea(c, d);\n};\n\n/**\n  Returns the area of a triangle with sides a, b, c, and d.\n\n  >>> triangleArea(3, 4, 5)\n  15.0\n  */\nconst triangleArea20 = (...args) => {\n  const [a, b, c, d] = args;\n  return triangleArea(a, b) * triangleArea(c, d);\n};\n\n/**\n  Returns the area of a triangle with sides a, b, c, and d.\n\n  >>> triangleArea(3, 4, 5)\n  15.0\n  */\nconst triangleArea21 = (...args) => {\n  const [a, b, c, d] = args;\n  return triangleArea(a, b) * triangleArea(c, d);\n};\n\n/**\n  Returns the area of a triangle with sides a, b, c, and d.\n\n  >>> triangleArea(3, 4, 5)\n  15.0\n  */\nconst triangleArea22 = (...args) => {\n  const [a, b, c, d] = args;\n  return triangleArea(a, b) * triangleArea(c, d);\n};\n\n/**\n  Returns the area of a triangle with sides a, b, c, and d.\n\n  >>> triangleArea(3, 4, 5)\n  15.0\n  */\nconst triangleArea23 = (...args) => {\n  const [a, b, c, d] = args;\n  return triangleArea(a, b) * triangleArea(c, d);\n};\n\n/**\n  Returns the area of a triangle with sides a, b, c, and d.\n\n  >>> triangleArea(3, 4, 5)\n  15.0\n  */\nconst triangleArea24 = (...args) => {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/46", "prompt": "/*TThe Fib4 sequence is a sequence similar to the Fibbonacci sequence, which is defined as: fib4 (0) - > 0 fib4 (1) - > 0 fib4 (2) - > 2 fib4 (3) - > 0 fib4 (n-1) - > fib4 (n-2) + fib4 (n-3) + fib4 (n-4).\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*TThe Fib4 sequence is a sequence similar to the Fibbonacci sequence, which is defined as: fib4 (0) - > 0 fib4 (1) - > 0 fib4 (2) - > 2 fib4 (3) - > 0 fib4 (n-1) - > fib4 (n-2) + fib4 (n-3) + fib4 (n-4).\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n < 2) return n;\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*\n  >>> fib5(10)\n  55\n  >>> fib5(20)\n  145\n  >>> fib5(30)\n  233\n  >>> fib5(50)\n  987654321\n  >>> fib5(100)\n  42424242\n  >>> fib5(1000)\n  4242424242\n  >>> fib5(10000)\n  424242424242\n  >>> fib5(100000)\n  42424242424242\n  >>> fib5(1000000)\n  4242424242424242\n  >>> fib5(10000000)\n  4242424242424242\n  >>> fib5(100000000)\n  424242424242424242\n  >>> fib5(1000000000)\n  424242424242424242\n  >>> fib5(10000000000)\n  424242424242424242\n  >>> fib5(100000000000)\n  424242424242424242\n  >>> fib5(1000000000000)\n  424242424242424242\n  >>> fib5(10000000000000)\n  424242424242424242\n  >>> fib5(100000000000000)\n  424242424242424242\n  >>> fib5(1000000000000000)\n  424242424242424242\n  >>> fib5(10000000000000000)\n  424242424242424242\n  >>> fib5(100000000000000000)\n  424242424242424242\n  >>> fib5(1000000000000000001)\n  42424242424242424242\n  >>> fib5(1000000000000000002)\n  424242424242424242\n  >>> fib5(1000000000000000003)\n  424242424242424242\n  >>> fib5(1000000000000000004)\n  424242424242424242\n  >>> fib5(1000000000000000005)\n  424242424242424242\n  >>> fib5(1000000000000000006)\n  424242424242424242\n  >>> fib5(1000000000000000007)\n  424242424242424242\n  >>> fib5(1000000000000000008)\n  424242424242424242\n  >>> fib5(1000000000000000009)\n  424242424242424242\n  >>> fib5(10000000000000000010)\n  424242424242424242\n  >>> fib5(10000000000000000011)\n  424242424242424242\n  >>> fib5(10000000000000000012)\n  424242424242424242\n  >>> fib5(10000000000000000013)\n  424242424242424242\n  >>> fib5(10000000000000000014)\n  424242424242424242\n  >>> fib5(10000000000000000015)\n  424242424242424242\n  >>> fib5(10000000000000000016)\n  424242424242424242\n  >>> fib5(10000000000000000017)\n  424242424242424242\n  >>> fib5(10000000000000000018)\n  424242424242424242\n  >>> fib5(10000000000000000019)\n  424242424242424242\n  >>> fib5(10000000000000000020)\n  424242424242424242\n  >>> fib5(10000000000000000021)\n  424242424242424242\n  >>> fib5(10000000000000000022)\n  424242424242424242\n  >>> fib5(10000000000000000023)\n  424242424242424242\n  >>> fib5(10000000000000000024)\n  424242424242424242\n  >>> fib5(10000000000000000025)\n  424242424242424242\n  >>> fib5(10000000000000000026)\n  424242424242424242\n  >>> fib5(10000000000000000027)\n  424242424242424242\n  >>> fib5(10000000000000000028)\n  424242424242424242\n  >>> fib5(10000000000000000029)\n  424242424242424242\n  >>> fib5(10000000000000000030)\n  424242424242424242\n  >>> fib5(10000000000000000031)\n  424242424242424242\n  >>> fib5(10000000000000000032)\n  424242424242424242\n  >>> fib5(10000000000000000033)\n  424242424242424242\n  >>> fib5(10000000000000000034)\n  424242424242424242\n  >>> fib5(10000000000000000035)\n  424242424242424242\n  >>> fib5(10000000000000000036)\n  424242424242424242\n  >>> fib5(10000000000000000037)\n  424242424242424242\n  >>> fib5(10000000000000000038)\n  42424242424242424242\n  >>> fib5(10000000000000000039)\n  42424242424242424242\n  >>> fib5(10000000000000000040)\n  424242424242424242\n  >>> fib5(10000000000000000041)\n  424242424242424242\n  >>> fib5(10000000000000000042)\n  424242424242424242\n  >>> fib5(10000000000000000043)\n  424242424242424242\n  >>> fib5(10000000000000000044)\n  424242424242424242\n  >>> fib5(10000000000000000045)\n  424242424242424242\n  >>> fib5(10000000000000000044)\n  424242424242424242\n  >>> fib5(10000000000000000046)\n  424242424242424242\n  >>> fib5(10000000000000000047)\n  424242424242424242\n  >>> fib5(10000000000000000048)\n  424242424242424242\n  ", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/47", "prompt": "/*RThe median number of items in the list.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*RThe median number of items in the list.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let n = l.length\n  if (n <= 1) return 0\n  let mid = Math.floor((n / 2) | 0)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid, l.length)\n  return median(left) + median(right)\n}\n\n/**\n  Returns the median of the given list of numbers.\n\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfList = (l) => {\n  return median(l)\n}\n\n/**\n  Returns the median of the given list of numbers.\n\n  >>> medianOfList([3, 1, 2, 4, 5])\n  3\n  >>> medianOfList([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfNumbers = (l) => {\n  return median(l)\n}\n\n/**\n  Returns the median of the given list of numbers.\n\n  >>> medianOfListOfNumbers([3, 1, 2, 4, 5])\n  3\n  >>> medianOfListOfNumbers([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfNumbersOfNumbers = (l) => {\n  return median(l)\n}\n\n/**\n  Returns the median of the given list of numbers.\n\n  >>> medianOfListOfNumbersOfNumbers([3, 1, 2, 4, 5])\n  3\n  >>> medianOfListOfNumbersOfNumbers([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfNumbersOfNumbersOfNumbers = (l) => {\n  return median(l)\n}\n\n/**\n  Returns the median of the given list of numbers.\n\n  >>> medianOfListOfNumbersOfNumbersOfNumbers([3, 1, 2, 4, 5])\n  3\n  >>> medianOfListOfNumbersOfNumbersOfNumbers([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfNumbersOfNumbersOfNumbersOfNumbers = (l) => {\n  return median(l)\n}\n\n/**\n  Returns the median of the given list of numbers.\n\n  >>> medianOfListOfNumbersOfNumbersOfNumbersOfNumbers([3, 1, 2, 4, 5])\n  3\n  >>> medianOfListOfNumbersOfNumbersOfNumbersOfNumbers([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfNumbersOfNumbersOfNumbersOfNumbersOfNumbers = (l) => {\n  return median(l)\n}\n\n/**\n  Returns the median of the given list of numbers.\n\n  >>> medianOfListOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbers([3, 1, 2, 4, 5])\n  3\n  >>> medianOfListOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbers([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbers = (l) => {\n  return median(l)\n}\n\n/**\n  Returns the median of the given list of numbers.\n\n  >>> medianOfListOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbersOfNumbers", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/48", "prompt": "/*\n  Tests if the given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  Tests if the given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Tests if the given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome2 = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Tests if the given string is a palindrome\n  >>> isPalindrome2('aba')\n  true\n  >>> isPalindrome2('aaaaa')\n  true\n  >>> isPalindrome2('zbcd')\n  false\n  */\nconst isPalindrome3 = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Tests if the given string is a palindrome\n  >>> isPalindrome3('aba')\n  true\n  >>> isPalindrome3('aaaaa')\n  true\n  >>> isPalindrome3('zbcd')\n  false\n  */\nconst isPalindrome4 = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Tests if the given string is a palindrome\n  >>> isPalindrome4('aba')\n  true\n  >>> isPalindrome4('aaaaa')\n  true\n  >>> isPalindrome4('zbcd')\n  false\n  */\nconst isPalindrome5 = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Tests if the given string is a palindrome\n  >>> isPalindrome5('aba')\n  true\n  >>> isPalindrome5('aaaaa')\n  true\n  >>> isPalindrome5('zbcd')\n  false\n  */\nconst isPalindrome6 = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Tests if the given string is a palindrome\n  >>> isPalindrome6('aba')\n  true\n  >>> isPalindrome6('aaaaa')\n  true\n  >>> isPalindrome6('zbcd')\n  false\n  */\nconst isPalindrome7 = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Tests if the given string is a palindrome\n  >>> isPalindrome7('aba')\n  true\n  >>> isPalindrome7('aaaaa')\n  true\n  >>> isPalindrome7('zbcd')\n  false\n  */\nconst isPalindrome8 = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Tests if the given string is a palindrome\n  >>> isPalindrome8('aba')\n  true\n  >>> isPalindrome8('aaaaa')\n  true\n  >>> isPalindrome8('zbcd')\n  false\n  */\nconst isPalindrome9 = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Tests if the given string is a palindrome\n  >>> isPalindrome9('aba')\n  true\n  >>> isPalindrome9('aaaaa')\n  true\n  >>> isPalindrome9('zbcd')\n  false\n  */\nconst isPalindrome10 = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Tests if the given string is a palindrome\n  >>> isPalindrome10('aba')\n  true\n  >>> isPalindrome10('aaaaa')\n  true\n  >>> isPalindrome10('zbcd')\n  false\n  */\nconst isPalindrome11 = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Tests if the given string is a palindrome\n  >>> isPalindrome11('aba')\n  true\n  >>> isPalindrome11('aaaaa')\n  true\n  >>> isPalindrome11('zbcd')\n  false\n  */\nconst isPalindrome12 = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Tests if the given string is a palindrome\n  >>> isPalindrome12('aba')\n  true\n  >>> isPalindrome12('aaaaa')\n  true\n  >>> isPalindrome12('zbcd')\n  false\n  */\nconst isPalindrome13 = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Tests if the given string is a palindrome\n  >>> isPalindrome13('aba')\n  true\n  >>> isPalindrome13('aaaaa')\n  true\n  >>> isPalindrome13('zbcd')\n  false\n  */\nconst isPalindrome14 = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Tests if the given string is a palindrome\n  >>> isPalindrome14('aba')\n  true\n  >>> isPalindrome14('aaaaa')\n  true\n  >>> isPalindrome14('zbcd')\n  false\n  */\nconst isPalindrome15 = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Tests if the given string is a palindrome\n  >>> isPalindrome15('aba')\n  true\n  >>> isPalindrome15('aaaaa')\n  true\n  >>> isPalindrome15('zbcd')\n  false\n  */\nconst isPalindrome16 = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Tests if the given string is a palindrome\n  >>> isPalindrome16('aba')\n  true\n  >>> isPalindrome16('aaaaa')\n  true\n  >>> isPalindrome16('zbcd')\n  false\n  */\nconst isPalindrome17 = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Tests if the given string is a palindrome\n  >>> isPalindrome17('aba')\n  true\n  >>> isPalindrome17('aaaaa')\n  true\n  >>> isPalindrome17('zbcd')\n  false\n  */\nconst isPalindrome18 = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/49", "prompt": "/*Return 2 ^ n modulo p (Attention Numeric).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Return 2 ^ n modulo p (Attention Numeric).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  if (n < 0 || p < 0) {\n    throw new Error('Modulus must be non-negative integers');\n  }\n  if (p === 0 || p === 1) {\n    return n;\n  }\n  if (p === 2) {\n    return (n + 1) & -2;\n  }\n  if (p === 3) {\n    return (n + 1) & 3;\n  }\n  if (p === 4) {\n    return (n + 1) & 7;\n  }\n  if (p === 5) {\n    return (n + 1) & 15;\n  }\n  if (p === 6) {\n    return (n + 1) & 31;\n  }\n  if (p === 7) {\n    return (n + 1) & 63;\n  }\n  if (p === 8) {\n    return (n + 1) & 127;\n  }\n  if (p === 9) {\n    return (n + 1) & 255;\n  }\n  if (p === 10) {\n    return (n + 1) & 511;\n  }\n  if (p === 11) {\n    return (n + 1) & 1023 | 128;\n  }\n  if (p === 12) {\n    return (n + 1) & 2047 | 256;\n  }\n  if (p === 13) {\n    return (n + 1) & 4095 | 512;\n  }\n  if (p === 14) {\n    return (n + 1) & 8191 | 1024;\n  }\n  if (p === 15) {\n    return (n + 1) & 16383 | 2048;\n  }\n  if (p === 16) {\n    return (n + 1) & 32767 | 4096;\n  }\n  if (p === 17) {\n    return (n + 1) & 65535 | 8192;\n  }\n  if (p === 18) {\n    return (n + 1) & 131071 | 16384;\n  }\n  if (p === 19) {\n    return (n + 1) & 262143 | 32768;\n  }\n  if (p === 20) {\n    return (n + 1) & 524287 | 65536;\n  }\n  if (p === 21) {\n    return (n + 1) & 1048575 | 131072;\n  }\n  if (p === 22) {\n    return (n + 1) & 2097151 | 262144;\n  }\n  if (p === 23) {\n    return (n + 1) & 4194303 | 524288;\n  }\n  if (p === 24) {\n    return (n + 1) & 8388607 | 1048576;\n  }\n  if (p === 25) {\n    return (n + 1) & 16777215 | 2097152;\n  }\n  if (p === 26) {\n    return (n + 1) & 33554431 | 4194304;\n  }\n  if (p === 27) {\n    return (n + 1) & 67108863 | 8388608;\n  }\n  if (p === 28) {\n    return (n + 1) & 134217727 | 16777216;\n  }\n  if (p === 29) {\n    return (n + 1) & 268435455 | 33554432;\n  }\n  if (p === 30) {\n    return (n + 1) & 536870911 & 67108863;\n  }\n  if (p === 31) {\n    return (n + 1) & 1073741823 & 134217728;\n  }\n  if (p === 32) {\n    return (n + 1) & 2147483647 & 268435456;\n  }\n  if (p === 33) {\n    return (n + 1) & 536870912 & 67108864;\n  }\n  if (p === 34) {\n    return (n + 1) & 1073741824 & 134217729;\n  }\n  if (p === 35) {\n    return (n + 1) & 2147483648 & 268435457;\n  }\n  if (p === 36) {\n    return (n + 1) & 536870913 & 67108865;\n  }\n  if (p === 37) {\n    return (n + 1) & 1073741825 & 134217730;\n  }\n  if (p === 38) {\n    return (n + 1) & 2147483649 & 268435458;\n  }\n  if (p === 39) {\n    return (n + 1) & 536870914 & 67108866;\n  }\n  if (p === 40) {\n    return (n + 1) & 1073741826 & 134217731;\n  }\n  if (p === 41) {\n    return (n + 1) & 2147483650 & 268435459;\n  }\n  if (p === 42) {\n    return (n + 1) & 536870915 & 67108867;\n  }\n  if (p === 43) {\n    return (n + 1) & 1073741827 & 134217732;\n  }\n  if (p === 44) {\n    return (n + 1) & 2147483651 & 268435460;\n  }\n  if (p === 45) {\n    return (n + 1) & 536870916 & 67108868;\n  }\n  if (p === 46) {\n    return (n + 1) & 1073741828 & 134217733;\n  }\n  if (p === 47) {\n    return (n + 1) & 2147483652 & 268435461;\n  }\n  if (p === 48) {\n    return (n + 1) & 536870917 & 67108869;\n  }\n  if (p === 49) {\n    return (n + 1) & 1073741829 & 134217734;\n  }\n  if (p === 50) {\n    return (n + 1) & 2147483653 & 268435462;\n  }\n  if (p === 51) {\n    return (n + 1) & 536870918 & 67108870;\n  }\n  if (p === 52) {\n    return (n + 1) & 1073741830 & 134217735;\n  }\n  if (p === 53) {\n    return (n + 1) & 2147483654 & 268435463;\n  }\n  if (p === 54) {\n    return (n + 1) & 536870919 & 67108871;\n  }\n  if (p === 55) {\n    return (n + 1) & 1073741831 & 134217736;\n  }\n  if (p === 56) {\n    return (n + 1) & 2147483655 & 268435464;\n  }\n  if (p === 57) {\n    return (n + 1) & 536870920 & 67108872;\n  }\n  if (p === 58) {\n    return (n + 1) & 1073741832 & 134217737;\n  }\n  if (p === 59) {\n    return (n + 1) & 2147483656 & 268435465;\n  }\n  if (p === 60) {\n    return (n + 1) & 536870921 & 67108873;\n  }\n  if (p === 61) {\n    return (n + 1) & 1073741833 & 134217738;\n  }\n  if (p === 62) {\n    return (n + 1) & 2147483657 & 268435466;\n  }\n  if (p === 63) {\n    return (n + 1) & 536870922 & 67108874;\n  }\n  if (p === 64) {\n    return (n + 1) & 1073741834 & 134217739;\n  }\n  if (p === 65) {\n    return (n + 1) & 2147483658 & 268435467;\n  }\n  if (p === 66) {\n    return (n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number \"delimeter\" between two consecutive elements of the \"Numbers\" input list.\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Insert a number \"delimeter\" between two consecutive elements of the \"Numbers\" input list.\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  const result = [];\n  let i = 0;\n  let j = 0;\n  while (i < numbers.length) {\n    if (numbers[i]!== delimeter) {\n      result.push(numbers[i]);\n      i++;\n    } else {\n      result.push(delimeter);\n      j++;\n    }\n  }\n  return result;\n};\n\n/**\n * Remove all occurrences of a value from an array.\n * >>> remove([1,2,3], 2)\n * [1,2,3]\n * >>> remove([1,2,3], 3)\n * []\n * >>> remove([1,2,3], 1)\n * [1,2,3]\n */\nconst remove = (array, value) => {\n  const index = array.indexOf(value);\n  if (index === -1) {\n    return [];\n  }\n  return array.slice(0, index).concat(array.slice(index + 1));\n};\n\n/**\n * Remove all occurrences of a value from an array.\n * >>> remove([1,2,3], 2)\n * [1,2,3]\n * >>> remove([1,2,3], 3)\n * []\n * >>> remove([1,2,3], 1)\n * [1,2,3]\n */\nconst removeAll = (array, value) => {\n  const index = array.indexOf(value);\n  if (index === -1) {\n    return [];\n  }\n  return array.slice(0, index).concat(array.slice(index + 1));\n};\n\n/**\n * Remove all occurrences of a value from an array.\n * >>> remove([1,2,3], 2)\n * [1,2,3]\n * >>> remove([1,2,3], 3)\n * []\n * >>> remove([1,2,3], 1)\n * [1,2,3]\n */\nconst removeAllBut = (array, value) => {\n  const index = array.indexOf(value);\n  if (index === -1) {\n    return [];\n  }\n  return array.slice(0, index).concat(array.slice(index + 1));\n};\n\n/**\n * Remove all occurrences of a value from an array.\n * >>> remove([1,2,3], 2)\n * [1,2,3]\n * >>> remove([1,2,3], 3)\n * []\n * >>> remove([1,2,3], 1)\n * [1,2,3]\n */\nconst removeAllButNot = (array, value) => {\n  const index = array.indexOf(value);\n  if (index === -1) {\n    return [];\n  }\n  return array.slice(0, index).concat(array.slice(index + 1));\n};\n\n/**\n * Remove all occurrences of a value from an array.\n * >>> remove([1,2,3], 2)\n * [1,2,3]\n * >>> remove([1,2,3], 3)\n * []\n * >>> remove([1,2,3], 1)\n * [1,2,3]\n */\nconst removeAllButNot = (array, value) => {\n  const index = array.indexOf(value);\n  if (index === -1) {\n    return [];\n  }\n  return array.slice(0, index).concat(array.slice(index + 1));\n};\n\n/**\n * Remove all occurrences of a value from an array.\n * >>> remove([1,2,3], 2)\n * [1,2,3]\n * >>> remove([1,2,3], 3)\n * []\n * >>> remove([1,2,3], 1)\n * [1,2,3]\n */\nconst removeAllButNot = (array, value) => {\n  const index = array.indexOf(value);\n  if (index === -1) {\n    return [];\n  }\n  return array.slice(0, index).concat(array.slice(index + 1));\n};\n\n/**\n * Remove all occurrences of a value from an array.\n * >>> remove([1,2,3], 2)\n * [1,2,3]\n * >>> remove([1,2,3], 3)\n * []\n * >>> remove([1,2,3], 1)\n * [1,2,3]\n */\nconst removeAllButNot = (array, value) => {\n  const index = array.indexOf(value);\n  if (index === -1) {\n    return [];\n  }\n  return array.slice(0, index).concat(array.slice(index + 1));\n};\n\n/**\n * Remove all occurrences of a value from an array.\n * >>> remove([1,2,3], 2)\n * [1,2,3]\n * >>> remove([1,2,3], 3)\n * []\n * >>> remove([1,2,3], 1)\n * [1,2,3]\n */\nconst removeAllButNot = (array, value) => {\n  const index = array.indexOf(value);\n  if (index === -1) {\n    return [];\n  }\n  return array.slice(0, index).concat(array.slice(index + 1));\n};\n\n/**\n * Remove all occurrences of a value from an array.\n * >>> remove([1,2,3], 2)\n * [1,2,3]\n * >>> remove([1,2,3], 3)\n * []\n * >>> remove([1,2,3], 1)\n * [1,2,3]\n */\nconst removeAllButNot = (array, value) => {\n  const index = array.indexOf(value);\n  if (index === -1) {\n    return [];\n  }\n  return array.slice(0, index).concat(array.slice(index + 1));\n};\n\n/**\n * Remove all occurrences of a value from an array.\n * >>> remove([1,2,3], 2)\n * [1,2,3]\n * >>> remove([1,2,3], 3)\n * []\n * >>> remove([1,2,3], 1)\n * [1,2,3]\n */\nconst removeAllButNot = (array, value) => {\n  const index = array.indexOf(value);\n  if (index === -1) {\n    return [];\n  }\n  return array.slice(0, index).concat(array.slice(index + 1));\n};\n\n/**\n * Remove all occurrences of a value from an array.\n * >>> remove([1,2,3], 2)\n * [1,2,3]\n * >>> remove([1,2,3], 3)\n * []\n * >>> remove([1,2,3], 1)\n * [1,2,3]\n */\nconst removeAllButNot = (array, value) => {\n  const index = array.indexOf(value);\n  if (index === -1) {\n    return [];\n  }\n  return array.slice(0, index).concat(array.slice(index + 1));\n};\n\n/**\n * Remove all occurrences of a value from an array.\n * >>> remove([1,2,3], 2)\n * [1,2,3]\n * >>> remove([1,2,3], 3)\n * []\n * >>> remove([1,2,3], 1)\n * [1,2,3]\n */\nconst removeAllButNot = (array, value) => {\n  const index = array.indexOf(value);\n  if (index === -1) {\n    return [];\n  }\n  return array.slice(0, index).concat(array.slice(index + 1));\n};\n\n/**\n * Remove all occurrences of a value from an array.\n * >>> remove([1,2,3], 2)\n * [1,2,3]\n * >>> remove([1,2,3], 3)\n * []\n * >>> remove([1,2,3], 1)\n * [1,2,3]\n */\nconst removeAllButNot = (array, value) => {\n  const index = array.indexOf(value);\n  if (index === -1) {\n    return [];\n  }\n  return array.slice(0, index).concat(array.slice(index + 1));\n};\n\n/**\n * Remove all occurrences of a value from an array.\n * >>> remove([1,2,3], 2)\n * [1,2,3]\n * >>> remove([1,2,3], 3)\n * []\n * >>> remove([1,2,3], 1)\n * [1,2,3]\n */\nconst removeAllButNot = (array, value) => {\n  const index = array.indexOf(value);\n  if (index === -1) {\n    return [];\n  }\n  return array.slice(0, index).concat(array.slice(index + 1));\n};\n\n/**\n * Remove all occurrences of a value from an array.\n * >>> remove([1,2,3], 2)\n * [1,2,3]\n * >>> remove([1,2,3], 3)\n * []\n * >>> remove([1,2,3], 1)\n * [1,2,3]\n */\nconst removeAllButNot = (array, value) => {\n  const index = array.indexOf(value);\n  if (index === -1) {\n    return [];\n  }\n  return array.slice(0, index).concat(array.slice(index + 1));\n};\n\n/**\n * Remove all occurrences of a value from an array.\n * >>> remove([1,2,3], 2)\n * [1,2,3]\n * >>> remove([1,2,3], 3)\n * []\n * >>> remove([1,2,3], 1)\n * [1,2,3]\n */\nconst removeAllButNot = (array, value) => {\n  const index = array.indexOf(value);\n  if (index === -1) {\n    return [];\n  }\n  return ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decode = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encode = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decode = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeToHex = (s) => {\n  return encodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).join(\"0x\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeToHex = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeToAscii = (s) => {\n  return encodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(10)).join(\"_\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeToAscii = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeToBase64 = (s) => {\n  return encodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(2)).join(\"=\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeToBase64 = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeToBase32 = (s) => {\n  return encodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(2)).join(\"=\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeToBase32 = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeToBase16 = (s) => {\n  return encodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(2)).join(\"=\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeToBase16 = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeToHexBase64 = (s) => {\n  return encodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(2)).join(\"=\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeToHexBase64 = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeToHexBase32 = (s) => {\n  return encodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(2)).join(\"=\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeToHexBase32 = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeToHexBase16 = (s) => {\n  return encodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(2)).join(\"=\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeToHexBase16 = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeToBase64Base32 = (s) => {\n  return encodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(2)).join(\"=\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeToBase64Base32 = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeToBase64Base16 = (s) => {\n  return encodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(2)).join(\"=\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeToBase64Base16 = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeToHexBase64Base32 = (s) => {\n  return encodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(2)).join(\"=\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeToHexBase64Base32 = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeToHexBase64Base16 = (s) => {\n  return encodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(2)).join(\"=\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeToHexBase64Base16 = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeToBase64Hex = (s) => {\n  return encodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(2)).join(\"=\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeToBase64Hex = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeToBase64Ascii = (s) => {\n  return encodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(2)).join(\"_\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeToBase64Ascii = (s) => {\n  return decode", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function that takes strings and returns strings without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  removeVowels is a function that takes strings and returns strings without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  let vowels = 'aeiouAEIOU'\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = text.length\n  let vowelsIndex = 0", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/52", "prompt": "/*Return true if all numbers in list l are below the t threshold.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Return true if all numbers in list l are below the t threshold.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  return l.some((n) => n < t);\n};\n\n/*Return true if all numbers in list l are above the t threshold.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  true\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst aboveThreshold = (l, t) => {\n  return l.some((n) => n > t);\n};\n\n/*Return true if all numbers in list l are equal to t.\n  >>> equalThreshold([1, 2, 4, 10], 100)\n  true\n  >>> equalThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst equalThreshold = (l, t) => {\n  return l.every((n) => n === t);\n};\n\n/*Return true if all numbers in list l are greater than t.\n  >>> greaterThanThreshold([1, 2, 4, 10], 100)\n  true\n  >>> greaterThanThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst greaterThanThreshold = (l, t) => {\n  return l.every((n) => n > t);\n};\n\n/*Return true if all numbers in list l are less than t.\n  >>> lessThanThreshold([1, 2, 4, 10], 100)\n  true\n  >>> lessThanThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst lessThanThreshold = (l, t) => {\n  return l.every((n) => n < t);\n};\n\n/*Return true if all numbers in list l are a multiple of t.\n  >>> multipleOfThreshold([1, 2, 4, 10], 100)\n  true\n  >>> multipleOfThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst multipleOfThreshold = (l, t) => {\n  return l.every((n) => n % t === 0);\n};\n\n/*Return true if all numbers in list l are a multiple of t.\n  >>> multipleOfThreshold([1, 2, 4, 10], 5)\n  true\n  >>> multipleOfThreshold([1, 20, 4, 10], 100)\n  false\n  */\nconst multipleOf = (l, t) => {\n  return l.every((n) => n % t === 0);\n};\n\n/*Return true if all numbers in list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 5)\n  true\n  >>> multipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst multipleOf = (l, t) => {\n  return l.every((n) => n % t === 0);\n};\n\n/*Return true if all numbers in list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 100)\n  true\n  >>> multipleOf([1, 20, 4, 10], 5)\n  false\n  */\nconst multipleOf = (l, t) => {\n  return l.every((n) => n % t === 0);\n};\n\n/*Return true if all numbers in list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 5)\n  true\n  >>> multipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst multipleOf = (l, t) => {\n  return l.every((n) => n % t === 0);\n};\n\n/*Return true if all numbers in list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 5)\n  true\n  >>> multipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst multipleOf = (l, t) => {\n  return l.every((n) => n % t === 0);\n};\n\n/*Return true if all numbers in list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 5)\n  true\n  >>> multipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst multipleOf = (l, t) => {\n  return l.every((n) => n % t === 0);\n};\n\n/*Return true if all numbers in list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 5)\n  true\n  >>> multipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst multipleOf = (l, t) => {\n  return l.every((n) => n % t === 0);\n};\n\n/*Return true if all numbers in list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 5)\n  true\n  >>> multipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst multipleOf = (l, t) => {\n  return l.every((n) => n % t === 0);\n};\n\n/*Return true if all numbers in list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 5)\n  true\n  >>> multipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst multipleOf = (l, t) => {\n  return l.every((n) => n % t === 0);\n};\n\n/*Return true if all numbers in list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 5)\n  true\n  >>> multipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst multipleOf = (l, t) => {\n  return l.every((n) => n % t === 0);\n};\n\n/*Return true if all numbers in list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 5)\n  true\n  >>> multipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst multipleOf = (l, t) => {\n  return l.every((n) => n % t === 0);\n};\n\n/*Return true if all numbers in list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 5)\n  true\n  >>> multipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst multipleOf = (l, t) => {\n  return l.every((n) => n % t === 0);\n};\n\n/*Return true if all numbers in list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 5)\n  true\n  >>> multipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst multipleOf = (l, t) => {\n  return l.every((n) => n % t === 0);\n};\n\n/*Return true if all numbers in list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 5)\n  true\n  >>> multipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst multipleOf = (l, t) => {\n  return l.every((n) => n % t === 0);\n};\n\n/*Return true if all numbers in list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 5)\n  true\n  >>> multipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst multipleOf = (l, t) => {\n  return l.every((n) => n % t === 0);\n};\n\n/*Return true if all numbers in list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 5)\n  true\n  >>> multipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst multipleOf = (l, t) => {\n  return l.every((n) => n % t === 0);\n};\n\n/*Return true if all numbers in list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 5)\n  true\n  >>> multipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst multipleOf = (l, t) => {\n  return l.every((n) => n % t === 0);\n};\n\n/*Return true if all numbers in list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 5)\n  true\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y with rounding\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst addWithRounding = (x, y) => {\n  return x + Math.round(x * 100) / 100;\n};\n\n/*\n  Add two numbers x and y with rounding and a precision\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst addWithRoundingAndPrecision = (x, y) => {\n  return x + Math.round(x * 100) / 100 + Math.round(x * 100) / 100;\n};\n\n/*\n  Add two numbers x and y with rounding and a precision and a rounding method\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst addWithRoundingAndPrecisionAndRoundingMethod = (x, y) => {\n  return x + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100;\n};\n\n/*\n  Add two numbers x and y with rounding and a precision and a rounding method\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst addWithRoundingAndPrecisionAndRoundingMethodAndPrecision = (x, y) => {\n  return x + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100;\n};\n\n/*\n  Add two numbers x and y with rounding and a precision and a rounding method\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst addWithRoundingAndPrecisionAndRoundingMethodAndPrecisionAndRoundingMethod = (x, y) => {\n  return x + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100;\n};\n\n/*\n  Add two numbers x and y with rounding and a precision and a rounding method\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst addWithRoundingAndPrecisionAndRoundingMethodAndPrecisionAndRoundingMethodAndPrecision = (x, y) => {\n  return x + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100;\n};\n\n/*\n  Add two numbers x and y with rounding and a precision and a rounding method\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst addWithRoundingAndPrecisionAndRoundingMethodAndPrecisionAndRoundingMethodAndPrecision = (x, y) => {\n  return x + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100;\n};\n\n/*\n  Add two numbers x and y with rounding and a precision and a rounding method\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst addWithRoundingAndPrecisionAndRoundingMethodAndPrecisionAndRoundingMethodAndPrecision = (x, y) => {\n  return x + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100;\n};\n\n/*\n  Add two numbers x and y with rounding and a precision and a rounding method\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst addWithRoundingAndPrecisionAndRoundingMethodAndPrecisionAndRoundingMethodAndPrecision = (x, y) => {\n  return x + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100;\n};\n\n/*\n  Add two numbers x and y with rounding and a precision and a rounding method\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst addWithRoundingAndPrecisionAndRoundingMethodAndPrecisionAndRoundingMethodAndPrecision = (x, y) => {\n  return x + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100;\n};\n\n/*\n  Add two numbers x and y with rounding and a precision and a rounding method\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst addWithRoundingAndPrecisionAndRoundingMethodAndPrecisionAndRoundingMethodAndPrecision = (x, y) => {\n  return x + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100;\n};\n\n/*\n  Add two numbers x and y with rounding and a precision and a rounding method\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst addWithRoundingAndPrecisionAndRoundingMethodAndPrecisionAndRoundingMethodAndPrecision = (x, y) => {\n  return x + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100;\n};\n\n/*\n  Add two numbers x and y with rounding and a precision and a rounding method\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst addWithRoundingAndPrecisionAndRoundingMethodAndPrecisionAndRoundingMethodAndPrecision = (x, y) => {\n  return x + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100;\n};\n\n/*\n  Add two numbers x and y with rounding and a precision and a rounding method\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst addWithRoundingAndPrecisionAndRoundingMethodAndPrecisionAndRoundingMethodAndPrecision = (x, y) => {\n  return x + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100;\n};\n\n/*\n  Add two numbers x and y with round", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check that two words have the same letters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  Check that two words have the same letters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  if (s0 === s1) return true;\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false;\n  }\n  return true;\n};\n\n/*\n  Convert a number to a string in hexadecimal.\n  >>> hexToInt('0xff')\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff', 16)\n  255\n  >>> hexToInt('0xff", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/55", "prompt": "/*RThe Fibonacci number is the ninth.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*RThe Fibonacci number is the ninth.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(5)\n  34\n  >>> fib(4)\n  14\n  >>> fib(3)\n  9\n  >>> fib(2)\n  1\n  >>> fib(7)\n  24\n  >>> fib(6)\n  55\n  >>> fib(5)\n  34\n  >>> fib(4)\n  14\n  >>> fib(3)\n  9\n  >>> fib(2)\n  1\n  >>> fib(7)\n  24\n  >>> fib(6)\n  55\n  >>> fib(5)\n  34\n  >>> fib(4)\n  14\n  >>> fib(3)\n  9\n  >>> fib(2)\n  1\n  >>> fib(7)\n  24\n  >>> fib(6)\n  55\n  >>> fib(5)\n  34\n  >>> fib(4)\n  14\n  >>> fib(3)\n  9\n  >>> fib(2)\n  1\n  >>> fib(7)\n  24\n  >>> fib(6)\n  55\n  >>> fib(5)\n  34\n  >>> fib(4)\n  14\n  >>> fib(3)\n  9\n  >>> fib(2)\n  1\n  >>> fib(7)\n  24\n  >>> fib(6)\n  55\n  >>> fib(5)\n  34\n  >>> fib(4)\n  14\n  >>> fib(3)\n  9\n  >>> fib(2)\n  1\n  >>> fib(7)\n  24\n  >>> fib(6)\n  55\n  >>> fib(5)\n  34\n  >>> fib(4)\n  14\n  >>> fib(3)\n  9\n  >>> fib(2)\n  1\n  >>> fib(7)\n  24\n  >>> fib(6)\n  55\n  >>> fib(5)\n  34\n  >>> fib(4)\n  14\n  >>> fib(3)\n  9\n  >>> fib(2)\n  1\n  >>> fib(7)\n  24\n  >>> fib(6)\n  55\n  >>> fib(5)\n  34\n  >>> fib(4)\n  14\n  >>> fib(3)\n  9\n  >>> fib(2)\n  1\n  >>> fib(7)\n  24\n  >>> fib(6)\n  55\n  >>> fib(5)\n  34\n  >>> fib(4)\n  14\n  >>> fib(3)\n  9\n  >>> fib(2)\n  1\n  >>> fib(7)\n  24\n  >>> fib(6)\n  55\n  >>> fib(5)\n  34\n  >>> fib(4)\n  14\n  >>> fib(3)\n  9\n  >>> fib(2)\n  1\n  >>> fib(7)\n  24\n  >>> fib(6)\n  55\n  >>> fib(5)\n  34\n  >>> fib(4)\n  14\n  >>> fib(3)\n  9\n  >>> fib(2)\n  1\n  >>> fib(7)\n  24\n  >>> fib(6)\n  55\n  >>> fib(5)\n  34\n  >>> fib(4)\n  14\n  >>> fib(3)\n  9\n  >>> fib(2)\n  1\n  >>> fib(7)\n  24\n  >>> fib(6)\n  55\n  >>> fib(5)\n  34\n  >>> fib(4)\n  14\n  >>> fib(3)\n  9\n  >>> fib(2)\n  1\n  >>> fib(7)\n  24\n  >>> fib(6)\n  55\n  >>> fib(5)\n  34\n  >>> fib(4)\n  14\n  >>> fib(3)\n  9\n  >>> fib(2)\n  1\n  >>> fib(7)\n  24\n  >>> fib(6)\n  55\n  >>> fib(5)\n  34\n  >>> fib(4)\n  14\n  >>> fib(3)\n  9\n  >>> fib(2)\n  1\n  >>> fib(7)\n  24\n  >>> fib(6)\n  55\n  >>> fib(5)\n  34\n  >>> fib(4)\n  14\n  >>> fib(3)\n  9\n  >>> fib(2)\n  1\n  >>> fib(7)\n  24\n  >>> fib(6)\n  55\n  >>> fib(5)\n  34\n  >>> fib(4)\n  14\n  >>> fib(3)\n  9\n  >>> fib(2)\n  1\n  >>> fib(7)\n  24\n  >>> fib(6)\n  55\n  >>> fib(5)\n  34\n  >>> fib(4)\n  14\n  >>> fib(3)\n  9\n  >>> fib(2)\n  1\n  >>> fib(7)\n  24\n  >>> fib(6)\n  55\n  >>> fib(5)\n  34\n  >>> fib(4)\n  14\n  >>> fib(3)\n  9\n  >>> fib(2)\n  1\n  >>> fib(7)\n  24\n  >>> fib(6)\n  55\n  >>> fib(5)\n  34\n  >>> fib(4)\n  14\n  >>> fib(3)\n  9\n  >>> fib(2)\n  1\n  >>> fib(7)\n  24\n  >>> fib(6)\n  55\n  >>> fib(5)\n  34\n  >>> fib(4)\n  14\n  >>> fib(3)\n  9\n  >>> fib(2)\n  1\n  >>> fib(7)\n  24\n  >>> fib(6)\n  55\n  >>> fib(5)\n  34\n  >>> fib(4)\n  14\n  >>> fib(3)\n  9\n  >>> fib(2)\n  1\n  >>> fib(7)\n  24\n  >>> fib(6)\n  55\n  >>> fib(5)\n  34\n  >>> fib(4)\n  14\n  >>> fib(3)\n  9\n  >>> fib(2)\n  1\n  >>> fib(7)\n  24\n  >>> fib(6)\n  55\n  >>> fib(5)\n  34\n  >>> fib(4)\n  14\n  >>> fib(3)\n  9\n  >>> fib(2)\n  1\n  >>> fib(7)\n  24\n  >>> fib(6)\n  55\n  >>> fib(5)\n  34\n  >>> fib(4)\n  14\n  >>> fib(3)\n  9\n  >>> fib(2)\n  1\n  >>> fib(7)\n  24\n  >>> fib(6)\n  55\n  >>> fib(5)\n  34\n  >>> fib(4)\n  14\n  >>> fib(3)\n  9\n  >>> fib(2)\n  1\n  >>> fib(7)\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">.\" returns false if each opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string of \"<\" and \">.\" returns false if each opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketingRegex = new RegExp(`^${brackets}+$`);\n  return bracketingRegex.test(string);\n};\n\n/**\n * Checks if a string is a valid JSON string.\n *\n * Valid JSON strings are valid JavaScript objects and arrays. All other strings are invalid JSON.\n *\n * Valid JSON strings can be parsed by JSON.parse().\n *\n * Valid JSON strings can be stringified with JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.stringify().\n *\n * Valid JSON strings can be converted to a JavaScript object or array using JSON.parse().\n *\n * Valid JSON strings can be converted to a JavaScript object or array ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/57", "prompt": "/*RIt is true that list elements monotonously increase or decrease.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*RIt is true that list elements monotonously increase or decrease.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let i = l.length - 1;\n  let j = 0;\n  let k = 0;\n  let res = true;\n  while (i > 0) {\n    if (l[j] < l[k]) {\n      res = false;\n      break;\n    }\n    k = j;\n    j = i;\n    i = i - 1;\n  }\n  return res;\n};\n\n/**\n * Returns true if the given array is sorted.\n *\n * @param {Array} arr\n * @return {Boolean}\n */\nconst sorted = (arr) => {\n  return arr.sort().join('') === arr.join('');\n};\n\n/**\n * Returns true if the given array is sorted.\n *\n * @param {Array} arr\n * @return {Boolean}\n */\nconst sortedEqual = (arr) => {\n  return arr.sort().join('') === arr.join('');\n};\n\n/**\n * Returns true if the given array is sorted.\n *\n * @param {Array} arr\n * @return {Boolean}\n */\nconst sortedEqualIgnoreCase = (arr) => {\n  return arr.sort().join('') === arr.join('');\n};\n\n/**\n * Returns true if the given array is sorted.\n *\n * @param {Array} arr\n * @return {Boolean}\n */\nconst sortedEqualIgnoreCaseIgnoreCase = (arr) => {\n  return arr.sort().join('') === arr.join('');\n};\n\n/**\n * Returns true if the given array is sorted.\n *\n * @param {Array} arr\n * @return {Boolean}\n */\nconst sortedEqualIgnoreCaseIgnoreCaseIgnoreCase = (arr) => {\n  return arr.sort().join('') === arr.join('');\n};\n\n/**\n * Returns true if the given array is sorted.\n *\n * @param {Array} arr\n * @return {Boolean}\n */\nconst sortedEqualIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (arr) => {\n  return arr.sort().join('') === arr.join('');\n};\n\n/**\n * Returns true if the given array is sorted.\n *\n * @param {Array} arr\n * @return {Boolean}\n */\nconst sortedEqualIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (arr) => {\n  return arr.sort().join('') === arr.join('');\n};\n\n/**\n * Returns true if the given array is sorted.\n *\n * @param {Array} arr\n * @return {Boolean}\n */\nconst sortedEqualIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (arr) => {\n  return arr.sort().join('') === arr.join('');\n};\n\n/**\n * Returns true if the given array is sorted.\n *\n * @param {Array} arr\n * @return {Boolean}\n */\nconst sortedEqualIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (arr) => {\n  return arr.sort().join('') === arr.join('');\n};\n\n/**\n * Returns true if the given array is sorted.\n *\n * @param {Array} arr\n * @return {Boolean}\n */\nconst sortedEqualIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/58", "prompt": "/*RHe sorted out unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*RHe sorted out unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set();\n  const set1 = new Set();\n  const set2 = new Set();\n  const set3 = new Set();\n  const set4 = new Set();\n  const set5 = new Set();\n  const set6 = new Set();\n  const set7 = new Set();\n  const set8 = new Set();\n  const set9 = new Set();\n  const set10 = new Set();\n  const set11 = new Set();\n  const set12 = new Set();\n  const set13 = new Set();\n  const set14 = new Set();\n  const set15 = new Set();\n  const set16 = new Set();\n  const set17 = new Set();\n  const set18 = new Set();\n  const set19 = new Set();\n  const set20 = new Set();\n  const set21 = new Set();\n  const set22 = new Set();\n  const set23 = new Set();\n  const set24 = new Set();\n  const set25 = new Set();\n  const set26 = new Set();\n  const set27 = new Set();\n  const set28 = new Set();\n  const set29 = new Set();\n  const set30 = new Set();\n  const set31 = new Set();\n  const set32 = new Set();\n  const set33 = new Set();\n  const set34 = new Set();\n  const set35 = new Set();\n  const set36 = new Set();\n  const set37 = new Set();\n  const set38 = new Set();\n  const set39 = new Set();\n  const set40 = new Set();\n  const set41 = new Set();\n  const set42 = new Set();\n  const set43 = new Set();\n  const set44 = new Set();\n  const set45 = new Set();\n  const set46 = new Set();\n  const set47 = new Set();\n  const set48 = new Set();\n  const set49 = new Set();\n  const set50 = new Set();\n  const set51 = new Set();\n  const set52 = new Set();\n  const set53 = new Set();\n  const set54 = new Set();\n  const set55 = new Set();\n  const set56 = new Set();\n  const set57 = new Set();\n  const set58 = new Set();\n  const set59 = new Set();\n  const set60 = new Set();\n  const set61 = new Set();\n  const set62 = new Set();\n  const set63 = new Set();\n  const set64 = new Set();\n  const set65 = new Set();\n  const set66 = new Set();\n  const set67 = new Set();\n  const set68 = new Set();\n  const set69 = new Set();\n  const set70 = new Set();\n  const set71 = new Set();\n  const set72 = new Set();\n  const set73 = new Set();\n  const set74 = new Set();\n  const set75 = new Set();\n  const set76 = new Set();\n  const set77 = new Set();\n  const set78 = new Set();\n  const set79 = new Set();\n  const set80 = new Set();\n  const set81 = new Set();\n  const set82 = new Set();\n  const set83 = new Set();\n  const set84 = new Set();\n  const set85 = new Set();\n  const set86 = new Set();\n  const set87 = new Set();\n  const set88 = new Set();\n  const set89 = new Set();\n  const set90 = new Set();\n  const set91 = new Set();\n  const set92 = new Set();\n  const set93 = new Set();\n  const set94 = new Set();\n  const set95 = new Set();\n  const set96 = new Set();\n  const set97 = new Set();\n  const set98 = new Set();\n  const set99 = new Set();\n  const set100 = new Set();\n  const set101 = new Set();\n  const set102 = new Set();\n  const set103 = new Set();\n  const set104 = new Set();\n  const set105 = new Set();\n  const set106 = new Set();\n  const set107 = new Set();\n  const set108 = new Set();\n  const set109 = new Set();\n  const set110 = new Set();\n  const set111 = new Set();\n  const set112 = new Set();\n  const set113 = new Set();\n  const set114 = new Set();\n  const set115 = new Set();\n  const set116 = new Set();\n  const set117 = new Set();\n  const set118 = new Set();\n  const set119 = new Set();\n  const set120 = new Set();\n  const set121 = new Set();\n  const set122 = new Set();\n  const set123 = new Set();\n  const set124 = new Set();\n  const set125 = new Set();\n  const set126 = new Set();\n  const set127 = new Set();\n  const set128 = new Set();\n  const set129 = new Set();\n  const set130 = new Set();\n  const set131 = new Set();\n  const set132 = new Set();\n  const set133 = new Set();\n  const set134 = new Set();\n  const set135 = new Set();\n  const set136 = new Set();\n  const set137 = new Set();\n  const set138 = new Set();\n  const set139 = new Set();\n  const set140 = new Set();\n  const set141 = new Set();\n  const set142 = new Set();\n  const set143 = new Set();\n  const set144 = new Set();\n  const set145 = new Set();\n  const set146 = new Set();\n  const set147 = new Set();\n  const set148 = new Set();\n  const set149 = new Set();\n  const set150 = new Set();\n  const set151 = new Set();\n  const set152 = new Set();\n  const set153 = new Set();\n  const set154 = new Set();\n  const set155 = new Set();\n  const set156 = new Set();\n  const set157 = new Set();\n  const set158 = new Set();\n  const set159 = new Set();\n  const set160 = new Set();\n  const set161 = new Set();\n  const set162 = new Set();\n  const set163 = new Set();\n  const set164 = new Set();\n  const set165 = new Set();\n  const set166 = new Set();\n  const set167 = new Set();\n  const set168 = new Set();\n  const set169 = new Set();\n  const set170 = new Set();\n  const set171 = new Set();\n  const set172 = new Set();\n  const set173 = new Set();\n  const set174 = new Set();\n  const set175 = new Set();\n  const set176 = new Set();\n  const set177 = new Set();\n  const set178 = new Set();\n  const set179 = new Set();\n  const set180 = new Set();\n  const set181 = new Set();\n  const set182 = new Set();\n  const set183 = new Set();\n  const set184 = new Set();\n  const set185 = new Set();\n  const set186 = new Set();\n  const set187 = new Set();\n  const set188 = new Set();\n  const set189 = new Set();\n  const set190 = new Set();\n  const set191 = new Set();\n  const set192 = new Set();\n  const set193 = new Set();\n  const set194 = new Set();\n  const set195 = new Set();\n  const set196 = new Set();\n  const set197 = new Set();\n  const set198 = new Set();\n  const set199 = new Set();\n  const set200 = new ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/59", "prompt": "/*RSuppose n > 1 and is not a prime number.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*RSuppose n > 1 and is not a prime number.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor++;\n  }\n  return factor;\n};\n\n/*\n  Given a number, return its prime factors.\n  >>> primeFactors(13195)\n  [2, 3, 5, 7]\n  >>> primeFactors(2048)\n  [2, 3, 5]\n  */\nconst primeFactors = (n) => {\n  let factors = [];\n  let primeFactor = 1;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      factors.push(primeFactor);\n      primeFactor++;\n    }\n  }\n  return factors;\n};\n\n/*\n  Given a number, return its prime factors.\n  >>> primeFactors(13195)\n  [2, 3, 5, 7]\n  >>> primeFactors(2048)\n  [2, 3, 5]\n  */\nconst primeFactorsFast = (n) => {\n  let factors = [];\n  let primeFactor = 1;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      factors.push(primeFactor);\n      primeFactor++;\n    }\n  }\n  return factors;\n};\n\n/*\n  Given a number, return its prime factors.\n  >>> primeFactors(13195)\n  [2, 3, 5, 7]\n  >>> primeFactors(2048)\n  [2, 3, 5]\n  */\nconst primeFactorsFast2 = (n) => {\n  let factors = [];\n  let primeFactor = 1;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      factors.push(primeFactor);\n      primeFactor++;\n    }\n  }\n  return factors;\n};\n\n/*\n  Given a number, return its prime factors.\n  >>> primeFactors(13195)\n  [2, 3, 5, 7]\n  >>> primeFactors(2048)\n  [2, 3, 5]\n  */\nconst primeFactorsFast3 = (n) => {\n  let factors = [];\n  let primeFactor = 1;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      factors.push(primeFactor);\n      primeFactor++;\n    }\n  }\n  return factors;\n};\n\n/*\n  Given a number, return its prime factors.\n  >>> primeFactors(13195)\n  [2, 3, 5, 7]\n  >>> primeFactors(2048)\n  [2, 3, 5]\n  */\nconst primeFactorsFast4 = (n) => {\n  let factors = [];\n  let primeFactor = 1;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      factors.push(primeFactor);\n      primeFactor++;\n    }\n  }\n  return factors;\n};\n\n/*\n  Given a number, return its prime factors.\n  >>> primeFactors(13195)\n  [2, 3, 5, 7]\n  >>> primeFactors(2048)\n  [2, 3, 5]\n  */\nconst primeFactorsFast5 = (n) => {\n  let factors = [];\n  let primeFactor = 1;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      factors.push(primeFactor);\n      primeFactor++;\n    }\n  }\n  return factors;\n};\n\n/*\n  Given a number, return its prime factors.\n  >>> primeFactors(13195)\n  [2, 3, 5, 7]\n  >>> primeFactors(2048)\n  [2, 3, 5]\n  */\nconst primeFactorsFast6 = (n) => {\n  let factors = [];\n  let primeFactor = 1;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      factors.push(primeFactor);\n      primeFactor++;\n    }\n  }\n  return factors;\n};\n\n/*\n  Given a number, return its prime factors.\n  >>> primeFactors(13195)\n  [2, 3, 5, 7]\n  >>> primeFactors(2048)\n  [2, 3, 5]\n  */\nconst primeFactorsFast7 = (n) => {\n  let factors = [];\n  let primeFactor = 1;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      factors.push(primeFactor);\n      primeFactor++;\n    }\n  }\n  return factors;\n};\n\n/*\n  Given a number, return its prime factors.\n  >>> primeFactors(13195)\n  [2, 3, 5, 7]\n  >>> primeFactors(2048)\n  [2, 3, 5]\n  */\nconst primeFactorsFast8 = (n) => {\n  let factors = [];\n  let primeFactor = 1;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      factors.push(primeFactor);\n      primeFactor++;\n    }\n  }\n  return factors;\n};\n\n/*\n  Given a number, return its prime factors.\n  >>> primeFactors(13195)\n  [2, 3, 5, 7]\n  >>> primeFactors(2048)\n  [2, 3, 5]\n  */\nconst primeFactorsFast9 = (n) => {\n  let factors = [];\n  let primeFactor = 1;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      factors.push(primeFactor);\n      primeFactor++;\n    }\n  }\n  return factors;\n};\n\n/*\n  Given a number, return its prime factors.\n  >>> primeFactors(13195)\n  [2, 3, 5, 7]\n  >>> primeFactors(2048)\n  [2, 3, 5]\n  */\nconst primeFactorsFast10 = (n) => {\n  let factors = [];\n  let primeFactor = 1;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      factors.push(primeFactor);\n      primeFactor++;\n    }\n  }\n  return factors;\n};\n\n/*\n  Given a number, return its prime factors.\n  >>> primeFactors(13195)\n  [2, 3, 5, 7]\n  >>> primeFactors(2048)\n  [2, 3, 5]\n  */\nconst primeFactorsFast11 = (n) => {\n  let factors = [];\n  let primeFactor = 1;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      factors.push(primeFactor);\n      primeFactor++;\n    }\n  }\n  return factors;\n};\n\n/*\n  Given a number, return its prime factors.\n  >>> primeFactors(13195)\n  [2, 3, 5, 7]\n  >>> primeFactors(2048)\n  [2, 3, 5]\n  */\nconst primeFactorsFast12 = (n) => {\n  let factors = [];\n  let primeFactor = 1;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      factors.push(primeFactor);\n      primeFactor++;\n    }\n  }\n  return factors;\n};\n\n/*\n  Given a number, return its prime factors.\n  >>> primeFactors(13195)\n  [2, 3, 5, 7]\n  >>> primeFactors(2048)\n  [2, 3, 5]\n  */\nconst primeFactorsFast13 = (n) => {\n  let factors = [];\n  let primeFactor = 1;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      factors.push(primeFactor);\n      primeFactor++;\n    }\n  }\n  return factors;\n};\n\n/*\n  Given a number, return its prime factors.\n  >>> primeFactors(13195)\n  [2, 3, 5, 7]\n  >>> primeFactors(2048)\n  [2, 3, 5]\n  */\nconst primeFactorsFast14 = (n) => {\n  let factors = [];\n  let primeFactor = 1;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      factors.push(primeFactor);\n      primeFactor++;\n    }\n  }\n  return factors;\n};\n\n/*\n  Given a number, return its prime factors.\n  >>> primeFactors(13195)\n  [2, 3, 5, 7]\n  >>> primeFactors(2048)\n  [2, 3, 5]\n  */\nconst primeFactorsFast15 = (n) => {\n  let factors = [];\n  let primeFactor = 1;\n  while (", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/6", "prompt": "/* Input to this function is a string representing multiple groups of nested brackets, separated by spaces. For each group, the lowest level of nesting of brackets is output. E.g. () ()) has a maximum of two levels of nesting, while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Input to this function is a string representing multiple groups of nested brackets, separated by spaces. For each group, the lowest level of nesting of brackets is output. E.g. () ()) has a maximum of two levels of nesting, while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_stack = []\n  const paren_stack_count = 0\n  const paren_stack_counts = []\n  const paren_stack_counts_lengths = []\n  const paren_stack_counts_lengths_lengths = []\n  const paren_stack_counts_lengths_lengths_lengths = []\n  const paren_stack_counts_lengths_lengths_lengths_lengths = []\n  const paren_stack_counts_lengths_lengths_lengths_lengths_lengths = []\n  const paren_stack_counts_lengths_lengths_lengths_lengths_lengths_lengths = []\n  const paren_stack_counts_lengths_lengths_lengths_lengths_lengths_lengths_lengths = []\n  const paren_stack_counts_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths = []\n  const paren_stack_counts_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths = []\n  const paren_stack_counts_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths = []\n  const paren_stack_counts_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths = []\n  const paren_stack_counts_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths = []\n  const paren_stack_counts_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths = []\n  const paren_stack_counts_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths = []\n  const paren_stack_counts_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths = []\n  const paren_stack_counts_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths = []\n  const paren_stack_counts_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths = []\n  const paren_stack_counts_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths = []\n  const paren_stack_counts_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths = []\n  const paren_stack_counts_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths = []\n  const paren_stack_counts_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths = []\n  const paren_stack_counts_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths = []\n  const paren_stack_counts_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths = []\n  const paren_stack_counts_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths = []\n  const paren_stack_counts_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths = []\n  const paren_stack_counts_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths = []\n  const paren_stack_counts_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths = []\n  const paren_stack_counts_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths = []\n  const paren_stack_counts_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a function that adds numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*sumToN is a function that adds numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all even numbers from 1 to n.\n  >>> sumEvens(30)\n  465\n  >>> sumEvens(100)\n  5050\n  >>> sumEvens(5)\n  15\n  >>> sumEvens(10)\n  55\n  >>> sumEvens(1)\n  1\n  */\nconst sumEvens = (num) => {\n  let sum = 0;\n  for (let i = 1; i <= num; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all odd numbers from 1 to n.\n  >>> sumOdds(30)\n  465\n  >>> sumOdds(100)\n  5050\n  >>> sumOdds(5)\n  15\n  >>> sumOdds(10)\n  55\n  >>> sumOdds(1)\n  1\n  */\nconst sumOdds = (num) => {\n  let sum = 0;\n  for (let i = 1; i <= num; i++) {\n    if (i % 2!== 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*\n  A function that returns the product of all numbers from 1 to n.\n  >>> product(30)\n  465\n  >>> product(100)\n  5050\n  >>> product(5)\n  15\n  >>> product(10)\n  55\n  >>> product(1)\n  1\n  */\nconst product = (num) => {\n  let product = 1;\n  for (let i = 1; i <= num; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*\n  A function that returns the product of all even numbers from 1 to n.\n  >>> productEvens(30)\n  465\n  >>> productEvens(100)\n  5050\n  >>> productEvens(5)\n  15\n  >>> productEvens(10)\n  55\n  >>> productEvens(1)\n  1\n  */\nconst productEvens = (num) => {\n  let product = 1;\n  for (let i = 1; i <= num; i++) {\n    if (i % 2 === 0) {\n      product *= i;\n    }\n  }\n  return product;\n};\n\n/*\n  A function that returns the product of all odd numbers from 1 to n.\n  >>> productOdds(30)\n  465\n  >>> productOdds(100)\n  5050\n  >>> productOdds(5)\n  15\n  >>> productOdds(10)\n  55\n  >>> productOdds(1)\n  1\n  */\nconst productOdds = (num) => {\n  let product = 1;\n  for (let i = 1; i <= num; i++) {\n    if (i % 2!== 0) {\n      product *= i;\n    }\n  }\n  return product;\n};\n\n/*\n  A function that returns the factorial of n.\n  >>> factorial(30)\n  120\n  >>> factorial(100)\n  720\n  >>> factorial(5)\n  5040\n  >>> factorial(10)\n  40320\n  >>> factorial(1)\n  1\n  */\nconst factorial = (n) => {\n  let fact = 1;\n  for (let i = 1; i <= n; i++) {\n    fact *= i;\n  }\n  return fact;\n};\n\n/*\n  A function that returns the factorial of n raised to the power n.\n  >>> factorialPower(30)\n  120\n  >>> factorialPower(100)\n  720\n  >>> factorialPower(5)\n  5040\n  >>> factorialPower(10)\n  40320\n  >>> factorialPower(1)\n  1\n  */\nconst factorialPower = (n) => {\n  let fact = 1;\n  for (let i = 1; i <= n; i++) {\n    fact *= i;\n  }\n  return fact ** n;\n};\n\n/*\n  A function that returns the sum of all numbers from 1 to n.\n  >>> sumOfNumbers(30)\n  465\n  >>> sumOfNumbers(100)\n  5050\n  >>> sumOfNumbers(5)\n  15\n  >>> sumOfNumbers(10)\n  55\n  >>> sumOfNumbers(1)\n  1\n  */\nconst sumOfNumbers = (num) => {\n  let sum = 0;\n  for (let i = 1; i <= num; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all even numbers from 1 to n.\n  >>> sumOfEvenNumbers(30)\n  465\n  >>> sumOfEvenNumbers(100)\n  5050\n  >>> sumOfEvenNumbers(5)\n  15\n  >>> sumOfEvenNumbers(10)\n  55\n  >>> sumOfEvenNumbers(1)\n  1\n  */\nconst sumOfEvenNumbers = (num) => {\n  let sum = 0;\n  for (let i = 1; i <= num; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all odd numbers from 1 to n.\n  >>> sumOfOddNumbers(30)\n  465\n  >>> sumOfOddNumbers(100)\n  5050\n  >>> sumOfOddNumbers(5)\n  15\n  >>> sumOfOddNumbers(10)\n  55\n  >>> sumOfOddNumbers(1)\n  1\n  */\nconst sumOfOddNumbers = (num) => {\n  let sum = 0;\n  for (let i = 1; i <= num; i++) {\n    if (i % 2!== 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all numbers from 1 to n.\n  >>> sumOfNumbersEven(30)\n  465\n  >>> sumOfNumbersEven(100)\n  5050\n  >>> sumOfNumbersEven(5)\n  15\n  >>> sumOfNumbersEven(10)\n  55\n  >>> sumOfNumbersEven(1)\n  1\n  */\nconst sumOfNumbersEven = (num) => {\n  let sum = 0;\n  for (let i = 1; i <= num; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all even numbers from 1 to n.\n  >>> sumOfNumbersOdd(30)\n  465\n  >>> sumOfNumbersOdd(100)\n  5050\n  >>> sumOfNumbersOdd(5)\n  15\n  >>> sumOfNumbersOdd(10)\n  55\n  >>> sumOfNumbersOdd(1)\n  1\n  */\nconst sumOfNumbersOdd = (num) => {\n  let sum = 0;\n  for (let i = 1; i <= num; i++) {\n    if (i % 2!== 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all numbers from 1 to n.\n  >>> sumOfNumbersEvenOdd(30)\n  465\n  >>> sumOfNumbersEvenOdd(100)\n  5050\n  >>> sumOfNumbersEvenOdd(5)\n  15\n  >>> sumOfNumbersEvenOdd(10)\n  55\n  >>> sumOfNumbersEvenOdd(1)\n  1\n  */\nconst sumOfNumbersEvenOdd = (num) => {\n  let sum = 0;\n  for (let i = 1; i <= num; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \").\" returns true if each opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string of \"(\" and \").\" returns true if each opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const openingBrackets = brackets.match(/[^(]+/g);\n  const closingBrackets = brackets.match(/[^)]+/g);\n  return openingBrackets.every(opening => closingBrackets.every(closing => opening === closing));\n};\n\n/**\n * Returns true if a word is capitalized.\n *\n * >>> isCapitalized(\"Hello\")\n * true\n * >>> isCapitalized(\"Hello!\")\n * false\n */\nconst isCapitalized = (word) => {\n  return word[0] === word[0].toUpperCase() && word.length > 1;\n};\n\n/**\n * Returns true if a word is lowercased.\n *\n * >>> isLowercased(\"Hello\")\n * true\n * >>> isLowercased(\"Hello!\")\n * false\n */\nconst isLowercased = (word) => {\n  return word[0] === word[0].toLowerCase() && word.length > 1;\n};\n\n/**\n * Returns true if a word is uppercased.\n *\n * >>> isUppercased(\"Hello\")\n * true\n * >>> isUppercased(\"Hello!\")\n * false\n */\nconst isUppercased = (word) => {\n  return word[0] === word[0].toUpperCase() && word.length > 1;\n};\n\n/**\n * Returns true if a word is capitalized and lowercased.\n *\n * >>> isCapitalizedAndLowercased(\"Hello\")\n * true\n * >>> isCapitalizedAndLowercased(\"Hello!\")\n * false\n */\nconst isCapitalizedAndLowercased = (word) => {\n  return isCapitalized(word) && isLowercased(word);\n};\n\n/**\n * Returns true if a word is capitalized and uppercased.\n *\n * >>> isCapitalizedAndUppercased(\"Hello\")\n * true\n * >>> isCapitalizedAndUppercased(\"Hello!\")\n * false\n */\nconst isCapitalizedAndUppercased = (word) => {\n  return isCapitalized(word) && isUppercased(word);\n};\n\n/**\n * Returns true if a word is capitalized and lowercased and uppercased.\n *\n * >>> isCapitalizedAndLowercasedAndUppercased(\"Hello\")\n * true\n * >>> isCapitalizedAndLowercasedAndUppercased(\"Hello!\")\n * false\n */\nconst isCapitalizedAndLowercasedAndUppercased = (word) => {\n  return isCapitalizedAndLowercased(word) && isUppercasedAndUppercased(word);\n};\n\n/**\n * Returns true if a word is capitalized and lowercased and uppercased.\n *\n * >>> isCapitalizedAndLowercasedAndUppercased(\"Hello\")\n * true\n * >>> isCapitalizedAndLowercasedAndUppercased(\"Hello!\")\n * false\n */\nconst isCapitalizedAndLowercasedAndUppercasedAndCapitalized = (word) => {\n  return isCapitalizedAndLowercasedAndUppercased(word) && isCapitalized(word);\n};\n\n/**\n * Returns true if a word is capitalized and lowercased and uppercased.\n *\n * >>> isCapitalizedAndLowercasedAndUppercasedAndCapitalized(\"Hello\")\n * true\n * >>> isCapitalizedAndLowercasedAndUppercasedAndCapitalized(\"Hello!\")\n * false\n */\nconst isCapitalizedAndLowercasedAndUppercasedAndCapitalizedAndCapitalized = (word) => {\n  return isCapitalizedAndLowercasedAndUppercasedAndCapitalized(word) && isCapitalizedAndUppercased(word);\n};\n\n/**\n * Returns true if a word is capitalized and lowercased and uppercased.\n *\n * >>> isCapitalizedAndLowercasedAndUppercasedAndCapitalizedAndCapitalized(\"Hello\")\n * true\n * >>> isCapitalizedAndLowercasedAndUppercasedAndCapitalizedAndCapitalized(\"Hello!\")\n * false\n */\nconst isCapitalizedAndLowercasedAndUppercasedAndCapitalizedAndCapitalizedAndCapitalized = (word) => {\n  return isCapitalizedAndLowercasedAndUppercasedAndCapitalizedAndCapitalized(word) && isCapitalizedAndUppercased(word);\n};\n\n/**\n * Returns true if a word is capitalized and lowercased and uppercased.\n *\n * >>> isCapitalizedAndLowercasedAndUppercasedAndCapitalizedAndCapitalizedAndCapitalized(\"Hello\")\n * true\n * >>> isCapitalizedAndLowercasedAndUppercasedAndCapitalizedAndCapitalizedAndCapitalized(\"Hello!\")\n * false\n */\nconst isCapitalizedAndLowercasedAndUppercasedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalized = (word) => {\n  return isCapitalizedAndLowercasedAndUppercasedAndCapitalizedAndCapitalizedAndCapitalized(word) && isCapitalizedAndUppercased(word);\n};\n\n/**\n * Returns true if a word is capitalized and lowercased and uppercased.\n *\n * >>> isCapitalizedAndLowercasedAndUppercasedAndCapitalizedAndCapitalizedAndCapitalized(\"Hello\")\n * true\n * >>> isCapitalizedAndLowercasedAndUppercasedAndCapitalizedAndCapitalizedAndCapitalized(\"Hello!\")\n * false\n */\nconst isCapitalizedAndLowercasedAndUppercasedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalized = (word) => {\n  return isCapitalizedAndLowercasedAndUppercasedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalized(word) && isCapitalizedAndUppercased(word);\n};\n\n/**\n * Returns true if a word is capitalized and lowercased and uppercased.\n *\n * >>> isCapitalizedAndLowercasedAndUppercasedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalized(\"Hello\")\n * true\n * >>> isCapitalizedAndLowercasedAndUppercasedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalized(\"Hello!\")\n * false\n */\nconst isCapitalizedAndLowercasedAndUppercasedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalized = (word) => {\n  return isCapitalizedAndLowercasedAnd", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefficients of a polynomial. xs [0] + xs [1] * x + xs [2] * x ^ 2 +.... return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* xs represent coefficients of a polynomial. xs [0] + xs [1] * x + xs [2] * x ^ 2 +.... return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  let result = [];\n  for (let i = 0; i < xs.length; i++) {\n    const x = xs[i];\n    const derivative = x * x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/63", "prompt": "/*TThe FibFib number sequence is a sequence similar to the Fibbonacci sequence, which is defined as follows: fibfib (0) = = 0 fibfib (1) = = 0 fibfib (2) = = 1 fibfib (n) = fibfib (n-1) + fibfib (n-2) + fibfib (n-3). Please write a function to efficiently calculate the nth element of the FibFib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*TThe FibFib number sequence is a sequence similar to the Fibbonacci sequence, which is defined as follows: fibfib (0) = = 0 fibfib (1) = = 0 fibfib (2) = = 1 fibfib (n) = fibfib (n-1) + fibfib (n-2) + fibfib (n-3). Please write a function to efficiently calculate the nth element of the FibFib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n <= 1) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to calculate the nth element of the Fibonacci sequence using recursion.\n  >>> fibfib_rec(1)\n  0\n  >>> fibfib_rec(5)\n  4\n  >>> fibfib_rec(8)\n  24\n  */\nconst fibfib_rec = (n) => {\n  if (n <= 1) return 0;\n  return fibfib_rec(n - 1) + fibfib_rec(n - 2) + fibfib_rec(n - 3);\n};\n\n/*\n  Write a function to calculate the nth element of the Fibonacci sequence using recursion.\n  >>> fibfib_rec_fast(1)\n  0\n  >>> fibfib_rec_fast(5)\n  4\n  >>> fibfib_rec_fast(8)\n  24\n  */\nconst fibfib_rec_fast = (n) => {\n  if (n <= 1) return 0;\n  return fibfib_rec_fast(n - 1) + fibfib_rec_fast(n - 2) + fibfib_rec_fast(n - 3);\n};\n\n/*\n  Write a function to calculate the nth element of the Fibonacci sequence using recursion.\n  >>> fibfib_rec_fast_fast(1)\n  0\n  >>> fibfib_rec_fast_fast(5)\n  4\n  >>> fibfib_rec_fast_fast(8)\n  24\n  */\nconst fibfib_rec_fast_fast = (n) => {\n  if (n <= 1) return 0;\n  return fibfib_rec_fast_fast(n - 1) + fibfib_rec_fast_fast(n - 2) + fibfib_rec_fast_fast(n - 3);\n};\n\n/*\n  Write a function to calculate the nth element of the Fibonacci sequence using recursion.\n  >>> fibfib_rec_fast_fast_fast(1)\n  0\n  >>> fibfib_rec_fast_fast_fast(5)\n  4\n  >>> fibfib_rec_fast_fast_fast(8)\n  24\n  */\nconst fibfib_rec_fast_fast_fast = (n) => {\n  if (n <= 1) return 0;\n  return fibfib_rec_fast_fast_fast(n - 1) + fibfib_rec_fast_fast_fast(n - 2) + fibfib_rec_fast_fast_fast(n - 3);\n};\n\n/*\n  Write a function to calculate the nth element of the Fibonacci sequence using recursion.\n  >>> fibfib_rec_fast_fast_fast(1)\n  0\n  >>> fibfib_rec_fast_fast_fast(5)\n  4\n  >>> fibfib_rec_fast_fast_fast(8)\n  24\n  */\nconst fibfib_rec_fast_fast_fast_fast = (n) => {\n  if (n <= 1) return 0;\n  return fibfib_rec_fast_fast_fast_fast(n - 1) + fibfib_rec_fast_fast_fast_fast(n - 2) + fibfib_rec_fast_fast_fast_fast(n - 3);\n};\n\n/*\n  Write a function to calculate the nth element of the Fibonacci sequence using recursion.\n  >>> fibfib_rec_fast_fast_fast_fast(1)\n  0\n  >>> fibfib_rec_fast_fast_fast(5)\n  4\n  >>> fibfib_rec_fast_fast_fast(8)\n  24\n  */\nconst fibfib_rec_fast_fast_fast_fast = (n) => {\n  if (n <= 1) return 0;\n  return fibfib_rec_fast_fast_fast_fast(n - 1) + fibfib_rec_fast_fast_fast_fast(n - 2) + fibfib_rec_fast_fast_fast_fast(n - 3);\n};\n\n/*\n  Write a function to calculate the nth element of the Fibonacci sequence using recursion.\n  >>> fibfib_rec_fast_fast_fast(1)\n  0\n  >>> fibfib_rec_fast_fast_fast(5)\n  4\n  >>> fibfib_rec_fast_fast_fast(8)\n  24\n  */\nconst fibfib_rec_fast_fast_fast_fast_fast = (n) => {\n  if (n <= 1) return 0;\n  return fibfib_rec_fast_fast_fast_fast_fast(n - 1) + fibfib_rec_fast_fast_fast_fast_fast(n - 2) + fibfib_rec_fast_fast_fast_fast_fast(n - 3);\n};\n\n/*\n  Write a function to calculate the nth element of the Fibonacci sequence using recursion.\n  >>> fibfib_rec_fast_fast_fast_fast(1)\n  0\n  >>> fibfib_rec_fast_fast_fast(5)\n  4\n  >>> fibfib_rec_fast_fast_fast(8)\n  24\n  */\nconst fibfib_rec_fast_fast_fast_fast_fast_fast = (n) => {\n  if (n <= 1) return 0;\n  return fibfib_rec_fast_fast_fast_fast_fast_fast(n - 1) + fibfib_rec_fast_fast_fast_fast_fast_fast(n - 2) + fibfib_rec_fast_fast_fast_fast_fast_fast(n - 3);\n};\n\n/*\n  Write a function to calculate the nth element of the Fibonacci sequence using recursion.\n  >>> fibfib_rec_fast_fast_fast_fast_fast(1)\n  0\n  >>> fibfib_rec_fast_fast_fast(5)\n  4\n  >>> fibfib_rec_fast_fast_fast(8)\n  24\n  */\nconst fibfib_rec_fast_fast_fast_fast_fast_fast = (n) => {\n  if (n <= 1) return 0;\n  return fibfib_rec_fast_fast_fast_fast_fast_fast(n - 1) + fibfib_rec_fast_fast_fast_fast_fast_fast(n - 2) + fibfib_rec_fast_fast_fast_fast_fast_fast(n - 3);\n};\n\n/*\n  Write a function to calculate the nth element of the Fibonacci sequence using recursion.\n  >>> fibfib_rec_fast_fast_fast_fast_fast(1)\n  0\n  >>> fibfib_rec_fast_fast_fast(5)\n  4\n  >>> fibfib_rec_fast_fast_fast(8)\n  24\n  */\nconst fibfib_rec_fast_fast_fast_fast_fast_fast_fast = (n) => {\n  if (n <= 1) return 0;\n  return fibfib_rec_fast_fast_fast_fast_fast_fast_fast_fast(n - 1) + fibfib_rec_fast_fast_fast_fast_fast_fast_fast_fast(n - 2) + fibfib_rec_fast_fast_fast_fast_fast_fast_fast_fast(n - 3);\n};\n\n/*\n  Write a function to calculate the nth element of the Fibonacci sequence using recursion.\n  >>> fibfib_rec_fast_fast_fast_fast_fast(1)\n  0\n  >>> fibfib_rec_fast_fast_fast(5)\n  4\n  >>> fibfib_rec_fast_fast_fast(8)\n  24\n  */\nconst fibfib_rec_fast_fast_fast_fast_fast_fast_fast = (n) => {\n  if (n <= 1) return 0;\n  return fibfib_rec_fast_fast_fast_fast_fast_fast_fast_fast(n - 1) + fibfib_rec_fast_fast_fast_fast_fast_fast_fast_fast_fast(n - 2) + fibfib_rec_fast_fast_fast_fast_fast_fast_fast_fast_fast(n - 3);\n};\n\n/*\n  Write a function to calculate the nth element of the Fibonacci sequence using recursion.\n  >>> fibfib_rec_fast_fast_fast_fast_fast(1)\n  0\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/64", "prompt": "/*Write is a vowel count function that takes a string that represents a word as input and returns the number of vowels in the string. In this case, vowels are \"a,\" \"e,\" \"i,\" \"o,\" \"u.\" Again, \"y\" is a vowel, but only if it is at the end of the given word. Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Write is a vowel count function that takes a string that represents a word as input and returns the number of vowels in the string. In this case, vowels are \"a,\" \"e,\" \"i,\" \"o,\" \"u.\" Again, \"y\" is a vowel, but only if it is at the end of the given word. Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  let lastVowelVowel = s.charAt(s.length - 2);\n  let lastVowelVowelVowel = s.charAt(s.length - 3);\n  let lastVowelVowelVowelVowel = s.charAt(s.length - 4);\n  let lastVowelVowelVowelVowelVowel = s.charAt(s.length - 5);\n  let lastVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 6);\n  let lastVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 7);\n  let lastVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 8);\n  let lastVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 9);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 10);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 11);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 12);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 13);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 14);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 15);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 16);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 17);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 18);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 19);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 20);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 21);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 22);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 23);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 24);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 25);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 26);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 27);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 28);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 29);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 30);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 31);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 32);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 33);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 34);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 35);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 36);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 37);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowel = s.charAt(s.length - 38);\n  let lastVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowel", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/65", "prompt": "/*Circular displacement of digits of integer x, displacement of digits to the right by displacing and returning the result as a string. If displacement > number of digits, return the digits inversely.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Circular displacement of digits of integer x, displacement of digits to the right by displacing and returning the result as a string. If displacement > number of digits, return the digits inversely.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  const digits = Math.ceil(Math.log10(Math.abs(x))) + 1;\n  let result = \"\";\n  let digit;\n\n  for (let i = 0; i < digits; i++) {\n    digit = x % 10;\n    result += digits[digit];\n    x = Math.floor(x / 10);\n  }\n\n  return result + digits[digit];\n};\n\n/**\n * Converts a string to a number by parsing it into an array of digits and then converting the digits into their decimal equivalent using radix 10. Returns NaN if parsing fails.\n * >>> parseInt(\"12\")\n  12\n  >>> parseInt(\"12\", 10)\n  12\n  >>> parseInt(\"12\", 10)\n  NaN\n  */\nconst parseInt = str => {\n  const digits = str.split(\"\").map(digit => parseInt(digit, 10));\n  return digits.reduce((acc, digit) => acc + digit, 0);\n};\n\n/**\n * Converts a string to a number by parsing it into an array of digits and then converting the digits into their decimal equivalent using radix 10. Returns NaN if parsing fails.\n * >>> parseInt(\"12\", 10)\n  12\n  >>> parseInt(\"12\", 10)\n  12\n  >>> parseInt(\"12\", 10)\n  NaN\n  */\nconst parseInt10 = str => {\n  const digits = str.split(\"\").map(digit => parseInt(digit, 10));\n  return digits.reduce((acc, digit) => acc + digit * 10, 0);\n};\n\n/**\n * Converts a string to a number by parsing it into an array of digits and then converting the digits into their decimal equivalent using radix 10. Returns NaN if parsing fails.\n * >>> parseInt(\"12\", 10)\n  12\n  >>> parseInt(\"12\", 10)\n  12\n  >>> parseInt(\"12\", 10)\n  NaN\n  */\nconst parseInt100 = str => {\n  const digits = str.split(\"\").map(digit => parseInt(digit, 10));\n  return digits.reduce((acc, digit) => acc + digit * 100, 0);\n};\n\n/**\n * Converts a string to a number by parsing it into an array of digits and then converting the digits into their decimal equivalent using radix 10. Returns NaN if parsing fails.\n * >>> parseInt(\"12\", 10)\n  12\n  >>> parseInt(\"12\", 10)\n  12\n  >>> parseInt(\"12\", 10)\n  NaN\n  */\nconst parseInt1000 = str => {\n  const digits = str.split(\"\").map(digit => parseInt(digit, 10));\n  return digits.reduce((acc, digit) => acc + digit * 1000, 0);\n};\n\n/**\n * Converts a string to a number by parsing it into an array of digits and then converting the digits into their decimal equivalent using radix 10. Returns NaN if parsing fails.\n * >>> parseInt(\"12\", 10)\n  12\n  >>> parseInt(\"12\", 10)\n  12\n  >>> parseInt(\"12\", 10)\n  NaN\n  */\nconst parseInt10000 = str => {\n  const digits = str.split(\"\").map(digit => parseInt(digit, 10));\n  return digits.reduce((acc, digit) => acc + digit * 10000, 0);\n};\n\n/**\n * Converts a string to a number by parsing it into an array of digits and then converting the digits into their decimal equivalent using radix 10. Returns NaN if parsing fails.\n * >>> parseInt(\"12\", 10)\n  12\n  >>> parseInt(\"12\", 10)\n  12\n  >>> parseInt(\"12\", 10)\n  NaN\n  */\nconst parseInt100000 = str => {\n  const digits = str.split(\"\").map(digit => parseInt(digit, 10));\n  return digits.reduce((acc, digit) => acc + digit * 100000, 0);\n};\n\n/**\n * Converts a string to a number by parsing it into an array of digits and then converting the digits into their decimal equivalent using radix 10. Returns NaN if parsing fails.\n * >>> parseInt(\"12\", 10)\n  12\n  >>> parseInt(\"12\", 10)\n  12\n  >>> parseInt(\"12\", 10)\n  NaN\n  */\nconst parseInt1000000 = str => {\n  const digits = str.split(\"\").map(digit => parseInt(digit, 10));\n  return digits.reduce((acc, digit) => acc + digit * 1000000, 0);\n};\n\n/**\n * Converts a string to a number by parsing it into an array of digits and then converting the digits into their decimal equivalent using radix 10. Returns NaN if parsing fails.\n * >>> parseInt(\"12\", 10)\n  12\n  >>> parseInt(\"12\", 10)\n  12\n  >>> parseInt(\"12\", 10)\n  NaN\n  */\nconst parseInt10000000 = str => {\n  const digits = str.split(\"\").map(digit => parseInt(digit, 10));\n  return digits.reduce((acc, digit) => acc + digit * 10000000, 0);\n};\n\n/**\n * Converts a string to a number by parsing it into an array of digits and then converting the digits into their decimal equivalent using radix 10. Returns NaN if parsing fails.\n * >>> parseInt(\"12\", 10)\n  12\n  >>> parseInt(\"12\", 10)\n  12\n  >>> parseInt(\"12\", 10)\n  NaN\n  */\nconst parseInt100000000 = str => {\n  const digits = str.split(\"\").map(digit => parseInt(digit, 10));\n  return digits.reduce((acc, digit) => acc + digit * 100000000, 0);\n};\n\n/**\n * Converts a string to a number by parsing it into an array of digits and then converting the digits into their decimal equivalent using radix 10. Returns NaN if parsing fails.\n * >>> parseInt(\"12\", 10)\n  12\n  >>> parseInt(\"12\", 10)\n  12\n  >>> parseInt(\"12\", 10)\n  NaN\n  */\nconst parseInt1000000000 = str => {\n  const digits = str.split(\"\").map(digit => parseInt(digit, 10));\n  return digits.reduce((acc, digit) => acc + digit * 1000000000, 0);\n};\n\n/**\n * Converts a string to a number by parsing it into an array of digits and then converting the digits into their decimal equivalent using radix 10. Returns NaN if parsing fails.\n * >>> parseInt(\"12\", 10)\n  12\n  >>> parseInt(\"12\", 10)\n  12\n  >>> parseInt(\"12\", 10)\n  NaN\n  */\nconst parseInt10000000000 = str => {\n  const digits = str.split(\"\").map(digit => parseInt(digit, 10));\n  return digits.reduce((acc, digit) => acc + digit * 10000000000, 0);\n};\n\n/**\n * Converts a string to a number by parsing it into an array of digits and then converting the digits into their decimal equivalent using radix 10. Returns NaN if parsing fails.\n * >>> parseInt(\"12\", 10)\n  12\n  >>> parseInt(\"12\", 10)\n  12\n  >>> parseInt(\"12\", 10)\n  NaN\n  */\nconst parseInt100000000000 = str => {\n  const digits = str.split(\"\").map(digit => parseInt(digit, 10));\n  return digits.reduce((acc, digit) => acc + digit * 100000000000, 0);\n};\n\n/**\n * Converts a string to a number by parsing it into an array of digits and then converting the digits into their decimal equivalent using radix 10. Returns NaN if parsing fails.\n * >>> parseInt(\"", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/66", "prompt": "/*Task Writes a function that takes a string as input and returns only the sum of the upper letters of 'ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Task Writes a function that takes a string as input and returns only the sum of the upper letters of 'ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the lower letters of 'ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSumLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the upper and lower case letters of 'ASCII codes.\n\n  Examples:\n      digitSumLower(\"\") => 0\n      digitSumLower(\"abAB\") => 131\n      digitSumLower(\"abcCd\") => 67\n      digitSumLower(\"helloE\") => 69\n      digitSumLower(\"woArBld\") => 131\n      digitSumLower(\"aAaaaXa\") => 153\n  */\nconst digitSumLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the digits of 'ASCII codes.\n\n  Examples:\n      digitSumDigit(\"\") => 0\n      digitSumDigit(\"abAB\") => 131\n      digitSumDigit(\"abcCd\") => 67\n      digitSumDigit(\"helloE\") => 69\n      digitSumDigit(\"woArBld\") => 131\n      digitSumDigit(\"aAaaaXa\") => 153\n  */\nconst digitSumDigit = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the digits of 'ASCII codes.\n\n  Examples:\n      digitSumDigit(\"\") => 0\n      digitSumDigit(\"abAB\") => 131\n      digitSumDigit(\"abcCd\") => 67\n      digitSumDigit(\"helloE\") => 69\n      digitSumDigit(\"woArBld\") => 131\n      digitSumDigit(\"aAaaaXa\") => 153\n  */\nconst digitSumDigitLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the digits of 'ASCII codes.\n\n  Examples:\n      digitSumDigitLower(\"\") => 0\n      digitSumDigitLower(\"abAB\") => 131\n      digitSumDigitLower(\"abcCd\") => 67\n      digitSumDigitLower(\"helloE\") => 69\n      digitSumDigitLower(\"woArBld\") => 131\n      digitSumDigitLower(\"aAaaaXa\") => 153\n  */\nconst digitSumDigitLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the digits of 'ASCII codes.\n\n  Examples:\n      digitSumDigit(\"\") => 0\n      digitSumDigit(\"abAB\") => 131\n      digitSumDigit(\"abcCd\") => 67\n      digitSumDigit(\"helloE\") => 69\n      digitSumDigit(\"woArBld\") => 131\n      digitSumDigit(\"aAaaaXa\") => 153\n  */\nconst digitSumDigitDigit = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the digits of 'ASCII codes.\n\n  Examples:\n      digitSumDigit(\"\") => 0\n      digitSumDigit(\"abAB\") => 131\n      digitSumDigit(\"abcCd\") => 67\n      digitSumDigit(\"helloE\") => 69\n      digitSumDigit(\"woArBld\") => 131\n      digitSumDigit(\"aAaaaXa\") => 153\n  */\nconst digitSumDigitDigitLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the digits of 'ASCII codes.\n\n  Examples:\n      digitSumDigitDigit(\"\") => 0\n      digitSumDigitDigit(\"abAB\") => 131\n      digitSumDigitDigit(\"abcCd\") => 67\n      digitSumDigitDigit(\"helloE\") => 69\n      digitSumDigitDigit(\"woArBld\") => 131\n      digitSumDigitDigit(\"aAaaaXa\") => 153\n  */\nconst digitSumDigitDigitLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the digits of 'ASCII codes.\n\n  Examples:\n      digitSumDigitDigit(\"\") => 0\n      digitSumDigitDigit(\"abAB\") => 131\n      digitSumDigitDigit(\"abcCd\") => 67\n      digitSumDigitDigit(\"helloE\") => 69\n      digitSumDigitDigit(\"woArBld\") => 131\n      digitSumDigitDigit(\"aAaaaXa\") => 153\n  */\nconst digitSumDigitDigit = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the digits of 'ASCII codes.\n\n  Examples:\n      digitSumDigitDigit(\"\") => 0\n      digitSumDigitDigit(\"abAB\") => 131\n      digitSumDigitDigit(\"abcCd\") => 67\n      digitSumDigitDigit(\"helloE\") => 69\n      digitSumDigitDigit(\"woArBld\") => 131\n      digitSumDigitDigit(\"aAaaaXa\") => 153\n  */\nconst digitSumDigitDigitLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the digits of 'ASCII codes.\n\n  Examples:\n      digitSumDigitDigit(\"\") => 0\n      digitSumDigitDigit(\"abAB\") => 131\n      digitSumDigitDigit(\"abcCd\") => 67\n      digitSumDigitDigit(\"helloE\") => 69\n      digitSumDigitDigit(\"woArBld\") => 131\n      digit", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let fruits = n.split(\" \").map(Number);\n  fruits.forEach((fruit) => {\n    total += fruit;\n  });\n  return total - fruits.length;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let fruits = n.split(\" \").map(Number);\n  fruits.forEach((fruit) => {\n    total += fruit;\n  });\n  return total - fruits.length;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let fruits = n.split(\" \").map(Number);\n  fruits.forEach((fruit) => {\n    total += fruit;\n  });\n  return total - fruits.length;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let fruits = n.split(\" \").map(Number);\n  fruits.forEach((fruit) => {\n    total += fruit;\n  });\n  return total - fruits.length;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let fruits = n.split(\" \").map(Number);\n  fruits.forEach((fruit) => {\n    total += fruit;\n  });\n  return total - fruits.length;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let fruits = n.split(\" \").map(Number);\n  fruits.forEach((fruit) => {\n    total += fruit;\n  });\n  return total - fruits.length;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let fruits = n.split(\" \").map(Number);\n  fruits.forEach((fruit) => {\n    total += fruit;\n  });\n  return total - fruits.length;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to pluck one of the nodes and return it.\n  The plucked node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The plucked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to pluck one of the nodes and return it.\n  The plucked node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The plucked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const len = arr.length;\n  let result = [];\n  let even = 0;\n  let min = 0;\n  let index = 0;\n\n  for (let i = 0; i < len; i++) {\n    if (arr[i] % 2 === 0) {\n      even = arr[i];\n      min = i;\n    }\n  }\n\n  if (even === 0 && min === len) {\n    return [];\n  }\n\n  for (let i = 0; i < len; i++) {\n    if (arr[i] % 2 === 0) {\n      result.push(arr[min]);\n      index = min;\n    }\n  }\n\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-minimum-number-of-consecutive-zeroes-in-an-array/\n// https://leetcode.com/problems/find-the-minimum-number-of-consecutive-zeroes-in-an-array/discuss/7871/Java-Solution-for-the-Minimum-Number-of-Consecutive-Zeroes-in-an-Array\n// https://leetcode.com/problems/find-the-minimum-number-of-consecutive-zeroes-in-an-array/discuss/7871/Java-Solution-for-the-Minimum-Number-of-Consecutive-Zeroes-in-an-Array\n// https://leetcode.com/problems/find-the-minimum-number-of-consecutive-zeroes-in-an-array/discuss/7871/Java-Solution-for-the-Minimum-Number-of-Consecutive-Zeroes-in-an-Array\n// https://leetcode.com/problems/find-the-minimum-number-of-consecutive-zeroes-in-an-array/discuss/7871/Java-Solution-for-the-Minimum-Number-of-Consecutive-Zeroes-in-an-Array\n// https://leetcode.com/problems/find-the-minimum-number-of-consecutive-zeroes-in-an-array/discuss/7871/Java-Solution-for-the-Minimum-Number-of-Consecutive-Zeroes-in-an-Array\n// https://leetcode.com/problems/find-the-minimum-number-of-consecutive-zeroes-in-an-array/discuss/7871/Java-Solution-for-the-Minimum-Number-of-Consecutive-Zeroes-in-an-Array\n// https://leetcode.com/problems/find-the-minimum-number-of-consecutive-zeroes-in-an-array/discuss/7871/Java-Solution-for-the-Minimum-Number-of-Consecutive-Zeroes-in-an-Array\n// https://leetcode.com/problems/find-the-minimum-number-of-consecutive-zeroes-in-an-array/discuss/7871/Java-Solution-for-the-Minimum-Number-of-Consecutive-Zeroes-in-an-Array\n// https://leetcode.com/problems/find-the-minimum-number-of-consecutive-zeroes-in-an-array/discuss/7871/Java-Solution-for-the-Minimum-Number-of-Consecutive-Zeroes-in-an-Array\n// https://leetcode.com/problems/find-the-minimum-number-of-consecutive-zeroes-in-an-array/discuss/7871/Java-Solution-for-the-Minimum-Number-of-Consecutive-Zeroes-in-an-Array\n// https://leetcode.com/problems/find-the-minimum-number-of-consecutive-zeroes-in-an-array/discuss/7871/Java-Solution-for-the-Minimum-Number-of-Consecutive-Zeroes-in-an-Array\n// https://leetcode.com/problems/find-the-minimum-number-of-consecutive-zeroes-in-an-array/discuss/7871/Java-Solution-for-the-Minimum-Number-of-Consecutive-Zeroes-in-an-Array\n// https://leetcode.com/problems/find-the-minimum-number-of-consecutive-zeroes-in-an-array/discuss/7871/Java-Solution-for-the-Minimum-Number-of-Consecutive-Zeroes-in-an-Array\n// https://leetcode.com/problems/find-the-minimum-number-of-consecutive-zeroes-in-an-array/discuss/7871/Java-Solution-for-the-Minimum-Number-of-Consecutive-Zeroes-in-an-Array\n// https://leetcode.com/problems/find-the-minimum-number-of-consecutive-zeroes-in-an-array/discuss/7871/Java-Solution-for-the-Minimum-Number-of-Consecutive-Zeroes-in-an-Array\n// https://leetcode.com/problems/find-the-minimum-number-of-consecutive-zeroes-in-an-array/discuss/7871/Java-Solution-for-the-Minimum-Number-of-Consecutive-Zeroes-in-an-Array\n// https://leetcode.com/problems/find-the-minimum-number-of-consecutive-zeroes-in-an-array/discuss/7871/Java-Solution-for-the-Minimum-Number-of-Consecutive-Zeroes-in-an-Array\n// https://leetcode.com/problems/find-the-minimum-number-of-consecutive-zeroes-in-an-array/discuss/7871/Java-Solution-for-the-Minimum-Number-of-Consecutive-Zeroes-in-an-Array\n// https://leetcode.com/problems/find-the-minimum-number-of-consecutive-zeroes-in-an-array/discuss/7871/Java-Solution-for-the-Minimum-Number-of-Consecutive-Zeroes-in-an-Array\n// https://leetcode.com/problems/find-the-minimum-number-of-consecutive-zeroes-in-an-array/discuss/7871/Java-Solution-for-the-Minimum-Number-of-Consecutive-Zeroes-in-an-Array\n// https://leetcode.com/problems/find-the-minimum-number-of-consecutive-zeroes-in-an-array/discuss/7871/Java-Solution-for-the-Minimum-Number-of-Consecutive-Zeroes-in-an-Array\n// https://leetcode.com/problems/find-the-minimum-number-of-consecutive-zeroes-in-an-array/discuss/7871/Java-Solution-for-the-Minimum-Number-of-Consecutive-Zeroes-in-an-Array\n// https://leetcode.com/problems/find-the-minimum-number-of-consecutive-zeroes-in-an-array/discuss/7871/Java-Solution-for-the-Minimum-Number-of-Consecutive-Zeroes-in-an-Array\n// https://leetcode.com/problems/find-the-minimum-number-of-consecutive-zeroes-in-an-array/discuss/7871/Java-Solution-for-the-Minimum-Number-of-Consecutive-Zeroes-in-an-Array\n// https://", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/69", "prompt": "/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 4\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 4\n      search([5, 5, 4, 4, 4])) == 4\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 4\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 4\n      search([5, 5, 4, 4, 4])) == 4\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 4\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 4\n      search([5, 5, 4, 4, 4])) == 4\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 4\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 4\n      search([5, 5, 4, 4, 4])) == 4\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 4\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 4\n      search([5, 5, 4, 4, 4])) == 4\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 4\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 4\n      search([5, 5, 4, 4, 4])) == 4\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 4\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 4\n      search([5, 5, 4, 4, 4])) == 4\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 4\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 4\n      search([5, 5, 4, 4, 4])) == 4\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 4\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 4\n      search([5, 5, 4, 4, 4])) == 4\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 4\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 4\n      search([5, 5, 4, 4, 4])) == 4\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 4\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 4\n      search([5, 5, 4, 4, 4])) == 4\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input list of strings only for strings that contain a specific substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Filter an input list of strings only for strings that contain a specific substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) === 0)\n}\n\n/**\n * Filter an input list of strings only for strings that contain a specific substring\n * and are of the same length\n * >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n * ['abc', 'bacd', 'array']\n */\nconst filterBySubstringLength = (strings, substring) => {\n  return strings.filter(str => str.length >= substring.length)\n}\n\n/**\n * Filter an input list of strings only for strings that contain a specific substring\n * and are of the same length\n * >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n * ['abc', 'bacd', 'array']\n */\nconst filterBySubstringLengthAndSubstring = (strings, substring) => {\n  return strings.filter(str => str.length >= substring.length && str.indexOf(substring) === 0)\n}\n\n/**\n * Filter an input list of strings only for strings that contain a specific substring\n * and are of the same length\n * >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n * ['abc', 'bacd', 'array']\n */\nconst filterBySubstringLengthAndSubstringLength = (strings, substring) => {\n  return strings.filter(str => str.length >= substring.length && str.length >= substring.length)\n}\n\n/**\n * Filter an input list of strings only for strings that contain a specific substring\n * and are of the same length\n * >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n * ['abc', 'bacd', 'array']\n */\nconst filterBySubstringLengthAndSubstringLengthAndSubstring = (strings, substring) => {\n  return strings.filter(str => str.length >= substring.length && str.length >= substring.length && str.indexOf(substring) === 0)\n}\n\n/**\n * Filter an input list of strings only for strings that contain a specific substring\n * and are of the same length\n * >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n * ['abc', 'bacd', 'array']\n */\nconst filterBySubstringLengthAndSubstringLengthAndSubstring = (strings, substring) => {\n  return strings.filter(str => str.length >= substring.length && str.length >= substring.length && str.length >= substring.length)\n}\n\n/**\n * Filter an input list of strings only for strings that contain a specific substring\n * and are of the same length\n * >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n * ['abc', 'bacd', 'array']\n */\nconst filterBySubstringLengthAndSubstringLengthAndSubstringLength = (strings, substring) => {\n  return strings.filter(str => str.length >= substring.length && str.length >= substring.length && str.length >= substring.length)\n}\n\n/**\n * Filter an input list of strings only for strings that contain a specific substring\n * and are of the same length\n * >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n * ['abc', 'bacd', 'array']\n */\nconst filterBySubstringLengthAndSubstringLengthAndSubstringLengthAndSubstring = (strings, substring) => {\n  return strings.filter(str => str.length >= substring.length && str.length >= substring.length && str.length >= substring.length && str.indexOf(substring) === 0)\n}\n\n/**\n * Filter an input list of strings only for strings that contain a specific substring\n * and are of the same length\n * >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n * ['abc', 'bacd', 'array']\n */\nconst filterBySubstringLengthAndSubstringLengthAndSubstringLengthAndSubstring = (strings, substring) => {\n  return strings.filter(str => str.length >= substring.length && str.length >= substring.length && str.length >= substring.length && str.length >= substring.length)\n}\n\n/**\n * Filter an input list of strings only for strings that contain a specific substring\n * and are of the same length\n * >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n * ['abc', 'bacd', 'array']\n */\nconst filterBySubstringLengthAndSubstringLengthAndSubstringLengthAndSubstringLength = (strings, substring) => {\n  return strings.filter(str => str.length >= substring.length && str.length >= substring.length && str.length >= substring.length && str.length >= substring.length)\n}\n\n/**\n * Filter an input list of strings only for strings that contain a specific substring\n * and are of the same length\n * >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n * ['abc', 'bacd', 'array']\n */\nconst filterBySubstringLengthAndSubstringLengthAndSubstringLengthAndSubstringLength = (strings, substring) => {\n  return strings.filter(str => str.length >= substring.length && str.length >= substring.length && str.length >= substring.length && str.length >= substring.length)\n}\n\n/**\n * Filter an input list of strings only for strings that contain a specific substring\n * and are of the same length\n * >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n * ['abc', 'bacd', 'array']\n */\nconst filterBySubstringLengthAndSubstringLengthAndSubstringLengthAndSubstringLengthAndSubstringLength = (strings, substring) => {\n  return strings.filter(str => str.length >= substring.length && str.length >= substring.length && str.length >= substring.length && str.length >= substring.length)\n}\n\n/**\n * Filter an input list of strings only for strings that contain a specific substring\n * and are of the same length\n * >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n * ['abc', 'bacd', 'array']\n */\nconst filterBySubstringLengthAndSubstringLengthAndSubstringLengthAndSubstringLengthAndSubstringLengthAndSubstringLength = (strings, substring) => {\n  return strings.filter(str => str.length >= substring.length && str.length >= substring.length && str.length >= substring.length && str.length >= substring.length && str.length >= substring.length)\n}\n\n/**\n * Filter an input list of strings only for strings that contain a specific substring\n * and are of the same length\n * >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n * ['abc', 'bacd', 'array']\n */\nconst filterBySubstringLengthAndSubstringLengthAndSubstringLengthAndSubstringLengthAndSubstringLengthAndSubstringLength = (strings, substring) => {\n  return strings.filter(str => str.length >= substring.length && str.length >= substring.length && str.length >= substring.length && str.length >= substring.length && str.length >= substring.length)\n}\n\n/**\n * Filter an input list of strings only for strings that contain a specific substring\n * and are of the same length\n * >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n * ['abc', 'bacd', 'array']\n */\nconst filterBySubstringLengthAndSubstringLengthAndSubstringLengthAndSubstringLengthAndSubstringLengthAndSubstringLength = (strings, substring) => {\n  return strings.filter(str => str.length >= substring.length && str.length >= substring.length && str.length >= substring.length && str.length >= substring.length && str.length >= substring.length)\n}\n\n/**\n * Filter an input list of strings only for strings that contain a specific substring\n * and are of the same ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/70", "prompt": "/*\n  Strange sorting is when you start with the minimum, then with the maximum of the remaining integers, then with the minimum, and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  Strange sorting is when you start with the minimum, then with the maximum of the remaining integers, then with the minimum, and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const sortedLst = lst.sort((a, b) => a - b);\n  const sortedLst2 = lst.sort((a, b) => b - a);\n  return sortedLst.concat(sortedLst2);\n};\n\n/**\n * Given a sorted array and a target number, return all numbers in the array that are greater than or equal to the target number.\n * If the target number is 0, return an empty array.\n * If the target number is negative, return all numbers in the array that are less than or equal to the target number.\n * If the target number is positive, return all numbers in the array that are greater than or equal to the target number.\n * If the target number is equal to the length of the array, the function should return an empty array.\n * If the target number is greater than the length of the array, the function should return an empty array.\n * If the target number is less than the length of the array, the function should return an empty array.\n * If the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is less than the length of the array, the function should return an empty array.\n * If the target number is equal to the length of the array and the target number is less than the length of the array and the target number is greater than the length of the array, the function should return an empty array.\n * If the target number is equal to the length of the array and the target number is equal to the length of the array and the target number is less than the length of the array and the target number is greater than the length of the array, the function should return an empty array.\n * If the target number is equal to the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is less than the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array, the function should return an empty array.\n * If the target number is equal to the length of the array and the target number is equal to the length of the array and the target number is less than the length of the array and the target number is greater than the length of the array and the target number is equal to the length of the array and the target number is less than the length of the array and the target number is greater than the length of the array, the function should return an empty array.\n * If the target number is equal to the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is less than the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is equal to the length of the array and the target number is less than the length of the array and the target number is greater than the length of the array, the function should return an empty array.\n * If the target number is equal to the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is less than the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is equal to the length of the array and the target number is less than the length of the array and the target number is greater than the length of the array, the function should return an empty array.\n * If the target number is equal to the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is less than the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is equal to the length of the array and the target number is less than the length of the array and the target number is greater than the length of the array, the function should return an empty array.\n * If the target number is equal to the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is less than the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is equal to the length of the array and the target number is less than the length of the array and the target number is greater than the length of the array, the function should return an empty array.\n * If the target number is equal to the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is less than the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is equal to the length of the array and the target number is less than the length of the array and the target number is greater than the length of the array, the function should return an empty array.\n * If the target number is equal to the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is less than the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is equal to the length of the array and the target number is less than the length of the array and the target number is greater than the length of the array, the function should return an empty array.\n * If the target number is equal to the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is less than the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is equal to the length of the array and the target number is less than the length of the array and the target number is greater than the length of the array, the function should return an empty array.\n * If the target number is equal to the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is less than the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is equal to the length of the array and the target number is less than the length of the array and the target number is greater than the length of the array, the function should return an empty array.\n * If the target number is equal to the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is less than the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is equal to the length of the array and the target number is less than the length of the array and the target number is greater than the length of the array, the function should return an empty array.\n * If the target number is equal to the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is less than the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is equal to the length of the array and the target number is less than the length of the array and the target number is greater than the length of the array, the function should return an empty array.\n * If the target number is equal to the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is less than the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is equal to the length of the array and the target number is less than the length of the array and the target number is greater than the length of the array, the function should return an empty array.\n * If the target number is equal to the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is less than the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is equal to the length of the array and the target number is less than the length of the array and the target number is greater than the length of the array, the function should return an empty array.\n * If the target number is equal to the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is less than the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is equal to the length of the array and the target number is less than the length of the array and the target number is greater than the length of the array, the function should return an empty array.\n * If the target number is equal to the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is less than the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is equal to the length of the array and the target number is less than the length of the array and the target number is greater than the length of the array, the function should return an empty array.\n * If the target number is equal to the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is less than the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is equal to the length of the array and the target number is less than the length of the array and the target number is greater than the length of the array, the function should return an empty array.\n * If the target number is equal to the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is less than the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is equal to the length of the array and the target number is less than the length of the array and the target number is greater than the length of the array, the function should return an empty array.\n * If the target number is equal to the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is less than the length of the array and the target number is equal to the length of the array and the target number is greater than the length of the array and the target number is equal to the length of the ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the length of the three sides of a triangle. Return the area of the triangle rounded to 2 decimal points if the three sides form a valid triangle. Otherwise, return -1 Three sides a valid triangle if the sum of two sides is greater than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  Given the length of the three sides of a triangle. Return the area of the triangle rounded to 2 decimal points if the three sides form a valid triangle. Otherwise, return -1 Three sides a valid triangle if the sum of two sides is greater than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  const area = (a + b + c) / 2;\n  return Math.round(area * 100) / 100;\n};\n\n/*\n  Given the length of the three sides of a rectangle. Return the area of the rectangle rounded to 2 decimal points if the three sides form a valid rectangle. Otherwise, return -1 Three sides a valid rectangle if the sum of two sides is greater than the third side.\n  Example:\n  rectangleArea(3, 4, 5) == 10.00\n  rectangleArea(1, 2, 10) == -1\n  */\nconst rectangleArea = (a, b, c) => {\n  const area = (a + b + c) / 2;\n  return Math.round(area * 100) / 100;\n};\n\n/*\n  Given the length of the three sides of a pentagon. Return the area of the pentagon rounded to 2 decimal points if the three sides form a valid pentagon. Otherwise, return -1 Three sides a valid pentagon if the sum of two sides is greater than the third side.\n  Example:\n  pentagonArea(3, 4, 5) == 10.00\n  pentagonArea(1, 2, 10) == -1\n  */\nconst pentagonArea = (a, b, c) => {\n  const area = (a + b + c) / 2;\n  return Math.round(area * 100) / 100;\n};\n\n/*\n  Given the length of the three sides of a hexagon. Return the area of the hexagon rounded to 2 decimal points if the three sides form a valid hexagon. Otherwise, return -1 Three sides a valid hexagon if the sum of two sides is greater than the third side.\n  Example:\n  hexagonArea(3, 4, 5) == 10.00\n  hexagonArea(1, 2, 10) == -1\n  */\nconst hexagonArea = (a, b, c) => {\n  const area = (a + b + c) / 2;\n  return Math.round(area * 100) / 100;\n};\n\n/*\n  Given the length of the three sides of a heptagon. Return the area of the heptagon rounded to 2 decimal points if the three sides form a valid heptagon. Otherwise, return -1 Three sides a valid heptagon if the sum of two sides is greater than the third side.\n  Example:\n  heptagonArea(3, 4, 5) == 10.00\n  heptagonArea(1, 2, 10) == -1\n  */\nconst heptagonArea = (a, b, c) => {\n  const area = (a + b + c) / 2;\n  return Math.round(area * 100) / 100;\n};\n\n/*\n  Given the length of the three sides of a decagon. Return the area of the decagon rounded to 2 decimal points if the three sides form a valid decagon. Otherwise, return -1 Three sides a valid decagon if the sum of two sides is greater than the third side.\n  Example:\n  decagonArea(3, 4, 5) == 10.00\n  decagonArea(1, 2, 10) == -1\n  */\nconst decagonArea = (a, b, c) => {\n  const area = (a + b + c) / 2;\n  return Math.round(area * 100) / 100;\n};\n\n/*\n  Given the length of the three sides of a dodecagon. Return the area of the dodecagon rounded to 2 decimal points if the three sides form a valid dodecagon. Otherwise, return -1 Three sides a valid dodecagon if the sum of two sides is greater than the third side.\n  Example:\n  dodecagonArea(3, 4, 5) == 10.00\n  dodecagonArea(1, 2, 10) == -1\n  */\nconst dodecagonArea = (a, b, c) => {\n  const area = (a + b + c) / 2;\n  return Math.round(area * 100) / 100;\n};\n\n/*\n  Given the length of the three sides of a quadigon. Return the area of the quadigon rounded to 2 decimal points if the three sides form a valid quadigon. Otherwise, return -1 Three sides a valid quadigon if the sum of two sides is greater than the third side.\n  Example:\n  quadigonArea(3, 4, 5) == 10.00\n  quadigonArea(1, 2, 10) == -1\n  */\nconst quadigonArea = (a, b, c) => {\n  const area = (a + b + c) / 2;\n  return Math.round(area * 100) / 100;\n};\n\n/*\n  Given the length of the three sides of a hexadecant. Return the area of the hexadecant rounded to 2 decimal points if the three sides form a valid hexadecant. Otherwise, return -1 Three sides a valid hexadecant if the sum of two sides is greater than the third side.\n  Example:\n  hexadecantArea(3, 4, 5) == 10.00\n  hexadecantArea(1, 2, 10) == -1\n  */\nconst hexadecantArea = (a, b, c) => {\n  const area = (a + b + c) / 2;\n  return Math.round(area * 100) / 100;\n};\n\n/*\n  Given the length of the three sides of a hexagon. Return the area of the hexagon rounded to 2 decimal points if the three sides form a valid hexagon. Otherwise, return -1 Three sides a valid hexagon if the sum of two sides is greater than the third side.\n  Example:\n  hexagonArea(3, 4, 5) == 10.00\n  hexagonArea(1, 2, 10) == -1\n  */\nconst hexagonArea = (a, b, c) => {\n  const area = (a + b + c) / 2;\n  return Math.round(area * 100) / 100;\n};\n\n/*\n  Given the length of the three sides of a heptagon. Return the area of the heptagon rounded to 2 decimal points if the three sides form a valid heptagon. Otherwise, return -1 Three sides a valid heptagon if the sum of two sides is greater than the third side.\n  Example:\n  heptagonArea(3, 4, 5) == 10.00\n  heptagonArea(1, 2, 10) == -1\n  */\nconst heptagonArea = (a, b, c) => {\n  const area = (a + b + c) / 2;\n  return Math.round(area * 100) / 100;\n};\n\n/*\n  Given the length of the three sides of a decagon. Return the area of the decagon rounded to 2 decimal points if the three sides form a valid decagon. Otherwise, return -1 Three sides a valid decagon if the sum of two sides is greater than the third side.\n  Example:\n  decagonArea(3, 4, 5) == 10.00\n  decagonArea(1, 2, 10) == -1\n  */\nconst decagonArea = (a, b, c) => {\n  const area = (a + b + c) / 2;\n  return Math.round(area * 100) / 100;\n};\n\n/*\n  Given the length of the three sides of a dodecagon. Return the area of the dodecagon rounded to 2 decimal points if the three sides form a valid dodecagon. Otherwise, return -1 Three sides a valid dodecagon if the sum of two sides is greater than the third side.\n  Example:\n  dodecagonArea(3, 4, 5) == 10.00\n  dodecagonArea(1, 2, 10) == -1\n  */\nconst dodecagonArea = (a, b, c) => {\n  const area = (a + b + c) / 2;\n  return Math.round(area * 100) / 100;\n};\n\n/*\n  Given the length of the three sides of a quadigon. Return the area of the quadigon rounded to 2 decimal points if the three sides form a valid quadigon. Otherwise, return -1 Three sides a valid quadigon if the sum of two sides is greater than the third side.\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a function that returns true when the object q flies, and false otherwise. If the object q flies when it is balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that returns true when the object q flies, and false otherwise. If the object q flies when it is balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = Math.max(...q.map(w => w));\n  const sumWeight = q.map(w => w).reduce((a, b) => a + b, 0);\n  return sumWeight <= maxWeight;\n};\n\nmodule.exports = willItFly;\n\n},{}],8:[function(require,module,exports){\n/*\n  Write a function that returns true when the object q flies, and false otherwise. If the object q flies when it is balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = Math.max(...q.map(w => w));\n  const sumWeight = q.map(w => w).reduce((a, b) => a + b, 0);\n  return sumWeight <= maxWeight && willItFly.isBalanced(q, maxWeight);\n};\n\nmodule.exports = willItFly;\n\n},{}],9:[function(require,module,exports){\n/*\n  Write a function that returns true when the object q flies, and false otherwise. If the object q flies when it is balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = Math.max(...q.map(w => w));\n  const sumWeight = q.map(w => w).reduce((a, b) => a + b, 0);\n  return sumWeight <= maxWeight && willItFly.isBalanced(q, maxWeight);\n};\n\nmodule.exports = willItFly;\n\n},{}],10:[function(require,module,exports){\n/*\n  Write a function that returns true when the object q flies, and false otherwise. If the object q flies when it is balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = Math.max(...q.map(w => w));\n  const sumWeight = q.map(w => w).reduce((a, b) => a + b, 0);\n  return sumWeight <= maxWeight && willItFly.isBalanced(q, maxWeight);\n};\n\nmodule.exports = willItFly;\n\n},{}],11:[function(require,module,exports){\n/*\n  Write a function that returns true when the object q flies, and false otherwise. If the object q flies when it is balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = Math.max(...q.map(w => w));\n  const sumWeight = q.map(w => w).reduce((a, b) => a + b, 0);\n  return sumWeight <= maxWeight && willItFly.isBalanced(q, maxWeight);\n};\n\nmodule.exports = willItFly;\n\n},{}],12:[function(require,module,exports){\n/*\n  Write a function that returns true when the object q flies, and false otherwise. If the object q flies when it is balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = Math.max(...q.map(w => w));\n  const sumWeight = q.map(w => w).reduce((a, b) => a + b, 0);\n  return sumWeight <= maxWeight && willItFly.isBalanced(q, maxWeight);\n};\n\nmodule.exports = willItFly;\n\n},{}],13:[function(require,module,exports){\n/*\n  Write a function that returns true when the object q flies, and false otherwise. If the object q flies when it is balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalance", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/73", "prompt": "/*\n  A palindromic array is an array that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  A palindromic array is an array that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let min = Number.MAX_VALUE;\n  let max = -Number.MAX_VALUE;\n  let change = -1;\n  let i = arr.length - 1;\n\n  while (i--) {\n    if (arr[i] < min) {\n      min = arr[i];\n      change = i;\n    }\n    if (arr[i] > max) {\n      max = arr[i];\n      change = i;\n    }\n  }\n\n  return change;\n};\n\n/*\n  A palindromic number is a number that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange(123) == 3\n  smallestChange(123) == 2\n  smallestChange(123) == 1\n  smallestChange(123) == 0\n  */\nconst smallestChange = (num) => {\n  let min = Number.MAX_VALUE;\n  let max = -Number.MAX_VALUE;\n  let change = -1;\n  let i = num - 1;\n\n  while (i--) {\n    if (num < min) {\n      min = num;\n      change = i;\n    }\n    if (num > max) {\n      max = num;\n      change = i;\n    }\n  }\n\n  return change;\n};\n\n/*\n  A palindromic string is a string that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange(\"hello\") == 5\n  smallestChange(\"hello\") == 4\n  smallestChange(\"hello\") == 3\n  smallestChange(\"hello\") == 2\n  smallestChange(\"hello\") == 1\n  smallestChange(\"hello\") == 0\n  */\nconst smallestChange = (str) => {\n  let min = Number.MAX_VALUE;\n  let max = -Number.MAX_VALUE;\n  let change = -1;\n  let i = str.length - 1;\n\n  while (i--) {\n    if (str[i] < min) {\n      min = str[i];\n      change = i;\n    }\n    if (str[i] > max) {\n      max = str[i];\n      change = i;\n    }\n  }\n\n  return change;\n};\n\n/*\n  A palindromic array is a string that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange([1,2,3,4,5,6,7]) == 7\n  smallestChange([1,2,3,4,5,6,7]) == 6\n  smallestChange([1,2,3,4,5,6,7]) == 5\n  smallestChange([1,2,3,4,5,6,7]) == 4\n  smallestChange([1,2,3,4,5,6,7]) == 3\n  smallestChange([1,2,3,4,5,6,7]) == 2\n  smallestChange([1,2,3,4,5,6,7]) == 1\n  smallestChange([1,2,3,4,5,6,7]) == 0\n  */\nconst smallestChange = (arr) => {\n  let min = Number.MAX_VALUE;\n  let max = -Number.MAX_VALUE;\n  let change = -1;\n  let i = arr.length - 1;\n\n  while (i--) {\n    if (arr[i] < min) {\n      min = arr[i];\n      change = i;\n    }\n    if (arr[i] > max) {\n      max = arr[i];\n      change = i;\n    }\n  }\n\n  return change;\n};\n\n/*\n  A palindromic number is a string that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange(123) == 3\n  smallestChange(123) == 2\n  smallestChange(123) == 1\n  smallestChange(123) == 0\n  */\nconst smallestChange = (num) => {\n  let min = Number.MAX_VALUE;\n  let max = -Number.MAX_VALUE;\n  let change = -1;\n  let i = num - 1;\n\n  while (i--) {\n    if (num < min) {\n      min = num;\n      change = i;\n    }\n    if (num > max) {\n      max = num;\n      change = i;\n    }\n  }\n\n  return change;\n};\n\n/*\n  A palindromic string is a string that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange(\"hello\") == 5\n  smallestChange(\"hello\") == 4\n  smallestChange(\"hello\") == 3\n  smallestChange(\"hello\") == 2\n  smallestChange(\"hello\") == 1\n  smallestChange(\"hello\") == 0\n  */\nconst smallestChange = (str) => {\n  let min = Number.MAX_VALUE;\n  let max = -Number.MAX_VALUE;\n  let change = -1;\n  let i = str.length - 1;\n\n  while (i--) {\n    if (str[i] < min) {\n      min = str[i];\n      change = i;\n    }\n    if (str[i] > max) {\n      max = str[i];\n      change = i;\n    }\n  }\n\n  return change;\n};\n\n/*\n  A palindromic array is a string that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange([1,2,3,4,5,6,7]) == 7\n  smallestChange([1,2,3,4,5,6,7]) == 6\n  smallestChange([1,2,3,4,5,6,7]) == 5\n  smallestChange([1,2,3,4,5,6,7]) == 4\n  smallestChange([1,2,3,4,5,6,7]) == 3\n  smallestChange([1,2,3,4,5,6,7]) == 2\n  smallestChange([1,2,3,4,5,6,7]) == 1\n  smallestChange([1,2,3,4,5,6,7]) == 0\n  */\nconst smallestChange = (arr) => {\n  let min = Number.MAX_VALUE;\n  let max = -Number.MAX_VALUE;\n  let change = -1;\n  let i = arr.length - 1;\n\n  while (i--) {\n    if (arr[i] < min) {\n      min = arr[i];\n      change = i;\n    }\n    if (arr[i] > max) {\n      max = arr[i];\n      change = i;\n    }\n  }\n\n  return change;\n};\n\n/*\n  A palindromic number is a string that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange(123) == 3\n  smallestChange(123) == 2\n  smallestChange(123) == 1\n  smallestChange(123) == 0\n  */\nconst smallestChange = (num) => {\n  let min = Number.MAX_VALUE;\n  let max = -Number.MAX_VALUE;\n  let change = -1;\n  let i = num - 1;\n\n  while (i--) {\n    if (num < min) {\n      min = num;\n      change = i;\n    }\n    if (num > max) {\n      max = num;\n      change = i;\n    }\n  }\n\n  return change;\n};\n\n/*\n  A palindromic string is a string that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange(\"hello\") == 5\n  smallestChange(\"hello\") == 4\n  smallestChange(\"hello\") == 3\n  smallestChange(\"hello\") == 2\n  smallestChange(\"hello\") == 1\n  smallestChange(\"hello\") == 0\n  */\nconst smallestChange = (str) => {\n  let min = Number.MAX_VALUE;\n  let max = -Number.MAX_VALUE;\n  let change = -1;\n  let i = str.length - 1;\n\n  while (i--) {\n    if (str[i] < min) {\n      min = str[i];\n      change = i;\n    }\n    if (str[i] > max) {\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a function that accepts two lists of strings and returns the list that is the total number of characters in all strings of the list less than the other list. If both lists have the same number of characters, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that accepts two lists of strings and returns the list that is the total number of characters in all strings of the list less than the other list. If both lists have the same number of characters, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const set1 = new Set(lst1);\n  const set2 = new Set(lst2);\n  const common = set1.has(set2.size);\n  return common? [...set1,...set2] : lst1;\n};\n\nmodule.exports = totalMatch;\n\n},{}],3:[function(require,module,exports){\nconst totalMatch = require('./totalMatch');\n\n/**\n * Write a function that accepts two lists of strings and returns the list that is the total number of characters in all strings of the list greater than the other list. If both lists have the same number of characters, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalNotMatch = (lst1, lst2) => {\n  const set1 = new Set(lst1);\n  const set2 = new Set(lst2);\n  const common = set1.has(set2.size);\n  return common? [...set1,...set2] : lst1;\n};\n\nmodule.exports = totalNotMatch;\n\n},{\"./totalMatch\":2}],4:[function(require,module,exports){\nconst totalMatch = require('./totalMatch');\n\n/**\n * Write a function that accepts two lists of strings and returns the list that is the total number of characters in all strings of the list equal to the other list. If both lists have the same number of characters, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalEqual = (lst1, lst2) => {\n  const set1 = new Set(lst1);\n  const set2 = new Set(lst2);\n  const common = set1.has(set2.size);\n  return common? [...set1,...set2] : lst1;\n};\n\nmodule.exports = totalEqual;\n\n},{\"./totalMatch\":2}],5:[function(require,module,exports){\nconst totalMatch = require('./totalMatch');\n\n/**\n * Write a function that accepts two lists of strings and returns the list that is the total number of characters in all strings of the list greater than or equal to the other list. If both lists have the same number of characters, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalGreaterThan = (lst1, lst2) => {\n  const set1 = new Set(lst1);\n  const set2 = new Set(lst2);\n  const common = set1.has(set2.size);\n  return common? [...set1,...set2] : lst1;\n};\n\nmodule.exports = totalGreaterThan;\n\n},{\"./totalMatch\":2}],6:[function(require,module,exports){\nconst totalMatch = require('./totalMatch');\n\n/**\n * Write a function that accepts two lists of strings and returns the list that is the total number of characters in all strings of the list less than or equal to the other list. If both lists have the same number of characters, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalLessThan = (lst1, lst2) => {\n  const set1 = new Set(lst1);\n  const set2 = new Set(lst2);\n  const common = set1.has(set2.size);\n  return common? [...set1,...set2] : lst1;\n};\n\nmodule.exports = totalLessThan;\n\n},{\"./totalMatch\":2}],7:[function(require,module,exports){\nconst totalMatch = require('./totalMatch');\n\n/**\n * Write a function that accepts two lists of strings and returns the list that is the total number of characters in all strings of the list equal to the other list. If both lists have the same number of characters, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalEqualOrGreaterThan = (lst1, lst2) => {\n  const set1 = new Set(lst1);\n  const set2 = new Set(lst2);\n  const common = set1.has(set2.size);\n  return common? [...set1,...set2] : lst1;\n};\n\nmodule.exports = totalEqualOrGreaterThan;\n\n},{\"./totalMatch\":2}],8:[function(require,module,exports){\nconst totalMatch = require('./totalMatch');\n\n/**\n * Write a function that accepts two lists of strings and returns the list that is the total number of characters in all strings of the list equal to the other list. If both lists have the same number of characters, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/75", "prompt": "/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiply", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/76", "prompt": "/*YOur task is to write a function that returns true if a number x is a simple power of n and in other cases a false one. x is a simple power of n if n * * int = x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*YOur task is to write a function that returns true if a number x is a simple power of n and in other cases a false one. x is a simple power of n if n * * int = x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  let isSimple = true;\n  if (n % 2 === 0) {\n    isSimple = false;\n  }\n  if (n % 2 === 1) {\n    isSimple =\n      x % 2 === 0 &&\n      x % 3 === 0 &&\n      x % 5 === 0;\n  }\n  return isSimple;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a power of n and in other cases a false one. x is a power of n if n ** int = x\n  For example:\n  isPowerOf(3, 2) => true\n  isPowerOf(3, 1) => true\n  isPowerOf(3, 0) => false\n  isPowerOf(2, 2) => false\n  isPowerOf(2, 1) => false\n  isPowerOf(2, 0) => false\n  isPowerOf(1, 2) => false\n  isPowerOf(1, 1) => false\n  isPowerOf(1, 0) => false\n  isPowerOf(0, 2) => false\n  isPowerOf(0, 1) => false\n  isPowerOf(0, 0) => false\n  */\nconst isPowerOf = (x, n) => {\n  let isPowerOf = true;\n  if (n % 2 === 0) {\n    isPowerOf = false;\n  }\n  if (n % 2 === 1) {\n    isPowerOf = x % 2 === 0;\n  }\n  return isPowerOf;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a power of n and in other cases a false one. x is a power of n if n ** int = x\n  For example:\n  isPowerOf(3, 2) => true\n  isPowerOf(3, 1) => true\n  isPowerOf(3, 0) => false\n  isPowerOf(2, 2) => false\n  isPowerOf(2, 1) => false\n  isPowerOf(2, 0) => false\n  isPowerOf(1, 2) => false\n  isPowerOf(1, 1) => false\n  isPowerOf(1, 0) => false\n  isPowerOf(0, 2) => false\n  isPowerOf(0, 1) => false\n  isPowerOf(0, 0) => false\n  */\nconst isPowerOf2 = (x, n) => {\n  let isPowerOf = true;\n  if (n % 2 === 0) {\n    isPowerOf = false;\n  }\n  if (n % 2 === 1) {\n    isPowerOf = x % 2 === 0;\n  }\n  return isPowerOf;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a power of n and in other cases a false one. x is a power of n if n ** int = x\n  For example:\n  isPowerOf(3, 2) => true\n  isPowerOf(3, 1) => true\n  isPowerOf(3, 0) => false\n  isPowerOf(2, 2) => false\n  isPowerOf(2, 1) => false\n  isPowerOf(2, 0) => false\n  isPowerOf(1, 2) => false\n  isPowerOf(1, 1) => false\n  isPowerOf(1, 0) => false\n  isPowerOf(0, 2) => false\n  isPowerOf(0, 1) => false\n  isPowerOf(0, 0) => false\n  */\nconst isPowerOf3 = (x, n) => {\n  let isPowerOf = true;\n  if (n % 2 === 0) {\n    isPowerOf = false;\n  }\n  if (n % 2 === 1) {\n    isPowerOf = x % 2 === 0;\n  }\n  return isPowerOf;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a power of n and in other cases a false one. x is a power of n if n ** int = x\n  For example:\n  isPowerOf(3, 2) => true\n  isPowerOf(3, 1) => true\n  isPowerOf(3, 0) => false\n  isPowerOf(2, 2) => false\n  isPowerOf(2, 1) => false\n  isPowerOf(2, 0) => false\n  isPowerOf(1, 2) => false\n  isPowerOf(1, 1) => false\n  isPowerOf(1, 0) => false\n  isPowerOf(0, 2) => false\n  isPowerOf(0, 1) => false\n  isPowerOf(0, 0) => false\n  */\nconst isPowerOf4 = (x, n) => {\n  let isPowerOf = true;\n  if (n % 2 === 0) {\n    isPowerOf = false;\n  }\n  if (n % 2 === 1) {\n    isPowerOf = x % 2 === 0;\n  }\n  return isPowerOf;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a power of n and in other cases a false one. x is a power of n if n ** int = x\n  For example:\n  isPowerOf(3, 2) => true\n  isPowerOf(3, 1) => true\n  isPowerOf(3, 0) => false\n  isPowerOf(2, 2) => false\n  isPowerOf(2, 1) => false\n  isPowerOf(2, 0) => false\n  isPowerOf(1, 2) => false\n  isPowerOf(1, 1) => false\n  isPowerOf(1, 0) => false\n  isPowerOf(0, 2) => false\n  isPowerOf(0, 1) => false\n  isPowerOf(0, 0) => false\n  */\nconst isPowerOf5 = (x, n) => {\n  let isPowerOf = true;\n  if (n % 2 === 0) {\n    isPowerOf = false;\n  }\n  if (n % 2 === 1) {\n    isPowerOf = x % 2 === 0;\n  }\n  return isPowerOf;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a power of n and in other cases a false one. x is a power of n if n ** int = x\n  For example:\n  isPowerOf(3, 2) => true\n  isPowerOf(3, 1) => true\n  isPowerOf(3, 0) => false\n  isPowerOf(2, 2) => false\n  isPowerOf(2, 1) => false\n  isPowerOf(2, 0) => false\n  isPowerOf(1, 2) => false\n  isPowerOf(1, 1) => false\n  isPowerOf(1, 0) => false\n  isPowerOf(0, 2) => false\n  isPowerOf(0, 1) => false\n  isPowerOf(0, 0) => false\n  */\nconst isPowerOf6 = (x, n) => {\n  let isPowerOf = true;\n  if (n % 2 === 0) {\n    isPowerOf = false;\n  }\n  if (n % 2 === 1) {\n    isPowerOf = x % 2 === 0;\n  }\n  return isPowerOf;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a power of n and in other cases a false one. x is a power of n if n ** int = x\n  For example:\n  isPowerOf(3, 2) => true\n  isPowerOf(3, 1) => true\n  isPowerOf(3, 0) => false\n  isPowerOf(2, 2) => false\n  isPowerOf(2, 1) => false\n  isPowerOf(2, 0) => false\n  isPowerOf(1, 2) => false\n  isPowerOf(1, 1) => false\n  isPowerOf(1, 0) => false\n  isPowerOf(0, 2) => false\n  isPowerOf(0, 1) => false\n  isPowerOf(0, 0) => false\n  */\nconst isPowerOf7 = (x, n) => {\n  let isPowerOf = true;\n  if (n % 2 === 0) {\n    isPowerOf = false;\n  }\n  if (n % 2 === 1) {\n    isPowerOf = x % 2 === 0;\n  }\n  return isPowerOf;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a power of n and in other cases a false one. x is a power of n if n ** int = x\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a function that takes an integer a and returns true if this ingeger is a die of an integer. Note: You can assume that the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that takes an integer a and returns true if this ingeger is a die of an integer. Note: You can assume that the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a < 1) {\n    return false;\n  }\n  if (a === 1) {\n    return true;\n  }\n  return iscube(Math.floor(a / 2));\n};\n\n/*\n  Write a function that takes an integer a and returns true if this ingeger is a king of an integer. Note: You can assume that the input is always valid.\n  Examples:\n  isking(1) ==> true\n  isking(2) ==> false\n  isking(-1) ==> true\n  isking(64) ==> true\n  isking(0) ==> true\n  isking(180) ==> false\n  */\nconst isking = (a) => {\n  if (a < 1) {\n    return false;\n  }\n  if (a === 1) {\n    return true;\n  }\n  return isking(Math.floor(a / 2));\n};\n\n/*\n  Write a function that takes an integer a and returns true if this ingeger is a rock of an integer. Note: You can assume that the input is always valid.\n  Examples:\n  isrock(1) ==> true\n  isrock(2) ==> false\n  isrock(-1) ==> true\n  isrock(64) ==> true\n  isrock(0) ==> true\n  isrock(180) ==> false\n  */\nconst isrock = (a) => {\n  if (a < 1) {\n    return false;\n  }\n  if (a === 1) {\n    return true;\n  }\n  return isrock(Math.floor(a / 2));\n};\n\n/*\n  Write a function that takes an integer a and returns true if this ingeger is a paper of a integer. Note: You can assume that the input is always valid.\n  Examples:\n  ispaper(1) ==> true\n  ispaper(2) ==> false\n  ispaper(-1) ==> true\n  ispaper(64) ==> true\n  ispaper(0) ==> true\n  ispaper(180) ==> false\n  */\nconst ispaper = (a) => {\n  if (a < 1) {\n    return false;\n  }\n  if (a === 1) {\n    return true;\n  }\n  return ispaper(Math.floor(a / 2));\n};\n\n/*\n  Write a function that takes an integer a and returns true if this ingeger is a pencil of a integer. Note: You can assume that the input is always valid.\n  Examples:\n  ispencil(1) ==> true\n  ispencil(2) ==> false\n  ispencil(-1) ==> true\n  ispencil(64) ==> true\n  ispencil(0) ==> true\n  ispencil(180) ==> false\n  */\nconst ispencil = (a) => {\n  if (a < 1) {\n    return false;\n  }\n  if (a === 1) {\n    return true;\n  }\n  return ispencil(Math.floor(a / 2));\n};\n\n/*\n  Write a function that takes an integer a and returns true if this ingeger is a piece of paper of a integer. Note: You can assume that the input is always valid.\n  Examples:\n  ispaper(1) ==> true\n  ispaper(2) ==> false\n  ispaper(-1) ==> true\n  ispaper(64) ==> true\n  ispaper(0) ==> true\n  ispaper(180) ==> false\n  */\nconst ispaper = (a) => {\n  if (a < 1) {\n    return false;\n  }\n  if (a === 1) {\n    return true;\n  }\n  return ispaper(Math.floor(a / 2));\n};\n\n/*\n  Write a function that takes an integer a and returns true if this ingeger is a piece of pencil of a integer. Note: You can assume that the input is always valid.\n  Examples:\n  ispencil(1) ==> true\n  ispencil(2) ==> false\n  ispencil(-1) ==> true\n  ispencil(64) ==> true\n  ispencil(0) ==> true\n  ispencil(180) ==> false\n  */\nconst ispencil = (a) => {\n  if (a < 1) {\n    return false;\n  }\n  if (a === 1) {\n    return true;\n  }\n  return ispencil(Math.floor(a / 2));\n};\n\n/*\n  Write a function that takes an integer a and returns true if this ingeger is a piece of paper of a integer. Note: You can assume that the input is always valid.\n  Examples:\n  ispaper(1) ==> true\n  ispaper(2) ==> false\n  ispaper(-1) ==> true\n  ispaper(64) ==> true\n  ispaper(0) ==> true\n  ispaper(180) ==> false\n  */\nconst ispaper = (a) => {\n  if (a < 1) {\n    return false;\n  }\n  if (a === 1) {\n    return true;\n  }\n  return ispaper(Math.floor(a / 2));\n};\n\n/*\n  Write a function that takes an integer a and returns true if this ingeger is a piece of paper of a integer. Note: You can assume that the input is always valid.\n  Examples:\n  ispaper(1) ==> true\n  ispaper(2) ==> false\n  ispaper(-1) ==> true\n  ispaper(64) ==> true\n  ispaper(0) ==> true\n  ispaper(180) ==> false\n  */\nconst ispaper = (a) => {\n  if (a < 1) {\n    return false;\n  }\n  if (a === 1) {\n    return true;\n  }\n  return ispaper(Math.floor(a / 2));\n};\n\n/*\n  Write a function that takes an integer a and returns true if this ingeger is a piece of paper of a integer. Note: You can assume that the input is always valid.\n  Examples:\n  ispaper(1) ==> true\n  ispaper(2) ==> false\n  ispaper(-1) ==> true\n  ispaper(64) ==> true\n  ispaper(0) ==> true\n  ispaper(180) ==> false\n  */\nconst ispaper = (a) => {\n  if (a < 1) {\n    return false;\n  }\n  if (a === 1) {\n    return true;\n  }\n  return ispaper(Math.floor(a / 2));\n};\n\n/*\n  Write a function that takes an integer a and returns true if this ingeger is a piece of paper of a integer. Note: You can assume that the input is always valid.\n  Examples:\n  ispaper(1) ==> true\n  ispaper(2) ==> false\n  ispaper(-1) ==> true\n  ispaper(64) ==> true\n  ispaper(0) ==> true\n  ispaper(180) ==> false\n  */\nconst ispaper = (a) => {\n  if (a < 1) {\n    return false;\n  }\n  if (a === 1) {\n    return true;\n  }\n  return ispaper(Math.floor(a / 2));\n};\n\n/*\n  Write a function that takes an integer a and returns true if this ingeger is a piece of paper of a integer. Note: You can assume that the input is always valid.\n  Examples:\n  ispaper(1) ==> true\n  ispaper(2) ==> false\n  ispaper(-1) ==> true\n  ispaper(64) ==> true\n  ispaper(0) ==> true\n  ispaper(180) ==> false\n  */\nconst ispaper = (a) => {\n  if (a < 1) {\n    return false;\n  }\n  if (a === 1) {\n    return true;\n  }\n  return ispaper(Math.floor(a / 2));\n};\n\n/*\n  Write a function that takes an integer a and returns true if this ingeger is a piece of paper of a integer. Note: You can assume that the input is always valid.\n  Examples:\n  ispaper(1) ==> true\n  ispaper(2) ==> false\n  ispaper(-1) ==> true\n  ispaper(64) ==> true\n  ispap", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let count = 0;\n  let numStr = num.toString();\n  let symbols = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  let symbolCount = symbols.length;\n  let symbolIndex = 0;\n  let symbolIndex2 = 0;\n  let symbolIndex3 = 0;\n  let symbolIndex4 = 0;\n  let symbolIndex5 = 0;\n  let symbolIndex6 = 0;\n  let symbolIndex7 = 0;\n  let symbolIndex8 = 0;\n  let symbolIndex9 = 0;\n  let symbolIndex10 = 0;\n  let symbolIndex11 = 0;\n  let symbolIndex12 = 0;\n  let symbolIndex13 = 0;\n  let symbolIndex14 = 0;\n  let symbolIndex15 = 0;\n  let symbolIndex16 = 0;\n  let symbolIndex17 = 0;\n  let symbolIndex18 = 0;\n  let symbolIndex19 = 0;\n  let symbolIndex20 = 0;\n  let symbolIndex21 = 0;\n  let symbolIndex22 = 0;\n  let symbolIndex23 = 0;\n  let symbolIndex24 = 0;\n  let symbolIndex25 = 0;\n  let symbolIndex26 = 0;\n  let symbolIndex27 = 0;\n  let symbolIndex28 = 0;\n  let symbolIndex29 = 0;\n  let symbolIndex30 = 0;\n  let symbolIndex31 = 0;\n  let symbolIndex32 = 0;\n  let symbolIndex33 = 0;\n  let symbolIndex34 = 0;\n  let symbolIndex35 = 0;\n  let symbolIndex36 = 0;\n  let symbolIndex37 = 0;\n  let symbolIndex38 = 0;\n  let symbolIndex39 = 0;\n  let symbolIndex40 = 0;\n  let symbolIndex41 = 0;\n  let symbolIndex42 = 0;\n  let symbolIndex43 = 0;\n  let symbolIndex44 = 0;\n  let symbolIndex45 = 0;\n  let symbolIndex46 = 0;\n  let symbolIndex47 = 0;\n  let symbolIndex48 = 0;\n  let symbolIndex49 = 0;\n  let symbolIndex50 = 0;\n  let symbolIndex51 = 0;\n  let symbolIndex52 = 0;\n  let symbolIndex53 = 0;\n  let symbolIndex54 = 0;\n  let symbolIndex55 = 0;\n  let symbolIndex56 = 0;\n  let symbolIndex57 = 0;\n  let symbolIndex58 = 0;\n  let symbolIndex59 = 0;\n  let symbolIndex60 = 0;\n  let symbolIndex61 = 0;\n  let symbolIndex62 = 0;\n  let symbolIndex63 = 0;\n  let symbolIndex64 = 0;\n  let symbolIndex65 = 0;\n  let symbolIndex66 = 0;\n  let symbolIndex67 = 0;\n  let symbolIndex68 = 0;\n  let symbolIndex69 = 0;\n  let symbolIndex70 = 0;\n  let symbolIndex71 = 0;\n  let symbolIndex72 = 0;\n  let symbolIndex73 = 0;\n  let symbolIndex74 = 0;\n  let symbolIndex75 = 0;\n  let symbolIndex76 = 0;\n  let symbolIndex77 = 0;\n  let symbolIndex78 = 0;\n  let symbolIndex79 = 0;\n  let symbolIndex80 = 0;\n  let symbolIndex81 = 0;\n  let symbolIndex82 = 0;\n  let symbolIndex83 = 0;\n  let symbolIndex84 = 0;\n  let symbolIndex85 = 0;\n  let symbolIndex86 = 0;\n  let symbolIndex87 = 0;\n  let symbolIndex88 = 0;\n  let symbolIndex89 = 0;\n  let symbolIndex90 = 0;\n  let symbolIndex91 = 0;\n  let symbolIndex92 = 0;\n  let symbolIndex93 = 0;\n  let symbolIndex94 = 0;\n  let symbolIndex95 = 0;\n  let symbolIndex96 = 0;\n  let symbolIndex97 = 0;\n  let symbolIndex98 = 0;\n  let symbolIndex99 = 0;\n  let symbolIndex100 = 0;\n  let symbolIndex101 = 0;\n  let symbolIndex102 = 0;\n  let symbolIndex103 = 0;\n  let symbolIndex104 = 0;\n  let symbolIndex105 = 0;\n  let symbolIndex106 = 0;\n  let symbolIndex107 = 0;\n  let symbolIndex108 = 0;\n  let symbolIndex109 = 0;\n  let symbolIndex110 = 0;\n  let symbolIndex111 = 0;\n  let symbolIndex112 = 0;\n  let symbolIndex113 = 0;\n  let symbolIndex114 = 0;\n  let symbolIndex115 = 0;\n  let symbolIndex116 = 0;\n  let symbolIndex117 = 0;\n  let symbolIndex118 = 0;\n  let symbolIndex119 = 0;\n  let symbolIndex120 = 0;\n  let symbolIndex121 = 0;\n  let symbolIndex122 = 0;\n  let symbolIndex123 = 0;\n  let symbolIndex124 = 0;\n  let symbolIndex125 = 0;\n  let symbolIndex126 = 0;\n  let symbolIndex127 = 0;\n  let symbolIndex128 = 0;\n  let symbolIndex129 = 0;\n  let symbolIndex130 = 0;\n  let symbolIndex131 = 0;\n  let symbolIndex132 = 0;\n  let symbolIndex133 = 0;\n  let symbolIndex134 = 0;\n  let symbolIndex135 = 0;\n  let symbolIndex136 = 0;\n  let symbolIndex137 = 0;\n  let symbolIndex138 = 0;\n  let symbolIndex139 = 0;\n  let symbolIndex140 = 0;\n  let symbolIndex141 = 0;\n  let symbolIndex142 = 0;\n  let symbolIndex143 = 0;\n  let symbolIndex144 = 0;\n  let symbolIndex145 = 0;\n  let symbolIndex146 = 0;\n  let symbolIndex147 = 0;\n  let symbolIndex148 = 0;\n  let symbolIndex149 = 0;\n  let symbolIndex150 = 0;\n  let symbolIndex151 = 0;\n  let symbolIndex152 = 0;\n  let symbolIndex153 = 0;\n  let symbolIndex154 = 0;\n  let symbolIndex155 = 0;\n  let symbolIndex156 = 0;\n  let symbolIndex157 = 0;\n  let symbolIndex158 = 0;\n  let symbolIndex159 = 0;\n  let symbolIndex160 = 0;\n  let symbolIndex161 = 0;\n  let symbolIndex162 = 0;\n  let symbolIndex163 = 0;\n  let symbolIndex164 = 0;\n  let symbolIndex165 = 0;\n  let symbolIndex166 = 0;\n  let symbolIndex167 = 0;\n  let symbolIndex168 = 0;\n  let symbolIndex169 = 0;\n  let symbolIndex170 = 0;\n  let symbolIndex171 = 0;\n  let symbolIndex172 = 0;\n  let symbolIndex173 = 0;\n  let symbolIndex174 = 0;\n  let symbolIndex175 = 0;\n  let symbolIndex176 = 0;\n  let symbolIndex177 = 0;\n  let symbolIndex178 = 0;\n  let symbolIndex179 = 0;\n  let symbolIndex180 = 0;\n  let symbolIndex181 = 0;\n  let symbolIndex182 = 0;\n  let symbolIndex183 = 0;\n  let symbolIndex184 = 0;\n  let symbolIndex185 = 0;\n  let symbolIndex186 = 0;\n  let symbolIndex187 = 0;\n  let symbolIndex188 = 0;\n  let symbolIndex189 = 0;\n  let symbolIndex190 = 0;\n  let symbolIndex191 = 0;\n  let symbolIndex192 = 0;\n  let symbolIndex193 = 0;\n  let symbolIndex194 = 0;\n  let symbolIndex195 = 0;\n  let symbolIndex196 = 0;\n  let symbolIndex197 = 0;\n  let symbolIndex198 = 0;\n  let symbolIndex199 = 0;\n  let symbolIndex200 = 0;\n  let symbolIndex201 = 0;\n  let symbolIndex202 = 0;\n  let symbolIndex203 = 0;\n  let symbolIndex204 = 0;\n  let symbolIndex205 = 0;\n  let symbolIndex206 = 0;\n  let symbolIndex207 = 0;\n  let symbolIndex208 = 0;\n  let symbolIndex209 = 0;\n  let symbolIndex", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/79", "prompt": "/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let decimalString = decimal.toString();\n  for (let i = 0; i < decimalString.length; i++) {\n    if (decimalString.charAt(i) == '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n  return binary;\n};\n\n/*\n  Given a string, convert it to an integer.\n\n  Examples:\n  stringToInteger(\"\")    # returns 0\n  stringToInteger(\"1\")   # returns 1\n  stringToInteger(\"11\")  # returns 11\n  stringToInteger(\"111\")  # returns 111\n  */\nconst stringToInteger = (string) => {\n  let integer = 0;\n  let stringLength = string.length;\n  for (let i = 0; i < stringLength; i++) {\n    integer += parseInt(string.charAt(i), 2);\n  }\n  return integer;\n};\n\n/*\n  Given a string, convert it to an integer.\n\n  Examples:\n  stringToInteger(\"\")    # returns 0\n  stringToInteger(\"1\")   # returns 1\n  stringToInteger(\"11\")  # returns 11\n  stringToInteger(\"111\")  # returns 111\n  */\nconst stringToIntegerWithLeadingZeros = (string) => {\n  let integer = 0;\n  let stringLength = string.length;\n  for (let i = 0; i < stringLength; i++) {\n    integer += parseInt(string.charAt(i), 2);\n  }\n  return integer + '';\n};\n\n/*\n  Given a string, convert it to an integer.\n\n  Examples:\n  stringToIntegerWithLeadingZeros(\"\")    # returns 0\n  stringToIntegerWithLeadingZeros(\"1\")   # returns 1\n  stringToIntegerWithLeadingZeros(\"11\")  # returns 11\n  stringToIntegerWithLeadingZeros(\"111\")  # returns 111\n  */\nconst stringToIntegerWithLeadingZerosWithLeadingZeros = (string) => {\n  let integer = 0;\n  let stringLength = string.length;\n  for (let i = 0; i < stringLength; i++) {\n    integer += parseInt(string.charAt(i), 2);\n  }\n  return integer + '';\n};\n\n/*\n  Given a string, convert it to an integer.\n\n  Examples:\n  stringToIntegerWithLeadingZerosWithLeadingZeros(\"\")    # returns 0\n  stringToIntegerWithLeadingZerosWithLeadingZeros(\"1\")   # returns 1\n  stringToIntegerWithLeadingZerosWithLeadingZeros(\"11\")  # returns 11\n  stringToIntegerWithLeadingZerosWithLeadingZeros(\"111\")  # returns 111\n  */\nconst stringToIntegerWithLeadingZerosWithLeadingZerosWithLeadingZeros = (string) => {\n  let integer = 0;\n  let stringLength = string.length;\n  for (let i = 0; i < stringLength; i++) {\n    integer += parseInt(string.charAt(i), 2);\n  }\n  return integer + '';\n};\n\n/*\n  Given a string, convert it to an integer.\n\n  Examples:\n  stringToIntegerWithLeadingZerosWithLeadingZerosWithLeadingZeros(\"\")    # returns 0\n  stringToIntegerWithLeadingZerosWithLeadingZerosWithLeadingZeros(\"1\")   # returns 1\n  stringToIntegerWithLeadingZerosWithLeadingZerosWithLeadingZeros(\"11\")  # returns 11\n  stringToIntegerWithLeadingZerosWithLeadingZerosWithLeadingZeros(\"111\")  # returns 111\n  */\nconst stringToIntegerWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZeros = (string) => {\n  let integer = 0;\n  let stringLength = string.length;\n  for (let i = 0; i < stringLength; i++) {\n    integer += parseInt(string.charAt(i), 2);\n  }\n  return integer + '';\n};\n\n/*\n  Given a string, convert it to an integer.\n\n  Examples:\n  stringToIntegerWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZeros(\"\")    # returns 0\n  stringToIntegerWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZeros(\"1\")   # returns 1\n  stringToIntegerWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZeros(\"11\")  # returns 11\n  stringToIntegerWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZeros(\"111\")  # returns 111\n  */\nconst stringToIntegerWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZeros = (string) => {\n  let integer = 0;\n  let stringLength = string.length;\n  for (let i = 0; i < stringLength; i++) {\n    integer += parseInt(string.charAt(i), 2);\n  }\n  return integer + '';\n};\n\n/*\n  Given a string, convert it to an integer.\n\n  Examples:\n  stringToIntegerWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZeros(\"\")    # returns 0\n  stringToIntegerWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZeros(\"1\")   # returns 1\n  stringToIntegerWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZeros(\"11\")  # returns 11\n  stringToIntegerWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZeros(\"111\")  # returns 111\n  */\nconst stringToIntegerWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZeros = (string) => {\n  let integer = 0;\n  let stringLength = string.length;\n  for (let i = 0; i < stringLength; i++) {\n    integer += parseInt(string.charAt(i), 2);\n  }\n  return integer + '';\n};\n\n/*\n  Given a string, convert it to an integer.\n\n  Examples:\n  stringToIntegerWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZeros(\"\")    # returns 0\n  stringToIntegerWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZeros(\"1\")   # returns 1\n  stringToIntegerWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZerosWithLeadingZerosWith", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisting of a sum and a product of all integers in a list. Empty sum should be 0 and empty product should be 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* For a given list of integers, return a tuple consisting of a sum and a product of all integers in a list. Empty sum should be 0 and empty product should be 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  if (numbers.length === 0) {\n    return (0, 1);\n  }\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/**\n * Given a string, return a string that is the concatenation of all characters in the string.\n * For example \"abc\" -> \"abcabc\".\n * For an empty string, return an empty string.\n * For a string, return an empty string if there are no characters in the string.\n * For a string, return an empty string if there are only spaces in the string.\n * For a string, return an empty string if there are only numbers in the string.\n * For a string, return an empty string if there are only letters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the string.\n * For a string, return an empty string if there are only special characters in the ", "passed": 1, "run_status": 0, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/80", "prompt": "/*YYou get a string s. Your task is to check whether the string is happy or not. A string is happy if it is at least 3 long and all three consecutive letters are clearly distinguishable from each other.\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*YYou get a string s. Your task is to check whether the string is happy or not. A string is happy if it is at least 3 long and all three consecutive letters are clearly distinguishable from each other.\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let len = s.length;\n  let isHappy = true;\n  for (let i = 0; i < len; i++) {\n    let c = s.charAt(i);\n    if (c ==='' || c === '\\t' || c === '\\n' || c === '\\r' || c === '\\'') {\n      continue;\n    }\n    if (c === 'a' || c === 'e' || c === 'i' || c === 'o' || c === 'u') {\n      isHappy = false;\n      break;\n    }\n  }\n  return isHappy;\n};\n\n/*\n  Given a string s, return true if it is possible to form a word from it by deleting all letters that are not letters of the alphabet. For example, given s = \"ab\", return true.\n  Given s = \"aba\", return false.\n  Given s = \"abc\", return false.\n  Given s = \"abcabc\", return true.\n  Given s = \"abcabcabc\", return false.\n  Given s = \"abcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\", return true.\n  Given s = \"abcabcabcabcabcab", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/81", "prompt": "/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const letterGrades = ['A', 'B', 'C', 'D', 'E'];\n  const gradesArray = grades.map((grade) => grade * 1);\n  const sumOfGrades = gradesArray.reduce((acc, cur) => acc + cur);\n  const average = sumOfGrades / gradesArray.length;\n  const letterGrade = letterGrades[average];\n  return [letterGrade];\n};\n\n/*\n  Write a function that takes an array of grades and returns the letter grade\n  for the last semester in the semester. The last semester is the semester that\n  the teacher has taken the course. For example, the last semester in the semester\n  is semester 3, the teacher has taken the course on semester 1. Write a function\n  that takes an array of grades and returns the letter grade for the last semester\n  in the semester. The last semester is the semester that the teacher has taken\n  the course. For example, the last semester in the semester is semester 3, the\n  teacher has taken the course on semester 1. Write a function that takes\n  an array of grades and returns the letter grade for the last semester in\n  the semester. The last semester is the semester that the teacher has taken\n  the course. For example, the last semester in the semester is semester 3, the\n  teacher has taken the course on semester 1. Write a function that takes\n  an array of grades and returns the letter grade for the last semester in\n  the semester. The last semester is the semester that the teacher has taken\n  the course. For example, the last semester in the semester is semester 3, the\n  teacher has taken the course on semester 1. Write a function that takes\n  an array of grades and returns the letter grade for the last semester in\n  the semester. The last semester is the semester that the teacher has taken\n  the course. For example, the last semester in the semester is semester 3, the\n  teacher has taken the course on semester 1. Write a function that takes\n  an array of grades and returns the letter grade for the last semester in\n  the semester. The last semester is the semester that the teacher has taken\n  the course. For example, the last semester in the semester is semester 3, the\n  teacher has taken the course on semester 1. Write a function that takes\n  an array of grades and returns the letter grade for the last semester in\n  the semester. The last semester is the semester that the teacher has taken\n  the course. For example, the last semester in the semester is semester 3, the\n  teacher has taken the course on semester 1. Write a function that takes\n  an array of grades and returns the letter grade for the last semester in\n  the semester. The last semester is the semester that the teacher has taken\n  the course. For example, the last semester in the semester is semester 3, the\n  teacher has taken the course on semester 1. Write a function that takes\n  an array of grades and returns the letter grade for the last semester in\n  the semester. The last semester is the semester that the teacher has taken\n  the course. For example, the last semester in the semester is semester 3, the\n  teacher has taken the course on semester 1. Write a function that takes\n  an array of grades and returns the letter grade for the last semester in\n  the semester. The last semester is the semester that the teacher has taken\n  the course. For example, the last semester in the semester is semester 3, the\n  teacher has taken the course on semester 1. Write a function that takes\n  an array of grades and returns the letter grade for the last semester in\n  the semester. The last semester is the semester that the teacher has taken\n  the course. For example, the last semester in the semester is semester 3, the\n  teacher has taken the course on semester 1. Write a function that takes\n  an array of grades and returns the letter grade for the last semester in\n  the semester. The last semester is the semester that the teacher has taken\n  the course. For example, the last semester in the semester is semester 3, the\n  teacher has taken the course on semester 1. Write a function that takes\n  an array of grades and returns the letter grade for the last semester in\n  the semester. The last semester is the semester that the teacher has taken\n  the course. For example, the last semester in the semester is semester 3, the\n  teacher has taken the course on semester 1. Write a function that takes\n  an array of grades and returns the letter grade for the last semester in\n  the semester. The last semester is the semester that the teacher has taken\n  the course. For example, the last semester in the semester is semester 3, the\n  teacher has taken the course on semester 1. Write a function that takes\n  an array of grades and returns the letter grade for the last semester in\n  the semester. The last semester is the semester that the teacher has taken\n  the course. For example, the last semester in the semester is semester 3, the\n  teacher has taken the course on semester 1. Write a function that takes\n  an array of grades and returns the letter grade for the last semester in\n  the semester. The last semester is the seme", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/82", "prompt": "/*Write is a function that takes a string and returns true if the string length is a prime or otherwise wrong\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Write is a function that takes a string and returns true if the string length is a prime or otherwise wrong\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let isPrime = true;\n  let length = string.length;\n  for (let i = 2; i < length; i++) {\n    if (i % 2 === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('kittens') == false\n  */\nconst palindrome = (string) => {\n  let isPalindrome = true;\n  let length = string.length;\n  for (let i = length - 1; i >= 0; i--) {\n    if (string[i]!== string[length - i - 1]) {\n      isPalindrome = false;\n      break;\n    }\n  }\n  return isPalindrome;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('kittens') == false\n  */\nconst reverse = (string) => {\n  let isReverse = true;\n  let length = string.length;\n  for (let i = length - 1; i >= 0; i--) {\n    if (string[i]!== string[length - i - 1]) {\n      isReverse = false;\n      break;\n    }\n  }\n  return isReverse;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reverse('Hello') == true\n  reverse('kittens') == true\n  reverse('kittens') == false\n  */\nconst reverseWords = (string) => {\n  let isReverse = true;\n  let length = string.length;\n  for (let i = 0; i < length; i++) {\n    if (string[i]!== string[length - i - 1]) {\n      isReverse = false;\n      break;\n    }\n  }\n  return isReverse;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reverseWords('Hello') == true\n  reverseWords('kittens') == true\n  reverseWords('kittens') == false\n  */\nconst reverseWordsReverse = (string) => {\n  let isReverse = true;\n  let length = string.length;\n  for (let i = 0; i < length; i++) {\n    if (string[i]!== string[length - i - 1]) {\n      isReverse = false;\n      break;\n    }\n  }\n  return isReverse;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reverseWordsReverse('Hello') == true\n  reverseWordsReverse('kittens') == true\n  reverseWordsReverse('kittens') == false\n  */\nconst reverseWordsReverseWords = (string) => {\n  let isReverse = true;\n  let length = string.length;\n  for (let i = 0; i < length; i++) {\n    if (string[i]!== string[length - i - 1]) {\n      isReverse = false;\n      break;\n    }\n  }\n  return isReverse;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reverseWordsReverseWords('Hello') == true\n  reverseWordsReverseWords('kittens') == true\n  reverseWordsReverseWords('kittens') == false\n  */\nconst reverseWordsReverseWordsReverse = (string) => {\n  let isReverse = true;\n  let length = string.length;\n  for (let i = 0; i < length; i++) {\n    if (string[i]!== string[length - i - 1]) {\n      isReverse = false;\n      break;\n    }\n  }\n  return isReverse;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reverseWordsReverseWordsReverse('Hello') == true\n  reverseWordsReverseWordsReverse('kittens') == true\n  reverseWordsReverseWordsReverse('kittens') == false\n  */\nconst reverseWordsReverseWordsReverseWords = (string) => {\n  let isReverse = true;\n  let length = string.length;\n  for (let i = 0; i < length; i++) {\n    if (string[i]!== string[length - i - 1]) {\n      isReverse = false;\n      break;\n    }\n  }\n  return isReverse;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reverseWordsReverseWordsReverseWords('Hello') == true\n  reverseWordsReverseWordsReverseWords('kittens') == true\n  reverseWordsReverseWordsReverseWords('kittens') == false\n  */\nconst reverseWordsReverseWordsReverseWordsReverse = (string) => {\n  let isReverse = true;\n  let length = string.length;\n  for (let i = 0; i < length; i++) {\n    if (string[i]!== string[length - i - 1]) {\n      isReverse = false;\n      break;\n    }\n  }\n  return isReverse;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reverseWordsReverseWordsReverseWordsReverse('Hello') == true\n  reverseWordsReverseWordsReverseWordsReverse('kittens') == true\n  reverseWordsReverseWordsReverseWordsReverse('kittens') == false\n  */\nconst reverseWordsReverseWordsReverseWordsReverseWords = (string) => {\n  let isReverse = true;\n  let length = string.length;\n  for (let i = 0; i < length; i++) {\n    if (string[i]!== string[length - i - 1]) {\n      isReverse = false;\n      break;\n    }\n  }\n  return isReverse;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reverseWordsReverseWordsReverseWordsReverseWordsReverse('Hello') == true\n  reverseWordsReverseWordsReverseWordsReverseWordsReverse('kittens') == true\n  reverseWordsReverseWordsReverseWordsReverseWordsReverse('kittens') == false\n  */\nconst reverseWordsReverseWordsReverseWordsReverseWordsReverseWords = (string) => {\n  let isReverse = true;\n  let length = string.length;\n  for (let i = 0; i < length; i++) {\n    if (string[i]!== string[length - i - 1]) {\n      isReverse = false;\n      break;\n    }\n  }\n  return isReverse;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reverseWordsReverseWordsReverseWordsReverseWordsReverseWordsReverse('Hello') == true\n  reverseWordsReverseWordsReverseWordsReverseWordsReverseWordsReverse('kittens') == true\n  reverseWordsReverseWordsReverseWordsReverseWordsReverseWordsReverse('kittens') == false\n  */\nconst reverseWordsReverseWordsReverseWordsReverseWordsReverseWordsReverseWords = (string) => {\n  let isReverse = true;\n  let length = string.length;\n  for (let i = 0; i < length; i++) {\n    if (string[i]!== string[length - i - 1]) {\n      isReverse = false;\n      break;\n    }\n  }\n  return isReverse;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reverseWordsReverseWordsReverseWordsReverseWordsReverseWordsReverseWordsReverse('Hello') == true\n  reverseWordsReverseWordsReverseWordsReverseWordsReverseWordsReverseWordsReverse", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/83", "prompt": "/*\n  For a positive integer n, the number of n-digit positive integers starting or ending with 1 is returned. * / const startsOneEnds = (n) = > {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  For a positive integer n, the number of n-digit positive integers starting or ending with 1 is returned. * / const startsOneEnds = (n) = > {\n  n >= 0 && n <= 9\n}\n*/\n\nfunction startsOneEnds(n) {\n  return n >= 0 && n <= 9;\n}\n\nfunction endsOneStarts(n) {\n  return n >= 1 && n <= 9;\n}\n\nfunction startsOne(n) {\n  return startsOneEnds(n) && n!== 0;\n}\n\nfunction endsOne(n) {\n  return endsOneStarts(n) && n!== 0;\n}\n\nfunction startsWith(n) {\n  return n!== 0 && n.startsWith(n);\n}\n\nfunction endsWith(n) {\n  return n!== 0 && n.endsWith(n);\n}\n\nfunction startsWithCaseInsensitive(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithCaseInsensitive(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithIgnoreCase(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithIgnoreCase(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithIgnoreCaseInsensitive(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithIgnoreCaseInsensitive(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithCaseInsensitiveIgnoreCase(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithCaseInsensitiveIgnoreCase(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithCaseInsensitiveIgnoreCaseInsensitive(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithCaseInsensitiveIgnoreCaseInsensitive(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithCaseInsensitiveStartsWith(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithCaseInsensitiveStartsWith(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithCaseInsensitiveEndsWith(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithCaseInsensitiveEndsWith(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithCaseInsensitiveStartsWithCaseInsensitive(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithCaseInsensitiveStartsWithCaseInsensitive(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithCaseInsensitiveEndsWithCaseInsensitive(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithCaseInsensitiveEndsWithCaseInsensitive(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithCaseInsensitiveStartsWithIgnoreCase(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithCaseInsensitiveStartsWithIgnoreCase(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithCaseInsensitiveEndsWithIgnoreCase(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithCaseInsensitiveEndsWithIgnoreCase(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithCaseInsensitiveStartsWithIgnoreCaseInsensitive(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithCaseInsensitiveStartsWithIgnoreCaseInsensitive(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithCaseInsensitiveEndsWithIgnoreCaseInsensitive(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithCaseInsensitiveEndsWithIgnoreCaseInsensitive(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithCaseInsensitiveStartsWithCaseInsensitiveIgnoreCase(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithCaseInsensitiveStartsWithCaseInsensitiveIgnoreCase(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithCaseInsensitiveEndsWithCaseInsensitiveIgnoreCase(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithCaseInsensitiveEndsWithCaseInsensitiveIgnoreCase(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithCaseInsensitiveStartsWithCaseInsensitiveStartsWith(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithCaseInsensitiveStartsWithCaseInsensitiveStartsWith(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithCaseInsensitiveEndsWithCaseInsensitiveStartsWith(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithCaseInsensitiveEndsWithCaseInsensitiveStartsWith(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithCaseInsensitiveStartsWithCaseInsensitiveEndsWith(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithCaseInsensitiveStartsWithCaseInsensitiveEndsWith(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithCaseInsensitiveEndsWithCaseInsensitiveEndsWith(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithCaseInsensitiveEndsWithCaseInsensitiveEndsWith(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithCaseInsensitiveStartsWithCaseInsensitiveStartsWith(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithCaseInsensitiveStartsWithCaseInsensitiveStartsWith(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithCaseInsensitiveEndsWithCaseInsensitiveStartsWith(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithCaseInsensitiveEndsWithCaseInsensitiveStartsWith(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithCaseInsensitiveStartsWithCaseInsensitiveEndsWith(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithCaseInsensitiveStartsWithCaseInsensitiveEndsWith(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithCaseInsensitiveEndsWithCaseInsensitiveEndsWith(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithCaseInsensitiveEndsWithCaseInsensitiveEndsWith(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithCaseInsensitiveStartsWithCaseInsensitiveStartsWithCaseInsensitive(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithCaseInsensitiveStartsWithCaseInsensitiveStartsWithCaseInsensitive(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithCaseInsensitiveEndsWithCaseInsensitiveStartsWithCaseInsensitive(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithCaseInsensitiveEndsWithCaseInsensitiveStartsWithCaseInsensitive(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithCaseInsensitiveStartsWithCaseInsensitiveEndsWithCaseInsensitive(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithCaseInsensitiveStartsWithCaseInsensitiveEndsWithCaseInsensitive(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithCaseInsensitiveEndsWithCaseInsensitiveEndsWithCaseInsensitive(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithCaseInsensitiveEndsWithCaseInsensitiveEndsWithCaseInsensitive(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithCaseInsensitiveStartsWithCaseInsensitiveStartsWithCaseInsensitive(n) {\n  return n.startsWith(n);\n}\n\nfunction endsWithCaseInsensitiveStartsWithCaseInsensitiveStartsWithCaseInsensitive(n) {\n  return n.endsWith(n);\n}\n\nfunction startsWithCaseInsensitiveEndsWithCaseInsensitive", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/84", "prompt": "/*GIf you use a positive integer N, return the sum total of its digits in binary form.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*GIf you use a positive integer N, return the sum total of its digits in binary form.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  \n  for (let i = 0; i <= N; i++) {\n    binary = binary + binary(i).toString(2);\n    sum = sum + parseInt(binary, 2);\n  }\n  \n  return sum;\n};\n\n/*\n  Function: bin\n  Description: Converts a number into binary representation.\n  \n  Input:\n      a number N\n  Output:\n      a string of binary number\n  */\nconst bin = (N) => {\n  let binary = \"\";\n  \n  for (let i = 0; i <= N; i++) {\n    binary = binary + binary(i).toString(2);\n  }\n  \n  return binary;\n};\n\n/*\n  Function: reverse\n  Description: Reverses a string.\n  \n  Input:\n      a string\n  Output:\n      a reversed string\n  */\nconst reverse = (str) => {\n  let reversedString = \"\";\n  \n  for (let i = str.length - 1; i >= 0; i--) {\n    reversedString = reversedString + str[i];\n  }\n  \n  return reversedString;\n};\n\n/*\n  Function: reverse\n  Description: Reverses a string.\n  \n  Input:\n      a string\n  Output:\n      a reversed string\n  */\nconst reverse = (str) => {\n  let reversedString = \"\";\n  \n  for (let i = str.length - 1; i >= 0; i--) {\n    reversedString = reversedString + str[i];\n  }\n  \n  return reversedString;\n};\n\n/*\n  Function: reverse\n  Description: Reverses a string.\n  \n  Input:\n      a string\n  Output:\n      a reversed string\n  */\nconst reverse = (str) => {\n  let reversedString = \"\";\n  \n  for (let i = str.length - 1; i >= 0; i--) {\n    reversedString = reversedString + str[i];\n  }\n  \n  return reversedString;\n};\n\n/*\n  Function: reverse\n  Description: Reverses a string.\n  \n  Input:\n      a string\n  Output:\n      a reversed string\n  */\nconst reverse = (str) => {\n  let reversedString = \"\";\n  \n  for (let i = str.length - 1; i >= 0; i--) {\n    reversedString = reversedString + str[i];\n  }\n  \n  return reversedString;\n};\n\n/*\n  Function: reverse\n  Description: Reverses a string.\n  \n  Input:\n      a string\n  Output:\n      a reversed string\n  */\nconst reverse = (str) => {\n  let reversedString = \"\";\n  \n  for (let i = str.length - 1; i >= 0; i--) {\n    reversedString = reversedString + str[i];\n  }\n  \n  return reversedString;\n};\n\n/*\n  Function: reverse\n  Description: Reverses a string.\n  \n  Input:\n      a string\n  Output:\n      a reversed string\n  */\nconst reverse = (str) => {\n  let reversedString = \"\";\n  \n  for (let i = str.length - 1; i >= 0; i--) {\n    reversedString = reversedString + str[i];\n  }\n  \n  return reversedString;\n};\n\n/*\n  Function: reverse\n  Description: Reverses a string.\n  \n  Input:\n      a string\n  Output:\n      a reversed string\n  */\nconst reverse = (str) => {\n  let reversedString = \"\";\n  \n  for (let i = str.length - 1; i >= 0; i--) {\n    reversedString = reversedString + str[i];\n  }\n  \n  return reversedString;\n};\n\n/*\n  Function: reverse\n  Description: Reverses a string.\n  \n  Input:\n      a string\n  Output:\n      a reversed string\n  */\nconst reverse = (str) => {\n  let reversedString = \"\";\n  \n  for (let i = str.length - 1; i >= 0; i--) {\n    reversedString = reversedString + str[i];\n  }\n  \n  return reversedString;\n};\n\n/*\n  Function: reverse\n  Description: Reverses a string.\n  \n  Input:\n      a string\n  Output:\n      a reversed string\n  */\nconst reverse = (str) => {\n  let reversedString = \"\";\n  \n  for (let i = str.length - 1; i >= 0; i--) {\n    reversedString = reversedString + str[i];\n  }\n  \n  return reversedString;\n};\n\n/*\n  Function: reverse\n  Description: Reverses a string.\n  \n  Input:\n      a string\n  Output:\n      a reversed string\n  */\nconst reverse = (str) => {\n  let reversedString = \"\";\n  \n  for (let i = str.length - 1; i >= 0; i--) {\n    reversedString = reversedString + str[i];\n  }\n  \n  return reversedString;\n};\n\n/*\n  Function: reverse\n  Description: Reverses a string.\n  \n  Input:\n      a string\n  Output:\n      a reversed string\n  */\nconst reverse = (str) => {\n  let reversedString = \"\";\n  \n  for (let i = str.length - 1; i >= 0; i--) {\n    reversedString = reversedString + str[i];\n  }\n  \n  return reversedString;\n};\n\n/*\n  Function: reverse\n  Description: Reverses a string.\n  \n  Input:\n      a string\n  Output:\n      a reversed string\n  */\nconst reverse = (str) => {\n  let reversedString = \"\";\n  \n  for (let i = str.length - 1; i >= 0; i--) {\n    reversedString = reversedString + str[i];\n  }\n  \n  return reversedString;\n};\n\n/*\n  Function: reverse\n  Description: Reverses a string.\n  \n  Input:\n      a string\n  Output:\n      a reversed string\n  */\nconst reverse = (str) => {\n  let reversedString = \"\";\n  \n  for (let i = str.length - 1; i >= 0; i--) {\n    reversedString = reversedString + str[i];\n  }\n  \n  return reversedString;\n};\n\n/*\n  Function: reverse\n  Description: Reverses a string.\n  \n  Input:\n      a string\n  Output:\n      a reversed string\n  */\nconst reverse = (str) => {\n  let reversedString = \"\";\n  \n  for (let i = str.length - 1; i >= 0; i--) {\n    reversedString = reversedString + str[i];\n  }\n  \n  return reversedString;\n};\n\n/*\n  Function: reverse\n  Description: Reverses a string.\n  \n  Input:\n      a string\n  Output:\n      a reversed string\n  */\nconst reverse = (str) => {\n  let reversedString = \"\";\n  \n  for (let i = str.length - 1; i >= 0; i--) {\n    reversedString = reversedString + str[i];\n  }\n  \n  return reversedString;\n};\n\n/*\n  Function: reverse\n  Description: Reverses a string.\n  \n  Input:\n      a string\n  Output:\n      a reversed string\n  */\nconst reverse = (str) => {\n  let reversedString = \"\";\n  \n  for (let i = str.length - 1; i >= 0; i--) {\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. remove the even elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst remove = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. remove the even elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeEven = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. remove the odd elements that are at even indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeOdd = (lst, index) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd.splice(index, 1));\n};\n\n/*Given a non-empty list of integers lst. remove all elements that are at odd indices..\n\n\n  Examples:\n      removeAll([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeAll = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. remove all elements that are at even indices..\n\n\n  Examples:\n      removeAll([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeAllEven = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. remove all elements that are at odd indices..\n\n\n  Examples:\n      removeAll([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeAllOdd = (lst, index) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd.splice(index, 1));\n};\n\n/*Given a non-empty list of integers lst. remove all elements that are at even indices..\n\n\n  Examples:\n      removeAll([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeAllEvenOdd = (lst, index) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd.splice(index, 1));\n};\n\n/*Given a non-empty list of integers lst. remove all elements that are at odd indices..\n\n\n  Examples:\n      removeAll([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeAllOddEven = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. remove all elements that are at even indices..\n\n\n  Examples:\n      removeAll([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeAllOddEvenOdd = (lst, index) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd.splice(index, 1));\n};\n\n/*Given a non-empty list of integers lst. remove all elements that are at odd indices..\n\n\n  Examples:\n      removeAll([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeAllEvenOddOdd = (lst, index) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd.splice(index, 1));\n};\n\n/*Given a non-empty list of integers lst. remove all elements that are at odd indices..\n\n\n  Examples:\n      removeAll([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeAllOddEvenOddOdd = (lst, index) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd.splice(index, 1));\n};\n\n/*Given a non-empty list of integers lst. remove all elements that are at odd indices..\n\n\n  Examples:\n      removeAll([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeAllEvenOddEvenOddOdd = (lst, index) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd.splice(index, 1));\n};\n\n/*Given a non-empty list of integers lst. remove all elements that are at odd indices..\n\n\n  Examples:\n      removeAll([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeAllOddEvenOddEvenOddOdd = (lst, index) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd.splice(index, 1));\n};\n\n/*Given a non-empty list of integers lst. remove all elements that are at odd indices..\n\n\n  Examples:\n      removeAll([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeAllEvenOddEvenOddEvenOddOdd = (lst, index) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd.splice(index, 1));\n};\n\n/*Given a non-empty list of integers lst. remove all elements that are at odd indices..\n\n\n  Examples:\n      removeAll([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeAllOddEvenOddEvenOddEvenOddOdd = (lst, index) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd.splice(index, 1));\n};\n\n/*Given a non-empty list of integers lst. remove all elements that are at odd indices..\n\n\n  Examples:\n      removeAll([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeAllEvenOddEvenOddEvenOddEvenOddOdd = (lst, index) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd.", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a function that takes a string and returns an ordered version of it. The ordered version of string is a string in which all words (separated by spaces) are replaced by a new word in which all characters are ordered in ascending order based on the ascii value. Note: You should keep the order of words and spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that takes a string and returns an ordered version of it. The ordered version of string is a string in which all words (separated by spaces) are replaced by a new word in which all characters are ordered in ascending order based on the ascii value. Note: You should keep the order of words and spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newStr = '';\n  let word = '';\n  let i = 0;\n  let j = 0;\n  let temp = '';\n  let tempWord = '';\n  let tempWordWord = '';\n  let tempWordWordWord = '';\n  let tempWordWordWordWord = '';\n  let tempWordWordWordWordWord = '';\n  let tempWordWordWordWordWordWord = '';\n  let tempWordWordWordWordWordWordWord = '';\n  let tempWordWordWordWordWordWordWordWord = '';\n  let tempWordWordWordWordWordWordWordWordWord = '';\n  let tempWordWordWordWordWordWordWordWordWordWord = '';\n  let tempWordWordWordWordWordWordWordWordWordWordWord = '';\n  let tempWordWordWordWordWordWordWordWordWordWordWordWordWord = '';\n  let tempWordWordWordWordWordWordWordWordWordWordWordWordWordWordWord = '';\n  let tempWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWord", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const row = []\n  let i = 0\n  let j = 0\n  while (i < lst.length) {\n    if (lst[i][j] === x) {\n      row.push([i, j])\n      i++\n      j++\n    } else {\n      i++\n    }\n  }\n  row.sort((a, b) => a[1] - b[1])\n  return row\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getCol = (lst, x) => {\n  const col = []\n  let i = 0\n  let j = 0\n  while (i < lst.length) {\n    if (lst[j][i] === x) {\n      col.push([i, j])\n      i++\n      j++\n    } else {\n      i++\n    }\n  }\n  col.sort((a, b) => a[1] - b[1])\n  return col\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getDiag = (lst, x) => {\n  const diag = []\n  let i = 0\n  let j = 0\n  while (i < lst.length) {\n    if (lst[i][j] === x) {\n      diag.push([i, j])\n      i++\n      j++\n    } else {\n      i++\n    }\n  }\n  diag.sort((a, b) => a[1] - b[1])\n  return diag\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getDiagRow = (lst, x) => {\n  const diag = []\n  let i = 0\n  let j = 0\n  while (i < lst.length) {\n    if (lst[i][j] === x) {\n      diag.push([i, j])\n      i++\n      j++\n    } else {\n      i++\n    }\n  }\n  diag.sort((a, b) => a[1] - b[1])\n  return diag\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getDiagCol = (lst, x) => {\n  const diag = []\n  let i = 0\n  let j = 0\n  while (i < lst.length) {\n    if (lst[j][i] === x) {\n      diag.push([i, j])\n      i++\n      j++\n    } else {\n      i++\n    }\n  }\n  diag.sort((a, b) => a[1] - b[1])\n  return diag\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getDiagDiag = (lst, x) => {\n  const diag = []\n  let i = 0\n  let j = 0\n  while (i < lst.length) {\n    if (lst[i][j] === x) {\n      diag.push([i, j])\n      i++\n      j++\n    } else {\n      i++\n    }\n  }\n  diag.sort((a, b) => a[1] - b[1])\n  return diag\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/88", "prompt": "/*\n  For an array of non-negative integers, return a copy of the given array after sorting. You sort the given array in ascending order if the sum (first index value, last index value) is odd, or sort it in descending order if the sum (first index value, last index value) is even. Note: * Do not change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  For an array of non-negative integers, return a copy of the given array after sorting. You sort the given array in ascending order if the sum (first index value, last index value) is odd, or sort it in descending order if the sum (first index value, last index value) is even. Note: * Do not change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sortedArray = array.sort((a, b) => {\n    if (a % 2 === 0 && b % 2 === 0) {\n      return a - b;\n    }\n    return b - a;\n  });\n  return sortedArray;\n};\n\n/**\n * Given an array of integers, return an array of the same size where each element is the sum of the elements in the original array except for that element.\n\n  Examples:\n  * sumArray([1, 2, 3, 4, 5]) => [6, 5, 4, 3, 2, 1]\n  * sumArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * sumArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * sumArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  */\nconst sumArray = (array) => {\n  const sumArray = array.map((num) => {\n    return num;\n  });\n  return sumArray;\n};\n\n/**\n * Given an array of integers, return an array of the same size where each element is the difference of the elements in the original array except for that element.\n\n  Examples:\n  * differenceArray([1, 2, 3, 4, 5]) => [3, 4, 5]\n  * differenceArray([2, 3, 4, 5]) => [1, 2]\n  * differenceArray([2, 3, 4, 5]) => [3, 4, 5]\n  * differenceArray([2, 3, 4, 5]) => [3, 4, 5]\n  */\nconst differenceArray = (array) => {\n  const differenceArray = array.map((num) => {\n    return num - num;\n  });\n  return differenceArray;\n};\n\n/**\n * Given an array of integers, return an array of the same size where each element is the product of the elements in the original array except for that element.\n\n  Examples:\n  * productArray([1, 2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * productArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * productArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * productArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  */\nconst productArray = (array) => {\n  const productArray = array.map((num) => {\n    return num * num;\n  });\n  return productArray;\n};\n\n/**\n * Given an array of integers, return an array of the same size where each element is the quotient of the elements in the original array except for that element.\n\n  Examples:\n  * quotientArray([1, 2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * quotientArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * quotientArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * quotientArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  */\nconst quotientArray = (array) => {\n  const quotientArray = array.map((num) => {\n    return num / num;\n  });\n  return quotientArray;\n};\n\n/**\n * Given an array of integers, return an array of the same size where each element is the remainder of the elements in the original array except for that element.\n\n  Examples:\n  * remainderArray([1, 2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * remainderArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * remainderArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * remainderArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  */\nconst remainderArray = (array) => {\n  const remainderArray = array.map((num) => {\n    return num % num;\n  });\n  return remainderArray;\n};\n\n/**\n * Given an array of integers, return an array of the same size where each element is the absolute value of the elements in the original array except for that element.\n\n  Examples:\n  * absoluteArray([1, 2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * absoluteArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * absoluteArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * absoluteArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  */\nconst absoluteArray = (array) => {\n  const absoluteArray = array.map((num) => {\n    return Math.abs(num);\n  });\n  return absoluteArray;\n};\n\n/**\n * Given an array of integers, return an array of the same size where each element is the square root of the elements in the original array except for that element.\n\n  Examples:\n  * squareRootArray([1, 2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * squareRootArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * squareRootArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * squareRootArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  */\nconst squareRootArray = (array) => {\n  const squareRootArray = array.map((num) => {\n    return Math.sqrt(num);\n  });\n  return squareRootArray;\n};\n\n/**\n * Given an array of integers, return an array of the same size where each element is the absolute value of the elements in the original array except for that element.\n\n  Examples:\n  * absoluteValueArray([1, 2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * absoluteValueArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * absoluteValueArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * absoluteValueArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  */\nconst absoluteValueArray = (array) => {\n  const absoluteValueArray = array.map((num) => {\n    return Math.abs(num);\n  });\n  return absoluteValueArray;\n};\n\n/**\n * Given an array of integers, return an array of the same size where each element is the square root of the elements in the original array except for that element.\n\n  Examples:\n  * squareRootValueArray([1, 2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * squareRootValueArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * squareRootValueArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * squareRootValueArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  */\nconst squareRootValueArray = (array) => {\n  const squareRootValueArray = array.map((num) => {\n    return Math.sqrt(num);\n  });\n  return squareRootValueArray;\n};\n\n/**\n * Given an array of integers, return an array of the same size where each element is the square root of the elements in the original array except for that element.\n\n  Examples:\n  * squareRootValueArray([1, 2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * squareRootValueArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * squareRootValueArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * squareRootValueArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  */\nconst squareRootValueArray = (array) => {\n  const squareRootValueArray = array.map((num) => {\n    return Math.sqrt(num);\n  });\n  return squareRootValueArray;\n};\n\n/**\n * Given an array of integers, return an array of the same size where each element is the square root of the elements in the original array except for that element.\n\n  Examples:\n  * squareRootValueArray([1, 2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * squareRootValueArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * squareRootValueArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * squareRootValueArray([2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  */\nconst squareRootValueArray = (array) => {\n  const squareRootValueArray = array.map((num) => {\n    return Math.sqrt(num);\n  });\n  return squareRootValueArray;\n};\n\n/**\n * Given an array of integers, return an array of the same size where each element is the square root of the elements in the original array except for that element.\n\n  Examples:\n  * squareRootValueArray([1, 2, 3, 4, 5]) => [5, 4, 3, 2, 1]\n  * squareRootValueArray([2, 3, 4, 5]) => ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/89", "prompt": "/*CEncrypt a function that takes a string as argument and returns a string that is encrypted with the rotating alphabet. Rotate the alphabet so that the letters move down by two multiplied by two digits.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*CEncrypt a function that takes a string as argument and returns a string that is encrypted with the rotating alphabet. Rotate the alphabet so that the letters move down by two multiplied by two digits.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let result = '';\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let alphabetLength = alphabet.length;\n  let alphabetIndex = 0;\n  let alphabetIndex2 = 0;\n  let alphabetIndex3 = 0;\n  let alphabetIndex4 = 0;\n  let alphabetIndex5 = 0;\n  let alphabetIndex6 = 0;\n  let alphabetIndex7 = 0;\n  let alphabetIndex8 = 0;\n  let alphabetIndex9 = 0;\n  let alphabetIndex10 = 0;\n  let alphabetIndex11 = 0;\n  let alphabetIndex12 = 0;\n  let alphabetIndex13 = 0;\n  let alphabetIndex14 = 0;\n  let alphabetIndex15 = 0;\n  let alphabetIndex16 = 0;\n  let alphabetIndex17 = 0;\n  let alphabetIndex18 = 0;\n  let alphabetIndex19 = 0;\n  let alphabetIndex20 = 0;\n  let alphabetIndex21 = 0;\n  let alphabetIndex22 = 0;\n  let alphabetIndex23 = 0;\n  let alphabetIndex24 = 0;\n  let alphabetIndex25 = 0;\n  let alphabetIndex26 = 0;\n  let alphabetIndex27 = 0;\n  let alphabetIndex28 = 0;\n  let alphabetIndex29 = 0;\n  let alphabetIndex30 = 0;\n  let alphabetIndex31 = 0;\n  let alphabetIndex32 = 0;\n  let alphabetIndex33 = 0;\n  let alphabetIndex34 = 0;\n  let alphabetIndex35 = 0;\n  let alphabetIndex36 = 0;\n  let alphabetIndex37 = 0;\n  let alphabetIndex38 = 0;\n  let alphabetIndex39 = 0;\n  let alphabetIndex40 = 0;\n  let alphabetIndex41 = 0;\n  let alphabetIndex42 = 0;\n  let alphabetIndex43 = 0;\n  let alphabetIndex44 = 0;\n  let alphabetIndex45 = 0;\n  let alphabetIndex46 = 0;\n  let alphabetIndex47 = 0;\n  let alphabetIndex48 = 0;\n  let alphabetIndex49 = 0;\n  let alphabetIndex50 = 0;\n  let alphabetIndex51 = 0;\n  let alphabetIndex52 = 0;\n  let alphabetIndex53 = 0;\n  let alphabetIndex54 = 0;\n  let alphabetIndex55 = 0;\n  let alphabetIndex56 = 0;\n  let alphabetIndex57 = 0;\n  let alphabetIndex58 = 0;\n  let alphabetIndex59 = 0;\n  let alphabetIndex60 = 0;\n  let alphabetIndex61 = 0;\n  let alphabetIndex62 = 0;\n  let alphabetIndex63 = 0;\n  let alphabetIndex64 = 0;\n  let alphabetIndex65 = 0;\n  let alphabetIndex66 = 0;\n  let alphabetIndex67 = 0;\n  let alphabetIndex68 = 0;\n  let alphabetIndex69 = 0;\n  let alphabetIndex70 = 0;\n  let alphabetIndex71 = 0;\n  let alphabetIndex72 = 0;\n  let alphabetIndex73 = 0;\n  let alphabetIndex74 = 0;\n  let alphabetIndex75 = 0;\n  let alphabetIndex76 = 0;\n  let alphabetIndex77 = 0;\n  let alphabetIndex78 = 0;\n  let alphabetIndex79 = 0;\n  let alphabetIndex80 = 0;\n  let alphabetIndex81 = 0;\n  let alphabetIndex82 = 0;\n  let alphabetIndex83 = 0;\n  let alphabetIndex84 = 0;\n  let alphabetIndex85 = 0;\n  let alphabetIndex86 = 0;\n  let alphabetIndex87 = 0;\n  let alphabetIndex88 = 0;\n  let alphabetIndex89 = 0;\n  let alphabetIndex90 = 0;\n  let alphabetIndex91 = 0;\n  let alphabetIndex92 = 0;\n  let alphabetIndex93 = 0;\n  let alphabetIndex94 = 0;\n  let alphabetIndex95 = 0;\n  let alphabetIndex96 = 0;\n  let alphabetIndex97 = 0;\n  let alphabetIndex98 = 0;\n  let alphabetIndex99 = 0;\n  let alphabetIndex100 = 0;\n  let alphabetIndex101 = 0;\n  let alphabetIndex102 = 0;\n  let alphabetIndex103 = 0;\n  let alphabetIndex104 = 0;\n  let alphabetIndex105 = 0;\n  let alphabetIndex106 = 0;\n  let alphabetIndex107 = 0;\n  let alphabetIndex108 = 0;\n  let alphabetIndex109 = 0;\n  let alphabetIndex110 = 0;\n  let alphabetIndex111 = 0;\n  let alphabetIndex112 = 0;\n  let alphabetIndex113 = 0;\n  let alphabetIndex114 = 0;\n  let alphabetIndex115 = 0;\n  let alphabetIndex116 = 0;\n  let alphabetIndex117 = 0;\n  let alphabetIndex118 = 0;\n  let alphabetIndex119 = 0;\n  let alphabetIndex120 = 0;\n  let alphabetIndex121 = 0;\n  let alphabetIndex122 = 0;\n  let alphabetIndex123 = 0;\n  let alphabetIndex124 = 0;\n  let alphabetIndex125 = 0;\n  let alphabetIndex126 = 0;\n  let alphabetIndex127 = 0;\n  let alphabetIndex128 = 0;\n  let alphabetIndex129 = 0;\n  let alphabetIndex130 = 0;\n  let alphabetIndex131 = 0;\n  let alphabetIndex132 = 0;\n  let alphabetIndex133 = 0;\n  let alphabetIndex134 = 0;\n  let alphabetIndex135 = 0;\n  let alphabetIndex136 = 0;\n  let alphabetIndex137 = 0;\n  let alphabetIndex138 = 0;\n  let alphabetIndex139 = 0;\n  let alphabetIndex140 = 0;\n  let alphabetIndex141 = 0;\n  let alphabetIndex142 = 0;\n  let alphabetIndex143 = 0;\n  let alphabetIndex144 = 0;\n  let alphabetIndex145 = 0;\n  let alphabetIndex146 = 0;\n  let alphabetIndex147 = 0;\n  let alphabetIndex148 = 0;\n  let alphabetIndex149 = 0;\n  let alphabetIndex150 = 0;\n  let alphabetIndex151 = 0;\n  let alphabetIndex152 = 0;\n  let alphabetIndex153 = 0;\n  let alphabetIndex154 = 0;\n  let alphabetIndex155 = 0;\n  let alphabetIndex156 = 0;\n  let alphabetIndex157 = 0;\n  let alphabetIndex158 = 0;\n  let alphabetIndex159 = 0;\n  let alphabetIndex160 = 0;\n  let alphabetIndex161 = 0;\n  let alphabetIndex162 = 0;\n  let alphabetIndex163 = 0;\n  let alphabetIndex164 = 0;\n  let alphabetIndex165 = 0;\n  let alphabetIndex166 = 0;\n  let alphabetIndex167 = 0;\n  let alphabetIndex168 = 0;\n  let alphabetIndex169 = 0;\n  let alphabetIndex170 = 0;\n  let alphabetIndex171 = 0;\n  let alphabetIndex172 = 0;\n  let alphabetIndex173 = 0;\n  let alphabetIndex174 = 0;\n  let alphabetIndex175 = 0;\n  let alphabetIndex176 = 0;\n  let alphabetIndex177 = 0;\n  let alphabetIndex178 = 0;\n  let alphabetIndex179 = 0;\n  let alphabetIndex180 = 0;\n  let alphabetIndex181 = 0;\n  let alphabetIndex182 = 0;\n  let alphabetIndex183 = 0;\n  let alphabetIndex184 = 0;\n  let alphabetIndex185 = 0;\n  let alphabetIndex186 = 0;\n  let alphabetIndex187 = 0;\n  let alphabetIndex188 = 0;\n  let alphabetIndex189 = 0;\n  let alphabetIndex190 = 0;\n  let alphabetIndex191 = 0;\n  let alphabetIndex192 = 0;\n  let alphabetIndex193 = 0;\n  let alphabetIndex194 = 0;\n  let alphabetIndex195 = 0;\n  let alphabetIndex196 = 0;\n  let alphabetIndex197 = 0;\n  let alphabetIndex198 = 0;\n  let alphabetIndex199 = 0;\n  let alphabetIndex200 = 0;\n  let alphabetIndex201 = 0;\n  let alphabetIndex202 = 0;\n  let alphabetIndex203 = 0;\n  let alphabetIndex204 = 0;\n  let alphabetIndex205 = 0;\n  let alphabetIndex206 = 0;\n  let alphabetIndex207 = 0;\n  let alphabetIndex208 = 0;\n  let alphabetIndex209 = 0;\n  let alphabetIndex210 = 0;\n  let alphabetIndex211 = 0;\n  let alphabetIndex212 = 0;\n  let alphabetIndex213 = 0;\n  let alphabetIndex214 = 0;\n  let alphabetIndex215 = 0;\n  let alphabetIndex216 = 0;\n  let alphabetIndex217 = 0;\n  let alphabetIndex218 = 0;\n  let alphabetIndex219 = 0;\n  let alphabetIndex220 = 0;\n  let alphabetIndex221 = 0;\n  let alphabetIndex222 = 0;\n  let alphabetIndex223 = 0;\n  let alphabetIndex224 = 0;\n  let alphabetIndex225 = 0;\n  let alphabetIndex226 = 0;\n  let alphabetIndex227 = 0;\n  let alphabetIndex228 = 0;\n  let alphabetIndex229 = 0;\n  let alphabetIndex230 = 0;\n  let alphabetIndex231 = 0;\n  let alphabetIndex232 = 0;\n  let alphabetIndex233 = 0;\n  let alphabetIndex234 = 0;\n  let alphabetIndex235 = 0;\n  let alphabetIndex236 = 0;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/9", "prompt": "/* Generate from a given list of integers a list of rotating maximum elements found up to a certain moment in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Generate from a given list of integers a list of rotating maximum elements found up to a certain moment in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const maxNumbers = numbers.reduce((acc, curr) => Math.max(acc, curr), 0);\n  const maxNumbersArray = Array.from(new Array(maxNumbers), () => 0);\n  let maxNumbersIndex = 0;\n  let maxNumbersValue = 0;\n  let maxNumbersIndexArray = [];\n  let maxNumbersValueArray = [];\n  let maxNumbersIndexArrayLength = 0;\n  let maxNumbersValueArrayLength = 0;\n  let maxNumbersIndexArrayIndex = 0;\n  let maxNumbersValueArrayIndex = 0;\n  let maxNumbersIndexArrayValue = 0;\n  let maxNumbersValueArrayValue = 0;\n  let maxNumbersIndexArrayIndexValue = 0;\n  let maxNumbersValueArrayIndexValue = 0;\n  let maxNumbersIndexArrayValueValue = 0;\n  let maxNumbersValueArrayValueValue = 0;\n  let maxNumbersIndexArrayIndexValueValue = 0;\n  let maxNumbersValueArrayIndexValueValue = 0;\n  let maxNumbersIndexArrayValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValue = 0;\n  let maxNumbersIndexArrayIndexValueValueValue = 0;\n  let maxNumbersValueArrayIndexValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersValueArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersIndexArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxNumbersValue", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/90", "prompt": "/*\n  Write a function nextSmallest () that returns the second smallest element in the list. Returns zero if there is no such element. nextSmallest ([1, 2, 3, 4, 5]) = = 2 nextSmallest ([5, 1, 4, 3, 2]) = = 2 nextSmallest ([]) = = null nextSmallest ([1, 1]) = = null * / const nextSmallest = (lst) = > {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function nextSmallest () that returns the second smallest element in the list. Returns zero if there is no such element. nextSmallest ([1, 2, 3, 4, 5]) = = 2 nextSmallest ([5, 1, 4, 3, 2]) = = 2 nextSmallest ([]) = = null nextSmallest ([1, 1]) = = null * / const nextSmallest = (lst) = > {\n    const n = lst.length;\n    if (n === 0) return null;\n    if (n === 1) return lst[0];\n    if (n === 2) return lst[1];\n    if (n % 2 === 0) return nextSmallest(lst[Math.floor(n / 2)]);\n    return nextSmallest(lst[Math.floor(n / 2) + 1]);\n  }\n*/\n\n// Write a function nextBiggest () that returns the biggest element in the list. Returns zero if there is no such element. nextBiggest ([1, 2, 3, 4, 5]) = = 5 nextBiggest ([5, 1, 4, 3, 2]) = = 5 nextBiggest ([]) = = null nextBiggest ([1, 1]) = = null * / const nextBiggest = (lst) = > {\n    const n = lst.length;\n    if (n === 0) return null;\n    if (n === 1) return lst[0];\n    if (n === 2) return lst[1];\n    if (n % 2 === 0) return nextBiggest(lst[Math.floor(n / 2)]);\n    return nextBiggest(lst[Math.floor(n / 2) + 1]);\n  }\n\n// Write a function nextBiggest () that returns the biggest element in the list. Returns zero if there is no such element. nextBiggest ([1, 2, 3, 4, 5]) = = 5 nextBiggest ([5, 1, 4, 3, 2]) = = 5 nextBiggest ([]) = = null nextBiggest ([1, 1]) = = null * / const nextBiggest = (lst) = > {\n    const n = lst.length;\n    if (n === 0) return null;\n    if (n === 1) return lst[0];\n    if (n === 2) return lst[1];\n    if (n % 2 === 0) return nextBiggest(lst[Math.floor(n / 2)]);\n    return nextBiggest(lst[Math.floor(n / 2) + 1]);\n  }\n\n// Write a function nextBiggest () that returns the biggest element in the list. Returns zero if there is no such element. nextBiggest ([1, 2, 3, 4, 5]) = = 5 nextBiggest ([5, 1, 4, 3, 2]) = = 5 nextBiggest ([]) = = null nextBiggest ([1, 1]) = = null * / const nextBiggest = (lst) = > {\n    const n = lst.length;\n    if (n === 0) return null;\n    if (n === 1) return lst[0];\n    if (n === 2) return lst[1];\n    if (n % 2 === 0) return nextBiggest(lst[Math.floor(n / 2)]);\n    return nextBiggest(lst[Math.floor(n / 2) + 1]);\n  }\n\n// Write a function nextBiggest () that returns the biggest element in the list. Returns zero if there is no such element. nextBiggest ([1, 2, 3, 4, 5]) = = 5 nextBiggest ([5, 1, 4, 3, 2]) = = 5 nextBiggest ([]) = = null nextBiggest ([1, 1]) = = null * / const nextBiggest = (lst) = > {\n    const n = lst.length;\n    if (n === 0) return null;\n    if (n === 1) return lst[0];\n    if (n === 2) return lst[1];\n    if (n % 2 === 0) return nextBiggest(lst[Math.floor(n / 2)]);\n    return nextBiggest(lst[Math.floor(n / 2) + 1]);\n  }\n\n// Write a function nextBiggest () that returns the biggest element in the list. Returns zero if there is no such element. nextBiggest ([1, 2, 3, 4, 5]) = = 5 nextBiggest ([5, 1, 4, 3, 2]) = = 5 nextBiggest ([]) = = null nextBiggest ([1, 1]) = = null * / const nextBiggest = (lst) = > {\n    const n = lst.length;\n    if (n === 0) return null;\n    if (n === 1) return lst[0];\n    if (n === 2) return lst[1];\n    if (n % 2 === 0) return nextBiggest(lst[Math.floor(n / 2)]);\n    return nextBiggest(lst[Math.floor(n / 2) + 1]);\n  }\n\n// Write a function nextBiggest () that returns the biggest element in the list. Returns zero if there is no such element. nextBiggest ([1, 2, 3, 4, 5]) = = 5 nextBiggest ([5, 1, 4, 3, 2]) = = 5 nextBiggest ([]) = = null nextBiggest ([1, 1]) = = null * / const nextBiggest = (lst) = > {\n    const n = lst.length;\n    if (n === 0) return null;\n    if (n === 1) return lst[0];\n    if (n === 2) return lst[1];\n    if (n % 2 === 0) return nextBiggest(lst[Math.floor(n / 2)]);\n    return nextBiggest(lst[Math.floor(n / 2) + 1]);\n  }\n\n// Write a function nextBiggest () that returns the biggest element in the list. Returns zero if there is no such element. nextBiggest ([1, 2, 3, 4, 5]) = = 5 nextBiggest ([5, 1, 4, 3, 2]) = = 5 nextBiggest ([]) = = null nextBiggest ([1, 1]) = = null * / const nextBiggest = (lst) = > {\n    const n = lst.length;\n    if (n === 0) return null;\n    if (n === 1) return lst[0];\n    if (n === 2) return lst[1];\n    if (n % 2 === 0) return nextBiggest(lst[Math.floor(n / 2)]);\n    return nextBiggest(lst[Math.floor(n / 2) + 1]);\n  }\n\n// Write a function nextBiggest () that returns the biggest element in the list. Returns zero if there is no such element. nextBiggest ([1, 2, 3, 4, 5]) = = 5 nextBiggest ([5, 1, 4, 3, 2]) = = 5 nextBiggest ([]) = = null nextBiggest ([1, 1]) = = null * / const nextBiggest = (lst) = > {\n    const n = lst.length;\n    if (n === 0) return null;\n    if (n === 1) return lst[0];\n    if (n === 2) return lst[1];\n    if (n % 2 === 0) return nextBiggest(lst[Math.floor(n / 2)]);\n    return nextBiggest(lst[Math.floor(n / 2) + 1]);\n  }\n\n// Write a function nextBiggest () that returns the biggest element in the list. Returns zero if there is no such element. nextBiggest ([1, 2, 3, 4, 5]) = = 5 nextBiggest ([5, 1, 4, 3, 2]) = = 5 nextBiggest ([]) = = null nextBiggest ([1, 1]) = = null * / const nextBiggest = (lst) = > {\n    const n = lst.length;\n    if (n === 0) return null;\n    if (n === 1) return lst[0];\n    if (n === 2) return lst[1];\n    if (n % 2 === 0) return nextBiggest(lst[Math.floor(n / 2)]);\n    return nextBiggest(lst[Math.floor(n / 2) + 1]);\n  }\n\n// Write a function nextBiggest () that returns the biggest element in the list. Returns zero if there is no such element. nextBiggest ([1, 2, 3, 4, 5]) = = 5 nextBiggest ([5, 1, 4, 3, 2]) = = 5 nextBiggest ([]) = = null nextBiggest ([1, 1]) = = null * / const nextBiggest = (lst) = > {\n    const n = lst.length;\n    if (n === 0) return null;\n    if (n === 1) return lst[0];\n    if (n === 2) return lst[1];\n    if (n % 2 === 0) return nextBiggest(lst[Math.floor(n / 2)]);\n    return nextBiggest(lst[Math.floor(n / 2) + 1]);\n  }\n\n// Write a function nextBiggest () that returns the biggest element in the list. Returns zero if there is no such element. nextBiggest ([1, 2, 3, 4, 5]) = = 5 nextBiggest ([5, 1, 4, 3, 2]) = = 5 nextBiggest ([]) = = null nextBiggest ([1, 1]) = = null * / const nextBiggest = (lst) = > {\n    const n = lst.length;\n    if (n === 0) return null;\n    if (", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/91", "prompt": "/*\n  Boredom is a sentence that begins with the word \"I.\" Sentences are delimited by. \",\"? \"or\"!. \"For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  Boredom is a sentence that begins with the word \"I.\" Sentences are delimited by. \",\"? \"or\"!. \"For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  const bored = S.split(\" \");\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/92", "prompt": "/* Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  return x === y && y === z || x === -y && y === z || x === -z && y === z || x === y && -y === z || x === -y && -z === z || x === -z && -y === z || x === -z && -z === y || x === y && -y === -z || x === -y && -z === -z || x === -z && -y === -z || x === -z && -z === -y;\n};\n\n// Create a function consisting of 3 numbers. Returns true if all numbers are equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\nconst allInt = (x, y, z) => {\n  return x === y && y === z || x === -y && y === z || x === -z && y === z || x === y && -y === z || x === -y && -z === z || x === -z && -y === z || x === -z && -z === y || x === y && -y === -z || x === -y && -z === -z || x === -z && -y === -z || x === -z && -z === -y;\n};\n\n// Create a function consisting of 3 numbers. Returns true if all numbers are equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\nconst allIntOrZero = (x, y, z) => {\n  return x === y && y === z || x === -y && y === z || x === -z && y === z || x === y && -y === z || x === -y && -z === z || x === -z && -y === z || x === -z && -z === y || x === y && -y === -z || x === -y && -z === -z || x === -z && -y === -z || x === -z && -z === -y;\n};\n\n// Create a function consisting of 3 numbers. Returns true if all numbers are equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\nconst allIntOrZeroOrZero = (x, y, z) => {\n  return x === y && y === z || x === -y && y === z || x === -z && y === z || x === y && -y === z || x === -y && -z === z || x === -z && -y === z || x === -z && -z === y || x === y && -y === -z || x === -y && -z === -z || x === -z && -y === -z || x === -z && -z === -y;\n};\n\n// Create a function consisting of 3 numbers. Returns true if all numbers are equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\nconst allIntOrZeroOrZeroOrZero = (x, y, z) => {\n  return x === y && y === z || x === -y && y === z || x === -z && y === z || x === y && -y === z || x === -y && -z === z || x === -z && -y === z || x === -z && -z === y || x === y && -y === -z || x === -y && -z === -z || x === -z && -y === -z || x === -z && -z === -y;\n};\n\n// Create a function consisting of 3 numbers. Returns true if all numbers are equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\nconst allIntOrZeroOrZeroOrZeroOrZero = (x, y, z) => {\n  return x === y && y === z || x === -y && y === z || x === -z && y === z || x === y && -y === z || x === -y && -z === z || x === -z && -y === z || x === -z && -z === y || x === y && -y === -z || x === -y && -z === -z || x === -z && -y === -z || x === -z && -z === -y;\n};\n\n// Create a function consisting of 3 numbers. Returns true if all numbers are equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\nconst allIntOrZeroOrZeroOrZeroOrZeroOrZero = (x, y, z) => {\n  return x === y && y === z || x === -y && y === z || x === -z && y === z || x === y && -y === z || x === -y && -z === z || x === -z && -y === z || x === -z && -z === y || x === y && -y === -z || x === -y && -z === -z || x === -z && -y === -z || x === -z && -z === -y;\n};\n\n// Create a function consisting of 3 numbers. Returns true if all numbers are equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\nconst allIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = (x, y, z) => {\n  return x === y && y === z || x === -y && y === z || x === -z && y === z || x === y && -y === z || x === -y && -z === z || x === -z && -y === z || x === -z && -z === y || x === y && -y === -z || x === -y && -z === -z || x === -z && -y === -z || x === -z && -z === -y;\n};\n\n// Create a function consisting of 3 numbers. Returns true if all numbers are equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\nconst allIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = (x, y, z) => {\n  return x === y && y === z || x === -y && y === z || x === -z && y === z || x === y && -y === z || x === -y && -z === z || x === -z && -y === z || x === -z && -z === y || x === y && -y === -z || x === -y && -z === -z || x === -z && -y === -z || x === -z && -z === -y;\n};\n\n// Create a function consisting of 3 numbers. Returns true if all numbers are equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\nconst allIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = (x, y, z) => {\n  return x === y && y === z || x === -y && y === z || x === -z && y === z || x === y && -y === z || x === -y && -z === z || x === -z && -", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a function that captures a message and encodes it so that it reverses the uppercase letters of all letters and replaces all vowels in the message with the letter that appears 2 places in front of that vowel in the English alphabet. Let's just say letters. Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that captures a message and encodes it so that it reverses the uppercase letters of all letters and replaces all vowels in the message with the letter that appears 2 places in front of that vowel in the English alphabet. Let's just say letters. Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  const vowels = 'aeiouy';\n  const letters = message.split('');\n  let encoded = '';\n  for (let i = 0; i < letters.length; i++) {\n    const letter = letters[i];\n    if (vowels.includes(letter)) {\n      encoded += letter;\n    } else {\n      encoded += letters.charAt(i);\n    }\n  }\n  return encoded;\n};\n\n/*\n  Write a function that decodes a message and decodes it so that it reverses the uppercase letters of all letters and replaces all vowels in the message with the letter that appears 2 places in front of that vowel in the English alphabet. Let's just say letters. Examples:\n  >>> decode('TGST')\n  'test'\n  >>> decode('tHKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst decode = (message) => {\n  const vowels = 'aeiouy';\n  const letters = message.split('');\n  let decoded = '';\n  for (let i = 0; i < letters.length; i++) {\n    const letter = letters[i];\n    if (vowels.includes(letter)) {\n      decoded += letter;\n    } else {\n      decoded += letters.charAt(i);\n    }\n  }\n  return decoded;\n};\n\n/*\n  Write a function that reverses a message and decodes it so that it reverses the uppercase letters of all letters and replaces all vowels in the message with the letter that appears 2 places in front of that vowel in the English alphabet. Let's just say letters. Examples:\n  >>> reverse('TGST')\n  'test'\n  >>> reverse('tHKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst reverse = (message) => {\n  const vowels = 'aeiouy';\n  const letters = message.split('');\n  let reversed = '';\n  for (let i = 0; i < letters.length; i++) {\n    const letter = letters[i];\n    if (vowels.includes(letter)) {\n      reversed += letter;\n    } else {\n      reversed += letters.charAt(i);\n    }\n  }\n  return reversed;\n};\n\n/*\n  Write a function that reverses a message and encodes it so that it reverses the uppercase letters of all letters and replaces all vowels in the message with the letter that appears 2 places in front of that vowel in the English alphabet. Let's just say letters. Examples:\n  >>> encode('TGST')\n  'test'\n  >>> encode('tHKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst encodeReverse = (message) => {\n  const vowels = 'aeiouy';\n  const letters = message.split('');\n  let encoded = '';\n  for (let i = 0; i < letters.length; i++) {\n    const letter = letters[i];\n    if (vowels.includes(letter)) {\n      encoded += letter;\n    } else {\n      encoded += letters.charAt(i);\n    }\n  }\n  return encoded;\n};\n\n/*\n  Write a function that reverses a message and decodes it so that it reverses the uppercase letters of all letters and replaces all vowels in the message with the letter that appears 2 places in front of that vowel in the English alphabet. Let's just say letters. Examples:\n  >>> decode('TGST')\n  'test'\n  >>> decode('tHKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst decodeReverse = (message) => {\n  const vowels = 'aeiouy';\n  const letters = message.split('');\n  let decoded = '';\n  for (let i = 0; i < letters.length; i++) {\n    const letter = letters[i];\n    if (vowels.includes(letter)) {\n      decoded += letter;\n    } else {\n      decoded += letters.charAt(i);\n    }\n  }\n  return decoded;\n};\n\n/*\n  Write a function that reverses a message and encodes it so that it reverses the uppercase letters of all letters and replaces all vowels in the message with the letter that appears 2 places in front of that vowel in the English alphabet. Let's just say letters. Examples:\n  >>> encode('TGST')\n  'test'\n  >>> encode('tHKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst encodeReverseReverse = (message) => {\n  const vowels = 'aeiouy';\n  const letters = message.split('');\n  let encoded = '';\n  for (let i = 0; i < letters.length; i++) {\n    const letter = letters[i];\n    if (vowels.includes(letter)) {\n      encoded += letter;\n    } else {\n      encoded += letters.charAt(i);\n    }\n  }\n  return encoded;\n};\n\n/*\n  Write a function that reverses a message and decodes it so that it reverses the uppercase letters of all letters and replaces all vowels in the message with the letter that appears 2 places in front of that vowel in the English alphabet. Let's just say letters. Examples:\n  >>> decode('TGST')\n  'test'\n  >>> decode('tHKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst decodeReverseReverse = (message) => {\n  const vowels = 'aeiouy';\n  const letters = message.split('');\n  let decoded = '';\n  for (let i = 0; i < letters.length; i++) {\n    const letter = letters[i];\n    if (vowels.includes(letter)) {\n      decoded += letter;\n    } else {\n      decoded += letters.charAt(i);\n    }\n  }\n  return decoded;\n};\n\n/*\n  Write a function that reverses a message and encodes it so that it reverses the uppercase letters of all letters and replaces all vowels in the message with the letter that appears 2 places in front of that vowel in the English alphabet. Let's just say letters. Examples:\n  >>> encode('TGST')\n  'test'\n  >>> encode('tHKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst encodeReverseReverseReverse = (message) => {\n  const vowels = 'aeiouy';\n  const letters = message.split('');\n  let encoded = '';\n  for (let i = 0; i < letters.length; i++) {\n    const letter = letters[i];\n    if (vowels.includes(letter)) {\n      encoded += letter;\n    } else {\n      encoded += letters.charAt(i);\n    }\n  }\n  return encoded;\n};\n\n/*\n  Write a function that reverses a message and decodes it so that it reverses the uppercase letters of all letters and replaces all vowels in the message with the letter that appears 2 places in front of that vowel in the English alphabet. Let's just say letters. Examples:\n  >>> decode('TGST')\n  'test'\n  >>> decode('tHKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst decodeReverseReverseReverse = (message) => {\n  const vowels = 'aeiouy';\n  const letters = message.split('');\n  let decoded = '';\n  for (let i = 0; i < letters.length; i++) {\n    const letter = letters[i];\n    if (vowels.includes(letter)) {\n      decoded += letter;\n    } else {\n      decoded += letters.charAt(i);\n    }\n  }\n  return decoded;\n};\n\n/*\n  Write a function that reverses a message and encodes it so that it reverses the uppercase letters of all letters and replaces all vowels in the message with the letter that appears 2 places in front of that vowel in the English alphabet. Let's just say letters. Examples:\n  >>> encode('TGST')\n  'test'\n  >>> encode('tHKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst encodeReverseReverseReverse = (message) => {\n  const vowels = 'aeiouy';\n  const ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/94", "prompt": "/*YYou get a list of integers. You have to find the largest primary value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*YYou get a list of integers. You have to find the largest primary value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let sum = 0;\n  let max = 0;\n  let maxDigit = 0;\n  let maxDigitSum = 0;\n  let maxDigitSum2 = 0;\n  let maxDigitSum3 = 0;\n  let maxDigitSum4 = 0;\n  let maxDigitSum5 = 0;\n  let maxDigitSum6 = 0;\n  let maxDigitSum7 = 0;\n  let maxDigitSum8 = 0;\n  let maxDigitSum9 = 0;\n  let maxDigitSum10 = 0;\n  let maxDigitSum11 = 0;\n  let maxDigitSum12 = 0;\n  let maxDigitSum13 = 0;\n  let maxDigitSum14 = 0;\n  let maxDigitSum15 = 0;\n  let maxDigitSum16 = 0;\n  let maxDigitSum17 = 0;\n  let maxDigitSum18 = 0;\n  let maxDigitSum19 = 0;\n  let maxDigitSum20 = 0;\n  let maxDigitSum21 = 0;\n  let maxDigitSum22 = 0;\n  let maxDigitSum23 = 0;\n  let maxDigitSum24 = 0;\n  let maxDigitSum25 = 0;\n  let maxDigitSum26 = 0;\n  let maxDigitSum27 = 0;\n  let maxDigitSum28 = 0;\n  let maxDigitSum29 = 0;\n  let maxDigitSum30 = 0;\n  let maxDigitSum31 = 0;\n  let maxDigitSum32 = 0;\n  let maxDigitSum33 = 0;\n  let maxDigitSum34 = 0;\n  let maxDigitSum35 = 0;\n  let maxDigitSum36 = 0;\n  let maxDigitSum37 = 0;\n  let maxDigitSum38 = 0;\n  let maxDigitSum39 = 0;\n  let maxDigitSum40 = 0;\n  let maxDigitSum41 = 0;\n  let maxDigitSum42 = 0;\n  let maxDigitSum43 = 0;\n  let maxDigitSum44 = 0;\n  let maxDigitSum45 = 0;\n  let maxDigitSum46 = 0;\n  let maxDigitSum47 = 0;\n  let maxDigitSum48 = 0;\n  let maxDigitSum49 = 0;\n  let maxDigitSum50 = 0;\n  let maxDigitSum51 = 0;\n  let maxDigitSum52 = 0;\n  let maxDigitSum53 = 0;\n  let maxDigitSum54 = 0;\n  let maxDigitSum55 = 0;\n  let maxDigitSum56 = 0;\n  let maxDigitSum57 = 0;\n  let maxDigitSum58 = 0;\n  let maxDigitSum59 = 0;\n  let maxDigitSum60 = 0;\n  let maxDigitSum61 = 0;\n  let maxDigitSum62 = 0;\n  let maxDigitSum63 = 0;\n  let maxDigitSum64 = 0;\n  let maxDigitSum65 = 0;\n  let maxDigitSum66 = 0;\n  let maxDigitSum67 = 0;\n  let maxDigitSum68 = 0;\n  let maxDigitSum69 = 0;\n  let maxDigitSum70 = 0;\n  let maxDigitSum71 = 0;\n  let maxDigitSum72 = 0;\n  let maxDigitSum73 = 0;\n  let maxDigitSum74 = 0;\n  let maxDigitSum75 = 0;\n  let maxDigitSum76 = 0;\n  let maxDigitSum77 = 0;\n  let maxDigitSum78 = 0;\n  let maxDigitSum79 = 0;\n  let maxDigitSum80 = 0;\n  let maxDigitSum81 = 0;\n  let maxDigitSum82 = 0;\n  let maxDigitSum83 = 0;\n  let maxDigitSum84 = 0;\n  let maxDigitSum85 = 0;\n  let maxDigitSum86 = 0;\n  let maxDigitSum87 = 0;\n  let maxDigitSum88 = 0;\n  let maxDigitSum89 = 0;\n  let maxDigitSum90 = 0;\n  let maxDigitSum91 = 0;\n  let maxDigitSum92 = 0;\n  let maxDigitSum93 = 0;\n  let maxDigitSum94 = 0;\n  let maxDigitSum95 = 0;\n  let maxDigitSum96 = 0;\n  let maxDigitSum97 = 0;\n  let maxDigitSum98 = 0;\n  let maxDigitSum99 = 0;\n  let maxDigitSum100 = 0;\n  let maxDigitSum101 = 0;\n  let maxDigitSum102 = 0;\n  let maxDigitSum103 = 0;\n  let maxDigitSum104 = 0;\n  let maxDigitSum105 = 0;\n  let maxDigitSum106 = 0;\n  let maxDigitSum107 = 0;\n  let maxDigitSum108 = 0;\n  let maxDigitSum109 = 0;\n  let maxDigitSum110 = 0;\n  let maxDigitSum111 = 0;\n  let maxDigitSum112 = 0;\n  let maxDigitSum113 = 0;\n  let maxDigitSum114 = 0;\n  let maxDigitSum115 = 0;\n  let maxDigitSum116 = 0;\n  let maxDigitSum117 = 0;\n  let maxDigitSum118 = 0;\n  let maxDigitSum119 = 0;\n  let maxDigitSum120 = 0;\n  let maxDigitSum121 = 0;\n  let maxDigitSum122 = 0;\n  let maxDigitSum123 = 0;\n  let maxDigitSum124 = 0;\n  let maxDigitSum125 = 0;\n  let maxDigitSum126 = 0;\n  let maxDigitSum127 = 0;\n  let maxDigitSum128 = 0;\n  let maxDigitSum129 = 0;\n  let maxDigitSum130 = 0;\n  let maxDigitSum131 = 0;\n  let maxDigitSum132 = 0;\n  let maxDigitSum133 = 0;\n  let maxDigitSum134 = 0;\n  let maxDigitSum135 = 0;\n  let maxDigitSum136 = 0;\n  let maxDigitSum137 = 0;\n  let maxDigitSum138 = 0;\n  let maxDigitSum139 = 0;\n  let maxDigitSum140 = 0;\n  let maxDigitSum141 = 0;\n  let maxDigitSum142 = 0;\n  let maxDigitSum143 = 0;\n  let maxDigitSum144 = 0;\n  let maxDigitSum145 = 0;\n  let maxDigitSum146 = 0;\n  let maxDigitSum147 = 0;\n  let maxDigitSum148 = 0;\n  let maxDigitSum149 = 0;\n  let maxDigitSum150 = 0;\n  let maxDigitSum151 = 0;\n  let maxDigitSum152 = 0;\n  let maxDigitSum153 = 0;\n  let maxDigitSum154 = 0;\n  let maxDigitSum155 = 0;\n  let maxDigitSum156 = 0;\n  let maxDigitSum157 = 0;\n  let maxDigitSum158 = 0;\n  let maxDigitSum159 = 0;\n  let maxDigitSum160 = 0;\n  let maxDigitSum161 = 0;\n  let maxDigitSum162 = 0;\n  let maxDigitSum163 = 0;\n  let maxDigitSum164 = 0;\n  let maxDigitSum165 = 0;\n  let maxDigitSum166 = 0;\n  let maxDigitSum167 = 0;\n  let maxDigitSum168 = 0;\n  let maxDigitSum169 = 0;\n  let maxDigitSum170 = 0;\n  let maxDigitSum171 = 0;\n  let maxDigitSum172 = 0;\n  let maxDigitSum173 = 0;\n  let maxDigitSum174 = 0;\n  let maxDigitSum175 = 0;\n  let maxDigitSum176 = 0;\n  let maxDigitSum177 = 0;\n  let maxDigitSum178 = 0;\n  let maxDigitSum179 = 0;\n  let maxDigitSum180 = 0;\n  let maxDigitSum181 = 0;\n  let maxDigitSum182 = 0;\n  let maxDigitSum183 = 0;\n  let maxDigitSum184 = 0;\n  let maxDigitSum185 = 0;\n  let maxDigitSum186 = 0;\n  let maxDigitSum187 = 0;\n  let maxDigitSum188 = 0;\n  let maxDigitSum189 = 0;\n  let maxDigitSum190 = 0;\n  let maxDigitSum191 = 0;\n  let maxDigitSum192 = 0;\n  let maxDigitSum193 = 0;\n  let max", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/95", "prompt": "/*\n  If you specify a dictionary, you return true if all key strings are lowercase or all key strings are uppercase, otherwise you return false. If the specified dictionary is empty, the function should return false.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  If you specify a dictionary, you return true if all key strings are lowercase or all key strings are uppercase, otherwise you return false. If the specified dictionary is empty, the function should return false.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let isCaseSensitive = true;\n  let isCaseInsensitive = true;\n  for (let key in dict) {\n    if (dict[key] === \"\") {\n      isCaseSensitive = false;\n    } else if (dict[key].toLowerCase() === dict[key].toUpperCase()) {\n      isCaseInsensitive = false;\n    } else {\n      isCaseSensitive = true;\n      isCaseInsensitive = true;\n    }\n  }\n  return isCaseSensitive && isCaseInsensitive;\n};\n\n/*\n  If you specify a dictionary, you return true if all key strings are lowercase or all key strings are uppercase, otherwise you return false. If the specified dictionary is empty, the function should return false.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCaseInsensitive = (dict) => {\n  let isCaseSensitive = true;\n  let isCaseInsensitive = true;\n  for (let key in dict) {\n    if (dict[key] === \"\") {\n      isCaseSensitive = false;\n    } else if (dict[key].toLowerCase() === dict[key].toUpperCase()) {\n      isCaseInsensitive = true;\n    } else {\n      isCaseSensitive = true;\n      isCaseInsensitive = false;\n    }\n  }\n  return isCaseSensitive && isCaseInsensitive;\n};\n\n/*\n  If you specify a dictionary, you return true if all key strings are lowercase or all key strings are uppercase, otherwise you return false. If the specified dictionary is empty, the function should return false.\n  Examples:\n  checkDictCaseInsensitive({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCaseInsensitive({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCaseInsensitive({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCaseInsensitive({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCaseInsensitive({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCaseInsensitiveInsensitive = (dict) => {\n  let isCaseSensitive = true;\n  let isCaseInsensitive = true;\n  for (let key in dict) {\n    if (dict[key] === \"\") {\n      isCaseSensitive = false;\n    } else if (dict[key].toLowerCase() === dict[key].toUpperCase()) {\n      isCaseInsensitive = true;\n    } else {\n      isCaseSensitive = true;\n      isCaseInsensitive = false;\n    }\n  }\n  return isCaseSensitive && isCaseInsensitive;\n};\n\n/*\n  If you specify a dictionary, you return true if all key strings are lowercase or all key strings are uppercase, otherwise you return false. If the specified dictionary is empty, the function should return false.\n  Examples:\n  checkDictCaseInsensitiveInsensitive({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCaseInsensitiveInsensitive({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCaseInsensitiveInsensitive({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCaseInsensitiveInsensitive({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCaseInsensitiveInsensitive({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCaseInsensitiveInsensitiveInsensitive = (dict) => {\n  let isCaseSensitive = true;\n  let isCaseInsensitive = true;\n  for (let key in dict) {\n    if (dict[key] === \"\") {\n      isCaseSensitive = false;\n    } else if (dict[key].toLowerCase() === dict[key].toUpperCase()) {\n      isCaseInsensitive = true;\n    } else {\n      isCaseSensitive = true;\n      isCaseInsensitive = false;\n    }\n  }\n  return isCaseSensitive && isCaseInsensitive;\n};\n\n/*\n  If you specify a dictionary, you return true if all key strings are lowercase or all key strings are uppercase, otherwise you return false. If the specified dictionary is empty, the function should return false.\n  Examples:\n  checkDictCaseInsensitiveInsensitiveInsensitive({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCaseInsensitiveInsensitiveInsensitive({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCaseInsensitiveInsensitiveInsensitive({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCaseInsensitiveInsensitiveInsensitive({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCaseInsensitiveInsensitiveInsensitive({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCaseInsensitiveInsensitiveInsensitiveInsensitive = (dict) => {\n  let isCaseSensitive = true;\n  let isCaseInsensitive = true;\n  for (let key in dict) {\n    if (dict[key] === \"\") {\n      isCaseSensitive = false;\n    } else if (dict[key].toLowerCase() === dict[key].toUpperCase()) {\n      isCaseInsensitive = true;\n    } else {\n      isCaseSensitive = true;\n      isCaseInsensitive = false;\n    }\n  }\n  return isCaseSensitive && isCaseInsensitive;\n};\n\n/*\n  If you specify a dictionary, you return true if all key strings are lowercase or all key strings are uppercase, otherwise you return false. If the specified dictionary is empty, the function should return false.\n  Examples:\n  checkDictCaseInsensitiveInsensitiveInsensitiveInsensitive({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCaseInsensitiveInsensitiveInsensitiveInsensitive({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCaseInsensitiveInsensitiveInsensitiveInsensitive({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCaseInsensitiveInsensitiveInsensitiveInsensitive({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  check", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/96", "prompt": "/*IImplement a function that takes a non-negative integer and returns an array of the first n integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*IImplement a function that takes a non-negative integer and returns an array of the first n integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  const primes = [];\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      primes.push(i);\n    }\n    i++;\n  }\n  return primes;\n};\n\n/*IImplement a function that takes a non-negative integer and returns an array of the prime factors of n.\n  for example:\n  factors(5) => [2,3]\n  factors(11) => [2,3,5,7]\n  factors(0) => []\n  factors(20) => [2,3,5,7,11,13,17,19]\n  factors(1) => []\n  factors(18) => [2,3,5,7,11,13,17]\n  */\nconst factors = (n) => {\n  const factors = [];\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      factors.push(i);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/*IImplement a function that takes a non-negative integer and returns an array of the prime factors of n.\n  for example:\n  factors2(5) => [2,3]\n  factors2(11) => [2,3,5,7]\n  factors2(0) => []\n  factors2(20) => [2,3,5,7,11,13,17,19]\n  factors2(1) => []\n  factors2(18) => [2,3,5,7,11,13,17]\n  */\nconst factors2 = (n) => {\n  const factors = [];\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      factors.push(i);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/*IImplement a function that takes a non-negative integer and returns an array of the prime factors of n.\n  for example:\n  factors3(5) => [2,3]\n  factors3(11) => [2,3,5,7]\n  factors3(0) => []\n  factors3(20) => [2,3,5,7,11,13,17,19]\n  factors3(1) => []\n  factors3(18) => [2,3,5,7,11,13,17]\n  */\nconst factors3 = (n) => {\n  const factors = [];\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      factors.push(i);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/*IImplement a function that takes a non-negative integer and returns an array of the prime factors of n.\n  for example:\n  factors4(5) => [2,3]\n  factors4(11) => [2,3,5,7]\n  factors4(0) => []\n  factors4(20) => [2,3,5,7,11,13,17,19]\n  factors4(1) => []\n  factors4(18) => [2,3,5,7,11,13,17]\n  */\nconst factors4 = (n) => {\n  const factors = [];\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      factors.push(i);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/*IImplement a function that takes a non-negative integer and returns an array of the prime factors of n.\n  for example:\n  factors5(5) => [2,3]\n  factors5(11) => [2,3,5,7]\n  factors5(0) => []\n  factors5(20) => [2,3,5,7,11,13,17,19]\n  factors5(1) => []\n  factors5(18) => [2,3,5,7,11,13,17]\n  */\nconst factors5 = (n) => {\n  const factors = [];\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      factors.push(i);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/*IImplement a function that takes a non-negative integer and returns an array of the prime factors of n.\n  for example:\n  factors6(5) => [2,3]\n  factors6(11) => [2,3,5,7]\n  factors6(0) => []\n  factors6(20) => [2,3,5,7,11,13,17,19]\n  factors6(1) => []\n  factors6(18) => [2,3,5,7,11,13,17]\n  */\nconst factors6 = (n) => {\n  const factors = [];\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      factors.push(i);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/*IImplement a function that takes a non-negative integer and returns an array of the prime factors of n.\n  for example:\n  factors7(5) => [2,3]\n  factors7(11) => [2,3,5,7]\n  factors7(0) => []\n  factors7(20) => [2,3,5,7,11,13,17,19]\n  factors7(1) => []\n  factors7(18) => [2,3,5,7,11,13,17]\n  */\nconst factors7 = (n) => {\n  const factors = [];\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      factors.push(i);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/*IImplement a function that takes a non-negative integer and returns an array of the prime factors of n.\n  for example:\n  factors8(5) => [2,3]\n  factors8(11) => [2,3,5,7]\n  factors8(0) => []\n  factors8(20) => [2,3,5,7,11,13,17,19]\n  factors8(1) => []\n  factors8(18) => [2,3,5,7,11,13,17]\n  */\nconst factors8 = (n) => {\n  const factors = [];\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      factors.push(i);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/*IImplement a function that takes a non-negative integer and returns an array of the prime factors of n.\n  for example:\n  factors9(5) => [2,3]\n  factors9(11) => [2,3,5,7]\n  factors9(0) => []\n  factors9(20) => [2,3,5,7,11,13,17,19]\n  factors9(1) => []\n  factors9(18) => [2,3,5,7,11,13,17]\n  */\nconst factors9 = (n) => {\n  const factors = [];\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      factors.push(i);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/*IImplement a function that takes a non-negative integer and returns an array of the prime factors of n.\n  for example:\n  factors10(5) => [2,3]\n  factors10(11) => [2,3,5,7]\n  factors10(0) => []\n  factors10(20) => [2,3,5,7,11,13,17,19]\n  factors10(1) => []\n  factors10(18) => [2,3,5,7,11,13,17]\n  */\nconst factors10 = (n) => {\n  const factors = [];\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      factors.push(i);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/*IImplement a function that takes a non-negative integer and returns an array of the prime factors of ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/97", "prompt": "/*CComplete the function that takes two integers and returns the product of their unit digits. Suppose the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*CComplete the function that takes two integers and returns the product of their unit digits. Suppose the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let result = 0;\n  let digit;\n  while (b > 0) {\n    digit = a % 10;\n    result += digit * b;\n    a = Math.floor(a / 10);\n    b = Math.floor(a / 10);\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return the largest power of 2 that divides n.\n  Examples:\n  powerOf2(4) should return 2.\n  powerOf2(5) should return 4.\n  powerOf2(6) should return 8.\n  powerOf2(7) should return 16.\n  powerOf2(8) should return 32.\n  powerOf2(9) should return 64.\n  powerOf2(10) should return 128.\n  powerOf2(11) should return 256.\n  powerOf2(12) should return 512.\n  powerOf2(13) should return 1024.\n  powerOf2(14) should return 2048.\n  powerOf2(15) should return 4096.\n  powerOf2(16) should return 8192.\n  powerOf2(17) should return 16384.\n  powerOf2(18) should return 32768.\n  powerOf2(19) should return 65536.\n  powerOf2(20) should return 131072.\n  powerOf2(21) should return 262144.\n  powerOf2(22) should return 524288.\n  powerOf2(23) should return 1048576.\n  powerOf2(24) should return 2097152.\n  powerOf2(25) should return 4194304.\n  powerOf2(26) should return 8388608.\n  powerOf2(27) should return 16777216.\n  powerOf2(28) should return 33554432.\n  powerOf2(29) should return 67108864.\n  powerOf2(30) should return 134217728.\n  powerOf2(31) should return 268435456.\n  powerOf2(32) should return 536870912.\n  powerOf2(33) should return 1073741824.\n  powerOf2(34) should return 2147483648.\n  powerOf2(35) should return 4294967296.\n  powerOf2(36) should return 0 \n*/\nconst powerOf2 = n => {\n  let result = 1;\n  let powerOf2Factor = 1;\n  while (n > 0) {\n    result = result * powerOf2Factor;\n    powerOf2Factor *= 2;\n    n = Math.floor(n / 2);\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return the largest power of 2 that divides n modulo n.\n  Examples:\n  powerOf2Mod(4) should return 2.\n  powerOf2Mod(5) should return 4.\n  powerOf2Mod(6) should return 8.\n  powerOf2Mod(7) should return 16.\n  powerOf2Mod(8) should return 32.\n  powerOf2Mod(9) should return 64.\n  powerOf2Mod(10) should return 128.\n  powerOf2Mod(11) should return 256.\n  powerOf2Mod(12) should return 512.\n  powerOf2Mod(13) should return 1024.\n  powerOf2Mod(14) should return 2048.\n  powerOf2Mod(15) should return 4096.\n  powerOf2Mod(16) should return 8192.\n  powerOf2Mod(17) should return 16384.\n  powerOf2Mod(18) should return 32768.\n  powerOf2Mod(19) should return 65536.\n  powerOf2Mod(20) should return 131072.\n  powerOf2Mod(21) should return 262144.\n  powerOf2Mod(22) should return 524288.\n  powerOf2Mod(23) should return 1048576.\n  powerOf2Mod(24) should return 2097152.\n  powerOf2Mod(25) should return 4194304.\n  powerOf2Mod(26) should return 8388608.\n  powerOf2Mod(27) should return 16777216.\n  powerOf2Mod(28) should return 33554432.\n  powerOf2Mod(29) should return 67108864.\n  powerOf2Mod(30) should return 134217728.\n  powerOf2Mod(31) should return 268435456.\n  powerOf2Mod(32) should return 536870912.\n  powerOf2Mod(33) should return 1073741824.\n  powerOf2Mod(34) should return 2147483648.\n  powerOf2Mod(35) should return 4294967296.\n  powerOf2Mod(36) should return 0 \n*/\nconst powerOf2Mod = n => {\n  let result = 1;\n  let powerOf2ModFactor = 1;\n  while (n > 0) {\n    result = result * powerOf2ModFactor;\n    powerOf2ModFactor *= 2;\n    n = Math.floor(n / 2);\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return the largest power of 2 that divides n modulo n modulo n.\n  Examples:\n  powerOf2ModMod(4) should return 2.\n  powerOf2ModMod(5) should return 4.\n  powerOf2ModMod(6) should return 8.\n  powerOf2ModMod(7) should return 16.\n  powerOf2ModMod(8) should return 32.\n  powerOf2ModMod(9) should return 64.\n  powerOf2ModMod(10) should return 128.\n  powerOf2ModMod(11) should return 256.\n  powerOf2ModMod(12) should return 512.\n  powerOf2ModMod(13) should return 1024.\n  powerOf2ModMod(14) should return 2048.\n  powerOf2ModMod(15) should return 4096.\n  powerOf2ModMod(16) should return 8192.\n  powerOf2ModMod(17) should return 16384.\n  powerOf2ModMod(18) should return 32768.\n  powerOf2ModMod(19) should return 65536.\n  powerOf2ModMod(20) should return 131072.\n  powerOf2ModMod(21) should return 262144.\n  powerOf2ModMod(22) should return 524288.\n  powerOf2ModMod(23) should return 1048576.\n  powerOf2ModMod(24) should return 2097152.\n  powerOf2ModMod(25) should return 4194304.\n  powerOf2ModMod(26) should return 8388608.\n  powerOf2ModMod(27) should return 16777216.\n  powerOf2ModMod(28) should return 33554432.\n  powerOf2ModMod(29) should return 67108864.\n  powerOf2ModMod(30) should return 134217728.\n  powerOf2ModMod(31) ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/98", "prompt": "/*\n  For a string s, the number of uppercase letters in even indexes is counted.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  For a string s, the number of uppercase letters in even indexes is counted.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] >= 'a' && s[i] <= 'z') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, return true if and only if the string contains only lowercase letters.\n  \n  For example:\n  hasLower('aBCdEf') returns true\n  hasLower('abcdefg') returns false\n  hasLower('dBBE') returns false\n  */\nconst hasLower = (s) => {\n  let hasLower = true;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] >= 'a' && s[i] <= 'z') {\n      hasLower = false;\n      break;\n    }\n  }\n  return hasLower;\n};\n\n/*\n  Given a string s, return true if and only if the string contains only uppercase letters.\n  \n  For example:\n  hasUpper('aBCdEf') returns true\n  hasUpper('abcdefg') returns false\n  hasUpper('dBBE') returns false\n  */\nconst hasUpper = (s) => {\n  let hasUpper = true;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] >= 'A' && s[i] <= 'Z') {\n      hasUpper = false;\n      break;\n    }\n  }\n  return hasUpper;\n};\n\n/*\n  Given a string s, return true if and only if the string contains only digits and letters.\n  \n  For example:\n  hasDigit('aBCdEf') returns true\n  hasDigit('abcdefg') returns false\n  hasDigit('dBBE') returns false\n  */\nconst hasDigit = (s) => {\n  let hasDigit = true;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] >= '0' && s[i] <= '9') {\n      hasDigit = false;\n      break;\n    }\n  }\n  return hasDigit;\n};\n\n/*\n  Given a string s, return true if and only if the string contains only letters.\n  \n  For example:\n  hasLetter('aBCdEf') returns true\n  hasLetter('abcdefg') returns false\n  hasLetter('dBBE') returns false\n  */\nconst hasLetter = (s) => {\n  let hasLetter = true;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] >= 'a' && s[i] <= 'z') {\n      hasLetter = false;\n      break;\n    }\n  }\n  return hasLetter;\n};\n\n/*\n  Given a string s, return true if and only if the string contains only special characters.\n  \n  For example:\n  hasSpecial('aBCdEf') returns true\n  hasSpecial('abcdefg') returns false\n  hasSpecial('dBBE') returns false\n  */\nconst hasSpecial = (s) => {\n  let hasSpecial = true;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] >= '!' && s[i] <= '@') {\n      hasSpecial = false;\n      break;\n    }\n  }\n  return hasSpecial;\n};\n\n/*\n  Given a string s, return true if and only if the string contains only letters and digits and special characters.\n  \n  For example:\n  hasSpecialLetter('aBCdEf') returns true\n  hasSpecialLetter('abcdefg') returns false\n  hasSpecialLetter('dBBE') returns false\n  */\nconst hasSpecialLetter = (s) => {\n  let hasSpecialLetter = true;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] >= 'a' && s[i] <= 'z' && s[i] >= 'A' && s[i] <= 'Z') {\n      hasSpecialLetter = false;\n      break;\n    }\n  }\n  return hasSpecialLetter;\n};\n\n/*\n  Given a string s, return true if and only if the string contains only letters and digits and special characters.\n  \n  For example:\n  hasSpecialDigit('aBCdEf') returns true\n  hasSpecialDigit('abcdefg') returns false\n  hasSpecialDigit('dBBE') returns false\n  */\nconst hasSpecialDigit = (s) => {\n  let hasSpecialDigit = true;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] >= '0' && s[i] <= '9' && s[i] >= '!' && s[i] <= '@') {\n      hasSpecialDigit = false;\n      break;\n    }\n  }\n  return hasSpecialDigit;\n};\n\n/*\n  Given a string s, return true if and only if the string contains only letters and digits and special characters.\n  \n  For example:\n  hasSpecialLetterAndDigit('aBCdEf') returns true\n  hasSpecialLetterAndDigit('abcdefg') returns false\n  hasSpecialLetterAndDigit('dBBE') returns false\n  */\nconst hasSpecialLetterAndDigit = (s) => {\n  let hasSpecialLetterAndDigit = true;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] >= 'a' && s[i] <= 'z' && s[i] >= 'A' && s[i] <= 'Z') {\n      hasSpecialLetterAndDigit = false;\n      break;\n    }\n  }\n  return hasSpecialLetterAndDigit;\n};\n\n/*\n  Given a string s, return true if and only if the string contains only letters and digits and special characters.\n  \n  For example:\n  hasSpecialLetterAndDigit('aBCdEf') returns true\n  hasSpecialLetterAndDigit('abcdefg') returns false\n  hasSpecialLetterAndDigit('dBBE') returns false\n  */\nconst hasSpecialLetterAndDigitAndSpecial = (s) => {\n  let hasSpecialLetterAndDigitAndSpecial = true;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] >= 'a' && s[i] <= 'z' && s[i] >= 'A' && s[i] <= 'Z') {\n      hasSpecialLetterAndDigitAndSpecial = false;\n      break;\n    }\n  }\n  return hasSpecialLetterAndDigitAndSpecial;\n};\n\n/*\n  Given a string s, return true if and only if the string contains only letters and digits and special characters.\n  \n  For example:\n  hasSpecialLetterAndDigitAndSpecial('aBCdEf') returns true\n  hasSpecialLetterAndDigitAndSpecial('abcdefg') returns false\n  hasSpecialLetterAndDigitAndSpecial('dBBE') returns false\n  */\nconst hasSpecialLetterAndDigitAndSpecialLetter = (s) => {\n  let hasSpecialLetterAndDigitAndSpecialLetter = true;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] >= 'a' && s[i] <= 'z' && s[i] >= 'A' && s[i] <= 'Z') {\n      hasSpecialLetterAndDigitAndSpecialLetter = false;\n      break;\n    }\n  }\n  return hasSpecialLetterAndDigitAndSpecialLetter;\n};\n\n/*\n  Given a string s, return true if and only if the string contains only letters and digits and special characters.\n  \n  For example:\n  hasSpecialLetterAndDigitAndSpecialLetter('aBCdEf') returns true\n  hasSpecialLetterAndDigitAndSpecialLetter('abcdefg') returns false\n  hasSpecialLetterAndDigitAndSpecialLetter('dBBE') returns false\n  */\nconst hasSpecialLetterAndDigitAndSpecialDigit = (s) => {\n  let hasSpecialLetterAndDigitAndSpecialDigit = true;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] >= '0' && s[i] <= '9' && s[i] >= '!' && s[i] <= '@') {\n      hasSpecialLetterAndDigitAndSpecialDigit = false;\n      break;\n    }\n  }\n  return hasSpecialLetterAndDigitAndSpecialDigit;\n};\n\n/*\n  Given a string s, return true if and only if the string contains only letters and digits and special characters.\n  \n  For example:\n  hasSpecialLetterAndDigitAndSpecialLetter('aBCdEf') returns true\n  hasSpecialLetterAndDigitAndSpecialLetter('abcdefg') returns ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/99", "prompt": "/* Create a function that takes a value (string) that represents a number and returns the nearest integer to it. If the number is equal to two integers, round it from zero. Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Create a function that takes a value (string) that represents a number and returns the nearest integer to it. If the number is equal to two integers, round it from zero. Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  const [integer, fraction] = value.split(\".\");\n  const [integerPart, fractionPart] = integer.split(\".\");\n  const [integerPartPart, fractionPartPart] = fraction.split(\".\");\n  const [integerPartPartPart, fractionPartPartPart] = fractionPartPart.split(\".\");\n  const [integerPartPartPartPart, fractionPartPartPartPart] = fractionPartPartPartPart.split(\".\");\n  const [integerPartPartPartPartPart, fractionPartPartPartPartPart] = fractionPartPartPartPartPart.split(\".\");\n  const [integerPartPartPartPartPartPart, fractionPartPartPartPartPartPartPart] = fractionPartPartPartPartPartPart.split(\".\");\n  const [integerPartPartPartPartPartPartPart, fractionPartPartPartPartPartPartPartPart] = fractionPartPartPartPartPartPartPart.split(\".\");\n  const [integerPartPartPartPartPartPartPartPart, fractionPartPartPartPartPartPartPartPartPart] = fractionPartPartPartPartPartPartPartPartPart.split(\".\");\n  const [integerPartPartPartPartPartPartPartPartPart, fractionPartPartPartPartPartPartPartPartPartPartPart] = fractionPartPartPartPartPartPartPartPartPartPartPart.split(\".\");\n  const [integerPartPartPartPartPartPartPartPartPartPartPart, fractionPartPartPartPartPartPartPartPartPartPartPartPartPartPart] = fractionPartPartPartPartPartPartPartPartPartPartPartPartPartPart.split(\".\");\n  const [integerPartPartPartPartPartPartPartPartPartPartPartPartPart, fractionPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPartPart", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
