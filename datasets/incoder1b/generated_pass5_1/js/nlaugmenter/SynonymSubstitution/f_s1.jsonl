{"task_id": "JavaScript/0", "prompt": "/* determine if in given list of numbers, are any two numbers close to each early than \n   establish threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* determine if in given list of numbers, are any two numbers close to each early than \n   establish threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const closeElements = numbers.filter((number) => {\n    const distance = Math.abs(number - threshold);\n    return distance < threshold;\n  });\n  return closeElements.length > 0;\n};\n\n/* determine if given list of numbers, are any two numbers close to each early than \n   establish threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElementsOrEqual = (numbers, threshold) => {\n  const closeElements = numbers.filter((number) => {\n    const distance = Math.abs(number - threshold);\n    return distance >= threshold;\n  });\n  return closeElements.length > 0;\n};\n\n/* determine if given list of numbers, are any two numbers close to each early than \n   establish threshold.\n  >>> hasCloseElementsOrEqual([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElementsOrEqual([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElementsOrEqualOrZero = (numbers, threshold) => {\n  const closeElements = numbers.filter((number) => {\n    const distance = Math.abs(number - threshold);\n    return distance >= threshold || distance === 0;\n  });\n  return closeElements.length > 0;\n};\n\n/* determine if given list of numbers, are any two numbers close to each early than \n   establish threshold.\n  >>> hasCloseElementsOrEqualOrZero([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElementsOrEqualOrZero([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElementsOrEqualOrZeroOrOne = (numbers, threshold) => {\n  const closeElements = numbers.filter((number) => {\n    const distance = Math.abs(number - threshold);\n    return distance >= threshold || distance === 0 || distance === 1;\n  });\n  return closeElements.length > 0;\n};\n\n/* determine if given list of numbers, are any two numbers close to each early than \n   establish threshold.\n  >>> hasCloseElementsOrEqualOrZeroOrOne([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElementsOrEqualOrZeroOrOne([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElementsOrEqualOrZeroOrOneOrZero = (numbers, threshold) => {\n  const closeElements = numbers.filter((number) => {\n    const distance = Math.abs(number - threshold);\n    return distance >= threshold || distance === 0 || distance === 1;\n  });\n  return closeElements.length > 0;\n};\n\n/* determine if given list of numbers, are any two numbers close to each early than \n   establish threshold.\n  >>> hasCloseElementsOrEqualOrZeroOrOneOrZero([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElementsOrEqualOrZeroOrOneOrZero([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElementsOrEqualOrZeroOrOneOrZeroOrOne = (numbers, threshold) => {\n  const closeElements = numbers.filter((number) => {\n    const distance = Math.abs(number - threshold);\n    return distance >= threshold || distance === 0 || distance === 1 || distance === 1;\n  });\n  return closeElements.length > 0;\n};\n\n/* determine if given list of numbers, are any two numbers close to each early than \n   establish threshold.\n  >>> hasCloseElementsOrEqualOrZeroOrOneOrZeroOrOne([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElementsOrEqualOrZeroOrOneOrZeroOrOne([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElementsOrEqualOrZeroOrOneOrZeroOrOneOrZero = (numbers, threshold) => {\n  const closeElements = numbers.filter((number) => {\n    const distance = Math.abs(number - threshold);\n    return distance >= threshold || distance === 0 || distance === 1 || distance === 1;\n  });\n  return closeElements.length > 0;\n};\n\n/* determine if given list of numbers, are any two numbers close to each early than \n   establish threshold.\n  >>> hasCloseElementsOrEqualOrZeroOrOneOrZeroOrOne([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElementsOrEqualOrZeroOrOneOrZeroOrOne([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElementsOrEqualOrZeroOrOneOrZeroOrOneOrZeroOrOne = (numbers, threshold) => {\n  const closeElements = numbers.filter((number) => {\n    const distance = Math.abs(number - threshold);\n    return distance >= threshold || distance === 0 || distance === 1 || distance === 1;\n  });\n  return closeElements.length > 0;\n};\n\n/* determine if given list of numbers, are any two numbers close to each early than \n   establish threshold.\n  >>> hasCloseElementsOrEqualOrZeroOrOneOrZeroOrOneOrZeroOrOne([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElementsOrEqualOrZeroOrOneOrZeroOrOneOrZeroOrOne([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElementsOrEqualOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZero = (numbers, threshold) => {\n  const closeElements = numbers.filter((number) => {\n    const distance = Math.abs(number - threshold);\n    return distance >= threshold || distance === 0 || distance === 1 || distance === 1;\n  });\n  return closeElements.length > 0;\n};\n\n/* determine if given list of numbers, are any two numbers close to each early than \n   establish threshold.\n  >>> hasCloseElementsOrEqualOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOne([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElementsOrEqualOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOne([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElementsOrEqualOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOne = (numbers, threshold) => {\n  const closeElements = numbers.filter((number) => {\n    const distance = Math.abs(number - threshold);\n    return distance >= threshold || distance === 0 || distance === 1 || distance === 1;\n  });\n  return closeElements.length > 0;\n};\n\n/* determine if given list of numbers, are any two numbers close to each early than \n   establish threshold.\n  >>> hasCloseElementsOrEqualOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOne"}
{"task_id": "JavaScript/1", "prompt": "/* input signal to this function is a drawstring incorporate multiple group of cuddle parentheses. Your finish is to \n   separate those group into freestanding strings and return the list of those. \n   disjoined group are balanced (each open brace is by rights closed) and not nested within each other \n   neglect any quad in the stimulation string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* input signal to this function is a drawstring incorporate multiple group of cuddle parentheses. Your finish is to \n   separate those group into freestanding strings and return the list of those. \n   disjoined group are balanced (each open brace is by rights closed) and not nested within each other \n   neglect any quad in the stimulation string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]*)\\)/)\n  return paren_groups.map((group) => {\n    const paren_group = []\n    const paren_group_open = group.match(/\\(([^)]*)\\)/)\n    const paren_group_close = group.match(/\\)([^)]*)\\)/)\n    const paren_group_neglect = group.match(/\\(([^)]*)\\)/)\n    const paren_group_neglect_open = group.match(/\\(([^)]*)\\)/)\n    const paren_group_neglect_close = group.match(/\\)([^)]*)\\)/)\n    const paren_group_neglect_neglect = group.match(/\\(([^)]*)\\)/)\n    const paren_group_neglect_neglect_open = group.match(/\\(([^)]*)\\)/)\n    const paren_group_neglect_neglect_close = group.match(/\\)([^)]*)\\)/)\n    const paren_group_neglect_neglect_neglect = group.match(/\\(([^)]*)\\)/)\n    const paren_group_neglect_neglect_neglect_open = group.match(/\\(([^)]*)\\)/)\n    const paren_group_neglect_neglect_neglect_close = group.match(/\\)([^)]*)\\)/)\n    const paren_group_neglect_neglect_neglect_neglect = group.match(/\\(([^)]*)\\)/)\n    const paren_group_neglect_neglect_neglect_neglect_open = group.match(/\\(([^)]*)\\)/)\n    const paren_group_neglect_neglect_neglect_neglect_close = group.match(/\\)([^)]*)\\)/)\n    const paren_group_neglect_neglect_neglect_neglect_neglect = group.match(/\\(([^)]*)\\)/)\n    const paren_group_neglect_neglect_neglect_neglect_neglect_open = group.match(/\\(([^)]*)\\)/)\n    const paren_group_neglect_neglect_neglect_neglect_neglect_close = group.match(/\\)([^)]*)\\)/)\n    const paren_group_neglect_neglect_neglect_neglect_neglect_neglect = group.match(/\\(([^)]*)\\)/)\n    const paren_group_neglect_neglect_neglect_neglect_neglect_neglect_open = group.match(/\\(([^)]*)\\)/)\n    const paren_group_neglect_neglect_neglect_neglect_neglect_neglect_close = group.match(/\\)([^)]*)\\)/)\n    const paren_group_neglect_neglect_neglect_neglect_neglect_neglect_neglect = group.match(/\\(([^)]*)\\)/)\n    const paren_group_neglect_neglect_neglect_neglect_neglect_neglect_neglect_open = group.match(/\\(([^)]*)\\)/)\n    const paren_group_neglect_neglect_neglect_neglect_neglect_neglect_neglect_close = group.match(/\\)([^)]*)\\)/)\n    const paren_group_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect = group.match(/\\(([^)]*)\\)/)\n    const paren_group_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_open = group.match(/\\(([^)]*)\\)/)\n    const paren_group_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_close = group.match(/\\)([^)]*)\\)/)\n    const paren_group_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect = group.match(/\\(([^)]*)\\)/)\n    const paren_group_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_open = group.match(/\\(([^)]*)\\)/)\n    const paren_group_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_close = group.match(/\\)([^)]*)\\)/)\n    const paren_group_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect = group.match(/\\(([^)]*)\\)/)\n    const paren_group_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_open = group.match(/\\(([^)]*)\\)/)\n    const paren_group_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_close = group.match(/\\)([^)]*)\\)/)\n    const paren_group_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_neglect_"}
{"task_id": "JavaScript/2", "prompt": "/* establish a positive float detail number, it can be disintegrate into \n   and integer part (largest integer smaller than give number) and decimal fraction \n   (leftover function constantly smaller than 1). \n\n   Return the decimal function of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* establish a positive float detail number, it can be disintegrate into \n   and integer part (largest integer smaller than give number) and decimal fraction \n   (leftover function constantly smaller than 1). \n\n   Return the decimal function of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  let decimalPart = Math.floor(Math.log(number) / Math.LN10);\n  let integerPart = Math.floor(Math.log(number) / Math.LN10) - decimalPart;\n  let fractionPart = Math.pow(10, integerPart);\n  return Math.trunc(number * fractionPart) / fractionPart;\n}\n\n/* \n   Return the integer part of the number. \n   \n   Return 0 if the number is negative. \n   \n   >>> truncateNumber(-3)\n   0\n  */\nconst truncateIntegerPart = number => {\n  if (number < 0) {\n    return 0;\n  }\n  return Math.floor(Math.log(number) / Math.LN10) - Math.floor(Math.log(number) / Math.LN10) % 10;\n}\n\n/* \n   Return the decimal part of the number. \n   \n   Return 0 if the number is negative. \n   \n   >>> truncateNumber(-3.5)\n   0\n  */\nconst truncateDecimalPart = number => {\n  if (number < 0) {\n    return 0;\n  }\n  return Math.floor(Math.log(number) / Math.LN10) - Math.floor(Math.log(number) / Math.LN10) % 10;\n}\n\n/* \n   Return the fractional part of the number. \n   \n   Return 0 if the number is negative. \n   \n   >>> truncateNumber(-3.5)\n   0\n  */\nconst truncateFractionPart = number => {\n  if (number < 0) {\n    return 0;\n  }\n  return Math.floor(Math.log(number) / Math.LN10) - Math.floor(Math.log(number) / Math.LN10) % 10;\n}\n\n/* \n   Return the exponent of the number. \n   \n   Return 0 if the number is negative. \n   \n   >>> truncateNumber(-3.5)\n   0\n  */\nconst truncateExponentPart = number => {\n  if (number < 0) {\n    return 0;\n  }\n  return Math.floor(Math.log(number) / Math.LN10) - Math.floor(Math.log(number) / Math.LN10) % 10;\n}\n\n/* \n   Return the mantissa of the number. \n   \n   Return 0 if the number is negative. \n   \n   >>> truncateNumber(-3.5)\n   0\n  */\nconst truncateMantissaPart = number => {\n  if (number < 0) {\n    return 0;\n  }\n  return Math.floor(Math.log(number) / Math.LN10) - Math.floor(Math.log(number) / Math.LN10) % 10;\n}\n\n/* \n   Return the exponent of the number. \n   \n   Return 0 if the number is negative. \n   \n   >>> truncateNumber(-3.5)\n   0\n  */\nconst truncateExponent = number => {\n  if (number < 0) {\n    return 0;\n  }\n  return Math.floor(Math.log(number) / Math.LN10) - Math.floor(Math.log(number) / Math.LN10) % 10;\n}\n\n/* \n   Return the mantissa of the number. \n   \n   Return 0 if the number is negative. \n   \n   >>> truncateNumber(-3.5)\n   0\n  */\nconst truncateMantissa = number => {\n  if (number < 0) {\n    return 0;\n  }\n  return Math.floor(Math.log(number) / Math.LN10) - Math.floor(Math.log(number) / Math.LN10) % 10;\n}\n\n/* \n   Return the exponent of the number. \n   \n   Return 0 if the number is negative. \n   \n   >>> truncateNumber(-3.5)\n   0\n  */\nconst truncateExponent = number => {\n  if (number < 0) {\n    return 0;\n  }\n  return Math.floor(Math.log(number) / Math.LN10) - Math.floor(Math.log(number) / Math.LN10) % 10;\n}\n\n/* \n   Return the exponent of the number. \n   \n   Return 0 if the number is negative. \n   \n   >>> truncateNumber(-3.5)\n   0\n  */\nconst truncateExponent = number => {\n  if (number < 0) {\n    return 0;\n  }\n  return Math.floor(Math.log(number) / Math.LN10) - Math.floor(Math.log(number) / Math.LN10) % 10;\n}\n\n/* \n   Return the exponent of the number. \n   \n   Return 0 if the number is negative. \n   \n   >>> truncateNumber(-3.5)\n   0\n  */\nconst truncateExponent = number => {\n  if (number < 0) {\n    return 0;\n  }\n  return Math.floor(Math.log(number) / Math.LN10) - Math.floor(Math.log(number) / Math.LN10) % 10;\n}\n\n/* \n   Return the exponent of the number. \n   \n   Return 0 if the number is negative. \n   \n   >>> truncateNumber(-3.5)\n   0\n  */\nconst truncateExponent = number => {\n  if (number < 0) {\n    return 0;\n  }\n  return Math.floor(Math.log(number) / Math.LN10) - Math.floor(Math.log(number) / Math.LN10) % 10;\n}\n\n/* \n   Return the exponent of the number. \n   \n   Return 0 if the number is negative. \n   \n   >>> truncateNumber(-3.5)\n   0\n  */\nconst truncateExponent = number => {\n  if (number < 0) {\n    return 0;\n  }\n  return Math.floor(Math.log(number) / Math.LN10) - Math.floor(Math.log(number) / Math.LN10) % 10;\n}\n\n/* \n   Return the exponent of the number. \n   \n   Return 0 if the number is negative. \n   \n   >>> truncateNumber(-3.5)\n   0\n  */\nconst truncateExponent = number => {\n  if (number < 0) {\n    return 0;\n  }\n  return Math.floor(Math.log(number) / Math.LN10) - Math.floor(Math.log(number) / Math.LN10) % 10;\n}\n\n/* \n   Return the exponent of the number. \n   \n   Return 0 if the number is negative. \n   \n   >>> truncateNumber(-3.5)\n   0\n  */\nconst truncateExponent = number => {\n  if (number < 0) {\n    return 0;\n  }\n  return Math.floor(Math.log(number) / Math.LN10) - Math.floor(Math.log(number) / Math.LN10) % 10;\n}\n\n/* \n   Return the exponent of the number. \n   \n   Return 0 if the number is negative. \n   \n   >>> truncateNumber(-3.5)\n   0\n  */\nconst truncateExponent = number => {\n  if (number < 0) {\n    return 0;\n  }\n  return Math.floor(Math.log(number) / Math.LN10) - Math.floor(Math.log(number) / Math.LN10) % 10;\n}\n\n/* \n   Return the exponent of the number. \n   \n   Return 0 if the number is negative. \n   \n   >>> truncateNumber(-3.5)\n   0\n  */\nconst truncateExponent = number => {\n  if (number < 0) {\n    return 0;\n  }\n  return Math.floor(Math.log(number) / Math.LN10) - Math.floor(Math.log(number) / Math.LN10) % 10;\n}\n\n/* \n   Return the exponent of the number. \n   \n   Return 0 if the number is negative. \n   \n   >>> truncateNumber(-3.5)\n   0\n  */\nconst truncateExponent = number => {\n  if (number < 0) {\n    return 0;\n  }\n  return Math.floor(Math.log(number) / Math.LN10) - Math.floor(Math.log(number) / Math.LN10) % 10;\n}\n\n/* \n   Return the exponent of the number. \n   \n   Return 0 if the number is negative. \n   \n   >>> truncateNumber(-3.5)\n   0\n  */\nconst truncateExponent = number => {\n  if (number < 0) {\n    return 0;\n  }\n  return Math.floor(Math.log(number) / Math.LN10) - Math.floor(Math.log(number) / Math.LN10) % 10;\n}\n\n/* \n   Return the exponent of the number. \n   \n   Return 0 if the number is negative. \n   \n   >>> truncateNumber(-3.5)\n   0\n  */\nconst truncateExponent = number => {\n  if (number < 0) {\n    return 0;\n  }\n  return Math.floor(Math.log(number) / Math.LN10) - Math.floor(Math.log(number) / Math.LN10) % 10;\n}\n\n/* \n   Return the exponent of the number. \n   \n   Return 0 if the number is negative. \n   \n   >>> truncateNumber(-3.5)\n   0\n  */\n"}
{"task_id": "JavaScript/3", "prompt": "/* You're establish a list of deposit and withdrawal operations on a bank report that start with \n   zero balance. Your task is to detect if at any point the balance of report fallls below zero, and \n   at that point affair should return true. differently it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* You're establish a list of deposit and withdrawal operations on a bank report that start with \n   zero balance. Your task is to detect if at any point the balance of report fallls below zero, and \n   at that point affair should return true. differently it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance <= 0;\n};\n\n/* You're establish a list of deposit and withdrawal operations on a bank report that start with \n   zero balance. Your task is to detect if at any point the balance of report falls below zero, and \n   at that point affair should return true. differently it should return false.\n  >>> belowZero([-4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, "}
{"task_id": "JavaScript/4", "prompt": "/* For a establish list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the median absolute remainder between each \n   element and a centerpoint (mean in this case ): \n   MAD = modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* For a establish list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the median absolute remainder between each \n   element and a centerpoint (mean in this case ): \n   MAD = modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  const deviations = numbers.map(x => Math.abs(x - mean));\n  const median = deviations.reduce((acc, x) => acc + Math.round(x * 100) / 100, 0);\n  return median / numbers.length;\n};\n\n/**\n * Calculates the median absolute deviation of a list of numbers.\n * Median absolute deviation is the median absolute remainder between each \n * element and a centerpoint (mean in this case ): \n * MAD = modal | x - x_mean |\n * >>> medianAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n * 4\n */\nconst medianAbsoluteDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  const deviations = numbers.map(x => Math.abs(x - mean));\n  const median = deviations.reduce((acc, x) => acc + Math.round(x * 100) / 100, 0);\n  return median / numbers.length;\n};\n\n/**\n * Calculates the median absolute deviation of a list of numbers.\n * Median absolute deviation is the median absolute remainder between each \n * element and a centerpoint (mean in this case ): \n * MAD = modal | x - x_mean |\n * >>> medianAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n * 4\n */\nconst medianAbsoluteDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  const deviations = numbers.map(x => Math.abs(x - mean));\n  const median = deviations.reduce((acc, x) => acc + Math.round(x * 100) / 100, 0);\n  return median / numbers.length;\n};\n\n/**\n * Calculates the median absolute deviation of a list of numbers.\n * Median absolute deviation is the median absolute remainder between each \n * element and a centerpoint (mean in this case ): \n * MAD = modal | x - x_mean |\n * >>> medianAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n * 4\n */\nconst medianAbsoluteDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  const deviations = numbers.map(x => Math.abs(x - mean));\n  const median = deviations.reduce((acc, x) => acc + Math.round(x * 100) / 100, 0);\n  return median / numbers.length;\n};\n\n/**\n * Calculates the median absolute deviation of a list of numbers.\n * Median absolute deviation is the median absolute remainder between each \n * element and a centerpoint (mean in this case ): \n * MAD = modal | x - x_mean |\n * >>> medianAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n * 4\n */\nconst medianAbsoluteDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  const deviations = numbers.map(x => Math.abs(x - mean));\n  const median = deviations.reduce((acc, x) => acc + Math.round(x * 100) / 100, 0);\n  return median / numbers.length;\n};\n\n/**\n * Calculates the median absolute deviation of a list of numbers.\n * Median absolute deviation is the median absolute remainder between each \n * element and a centerpoint (mean in this case ): \n * MAD = modal | x - x_mean |\n * >>> medianAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n * 4\n */\nconst medianAbsoluteDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  const deviations = numbers.map(x => Math.abs(x - mean));\n  const median = deviations.reduce((acc, x) => acc + Math.round(x * 100) / 100, 0);\n  return median / numbers.length;\n};\n\n/**\n * Calculates the median absolute deviation of a list of numbers.\n * Median absolute deviation is the median absolute remainder between each \n * element and a centerpoint (mean in this case ): \n * MAD = modal | x - x_mean |\n * >>> medianAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n * 4\n */\nconst medianAbsoluteDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  const deviations = numbers.map(x => Math.abs(x - mean));\n  const median = deviations.reduce((acc, x) => acc + Math.round(x * 100) / 100, 0);\n  return median / numbers.length;\n};\n\n/**\n * Calculates the median absolute deviation of a list of numbers.\n * Median absolute deviation is the median absolute remainder between each \n * element and a centerpoint (mean in this case ): \n * MAD = modal | x - x_mean |\n * >>> medianAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n * 4\n */\nconst medianAbsoluteDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  const deviations = numbers.map(x => Math.abs(x - mean));\n  const median = deviations.reduce((acc, x) => acc + Math.round(x * 100) / 100, 0);\n  return median / numbers.length;\n};\n\n/**\n * Calculates the median absolute deviation of a list of numbers.\n * Median absolute deviation is the median absolute remainder between each \n * element and a centerpoint (mean in this case ): \n * MAD = modal | x - x_mean |\n * >>> medianAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n * 4\n */\nconst medianAbsoluteDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  const deviations = numbers.map(x => Math.abs(x - mean));\n  const median = deviations.reduce((acc, x) => acc + Math.round(x * 100) / 100, 0);\n  return median / numbers.length;\n};\n\n/**\n * Calculates the median absolute deviation of a list of numbers.\n * Median absolute deviation is the median absolute remainder between each \n * element and a centerpoint (mean in this case ): \n * MAD = modal | x - x_mean |\n * >>> medianAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n * 4\n */\nconst medianAbsoluteDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  const deviations = numbers.map(x => Math.abs(x - mean));\n  const median = deviations.reduce((acc, x) => acc + Math.round(x * 100) / 100, 0);\n  return median / numbers.length;\n};\n\n/**\n * Calculates the median absolute deviation of a list of numbers.\n * Median absolute deviation is the median absolute remainder between each \n * element and a centerpoint (mean in this case ): \n * MAD = modal | x - x_mean |\n * >>> medianAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n * 4\n */\nconst medianAbsoluteDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  const deviations = numbers.map(x => Math.abs(x - mean));\n  const median = deviations.reduce((acc, x) => acc + Math.round(x * 100) / 100, 0);\n  return median / numbers.length;\n};\n\n/**\n * Calculates the median absolute deviation of a list of numbers.\n * Median "}
{"task_id": "JavaScript/5", "prompt": "/* Insert a act 'delimeter' between every two consecutive element of input signal list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Insert a act 'delimeter' between every two consecutive element of input signal list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < numbers.length) {\n    if (j === numbers.length - 1) {\n      result.push(numbers[i])\n      i += 1\n    } else {\n      result.push(numbers[i])\n      result.push(delimeter)\n      i += 1\n      j++\n    }\n  }\n  return result\n}\n\n/* Remove all occurrences of an element from a list\n  >>> remove([1,2,3], 2)\n  [3,1]\n  >>> remove([1,2,3], 1)\n  [2,1]\n  >>> remove([1,2,3], 0)\n  []\n  */\nconst remove = (list, elem) => {\n  return list.filter((item, index) => index!== list.indexOf(elem))\n}\n\n/* Remove all occurrences of an element from a list while preserving the order\n  >>> remove([1,2,3], 2, 1)\n  [3,1]\n  >>> remove([1,2,3], 2, 0)\n  [2,1]\n  >>> remove([1,2,3], 1, 2)\n  [1,2]\n  >>> remove([1,2,3], 1, 0)\n  []\n  */\nconst removeWhile = (list, elem) => {\n  return list.filter((item, index) => index!== list.indexOf(elem) && item!== elem)\n}\n\n/* Remove all occurrences of an element from a list while preserving the order\n  >>> removeWhile([1,2,3], 2, 1)\n  [3,1]\n  >>> removeWhile([1,2,3], 2, 0)\n  [2,1]\n  >>> removeWhile([1,2,3], 1, 2)\n  [1,2]\n  >>> removeWhile([1,2,3], 1, 0)\n  []\n  */\nconst removeWhile2 = (list, elem) => {\n  return list.filter((item, index) => index!== list.indexOf(elem) && item!== elem && item!== list[list.indexOf(elem) + 1])\n}\n\n/* Remove all occurrences of an element from a list while preserving the order\n  >>> removeWhile2([1,2,3], 2, 1)\n  [3,1]\n  >>> removeWhile2([1,2,3], 2, 0)\n  [2,1]\n  >>> removeWhile2([1,2,3], 1, 2)\n  [1,2]\n  >>> removeWhile2([1,2,3], 1, 0)\n  []\n  */\nconst removeWhile3 = (list, elem) => {\n  return list.filter((item, index) => index!== list.indexOf(elem) && item!== elem && item!== list[list.indexOf(elem) + 1] && item!== list[list.indexOf(elem) + 2])\n}\n\n/* Remove all occurrences of an element from a list while preserving the order\n  >>> removeWhile3([1,2,3], 2, 1)\n  [3,1]\n  >>> removeWhile3([1,2,3], 2, 0)\n  [2,1]\n  >>> removeWhile3([1,2,3], 1, 2)\n  [1,2]\n  >>> removeWhile3([1,2,3], 1, 0)\n  []\n  */\nconst removeWhile4 = (list, elem) => {\n  return list.filter((item, index) => index!== list.indexOf(elem) && item!== elem && item!== list[list.indexOf(elem) + 1] && item!== list[list.indexOf(elem) + 2] && item!== list[list.indexOf(elem) + 3])\n}\n\n/* Remove all occurrences of an element from a list while preserving the order\n  >>> removeWhile4([1,2,3], 2, 1)\n  [3,1]\n  >>> removeWhile4([1,2,3], 2, 0)\n  [2,1]\n  >>> removeWhile4([1,2,3], 1, 2)\n  [1,2]\n  >>> removeWhile4([1,2,3], 1, 0)\n  []\n  */\nconst removeWhile5 = (list, elem) => {\n  return list.filter((item, index) => index!== list.indexOf(elem) && item!== elem && item!== list[list.indexOf(elem) + 1] && item!== list[list.indexOf(elem) + 2] && item!== list[list.indexOf(elem) + 3])\n}\n\n/* Remove all occurrences of an element from a list while preserving the order\n  >>> removeWhile5([1,2,3], 2, 1)\n  [3,1]\n  >>> removeWhile5([1,2,3], 2, 0)\n  [2,1]\n  >>> removeWhile5([1,2,3], 1, 2)\n  [1,2]\n  >>> removeWhile5([1,2,3], 1, 0)\n  []\n  */\nconst removeWhile6 = (list, elem) => {\n  return list.filter((item, index) => index!== list.indexOf(elem) && item!== elem && item!== list[list.indexOf(elem) + 1] && item!== list[list.indexOf(elem) + 2] && item!== list[list.indexOf(elem) + 3])\n}\n\n/* Remove all occurrences of an element from a list while preserving the order\n  >>> removeWhile6([1,2,3], 2, 1)\n  [3,1]\n  >>> removeWhile6([1,2,3], 2, 0)\n  [2,1]\n  >>> removeWhile6([1,2,3], 1, 2)\n  [1,2]\n  >>> removeWhile6([1,2,3], 1, 0)\n  []\n  */\nconst removeWhile7 = (list, elem) => {\n  return list.filter((item, index) => index!== list.indexOf(elem) && item!== elem && item!== list[list.indexOf(elem) + 1] && item!== list[list.indexOf(elem) + 2] && item!== list[list.indexOf(elem) + 3])\n}\n\n/* Remove all occurrences of an element from a list while preserving the order\n  >>> removeWhile7([1,2,3], 2, 1)\n  [3,1]\n  >>> removeWhile7([1,2,3], 2, 0)\n  [2,1]\n  >>> removeWhile7([1,2,3], 1, 2)\n  [1,2]\n  >>> removeWhile7([1,2,3], 1, 0)\n  []\n  */\nconst removeWhile8 = (list, elem) => {\n  return list.filter((item, index) => index!== list.indexOf(elem) && item!== elem && item!== list[list.indexOf(elem) + 1] && item!== list[list.indexOf(elem) + 2] && item!== list[list.indexOf(elem) + 3])\n}\n\n/* Remove all occurrences of an element from a list while preserving the order\n  >>> removeWhile8([1,2,3], 2, 1)\n  [3,1]\n  >>> removeWhile8([1,2,3], 2, 0)\n  [2,1]\n  >>> removeWhile8([1,2,3], 1, 2)\n  [1,2]\n  >>> removeWhile8([1,2,3], 1, 0)\n  []\n  */\nconst removeWhile9 = (list, elem) => {\n  return list.filter((item, index) => index!== list.indexOf(elem) && item!== elem && item!== list[list.indexOf(elem) + 1] && item!== list[list.indexOf(elem) + 2] && item!== list[list.indexOf(elem) + 3])\n}\n\n/* Remove all occurrences of an element from a list while preserving the order\n  >>> removeWhile9([1,2,3], 2, 1)\n  [3,1]\n  >>> removeWhile9([1,2,3], 2, 0)\n  [2,1]\n  >>> removeWhile9([1,2,3], 1, 2)\n  [1,2]\n  >>> removeWhile9([1,2,3], 1, 0)\n  []\n  */\nconst removeWhile10 = (list, elem) => {\n  return list.filter((item, index) => index!== list.indexOf(elem) && item!== elem && item!== list[list.indexOf(elem) + 1] && item!== list[list.indexOf(elem) + 2] && item!== list[list.indexOf(elem) + 3])\n}\n\n/* Remove all occurrences of an element from a list while preserving the order\n  >>> removeWhile10([1,2,3], 2, 1)\n  [3,1]\n  >>> removeWhile10([1,2,3], 2, 0)\n  [2,1]\n  >>> removeWhile10([1,2,3], 1, 2)\n  [1,2]\n  >>> removeWhile10([1,2,3], 1, 0)\n  []\n  */\nconst removeWhile11 = (list, elem) => {\n  return list.filter((item, index) => index!== list.indexOf(elem) && item!== elem && item!== list[list.indexOf(elem) + "}
{"task_id": "JavaScript/6", "prompt": "/* input signal to this function is a drawstring represent multiple group for nested parentheses distinguish by spaces. \n   For each of the group, output the deepest level of nesting of parenthesis. \n   E.g. (() ()) has maximal two levels of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* input signal to this function is a drawstring represent multiple group for nested parentheses distinguish by spaces. \n   For each of the group, output the deepest level of nesting of parenthesis. \n   E.g. (() ()) has maximal two levels of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_stack = []\n  const paren_level = 0\n  const paren_nesting = 0\n  const paren_nesting_level = 0\n  const paren_nesting_nesting = 0\n  const paren_nesting_nesting_level = 0\n  const paren_nesting_nesting_nesting = 0\n  const paren_nesting_nesting_nesting_level = 0\n  const paren_nesting_nesting_nesting_nesting = 0\n  const paren_nesting_nesting_nesting_nesting_level = 0\n  const paren_nesting_nesting_nesting_nesting_nesting = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_level = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nestlevel = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0\n  const paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_nest"}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input signal list of strings only for one that incorporate give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Filter an input signal list of strings only for one that incorporate give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1);\n};\n\n/**\n * Filter an input signal list of strings only for one that incorporate give substring\n * >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n * ['abc', 'bacd', 'array']\n */\nconst filterBySubstringNoCase = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/**\n * Filter an input signal list of strings only for one that incorporate give substring\n * >>> filterBySubstringNoCase(['abc', 'bacd', 'cde', 'array'], 'a')\n * ['abc', 'bacd', 'array']\n */\nconst filterBySubstringNoCaseIgnoreCase = (strings, substring) => {\n  return strings.filter(string => string.includes(substring, StringCase.IgnoreCase));\n};\n\n/**\n * Filter an input signal list of strings only for one that incorporate give substring\n * >>> filterBySubstringNoCaseIgnoreCase(['abc', 'bacd', 'cde', 'array'], 'a')\n * ['abc', 'bacd', 'array']\n */\nconst filterBySubstringNoCaseIgnoreCaseIgnoreCase = (strings, substring) => {\n  return strings.filter(string => string.includes(substring, StringCase.IgnoreCaseIgnoreCase));\n};\n\n/**\n * Filter an input signal list of strings only for one that incorporate give substring\n * >>> filterBySubstringNoCaseIgnoreCaseIgnoreCase(['abc', 'bacd', 'cde', 'array'], 'a')\n * ['abc', 'bacd', 'array']\n */\nconst filterBySubstringNoCaseIgnoreCaseIgnoreCaseIgnoreCase = (strings, substring) => {\n  return strings.filter(string => string.includes(substring, StringCase.IgnoreCaseIgnoreCaseIgnoreCase));\n};\n\n/**\n * Filter an input signal list of strings only for one that incorporate give substring\n * >>> filterBySubstringNoCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase(['abc', 'bacd', 'cde', 'array'], 'a')\n * ['abc', 'bacd', 'array']\n */\nconst filterBySubstringNoCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (strings, substring) => {\n  return strings.filter(string => string.includes(substring, StringCase.IgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase));\n};\n\n/**\n * Filter an input signal list of strings only for one that incorporate give substring\n * >>> filterBySubstringNoCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase(['abc', 'bacd', 'cde', 'array'], 'a')\n * ['abc', 'bacd', 'array']\n */\nconst filterBySubstringNoCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnore"}
{"task_id": "JavaScript/8", "prompt": "/* For a establish list of integers, return a tuple consist of a kernel and a intersection of all the integer in a list.\n   Empty sum should constitute equal to 0 and empty merchandise should be adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* For a establish list of integers, return a tuple consist of a kernel and a intersection of all the integer in a list.\n   Empty sum should constitute equal to 0 and empty merchandise should be adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let merchandise = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i] * int;\n    merchandise *= int;\n  }\n  return [sum, merchandise];\n};\n\n/* For a establish list of integers, return a tuple consist of a kernel and a intersection of all the integer in a list.\n   Empty sum should constitute equal to 0 and empty merchandise should be adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let merchandise = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i] * int;\n    merchandise *= int;\n  }\n  return [sum, merchandise];\n};\n\n/* For a establish list of integers, return a tuple consist of a kernel and a intersection of all the integer in a list.\n   Empty sum should constitute equal to 0 and empty merchandise should be adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let merchandise = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i] * int;\n    merchandise *= int;\n  }\n  return [sum, merchandise];\n};\n\n/* For a establish list of integers, return a tuple consist of a kernel and a intersection of all the integer in a list.\n   Empty sum should constitute equal to 0 and empty merchandise should be adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let merchandise = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i] * int;\n    merchandise *= int;\n  }\n  return [sum, merchandise];\n};\n\n/* For a establish list of integers, return a tuple consist of a kernel and a intersection of all the integer in a list.\n   Empty sum should constitute equal to 0 and empty merchandise should be adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let merchandise = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i] * int;\n    merchandise *= int;\n  }\n  return [sum, merchandise];\n};\n\n/* For a establish list of integers, return a tuple consist of a kernel and a intersection of all the integer in a list.\n   Empty sum should constitute equal to 0 and empty merchandise should be adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let merchandise = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i] * int;\n    merchandise *= int;\n  }\n  return [sum, merchandise];\n};\n\n/* For a establish list of integers, return a tuple consist of a kernel and a intersection of all the integer in a list.\n   Empty sum should constitute equal to 0 and empty merchandise should be adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let merchandise = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i] * int;\n    merchandise *= int;\n  }\n  return [sum, merchandise];\n};\n\n/* For a establish list of integers, return a tuple consist of a kernel and a intersection of all the integer in a list.\n   Empty sum should constitute equal to 0 and empty merchandise should be adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let merchandise = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i] * int;\n    merchandise *= int;\n  }\n  return [sum, merchandise];\n};\n\n/* For a establish list of integers, return a tuple consist of a kernel and a intersection of all the integer in a list.\n   Empty sum should constitute equal to 0 and empty merchandise should be adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let merchandise = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i] * int;\n    merchandise *= int;\n  }\n  return [sum, merchandise];\n};\n\n/* For a establish list of integers, return a tuple consist of a kernel and a intersection of all the integer in a list.\n   Empty sum should constitute equal to 0 and empty merchandise should be adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let merchandise = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i] * int;\n    merchandise *= int;\n  }\n  return [sum, merchandise];\n};\n\n/* For a establish list of integers, return a tuple consist of a kernel and a intersection of all the integer in a list.\n   Empty sum should constitute equal to 0 and empty merchandise should be adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let merchandise = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i] * int;\n    merchandise *= int;\n  }\n  return [sum, merchandise];\n};\n\n/* For a establish list of integers, return a tuple consist of a kernel and a intersection of all the integer in a list.\n   Empty sum should constitute equal to 0 and empty merchandise should be adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let merchandise = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i] * int;\n    merchandise *= int;\n  }\n  return [sum, merchandise];\n};\n\n/* For a establish list of integers, return a tuple consist of a kernel and a intersection of all the integer in a list.\n   Empty sum should constitute equal to 0 and empty merchan"}
{"task_id": "JavaScript/9", "prompt": "/* From a establish list of integers, beget a list of roll maximal component find oneself until given here and now \n   in the succession.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* From a establish list of integers, beget a list of roll maximal component find oneself until given here and now \n   in the succession.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  let max = 0;\n  let maxIndex = 0;\n  let maxValue = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > maxValue) {\n      max = numbers[i];\n      maxIndex = i;\n      maxValue = numbers[i];\n    }\n  }\n  return [maxValue, maxIndex];\n};\n\n/* From a establish list of integers, beget a list of roll minimal component find oneself until given here and now \n   in the succession.\n  >>> rollingMin([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMin = (numbers) => {\n  let min = 0;\n  let minIndex = 0;\n  let minValue = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] < minValue) {\n      min = numbers[i];\n      minIndex = i;\n      minValue = numbers[i];\n    }\n  }\n  return [minValue, minIndex];\n};\n\n/* From a establish list of integers, beget a list of roll sums component find oneself until given here and now \n   in the succession.\n  >>> rollingSum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 3, 4]\n  */\nconst rollingSum = (numbers) => {\n  let sum = 0;\n  let sumIndex = 0;\n  let sumValue = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    sumIndex += i;\n    sumValue += numbers[i];\n  }\n  return [sumValue, sumIndex];\n};\n\n/* From a establish list of integers, beget a list of roll averages component find oneself until given here and now \n   in the succession.\n  >>> rollingAverage([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 4, 5]\n  */\nconst rollingAverage = (numbers) => {\n  let sum = 0;\n  let sumIndex = 0;\n  let sumValue = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    sumIndex += i;\n    sumValue += numbers[i];\n  }\n  return [sumValue / sumIndex, sumIndex];\n};\n\n/* From a establish list of integers, beget a list of roll standard deviations component find oneself until given here and now \n   in the succession.\n  >>> rollingStandardDeviation([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 4, 5]\n  */\nconst rollingStandardDeviation = (numbers) => {\n  let sum = 0;\n  let sumIndex = 0;\n  let sumValue = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    sumIndex += i;\n    sumValue += numbers[i];\n  }\n  return Math.sqrt(sumValue / sumIndex);\n};\n\n/* From a establish list of integers, beget a list of roll variance component find oneself until given here and now \n   in the succession.\n  >>> rollingVariance([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 4, 5]\n  */\nconst rollingVariance = (numbers) => {\n  let sum = 0;\n  let sumIndex = 0;\n  let sumValue = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    sumIndex += i;\n    sumValue += numbers[i];\n  }\n  return sumValue / sumIndex;\n};\n\n/* From a establish list of integers, beget a list of roll skewness component find oneself until given here and now \n   in the succession.\n  >>> rollingSkewness([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 4, 5]\n  */\nconst rollingSkewness = (numbers) => {\n  let sum = 0;\n  let sumIndex = 0;\n  let sumValue = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    sumIndex += i;\n    sumValue += numbers[i];\n  }\n  return Math.sqrt(sumValue / sumIndex);\n};\n\n/* From a establish list of integers, beget a list of roll kurtosis component find oneself until given here and now \n   in the succession.\n  >>> rollingKurtosis([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 4, 5]\n  */\nconst rollingKurtosis = (numbers) => {\n  let sum = 0;\n  let sumIndex = 0;\n  let sumValue = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    sumIndex += i;\n    sumValue += numbers[i];\n  }\n  return Math.sqrt(sumValue / sumIndex);\n};\n\n/* From a establish list of integers, beget a list of roll skewness component find oneself until given here and now \n   in the succession.\n  >>> rollingKurtosis([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 4, 5]\n  */\nconst rollingKurtosis = (numbers) => {\n  let sum = 0;\n  let sumIndex = 0;\n  let sumValue = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    sumIndex += i;\n    sumValue += numbers[i];\n  }\n  return Math.sqrt(sumValue / sumIndex);\n};\n\n/* From a establish list of integers, beget a list of roll skewness component find oneself until given here and now \n   in the succession.\n  >>> rollingKurtosis([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 4, 5]\n  */\nconst rollingKurtosis = (numbers) => {\n  let sum = 0;\n  let sumIndex = 0;\n  let sumValue = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    sumIndex += i;\n    sumValue += numbers[i];\n  }\n  return Math.sqrt(sumValue / sumIndex);\n};\n\n/* From a establish list of integers, beget a list of roll skewness component find oneself until given here and now \n   in the succession.\n  >>> rollingKurtosis([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 4, 5]\n  */\nconst rollingKurtosis = (numbers) => {\n  let sum = 0;\n  let sumIndex = 0;\n  let sumValue = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    sumIndex += i;\n    sumValue += numbers[i];\n  }\n  return Math.sqrt(sumValue / sumIndex);\n};\n\n/* From a establish list of integers, beget a list of roll skewness component find oneself until given here and now \n   in the succession.\n  >>> rollingKurtosis([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 4, 5]\n  */\nconst rollingKurtosis = (numbers) => {\n  let sum = 0;\n  let sumIndex = 0;\n  let sumValue = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    sumIndex += i;\n    sumValue += numbers[i];\n  }\n  return Math.sqrt(sumValue / sumIndex);\n};\n\n/* From a establish list of integers, beget a list of roll skewness component find oneself until given here and now \n   in the succession.\n  >>> rollingKurtosis([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 4, 5]\n  */\nconst rollingKurtosis = (numbers) => {\n  let sum = 0;\n  let sumIndex = 0;\n  let sumValue = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    sumIndex += i;\n    sumValue += numbers[i];\n  }\n  return Math.sqrt(sumValue / sumIndex);\n};\n\n/* From a establish list of integers, beget a list of roll skewness component find oneself until given here and now \n   in the succession.\n  >>> rollingKurtosis([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 4, 5]\n  */"}
{"task_id": "JavaScript/10", "prompt": "/* screen if gniven strig is a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* rule the shortest palindrome that begin with a provide string.\n   Algorithm theme is simple: \n   - find oneself the long postfix of supplied string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* screen if gniven strig is a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* rule the shortest palindrome that begin with a provide string.\n   Algorithm theme is simple: \n   - find oneself the long postfix of supplied string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let palindrome = '';\n  let suffix = '';\n  let prefix = '';\n  let reverse = '';\n  let start = 0;\n  let end = 0;\n  let length = string.length;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w"}
{"task_id": "JavaScript/11", "prompt": "/* input signal are two strings a and b consist merely of 1s and zero. \n   do binary XOR on these inputs and return result besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* input signal are two strings a and b consist merely of 1s and zero. \n   do binary XOR on these inputs and return result besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = ''\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i]\n  }\n  return result\n}\n\n/* \n  input signal are two strings a and b consist merely of 1s and zero. \n  do binary XOR on these inputs and return result besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXorNoCase = (a, b) => {\n  let result = ''\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i]\n  }\n  return result\n}\n\n/* \n  input signal are two strings a and b consist merely of 1s and zero. \n  do binary XOR on these inputs and return result besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXorNoCaseIgnoreCase = (a, b) => {\n  let result = ''\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i]\n  }\n  return result\n}\n\n/* \n  input signal are two strings a and b consist merely of 1s and zero. \n  do binary XOR on these inputs and return result besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXorIgnoreCase = (a, b) => {\n  let result = ''\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i]\n  }\n  return result\n}\n\n/* \n  input signal are two strings a and b consist merely of 1s and zero. \n  do binary XOR on these inputs and return result besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXorIgnoreCaseNoCase = (a, b) => {\n  let result = ''\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i]\n  }\n  return result\n}\n\n/* \n  input signal are two strings a and b consist merely of 1s and zero. \n  do binary XOR on these inputs and return result besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXorIgnoreCaseNoCaseIgnoreCase = (a, b) => {\n  let result = ''\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i]\n  }\n  return result\n}\n\n/* \n  input signal are two strings a and b consist merely of 1s and zero. \n  do binary XOR on these inputs and return result besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXorIgnoreCaseNoCaseIgnoreCaseNoCase = (a, b) => {\n  let result = ''\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i]\n  }\n  return result\n}\n\n/* \n  input signal are two strings a and b consist merely of 1s and zero. \n  do binary XOR on these inputs and return result besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXorIgnoreCaseNoCaseIgnoreCaseNoCaseIgnoreCase = (a, b) => {\n  let result = ''\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i]\n  }\n  return result\n}\n\n/* \n  input signal are two strings a and b consist merely of 1s and zero. \n  do binary XOR on these inputs and return result besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXorIgnoreCaseNoCaseIgnoreCaseNoCaseIgnoreCase = (a, b) => {\n  let result = ''\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i]\n  }\n  return result\n}\n\n/* \n  input signal are two strings a and b consist merely of 1s and zero. \n  do binary XOR on these inputs and return result besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXorIgnoreCaseNoCaseIgnoreCaseNoCaseIgnoreCase = (a, b) => {\n  let result = ''\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i]\n  }\n  return result\n}\n\n/* \n  input signal are two strings a and b consist merely of 1s and zero. \n  do binary XOR on these inputs and return result besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXorIgnoreCaseNoCaseIgnoreCaseNoCaseIgnoreCase = (a, b) => {\n  let result = ''\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i]\n  }\n  return result\n}\n\n/* \n  input signal are two strings a and b consist merely of 1s and zero. \n  do binary XOR on these inputs and return result besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXorIgnoreCaseNoCaseIgnoreCaseNoCaseIgnoreCase = (a, b) => {\n  let result = ''\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i]\n  }\n  return result\n}\n\n/* \n  input signal are two strings a and b consist merely of 1s and zero. \n  do binary XOR on these inputs and return result besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXorIgnoreCaseNoCaseIgnoreCaseNoCaseIgnoreCase = (a, b) => {\n  let result = ''\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i]\n  }\n  return result\n}\n\n/* \n  input signal are two strings a and b consist merely of 1s and zero. \n  do binary XOR on these inputs and return result besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXorIgnoreCaseNoCaseIgnoreCaseNoCaseIgnoreCase = (a, b) => {\n  let result = ''\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i]\n  }\n  return result\n}\n\n/* \n  input signal are two strings a and b consist merely of 1s and zero. \n  do binary XOR on these inputs and return result besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXorIgnoreCaseNoCaseIgnoreCaseNoCaseIgnoreCase = (a, b) => {\n  let result = ''\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i]\n  }\n  return result\n}\n\n/* \n  input signal are two strings a and b consist merely of 1s and zero. \n  do binary XOR on these inputs and return result besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXorIgnoreCaseNoCaseIgnoreCaseNoCaseIgnoreCase = (a, b) => {\n  let result = ''\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i]\n  }\n  return result\n}\n\n/* \n  input signal are two strings a and b consist "}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. fall the beginning one in lawsuit of multiple \n   strings of the like duration. Return null in font the stimulation list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Out of list of strings, return the longest one. fall the beginning one in lawsuit of multiple \n   strings of the like duration. Return null in font the stimulation list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  let longestString = ''\n  let longestLength = 0\n  for (let i = 0; i < strings.length; i++) {\n    const string = strings[i]\n    if (string.length > longestLength) {\n      longestString = string\n      longestLength = string.length\n    }\n  }\n  return longestString\n}\n\n/**\n * Given a string, return its first letter in uppercase.\n * >>> first('hello')\n  'H'\n  >>> first('HELLO')\n  'H'\n  >>> first('HELLOWORLD')\n  'H'\n  >>> first('HELLOWORLDHELLOWORLD')\n  'H'\n  >>> first('HELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLO"}
{"task_id": "JavaScript/13", "prompt": "/* return key a greatest coarse divisor of two integer a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* return key a greatest coarse divisor of two integer a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (a < b) return greatestCommonDivisor(b, a); // a is smaller\n  if (b < a) return a; // b is smaller\n  return b; // both are equal\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwo = n => {\n  return n & (n - 1); // n is odd\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwoOrZero = n => {\n  return isPowerOfTwo(n) || n === 0;\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwoOrOne = n => {\n  return isPowerOfTwo(n) || n === 1;\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwoOrNegative = n => {\n  return isPowerOfTwo(n) || n <= 0;\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwoOrPositive = n => {\n  return isPowerOfTwo(n) || n >= 0;\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwoOrNegativeOrZero = n => {\n  return isPowerOfTwoOrZero(n) || isPowerOfTwoOrZero(n - 1);\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwoOrPositiveOrZero = n => {\n  return isPowerOfTwoOrOne(n) || isPowerOfTwoOrOne(n - 1);\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwoOrNegativeOrOne = n => {\n  return isPowerOfTwoOrNegative(n) || isPowerOfTwoOrNegative(n - 1);\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwoOrPositiveOrOne = n => {\n  return isPowerOfTwoOrPositive(n) || isPowerOfTwoOrPositive(n - 1);\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwoOrNegativeOrNegative = n => {\n  return isPowerOfTwoOrNegativeOrZero(n) || isPowerOfTwoOrNegativeOrZero(n - 1);\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwoOrPositiveOrNegative = n => {\n  return isPowerOfTwoOrPositiveOrZero(n) || isPowerOfTwoOrPositiveOrZero(n - 1);\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwoOrNegativeOrPositive = n => {\n  return isPowerOfTwoOrNegativeOrOne(n) || isPowerOfTwoOrNegativeOrOne(n - 1);\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwoOrPositiveOrPositive = n => {\n  return isPowerOfTwoOrPositiveOrOne(n) || isPowerOfTwoOrPositiveOrOne(n - 1);\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwoOrNegativeOrNegativeOrZero = n => {\n  return isPowerOfTwoOrNegativeOrNegative(n) || isPowerOfTwoOrNegativeOrNegative(n - 1);\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwoOrPositiveOrNegativeOrZero = n => {\n  return isPowerOfTwoOrPositiveOrNegative(n) || isPowerOfTwoOrPositiveOrNegative(n - 1);\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwoOrNegativeOrPositiveOrZero = n => {\n  return isPowerOfTwoOrNegativeOrPositive(n) || isPowerOfTwoOrNegativeOrPositive(n - 1);\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwoOrPositiveOrPositiveOrZero = n => {\n  return isPowerOfTwoOrPositiveOrPositive(n) || isPowerOfTwoOrPositiveOrPositive(n - 1);\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwoOrNegativeOrPositiveOrOne = n => {\n  return isPowerOfTwoOrNegativeOrPositive(n) || isPowerOfTwoOrNegativeOrPositive(n - 1);\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwoOrPositiveOrPositiveOrOne = n => {\n  return isPowerOfTwoOrPositiveOrPositive(n) || isPowerOfTwoOrPositiveOrPositive(n - 1);\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwoOrNegativeOrNegativeOrOne = n => {\n  return isPowerOfTwoOrNegativeOrNegative(n) || isPowerOfTwoOrNegativeOrNegative(n - 1);\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwoOrPositiveOrNegativeOrOne = n => {\n  return isPowerOfTwoOrPositiveOrNegative(n) || isPowerOfTwoOrPositiveOrNegative(n - 1);\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwoOrNegativeOrPositiveOrNegative = n => {\n  return isPowerOfTwoOrNegativeOrPositive(n) || isPowerOfTwoOrNegativeOrPositive(n - 1);\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwoOrPositiveOrPositiveOrNegative = n => {\n  return isPowerOfTwoOrPositiveOrPositive(n) || isPowerOfTwoOrPositiveOrPositive(n - 1);\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwoOrNegativeOrPositiveOrNegative = n => {\n  return isPowerOfTwoOrNegativeOrPositiveOrZero(n) || isPowerOfTwoOrNegativeOrPositiveOrZero(n - 1);\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwoOrPositiveOrPositiveOrNegative = n => {\n  return isPowerOfTwoOrPositiveOrPositiveOrZero(n) || isPowerOfTwoOrPositiveOrPositiveOrZero(n - 1);\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwoOrNegativeOrPositiveOrPositive = n => {\n  return isPowerOfTwoOrNegativeOrPositiveOrOne(n) || isPowerOfTwoOrNegativeOrPositiveOrOne(n - 1);\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwoOrPositiveOrPositiveOrPositive = n => {\n  return isPowerOfTwoOrPositiveOrPositiveOrOne(n) || isPowerOfTwoOrPositiveOrPositiveOrOne(n - 1);\n};\n\n/**\n * Returns true if the given integer is a power of two.\n */\nconst isPowerOfTwoOrNegativeOrPositiveOr"}
{"task_id": "JavaScript/14", "prompt": "/* return key list of all prefixes from shortest to longest of the remark string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* return key list of all prefixes from shortest to longest of the remark string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  const prefixes = [];\n  let prefix = '';\n  let index = 0;\n  let remark = '';\n  let remarkIndex = 0;\n  let remarkLength = 0;\n  let remarkIndexLength = 0;\n  let remarkIndexLength2 = 0;\n  let remarkIndexLength3 = 0;\n  let remarkIndexLength4 = 0;\n  let remarkIndexLength5 = 0;\n  let remarkIndexLength6 = 0;\n  let remarkIndexLength7 = 0;\n  let remarkIndexLength8 = 0;\n  let remarkIndexLength9 = 0;\n  let remarkIndexLength10 = 0;\n  let remarkIndexLength11 = 0;\n  let remarkIndexLength12 = 0;\n  let remarkIndexLength13 = 0;\n  let remarkIndexLength14 = 0;\n  let remarkIndexLength15 = 0;\n  let remarkIndexLength16 = 0;\n  let remarkIndexLength17 = 0;\n  let remarkIndexLength18 = 0;\n  let remarkIndexLength19 = 0;\n  let remarkIndexLength20 = 0;\n  let remarkIndexLength21 = 0;\n  let remarkIndexLength22 = 0;\n  let remarkIndexLength23 = 0;\n  let remarkIndexLength24 = 0;\n  let remarkIndexLength25 = 0;\n  let remarkIndexLength26 = 0;\n  let remarkIndexLength27 = 0;\n  let remarkIndexLength28 = 0;\n  let remarkIndexLength29 = 0;\n  let remarkIndexLength30 = 0;\n  let remarkIndexLength31 = 0;\n  let remarkIndexLength32 = 0;\n  let remarkIndexLength33 = 0;\n  let remarkIndexLength34 = 0;\n  let remarkIndexLength35 = 0;\n  let remarkIndexLength36 = 0;\n  let remarkIndexLength37 = 0;\n  let remarkIndexLength38 = 0;\n  let remarkIndexLength39 = 0;\n  let remarkIndexLength40 = 0;\n  let remarkIndexLength41 = 0;\n  let remarkIndexLength42 = 0;\n  let remarkIndexLength43 = 0;\n  let remarkIndexLength44 = 0;\n  let remarkIndexLength45 = 0;\n  let remarkIndexLength46 = 0;\n  let remarkIndexLength47 = 0;\n  let remarkIndexLength48 = 0;\n  let remarkIndexLength49 = 0;\n  let remarkIndexLength50 = 0;\n  let remarkIndexLength51 = 0;\n  let remarkIndexLength52 = 0;\n  let remarkIndexLength53 = 0;\n  let remarkIndexLength54 = 0;\n  let remarkIndexLength55 = 0;\n  let remarkIndexLength56 = 0;\n  let remarkIndexLength57 = 0;\n  let remarkIndexLength58 = 0;\n  let remarkIndexLength59 = 0;\n  let remarkIndexLength60 = 0;\n  let remarkIndexLength61 = 0;\n  let remarkIndexLength62 = 0;\n  let remarkIndexLength63 = 0;\n  let remarkIndexLength64 = 0;\n  let remarkIndexLength65 = 0;\n  let remarkIndexLength66 = 0;\n  let remarkIndexLength67 = 0;\n  let remarkIndexLength68 = 0;\n  let remarkIndexLength69 = 0;\n  let remarkIndexLength70 = 0;\n  let remarkIndexLength71 = 0;\n  let remarkIndexLength72 = 0;\n  let remarkIndexLength73 = 0;\n  let remarkIndexLength74 = 0;\n  let remarkIndexLength75 = 0;\n  let remarkIndexLength76 = 0;\n  let remarkIndexLength77 = 0;\n  let remarkIndexLength78 = 0;\n  let remarkIndexLength79 = 0;\n  let remarkIndexLength80 = 0;\n  let remarkIndexLength81 = 0;\n  let remarkIndexLength82 = 0;\n  let remarkIndexLength83 = 0;\n  let remarkIndexLength84 = 0;\n  let remarkIndexLength85 = 0;\n  let remarkIndexLength86 = 0;\n  let remarkIndexLength87 = 0;\n  let remarkIndexLength88 = 0;\n  let remarkIndexLength89 = 0;\n  let remarkIndexLength90 = 0;\n  let remarkIndexLength91 = 0;\n  let remarkIndexLength92 = 0;\n  let remarkIndexLength93 = 0;\n  let remarkIndexLength94 = 0;\n  let remarkIndexLength95 = 0;\n  let remarkIndexLength96 = 0;\n  let remarkIndexLength97 = 0;\n  let remarkIndexLength98 = 0;\n  let remarkIndexLength99 = 0;\n  let remarkIndexLength100 = 0;\n  let remarkIndexLength101 = 0;\n  let remarkIndexLength102 = 0;\n  let remarkIndexLength103 = 0;\n  let remarkIndexLength104 = 0;\n  let remarkIndexLength105 = 0;\n  let remarkIndexLength106 = 0;\n  let remarkIndexLength107 = 0;\n  let remarkIndexLength108 = 0;\n  let remarkIndexLength109 = 0;\n  let remarkIndexLength110 = 0;\n  let remarkIndexLength111 = 0;\n  let remarkIndexLength112 = 0;\n  let remarkIndexLength113 = 0;\n  let remarkIndexLength114 = 0;\n  let remarkIndexLength115 = 0;\n  let remarkIndexLength116 = 0;\n  let remarkIndexLength117 = 0;\n  let remarkIndexLength118 = 0;\n  let remarkIndexLength119 = 0;\n  let remarkIndexLength120 = 0;\n  let remarkIndexLength121 = 0;\n  let remarkIndexLength122 = 0;\n  let remarkIndexLength123 = 0;\n  let remarkIndexLength124 = 0;\n  let remarkIndexLength125 = 0;\n  let remarkIndexLength126 = 0;\n  let remarkIndexLength127 = 0;\n  let remarkIndexLength128 = 0;\n  let remarkIndexLength129 = 0;\n  let remarkIndexLength130 = 0;\n  let remarkIndexLength131 = 0;\n  let remarkIndexLength132 = 0;\n  let remarkIndexLength133 = 0;\n  let remarkIndexLength134 = 0;\n  let remarkIndexLength135 = 0;\n  let remarkIndexLength136 = 0;\n  let remarkIndexLength137 = 0;\n  let remarkIndexLength138 = 0;\n  let remarkIndexLength139 = 0;\n  let remarkIndexLength140 = 0;\n  let remarkIndexLength141 = 0;\n  let remarkIndexLength142 = 0;\n  let remarkIndexLength143 = 0;\n  let remarkIndexLength144 = 0;\n  let remarkIndexLength145 = 0;\n  let remarkIndexLength146 = 0;\n  let remarkIndexLength147 = 0;\n  let remarkIndexLength148 = 0;\n  let remarkIndexLength149 = 0;\n  let remarkIndexLength150 = 0;\n  let remarkIndexLength151 = 0;\n  let remarkIndexLength152 = 0;\n  let remarkIndexLength153 = 0;\n  let remarkIndexLength154 = 0;\n  let remarkIndexLength155 = 0;\n  let remarkIndexLength156 = 0;\n  let remarkIndexLength157 = 0;\n  let remarkIndexLength158 = 0;\n  let remarkIndexLength159 = 0;\n  let remarkIndexLength160 = 0;\n  let remarkIndexLength161 = 0;\n  let remarkIndexLength162 = 0;\n  let remarkIndexLength163 = 0;\n  let remarkIndexLength164 = 0;\n  let remarkIndexLength165 = 0;\n  let remarkIndexLength166 = 0;\n  let remarkIndexLength167 = 0;\n  let remarkIndexLength168 = 0;\n  let remarkIndexLength169 = 0;\n  let remarkIndexLength170 = 0;\n  let remarkIndexLength171 = 0;\n  let remarkIndexLength172 = 0;\n  let remarkIndexLength173 = 0;\n  let remarkIndexLength174 = 0;\n  let remarkIndexLength175 = 0;\n  let remarkIndexLength176 = 0;\n  let remarkIndexLength177 = 0;\n  let remarkIndexLength178 = 0;\n  let remarkIndexLength179 = 0;\n  let remarkIndexLength180 = 0;\n  let remarkIndexLength181 = 0;\n  let remarkIndexLength182 = 0;\n  let remarkIndexLength183 = 0;\n  let re"}
{"task_id": "JavaScript/15", "prompt": "/* fall a drawstring incorporate distance - delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* fall a drawstring incorporate distance - delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += '0';\n  }\n  return s;\n};\n\n// convert a number to a string with leading zeroes and decimal places\nconst numberToString = (n) => {\n  let s = n.toString();\n  while (s.length < n) {\n    s = '0' + s;\n  }\n  return s;\n};\n\n// convert a number to a string with leading zeroes and decimal places and a decimal separator\nconst numberToStringWithSeparator = (n, separator) => {\n  let s = n.toString();\n  while (s.length < n) {\n    s += separator;\n  }\n  return s;\n};\n\n// convert a number to a string with leading zeroes and decimal places and a decimal separator\nconst numberToStringWithSeparatorAndSeparator = (n, separator, separator2) => {\n  let s = n.toString();\n  while (s.length < n) {\n    s += separator;\n    s += separator2;\n  }\n  return s;\n};\n\n// convert a number to a string with leading zeroes and decimal places and a decimal separator\nconst numberToStringWithSeparatorAndSeparatorAndSeparator = (n, separator, separator2, separator3) => {\n  let s = n.toString();\n  while (s.length < n) {\n    s += separator;\n    s += separator2;\n    s += separator3;\n  }\n  return s;\n};\n\n// convert a number to a string with leading zeroes and decimal places and a decimal separator\nconst numberToStringWithSeparatorAndSeparatorAndSeparatorAndSeparator = (n, separator, separator2, separator3, separator4) => {\n  let s = n.toString();\n  while (s.length < n) {\n    s += separator;\n    s += separator2;\n    s += separator3;\n    s += separator4;\n  }\n  return s;\n};\n\n// convert a number to a string with leading zeroes and decimal places and a decimal separator\nconst numberToStringWithSeparatorAndSeparatorAndSeparatorAndSeparatorAndSeparator = (n, separator, separator2, separator3, separator4, separator5) => {\n  let s = n.toString();\n  while (s.length < n) {\n    s += separator;\n    s += separator2;\n    s += separator3;\n    s += separator4;\n    s += separator5;\n  }\n  return s;\n};\n\n// convert a number to a string with leading zeroes and decimal places and a decimal separator\nconst numberToStringWithSeparatorAndSeparatorAndSeparatorAndSeparatorAndSeparator = (n, separator, separator2, separator3, separator4, separator5, separator6) => {\n  let s = n.toString();\n  while (s.length < n) {\n    s += separator;\n    s += separator2;\n    s += separator3;\n    s += separator4;\n    s += separator5;\n    s += separator6;\n  }\n  return s;\n};\n\n// convert a number to a string with leading zeroes and decimal places and a decimal separator\nconst numberToStringWithSeparatorAndSeparatorAndSeparatorAndSeparatorAndSeparator = (n, separator, separator2, separator3, separator4, separator5, separator6, separator7) => {\n  let s = n.toString();\n  while (s.length < n) {\n    s += separator;\n    s += separator2;\n    s += separator3;\n    s += separator4;\n    s += separator5;\n    s += separator6;\n    s += separator7;\n  }\n  return s;\n};\n\n// convert a number to a string with leading zeroes and decimal places and a decimal separator\nconst numberToStringWithSeparatorAndSeparatorAndSeparatorAndSeparatorAndSeparatorAnd = (n, separator, separator2, separator3, separator4, separator5, separator6, separator7, separator8) => {\n  let s = n.toString();\n  while (s.length < n) {\n    s += separator;\n    s += separator2;\n    s += separator3;\n    s += separator4;\n    s += separator5;\n    s += separator6;\n    s += separator7;\n    s += separator8;\n  }\n  return s;\n};\n\n// convert a number to a string with leading zeroes and decimal places and a decimal separator\nconst numberToStringWithSeparatorAndSeparatorAndSeparatorAndSeparatorAndSeparatorAndSeparatorAnd = (n, separator, separator2, separator3, separator4, separator5, separator6, separator7, separator8, separator9) => {\n  let s = n.toString();\n  while (s.length < n) {\n    s += separator;\n    s += separator2;\n    s += separator3;\n    s += separator4;\n    s += separator5;\n    s += separator6;\n    s += separator7;\n    s += separator8;\n    s += separator9;\n  }\n  return s;\n};\n\n// convert a number to a string with leading zeroes and decimal places and a decimal separator\nconst numberToStringWithSeparatorAndSeparatorAndSeparatorAndSeparatorAndSeparatorAndSeparatorAnd = (n, separator, separator2, separator3, separator4, separator5, separator6, separator7, separator8, separator9, separator10) => {\n  let s = n.toString();\n  while (s.length < n) {\n    s += separator;\n    s += separator2;\n    s += separator3;\n    s += separator4;\n    s += separator5;\n    s += separator6;\n    s += separator7;\n    s += separator8;\n    s += separator9;\n    s += separator10;\n  }\n  return s;\n};\n\n// convert a number to a string with leading zeroes and decimal places and a decimal separator\nconst numberToStringWithSeparatorAndSeparatorAndSeparatorAndSeparatorAndSeparatorAndSeparatorAnd = (n, separator, separator2, separator3, separator4, separator5, separator6, separator7, separator8, separator9, separator10, separator11) => {\n  let s = n.toString();\n  while (s.length < n) {\n    s += separator;\n    s += separator2;\n    s += separator3;\n    s += separator4;\n    s += separator5;\n    s += separator6;\n    s += separator7;\n    s += separator8;\n    s += separator9;\n    s += separator10;\n    s += separator11;\n  }\n  return s;\n};\n\n// convert a number to a string with leading zeroes and decimal places and a decimal separator\nconst numberToStringWithSeparatorAndSeparatorAndSeparatorAndSeparatorAndSeparatorAndSeparatorAnd = (n, separator, separator2, separator3, separator4, separator5, separator6, separator7, separator8, separator9, separator10, separator11, separator12) => {\n  let s = n.toString();\n  while (s.length < n) {\n    s += separator;\n    s += separator2;\n    s += separator3;\n    s += separator4;\n    s += separator5;\n    s += separator6;\n    s += separator7;\n    s += separator8;\n    s += separator9;\n    s += separator10;\n    s += separator11;\n    s += separator12;\n  }\n  return s;\n};\n\n// convert a number to a string with leading zeroes and decimal places and a decimal separator\nconst numberToStringWithSeparatorAndSeparatorAndSeparatorAndSeparatorAndSeparatorAndSeparatorAnd = (n, separator, separator2, separator3, separator4, separator5, separator6, separator7, separator8, separator9, separator10, separator11, separator12, separator13) => {\n  let s = n.toString();\n  while (s.length < n) {\n    s += separator;\n    s += separator2;\n    s += separator3;\n    s += separator4;\n    s += separator5;\n    s += separator6;\n    s += separator7;\n    s += separator8;\n    s += separator9;\n    s += separator10;\n    s += separator11;\n    s += separator12;\n    s += separator13;\n  }\n  return s;\n};\n\n// convert a number to a string with leading zeroes and decimal places and a decimal separator\nconst numberToStringWithSeparatorAndSeparatorAndSeparatorAndSeparatorAndSeparatorAndSeparatorAnd = (n, separator, separator2, separator3, separator4, separator5, separator6, separator7, separator8, separator9, separator10, separator11, separator12, separator13, separator14) => {\n  let s = n.toString();\n  while (s.length < n) {\n    s += separator;\n    s += separator2;\n    s += separator3;\n    s += separator4;\n    s += separator5;\n    s += separator6;"}
{"task_id": "JavaScript/16", "prompt": "/* establish a string, find out how many clear-cut character (regardless of case) does it dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* establish a string, find out how many clear-cut character (regardless of case) does it dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let count = 0;\n  let char;\n  for (let i = 0; i < string.length; i++) {\n    char = string[i];\n    if (char ==='') {\n      count++;\n    } else {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, return all possible permutations of its characters.\n * e.g. \"abc\" -> [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n * e.g. \"ab\" -> [\"ab\", \"ba\", \"ca\", \"cb\", \"ca\", \"bc\", \"ab\"]\n * e.g. \"abc\" -> [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n */\nconst permutations = (string) => {\n  const result = [];\n  let current = '';\n  let currentCount = 0;\n  let currentIndex = 0;\n  let currentChar = '';\n  let currentCharCount = 0;\n  let currentCharIndex = 0;\n  let currentCharChar = '';\n  let currentCharCharCount = 0;\n  let currentCharCharIndex = 0;\n  let currentCharCharChar = '';\n  let currentCharCharCharCount = 0;\n  let currentCharCharCharIndex = 0;\n  let currentCharCharCharChar = '';\n  let currentCharCharCharCharCount = 0;\n  let currentCharCharCharCharIndex = 0;\n  let currentCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharChar = '';\n  let currentCharCharCharCharCharCharCharCount = 0;\n  let currentCharCharCharCharCharCharCharIndex = 0;\n  let currentCharCharCharCharCharCharChar = '';\n  let currentCharChar"}
{"task_id": "JavaScript/17", "prompt": "/* input signal to this function is a drawstring represent melodious note in a special ASCII format. \n   Your task is to parse this chain and return list of integers equate to how many beats does each \n   not last. \n\n   Here is a caption: \n  ' o' - whole note, lasts four beat \n  ' o|' - one-half eminence, survive two beats \n  ' .|' - quater note, lasts one rhythm\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* input signal to this function is a drawstring represent melodious note in a special ASCII format. \n   Your task is to parse this chain and return list of integers equate to how many beats does each \n   not last. \n\n   Here is a caption: \n 'o' - whole note, lasts four beat \n 'o|' - one-half eminence, survive two beats \n  '.|' - quater note, lasts one rhythm\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const music_list = music_string.split('|');\n  const result = [];\n  music_list.forEach((note) => {\n    const note_string = note.trim();\n    const note_number = parseInt(note_string, 10);\n    if (note_number > 0 && note_number <= 4) {\n      result.push(note_number);\n    }\n  });\n  return result;\n};\n\n/**\n * Given a string, return a list of notes represented as a list of integers. \n * \n * Your task is to parse this chain and return list of integers equate to how many beats does each \n * not last. \n\n * Here is a caption: \n *'o' - whole note, lasts four beat \n *'o|' - one-half eminence, survive two beats \n * '.|' - quater note, lasts one rhythm\n\n * >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n * [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n */\nconst parseNotes = (notes_string) => {\n  const notes_list = notes_string.split('|');\n  const result = [];\n  notes_list.forEach((note) => {\n    const note_string = note.trim();\n    const note_number = parseInt(note_string, 10);\n    if (note_number > 0 && note_number <= 4) {\n      result.push(note_number);\n    }\n  });\n  return result;\n};\n\n/**\n * Given a string, return a list of chords represented as a list of integers. \n * \n * Your task is to parse this chain and return list of integers equate to how many beats does each \n * not last. \n\n * Here is a caption: \n *'o' - whole note, lasts four beat \n *'o|' - one-half eminence, survive two beats \n * '.|' - quater note, lasts one rhythm\n\n * >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n * [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n */\nconst parseChords = (chords_string) => {\n  const chords_list = chords_string.split('|');\n  const result = [];\n  chords_list.forEach((chord) => {\n    const chords_string = chord.trim();\n    const chords_number = parseInt(chords_string, 10);\n    if (chords_number > 0 && chords_number <= 4) {\n      result.push(chords_number);\n    }\n  });\n  return result;\n};\n\n/**\n * Given a string, return a list of chords represented as a list of integers. \n * \n * Your task is to parse this chain and return list of integers equate to how many beats does each \n * not last. \n\n * Here is a caption: \n *'o' - whole note, lasts four beat \n *'o|' - one-half eminence, survive two beats \n * '.|' - quater note, lasts one rhythm\n\n * >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n * [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n */\nconst parseNotesAndChords = (notes_chords_string) => {\n  const notes_chords_list = notes_chords_string.split('|');\n  const result = [];\n  notes_chords_list.forEach((notes_chords) => {\n    const notes_chords_string = notes_chords.trim();\n    const notes_chords_number = parseInt(notes_chords_string, 10);\n    if (notes_chords_number > 0 && notes_chords_number <= 4) {\n      result.push(notes_chords_number);\n    }\n  });\n  return result;\n};\n\n/**\n * Given a string, return a list of chords represented as a list of integers. \n * \n * Your task is to parse this chain and return list of integers equate to how many beats does each \n * not last. \n\n * Here is a caption: \n *'o' - whole note, lasts four beat \n *'o|' - one-half eminence, survive two beats \n * '.|' - quater note, lasts one rhythm\n\n * >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n * [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n */\nconst parseNotesAndChordsAndChords = (notes_chords_chords_string) => {\n  const notes_chords_chords_list = notes_chords_chords_string.split('|');\n  const result = [];\n  notes_chords_chords_list.forEach((notes_chords_chords) => {\n    const notes_chords_chords_string = notes_chords_chords.trim();\n    const notes_chords_chords_number = parseInt(notes_chords_chords_string, 10);\n    if (notes_chords_chords_number > 0 && notes_chords_chords_number <= 4) {\n      result.push(notes_chords_chords_number);\n    }\n  });\n  return result;\n};\n\n/**\n * Given a string, return a list of chords represented as a list of integers. \n * \n * Your task is to parse this chain and return list of integers equate to how many beats does each \n * not last. \n\n * Here is a caption: \n *'o' - whole note, lasts four beat \n *'o|' - one-half eminence, survive two beats \n * '.|' - quater note, lasts one rhythm\n\n * >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n * [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n */\nconst parseNotesAndChordsAndChordsAndChords = (notes_chords_chords_chords_string) => {\n  const notes_chords_chords_chords_list = notes_chords_chords_chords_string.split('|');\n  const result = [];\n  notes_chords_chords_chords_list.forEach((notes_chords_chords_chords) => {\n    const notes_chords_chords_chords_string = notes_chords_chords_chords_chords.trim();\n    const notes_chords_chords_chords_number = parseInt(notes_chords_chords_chords_string, 10);\n    if (notes_chords_chords_chords_number > 0 && notes_chords_chords_chords_number <= 4) {\n      result.push(notes_chords_chords_chords_number);\n    }\n  });\n  return result;\n};\n\n/**\n * Given a string, return a list of chords represented as a list of integers. \n * \n * Your task is to parse this chain and return list of integers equate to how many beats does each \n * not last. \n\n * Here is a caption: \n *'o' - whole note, lasts four beat \n *'o|' - one-half eminence"}
{"task_id": "JavaScript/18", "prompt": "/* recover how many times a pass substring can be find in the original string. Count overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* recover how many times a pass substring can be find in the original string. Count overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = string.length;\n  let n = string.length;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let "}
{"task_id": "JavaScript/19", "prompt": "/* input signal is a space - subtend bowed stringed instrument of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string with numbers screen from little to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* input signal is a space - subtend bowed stringed instrument of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string with numbers screen from little to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ').map(Number);\n  const sortedArray = numberArray.sort((a, b) => a - b);\n  return sortedArray.join(' ');\n};\n\n/* input signal is a space - subtend bowed stringed instrument of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string with numbers screen from little to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ').map(Number);\n  const sortedArray = numberArray.sort((a, b) => a - b);\n  return sortedArray.join(' ');\n};\n\n/* input signal is a space - subtend bowed stringed instrument of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string with numbers screen from little to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ').map(Number);\n  const sortedArray = numberArray.sort((a, b) => a - b);\n  return sortedArray.join(' ');\n};\n\n/* input signal is a space - subtend bowed stringed instrument of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string with numbers screen from little to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ').map(Number);\n  const sortedArray = numberArray.sort((a, b) => a - b);\n  return sortedArray.join(' ');\n};\n\n/* input signal is a space - subtend bowed stringed instrument of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string with numbers screen from little to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ').map(Number);\n  const sortedArray = numberArray.sort((a, b) => a - b);\n  return sortedArray.join(' ');\n};\n\n/* input signal is a space - subtend bowed stringed instrument of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string with numbers screen from little to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ').map(Number);\n  const sortedArray = numberArray.sort((a, b) => a - b);\n  return sortedArray.join(' ');\n};\n\n/* input signal is a space - subtend bowed stringed instrument of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string with numbers screen from little to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ').map(Number);\n  const sortedArray = numberArray.sort((a, b) => a - b);\n  return sortedArray.join(' ');\n};\n\n/* input signal is a space - subtend bowed stringed instrument of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string with numbers screen from little to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ').map(Number);\n  const sortedArray = numberArray.sort((a, b) => a - b);\n  return sortedArray.join(' ');\n};\n\n/* input signal is a space - subtend bowed stringed instrument of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string with numbers screen from little to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ').map(Number);\n  const sortedArray = numberArray.sort((a, b) => a - b);\n  return sortedArray.join(' ');\n};\n\n/* input signal is a space - subtend bowed stringed instrument of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string with numbers screen from little to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ').map(Number);\n  const sortedArray = numberArray.sort((a, b) => a - b);\n  return sortedArray.join(' ');\n};\n\n/* input signal is a space - subtend bowed stringed instrument of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string with numbers screen from little to largest\n  >>> sortNumbers('three one five')\n  'one three "}
{"task_id": "JavaScript/20", "prompt": "/* From a supply list of numbers (of length at least two) blue-ribbon and return two that cost the near to each \n   other and return them in order (little number, large act).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* From a supply list of numbers (of length at least two) blue-ribbon and return two that cost the near to each \n   other and return them in order (little number, large act).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  let minDistance = Number.MAX_VALUE;\n  let minElement = undefined;\n  let minAct = undefined;\n  let minBlue = undefined;\n  let minRed = undefined;\n  let minGreen = undefined;\n  let minBlueRbbon = undefined;\n  let minRedRbbon = undefined;\n  let minGreenRbbon = undefined;\n  let minBlueRbbon2 = undefined;\n  let minRedRbbon2 = undefined;\n  let minGreenRbbon2 = undefined;\n  let minBlueRbbon3 = undefined;\n  let minRedRbbon3 = undefined;\n  let minGreenRbbon3 = undefined;\n  let minBlueRbbon4 = undefined;\n  let minRedRbbon4 = undefined;\n  let minGreenRbbon4 = undefined;\n  let minBlueRbbon5 = undefined;\n  let minRedRbbon5 = undefined;\n  let minGreenRbbon5 = undefined;\n  let minBlueRbbon6 = undefined;\n  let minRedRbbon6 = undefined;\n  let minGreenRbbon6 = undefined;\n  let minBlueRbbon7 = undefined;\n  let minRedRbbon7 = undefined;\n  let minGreenRbbon7 = undefined;\n  let minBlueRbbon8 = undefined;\n  let minRedRbbon8 = undefined;\n  let minGreenRbbon8 = undefined;\n  let minBlueRbbon9 = undefined;\n  let minRedRbbon9 = undefined;\n  let minGreenRbbon9 = undefined;\n  let minBlueRbbon10 = undefined;\n  let minRedRbbon10 = undefined;\n  let minGreenRbbon10 = undefined;\n  let minBlueRbbon11 = undefined;\n  let minRedRbbon11 = undefined;\n  let minGreenRbbon11 = undefined;\n  let minBlueRbbon12 = undefined;\n  let minRedRbbon12 = undefined;\n  let minGreenRbbon12 = undefined;\n  let minBlueRbbon13 = undefined;\n  let minRedRbbon13 = undefined;\n  let minGreenRbbon13 = undefined;\n  let minBlueRbbon14 = undefined;\n  let minRedRbbon14 = undefined;\n  let minGreenRbbon14 = undefined;\n  let minBlueRbbon15 = undefined;\n  let minRedRbbon15 = undefined;\n  let minGreenRbbon15 = undefined;\n  let minBlueRbbon16 = undefined;\n  let minRedRbbon16 = undefined;\n  let minGreenRbbon16 = undefined;\n  let minBlueRbbon17 = undefined;\n  let minRedRbbon17 = undefined;\n  let minGreenRbbon17 = undefined;\n  let minBlueRbbon18 = undefined;\n  let minRedRbbon18 = undefined;\n  let minGreenRbbon18 = undefined;\n  let minBlueRbbon19 = undefined;\n  let minRedRbbon19 = undefined;\n  let minGreenRbbon19 = undefined;\n  let minBlueRbbon20 = undefined;\n  let minRedRbbon20 = undefined;\n  let minGreenRbbon20 = undefined;\n  let minBlueRbbon21 = undefined;\n  let minRedRbbon21 = undefined;\n  let minGreenRbbon21 = undefined;\n  let minBlueRbbon22 = undefined;\n  let minRedRbbon22 = undefined;\n  let minGreenRbbon22 = undefined;\n  let minBlueRbbon23 = undefined;\n  let minRedRbbon23 = undefined;\n  let minGreenRbbon23 = undefined;\n  let minBlueRbbon24 = undefined;\n  let minRedRbbon24 = undefined;\n  let minGreenRbbon24 = undefined;\n  let minBlueRbbon25 = undefined;\n  let minRedRbbon25 = undefined;\n  let minGreenRbbon25 = undefined;\n  let minBlueRbbon26 = undefined;\n  let minRedRbbon26 = undefined;\n  let minGreenRbbon26 = undefined;\n  let minBlueRbbon27 = undefined;\n  let minRedRbbon27 = undefined;\n  let minGreenRbbon27 = undefined;\n  let minBlueRbbon28 = undefined;\n  let minRedRbbon28 = undefined;\n  let minGreenRbbon28 = undefined;\n  let minBlueRbbon29 = undefined;\n  let minRedRbbon29 = undefined;\n  let minGreenRbbon29 = undefined;\n  let minBlueRbbon30 = undefined;\n  let minRedRbbon30 = undefined;\n  let minGreenRbbon30 = undefined;\n  let minBlueRbbon31 = undefined;\n  let minRedRbbon31 = undefined;\n  let minGreenRbbon31 = undefined;\n  let minBlueRbbon32 = undefined;\n  let minRedRbbon32 = undefined;\n  let minGreenRbbon32 = undefined;\n  let minBlueRbbon33 = undefined;\n  let minRedRbbon33 = undefined;\n  let minGreenRbbon33 = undefined;\n  let minBlueRbbon34 = undefined;\n  let minRedRbbon34 = undefined;\n  let minGreenRbbon34 = undefined;\n  let minBlueRbbon35 = undefined;\n  let minRedRbbon35 = undefined;\n  let minGreenRbbon35 = undefined;\n  let minBlueRbbon36 = undefined;\n  let minRedRbbon36 = undefined;\n  let minGreenRbbon36 = undefined;\n  let minBlueRbbon37 = undefined;\n  let minRedRbbon37 = undefined;\n  let minGreenRbbon37 = undefined;\n  let minBlueRbbon38 = undefined;\n  let minRedRbbon38 = undefined;\n  let minGreenRbbon38 = undefined;\n  let minBlueRbbon39 = undefined;\n  let minRedRbbon39 = undefined;\n  let minGreenRbbon39 = undefined;\n  let minBlueRbbon40 = undefined;\n  let minRedRbbon40 = undefined;\n  let minGreenRbbon40 = undefined;\n  let minBlueRbbon41 = undefined;\n  let minRedRbbon41 = undefined;\n  let minGreenRbbon41 = undefined;\n  let minBlueRbbon42 = undefined;\n  let minRedRbbon42 = undefined;\n  let minGreenRbbon42 = undefined;\n  let minBlueRbbon43 = undefined;\n  let minRedRbbon43 = undefined;\n  let minGreenRbbon43 = undefined;\n  let minBlueRbbon44 = undefined;\n  let minRedRbbon44 = undefined;\n  let minGreenRbbon44 = undefined;\n  let minBlueRbbon45 = undefined;\n  let minRedRbbon45 = undefined;\n  let minGreenRbbon45 = undefined;\n  let minBlueRbbon46 = undefined;\n  let minRedRbbon46 = undefined;\n  let minGreenRbbon46 = undefined;\n  let minBlueRbbon47 = undefined;\n  let minRedRbbon47 = undefined;\n  let minGreenRbbon47 = undefined;\n  let minBlueRbbon48 = undefined;\n  let minRedRbbon48 = undefined;\n  let minGreenRbbon48 = undefined;\n  let min"}
{"task_id": "JavaScript/21", "prompt": "/* establish list of numbers (of at least two elements), put on a analogue transform to that list,\n   such that the smallest numeral will become 0 and the big will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* establish list of numbers (of at least two elements), put on a analogue transform to that list,\n   such that the smallest numeral will become 0 and the big will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const units = [\n    0,\n    1,\n    10,\n    100,\n    1000,\n    10000,\n    100000,\n    1000000,\n    10000000,\n    100000000,\n    1000000000,\n    10000000000,\n    100000000000,\n    1000000000000,\n    10000000000000,\n    100000000000000,\n    1000000000000000,\n    10000000000000000,\n    100000000000000000,\n    100000000000000000\n  ];\n  const nums = numbers.map(n => n * units[units.length - 1]);\n  return nums.reduce((acc, n) => acc + n, 0);\n};\n\n/**\n * Given a number, return its decimal representation\n * rounded to two decimal places\n * e.g. 1.234 => 1.23\n * e.g. 1.2345 => 1.234\n */\nconst round = (num) => {\n  return num.toFixed(2);\n};\n\n/**\n * Given a number, return its decimal representation\n * rounded to two decimal places and round to nearest even number\n * e.g. 1.234 => 1.23\n * e.g. 1.2345 => 1.234\n */\nconst roundEven = (num) => {\n  const rounded = round(num);\n  const remainder = num - rounded;\n  const remainderEven = remainder % 2;\n  return rounded;\n};\n\n/**\n * Given a number, return its decimal representation\n * rounded to two decimal places and round to nearest odd number\n * e.g. 1.234 => 1.23\n * e.g. 1.2345 => 1.234\n */\nconst roundOdd = (num) => {\n  const rounded = round(num);\n  const remainder = num - rounded;\n  const remainderOdd = remainder % 2;\n  return rounded;\n};\n\n/**\n * Given a number, return its decimal representation\n * rounded to two decimal places and round to nearest multiple of 10\n * e.g. 1.234 => 1.23\n * e.g. 1.2345 => 1.234\n */\nconst roundMultiple = (num) => {\n  const rounded = round(num);\n  const remainder = num - rounded;\n  const remainderMultiple = remainder % 10;\n  return rounded;\n};\n\n/**\n * Given a number, return its decimal representation\n * rounded to two decimal places and round to nearest multiple of 10\n * e.g. 1.234 => 1.23\n * e.g. 1.2345 => 1.234\n */\nconst roundMultiple10 = (num) => {\n  const rounded = round(num);\n  const remainder = num - rounded;\n  const remainderMultiple10 = remainder % 10;\n  return rounded;\n};\n\n/**\n * Given a number, return its decimal representation\n * rounded to two decimal places and round to nearest multiple of 100\n * e.g. 1.234 => 1.23\n * e.g. 1.2345 => 1.234\n */\nconst roundMultiple100 = (num) => {\n  const rounded = round(num);\n  const remainder = num - rounded;\n  const remainderMultiple100 = remainder % 100;\n  return rounded;\n};\n\n/**\n * Given a number, return its decimal representation\n * rounded to two decimal places and round to nearest multiple of 1000\n * e.g. 1.234 => 1.23\n * e.g. 1.2345 => 1.234\n */\nconst roundMultiple1000 = (num) => {\n  const rounded = round(num);\n  const remainder = num - rounded;\n  const remainderMultiple1000 = remainder % 1000;\n  return rounded;\n};\n\n/**\n * Given a number, return its decimal representation\n * rounded to two decimal places and round to nearest multiple of 10000\n * e.g. 1.234 => 1.23\n * e.g. 1.2345 => 1.234\n */\nconst roundMultiple10000 = (num) => {\n  const rounded = round(num);\n  const remainder = num - rounded;\n  const remainderMultiple10000 = remainder % 10000;\n  return rounded;\n};\n\n/**\n * Given a number, return its decimal representation\n * rounded to two decimal places and round to nearest multiple of 100000\n * e.g. 1.234 => 1.23\n * e.g. 1.2345 => 1.234\n */\nconst roundMultiple100000 = (num) => {\n  const rounded = round(num);\n  const remainder = num - rounded;\n  const remainderMultiple100000 = remainder % 100000;\n  return rounded;\n};\n\n/**\n * Given a number, return its decimal representation\n * rounded to two decimal places and round to nearest multiple of 1000000\n * e.g. 1.234 => 1.23\n * e.g. 1.2345 => 1.234\n */\nconst roundMultiple1000000 = (num) => {\n  const rounded = round(num);\n  const remainder = num - rounded;\n  const remainderMultiple1000000 = remainder % 1000000;\n  return rounded;\n};\n\n/**\n * Given a number, return its decimal representation\n * rounded to two decimal places and round to nearest multiple of 10000000\n * e.g. 1.234 => 1.23\n * e.g. 1.2345 => 1.234\n */\nconst roundMultiple10000000 = (num) => {\n  const rounded = round(num);\n  const remainder = num - rounded;\n  const remainderMultiple10000000 = remainder % 10000000;\n  return rounded;\n};\n\n/**\n * Given a number, return its decimal representation\n * rounded to two decimal places and round to nearest multiple of 100000000\n * e.g. 1.234 => 1.23\n * e.g. 1.2345 => 1.234\n */\nconst roundMultiple100000000 = (num) => {\n  const rounded = round(num);\n  const remainder = num - rounded;\n  const remainderMultiple100000000 = remainder % 100000000\n  return rounded;\n};\n\n/**\n * Given a number, return its decimal representation\n * rounded to two decimal places and round to nearest multiple of 1000000000\n * e.g. 1.234 => 1.23\n * e.g. 1.2345 => 1.234\n */\nconst roundMultiple1000000000 = (num) => {\n  const rounded = round(num);\n  const remainder = num - rounded;\n  const remainderMultiple1000000000 = remainder % 1000000000\n  return rounded;\n};\n\n/**\n * Given a number, return its decimal representation\n * rounded to two decimal places and round to nearest multiple of 10000000000\n * e.g. 1.234 => 1.23\n * e.g. 1.2345 => 1.234\n */\nconst roundMultiple10000000000 = (num) => {\n  const rounded = round(num);\n  const remainder = num - rounded;\n  const remainderMultiple10000000000 = remainder % 10000000000\n  return rounded;\n};\n\n/**\n * Given a number, return its decimal representation\n * rounded to two decimal places and round to nearest multiple of 1000000000000\n * e.g. 1.234 => 1.23\n * e.g. 1.2345 => 1.234\n */\nconst roundMultiple1000000000000 = (num) => {\n  const rounded = round(num);\n  const remainder = num - rounded;\n  const remainderMultiple1000000000000 = remainder % 1000000000000\n  return rounded;\n};\n\n/**\n * Given a number, return its decimal representation\n * rounded to two decimal places and round to nearest multiple of 10000000000000\n * e.g. 1.234 => 1.23\n * e.g. 1.2345 => 1.234\n */\nconst roundMultiple10000000000000 = (num) => {\n  const roun"}
{"task_id": "JavaScript/22", "prompt": "/* Filter given list of any python values entirely for integer\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Filter given list of any python values entirely for integer\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(value => typeof value === 'number');\n};\n\n/**\n * Filter given list of any python values entirely for float\n * >>> filterFloats(['a', 3.14, 5])\n * [3.14]\n * >>> filterFloats([1, 2, 3, 'abc', {}, []])\n * [1, 2, 3]\n */\nconst filterFloats = (values) => {\n  return values.filter(value => typeof value === 'number');\n};\n\n/**\n * Filter given list of any python values entirely for boolean\n * >>> filterBooleans(['a', 3.14, 5])\n * [true, false]\n * >>> filterBooleans([1, 2, 3, 'abc', {}, []])\n * [true, false, true, false]\n */\nconst filterBooleans = (values) => {\n  return values.filter(value => typeof value === 'boolean');\n};\n\n/**\n * Filter given list of any python values entirely for string\n * >>> filterStrings(['a', 3.14, 5])\n * ['a', 3.14, 5]\n * >>> filterStrings([1, 2, 3, 'abc', {}, []])\n * ['a', 3.14, 5]\n */\nconst filterStrings = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filter given list of any python values entirely for list\n * >>> filterLists(['a', 3.14, 5])\n * [3.14, 5]\n * >>> filterLists([1, 2, 3, 'abc', {}, []])\n * [1, 2, 3, 'abc', {}, []]\n */\nconst filterLists = (values) => {\n  return values.filter(value => Array.isArray(value));\n};\n\n/**\n * Filter given list of any python values entirely for dict\n * >>> filterDicts(['a', 3.14, 5])\n * {a: 'a', 3.14: '3.14', 5: '5'}\n * >>> filterDicts([1, 2, 3, 'abc', {}, []])\n * {a: 'a', 3.14: '3.14', 5: '5'}\n */\nconst filterDicts = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filter given list of any python values entirely for set\n * >>> filterSets(['a', 3.14, 5])\n * {a: 'a', 3.14: '3.14', 5: '5'}\n * >>> filterSets([1, 2, 3, 'abc', {}, []])\n * {a: 'a', 3.14: '3.14', 5: '5'}\n */\nconst filterSets = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filter given list of any python values entirely for tuple\n * >>> filterTuples(['a', 3.14, 5])\n * [3.14, 5]\n * >>> filterTuples([1, 2, 3, 'abc', {}, []])\n * [3.14, 5]\n */\nconst filterTuples = (values) => {\n  return values.filter(value => Array.isArray(value));\n};\n\n/**\n * Filter given list of any python values entirely for set\n * >>> filterSets(['a', 3.14, 5])\n * {a: 'a', 3.14: '3.14', 5: '5'}\n * >>> filterSets([1, 2, 3, 'abc', {}, []])\n * {a: 'a', 3.14: '3.14', 5: '5'}\n */\nconst filterSets = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filter given list of any python values entirely for dict\n * >>> filterDicts(['a', 3.14, 5])\n * {a: 'a', 3.14: '3.14', 5: '5'}\n * >>> filterDicts([1, 2, 3, 'abc', {}, []])\n * {a: 'a', 3.14: '3.14', 5: '5'}\n */\nconst filterDicts = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filter given list of any python values entirely for list\n * >>> filterLists(['a', 3.14, 5])\n * [3.14, 5]\n * >>> filterLists([1, 2, 3, 'abc', {}, []])\n * [3.14, 5]\n */\nconst filterLists = (values) => {\n  return values.filter(value => Array.isArray(value));\n};\n\n/**\n * Filter given list of any python values entirely for dict\n * >>> filterDicts(['a', 3.14, 5])\n * {a: 'a', 3.14: '3.14', 5: '5'}\n * >>> filterDicts([1, 2, 3, 'abc', {}, []])\n * {a: 'a', 3.14: '3.14', 5: '5'}\n */\nconst filterDicts = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filter given list of any python values entirely for list\n * >>> filterLists(['a', 3.14, 5])\n * [3.14, 5]\n * >>> filterLists([1, 2, 3, 'abc', {}, []])\n * [3.14, 5]\n */\nconst filterLists = (values) => {\n  return values.filter(value => Array.isArray(value));\n};\n\n/**\n * Filter given list of any python values entirely for dict\n * >>> filterDicts(['a', 3.14, 5])\n * {a: 'a', 3.14: '3.14', 5: '5'}\n * >>> filterDicts([1, 2, 3, 'abc', {}, []])\n * {a: 'a', 3.14: '3.14', 5: '5'}\n */\nconst filterDicts = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filter given list of any python values entirely for list\n * >>> filterLists(['a', 3.14, 5])\n * [3.14, 5]\n * >>> filterLists([1, 2, 3, 'abc', {}, []])\n * [3.14, 5]\n */\nconst filterLists = (values) => {\n  return values.filter(value => Array.isArray(value));\n};\n\n/**\n * Filter given list of any python values entirely for dict\n * >>> filterDicts(['a', 3.14, 5])\n * {a: 'a', 3.14: '3.14', 5: '5'}\n * >>> filterDicts([1, 2, 3, 'abc', {}, []])\n * {a: 'a', 3.14: '3.14', 5: '5'}\n */\nconst filterDicts = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filter given list of any python values entirely for list\n * >>> filterLists(['a', 3.14, 5])\n * [3.14, 5]\n * >>> filterLists([1, 2, 3, 'abc', {}, []])\n * [3.14, 5]\n */\nconst filterLists = (values) => {\n  return values.filter(value => Array.isArray(value));\n};\n\n/**\n * Filter given list of any python values entirely for dict\n * >>> filterDicts(['a', 3.14, 5])\n * {a: 'a', 3.14: '3.14', 5: '5'}\n * >>> filterDicts([1, 2, 3, 'abc', {}, []])\n * {a: 'a', 3.14: '3.14', 5: '5'}\n */\nconst filterDicts = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filter given list of any python values entirely for list\n * >>> filterLists(['a', 3.14, 5])\n * [3.14, 5]\n * >>> filterLists([1, 2, 3, 'abc', {}, []])\n * [3.14, 5]\n */\nconst filterLists = (values) => {\n  return values.filter(value => Array.isArray(value));\n};\n\n"}
{"task_id": "JavaScript/23", "prompt": "/* return key length of hold string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* return key length of hold string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  let length = 0;\n  for (let i = 0; i < string.length; i++) {\n    length += string.charCodeAt(i).length;\n  }\n  return length;\n};\n\n/**\n * Converts a Latin-1 string to a UTF-8 string.\n */\nconst latin1ToUtf8 = (string) => {\n  let utf16string = '';\n  for (let n = 0; n < string.length; n++) {\n    const c = string.charCodeAt(n);\n    if (c < 128) {\n      utf16string += String.fromCharCode(c);\n    } else {\n      const high = c >> 12 - 1 < 0? c : c >> 12 - 1;\n      const low = c & 63 < 128? c : c & 63 | 128;\n      utf16string += String.fromCharCode(((high >> 10) & 63) | low | 128);\n    }\n  }\n  return utf16string;\n};\n\n/**\n * Converts a UTF-8 string to a Latin-1 string.\n */\nconst utf8ToLatin1 = (string) => {\n  let latin1string = '';\n  for (let n = 0; n < string.length; n++) {\n    const c = string.charCodeAt(n);\n    if (c < 128) {\n      latin1string += String.fromCharCode(c);\n    } else {\n      const high = c >> 12 - 1 < 0? c : c >> 12 - 1;\n      const low = c & 63 < 128? c : c & 63 | 128;\n      latin1string += String.fromCharCode(((high >> 18) & 63) | low | 128);\n      latin1string += String.fromCharCode(((high >> 12) & 63) | low | 128);\n      latin1string += String.fromCharCode(((high >> 6) & 63) | low | 128);\n      latin1string += String.fromCharCode((high & 63) | 128);\n    }\n  }\n  return latin1string;\n};\n\n/**\n * Calculates the HMAC-SHA256 hash of a string.\n */\nconst hmacSha256 = (key, string) => {\n  const hmac = crypto.createHmac('sha256', key);\n  hmac.update(string);\n  return hmac.digest('hex');\n};\n\n/**\n * Calculates the HMAC-SHA512 hash of a string.\n */\nconst hmacSha512 = (key, string) => {\n  const hmac = crypto.createHmac('sha512', key);\n  hmac.update(string);\n  return hmac.digest('hex');\n};\n\n/**\n * Calculates the HMAC-SHA256 hash of a string.\n */\nconst hmacSha256WithRSA = (key, string) => {\n  const hmac = crypto.createHmac('sha256', key);\n  hmac.update(string);\n  return hmac.digest('hex');\n};\n\n/**\n * Calculates the HMAC-SHA512 hash of a string.\n */\nconst hmacSha512WithRSA = (key, string) => {\n  const hmac = crypto.createHmac('sha512', key);\n  hmac.update(string);\n  return hmac.digest('hex');\n};\n\n/**\n * Calculates the HMAC-SHA256 hash of a string.\n */\nconst hmacSha256WithRSA = (key, string) => {\n  const hmac = crypto.createHmac('sha256', key);\n  hmac.update(string);\n  return hmac.digest('hex');\n};\n\n/**\n * Calculates the HMAC-SHA512 hash of a string.\n */\nconst hmacSha512WithRSA = (key, string) => {\n  const hmac = crypto.createHmac('sha512', key);\n  hmac.update(string);\n  return hmac.digest('hex');\n};\n\n/**\n * Calculates the HMAC-SHA256 hash of a string.\n */\nconst hmacSha256WithRSA = (key, string) => {\n  const hmac = crypto.createHmac('sha256', key);\n  hmac.update(string);\n  return hmac.digest('hex');\n};\n\n/**\n * Calculates the HMAC-SHA512 hash of a string.\n */\nconst hmacSha512WithRSA = (key, string) => {\n  const hmac = crypto.createHmac('sha512', key);\n  hmac.update(string);\n  return hmac.digest('hex');\n};\n\n/**\n * Calculates the HMAC-SHA256 hash of a string.\n */\nconst hmacSha256WithRSA = (key, string) => {\n  const hmac = crypto.createHmac('sha256', key);\n  hmac.update(string);\n  return hmac.digest('hex');\n};\n\n/**\n * Calculates the HMAC-SHA512 hash of a string.\n */\nconst hmacSha512WithRSA = (key, string) => {\n  const hmac = crypto.createHmac('sha512', key);\n  hmac.update(string);\n  return hmac.digest('hex');\n};\n\n/**\n * Calculates the HMAC-SHA256 hash of a string.\n */\nconst hmacSha256WithRSA = (key, string) => {\n  const hmac = crypto.createHmac('sha256', key);\n  hmac.update(string);\n  return hmac.digest('hex');\n};\n\n/**\n * Calculates the HMAC-SHA512 hash of a string.\n */\nconst hmacSha512WithRSA = (key, string) => {\n  const hmac = crypto.createHmac('sha512', key);\n  hmac.update(string);\n  return hmac.digest('hex');\n};\n\n/**\n * Calculates the HMAC-SHA256 hash of a string.\n */\nconst hmacSha256WithRSA = (key, string) => {\n  const hmac = crypto.createHmac('sha256', key);\n  hmac.update(string);\n  return hmac.digest('hex');\n};\n\n/**\n * Calculates the HMAC-SHA512 hash of a string.\n */\nconst hmacSha512WithRSA = (key, string) => {\n  const hmac = crypto.createHmac('sha512', key);\n  hmac.update(string);\n  return hmac.digest('hex');\n};\n\n/**\n * Calculates the HMAC-SHA256 hash of a string.\n */\nconst hmacSha256WithRSA = (key, string) => {\n  const hmac = crypto.createHmac('sha256', key);\n  hmac.update(string);\n  return hmac.digest('hex');\n};\n\n/**\n * Calculates the HMAC-SHA512 hash of a string.\n */\nconst hmacSha512WithRSA = (key, string) => {\n  const hmac = crypto.createHmac('sha512', key);\n  hmac.update(string);\n  return hmac.digest('hex');\n};\n\n/**\n * Calculates the HMAC-SHA256 hash of a string.\n */\nconst hmacSha256WithRSA = (key, string) => {\n  const hmac = crypto.createHmac('sha256', key);\n  hmac.update(string);\n  return hmac.digest('hex');\n};\n\n/**\n * Calculates the HMAC-SHA512 hash of a string.\n */\nconst hmacSha512WithRSA = (key, string) => {\n  const hmac = crypto.createHmac('sha512', key);\n  hmac.update(string);\n  return hmac.digest('hex');\n};\n\n/**\n * Calculates the HMAC-SHA256 hash of a string.\n */\nconst hmacSha256WithRSA = (key, string) => {\n  const hmac = "}
{"task_id": "JavaScript/24", "prompt": "/* For a establish number n, discover the large issue that divide n evenly, little than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* For a establish number n, discover the large issue that divide n evenly, little than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let divisor = 1;\n  while (n % divisor === 0) {\n    divisor *= 10;\n  }\n  return divisor;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n^2) in the worst case\n */\nconst primeFactor = (n) => {\n  let factor = 1;\n  while (n % factor === 0) {\n    factor *= 10;\n  }\n  return factor;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n^2) in the worst case\n */\nconst primeFactors = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor === 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n^2) in the worst case\n */\nconst primeFactorsFast = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor === 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n^2) in the worst case\n */\nconst primeFactorsSlow = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor === 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n^2) in the worst case\n */\nconst primeFactorsSlowFast = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor === 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n^2) in the worst case\n */\nconst primeFactorsSlowFast2 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor === 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n^2) in the worst case\n */\nconst primeFactorsSlowFast3 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor === 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n^2) in the worst case\n */\nconst primeFactorsSlowFast4 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor === 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n^2) in the worst case\n */\nconst primeFactorsSlowFast5 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor === 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n^2) in the worst case\n */\nconst primeFactorsSlowFast6 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor === 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n^2) in the worst case\n */\nconst primeFactorsSlowFast7 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor === 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n^2) in the worst case\n */\nconst primeFactorsSlowFast8 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor === 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n^2) in the worst case\n */\nconst primeFactorsSlowFast9 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor === 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n^2) in the worst case\n */\nconst primeFactorsSlowFast10 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor === 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n^2) in the worst case\n */\nconst primeFactorsSlowFast11 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor === 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n^2) in the worst case\n */\nconst primeFactorsSlowFast12 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor === 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n^2) in the worst case\n */\nconst primeFactorsSlowFast13 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor === 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n^2) in the worst case\n */\nconst primeFactorsSlowFast14 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor === 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n^2) in the worst case\n */\nconst primeFactorsSlowFast15 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor === 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n^2) in the worst case\n */\nconst primeFactorsSlowFast16 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor === 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: "}
{"task_id": "JavaScript/25", "prompt": "/* return key list of prime factor of pass integer in the holy order from little to largest. \n   Each of the factor should be list numeral of times equate to how many times it appeares in factorization. \n   remark number should be adequate to the intersection of all factor\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* return key list of prime factor of pass integer in the holy order from little to largest. \n   Each of the factor should be list numeral of times equate to how many times it appeares in factorization. \n   remark number should be adequate to the intersection of all factor\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark = 0;\n  let factor = 1;\n  let factors = [];\n  let remark"}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integer, remove all element that occur more than once. \n   observe order of elements exit the like as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* From a list of integer, remove all element that occur more than once. \n   observe order of elements exit the like as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const seen = new Set();\n  return numbers.filter(number => {\n    if (seen.has(number)) {\n      return false;\n    }\n    seen.add(number);\n    return true;\n  });\n};\n\n/* From a list of integer, remove all element that occur more than once. \n   observe order of elements exit the like as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 2, 3, 4]\n  */\nconst removeDuplicates2 = (numbers) => {\n  const seen = new Set();\n  return numbers.filter(number => {\n    if (seen.has(number)) {\n      return false;\n    }\n    seen.add(number);\n    return true;\n  }).filter(number =>!seen.has(number));\n};\n\n/* From a list of integer, remove all element that occur more than once. \n   observe order of elements exit the like as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 2, 3, 4]\n  */\nconst removeDuplicates3 = (numbers) => {\n  const seen = new Set();\n  return numbers.filter(number => {\n    if (seen.has(number)) {\n      return false;\n    }\n    seen.add(number);\n    return true;\n  }).filter(number =>!seen.has(number)).filter(number =>!seen.has(number));\n};\n\n/* From a list of integer, remove all element that occur more than once. \n   observe order of elements exit the like as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 2, 3, 4]\n  */\nconst removeDuplicates4 = (numbers) => {\n  const seen = new Set();\n  return numbers.filter(number => {\n    if (seen.has(number)) {\n      return false;\n    }\n    seen.add(number);\n    return true;\n  }).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number));\n};\n\n/* From a list of integer, remove all element that occur more than once. \n   observe order of elements exit the like as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 2, 3, 4]\n  */\nconst removeDuplicates5 = (numbers) => {\n  const seen = new Set();\n  return numbers.filter(number => {\n    if (seen.has(number)) {\n      return false;\n    }\n    seen.add(number);\n    return true;\n  }).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number));\n};\n\n/* From a list of integer, remove all element that occur more than once. \n   observe order of elements exit the like as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 2, 3, 4]\n  */\nconst removeDuplicates6 = (numbers) => {\n  const seen = new Set();\n  return numbers.filter(number => {\n    if (seen.has(number)) {\n      return false;\n    }\n    seen.add(number);\n    return true;\n  }).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number));\n};\n\n/* From a list of integer, remove all element that occur more than once. \n   observe order of elements exit the like as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 2, 3, 4]\n  */\nconst removeDuplicates7 = (numbers) => {\n  const seen = new Set();\n  return numbers.filter(number => {\n    if (seen.has(number)) {\n      return false;\n    }\n    seen.add(number);\n    return true;\n  }).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has(number)).filter(number =>!seen.has("}
{"task_id": "JavaScript/27", "prompt": "/* For a establish string, flick small letter character to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* For a establish string, flick small letter character to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string\n   .toLowerCase()\n   .replace(/([a-z])([A-Z])/g, (match, m1, m2) => m1 + m2.toUpperCase())\n   .replace(/([A-Z])([a-z])/g, (match, m1, m2) => m1 + m2.toLowerCase());\n};\n\n/**\n * Converts a string to all lowercase.\n *\n * >>> lowerCase('Hello')\n  'hello'\n  */\nconst lowerCase = (string) => {\n  return string\n   .toLowerCase()\n   .replace(/([a-z])([A-Z])/g, (match, m1, m2) => m1 + m2.toUpperCase());\n};\n\n/**\n * Converts a string to all uppercase.\n *\n * >>> upperCase('Hello')\n  'HELLO'\n  */\nconst upperCase = (string) => {\n  return string\n   .toLowerCase()\n   .replace(/([A-Z])([a-z])/g, (match, m1, m2) => m1 + m2.toLowerCase());\n};\n\n/**\n * Converts a string to all uppercase.\n *\n * >>> upperCase('Hello')\n  'HELLO'\n  */\nconst capitalize = (string) => {\n  return string\n   .toLowerCase()\n   .replace(/([A-Z])([a-z])/g, (match, m1, m2) => m1 + m2.toUpperCase());\n};\n\n/**\n * Converts a string to all lowercase.\n *\n * >>> capitalize('Hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string\n   .toLowerCase()\n   .replace(/([a-z])([A-Z])/g, (match, m1, m2) => m1 + m2.toUpperCase());\n};\n\n/**\n * Converts a string to all uppercase.\n *\n * >>> capitalize('Hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string\n   .toLowerCase()\n   .replace(/([A-Z])([a-z])/g, (match, m1, m2) => m1 + m2.toLowerCase());\n};\n\n/**\n * Converts a string to all lowercase.\n *\n * >>> capitalize('Hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string\n   .toLowerCase()\n   .replace(/([a-z])([A-Z])/g, (match, m1, m2) => m1 + m2.toUpperCase());\n};\n\n/**\n * Converts a string to all uppercase.\n *\n * >>> capitalize('Hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string\n   .toLowerCase()\n   .replace(/([A-Z])([a-z])/g, (match, m1, m2) => m1 + m2.toLowerCase());\n};\n\n/**\n * Converts a string to all lowercase.\n *\n * >>> capitalize('Hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string\n   .toLowerCase()\n   .replace(/([a-z])([A-Z])/g, (match, m1, m2) => m1 + m2.toUpperCase());\n};\n\n/**\n * Converts a string to all lowercase.\n *\n * >>> capitalize('Hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string\n   .toLowerCase()\n   .replace(/([A-Z])([a-z])/g, (match, m1, m2) => m1 + m2.toLowerCase());\n};\n\n/**\n * Converts a string to all lowercase.\n *\n * >>> capitalize('Hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string\n   .toLowerCase()\n   .replace(/([A-Z])([a-z])/g, (match, m1, m2) => m1 + m2.toUpperCase());\n};\n\n/**\n * Converts a string to all lowercase.\n *\n * >>> capitalize('Hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string\n   .toLowerCase()\n   .replace(/([a-z])([A-Z])/g, (match, m1, m2) => m1 + m2.toLowerCase());\n};\n\n/**\n * Converts a string to all lowercase.\n *\n * >>> capitalize('Hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string\n   .toLowerCase()\n   .replace(/([A-Z])([a-z])/g, (match, m1, m2) => m1 + m2.toUpperCase());\n};\n\n/**\n * Converts a string to all lowercase.\n *\n * >>> capitalize('Hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string\n   .toLowerCase()\n   .replace(/([A-Z])([a-z])/g, (match, m1, m2) => m1 + m2.toLowerCase());\n};\n\n/**\n * Converts a string to all lowercase.\n *\n * >>> capitalize('Hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string\n   .toLowerCase()\n   .replace(/([A-Z])([a-z])/g, (match, m1, m2) => m1 + m2.toUpperCase());\n};\n\n/**\n * Converts a string to all lowercase.\n *\n * >>> capitalize('Hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string\n   .toLowerCase()\n   .replace(/([A-Z])([a-z])/g, (match, m1, m2) => m1 + m2.toLowerCase());\n};\n\n/**\n * Converts a string to all lowercase.\n *\n * >>> capitalize('Hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string\n   .toLowerCase()\n   .replace(/([A-Z])([a-z])/g, (match, m1, m2) => m1 + m2.toUpperCase());\n};\n\n/**\n * Converts a string to all lowercase.\n *\n * >>> capitalize('Hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string\n   .toLowerCase()\n   .replace(/([A-Z])([a-z])/g, (match, m1, m2) => m1 + m2.toLowerCase());\n};\n\n/**\n * Converts a string to all lowercase.\n *\n * >>> capitalize('Hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string\n   .toLowerCase()\n   .replace(/([A-Z])([a-z])/g, (match, m1, m2) => m1 + m2.toUpperCase());\n};\n\n/**\n * Converts a string to all lowercase.\n *\n * >>> capitalize('Hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string\n   .toLowerCase()\n   .replace(/([A-Z])([a-z])/g, (match, m1, m2) => m1 + m2.toLowerCase());\n};\n\n/**\n * Converts a string to all lowercase.\n *\n * >>> capitalize('Hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string\n   .toLowerCase()\n   .replace(/([A-Z])([a-z])/g, (match, m1, m2) => m1 + m2.toUpperCase());\n};\n\n/**\n * Converts a string to all lowercase.\n *\n * >>> capitalize('Hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string\n   .toLowerCase()\n   .replace(/([A-Z])([a-z])/g, (match, m1, m2) => m1 + m2.toLowerCase());\n};\n\n/**\n * Converts a string to all lowercase.\n *\n * >>> capitalize('Hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string\n   .toLowerCase()\n   .replace(/([A-Z])([a-z])/g, (match, m1, m2) => m1 + m2.toUpperCase());\n};\n\n/**\n * Converts a string to all lowercase.\n *\n * >>> capitalize('Hello')\n  'Hello'\n  */\nconst capitalize = (string) => {\n  return string\n   .toLowerCase()\n   .replace(/([A-Z])([a-z])/g, (match, m1, m2) => m"}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single drawstring\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Concatenate list of strings into a single drawstring\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/* Convert string to number\n  >>> number('abc')\n  123\n  >>> number('123.45')\n  123.45\n  >>> number('123.45.67')\n  123.4567\n  >>> number('123.4567')\n  123.4567\n  >>> number('123.4567.89')\n  123.456789\n  >>> number('123.4567.89')\n  123.456789\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567.89.1')\n  123.45678901\n  >>> number('123.4567."}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input signal list of strings only for one that get down with a give prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* Filter an input signal list of strings only for one that get down with a give prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix));\n};\n\n/**\n * Filter an input signal list of strings only for one that get down with a give suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array', 'cde']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  return strings.filter(string => string.endsWith(suffix));\n};\n\n/**\n * Filter an input signal list of strings only for one that get down with a give suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  return strings.filter(string => string.startsWith(suffix));\n};\n\n/**\n * Filter an input signal list of strings only for one that get down with a give suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(string => string.endsWith(prefix));\n};\n\n/**\n * Filter an input signal list of strings only for one that get down with a give suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  return strings.filter(string => string.startsWith(suffix));\n};\n\n/**\n * Filter an input signal list of strings only for one that get down with a give suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(string => string.endsWith(prefix));\n};\n\n/**\n * Filter an input signal list of strings only for one that get down with a give suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  return strings.filter(string => string.startsWith(suffix));\n};\n\n/**\n * Filter an input signal list of strings only for one that get down with a give suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(string => string.endsWith(prefix));\n};\n\n/**\n * Filter an input signal list of strings only for one that get down with a give suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  return strings.filter(string => string.startsWith(suffix));\n};\n\n/**\n * Filter an input signal list of strings only for one that get down with a give suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(string => string.endsWith(prefix));\n};\n\n/**\n * Filter an input signal list of strings only for one that get down with a give suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  return strings.filter(string => string.startsWith(suffix));\n};\n\n/**\n * Filter an input signal list of strings only for one that get down with a give suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(string => string.endsWith(prefix));\n};\n\n/**\n * Filter an input signal list of strings only for one that get down with a give suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  return strings.filter(string => string.startsWith(suffix));\n};\n\n/**\n * Filter an input signal list of strings only for one that get down with a give suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(string => string.endsWith(prefix));\n};\n\n/**\n * Filter an input signal list of strings only for one that get down with a give suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  return strings.filter(string => string.startsWith(suffix));\n};\n\n/**\n * Filter an input signal list of strings only for one that get down with a give suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(string => string.endsWith(prefix));\n};\n\n/**\n * Filter an input signal list of strings only for one that get down with a give suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  return strings.filter(string => string.startsWith(suffix));\n};\n\n/**\n * Filter an input signal list of strings only for one that get down with a give suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(string => string.endsWith(prefix));\n};\n\n/**\n * Filter an input signal list of strings only for one that get down with a give suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  return strings.filter(string => string.startsWith(suffix));\n};\n\n/**\n * Filter an input signal list of strings only for one that get down with a give suffix."}
{"task_id": "JavaScript/30", "prompt": "/*Return only positivist numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Return only positivist numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] >= 0) {\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return only negativity numbers in the list.\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 3 === 0) {\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible3 = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 3 === 0) {\n      result.push(l[i])\n    }\n  }\n  return result.filter(n => n % 3 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible3([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible3([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible3 = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 3 === 0) {\n      result.push(l[i])\n    }\n  }\n  return result.filter(n => n % 3 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible3([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible3([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible3 = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 3 === 0) {\n      result.push(l[i])\n    }\n  }\n  return result.filter(n => n % 3 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible3([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible3([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible3 = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 3 === 0) {\n      result.push(l[i])\n    }\n  }\n  return result.filter(n => n % 3 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible3([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible3([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible3 = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 3 === 0) {\n      result.push(l[i])\n    }\n  }\n  return result.filter(n => n % 3 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible3([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible3([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible3 = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 3 === 0) {\n      result.push(l[i])\n    }\n  }\n  return result.filter(n => n % 3 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible3([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible3([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible3 = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 3 === 0) {\n      result.push(l[i])\n    }\n  }\n  return result.filter(n => n % 3 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible3([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible3([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible3 = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 3 === 0) {\n      result.push(l[i])\n    }\n  }\n  return result.filter(n => n % 3 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible3([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible3([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible3 = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 3 === 0) {\n      result.push(l[i])\n    }\n  }\n  return result.filter(n => n % 3 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible3([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible3([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible3 = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 3 === 0) {\n      result.push(l[i])\n    }\n  }\n  return result.filter(n => n % 3 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible3([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible3([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible3 = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 3 === 0) {\n      result.push(l[i])\n    }\n  }\n  return result.filter(n => n % 3 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible3([-1, 2, -4, 5, 6])\n  ["}
{"task_id": "JavaScript/31", "prompt": "/*Return true if a impart number be choice, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Return true if a impart number be choice, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < Math.sqrt(n); i++) if (n % i === 0) return false;\n  return true;\n};\n\n/**\n * Given a number, return its prime factors.\n * If the number is divisible by 2, return [2,1].\n * If the number is divisible by 3, return [3,1].\n * If the number is divisible by 5, return [5,1].\n * If the number is divisible by 6, return [6,1].\n * If the number is divisible by 11, return [11,1].\n * If the number is divisible by 13, return [13,1].\n * If the number is divisible by 17, return [17,1].\n * If the number is divisible by 19, return [19,1].\n * If the number is divisible by 23, return [23,1].\n * If the number is divisible by 29, return [29,1].\n * If the number is divisible by 31, return [31,1].\n * If the number is divisible by 37, return [37,1].\n * If the number is divisible by 41, return [41,1].\n * If the number is divisible by 47, return [47,1].\n * If the number is divisible by 53, return [53,1].\n * If the number is divisible by 59, return [59,1].\n * If the number is divisible by 61, return [61,1].\n * If the number is divisible by 67, return [67,1].\n * If the number is divisible by 71, return [71,1].\n * If the number is divisible by 73, return [73,1].\n * If the number is divisible by 79, return [79,1].\n * If the number is divisible by 89, return [89,1].\n * If the number is divisible by 97, return [97,1].\n * If the number is divisible by 101, return [101,1].\n * If the number is divisible by 103, return [103,1].\n * If the number is divisible by 107, return [107,1].\n * If the number is divisible by 113, return [113,1].\n * If the number is divisible by 127, return [127,1].\n * If the number is divisible by 131, return [131,1].\n * If the number is divisible by 137, return [137,1].\n * If the number is divisible by 141, return [141,1].\n * If the number is divisible by 147, return [147,1].\n * If the number is divisible by 151, return [151,1].\n * If the number is divisible by 157, return [157,1].\n * If the number is divisible by 161, return [161,1].\n * If the number is divisible by 167, return [167,1].\n * If the number is divisible by 173, return [173,1].\n * If the number is divisible by 179, return [179,1].\n * If the number is divisible by 183, return [183,1].\n * If the number is divisible by 191, return [191,1].\n * If the number is divisible by 197, return [197,1].\n * If the number is divisible by 201, return [201,1].\n * If the number is divisible by 207, return [207,1].\n * If the number is divisible by 213, return [213,1].\n * If the number is divisible by 217, return [217,1].\n * If the number is divisible by 223, return [223,1].\n * If the number is divisible by 229, return [229,1].\n * If the number is divisible by 233, return [233,1].\n * If the number is divisible by 239, return [239,1].\n * If the number is divisible by 243, return [243,1].\n * If the number is divisible by 249, return [249,1].\n * If the number is divisible by 253, return [253,1].\n * If the number is divisible by 259, return [259,1].\n * If the number is divisible by 263, return [263,1].\n * If the number is divisible by 269, return [269,1].\n * If the number is divisible by 273, return [273,1].\n * If the number is divisible by 279, return [279,1].\n * If the number is divisible by 283, return [283,1].\n * If the number is divisible by 289, return [289,1].\n * If the number is divisible by 293, return [293,1].\n * If the number is divisible by 299, return [299,1].\n * If the number is divisible by 303, return [300,1].\n * If the number is divisible by 309, return [309,1].\n * If the number is divisible by 313, return [313,1].\n * If the number is divisible by 317, return [317,1].\n * If the number is divisible by 331, return [331,1].\n * If the number is divisible by 337, return [337,1].\n * If the number is divisible by 341, return [341,1].\n * If the number is divisible by 347, return [347,1].\n * If the number is divisible by 353, return [353,1].\n * If the number is divisible by 359, return [359,1].\n * If the number is divisible by 363, return [363,1].\n * If the number is divisible by 369, return [369,1].\n * If the number is divisible by 373, return [373,1].\n * If the number is divisible by 379, return [379,1].\n * If the number is divisible by 383, return [383,1].\n * If the number is divisible by 389, return [389,1].\n * If the number is divisible by 393, return [393,1].\n * If the number is divisible by 399, return [399,1].\n * If the number is divisible by 403, return [403,1].\n * If the number is divisible by 409, return [409,1].\n * If the number is divisible by 413, return [413,1].\n * If the number is divisible by 419, return [419,1].\n * If the number is divisible by 423, return [423,1].\n * If the number is divisible by 429, return [429,1].\n * If the number is divisible by 433, return [433,1].\n * If the number is divisible by 439, return [439,1].\n * If the number is divisible by 443, return [443,1].\n * If the number is divisible by 449, return [449,1].\n * If the number is divisible by 457, return [457,1].\n * If the number is divisible by 463, return [463,1].\n * If the number is divisible by 469, return [469,1].\n * If the number is divisible by 473, return [473,1].\n * If the number is divisible by 479, return [479,1].\n * If the number is divisible by 491, return [491,1].\n * If the number is divisible by 497, return [497,1].\n * If the number is divisible by 503, return [503,1].\n * If the number is divisible by 509, return [509,1].\n * If the number is divisible by 521, return [521,1].\n * If the number is divisible by 523, return [523,1].\n * If the number is divisible by 529, return [529,1].\n * If the number is divisible by 533, return [533,1].\n * If the number is divisible by 539, return [539"}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficient xs at detail x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficient of a polynomial. \n   findZero witness x such that poly(x) = 0. \n   findZero return merely merely zero point, even if there are many. \n   furthermore, findZero only accept list xs having even number of coefficients \n   and bombastic non zero coefficient as it guarantee \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  Evaluates polynomial with coefficient xs at detail x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficient of a polynomial. \n   findZero witness x such that poly(x) = 0. \n   findZero return merely merely zero point, even if there are many. \n   furthermore, findZero only accept list xs having even number of coefficients \n   and bombastic non zero coefficient as it guarantee \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  if (xs.length % 2!== 0) throw new Error('findZero only accept list xs having even number of coefficients and bombastic non zero coefficient')\n  const zero = xs[0]\n  const result = xs.reduce((prev, item, index) => {\n    if (item === 0) return prev\n    return prev + item * Math.pow(x, index)\n  }, 0)\n  return Math.sign(zero) === 0? result : zero\n}\n\n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// \n// "}
{"task_id": "JavaScript/33", "prompt": "/*This affair takes a list l and return a list l' such that \n   l' is identical to l in the indicies that constitute not divisible by three, while its values at the indicies that are divisible by three are adequate \n   to the values of the corresponding indicies of l, but screen.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*This affair takes a list l and return a list l' such that \n   l' is identical to l in the indicies that constitute not divisible by three, while its values at the indicies that are divisible by three are adequate \n   to the values of the corresponding indicies of l, but screen.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const l2 = l.slice(0);\n  l2.sort((a, b) => a % 3 === b % 3);\n  return l2;\n};\n\n/*\n  Given a list l and a number k, return a new list l such that l' is a list that has k elements. \n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 3)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 4)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 5)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 6)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 7)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 8)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 9)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 10)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 11)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 12)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 13)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 14)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 15)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 16)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 17)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 18)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 19)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 20)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 21)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 22)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 23)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 24)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 25)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 26)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 27)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 28)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 29)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 30)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 31)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 32)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 33)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 34)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 35)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 36)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 37)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 38)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 39)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 40)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 41)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 42)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 43)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 44)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 45)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 46)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 47)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 48)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 49)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 50)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 51)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 52)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 53)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 54)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 55)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 56)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 57)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 58)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 59)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 60)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 61)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 62)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sortThirdWithK([5, 6, 3, 4, 8, 9, 2], 63)\n  [2, 6, 3, 4, 8, 9, 5]\n  >>> sort"}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted unique element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Return sorted unique element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let seen = {}\n  return l.filter((item, index) => {\n    if (seen.hasOwnProperty(item)) {\n      return false\n    }\n    seen[item] = true\n    return true\n  })\n}\n\n/*Return sorted unique element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (l, key) => {\n  let seen = {}\n  return l.filter((item, index) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (l, key) => {\n  let seen = {}\n  return l.filter((item, index) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (l, key) => {\n  let seen = {}\n  return l.filter((item, index) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (l, key) => {\n  let seen = {}\n  return l.filter((item, index) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (l, key) => {\n  let seen = {}\n  return l.filter((item, index) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (l, key) => {\n  let seen = {}\n  return l.filter((item, index) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (l, key) => {\n  let seen = {}\n  return l.filter((item, index) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (l, key) => {\n  let seen = {}\n  return l.filter((item, index) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (l, key) => {\n  let seen = {}\n  return l.filter((item, index) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (l, key) => {\n  let seen = {}\n  return l.filter((item, index) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (l, key) => {\n  let seen = {}\n  return l.filter((item, index) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (l, key) => {\n  let seen = {}\n  return l.filter((item, index) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (l, key) => {\n  let seen = {}\n  return l.filter((item, index) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (l, key) => {\n  let seen = {}\n  return l.filter((item, index) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (l, key) => {\n  let seen = {}\n  return l.filter((item, index) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (l, key) => {\n  let seen = {}\n  return l.filter((item, index) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (l, key) => {\n  let seen = {}\n  return l.filter((item, index) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (l, key) => {\n  let seen = {}\n  return l.filter((item, index) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (l, key) => {\n  let seen = {}\n  return l.filter((item, index) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (l, key) => {\n  let seen = {}\n  return l.filter((item, index) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n"}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum component in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Return maximum component in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*Return minimum component in the list.\n  >>> minElement([1, 2, 3])\n  1\n  >>> minElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -5\n  */\nconst minElement = (l) => {\n  let min = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < min) {\n      min = l[i];\n    }\n  }\n  return min;\n};\n\n/*Return sum of all elements in the list.\n  >>> sumElement([1, 2, 3])\n  6\n  >>> sumElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  12\n  */\nconst sumElement = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return average of all elements in the list.\n  >>> averageElement([1, 2, 3])\n  1.5\n  >>> averageElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  2.8\n  */\nconst averageElement = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    count++;\n  }\n  return sum / count;\n};\n\n/*Return median of all elements in the list.\n  >>> medianElement([1, 2, 3])\n  3\n  >>> medianElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  5\n  */\nconst medianElement = (l) => {\n  let sum = 0;\n  let count = 0;\n  let mid = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    count++;\n    if (count % 2 === 0) {\n      mid = count / 2;\n    }\n  }\n  return l[mid];\n};\n\n/*Return standard deviation of all elements in the list.\n  >>> stdElement([1, 2, 3])\n  1.4142135623730951\n  >>> stdElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  1.4142135623730951\n  */\nconst stdElement = (l) => {\n  let sum = 0;\n  let count = 0;\n  let mid = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    count++;\n    if (count % 2 === 0) {\n      mid = count / 2;\n    }\n  }\n  return Math.sqrt(sum / count - Math.pow(sum / count - Math.pow(mid, 2), 2));\n};\n\n/*Return variance of all elements in the list.\n  >>> varianceElement([1, 2, 3])\n  1.4142135623730951\n  >>> varianceElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  1.4142135623730951\n  */\nconst varianceElement = (l) => {\n  let sum = 0;\n  let count = 0;\n  let mid = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    count++;\n    if (count % 2 === 0) {\n      mid = count / 2;\n    }\n  }\n  return Math.pow(sum / count - Math.pow(mid, 2), 2);\n};\n\n/*Return mode of all elements in the list.\n  >>> modeElement([1, 2, 3])\n  1\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElement = (l) => {\n  let max = 0;\n  let min = 0;\n  let count = 0;\n  let mid = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n    if (l[i] < min) {\n      min = l[i];\n    }\n    count++;\n    if (count % 2 === 0) {\n      mid = count / 2;\n    }\n  }\n  return l[mid];\n};\n\n/*Return mode of all elements in the list.\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElement = (l) => {\n  let max = 0;\n  let min = 0;\n  let count = 0;\n  let mid = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n    if (l[i] < min) {\n      min = l[i];\n    }\n    count++;\n    if (count % 2 === 0) {\n      mid = count / 2;\n    }\n  }\n  return l[mid];\n};\n\n/*Return mode of all elements in the list.\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElement = (l) => {\n  let max = 0;\n  let min = 0;\n  let count = 0;\n  let mid = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n    if (l[i] < min) {\n      min = l[i];\n    }\n    count++;\n    if (count % 2 === 0) {\n      mid = count / 2;\n    }\n  }\n  return l[mid];\n};\n\n/*Return mode of all elements in the list.\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElement = (l) => {\n  let max = 0;\n  let min = 0;\n  let count = 0;\n  let mid = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n    if (l[i] < min) {\n      min = l[i];\n    }\n    count++;\n    if (count % 2 === 0) {\n      mid = count / 2;\n    }\n  }\n  return l[mid];\n};\n\n/*Return mode of all elements in the list.\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElement = (l) => {\n  let max = 0;\n  let min = 0;\n  let count = 0;\n  let mid = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n    if (l[i] < min) {\n      min = l[i];\n    }\n    count++;\n    if (count % 2 === 0) {\n      mid = count / 2;\n    }\n  }\n  return l[mid];\n};\n\n/*Return mode of all elements in the list.\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElement = (l) => {\n  let max = 0;\n  let min = 0;\n  let count = 0;\n  let mid = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n    if (l[i] < min) {\n      min = l[i];\n    }\n    count++;\n    if (count % 2 === 0) {\n      mid = count / 2;\n    }\n  }\n  return l[mid];\n};\n\n/*Return mode of all elements in the list.\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElement = (l) => {\n  let max = 0;\n  let min = 0;\n  let count = 0;\n  let mid = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n    if (l[i] < min) {\n      min = l[i];\n    }\n    count++;\n    if (count % 2 === 0) {\n      mid = count / 2;\n    }\n  }\n  return l[mid];\n};\n\n/*Return mode of all elements in the list.\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElement = (l) => {\n  let max = 0;"}
{"task_id": "JavaScript/36", "prompt": "/*Return the number of time the finger 7 appear in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Return the number of time the finger 7 appear in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let last = 0;\n  let lastFizz = 0;\n  let lastBuzz = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 13 === 0) {\n      count++;\n    } else if (i % 11 === 0) {\n      lastFizz = i;\n      lastBuzz = i;\n    } else if (i % 5 === 0) {\n      lastFizz = i;\n      lastBuzz = i;\n    }\n  }\n  return count;\n};\n\n/*\n  Return the number of time the finger 7 appear in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let last = 0;\n  let lastFizz = 0;\n  let lastBuzz = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 13 === 0) {\n      count++;\n    } else if (i % 11 === 0) {\n      lastFizz = i;\n    } else if (i % 5 === 0) {\n      lastFizz = i;\n    }\n  }\n  return count;\n};\n\n/*\n  Return the number of time the finger 7 appear in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let last = 0;\n  let lastFizz = 0;\n  let lastBuzz = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 13 === 0) {\n      count++;\n    } else if (i % 11 === 0) {\n      lastFizz = i;\n    } else if (i % 5 === 0) {\n      lastFizz = i;\n    }\n  }\n  return count;\n};\n\n/*\n  Return the number of time the finger 7 appear in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let last = 0;\n  let lastFizz = 0;\n  let lastBuzz = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 13 === 0) {\n      count++;\n    } else if (i % 11 === 0) {\n      lastFizz = i;\n    } else if (i % 5 === 0) {\n      lastFizz = i;\n    }\n  }\n  return count;\n};\n\n/*\n  Return the number of time the finger 7 appear in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let last = 0;\n  let lastFizz = 0;\n  let lastBuzz = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 13 === 0) {\n      count++;\n    } else if (i % 11 === 0) {\n      lastFizz = i;\n    } else if (i % 5 === 0) {\n      lastFizz = i;\n    }\n  }\n  return count;\n};\n\n/*\n  Return the number of time the finger 7 appear in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let last = 0;\n  let lastFizz = 0;\n  let lastBuzz = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 13 === 0) {\n      count++;\n    } else if (i % 11 === 0) {\n      lastFizz = i;\n    } else if (i % 5 === 0) {\n      lastFizz = i;\n    }\n  }\n  return count;\n};\n\n/*\n  Return the number of time the finger 7 appear in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let last = 0;\n  let lastFizz = 0;\n  let lastBuzz = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 13 === 0) {\n      count++;\n    } else if (i % 11 === 0) {\n      lastFizz = i;\n    } else if (i % 5 === 0) {\n      lastFizz = i;\n    }\n  }\n  return count;\n};\n\n/*\n  Return the number of time the finger 7 appear in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let last = 0;\n  let lastFizz = 0;\n  let lastBuzz = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 13 === 0) {\n      count++;\n    } else if (i % 11 === 0) {\n      lastFizz = i;\n    } else if (i % 5 === 0) {\n      lastFizz = i;\n    }\n  }\n  return count;\n};\n\n/*\n  Return the number of time the finger 7 appear in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let last = 0;\n  let lastFizz = 0;\n  let lastBuzz = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 13 === 0) {\n      count++;\n    } else if (i % 11 === 0) {\n      lastFizz = i;\n    } else if (i % 5 === 0) {\n      lastFizz = i;\n    }\n  }\n  return count;\n};\n\n/*\n  Return the number of time the finger 7 appear in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let last = 0;\n  let lastFizz = 0;\n  let lastBuzz = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 13 === 0) {\n      count++;\n    } else if (i % 11 === 0) {\n      lastFizz = i;\n    } else if (i % 5 === 0) {\n      lastFizz = i;\n    }\n  }\n  return count;\n};\n\n/*\n  Return the number of time the finger 7 appear in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let last = 0;\n  let lastFizz = 0;\n  let lastBuzz = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 13"}
{"task_id": "JavaScript/37", "prompt": "/*This affair takes a list l and return a list l' such that \n   l' is identical to l in the leftover indicies, while its values at the even indicies be adequate \n   to the values of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*This affair takes a list l and return a list l' such that \n   l' is identical to l in the leftover indicies, while its values at the even indicies be adequate \n   to the values of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  let evens = l.filter((item, index) => index % 2 === 0);\n  return evens.sort((a, b) => a - b);\n};\n\n/*\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 1)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 2)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 3)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 4)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 5)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 6)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 7)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 8)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 9)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 10)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 11)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 12)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 13)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 14)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 15)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 16)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 17)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 18)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 19)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 20)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 21)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 22)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 23)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 24)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 25)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 26)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 27)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 28)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 29)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 30)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 31)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 32)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 33)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 34)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 35)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 36)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 37)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 38)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 39)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 40)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 41)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 42)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 43)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 44)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 45)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 46)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 47)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 48)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 49)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 50)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 51)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 52)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 53)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 54)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 55)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 56)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 57)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 58)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 59)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 60)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 61)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 62)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 63)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 64)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 65)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 66)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 67)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 68)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 69)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 70)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 71)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 72)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 73)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 74)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 75)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 76)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 77)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 78)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 79)\n  [3, 6, 5, 4]\n  >>> sortEven([5, 6, 3, 4], 80)"}
{"task_id": "JavaScript/38", "prompt": "/*\n  reappearance encoded drawstring by cycle groups of three character. \n   * / \n const encodeCyclic = (s) = > { \n   volt-ampere groups = [ ], groups2 = [ ]; \n   for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   take as stimulation string encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  reappearance encoded drawstring by cycle groups of three character. \n   * / \n const encodeCyclic = (s) = > { \n   volt-ampere groups = [ ], groups2 = [ ]; \n   for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   take as stimulation string encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   const decoded = encodeCyclic(s);\n   const voltAmpereGroups = decoded.split('');\n   const ampereGroups = [];\n   for (let i = 0; i < voltAmpereGroups.length; i++) {\n     if (voltAmpereGroups[i].length === 3) \n       ampereGroups.push(voltAmpereGroups[i].slice(1) + voltAmpereGroups[i]);\n     else \n       ampereGroups.push(voltAmpereGroups[i]);\n   }\n   return ampereGroups.join('');\n}\n\n/*\n   take as stimulation string decode with decode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   const decoded = decodeCyclic(s);\n   const voltAmpereGroups = decoded.split('');\n   const ampereGroups = [];\n   for (let i = 0; i < voltAmpereGroups.length; i++) {\n     if (voltAmpereGroups[i].length === 3) \n       ampereGroups.push(voltAmpereGroups[i].slice(1) + voltAmpereGroups[i]);\n     else \n       ampereGroups.push(voltAmpereGroups[i]);\n   }\n   return ampereGroups.join('');\n}\n\n/*\n   take as stimulation string encode with encode_cyclic function. Returns decoded string. \n   * / \n const encodeCyclic = (s) = > {\n   const voltAmpereGroups = encodeCyclic(s).split('');\n   const ampereGroups = [];\n   for (let i = 0; i < voltAmpereGroups.length; i++) {\n     if (voltAmpereGroups[i].length === 3) \n       ampereGroups.push(voltAmpereGroups[i].slice(1) + voltAmpereGroups[i]);\n     else \n       ampereGroups.push(voltAmpereGroups[i]);\n   }\n   return ampereGroups.join('');\n}\n\n/*\n   take as stimulation string decode with decode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   const decoded = decodeCyclic(s);\n   const voltAmpereGroups = decoded.split('');\n   const ampereGroups = [];\n   for (let i = 0; i < voltAmpereGroups.length; i++) {\n     if (voltAmpereGroups[i].length === 3) \n       ampereGroups.push(voltAmpereGroups[i].slice(1) + voltAmpereGroups[i]);\n     else \n       ampereGroups.push(voltAmpereGroups[i]);\n   }\n   return ampereGroups.join('');\n}\n\n/*\n   take as stimulation string encode with encode_cyclic function. Returns decoded string. \n   * / \n const encodeCyclic = (s) = > {\n   const voltAmpereGroups = encodeCyclic(s).split('');\n   const ampereGroups = [];\n   for (let i = 0; i < voltAmpereGroups.length; i++) {\n     if (voltAmpereGroups[i].length === 3) \n       ampereGroups.push(voltAmpereGroups[i].slice(1) + voltAmpereGroups[i]);\n     else \n       ampereGroups.push(voltAmpereGroups[i]);\n   }\n   return ampereGroups.join('');\n}\n\n/*\n   take as stimulation string decode with decode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   const decoded = decodeCyclic(s);\n   const voltAmpereGroups = decoded.split('');\n   const ampereGroups = [];\n   for (let i = 0; i < voltAmpereGroups.length; i++) {\n     if (voltAmpereGroups[i].length === 3) \n       ampereGroups.push(voltAmpereGroups[i].slice(1) + voltAmpereGroups[i]);\n     else \n       ampereGroups.push(voltAmpereGroups[i]);\n   }\n   return ampereGroups.join('');\n}\n\n/*\n   take as stimulation string encode with encode_cyclic function. Returns decoded string. \n   * / \n const encodeCyclic = (s) = > {\n   const voltAmpereGroups = encodeCyclic(s).split('');\n   const ampereGroups = [];\n   for (let i = 0; i < voltAmpereGroups.length; i++) {\n     if (voltAmpereGroups[i].length === 3) \n       ampereGroups.push(voltAmpereGroups[i].slice(1) + voltAmpereGroups[i]);\n     else \n       ampereGroups.push(voltAmpereGroups[i]);\n   }\n   return ampereGroups.join('');\n}\n\n/*\n   take as stimulation string decode with decode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   const decoded = decodeCyclic(s);\n   const voltAmpereGroups = decoded.split('');\n   const ampereGroups = [];\n   for (let i = 0; i < voltAmpereGroups.length; i++) {\n     if (voltAmpereGroups[i].length === 3) \n       ampereGroups.push(voltAmpereGroups[i].slice(1) + voltAmpereGroups[i]);\n     else \n       ampereGroups.push(voltAmpereGroups[i]);\n   }\n   return ampereGroups.join('');\n}\n\n/*\n   take as stimulation string encode with encode_cyclic function. Returns decoded string. \n   * / \n const encodeCyclic = (s) = > {\n   const voltAmpereGroups = encodeCyclic(s).split('');\n   const ampereGroups = [];\n   for (let i = 0; i < voltAmpereGroups.length; i++) {\n     if (voltAmpereGroups[i].length === 3) \n       ampereGroups.push(voltAmpereGroups[i].slice(1) + voltAmpereGroups[i]);\n     else \n       ampereGroups.push(voltAmpereGroups[i]);\n   }\n   return ampereGroups.join('');\n}\n\n/*\n   take as stimulation string decode with decode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   const decoded = decodeCyclic(s);\n   const voltAmpereGroups = decoded.split('');\n   const ampereGroups = [];\n   for (let i = 0; i < voltAmpereGroups.length; i++) {\n     if (vol"}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib fall n-th number that equal a Fibonacci act and it's besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  primeFib fall n-th number that equal a Fibonacci act and it's besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  let a = 1, b = 1, c = 1, d = 1;\n  let prime = true;\n  while (prime) {\n    if (n % 2 === 0) {\n      prime = false;\n    }\n    if (n % 3 === 0) {\n      c = b;\n      b = d;\n      d = c;\n    }\n    if (n % 5 === 0) {\n      a = b;\n      b = d;\n      d = a;\n    }\n    n /= 5;\n  }\n  return d;\n};\n\n/**\n * A simple implementation of Math.trunc to truncate a number to a given precision.\n * \n * @param {number} n The number to truncate.\n * @param {number} precision The precision to truncate to.\n */\nconst truncate = (n, precision) => {\n  return Math.trunc(n / precision) * precision;\n};\n\n/**\n * A simple implementation of Math.floor to floor two numbers to a given precision.\n * \n * @param {number} n The number to floor.\n * @param {number} precision The precision to floor to.\n */\nconst floor = (n, precision) => {\n  return Math.floor(n / precision) * precision;\n};\n\n/**\n * A simple implementation of Math.ceil to round two numbers to a given precision.\n * \n * @param {number} n The number to round.\n * @param {number} precision The precision to round to.\n */\nconst ceil = (n, precision) => {\n  return Math.ceil(n / precision) * precision;\n};\n\n/**\n * A simple implementation of Math.truncto to truncate a number to a given precision.\n * \n * @param {number} n The number to truncate.\n * @param {number} precision The precision to truncate to.\n */\nconst truncto = (n, precision) => {\n  return Math.trunc(n * precision) / precision;\n};\n\n/**\n * A simple implementation of Math.floor to floor two numbers to a given precision.\n * \n * @param {number} n The number to floor.\n * @param {number} precision The precision to floor to.\n */\nconst floorto = (n, precision) => {\n  return Math.floor(n * precision) / precision;\n};\n\n/**\n * A simple implementation of Math.ceil to round two numbers to a given precision.\n * \n * @param {number} n The number to round.\n * @param {number} precision The precision to round to.\n */\nconst ceilto = (n, precision) => {\n  return Math.ceil(n * precision) / precision;\n};\n\n/**\n * A simple implementation of Math.truncto to truncate a number to a given precision.\n * \n * @param {number} n The number to truncate.\n * @param {number} precision The precision to truncate to.\n */\nconst trunctoto = (n, precision) => {\n  return Math.trunc(n * precision) / precision;\n};\n\n/**\n * A simple implementation of Math.trunc to truncate a number to a given precision.\n * \n * @param {number} n The number to truncate.\n * @param {number} precision The precision to truncate to.\n */\nconst trunc = (n, precision) => {\n  return Math.trunc(n / precision) * precision;\n};\n\n/**\n * A simple implementation of Math.floor to floor two numbers to a given precision.\n * \n * @param {number} n The number to floor.\n * @param {number} precision The precision to floor to.\n */\nconst floor = (n, precision) => {\n  return Math.floor(n / precision) * precision;\n};\n\n/**\n * A simple implementation of Math.ceil to round two numbers to a given precision.\n * \n * @param {number} n The number to round.\n * @param {number} precision The precision to round to.\n */\nconst ceil = (n, precision) => {\n  return Math.ceil(n / precision) * precision;\n};\n\n/**\n * A simple implementation of Math.truncto to truncate a number to a given precision.\n * \n * @param {number} n The number to truncate.\n * @param {number} precision The precision to truncate to.\n */\nconst truncto = (n, precision) => {\n  return Math.trunc(n * precision) / precision;\n};\n\n/**\n * A simple implementation of Math.trunc to truncate a number to a given precision.\n * \n * @param {number} n The number to truncate.\n * @param {number} precision The precision to truncate to.\n */\nconst trunc = (n, precision) => {\n  return Math.trunc(n / precision) * precision;\n};\n\n/**\n * A simple implementation of Math.trunc to truncate a number to a given precision.\n * \n * @param {number} n The number to truncate.\n * @param {number} precision The precision to truncate to.\n */\nconst trunctoto = (n, precision) => {\n  return Math.trunc(n * precision) / precision;\n};\n\n/**\n * A simple implementation of Math.trunc to truncate a number to a given precision.\n * \n * @param {number} n The number to truncate.\n * @param {number} precision The precision to truncate to.\n */\nconst trunc = (n, precision) => {\n  return Math.trunc(n / precision) * precision;\n};\n\n/**\n * A simple implementation of Math.trunc to truncate a number to a given precision.\n * \n * @param {number} n The number to truncate.\n * @param {number} precision The precision to truncate to.\n */\nconst trunctoto = (n, precision) => {\n  return Math.trunc(n * precision) / precision;\n};\n\n/**\n * A simple implementation of Math.trunc to truncate a number to a given precision.\n * \n * @param {number} n The number to truncate.\n * @param {number} precision The precision to truncate to.\n */\nconst trunc = (n, precision) => {\n  return Math.trunc(n / precision) * precision;\n};\n\n/**\n * A simple implementation of Math.trunc to truncate a number to a given precision.\n * \n * @param {number} n The number to truncate.\n * @param {number} precision The precision to truncate to.\n */\nconst trunctoto = (n, precision) => {\n  return Math.trunc(n * precision) / precision;\n};\n\n/**\n * A simple implementation of Math.trunc to truncate a number to a given precision.\n * \n * @param {number} n The number to truncate.\n * @param {number} precision The precision to truncate to.\n */\nconst trunc = (n, precision) => {\n  return Math.trunc(n / precision) * precision;\n};\n\n/**\n * A simple implementation of Math.trunc to truncate a number to a given precision.\n * \n * @param {number} n The number to truncate.\n * @param {number} precision The precision to truncate to.\n */\nconst trunctoto = (n, precision) => {\n  return Math.trunc(n * precision) / precision;\n};\n\n/**\n * A simple implementation of Math.trunc to truncate a number to a given precision.\n * \n * @param {number} n The number to truncate.\n * @param {number} precision The precision to truncate to.\n */\nconst trunc = (n, precision) => {\n  return Math.trunc(n / precision) * precision;\n};\n\n/**\n * A simple implementation of Math.trunc to truncate a number to a given precision.\n * \n * @param {number} n The number to truncate.\n * @param {number} precision The precision to truncate to.\n */\nconst trunctoto = (n, precision) => {\n  return Math.trunc(n * precision) / precision;\n};\n\n/**\n * A simple implementation of Math.trunc to truncate a number to a given precision.\n * \n * @param {number} n The number to truncate.\n * @param {number} precision The precision to truncate to.\n */\nconst trunc = (n, precision) => {\n  return Math.trunc(n / precision) * precision;\n};\n\n/**\n * A simple implementation of Math.trunc to truncate a number "}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero consider a list of integers as an remark. \n   it return on-key if there constitute three distinct elements in the list that \n   kernel to zero, and assumed differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  triplesSumToZero consider a list of integers as an remark. \n   it return on-key if there constitute three distinct elements in the list that \n   kernel to zero, and assumed differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0) continue;\n    if (l[i] === 1) sum += 1;\n    if (l[i] === 2) sum += 2;\n    if (l[i] === 3) sum += 3;\n  }\n  return sum === 3;\n};\n\n/*\n  triplesSumToOne consider a list of integers as an remark. \n   it return on-key if there constitute three distinct elements in the list that \n   kernel to one, and assumed differently.\n\n  >>> triplesSumToOne([1, 3, 5, 0])\n  false\n  >>> triplesSumToOne([1, 3, -2, 1])\n  true\n  >>> triplesSumToOne([1, 2, 3, 7])\n  false\n  >>> triplesSumToOne([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToOne([1])\n  false\n  */\nconst triplesSumToOne = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0) continue;\n    if (l[i] === 1) sum += 1;\n    if (l[i] === 2) sum += 2;\n    if (l[i] === 3) sum += 3;\n  }\n  return sum === 3;\n};\n\n/*\n  triplesSumToTwo consider a list of integers as an remark. \n   it return on-key if there constitute three distinct elements in the list that \n   kernel to two, and assumed differently.\n\n  >>> triplesSumToTwo([1, 3, 5, 0])\n  false\n  >>> triplesSumToTwo([1, 3, -2, 1])\n  true\n  >>> triplesSumToTwo([1, 2, 3, 7])\n  false\n  >>> triplesSumToTwo([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToTwo([1])\n  false\n  */\nconst triplesSumToTwo = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0) continue;\n    if (l[i] === 1) sum += 1;\n    if (l[i] === 2) sum += 2;\n    if (l[i] === 3) sum += 3;\n  }\n  return sum === 3;\n};\n\n/*\n  triplesSumToThree consider a list of integers as an remark. \n   it return on-key if there constitute three distinct elements in the list that \n   kernel to three, and assumed differently.\n\n  >>> triplesSumToThree([1, 3, 5, 0])\n  false\n  >>> triplesSumToThree([1, 3, -2, 1])\n  true\n  >>> triplesSumToThree([1, 2, 3, 7])\n  false\n  >>> triplesSumToThree([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToThree([1])\n  false\n  */\nconst triplesSumToThree = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0) continue;\n    if (l[i] === 1) sum += 1;\n    if (l[i] === 2) sum += 2;\n    if (l[i] === 3) sum += 3;\n  }\n  return sum === 3;\n};\n\n/*\n  triplesSumToFour consider a list of integers as an remark. \n   it return on-key if there constitute three distinct elements in the list that \n   kernel to four, and assumed differently.\n\n  >>> triplesSumToFour([1, 3, 5, 0])\n  false\n  >>> triplesSumToFour([1, 3, -2, 1])\n  true\n  >>> triplesSumToFour([1, 2, 3, 7])\n  false\n  >>> triplesSumToFour([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToFour([1])\n  false\n  */\nconst triplesSumToFour = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0) continue;\n    if (l[i] === 1) sum += 1;\n    if (l[i] === 2) sum += 2;\n    if (l[i] === 3) sum += 3;\n    if (l[i] === 4) sum += 4;\n  }\n  return sum === 4;\n};\n\n/*\n  triplesSumToFive consider a list of integers as an remark. \n   it return on-key if there constitute three distinct elements in the list that \n   kernel to five, and assumed differently.\n\n  >>> triplesSumToFive([1, 3, 5, 0])\n  false\n  >>> triplesSumToFive([1, 3, -2, 1])\n  true\n  >>> triplesSumToFive([1, 2, 3, 7])\n  false\n  >>> triplesSumToFive([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToFive([1])\n  false\n  */\nconst triplesSumToFive = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0) continue;\n    if (l[i] === 1) sum += 1;\n    if (l[i] === 2) sum += 2;\n    if (l[i] === 3) sum += 3;\n    if (l[i] === 5) sum += 5;\n  }\n  return sum === 5;\n};\n\n/*\n  triplesSumToSix consider a list of integers as an remark. \n   it return on-key if there constitute three distinct elements in the list that \n   kernel to six, and assumed differently.\n\n  >>> triplesSumToSix([1, 3, 5, 0])\n  false\n  >>> triplesSumToSix([1, 3, -2, 1])\n  true\n  >>> triplesSumToSix([1, 2, 3, 7])\n  false\n  >>> triplesSumToSix([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToSix([1])\n  false\n  */\nconst triplesSumToSix = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0) continue;\n    if (l[i] === 1) sum += 1;\n    if (l[i] === 2) sum += 2;\n    if (l[i] === 3) sum += 3;\n    if (l[i] === 6) sum += 6;\n  }\n  return sum === 6;\n};\n\n/*\n  triplesSumToSeven consider a list of integers as an remark. \n   it return on-key if there constitute three distinct elements in the list that \n   kernel to seven, and assumed differently.\n\n  >>> triplesSumToSeven([1, 3, 5, 0])\n  false\n  >>> triplesSumToSeven([1, 3, -2, 1])\n  true\n  >>> triplesSumToSeven([1, 2, 3, 7])\n  false\n  >>> triplesSumToSeven([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToSeven([1])\n  false\n  */\nconst triplesSumToSeven = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0) continue;\n    if (l[i] === 1) sum += 1;\n    if (l[i] === 2) sum += 2;\n    if (l[i] === 3) sum += 3;\n    if (l[i] === 7) sum += 7;\n  }\n  return sum === 7;\n};\n\n/*\n  triplesSumToEight consider a list of integers as an remark. \n   it return on-key if there constitute three distinct elements in the list that \n"}
{"task_id": "JavaScript/41", "prompt": "/*\n  think a road that's a absolutely uncoiled boundlessly retentive course. \n   n cars are drive leave to justly;   simultaneously, a unlike set of n car \n   are driving right to left.    The two set of cars start out exist very far from \n   each early.   All car move in the same focal ratio.   Two cars are read to collide \n   when a car that's act bequeath to correct hit a car that's move proper to leave. \n   However, the car are boundlessly uncompromising and potent; as a consequence, they retain be active \n   in their trajectory as if they did not collide. \n\n   This function outputs the act of such collision. \n   * / \n const carRaceCollision = (n) = > {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  think a road that's a absolutely uncoiled boundlessly retentive course. \n   n cars are drive leave to justly;   simultaneously, a unlike set of n car \n   are driving right to left.    The two set of cars start out exist very far from \n   each early.   All car move in the same focal ratio.   Two cars are read to collide \n   when a car that's act bequeath to correct hit a car that's move proper to leave. \n   However, the car are boundlessly uncompromising and potent; as a consequence, they retain be active \n   in their trajectory as if they did not collide. \n\n   This function outputs the act of such collision. \n   * / \n const carRaceCollision = (n) = > {\n   const car1 = new Car(...);\n   const car2 = new Car(...);\n   const car3 = new Car(...);\n   const car4 = new Car(...);\n   const car5 = new Car(...);\n   const car6 = new Car(...);\n   const car7 = new Car(...);\n   const car8 = new Car(...);\n   const car9 = new Car(...);\n   const car10 = new Car(...);\n   const car11 = new Car(...);\n   const car12 = new Car(...);\n   const car13 = new Car(...);\n   const car14 = new Car(...);\n   const car15 = new Car(...);\n   const car16 = new Car(...);\n   const car17 = new Car(...);\n   const car18 = new Car(...);\n   const car19 = new Car(...);\n   const car20 = new Car(...);\n   const car21 = new Car(...);\n   const car22 = new Car(...);\n   const car23 = new Car(...);\n   const car24 = new Car(...);\n   const car25 = new Car(...);\n   const car26 = new Car(...);\n   const car27 = new Car(...);\n   const car28 = new Car(...);\n   const car29 = new Car(...);\n   const car30 = new Car(...);\n   const car31 = new Car(...);\n   const car32 = new Car(...);\n   const car33 = new Car(...);\n   const car34 = new Car(...);\n   const car35 = new Car(...);\n   const car36 = new Car(...);\n   const car37 = new Car(...);\n   const car38 = new Car(...);\n   const car39 = new Car(...);\n   const car40 = new Car(...);\n   const car41 = new Car(...);\n   const car42 = new Car(...);\n   const car43 = new Car(...);\n   const car44 = new Car(...);\n   const car45 = new Car(...);\n   const car46 = new Car(...);\n   const car47 = new Car(...);\n   const car48 = new Car(...);\n   const car49 = new Car(...);\n   const car50 = new Car(...);\n   const car51 = new Car(...);\n   const car52 = new Car(...);\n   const car53 = new Car(...);\n   const car54 = new Car(...);\n   const car55 = new Car(...);\n   const car56 = new Car(...);\n   const car57 = new Car(...);\n   const car58 = new Car(...);\n   const car59 = new Car(...);\n   const car60 = new Car(...);\n   const car61 = new Car(...);\n   const car62 = new Car(...);\n   const car63 = new Car(...);\n   const car64 = new Car(...);\n   const car65 = new Car(...);\n   const car66 = new Car(...);\n   const car67 = new Car(...);\n   const car68 = new Car(...);\n   const car69 = new Car(...);\n   const car70 = new Car(...);\n   const car71 = new Car(...);\n   const car72 = new Car(...);\n   const car73 = new Car(...);\n   const car74 = new Car(...);\n   const car75 = new Car(...);\n   const car76 = new Car(...);\n   const car77 = new Car(...);\n   const car78 = new Car(...);\n   const car79 = new Car(...);\n   const car80 = new Car(...);\n   const car81 = new Car(...);\n   const car82 = new Car(...);\n   const car83 = new Car(...);\n   const car84 = new Car(...);\n   const car85 = new Car(...);\n   const car86 = new Car(...);\n   const car87 = new Car(...);\n   const car88 = new Car(...);\n   const car89 = new Car(...);\n   const car90 = new Car(...);\n   const car91 = new Car(...);\n   const car92 = new Car(...);\n   const car93 = new Car(...);\n   const car94 = new Car(...);\n   const car95 = new Car(...);\n   const car96 = new Car(...);\n   const car97 = new Car(...);\n   const car98 = new Car(...);\n   const car99 = new Car(...);\n   const car100 = new Car(...);\n   const car101 = new Car(...);\n   const car102 = new Car(...);\n   const car103 = new Car(...);\n   const car104 = new Car(...);\n   const car105 = new Car(...);\n   const car106 = new Car(...);\n   const car107 = new Car(...);\n   const car108 = new Car(...);\n   const car109 = new Car(...);\n   const car110 = new Car(...);\n   const car111 = new Car(...);\n   const car112 = new Car(...);\n   const car113 = new Car(...);\n   const car114 = new Car(...);\n   const car115 = new Car(...);\n   const car116 = new Car(...);\n   const car117 = new Car(...);\n   const car118 = new Car(...);\n   const car119 = new Car(...);\n   const car120 = new Car(...);\n   const car121 = new Car(...);\n   const car122 = new Car(...);\n   const car123 = new Car(...);\n   const car124 = new Car(...);\n   const car125 = new Car(...);\n   const car126 = new Car(...);\n   const car127 = new Car(...);\n   const car128 = new Car(...);\n   const car129 = new Car(...);\n   const car130 = new Car(...);\n   const car131 = new Car(...);\n   const car132 = new Car(...);\n   const car133 = new "}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let res = []\n  let i = 0\n  while (i < l.length) {\n    res.push(l[i])\n    i++\n  }\n  return res\n}\n\n/*Return list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  */\nconst decrList = (l) => {\n  let res = []\n  let i = 0\n  while (i < l.length) {\n    res.push(l[i])\n    i++\n  }\n  return res\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  */\nconst incrDecrList = (l) => {\n  let res = []\n  let i = 0\n  while (i < l.length) {\n    res.push(l[i])\n    i++\n  }\n  return res\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  */\nconst decrDecrList = (l) => {\n  let res = []\n  let i = 0\n  while (i < l.length) {\n    res.push(l[i])\n    i++\n  }\n  return res\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  */\nconst incrDecrList = (l) => {\n  let res = []\n  let i = 0\n  while (i < l.length) {\n    res.push(l[i])\n    i++\n  }\n  return res\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  */\nconst decrDecrList = (l) => {\n  let res = []\n  let i = 0\n  while (i < l.length) {\n    res.push(l[i])\n    i++\n  }\n  return res\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  */\nconst incrDecrList = (l) => {\n  let res = []\n  let i = 0\n  while (i < l.length) {\n    res.push(l[i])\n    i++\n  }\n  return res\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  */\nconst decrDecrList = (l) => {\n  let res = []\n  let i = 0\n  while (i < l.length) {\n    res.push(l[i])\n    i++\n  }\n  return res\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  */\nconst incrDecrList = (l) => {\n  let res = []\n  let i = 0\n  while (i < l.length) {\n    res.push(l[i])\n    i++\n  }\n  return res\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  */\nconst decrDecrList = (l) => {\n  let res = []\n  let i = 0\n  while (i < l.length) {\n    res.push(l[i])\n    i++\n  }\n  return res\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  */\nconst incrDecrList = (l) => {\n  let res = []\n  let i = 0\n  while (i < l.length) {\n    res.push(l[i])\n    i++\n  }\n  return res\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  */\nconst decrDecrList = (l) => {\n  let res = []\n  let i = 0\n  while (i < l.length) {\n    res.push(l[i])\n    i++\n  }\n  return res\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  */\nconst incrDecrList = (l) => {\n  let res = []\n  let i = 0\n  while (i < l.length) {\n    res.push(l[i])\n    i++\n  }\n  return res\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  */\nconst decrDecrList = (l) => {\n  let res = []\n  let i = 0\n  while (i < l.length) {\n    res.push(l[i])\n    i++\n  }\n  return res\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  */\nconst incrDecrList = (l) => {\n  let res = []\n  let i = 0\n  while (i < l.length) {\n    res.push(l[i])\n    i++\n  }\n  return res\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  */\nconst decrDecrList = (l) => {\n  let res = []\n  let i = 0\n  while (i < l.length) {\n    res.push(l[i])\n    i++\n  }\n  return res\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  */\nconst incrDecrList = (l) => {\n  let res = []\n  let i = 0\n  while (i < l.length) {\n    res.push(l[i])\n    i++\n  }\n  return res\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  */\nconst decrDecrList = (l) => {\n  let res = []\n  let i = 0\n  while (i < l.length) {\n    res.push(l[i])\n    i++\n  }\n  return res\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  */\nconst incrDecrList = (l) => {\n  let res = []\n  let i = 0\n  while (i < l.length) {\n    res.push(l[i])\n    i++\n  }"}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero consider a list of integers as an remark. \n   it return on-key if there constitute two distinct elements in the list that \n   kernel to zero, and assumed differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  pairsSumToZero consider a list of integers as an remark. \n   it return on-key if there constitute two distinct elements in the list that \n   kernel to zero, and assumed differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/*\n  pairsSumToOne consider a list of integers as an remark. \n   it return on-key if there constitute two distinct elements in the list that \n   kernel to one, and assumed differently.\n  >>> pairsSumToOne([1, 3, 5, 0])\n  false\n  >>> pairsSumToOne([1, 3, -2, 1])\n  false\n  >>> pairsSumToOne([1, 2, 3, 7])\n  false\n  >>> pairsSumToOne([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToOne([1])\n  false\n  */\nconst pairsSumToOne = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 1;\n};\n\n/*\n  pairsSumToTwo consider a list of integers as an remark. \n   it return on-key if there constitute two distinct elements in the list that \n   kernel to two, and assumed differently.\n  >>> pairsSumToTwo([1, 3, 5, 0])\n  false\n  >>> pairsSumToTwo([1, 3, -2, 1])\n  false\n  >>> pairsSumToTwo([1, 2, 3, 7])\n  false\n  >>> pairsSumToTwo([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToTwo([1])\n  false\n  */\nconst pairsSumToTwo = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 2;\n};\n\n/*\n  pairsSumToThree consider a list of integers as an remark. \n   it return on-key if there constitute two distinct elements in the list that \n   kernel to three, and assumed differently.\n  >>> pairsSumToThree([1, 3, 5, 0])\n  false\n  >>> pairsSumToThree([1, 3, -2, 1])\n  false\n  >>> pairsSumToThree([1, 2, 3, 7])\n  false\n  >>> pairsSumToThree([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToThree([1])\n  false\n  */\nconst pairsSumToThree = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 3;\n};\n\n/*\n  pairsSumToFour consider a list of integers as an remark. \n   it return on-key if there constitute two distinct elements in the list that \n   kernel to four, and assumed differently.\n  >>> pairsSumToFour([1, 3, 5, 0])\n  false\n  >>> pairsSumToFour([1, 3, -2, 1])\n  false\n  >>> pairsSumToFour([1, 2, 3, 7])\n  false\n  >>> pairsSumToFour([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToFour([1])\n  false\n  */\nconst pairsSumToFour = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 4;\n};\n\n/*\n  pairsSumToFive consider a list of integers as an remark. \n   it return on-key if there constitute two distinct elements in the list that \n   kernel to five, and assumed differently.\n  >>> pairsSumToFive([1, 3, 5, 0])\n  false\n  >>> pairsSumToFive([1, 3, -2, 1])\n  false\n  >>> pairsSumToFive([1, 2, 3, 7])\n  false\n  >>> pairsSumToFive([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToFive([1])\n  false\n  */\nconst pairsSumToFive = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 5;\n};\n\n/*\n  pairsSumToSix consider a list of integers as an remark. \n   it return on-key if there constitute two distinct elements in the list that \n   kernel to six, and assumed differently.\n  >>> pairsSumToSix([1, 3, 5, 0])\n  false\n  >>> pairsSumToSix([1, 3, -2, 1])\n  false\n  >>> pairsSumToSix([1, 2, 3, 7])\n  false\n  >>> pairsSumToSix([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToSix([1])\n  false\n  */\nconst pairsSumToSix = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 6;\n};\n\n/*\n  pairsSumToSeven consider a list of integers as an remark. \n   it return on-key if there constitute two distinct elements in the list that \n   kernel to seven, and assumed differently.\n  >>> pairsSumToSeven([1, 3, 5, 0])\n  false\n  >>> pairsSumToSeven([1, 3, -2, 1])\n  false\n  >>> pairsSumToSeven([1, 2, 3, 7])\n  false\n  >>> pairsSumToSeven([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToSeven([1])\n  false\n  */\nconst pairsSumToSeven = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 7;\n};\n\n/*\n  pairsSumToEight consider a list of integers as an remark. \n   it return on-key if there constitute two distinct elements in the list that \n   kernel to eight, and assumed differently.\n  >>> pairsSumToEight([1, 3, 5, 0])\n  false\n  >>> pairsSumToEight([1, 3, -2, 1])\n  false\n  >>> pairsSumToEight([1, 2, 3, 7])\n  false\n  >>> pairsSumToEight([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToEight([1])\n  false\n  */\nconst pairsSumToEight = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 8;\n};\n\n/*\n  pairsSumToNine consider a list of integers as an remark. \n   it return on-key if there constitute two distinct elements in the list that \n   kernel to nine, and assumed differently.\n  >>> pairsSumToNine([1, 3, 5, 0])\n  false\n  >>> pairsSumToNine([1, 3, -2, 1])\n  false\n  >>> pairsSumToNine([1, 2, 3, 7])\n  false\n  >>> pairsSumToNine([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToNine([1])\n  false\n  */\nconst pairsSumToNine = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 9;\n};\n\n/*\n  pairsSumToTen consider a list of integers as an remark. \n   it return on-key if there constitute two distinct elements in the "}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical base of remark act x to base.\n   return drawstring representation after the conversion. \n   base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Change numerical base of remark act x to base.\n   return drawstring representation after the conversion. \n   base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let remark = '';\n  let remarkAct = '';\n  let remarkActAct = '';\n  let remarkActActAct = '';\n  let remarkActActActAct = '';\n  let remarkActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActActAct = '';\n  let remarkActActActActActActActActAct = '';\n  let remarkActActActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActActActAct = '';\n  let remarkActActActActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActActAct = '';\n  let remarkActActActActActActActAct = '';\n  let remarkActActActActActActActAct = '';\n  let remarkActActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActActAct = '';\n  let remarkActActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActActAct = '';\n  let remarkActActActActActActActAct = '';\n  let remarkActActActActActActActAct = '';\n  let remarkActActActActActActActAct = '';\n  let remarkActActActActActActActAct = '';\n  let remarkActActActActActActActAct = '';\n  let remarkActActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActActAct = '';\n  let remarkActActActActActActActActActAct = '';\n  let remarkActActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActAct = '';\n  let remarkActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let remarkActActActActActAct = '';\n  let remarkActActActActActActAct = '';\n  let re"}
{"task_id": "JavaScript/45", "prompt": "/*Given length of a english and high return sphere for a triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Given length of a english and high return sphere for a triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const a = Math.sqrt(a * a + h * h);\n  const b = Math.sqrt(a * a + h * h);\n  const c = Math.sqrt(a * a + h * h);\n  return b * b - 4 * a * c;\n};\n\n/*Given length of a english and high return sphere for a quadrilateral.\n  >>> quadrilateralArea(5, 3)\n  9.5\n  */\nconst quadrilateralArea = (l, h) => {\n  const l = Math.sqrt(l * l + h * h);\n  const h = Math.sqrt(l * l + h * h);\n  return l * l - 2 * l * h + 4 * h * h;\n};\n\n/*Given length of a english and high return sphere for a pentagon.\n  >>> pentagonArea(5, 3)\n  11.5\n  */\nconst pentagonArea = (l, h) => {\n  const l = Math.sqrt(l * l + h * h);\n  const h = Math.sqrt(l * l + h * h);\n  return l * l - 2 * l * h + 4 * h * h;\n};\n\n/*Given length of a english and high return sphere for a hexagon.\n  >>> hexagonArea(5, 3)\n  17.25\n  */\nconst hexagonArea = (l, h) => {\n  const l = Math.sqrt(l * l + h * h);\n  const h = Math.sqrt(l * l + h * h);\n  return l * l - 2 * l * h + 4 * h * h;\n};\n\n/*Given length of a english and high return sphere for a heptagon.\n  >>> heptagonArea(5, 3)\n  27.25\n  */\nconst heptagonArea = (l, h) => {\n  const l = Math.sqrt(l * l + h * h);\n  const h = Math.sqrt(l * l + h * h);\n  return l * l - 2 * l * h + 4 * h * h;\n};\n\n/*Given length of a english and high return sphere for a decagon.\n  >>> decagonArea(5, 3)\n  106.25\n  */\nconst decagonArea = (l, h) => {\n  const l = Math.sqrt(l * l + h * h);\n  const h = Math.sqrt(l * l + h * h);\n  return l * l - 2 * l * h + 4 * h * h;\n};\n\n/*Given length of a english and high return sphere for a dodecagon.\n  >>> dodecagonArea(5, 3)\n  126.25\n  */\nconst dodecagonArea = (l, h) => {\n  const l = Math.sqrt(l * l + h * h);\n  const h = Math.sqrt(l * l + h * h);\n  return l * l - 2 * l * h + 4 * h * h;\n};\n\n/*Given length of a english and high return sphere for a quintic sphere.\n  >>> quinticSphereArea(5, 3)\n  146.25\n  */\nconst quinticSphereArea = (l, h) => {\n  const l = Math.sqrt(l * l + h * h);\n  const h = Math.sqrt(l * l + h * h);\n  return l * l - 2 * l * h + 4 * h * h;\n};\n\n/*Given length of a english and high return sphere for a hexagonal sphere.\n  >>> hexagonalSphereArea(5, 3)\n  176.25\n  */\nconst hexagonalSphereArea = (l, h) => {\n  const l = Math.sqrt(l * l + h * h);\n  const h = Math.sqrt(l * l + h * h);\n  return l * l - 2 * l * h + 4 * h * h;\n};\n\n/*Given length of a english and high return sphere for a heptagonal sphere.\n  >>> heptagonalSphereArea(5, 3)\n  276.25\n  */\nconst heptagonalSphereArea = (l, h) => {\n  const l = Math.sqrt(l * l + h * h);\n  const h = Math.sqrt(l * l + h * h);\n  return l * l - 2 * l * h + 4 * h * h;\n};\n\n/*Given length of a english and high return sphere for a decagonal sphere.\n  >>> decagonalSphereArea(5, 3)\n  106.25\n  */\nconst decagonalSphereArea = (l, h) => {\n  const l = Math.sqrt(l * l + h * h);\n  const h = Math.sqrt(l * l + h * h);\n  return l * l - 2 * l * h + 4 * h * h;\n};\n\n/*Given length of a english and high return sphere for a dodecagonal sphere.\n  >>> dodecagonalSphereArea(5, 3)\n  126.25\n  */\nconst dodecagonalSphereArea = (l, h) => {\n  const l = Math.sqrt(l * l + h * h);\n  const h = Math.sqrt(l * l + h * h);\n  return l * l - 2 * l * h + 4 * h * h;\n};\n\n/*Given length of a english and high return sphere for a quintic hexagonal sphere.\n  >>> quinticHexagonalSphereArea(5, 3)\n  146.25\n  */\nconst quinticHexagonalSphereArea = (l, h) => {\n  const l = Math.sqrt(l * l + h * h);\n  const h = Math.sqrt(l * l + h * h);\n  return l * l - 2 * l * h + 4 * h * h;\n};\n\n/*Given length of a english and high return sphere for a heptagonal hexagonal sphere.\n  >>> heptagonalHexagonalSphereArea(5, 3)\n  176.25\n  */\nconst heptagonalHexagonalSphereArea = (l, h) => {\n  const l = Math.sqrt(l * l + h * h);\n  const h = Math.sqrt(l * l + h * h);\n  return l * l - 2 * l * h + 4 * h * h;\n};\n\n/*Given length of a english and high return sphere for a decagonal hexagonal sphere.\n  >>> decagonalHexagonalSphereArea(5, 3)\n  106.25\n  */\nconst decagonalHexagonalSphereArea = (l, h) => {\n  const l = Math.sqrt(l * l + h * h);\n  const h = Math.sqrt(l * l + h * h);\n  return l * l - 2 * l * h + 4 * h * h;\n};\n\n/*Given length of a english and high return sphere for a dodecagonal hexagonal sphere.\n  >>> dodecagonalHexagonalSphereArea(5, 3)\n  126.25\n  */\nconst dodecagonalHexagonalSphereArea = (l, h) => {\n  const l = Math.sqrt(l * l + h * h);\n  const h = Math.sqrt(l * l + h * h);\n  return l * l - 2 * l * h + 4 * h * h;\n};\n\n/*Given length of a english and high return sphere for a quintic heptagonal sphere.\n  >>> quinticHeptagonalSphereArea(5, 3)\n  146.25\n  */\nconst quinticHeptagonalSphereArea = (l, h) => {\n  const l = Math.sqrt(l * l + h * h);\n  const h = Math.sqrt(l * l + h * h);\n  return l * l - 2 * l * h + 4 * h * h;\n};\n\n/*Given length of a english and high return sphere for a heptagonal heptagonal sphere.\n  >>> heptagonalHeptagonalSphereArea(5, 3)\n  176.25\n  */\nconst heptagonalHeptagonalSphereArea = (l, h) => {\n  const l = Math.sqrt(l * l + h * h);\n  const h = Math.sqrt(l * l + h * h);\n  return l * l - 2 * l * h + 4 * h * h;\n};\n\n/*Given length of a english and high return sphere for a decagonal heptagonal sphere.\n  >>> decagonalHeptagonalSphere"}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 act sequence is a succession similar to the Fibbonacci sequnece that's specify as follow: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please write a affair to efficiently compute the n-th chemical element of the fib4 number succession.   Do not practice recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*The Fib4 act sequence is a succession similar to the Fibbonacci sequnece that's specify as follow: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please write a affair to efficiently compute the n-th chemical element of the fib4 number succession.   Do not practice recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*\n  Write a function that computes the n-th Fibonacci number succession.\n  >>> fib5(5)\n  5\n  >>> fib5(6)\n  13\n  >>> fib5(7)\n  21\n  >>> fib5(8)\n  34\n  >>> fib5(9)\n  55\n  >>> fib5(10)\n  89\n  >>> fib5(11)\n  144\n  >>> fib5(12)\n  233\n  >>> fib5(13)\n  377\n  >>> fib5(14)\n  610\n  >>> fib5(15)\n  987\n  >>> fib5(16)\n  1597\n  >>> fib5(17)\n  2584\n  >>> fib5(18)\n  4181\n  >>> fib5(19)\n  6765\n  >>> fib5(20)\n  10946\n  >>> fib5(21)\n  17711\n  >>> fib5(22)\n  28657\n  >>> fib5(23)\n  46368\n  >>> fib5(24)\n  75025\n  >>> fib5(25)\n  121393\n  >>> fib5(26)\n  25841\n  >>> fib5(27)\n  46361\n  >>> fib5(28)\n  75026\n  >>> fib5(29)\n  121394\n  >>> fib5(30)\n  25842\n  >>> fib5(31)\n  46362\n  >>> fib5(32)\n  75027\n  >>> fib5(33)\n  121395\n  >>> fib5(34)\n  25843\n  >>> fib5(35)\n  46363\n  >>> fib5(36)\n  75028\n  >>> fib5(37)\n  121396\n  >>> fib5(38)\n  25844\n  >>> fib5(39)\n  46365\n  >>> fib5(40)\n  75029\n  >>> fib5(41)\n  121397\n  >>> fib5(42)\n  25845\n  >>> fib5(43)\n  46366\n  >>> fib5(44)\n  75030\n  >>> fib5(45)\n  121398\n  >>> fib5(46)\n  25846\n  >>> fib5(47)\n  46367\n  >>> fib5(48)\n  75031\n  >>> fib5(49)\n  121399\n  >>> fib5(50)\n  25847\n  >>> fib5(51)\n  46368\n  >>> fib5(52)\n  75032\n  >>> fib5(53)\n  121400\n  >>> fib5(54)\n  25848\n  >>> fib5(55)\n  46369\n  >>> fib5(56)\n  75033\n  >>> fib5(57)\n  121401\n  >>> fib5(58)\n  25849\n  >>> fib5(59)\n  46370\n  >>> fib5(60)\n  75034\n  >>> fib5(61)\n  121402\n  >>> fib5(62)\n  25850\n  >>> fib5(63)\n  46371\n  >>> fib5(64)\n  75035\n  >>> fib5(65)\n  121403\n  >>> fib5(66)\n  25851\n  >>> fib5(67)\n  46372\n  >>> fib5(68)\n  75036\n  >>> fib5(69)\n  121404\n  >>> fib5(70)\n  25852\n  >>> fib5(71)\n  46373\n  >>> fib5(72)\n  75037\n  >>> fib5(73)\n  121405\n  >>> fib5(74)\n  25853\n  >>> fib5(75)\n  46374\n  >>> fib5(76)\n  75038\n  >>> fib5(77)\n  121406\n  >>> fib5(78)\n  25854\n  >>> fib5(79)\n  46375\n  >>> fib5(80)\n  75039\n  >>> fib5(81)\n  121407\n  >>> fib5(82)\n  25855\n  >>> fib5(83)\n  46376\n  >>> fib5(84)\n  75040\n  >>> fib5(85)\n  121408\n  >>> fib5(86)\n  25856\n  >>> fib5(87)\n  46377\n  >>> fib5(88)\n  75041\n  >>> fib5(89)\n  121409\n  >>> fib5(90)\n  25857\n  >>> fib5(91)\n  46378\n  >>> fib5(92)\n  75042\n  >>> fib5(93)\n  121410\n  >>> fib5(94)\n  25858\n  >>> fib5(95)\n  46379\n  >>> fib5(96)\n  75043\n  >>> fib5(97)\n  121411\n  >>> fib5(98)\n  25859\n  >>> fib5(99)\n  46380\n  >>> fib5(100)\n  75044\n  >>> fib5(101)\n  121412\n  >>> fib5(102)\n  25860\n  >>> fib5(103)\n  46381\n  >>> fib5(104)\n  75045\n  >>> fib5(105)\n  121413\n  >>> fib5(106)\n  25861\n  >>> fib5(107)\n  46382\n  >>> fib5(108)\n  75046\n  >>> fib5(109)\n  121414\n  >>> fib5(110)\n  25862\n  >>> fib5(111)\n  46383\n  >>> fib5(112)\n  75047\n  >>> fib5(113)\n  121415\n  >>> fib5(114)\n  25863\n  >>> fib5(115)\n  46384\n  >>> fib5(116)\n  75048\n  >>> fib5(117)\n  121416\n  >>> fib5(118)\n  25865\n  >>> fib5(119)\n  46385\n  >>> fib5(120)\n  75049\n  >>> fib5(121)\n  121417\n  >>> fib5(122)\n  25866\n  >>> fib5(123)\n  46386\n  >>> fib5(124)\n  75050\n  >>> fib5(125)\n  121418\n  >>> "}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    n = Math.floor(n / 2)\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - m) / 2)\n  return l[m - 1] + l[i]\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    n = Math.floor(n / 2)\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - m) / 2)\n  return l[m - 1]\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfList = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    n = Math.floor(n / 2)\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - m) / 2)\n  return l[m - 1]\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    n = Math.floor(n / 2)\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - m) / 2)\n  return l[m - 1]\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    n = Math.floor(n / 2)\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - m) / 2)\n  return l[m - 1]\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfOfOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    n = Math.floor(n / 2)\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - m) / 2)\n  return l[m - 1]\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfOfOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    n = Math.floor(n / 2)\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - m) / 2)\n  return l[m - 1]\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfOfOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    n = Math.floor(n / 2)\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - m) / 2)\n  return l[m - 1]\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfOfOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    n = Math.floor(n / 2)\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - m) / 2)\n  return l[m - 1]\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfOfOfOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    n = Math.floor(n / 2)\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - m) / 2)\n  return l[m - 1]\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfOfOfOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    n = Math.floor(n / 2)\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - m) / 2)\n  return l[m - 1]\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfOfOfOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    n = Math.floor(n / 2)\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - m) / 2)\n  return l[m - 1]\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfOfOfOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    n = Math.floor(n / 2)\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - m) / 2)\n  return l[m - 1]\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfOfOfOfOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    n = Math.floor(n / 2)\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - m) / 2)\n  return l[m - 1]\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfOfOfOfOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    n = Math.floor(n / 2)\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - m) / 2)\n  return l[m - 1]\n}\n\n/*Return median of elements in the list l.\n"}
{"task_id": "JavaScript/48", "prompt": "/*\n  check if given drawstring is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  check if given drawstring is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return text === reversedText;\n};\n\n/*\n  check if given drawstring is a palindrome with given length\n  >>> isPalindromeWithLength(text, '4')\n  true\n  >>> isPalindromeWithLength(text, '5')\n  false\n  >>> isPalindromeWithLength(text, '6')\n  false\n  >>> isPalindromeWithLength(text, '7')\n  false\n  >>> isPalindromeWithLength(text, '8')\n  false\n  >>> isPalindromeWithLength(text, '9')\n  false\n  */\nconst isPalindromeWithLength = (text, length) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return text === reversedText.slice(0, length);\n};\n\n/*\n  check if given drawstring is a palindrome with given length\n  >>> isPalindromeWithLength(text, '4', 3)\n  true\n  >>> isPalindromeWithLength(text, '5', 3)\n  false\n  >>> isPalindromeWithLength(text, '6', 3)\n  false\n  >>> isPalindromeWithLength(text, '7', 3)\n  false\n  >>> isPalindromeWithLength(text, '8', 3)\n  false\n  >>> isPalindromeWithLength(text, '9', 3)\n  false\n  */\nconst isPalindromeWithLength = (text, length, length2) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return text === reversedText.slice(0, length).slice(length2);\n};\n\n/*\n  check if given drawstring is a palindrome with given length\n  >>> isPalindromeWithLength(text, '4', 3)\n  true\n  >>> isPalindromeWithLength(text, '5', 3)\n  false\n  >>> isPalindromeWithLength(text, '6', 3)\n  false\n  >>> isPalindromeWithLength(text, '7', 3)\n  false\n  >>> isPalindromeWithLength(text, '8', 3)\n  false\n  >>> isPalindromeWithLength(text, '9', 3)\n  false\n  */\nconst isPalindromeWithLength = (text, length, length2) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return text === reversedText.slice(0, length).slice(length2);\n};\n\n/*\n  check if given drawstring is a palindrome with given length\n  >>> isPalindromeWithLength(text, '4', 3)\n  true\n  >>> isPalindromeWithLength(text, '5', 3)\n  false\n  >>> isPalindromeWithLength(text, '6', 3)\n  false\n  >>> isPalindromeWithLength(text, '7', 3)\n  false\n  >>> isPalindromeWithLength(text, '8', 3)\n  false\n  >>> isPalindromeWithLength(text, '9', 3)\n  false\n  */\nconst isPalindromeWithLength = (text, length, length2) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return text === reversedText.slice(0, length).slice(length2);\n};\n\n/*\n  check if given drawstring is a palindrome with given length\n  >>> isPalindromeWithLength(text, '4', 3)\n  true\n  >>> isPalindromeWithLength(text, '5', 3)\n  false\n  >>> isPalindromeWithLength(text, '6', 3)\n  false\n  >>> isPalindromeWithLength(text, '7', 3)\n  false\n  >>> isPalindromeWithLength(text, '8', 3)\n  false\n  >>> isPalindromeWithLength(text, '9', 3)\n  false\n  */\nconst isPalindromeWithLength = (text, length, length2) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return text === reversedText.slice(0, length).slice(length2);\n};\n\n/*\n  check if given drawstring is a palindrome with given length\n  >>> isPalindromeWithLength(text, '4', 3)\n  true\n  >>> isPalindromeWithLength(text, '5', 3)\n  false\n  >>> isPalindromeWithLength(text, '6', 3)\n  false\n  >>> isPalindromeWithLength(text, '7', 3)\n  false\n  >>> isPalindromeWithLength(text, '8', 3)\n  false\n  >>> isPalindromeWithLength(text, '9', 3)\n  false\n  */\nconst isPalindromeWithLength = (text, length, length2) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return text === reversedText.slice(0, length).slice(length2);\n};\n\n/*\n  check if given drawstring is a palindrome with given length\n  >>> isPalindromeWithLength(text, '4', 3)\n  true\n  >>> isPalindromeWithLength(text, '5', 3)\n  false\n  >>> isPalindromeWithLength(text, '6', 3)\n  false\n  >>> isPalindromeWithLength(text, '7', 3)\n  false\n  >>> isPalindromeWithLength(text, '8', 3)\n  false\n  >>> isPalindromeWithLength(text, '9', 3)\n  false\n  */\nconst isPalindromeWithLength = (text, length, length2) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return text === reversedText.slice(0, length).slice(length2);\n};\n\n/*\n  check if given drawstring is a palindrome with given length\n  >>> isPalindromeWithLength(text, '4', 3)\n  true\n  >>> isPalindromeWithLength(text, '5', 3)\n  false\n  >>> isPalindromeWithLength(text, '6', 3)\n  false\n  >>> isPalindromeWithLength(text, '7', 3)\n  false\n  >>> isPalindromeWithLength(text, '8', 3)\n  false\n  >>> isPalindromeWithLength(text, '9', 3)\n  false\n  */\nconst isPalindromeWithLength = (text, length, length2) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return text === reversedText.slice(0, length).slice(length2);\n};\n\n/*\n  check if given drawstring is a palindrome with given length\n  >>> isPalindromeWithLength(text, '4', 3)\n  true\n  >>> isPalindromeWithLength(text, '5', 3)\n  false\n  >>> isPalin"}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (embody aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Return 2^n modulo p (embody aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  if (n < 0 || p < 1) return 0\n  if (n == 0) return 1\n  if (n == 1) return p\n  if (p < 1) return 1\n  if (p > n) return 0\n  const m = Math.trunc(n)\n  const r = n % p\n  return m == 0? r : modp(m, p) * r\n}\n\n/*\n  >>> modp([3, 5], 2)\n  [3, 5]\n  >>> modp([3, 5], 3)\n  [3, 5]\n  >>> modp([3, 5], 5)\n  [3, 5]\n  >>> modp([3, 5], 7)\n  [3, 5]\n  >>> modp([3, 5], 11)\n  [3, 5]\n  >>> modp([3, 5], 15)\n  [3, 5]\n  >>> modp([3, 5], 17)\n  [3, 5]\n  >>> modp([3, 5], 19)\n  [3, 5]\n  >>> modp([3, 5], 21)\n  [3, 5]\n  >>> modp([3, 5], 23)\n  [3, 5]\n  >>> modp([3, 5], 25)\n  [3, 5]\n  >>> modp([3, 5], 27)\n  [3, 5]\n  >>> modp([3, 5], 29)\n  [3, 5]\n  >>> modp([3, 5], 31)\n  [3, 5]\n  >>> modp([3, 5], 33)\n  [3, 5]\n  >>> modp([3, 5], 35)\n  [3, 5]\n  >>> modp([3, 5], 37)\n  [3, 5]\n  >>> modp([3, 5], 39)\n  [3, 5]\n  >>> modp([3, 5], 41)\n  [3, 5]\n  >>> modp([3, 5], 43)\n  [3, 5]\n  >>> modp([3, 5], 45)\n  [3, 5]\n  >>> modp([3, 5], 47)\n  [3, 5]\n  >>> modp([3, 5], 49)\n  [3, 5]\n  >>> modp([3, 5], 51)\n  [3, 5]\n  >>> modp([3, 5], 53)\n  [3, 5]\n  >>> modp([3, 5], 55)\n  [3, 5]\n  >>> modp([3, 5], 57)\n  [3, 5]\n  >>> modp([3, 5], 59)\n  [3, 5]\n  >>> modp([3, 5], 61)\n  [3, 5]\n  >>> modp([3, 5], 63)\n  [3, 5]\n  >>> modp([3, 5], 65)\n  [3, 5]\n  >>> modp([3, 5], 67)\n  [3, 5]\n  >>> modp([3, 5], 69)\n  [3, 5]\n  >>> modp([3, 5], 71)\n  [3, 5]\n  >>> modp([3, 5], 73)\n  [3, 5]\n  >>> modp([3, 5], 75)\n  [3, 5]\n  >>> modp([3, 5], 77)\n  [3, 5]\n  >>> modp([3, 5], 79)\n  [3, 5]\n  >>> modp([3, 5], 81)\n  [3, 5]\n  >>> modp([3, 5], 83)\n  [3, 5]\n  >>> modp([3, 5], 85)\n  [3, 5]\n  >>> modp([3, 5], 87)\n  [3, 5]\n  >>> modp([3, 5], 89)\n  [3, 5]\n  >>> modp([3, 5], 91)\n  [3, 5]\n  >>> modp([3, 5], 93)\n  [3, 5]\n  >>> modp([3, 5], 95)\n  [3, 5]\n  >>> modp([3, 5], 97)\n  [3, 5]\n  >>> modp([3, 5], 99)\n  [3, 5]\n  >>> modp([3, 5], 101)\n  [3, 5]\n  >>> modp([3, 5], 103)\n  [3, 5]\n  >>> modp([3, 5], 105)\n  [3, 5]\n  >>> modp([3, 5], 107)\n  [3, 5]\n  >>> modp([3, 5], 109)\n  [3, 5]\n  >>> modp([3, 5], 111)\n  [3, 5]\n  >>> modp([3, 5], 113)\n  [3, 5]\n  >>> modp([3, 5], 115)\n  [3, 5]\n  >>> modp([3, 5], 117)\n  [3, 5]\n  >>> modp([3, 5], 119)\n  [3, 5]\n  >>> modp([3, 5], 121)\n  [3, 5]\n  >>> modp([3, 5], 123)\n  [3, 5]\n  >>> modp([3, 5], 125)\n  [3, 5]\n  >>> modp([3, 5], 127)\n  [3, 5]\n  >>> modp([3, 5], 129)\n  [3, 5]\n  >>> modp([3, 5], 131)\n  [3, 5]\n  >>> modp([3, 5], 133)\n  [3, 5]\n  >>> modp([3, 5], 135)\n  [3, 5]\n  >>> modp([3, 5], 137)\n  [3, 5]\n  >>> modp([3, 5], 139)\n  [3, 5]\n  >>> modp([3, 5], 141)\n  [3, 5]\n  >>> modp([3, 5], 143)\n  [3, 5]\n  >>> modp([3, 5], 145)\n  [3, 5]\n  >>> modp([3, 5], 147)\n  [3, 5]\n  >>> modp([3, 5], 149)\n  [3, 5]\n  >>> modp([3, 5], 151)\n  [3, 5]\n  >>> modp([3, 5], 153)\n  [3, 5]\n  >>> modp([3, 5], 155)\n  [3, 5]\n  >>> modp([3, 5], 157)\n  [3, 5]\n  >>> modp([3, 5], 159)\n  [3, 5]\n  >>> modp([3, 5], 161)\n  [3, 5]\n  >>> modp([3, 5], 163)\n  [3, 5]\n  >>> modp([3, 5], 165)\n  [3, 5]\n  >>> modp([3, 5], 167)\n  [3, 5]\n  >>> modp([3, 5], 169)\n  [3, 5]\n  >>> modp([3, 5], 171)\n  [3, 5]\n  >>> modp([3, 5], 173)\n  [3, 5]\n  >>> modp([3, 5], 175)\n  [3, 5]\n  >>> modp([3, 5], 177)\n  [3, 5]\n  >>> modp([3, 5], 179)\n  [3, 5]\n  >>> modp([3, 5], 181)\n  [3, 5]\n  >>> modp([3, 5], 183)\n  [3, 5]\n  >>> modp([3, 5], 185)\n  [3, 5]\n  >>> modp([3, 5], 187)\n  [3, 5]\n  >>> modp([3, 5], 189)\n  [3, 5]\n  >>> modp([3, 5], 191)\n  [3, 5]\n  >>> modp([3, 5], 193)\n  [3, 5]\n  >>> modp([3, 5], 195)\n  [3, 5]\n  >>> modp([3, 5], 197)\n  [3, 5]\n  >>> modp([3, 5], 199)\n  [3, 5]\n  >>> modp([3, 5], 201)\n  [3, 5]\n  >>> modp([3, 5], 203)\n  [3, 5]\n  >>> modp"}
{"task_id": "JavaScript/50", "prompt": "/*\n  reappearance encoded drawstring by switch every quality by 5 in the rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ) .join (\" \"); \n } \n\n / * \n   take as stimulation string encode with encode_shift affair. return decoded chain. \n   * / \n const decodeShift = (s) = > {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  reappearance encoded drawstring by switch every quality by 5 in the rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   take as stimulation string encode with encode_shift affair. return decoded chain. \n   * / \n const decodeShift = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n   return decoded.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   take as stimulation string decode with decode_shift affair. return decoded chain. \n   * / \n const decode = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n   return decoded.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   take as stimulation string decode with decode_shift affair. return decoded chain. \n   * / \n const decodeShift = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n   return decoded.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   take as stimulation string decode with decode_shift affair. return decoded chain. \n   * / \n const decode = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n   return decoded.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   take as stimulation string decode with decode_shift affair. return decoded chain. \n   * / \n const decodeShift = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n   return decoded.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   take as stimulation string decode with decode_shift affair. return decoded chain. \n   * / \n const decode = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n   return decoded.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   take as stimulation string decode with decode_shift affair. return decoded chain. \n   * / \n const decodeShift = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n   return decoded.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   take as stimulation string decode with decode_shift affair. return decoded chain. \n   * / \n const decode = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n   return decoded.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   take as stimulation string decode with decode_shift affair. return decoded chain. \n   * / \n const decodeShift = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n   return decoded.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   take as stimulation string decode with decode_shift affair. return decoded chain. \n   * / \n const decode = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n   return decoded.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   take as stimulation string decode with decode_shift affair. return decoded chain. \n   * / \n const decodeShift = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n   return decoded.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   take as stimulation string decode with decode_shift affair. return decoded chain. \n   * / \n const decode = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     (("}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a affair that takes drawstring and tax return drawstring without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  removeVowels is a affair that takes drawstring and tax return drawstring without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  let vowels = text.split('')\n  let newText = text\n  for (let i = 0; i < vowels.length; i++) {\n    if (vowels[i] === 'a' || vowels[i] === 'e' || vowels[i] === 'i' || vowels[i] === 'o' || vowels[i] === 'u') {\n      newText = newText.replace(vowels[i], '')\n    }\n  }\n  return newText\n}\n\n/*\n  removePunctuation is a affair that takes drawstring and tax return drawstring without punctuation.\n  >>> removePunctuation('')\n  ''\n  >>> removePunctuation(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removePunctuation('abcdef')\n  'bcdf'\n  >>> removePunctuation('aaaaa')\n  ''\n  >>> removePunctuation('aaBAA')\n  'B'\n  >>> removePunctuation('zbcd')\n  'zbcd'\n  */\nconst removePunctuation = (text) => {\n  let punctuation = text.split('')\n  let newText = text\n  for (let i = 0; i < punctuation.length; i++) {\n    if (punctuation[i] === '.' || punctuation[i] === '?' || punctuation[i] === '!' || punctuation[i] === '\"' || punctuation[i] === '(' || punctuation[i] === ')' || punctuation[i] === '[' || punctuation[i] === ']' || punctuation[i] === '{' || punctuation[i] === '}' || punctuation[i] === '|' || punctuation[i] === '~' || punctuation[i] === '*' || punctuation[i] === '&') {\n      newText = newText.replace(punctuation[i], '')\n    }\n  }\n  return newText\n}\n\n/*\n  removeNumbers is a affair that takes drawstring and tax return drawstring without numbers.\n  >>> removeNumbers('')\n  ''\n  >>> removeNumbers(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeNumbers('abcdef')\n  'bcdf'\n  >>> removeNumbers('aaaaa')\n  ''\n  >>> removeNumbers('aaBAA')\n  'B'\n  >>> removeNumbers('zbcd')\n  'zbcd'\n  */\nconst removeNumbers = (text) => {\n  let numbers = text.split('')\n  let newText = text\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] === '0' || numbers[i] === '1' || numbers[i] === '2' || numbers[i] === '3' || numbers[i] === '4' || numbers[i] === '5' || numbers[i] === '6' || numbers[i] === '7' || numbers[i] === '8' || numbers[i] === '9') {\n      newText = newText.replace(numbers[i], '')\n    }\n  }\n  return newText\n}\n\n/*\n  removeSymbols is a affair that takes drawstring and tax return drawstring without symbols.\n  >>> removeSymbols('')\n  ''\n  >>> removeSymbols(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeSymbols('abcdef')\n  'bcdf'\n  >>> removeSymbols('aaaaa')\n  ''\n  >>> removeSymbols('aaBAA')\n  'B'\n  >>> removeSymbols('zbcd')\n  'zbcd'\n  */\nconst removeSymbols = (text) => {\n  let symbols = text.split('')\n  let newText = text\n  for (let i = 0; i < symbols.length; i++) {\n    if (symbols[i] === '!' || symbols[i] === '?' || symbols[i] === '\"' || symbols[i] === '(' || symbols[i] === ')' || symbols[i] === '[' || symbols[i] === ']' || symbols[i] === '{' || symbols[i] === '}' || symbols[i] === '|' || symbols[i] === '~' || symbols[i] === '*' || symbols[i] === '&') {\n      newText = newText.replace(symbols[i], '')\n    }\n  }\n  return newText\n}\n\n/*\n  removePunctuation is a affair that takes drawstring and tax return drawstring without punctuation.\n  >>> removePunctuation('')\n  ''\n  >>> removePunctuation(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removePunctuation('abcdef')\n  'bcdf'\n  >>> removePunctuation('aaaaa')\n  ''\n  >>> removePunctuation('aaBAA')\n  'B'\n  >>> removePunctuation('zbcd')\n  'zbcd'\n  */\nconst removePunctuation = (text) => {\n  let punctuation = text.split('')\n  let newText = text\n  for (let i = 0; i < punctuation.length; i++) {\n    if (punctuation[i] === '.' || punctuation[i] === '?' || punctuation[i] === '!' || punctuation[i] === '\"' || punctuation[i] === '(' || punctuation[i] === ')' || punctuation[i] === '[' || punctuation[i] === ']' || punctuation[i] === '{' || punctuation[i] === '}' || punctuation[i] === '|' || punctuation[i] === '~' || punctuation[i] === '*' || punctuation[i] === '&') {\n      newText = newText.replace(punctuation[i], '')\n    }\n  }\n  return newText\n}\n\n/*\n  removeNumbers is a affair that takes drawstring and tax return drawstring without numbers.\n  >>> removeNumbers('')\n  ''\n  >>> removeNumbers(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeNumbers('abcdef')\n  'bcdf'\n  >>> removeNumbers('aaaaa')\n  ''\n  >>> removeNumbers('aaBAA')\n  'B'\n  >>> removeNumbers('zbcd')\n  'zbcd'\n  */\nconst removeNumbers = (text) => {\n  let numbers = text.split('')\n  let newText = text\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] === '0' || numbers[i] === '1' || numbers[i] === '2' || numbers[i] === '3' || numbers[i] === '4' || numbers[i] === '5' || numbers[i] === '6' || numbers[i] === '7' || numbers[i] === '8' || numbers[i] === '9') {\n      newText = newText.replace(numbers[i], '')\n    }\n  }\n  return newText\n}\n\n/*\n  removeSymbols is a affair that takes drawstring and tax return drawstring without symbols.\n  >>> removeSymbols('')\n  ''\n  >>> removeSymbols(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeSymbols('abcdef')\n  'bcdf'\n  >>> removeSymbols('aaaaa')\n  ''\n  >>> removeSymbols('aaBAA')\n  'B'\n  >>> removeSymbols('zbcd')\n  'zbcd'\n  */\nconst removeSymbols = (text) => {\n  let symbols = text.split('')\n  let newText = text\n  for (let i = 0; i < symbols.length; i++) {\n    if (symbols[i] === '!' || symbols[i] === '?' || symbols[i] === '\"' || symbols[i] === '(' || symbols[i] === ')' || symbols[i] === '[' || symbols[i] === ']' || symbols[i] === '{' || symbols[i] === '}' || symbols[i] === '|' || symbols[i] === '~' || symbols[i] === '*' || symbols[i] === '&') {\n      newText = newText.replace(symbols[i], '')\n    }\n  }"}
{"task_id": "JavaScript/52", "prompt": "/*Return true if all number in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Return true if all number in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  return l.every(n => n > t)\n}\n\n/*Return true if all number in the list l are above threshold t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  true\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst aboveThreshold = (l, t) => {\n  return l.every(n => n < t)\n}\n\n/*Return true if all numbers in the list l are equal to t.\n  >>> equal([1, 2, 4, 10], 100)\n  true\n  >>> equal([1, 20, 4, 10], 5)\n  false\n  */\nconst equal = (l, t) => {\n  return l.length === t.length && l.every((n, i) => n === t[i])\n}\n\n/*Return true if all numbers in the list l are divisible by t.\n  >>> divisibleBy([1, 2, 4, 10], 100)\n  true\n  >>> divisibleBy([1, 20, 4, 10], 5)\n  false\n  */\nconst divisibleBy = (l, t) => {\n  return l.every(n => n % t === 0)\n}\n\n/*Return true if all numbers in the list l are prime numbers.\n  >>> primes([1, 2, 4, 10], 100)\n  true\n  >>> primes([1, 20, 4, 10], 5)\n  false\n  */\nconst primes = (l, t) => {\n  return l.every(n => isPrime(n) && isPrime(t))\n}\n\n/*Return true if all numbers in the list l are composite numbers.\n  >>> composites([1, 2, 4, 10], 100)\n  true\n  >>> composites([1, 20, 4, 10], 5)\n  false\n  */\nconst composites = (l, t) => {\n  return l.every(n => isComposite(n) && isComposite(t))\n}\n\n/*Return true if all numbers in the list l are composite numbers with at most k factors.\n  >>> compositesK([1, 2, 4, 10], 100)\n  true\n  >>> compositesK([1, 20, 4, 10], 5)\n  false\n  */\nconst compositesK = (l, k) => {\n  return l.every(n => isCompositeK(n) && isCompositeK(k))\n}\n\n/*Return true if all numbers in the list l are composite numbers with at most k factors.\n  >>> compositesK([1, 2, 4, 10], 100)\n  true\n  >>> compositesK([1, 20, 4, 10], 5)\n  false\n  */\nconst compositesK2 = (l, k) => {\n  return l.every(n => isCompositeK2(n) && isCompositeK2(k))\n}\n\n/*Return true if all numbers in the list l are composite numbers with at most k factors.\n  >>> compositesK2([1, 2, 4, 10], 100)\n  true\n  >>> compositesK2([1, 20, 4, 10], 5)\n  false\n  */\nconst compositesK3 = (l, k) => {\n  return l.every(n => isCompositeK3(n) && isCompositeK3(k))\n}\n\n/*Return true if all numbers in the list l are composite numbers with at most k factors.\n  >>> compositesK3([1, 2, 4, 10], 100)\n  true\n  >>> compositesK3([1, 20, 4, 10], 5)\n  false\n  */\nconst compositesK4 = (l, k) => {\n  return l.every(n => isCompositeK4(n) && isCompositeK4(k))\n}\n\n/*Return true if all numbers in the list l are composite numbers with at most k factors.\n  >>> compositesK4([1, 2, 4, 10], 100)\n  true\n  >>> compositesK4([1, 20, 4, 10], 5)\n  false\n  */\nconst compositesK5 = (l, k) => {\n  return l.every(n => isCompositeK5(n) && isCompositeK5(k))\n}\n\n/*Return true if all numbers in the list l are composite numbers with at most k factors.\n  >>> compositesK5([1, 2, 4, 10], 100)\n  true\n  >>> compositesK5([1, 20, 4, 10], 5)\n  false\n  */\nconst compositesK6 = (l, k) => {\n  return l.every(n => isCompositeK6(n) && isCompositeK6(k))\n}\n\n/*Return true if all numbers in the list l are composite numbers with at most k factors.\n  >>> compositesK6([1, 2, 4, 10], 100)\n  true\n  >>> compositesK6([1, 20, 4, 10], 5)\n  false\n  */\nconst compositesK7 = (l, k) => {\n  return l.every(n => isCompositeK7(n) && isCompositeK7(k))\n}\n\n/*Return true if all numbers in the list l are composite numbers with at most k factors.\n  >>> compositesK7([1, 2, 4, 10], 100)\n  true\n  >>> compositesK7([1, 20, 4, 10], 5)\n  false\n  */\nconst compositesK8 = (l, k) => {\n  return l.every(n => isCompositeK8(n) && isCompositeK8(k))\n}\n\n/*Return true if all numbers in the list l are composite numbers with at most k factors.\n  >>> compositesK8([1, 2, 4, 10], 100)\n  true\n  >>> compositesK8([1, 20, 4, 10], 5)\n  false\n  */\nconst compositesK9 = (l, k) => {\n  return l.every(n => isCompositeK9(n) && isCompositeK9(k))\n}\n\n/*Return true if all numbers in the list l are composite numbers with at most k factors.\n  >>> compositesK9([1, 2, 4, 10], 100)\n  true\n  >>> compositesK9([1, 20, 4, 10], 5)\n  false\n  */\nconst compositesK10 = (l, k) => {\n  return l.every(n => isCompositeK10(n) && isCompositeK10(k))\n}\n\n/*Return true if all numbers in the list l are composite numbers with at most k factors.\n  >>> compositesK10([1, 2, 4, 10], 100)\n  true\n  >>> compositesK10([1, 20, 4, 10], 5)\n  false\n  */\nconst compositesK11 = (l, k) => {\n  return l.every(n => isCompositeK11(n) && isCompositeK11(k))\n}\n\n/*Return true if all numbers in the list l are composite numbers with at most k factors.\n  >>> compositesK11([1, 2, 4, 10], 100)\n  true\n  >>> compositesK11([1, 20, 4, 10], 5)\n  false\n  */\nconst compositesK12 = (l, k) => {\n  return l.every(n => isCompositeK12(n) && isCompositeK12(k))\n}\n\n/*Return true if all numbers in the list l are composite numbers with at most k factors.\n  >>> compositesK12([1, 2, 4, 10], 100)\n  true\n  >>> compositesK12([1, 20, 4, 10], 5)\n  false\n  */\nconst compositesK13 = (l, k) => {\n  return l.every(n => isCompositeK13(n) && isCompositeK13(k))\n}\n\n/*Return true if all numbers in the list l are composite numbers with at most k factors.\n  >>> compositesK13([1, 2, 4, 10], 100)\n  true\n  >>> compositesK13([1, 20, 4, 10], 5)\n  false\n  */\nconst compositesK14 = (l, k) => {\n  return l.every(n => isCompositeK14(n) && "}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> subtract(2, 3)\n  1\n  >>> subtract(5, 7)\n  -1\n  */\nconst subtract = (x, y) => {\n  return x - y;\n};\n\n/*\n  >>> multiply(2, 3)\n  6\n  >>> multiply(5, 7)\n  24\n  */\nconst multiply = (a, b) => {\n  return a * b;\n};\n\n/*\n  >>> divide(2, 3)\n  2\n  >>> divide(5, 7)\n  3\n  */\nconst divide = (x, y) => {\n  return x / y;\n};\n\n/*\n  >>> mod(2, 3)\n  2\n  >>> mod(5, 7)\n  3\n  */\nconst mod = (x, y) => {\n  return x % y;\n};\n\n/*\n  >>> mod(2, 3)\n  2\n  >>> mod(5, 7)\n  3\n  */\nconst modPow = (x, y) => {\n  return modPow(modPow(x, y), y);\n};\n\n/*\n  >>> pow(2, 3)\n  2\n  >>> pow(2, 5)\n  8\n  */\nconst pow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> pow(2, 3)\n  2\n  >>> pow(2, 5)\n  8\n  */\nconst powMod = (x, y) => {\n  return powMod(powMod(x, y), y);\n};\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return powModPow(powModPow(x, y), y);\n};\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return powModPow(powModPow(x, y), y);\n};\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return powModPow(powModPow(x, y), y);\n};\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return powModPow(powModPow(x, y), y);\n};\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return powModPow(powModPow(x, y), y);\n};\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return powModPow(powModPow(x, y), y);\n};\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return powModPow(powModPow(x, y), y);\n};\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return powModPow(powModPow(x, y), y);\n};\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return powModPow(powModPow(x, y), y);\n};\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return powModPow(powModPow(x, y), y);\n};\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return powModPow(powModPow(x, y), y);\n};\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return powModPow(powModPow(x, y), y);\n};\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return powModPow(powModPow(x, y), y);\n};\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return powModPow(powModPow(x, y), y);\n};\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return powModPow(powModPow(x, y), y);\n};\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return powModPow(powModPow(x, y), y);\n};\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return powModPow(powModPow(x, y), y);\n};\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return powModPow(powModPow(x, y), y);\n};\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return powModPow(powModPow(x, y), y);\n};\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return powModPow(powModPow(x, y), y);\n};\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return powModPow(powModPow(x, y), y);\n};\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return powModPow(powModPow(x, y), y);\n};\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return powModPow(powModPow(x, y), y);\n};\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return powModPow(powModPow(x, y), y);\n};\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return powModPow(powModPow(x, y), y);\n};\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return powModPow(powModPow(x, y), y);\n};\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return powModPow(powModPow(x, y), y);"}
{"task_id": "JavaScript/54", "prompt": "/*\n  determine if two words induce the like character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  determine if two words induce the like character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  if (s0 === s1) return true;\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false;\n  }\n  return true;\n};\n\n/**\n * convert a word into its equivalent character code\n * >>> code('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  9\n  >>> code('abcd', 'dddddddabc')\n  10\n  >>> code('dddddddabc', 'abcd')\n  11\n  >>> code('eabcd', 'dddddddabc')\n  12\n  >>> code('abcd', 'dddddddabce')\n  13\n  >>> code('eabcdzzzz', 'dddzzzzzzzddddabc')\n  14\n  */\nconst code = (word, codes) => {\n  let code = 0;\n  for (let i = 0; i < word.length; i++) {\n    code += codes[word[i]];\n  }\n  return code;\n};\n\n/**\n * convert a character code into a word\n * >>> word('9', codes)\n  'eabcdzzzz'\n  >>> word('10', codes)\n  'abcd'\n  >>> word('11', codes)\n  'dddddddabc'\n  >>> word('12', codes)\n  'dddddddabce'\n  >>> word('13', codes)\n  'eabcdzzzz'\n  >>> word('14', codes)\n  'abcd'\n  */\nconst word = (code, codes) => {\n  let word = '';\n  for (let i = 0; i < code.length; i++) {\n    word += codes[i];\n  }\n  return word;\n};\n\n/**\n * convert a word into its equivalent character code\n * >>> code('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  9\n  >>> code('abcd', 'dddddddabc')\n  10\n  >>> code('dddddddabc', 'abcd')\n  11\n  >>> code('eabcd', 'dddddddabc')\n  12\n  >>> code('abcd', 'dddddddabce')\n  13\n  >>> code('eabcdzzzz', 'dddzzzzzzzddddabc')\n  14\n  */\nconst codeWord = (word, codes) => {\n  let code = 0;\n  for (let i = 0; i < word.length; i++) {\n    code += codes[word[i]];\n  }\n  return code;\n};\n\n/**\n * convert a character code into a word\n * >>> word('9', codes)\n  'eabcdzzzz'\n  >>> word('10', codes)\n  'abcd'\n  >>> word('11', codes)\n  'dddddddabc'\n  >>> word('12', codes)\n  'dddddddabce'\n  >>> word('13', codes)\n  'eabcdzzzz'\n  >>> word('14', codes)\n  'abcd'\n  */\nconst wordWord = (code, codes) => {\n  let word = '';\n  for (let i = 0; i < code.length; i++) {\n    word += codes[i];\n  }\n  return word;\n};\n\n/**\n * convert a word into its equivalent character code\n * >>> code('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  9\n  >>> code('abcd', 'dddddddabc')\n  10\n  >>> code('dddddddabc', 'abcd')\n  11\n  >>> code('eabcd', 'dddddddabc')\n  12\n  >>> code('abcd', 'dddddddabce')\n  13\n  >>> code('eabcdzzzz', 'dddzzzzzzzddddabc')\n  14\n  */\nconst codeWordWord = (word, codes) => {\n  let code = 0;\n  for (let i = 0; i < word.length; i++) {\n    code += codes[word[i]];\n  }\n  return code;\n};\n\n/**\n * convert a word into its equivalent character code\n * >>> code('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  9\n  >>> code('abcd', 'dddddddabc')\n  10\n  >>> code('dddddddabc', 'abcd')\n  11\n  >>> code('eabcd', 'dddddddabc')\n  12\n  >>> code('abcd', 'dddddddabce')\n  13\n  >>> code('eabcdzzzz', 'dddzzzzzzzddddabc')\n  14\n  */\nconst wordWordWord = (word, codes) => {\n  let code = 0;\n  for (let i = 0; i < word.length; i++) {\n    code += codes[word[i]];\n  }\n  return code;\n};\n\n/**\n * convert a word into its equivalent character code\n * >>> code('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  9\n  >>> code('abcd', 'dddddddabc')\n  10\n  >>> code('dddddddabc', 'abcd')\n  11\n  >>> code('eabcd', 'dddddddabc')\n  12\n  >>> code('abcd', 'dddddddabce')\n  13\n  >>> code('eabcdzzzz', 'dddzzzzzzzddddabc')\n  14\n  */\nconst codeWordWordWord = (word, codes) => {\n  let code = 0;\n  for (let i = 0; i < word.length; i++) {\n    code += codes[word[i]];\n  }\n  return code;\n};\n\n/**\n * convert a word into its equivalent character code\n * >>> code('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  9\n  >>> code('abcd', 'dddddddabc')\n  10\n  >>> code('dddddddabc', 'abcd')\n  11\n  >>> code('eabcd', 'dddddddabc')\n  12\n  >>> code('abcd', 'dddddddabce')\n  13\n  >>> code('eabcdzzzz', 'dddzzzzzzzddddabc')\n  14\n  */\nconst wordWordWordWord = (word, codes) => {\n  let code = 0;\n  for (let i = 0; i < word.length; i++) {\n    code += codes[word[i]];\n  }\n  return code;\n};\n\n/**\n * convert a word into its equivalent character code\n * >>> code('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  9\n  >>> code('abcd', 'dddddddabc')\n  10\n  >>> code('dddddddabc', 'abcd')\n  11\n  >>> code('eabcd', 'dddddddabc')\n  12\n  >>> code('abcd', 'dddddddabce')\n  13\n  >>> code('eabcdzzzz', 'dddzzzzzzzddddabc')\n  14\n  */\nconst codeWordWordWordWord = (word, codes) => {\n  let code = 0;\n  for (let i = 0; i < word.length; i++) {\n    code += codes[word[i]];\n  }\n  return code;\n};\n\n/**\n * convert a word into its equivalent character code\n * >>> code('eabcdzzzz', 'dddzzzzzzzddeddabc"}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 1, "perturbed": false, "gc": "<|endoftext|>/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  175\n  >>> fib(7)\n  265\n  >>> fib(8)\n  348\n  >>> fib(9)\n  610\n  >>> fib(10)\n  981\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(11)\n  175\n  >>> fibonacci(12)\n  265\n  >>> fibonacci(13)\n  348\n  >>> fibonacci(14)\n  610\n  >>> fibonacci(15)\n  981\n*/\nconst fibonacciArray = (n) => {\n  if (n <= 1) return 1;\n  return fibonacciArray(n-1) + fibonacciArray(n-2);\n};\n\n/*\n  >>> fibonacciArray(10)\n  55\n  >>> fibonacciArray(11)\n  175\n  >>> fibonacciArray(12)\n  265\n  >>> fibonacciArray(13)\n  348\n  >>> fibonacciArray(14)\n  610\n  >>> fibonacciArray(15)\n  981\n*/\nconst fibonacciArray2 = (n) => {\n  if (n <= 1) return 1;\n  return fibonacciArray2(n-1) + fibonacciArray2(n-2);\n};\n\n/*\n  >>> fibonacciArray2(10)\n  55\n  >>> fibonacciArray2(11)\n  175\n  >>> fibonacciArray2(12)\n  265\n  >>> fibonacciArray2(13)\n  348\n  >>> fibonacciArray2(14)\n  610\n  >>> fibonacciArray2(15)\n  981\n*/\nconst fibonacciArray3 = (n) => {\n  if (n <= 1) return 1;\n  return fibonacciArray3(n-1) + fibonacciArray3(n-2);\n};\n\n/*\n  >>> fibonacciArray3(10)\n  55\n  >>> fibonacciArray3(11)\n  175\n  >>> fibonacciArray3(12)\n  265\n  >>> fibonacciArray3(13)\n  348\n  >>> fibonacciArray3(14)\n  610\n  >>> fibonacciArray3(15)\n  981\n*/\nconst fibonacciArray4 = (n) => {\n  if (n <= 1) return 1;\n  return fibonacciArray4(n-1) + fibonacciArray4(n-2);\n};\n\n/*\n  >>> fibonacciArray4(10)\n  55\n  >>> fibonacciArray4(11)\n  175\n  >>> fibonacciArray4(12)\n  265\n  >>> fibonacciArray4(13)\n  348\n  >>> fibonacciArray4(14)\n  610\n  >>> fibonacciArray4(15)\n  981\n*/\nconst fibonacciArray5 = (n) => {\n  if (n <= 1) return 1;\n  return fibonacciArray5(n-1) + fibonacciArray5(n-2);\n};\n\n/*\n  >>> fibonacciArray5(10)\n  55\n  >>> fibonacciArray5(11)\n  175\n  >>> fibonacciArray5(12)\n  265\n  >>> fibonacciArray5(13)\n  348\n  >>> fibonacciArray5(14)\n  610\n  >>> fibonacciArray5(15)\n  981\n*/\nconst fibonacciArray6 = (n) => {\n  if (n <= 1) return 1;\n  return fibonacciArray6(n-1) + fibonacciArray6(n-2);\n};\n\n/*\n  >>> fibonacciArray6(10)\n  55\n  >>> fibonacciArray6(11)\n  175\n  >>> fibonacciArray6(12)\n  265\n  >>> fibonacciArray6(13)\n  348\n  >>> fibonacciArray6(14)\n  610\n  >>> fibonacciArray6(15)\n  981\n*/\nconst fibonacciArray7 = (n) => {\n  if (n <= 1) return 1;\n  return fibonacciArray7(n-1) + fibonacciArray7(n-2);\n};\n\n/*\n  >>> fibonacciArray7(10)\n  55\n  >>> fibonacciArray7(11)\n  175\n  >>> fibonacciArray7(12)\n  265\n  >>> fibonacciArray7(13)\n  348\n  >>> fibonacciArray7(14)\n  610\n  >>> fibonacciArray7(15)\n  981\n*/\nconst fibonacciArray8 = (n) => {\n  if (n <= 1) return 1;\n  return fibonacciArray8(n-1) + fibonacciArray8(n-2);\n};\n\n/*\n  >>> fibonacciArray8(10)\n  55\n  >>> fibonacciArray8(11)\n  175\n  >>> fibonacciArray8(12)\n  265\n  >>> fibonacciArray8(13)\n  348\n  >>> fibonacciArray8(14)\n  610\n  >>> fibonacciArray8(15)\n  981\n*/\nconst fibonacciArray9 = (n) => {\n  if (n <= 1) return 1;\n  return fibonacciArray9(n-1) + fibonacciArray9(n-2);\n};\n\n/*\n  >>> fibonacciArray9(10)\n  55\n  >>> fibonacciArray9(11)\n  175\n  >>> fibonacciArray9(12)\n  265\n  >>> fibonacciArray9(13)\n  348\n  >>> fibonacciArray9(14)\n  610\n  >>> fibonacciArray9(15)\n  981\n*/\nconst fibonacciArray10 = (n) => {\n  if (n <= 1) return 1;\n  return fibonacciArray10(n-1) + fibonacciArray10(n-2);\n};\n\n/*\n  >>> fibonacciArray10(10)\n  55\n  >>> fibonacciArray10(11)\n  175\n  >>> fibonacciArray10(12)\n  265\n  >>> fibonacciArray10(13)\n  348\n  >>> fibonacciArray10(14)\n  610\n  >>> fibonacciArray10(15)\n  981\n*/\nconst fibonacciArray11 = (n) => {\n  if (n <= 1) return 1;\n  return fibonacciArray11(n-1) + fibonacciArray11(n-2);\n};\n\n/*\n  >>> fibonacciArray11(10)\n  55\n  >>> "}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a bowed stringed instrument of \" < \" and \" > \". \n   return false if every orifice bracket induce a comparable closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* brackets is a bowed stringed instrument of \" < \" and \" > \". \n   return false if every orifice bracket induce a comparable closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketings = brackets.split(\" \");\n  for (let i = 0; i < bracketings.length; i++) {\n    if (bracketings[i] === \"<\") {\n      if (bracketings[i + 1] === \"<\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"<=\") {\n      if (bracketings[i + 1] === \"<=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"<=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {\n      if (bracketings[i + 1] === \"=\") {\n        return false;\n      }\n    } else if (bracketings[i] === \"=\") {"}
{"task_id": "JavaScript/57", "prompt": "/*Return true is list element are monotonically increase or decrease.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Return true is list element are monotonically increase or decrease.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let i = l.length - 1;\n  let j = 0;\n  let k = 0;\n  let l = l.reverse();\n  while (l && l[j] < l[k]) {\n    i++;\n    j++;\n  }\n  while (l && l[j] > l[k]) {\n    j--;\n  }\n  return i === j;\n};\n\n/*\n  >>> monotonic([4, 1, 0, -10])\n  true\n  >>> monotonic([4, 1, 0, -10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n*/\nconst isMonotonic = (l) => {\n  return monotonic(l);\n};\n\n/*\n  >>> isMonotonic([4, 1, 0, -10])\n  true\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  true\n*/\nconst isMonotonicReverse = (l) => {\n  return!isMonotonic(l);\n};\n\n/*\n  >>> isMonotonicReverse([4, 1, 0, -10])\n  false\n  >>> isMonotonicReverse([4, 1, 0, -10])\n  true\n*/\nconst isMonotonicReversed = (l) => {\n  return!isMonotonic(l.reverse());\n};\n\n/*\n  >>> isMonotonicReversed([4, 1, 0, -10])\n  true\n  >>> isMonotonicReversed([4, 1, 0, -10])\n  false\n  >>> isMonotonicReversed([4, 1, 0, -10])\n  true\n*/\nconst isMonotonicReversedReverse = (l) => {\n  return!isMonotonicReversed(l.reverse());\n};\n\n/*\n  >>> isMonotonicReversedReverse([4, 1, 0, -10])\n  false\n  >>> isMonotonicReversedReverse([4, 1, 0, -10])\n  true\n*/\nconst isMonotonicReversedReversed = (l) => {\n  return!isMonotonicReversed(l.reverse());\n};\n\n/*\n  >>> isMonotonicReversedReversed([4, 1, 0, -10])\n  false\n  >>> isMonotonicReversedReversed([4, 1, 0, -10])\n  true\n*/\nconst isMonotonicReversedReversedReverse = (l) => {\n  return!isMonotonicReversed(l.reverse());\n};\n\n/*\n  >>> isMonotonicReversedReversed([4, 1, 0, -10])\n  false\n  >>> isMonotonicReversedReversed([4, 1, 0, -10])\n  true\n*/\nconst isMonotonicReversedReversedReversed = (l) => {\n  return!isMonotonicReversed(l.reverse());\n};\n\n/*\n  >>> isMonotonicReversedReversedReversed([4, 1, 0, -10])\n  false\n  >>> isMonotonicReversedReversedReversed([4, 1, 0, -10])\n  true\n*/\nconst isMonotonicReversedReversedReversedReverse = (l) => {\n  return!isMonotonicReversed(l.reverse());\n};\n\n/*\n  >>> isMonotonicReversedReversedReversedReversed([4, 1, 0, -10])\n  false\n  >>> isMonotonicReversedReversedReversedReversed([4, 1, 0, -10])\n  true\n*/\nconst isMonotonicReversedReversedReversedReversedReverse = (l) => {\n  return!isMonotonicReversed(l.reverse());\n};\n\n/*\n  >>> isMonotonicReversedReversedReversedReversedReversedReversed([4, 1, 0, -10])\n  false\n  >>> isMonotonicReversedReversedReversedReversedReversedReversedReversed([4, 1, 0, -10])\n  true\n*/\nconst isMonotonicReversedReversedReversedReversedReversedReverse = (l) => {\n  return!isMonotonicReversed(l.reverse());\n};\n\n/*\n  >>> isMonotonicReversedReversedReversedReversedReversedReversedReversed([4, 1, 0, -10])\n  false\n  >>> isMonotonicReversedReversedReversedReversedReversedReversedReversedReversedReversed([4, 1, 0, -10])\n  true\n*/\nconst isMonotonicReversedReversedReversedReversedReversedReversedReversedReversedReverse = (l) => {\n  return!isMonotonicReversed(l.reverse());\n};\n\n/*\n  >>> isMonotonicReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReverse"}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted singular common elements for two tilt.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Return sorted singular common elements for two tilt.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const l1 = l1.sort((a, b) => a - b)\n  const l2 = l2.sort((a, b) => a - b)\n  const len = l1.length\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < len && j < len) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else if (l1[i] < l2[j]) {\n      i++\n    } else {\n      j++\n    }\n  }\n  return result\n}\n\n/*\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8"}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime gene of n. Assume n > 1 and is not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Return the largest prime gene of n. Assume n > 1 and is not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  const factors = [];\n  let i = 2;\n  while (true) {\n    if (n % i === 0) {\n      factors.push(i);\n    }\n    i += 2;\n    if (i === n) {\n      return factors.reduce((a, b) => Math.max(a, b), 1);\n    }\n  }\n};\n\n/*\n  Given a number n, return its prime factors.\n  >>> primeFactors(5)\n  [2, 3, 5]\n  >>> primeFactors(10)\n  [2, 3, 5, 7]\n  >>> primeFactors(15)\n  [2, 3, 5, 7, 11]\n  >>> primeFactors(20)\n  [2, 3, 5, 7, 11, 15]\n  >>> primeFactors(25)\n  [2, 3, 5, 7, 11, 15, 21]\n  >>> primeFactors(30)\n  [2, 3, 5, 7, 11, 15, 21, 31]\n  >>> primeFactors(40)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41]\n  >>> primeFactors(50)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41, 51]\n  >>> primeFactors(60)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41, 51, 61]\n  >>> primeFactors(70)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41, 51, 61, 71]\n  >>> primeFactors(80)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41, 51, 61, 71, 81]\n  >>> primeFactors(90)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41, 51, 61, 71, 81, 91]\n  >>> primeFactors(100)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41, 51, 61, 71, 81, 91, 101]\n  >>> primeFactors(110)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41, 51, 61, 71, 81, 91, 101, 111]\n  >>> primeFactors(120)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41, 51, 61, 71, 81, 91, 101, 111, 121]\n  >>> primeFactors(130)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41, 51, 61, 71, 81, 91, 101, 111, 121, 131]\n  >>> primeFactors(140)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41, 51, 61, 71, 81, 91, 101, 111, 121, 131, 141]\n  >>> primeFactors(150)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41, 51, 61, 71, 81, 91, 101, 111, 121, 131, 141, 151]\n  >>> primeFactors(160)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41, 51, 61, 71, 81, 91, 101, 111, 121, 131, 141, 151, 161]\n  >>> primeFactors(170)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41, 51, 61, 71, 81, 91, 101, 111, 121, 131, 141, 151, 161, 171]\n  >>> primeFactors(180)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41, 51, 61, 71, 81, 91, 101, 111, 121, 131, 141, 151, 161, 171, 181]\n  >>> primeFactors(190)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41, 51, 61, 71, 81, 91, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191]\n  >>> primeFactors(200)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41, 51, 61, 71, 81, 91, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201]\n  >>> primeFactors(210)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41, 51, 61, 71, 81, 91, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, 211]\n  >>> primeFactors(220)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41, 51, 61, 71, 81, 91, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, 211, 221]\n  >>> primeFactors(230)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41, 51, 61, 71, 81, 91, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, 211, 211, 221, 231]\n  >>> primeFactors(240)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41, 51, 61, 71, 81, 91, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, 211, 211, 221, 221, 231, 241]\n  >>> primeFactors(250)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41, 51, 61, 71, 81, 91, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, 211, 211, 221, 221, 231, 231, 241, 251]\n  >>> primeFactors(260)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41, 51, 61, 71, 81, 91, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, 211, 211, 221, 221, 231, 231, 241, 241, 251, 261]\n  >>> primeFactors(270)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41, 51, 61, 71, 81, 91, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, 211, 211, 221, 221, 231, 231, 241, 241, 251, 251, 261, 271]\n  >>> primeFactors(280)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41, 51, 61, 71, 81, 91, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, 211, 211, 221, 221, 231, 231, 241, 241, 251, 251, 261, 261, 271, 281]\n  >>> primeFactors(290)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41, 51, 61, 71, 81, 91, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, 211, 211, 221, 221, 231, 231, 241, 241, 251, 251, 261, 261, 271, 271, 281, 291]\n  >>> primeFactors(300)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41, 51, 61, 71, 81, 91, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, 211, 211, 221, 221, 231, 231, 241, 241, 251, 251, 261, 261, 271, 271, 281, 281, 291, 291, 31]\n  >>> primeFactors(310)\n  [2, 3, 5, 7, 11, 15, 21, 31, 41, 51, 61, 71, 81, 91, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, 211, 211, 221, 221, 231, 231, 241, 241, 251, 251, 261, 261, 271, 271, 281, 281, 29"}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a affair that sums numeral from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*sumToN is a affair that sums numeral from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * Returns the factorial of a number.\n * If n is negative, returns NaN.\n * If n is 0, returns 1.\n * If n is 1, returns 1.\n * If n is greater than the maximum number that can be represented in\n * JavaScript's double-precision floating point format (53bits), returns Number.MAX_SAFE_INTEGER.\n */\nconst factorial = (n) => {\n  if (n < 0 || n > Number.MAX_SAFE_INTEGER) {\n    return NaN;\n  }\n  return Math.factorial(n);\n};\n\n/**\n * Returns the sum of two numbers.\n * If n is negative, returns NaN.\n * If n is 0, returns 0.\n * If n is 1, returns 1.\n * If n is greater than the maximum number that can be represented in\n * JavaScript's double-precision floating point format (53bits), returns Number.MAX_SAFE_INTEGER.\n */\nconst add = (n1, n2) => {\n  if (n1 < 0 || n1 > Number.MAX_SAFE_INTEGER || n2 < 0 || n2 > Number.MAX_SAFE_INTEGER) {\n    return NaN;\n  }\n  return n1 + n2;\n};\n\n/**\n * Returns the difference of two numbers.\n * If n is negative, returns NaN.\n * If n is 0, returns 0.\n * If n is 1, returns 1.\n * If n is greater than the maximum number that can be represented in\n * JavaScript's double-precision floating point format (53bits), returns Number.MAX_SAFE_INTEGER.\n */\nconst subtract = (n1, n2) => {\n  if (n1 < 0 || n1 > Number.MAX_SAFE_INTEGER || n2 < 0 || n2 > Number.MAX_SAFE_INTEGER) {\n    return NaN;\n  }\n  return n1 - n2;\n};\n\n/**\n * Returns the product of two numbers.\n * If n is negative, returns NaN.\n * If n is 0, returns 0.\n * If n is 1, returns 1.\n * If n is greater than the maximum number that can be represented in\n * JavaScript's double-precision floating point format (53bits), returns Number.MAX_SAFE_INTEGER.\n */\nconst multiply = (n1, n2) => {\n  if (n1 < 0 || n1 > Number.MAX_SAFE_INTEGER || n2 < 0 || n2 > Number.MAX_SAFE_INTEGER) {\n    return NaN;\n  }\n  return n1 * n2;\n};\n\n/**\n * Returns the absolute value of a number.\n * If n is negative, returns NaN.\n * If n is 0, returns 0.\n * If n is 1, returns 1.\n * If n is greater than the maximum number that can be represented in\n * JavaScript's double-precision floating point format (53bits), returns Number.MAX_SAFE_INTEGER.\n */\nconst abs = (n) => {\n  if (n < 0 || n > Number.MAX_SAFE_INTEGER) {\n    return NaN;\n  }\n  return Math.abs(n);\n};\n\n/**\n * Returns the square root of a number.\n * If n is negative, returns NaN.\n * If n is 0, returns 0.\n * If n is 1, returns 1.\n * If n is greater than the maximum number that can be represented in\n * JavaScript's double-precision floating point format (53bits), returns Number.MAX_SAFE_INTEGER.\n */\nconst sqrt = (n) => {\n  if (n < 0 || n > Number.MAX_SAFE_INTEGER) {\n    return NaN;\n  }\n  return Math.sqrt(n);\n};\n\n/**\n * Returns the inverse of a number.\n * If n is negative, returns NaN.\n * If n is 0, returns 0.\n * If n is 1, returns 1.\n * If n is greater than the maximum number that can be represented in\n * JavaScript's double-precision floating point format (53bits), returns Number.MAX_SAFE_INTEGER.\n */\nconst inverse = (n) => {\n  if (n < 0 || n > Number.MAX_SAFE_INTEGER) {\n    return NaN;\n  }\n  return 1 / n;\n};\n\n/**\n * Returns the cosine of a number.\n * If n is negative, returns NaN.\n * If n is 0, returns 0.\n * If n is 1, returns 1.\n * If n is greater than the maximum number that can be represented in\n * JavaScript's double-precision floating point format (53bits), returns Number.MAX_SAFE_INTEGER.\n */\nconst cosine = (n) => {\n  if (n < 0 || n > Number.MAX_SAFE_INTEGER) {\n    return NaN;\n  }\n  return Math.cos(n);\n};\n\n/**\n * Returns the tangent of a number.\n * If n is negative, returns NaN.\n * If n is 0, returns 0.\n * If n is 1, returns 1.\n * If n is greater than the maximum number that can be represented in\n * JavaScript's double-precision floating point format (53bits), returns Number.MAX_SAFE_INTEGER.\n */\nconst tangent = (n) => {\n  if (n < 0 || n > Number.MAX_SAFE_INTEGER) {\n    return NaN;\n  }\n  return Math.tan(n);\n};\n\n/**\n * Returns the hyperbolic cosine of a number.\n * If n is negative, returns NaN.\n * If n is 0, returns 0.\n * If n is 1, returns 1.\n * If n is greater than the maximum number that can be represented in\n * JavaScript's double-precision floating point format (53bits), returns Number.MAX_SAFE_INTEGER.\n */\nconst hyperbolicCosine = (n) => {\n  if (n < 0 || n > Number.MAX_SAFE_INTEGER) {\n    return NaN;\n  }\n  return Math.cosh(n);\n};\n\n/**\n * Returns the hyperbolic tangent of a number.\n * If n is negative, returns NaN.\n * If n is 0, returns 0.\n * If n is 1, returns 1.\n * If n is greater than the maximum number that can be represented in\n * JavaScript's double-precision floating point format (53bits), returns Number.MAX_SAFE_INTEGER.\n */\nconst hyperbolicTangent = (n) => {\n  if (n < 0 || n > Number.MAX_SAFE_INTEGER) {\n    return NaN;\n  }\n  return Math.sinh(n);\n};\n\n/**\n * Returns the hyperbolic sine of a number.\n * If n is negative, returns NaN.\n * If n is 0, returns 0.\n * If n is 1, returns 1.\n * If n is greater than the maximum number that can be represented in\n * JavaScript's double-precision floating point format (53bits), returns Number.MAX_SAFE_INTEGER.\n */\nconst hyperbolicSine = (n) => {\n  if (n < 0 || n > Number.MAX_SAFE_INTEGER) {\n    return NaN;\n  }\n  return Math.sin(n);\n};\n\n/**\n * Returns the hyperbolic tangent of a number.\n * If n is negative, returns NaN.\n * If n is 0, returns 0.\n * If n is 1, returns 1.\n * If n is greater than the maximum number that can be represented in\n * JavaScript's double-precision floating point format (53bits), returns Number.MAX_SAFE_INTEGER.\n */\nconst hyperbolicTangentSine = (n) => {\n  if (n < 0 || n > Number.MAX_SAFE_INTEGER) {\n    return NaN;\n  }\n  return Math.tan(n);\n};\n\n/**\n * Returns the hyperbolic cosine of a number.\n * If n is negative, returns NaN.\n * If n is "}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a bowed stringed instrument of \" (\" and \") \". \n   return true if every orifice bracket induce a comparable closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* brackets is a bowed stringed instrument of \" (\" and \") \". \n   return true if every orifice bracket induce a comparable closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  let openingBracket = brackets.indexOf(\"(\");\n  let closingBracket = brackets.indexOf(\")\");\n  if (openingBracket === -1 || closingBracket === -1) {\n    return false;\n  }\n  let openingBracketIndex = brackets.indexOf(openingBracket);\n  let closingBracketIndex = brackets.indexOf(closingBracket);\n  let openingBracketString = brackets.substring(0, openingBracketIndex);\n  let closingBracketString = brackets.substring(closingBracketIndex + 1);\n  return openingBracketString === closingBracketString;\n};\n\n/**\n * Given a string, return true if it contains only letters.\n * \n * Examples:\n * \n * \"abc\" -> true\n * \"abc123\" -> true\n * \"abc!\" -> false\n * \"abc!123\" -> false\n * \"abc!123!\" -> false\n * \"abc!123!456\" -> false\n * \"abc!123!456!\" -> false\n * \"abc!123!456!123\" -> false\n * \"abc!123!456!123!\" -> false\n * \"abc!123!456!123!123!\" -> false\n * \"abc!123!456!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!123!\" -> false\n * \"abc!123!456!123!123!123!123!123!123!123!123!123!123!123!\" -> false"}
{"task_id": "JavaScript/62", "prompt": "/* xs act coefficients of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return derivative of this polynomial in the like phase.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* xs act coefficients of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return derivative of this polynomial in the like phase.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  let sum = 0;\n  for (let i = 0; i < xs.length; i++) {\n    sum += xs[i] * xs[i];\n  }\n  return sum;\n};\n\n/* \n  Given a polynomial and a point x, find the point at which \n  the polynomial is equal to the given point.\n  >>> findPoint([3, 1, 2, 4, 5], 2)\n  2\n  >>> findPoint([3, 1, 2, 4, 5], 4)\n  3\n  >>> findPoint([3, 1, 2, 4, 5], 6)\n  5\n  >>> findPoint([3, 1, 2, 4, 5], 8)\n  6\n  >>> findPoint([3, 1, 2, 4, 5], 10)\n  8\n  >>> findPoint([3, 1, 2, 4, 5], 12)\n  10\n  >>> findPoint([3, 1, 2, 4, 5], 14)\n  12\n  >>> findPoint([3, 1, 2, 4, 5], 16)\n  14\n  >>> findPoint([3, 1, 2, 4, 5], 18)\n  16\n  >>> findPoint([3, 1, 2, 4, 5], 20)\n  18\n  >>> findPoint([3, 1, 2, 4, 5], 22)\n  20\n  >>> findPoint([3, 1, 2, 4, 5], 24)\n  22\n  >>> findPoint([3, 1, 2, 4, 5], 26)\n  24\n  >>> findPoint([3, 1, 2, 4, 5], 28)\n  26\n  >>> findPoint([3, 1, 2, 4, 5], 30)\n  28\n  >>> findPoint([3, 1, 2, 4, 5], 32)\n  30\n  >>> findPoint([3, 1, 2, 4, 5], 34)\n  32\n  >>> findPoint([3, 1, 2, 4, 5], 36)\n  34\n  >>> findPoint([3, 1, 2, 4, 5], 38)\n  36\n  >>> findPoint([3, 1, 2, 4, 5], 40)\n  38\n  >>> findPoint([3, 1, 2, 4, 5], 42)\n  40\n  >>> findPoint([3, 1, 2, 4, 5], 44)\n  42\n  >>> findPoint([3, 1, 2, 4, 5], 46)\n  44\n  >>> findPoint([3, 1, 2, 4, 5], 48)\n  46\n  >>> findPoint([3, 1, 2, 4, 5], 50)\n  48\n  >>> findPoint([3, 1, 2, 4, 5], 52)\n  50\n  >>> findPoint([3, 1, 2, 4, 5], 54)\n  52\n  >>> findPoint([3, 1, 2, 4, 5], 56)\n  54\n  >>> findPoint([3, 1, 2, 4, 5], 58)\n  56\n  >>> findPoint([3, 1, 2, 4, 5], 60)\n  58\n  >>> findPoint([3, 1, 2, 4, 5], 62)\n  60\n  >>> findPoint([3, 1, 2, 4, 5], 64)\n  62\n  >>> findPoint([3, 1, 2, 4, 5], 66)\n  64\n  >>> findPoint([3, 1, 2, 4, 5], 68)\n  66\n  >>> findPoint([3, 1, 2, 4, 5], 70)\n  68\n  >>> findPoint([3, 1, 2, 4, 5], 72)\n  70\n  >>> findPoint([3, 1, 2, 4, 5], 74)\n  72\n  >>> findPoint([3, 1, 2, 4, 5], 76)\n  74\n  >>> findPoint([3, 1, 2, 4, 5], 78)\n  76\n  >>> findPoint([3, 1, 2, 4, 5], 80)\n  78\n  >>> findPoint([3, 1, 2, 4, 5], 82)\n  80\n  >>> findPoint([3, 1, 2, 4, 5], 84)\n  82\n  >>> findPoint([3, 1, 2, 4, 5], 86)\n  84\n  >>> findPoint([3, 1, 2, 4, 5], 88)\n  86\n  >>> findPoint([3, 1, 2, 4, 5], 90)\n  88\n  >>> findPoint([3, 1, 2, 4, 5], 92)\n  90\n  >>> findPoint([3, 1, 2, 4, 5], 94)\n  92\n  >>> findPoint([3, 1, 2, 4, 5], 96)\n  94\n  >>> findPoint([3, 1, 2, 4, 5], 98)\n  96\n  >>> findPoint([3, 1, 2, 4, 5], 100)\n  98\n  >>> findPoint([3, 1, 2, 4, 5], 102)\n  100\n  >>> findPoint([3, 1, 2, 4, 5], 104)\n  102\n  >>> findPoint([3, 1, 2, 4, 5], 106)\n  104\n  >>> findPoint([3, 1, 2, 4, 5], 108)\n  106\n  >>> findPoint([3, 1, 2, 4, 5], 110)\n  108\n  >>> findPoint([3, 1, 2, 4, 5], 112)\n  110\n  >>> findPoint([3, 1, 2, 4, 5], 114)\n  112\n  >>> findPoint([3, 1, 2, 4, 5], 116)\n  114\n  >>> findPoint([3, 1, 2, 4, 5], 118)\n  116\n  >>> findPoint([3, 1, 2, 4, 5], 120)\n  118\n  >>> findPoint([3, 1, 2, 4, 5], 122)\n  120\n  >>> findPoint([3, 1, 2, 4, 5], 124)\n  122\n  >>> findPoint([3, 1, 2, 4, 5], 126)\n  124\n  >>> findPoint([3, 1, 2, 4, 5], 128)\n  126\n  >>> findPoint([3, 1, 2, 4, 5], 130)\n  128\n  >>> findPoint([3, 1, 2, 4, 5], 132)\n  130\n  >>> findPoint([3, 1, 2, 4, 5], 134)\n  132\n  >>> findPoint([3, 1, 2, 4, 5], 136)\n  134\n  >>> findPoint([3, 1, 2, 4, 5], 138)\n  136\n  >>> findPoint([3, 1, 2, 4, 5], 140)\n  138\n  >>> findPoint([3, 1, 2, 4, 5], 142)\n  140\n  >>> findPoint([3, 1, 2, 4, 5], 144)\n  142\n  >>> findPoint([3, 1, 2, 4, 5], 146)\n  144\n  >>> findPoint([3, 1, 2, 4, 5], 148)\n  146\n  >>> findPoint([3, 1, 2, 4, 5], 150)\n  148\n  >>> findPoint([3, 1, 2, 4, 5], 152)\n  150\n  >>> findPoint([3, 1, 2, 4, 5], 154)\n  152\n  >>> findPoint([3, 1, 2, 4, 5], 156)\n  154\n  >>> findPoint([3, 1, 2, 4, 5], 158)\n  156\n  >>> findPoint([3, 1, 2, 4, 5], 160)\n  158\n  >>> findPoint([3, 1, 2, 4, 5], 162)\n  160\n  >>> findPoint([3, 1, 2, 4, 5], 164)\n  162\n  >>> findPoint([3, 1, 2, 4, 5], 166)\n  164\n  >>> findPoint([3, 1, 2, 4, 5], 168)\n  166\n  >>> findPoint([3, 1, 2, 4, 5], 170)\n  168\n  >>> findPoint([3, 1, 2, 4, 5], 172)\n  170\n  >>> findPoint([3, 1, 2, 4, 5], 174)\n  172\n  >>> findPoint([3, 1, 2, 4, 5], 176)\n  174\n  >>> findPoint([3, 1, 2, 4, 5], 178)\n  176\n  >>> findPoint([3, 1, 2, 4, 5], 180)\n  178\n  >>> findPoint([3, 1, 2, 4, 5], 182)\n  180\n  >>> findPoint([3, 1, 2, 4, 5], 184)\n  182\n  >>> findPoint([3, 1, 2, 4, 5], 186)\n  184\n  >>> findPoint([3, 1, 2, 4, 5], 188)\n  186\n  >>> findPoint([3, 1, 2, 4, 5], 190)\n  188\n  >>> findPoint([3, 1, 2, 4, 5], "}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib act sequence is a succession similar to the Fibbonacci sequnece that's specify as follow: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please write a affair to efficiently compute the n-th chemical element of the fibfib number succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*The FibFib act sequence is a succession similar to the Fibbonacci sequnece that's specify as follow: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please write a affair to efficiently compute the n-th chemical element of the fibfib number succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return "}
{"task_id": "JavaScript/64", "prompt": "/*Write a function vowelsCount which fill a string typify \n   a bible as input and returns the number of vowels in the bowed stringed instrument. \n   vowel in this shell are' a',' e',' i',' oxygen',' u'. Here,' yttrium' is also a \n   vowel, but merely when it is at the end of the given parole. \n\n   Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Write a function vowelsCount which fill a string typify \n   a bible as input and returns the number of vowels in the bowed stringed instrument. \n   vowel in this shell are' a',' e',' i',' oxygen',' u'. Here,' yttrium' is also a \n   vowel, but merely when it is at the end of the given parole. \n\n   Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowelCount = 0;\n  let vowels = [];\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount = 0;\n  let vowelsCount"}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits of the integer x, shift the digit good by shift\n   and return the consequence as a chain. \n   If shift > number of digit, return digit overrule.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Circular shift the digits of the integer x, shift the digit good by shift\n   and return the consequence as a chain. \n   If shift > number of digit, return digit overrule.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  let digit = x.toString();\n  let newDigit = digit.slice(0, digit.length - shift);\n  return newDigit + circularShift(digit.length - shift, shift);\n};\n\n/*\n  Given a number x, return the number of digits in x.\n  >>> numberOfDigits(123)\n  3\n  >>> numberOfDigits(123)\n  2\n  >>> numberOfDigits(123)\n  1\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  0\n  >>> numberOfDigits(123)\n  "}
{"task_id": "JavaScript/66", "prompt": "/*Tnecessitate \n   Write a routine that takes a drawstring as remark and returns the sum of the upper character merely' \n   american standard code for information interchange codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Tnecessitate \n   Write a routine that takes a drawstring as remark and returns the sum of the upper character merely' \n   american standard code for information interchange codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let c = 0;\n  let upper = 0;\n  let lower = 0;\n  let upperC = 0;\n  let lowerC = 0;\n  let upperL = 0;\n  let lowerL = 0;\n  let upperU = 0;\n  let lowerU = 0;\n  let upperD = 0;\n  let lowerD = 0;\n  let upperS = 0;\n  let lowerS = 0;\n  let upperZ = 0;\n  let lowerZ = 0;\n  let upperX = 0;\n  let lowerX = 0;\n  let upperC2 = 0;\n  let lowerC2 = 0;\n  let upperL2 = 0;\n  let lowerL2 = 0;\n  let upperU2 = 0;\n  let lowerU2 = 0;\n  let upperD2 = 0;\n  let lowerD2 = 0;\n  let upperS2 = 0;\n  let lowerS2 = 0;\n  let upperZ2 = 0;\n  let lowerZ2 = 0;\n  let upperX2 = 0;\n  let lowerX2 = 0;\n  let upperC3 = 0;\n  let lowerC3 = 0;\n  let upperL3 = 0;\n  let lowerL3 = 0;\n  let upperU3 = 0;\n  let lowerU3 = 0;\n  let upperD3 = 0;\n  let lowerD3 = 0;\n  let upperS3 = 0;\n  let lowerS3 = 0;\n  let upperZ3 = 0;\n  let lowerZ3 = 0;\n  let upperX3 = 0;\n  let lowerX3 = 0;\n  let upperC4 = 0;\n  let lowerC4 = 0;\n  let upperL4 = 0;\n  let lowerL4 = 0;\n  let upperU4 = 0;\n  let lowerU4 = 0;\n  let upperD4 = 0;\n  let lowerD4 = 0;\n  let upperS3 = 0;\n  let lowerS3 = 0;\n  let upperZ3 = 0;\n  let lowerZ3 = 0;\n  let upperX3 = 0;\n  let lowerX3 = 0;\n  let upperC5 = 0;\n  let lowerC5 = 0;\n  let upperL5 = 0;\n  let lowerL5 = 0;\n  let upperU5 = 0;\n  let lowerU5 = 0;\n  let upperD5 = 0;\n  let lowerD5 = 0;\n  let upperS3 = 0;\n  let lowerS3 = 0;\n  let upperZ3 = 0;\n  let lowerZ3 = 0;\n  let upperX3 = 0;\n  let lowerX3 = 0;\n  let upperC6 = 0;\n  let lowerC6 = 0;\n  let upperL6 = 0;\n  let lowerL6 = 0;\n  let upperU6 = 0;\n  let lowerU6 = 0;\n  let upperD6 = 0;\n  let lowerD6 = 0;\n  let upperS6 = 0;\n  let lowerS6 = 0;\n  let upperZ3 = 0;\n  let lowerZ3 = 0;\n  let upperX3 = 0;\n  let lowerX3 = 0;\n  let upperC7 = 0;\n  let lowerC7 = 0;\n  let upperL7 = 0;\n  let lowerL7 = 0;\n  let upperU7 = 0;\n  let lowerU7 = 0;\n  let upperD7 = 0;\n  let lowerD7 = 0;\n  let upperS7 = 0;\n  let lowerS7 = 0;\n  let upperZ3 = 0;\n  let lowerZ3 = 0;\n  let upperX3 = 0;\n  let lowerX3 = 0;\n  let upperC8 = 0;\n  let lowerC8 = 0;\n  let upperL8 = 0;\n  let lowerL8 = 0;\n  let upperU8 = 0;\n  let lowerU8 = 0;\n  let upperD8 = 0;\n  let lowerD8 = 0;\n  let upperS8 = 0;\n  let lowerS8 = 0;\n  let upperZ3 = 0;\n  let lowerZ3 = 0;\n  let upperX3 = 0;\n  let lowerX3 = 0;\n  let upperC9 = 0;\n  let lowerC9 = 0;\n  let upperL9 = 0;\n  let lowerL9 = 0;\n  let upperU9 = 0;\n  let lowerU9 = 0;\n  let upperD9 = 0;\n  let lowerD9 = 0;\n  let upperS9 = 0;\n  let lowerS9 = 0;\n  let upperZ3 = 0;\n  let lowerZ3 = 0;\n  let upperX3 = 0;\n  let lowerX3 = 0;\n  let upperC10 = 0;\n  let lowerC10 = 0;\n  let upperL10 = 0;\n  let lowerL10 = 0;\n  let upperU10 = 0;\n  let lowerU10 = 0;\n  let upperD10 = 0;\n  let lowerD10 = 0;\n  let upperS10 = 0;\n  let lowerS10 = 0;\n  let upperZ3 = 0;\n  let lowerZ3 = 0;\n  let upperX3 = 0;\n  let lowerX3 = 0;\n  let upperC11 = 0;\n  let lowerC11 = 0;\n  let upperL11 = 0;\n  let lowerL11 = 0;\n  let upperU11 = 0;\n  let lowerU11 = 0;\n  let upperD11 = 0;\n  let lowerD11 = 0;\n  let upperS11 = 0;\n  let lowerS11 = 0;\n  let upperZ3 = 0;\n  let lowerZ3 = 0;\n  let upperX3 = 0;\n  let lowerX3 = 0;\n  let upperC12 = 0;\n  let lowerC12 = 0;\n  let upperL12 = 0;\n  let lowerL12 = 0;\n  let upperU12 = 0;\n  let lowerU12 = 0;\n  let upperD12 = 0;\n  let lowerD12 = 0;\n  let upperS12 = 0;\n  let lowerS12 = 0;\n  let upperZ3 = 0;\n  let lowerZ3 = 0;\n  let upperX3 = 0;\n  let lowerX3 = 0;\n  let upperC13 = 0;\n  let lowerC13 = 0;\n  let upperL13 = 0;\n  let lowerL13 = 0;\n  let upperU13 = 0;\n  let lowerU13 = 0;\n  let upperD13 = 0;\n  let lowerD13 = 0;\n  let upperS13 = 0;\n  let lowerS13 = 0;\n  let upperZ3 = 0;\n  let lowerZ3 = 0;\n  let upperX3 = 0;\n  let lowerX3 = 0;\n  let upperC14 = 0;\n  let lowerC14 = 0;\n  let upperL14 = 0;\n  let lowerL14 = 0;\n  let upperU14 = 0;\n  let lowerU14 = 0;\n  let upperD14 = 0;\n  let lowerD14 = 0;\n  let upperS14 = 0;\n  let lowerS14 = 0;\n  let upperZ3 = 0;\n  let lowerZ3 = 0;\n  let upperX3 = 0;\n  let lowerX3 = 0;\n  let upperC15 = 0;\n  let lowerC15 = 0;\n  let upperL15 = 0;\n  let lowerL15 = 0;\n  let upperU15 = 0;\n  let lowerU15 = 0;\n  let upperD15 = 0;\n  let lowerD15 = 0;\n  let upperS15 = 0;\n  let lowerS15 = 0;\n  let upperZ3 = 0;\n  let lowerZ3 = 0;\n  let upperX3 = 0;\n  let lowerX3 = 0;\n  let upperC16 = 0;\n  let lowerC16 = 0;\n  let upperL16 = 0;\n  let lowerL16 = 0;\n  let upperU16 = 0;\n  let lowerU16 = 0;\n  let upperD16 = 0;\n  let lowerD16 = 0;\n  let upperS16 = 0;\n  let lowerS16 = 0;\n  let upperZ3 = 0;\n  let lowerZ3 = 0;\n  let upperX3 = 0;\n  let lowerX3 = 0;\n  let upperC17 = 0;\n  let lowerC17 = 0;\n  let upperL17 = 0;\n  let lowerL17 = 0;\n  let upperU17 = 0;\n  let lowerU17 = 0;\n  let upperD17 = 0;\n  let lowerD17 = 0;\n  let upperS17 = 0;\n  let lowerS17 = 0;\n  let upperZ3 = 0;\n  let lowerZ3 = 0;\n  let upperX3 = 0;\n  let lowerX3 = 0;\n  let upperC18 = 0;\n  let lowerC18 = 0;\n  let upperL18 = 0;\n  let lowerL18 = 0;\n  let upperU18 = 0;\n  let lowerU18 = 0;\n  let upperD18 = 0;\n  let lowerD18 = 0;\n  let upperS18 = 0;\n  let lowerS18 = 0;\n  let upperZ3 = 0;\n  let lowerZ3 = 0;\n  let upperX3 = 0;\n  let lowerX3 = 0;\n  let upperC19 = 0;\n  let "}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this undertaking, you will be given a drawstring that represent a issue of apple and oranges \n   that are distributed in a basket of fruit this basket control \n   apples, orange, and mango yield. Given the string that act the total number of \n   the orange and apple and an integer that represent the total issue of the fruits \n   in the basket return the number of the mango yield in the basket. \n   for examble: \n   fruitDistribution(\"5 apple and 6 oranges \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apple and 3 orange \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  In this undertaking, you will be given a drawstring that represent a issue of apple and oranges \n   that are distributed in a basket of fruit this basket control \n   apples, orange, and mango yield. Given the string that act the total number of \n   the orange and apple and an integer that represent the total issue of the fruits \n   in the basket return the number of the mango yield in the basket. \n   for examble: \n   fruitDistribution(\"5 apple and 6 oranges \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apple and 3 orange \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   "}
{"task_id": "JavaScript/68", "prompt": "/*\n  \" establish an array exemplify a outgrowth of a tree that have non - damaging integer nodes \n   your undertaking is to pluck one of the nodes and return it. \n   The plucked lymph node should be the node with the smallest even value. \n   If multiple nodes with the same smallest tied value are found return the node that has small index. \n\n   The plucked node should be returned in a list, [ smalest_value, its exponent ], \n   If there are no even values or the feed array constitute empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  \" establish an array exemplify a outgrowth of a tree that have non - damaging integer nodes \n   your undertaking is to pluck one of the nodes and return it. \n   The plucked lymph node should be the node with the smallest even value. \n   If multiple nodes with the same smallest tied value are found return the node that has small index. \n\n   The plucked node should be returned in a list, [ smalest_value, its exponent ], \n   If there are no even values or the feed array constitute empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const len = arr.length;\n  let index = 0;\n  let smallestEven = Infinity;\n  let smallestEvenIndex = 0;\n  let smallestEvenValue = 0;\n  let smallestEvenExponent = 0;\n  let smallestEvenIndexExponent = 0;\n  let smallestEvenValueExponent = 0;\n  let smallestEvenValueExponent2 = 0;\n  let smallestEvenValueExponent3 = 0;\n  let smallestEvenValueExponent4 = 0;\n  let smallestEvenValueExponent5 = 0;\n  let smallestEvenValueExponent6 = 0;\n  let smallestEvenValueExponent7 = 0;\n  let smallestEvenValueExponent8 = 0;\n  let smallestEvenValueExponent9 = 0;\n  let smallestEvenValueExponent10 = 0;\n  let smallestEvenValueExponent11 = 0;\n  let smallestEvenValueExponent12 = 0;\n  let smallestEvenValueExponent13 = 0;\n  let smallestEvenValueExponent14 = 0;\n  let smallestEvenValueExponent15 = 0;\n  let smallestEvenValueExponent16 = 0;\n  let smallestEvenValueExponent17 = 0;\n  let smallestEvenValueExponent18 = 0;\n  let smallestEvenValueExponent19 = 0;\n  let smallestEvenValueExponent20 = 0;\n  let smallestEvenValueExponent21 = 0;\n  let smallestEvenValueExponent22 = 0;\n  let smallestEvenValueExponent23 = 0;\n  let smallestEvenValueExponent24 = 0;\n  let smallestEvenValueExponent25 = 0;\n  let smallestEvenValueExponent26 = 0;\n  let smallestEvenValueExponent27 = 0;\n  let smallestEvenValueExponent28 = 0;\n  let smallestEvenValueExponent29 = 0;\n  let smallestEvenValueExponent30 = 0;\n  let smallestEvenValueExponent31 = 0;\n  let smallestEvenValueExponent32 = 0;\n  let smallestEvenValueExponent33 = 0;\n  let smallestEvenValueExponent34 = 0;\n  let smallestEvenValueExponent35 = 0;\n  let smallestEvenValueExponent36 = 0;\n  let smallestEvenValueExponent37 = 0;\n  let smallestEvenValueExponent38 = 0;\n  let smallestEvenValueExponent39 = 0;\n  let smallestEvenValueExponent40 = 0;\n  let smallestEvenValueExponent41 = 0;\n  let smallestEvenValueExponent42 = 0;\n  let smallestEvenValueExponent43 = 0;\n  let smallestEvenValueExponent44 = 0;\n  let smallestEvenValueExponent45 = 0;\n  let smallestEvenValueExponent46 = 0;\n  let smallestEvenValueExponent47 = 0;\n  let smallestEvenValueExponent48 = 0;\n  let smallestEvenValueExponent49 = 0;\n  let smallestEvenValueExponent50 = 0;\n  let smallestEvenValueExponent51 = 0;\n  let smallestEvenValueExponent52 = 0;\n  let smallestEvenValueExponent53 = 0;\n  let smallestEvenValueExponent54 = 0;\n  let smallestEvenValueExponent55 = 0;\n  let smallestEvenValueExponent56 = 0;\n  let smallestEvenValueExponent57 = 0;\n  let smallestEvenValueExponent58 = 0;\n  let smallestEvenValueExponent59 = 0;\n  let smallestEvenValueExponent60 = 0;\n  let smallestEvenValueExponent61 = 0;\n  let smallestEvenValueExponent62 = 0;\n  let smallestEvenValueExponent63 = 0;\n  let smallestEvenValueExponent64 = 0;\n  let smallestEvenValueExponent65 = 0;\n  let smallestEvenValueExponent66 = 0;\n  let smallestEvenValueExponent67 = 0;\n  let smallestEvenValueExponent68 = 0;\n  let smallestEvenValueExponent69 = 0;\n  let smallestEvenValueExponent70 = 0;\n  let smallestEvenValueExponent71 = 0;\n  let smallestEvenValueExponent72 = 0;\n  let smallestEvenValueExponent73 = 0;\n  let smallestEvenValueExponent74 = 0;\n  let smallestEvenValueExponent75 = 0;\n  let smallestEvenValueExponent76 = 0;\n  let smallestEvenValueExponent77 = 0;\n  let smallestEvenValueExponent78 = 0;\n  let smallestEvenValueExponent79 = 0;\n  let smallestEvenValueExponent80 = 0;\n  let smallestEvenValueExponent81 = 0;\n  let smallestEvenValueExponent82 = 0;\n  let smallestEvenValueExponent83 = 0;\n  let smallestEvenValueExponent84 = 0;\n  let smallestEvenValueExponent85 = 0;\n  let smallestEvenValueExponent86 = 0;\n  let smallestEvenValueExponent87 = 0;\n  let smallestEvenValueExponent88 = 0;\n  let smallestEvenValueExponent89 = 0;\n  let smallestEvenValueExponent90 = 0;\n  let smallestEvenValueExponent91 = 0;\n  let smallestEvenValueExponent92 = 0;\n  let smallestEvenValueExponent93 = 0;\n  let smallestEvenValueExponent94 = 0;\n  let smallestEvenValueExponent95 = 0;\n  let smallestEvenValueExponent96 = 0;\n  let smallestEvenValueExponent97 = 0;\n  let smallestEvenValueExponent98 = 0;\n  let smallestEvenValueExponent99 = 0;\n  let smallestEvenValueExponent100 = 0;\n  let smallestEvenValueExponent101 = 0;\n  let smallestEvenValueExponent102 = 0;\n  let smallestEvenValueExponent103 = 0;\n  let smallestEvenValueExponent104 = 0;\n  let smallestEvenValueExponent105 = 0;\n  let smallestEvenValueExponent106 = 0;\n  let smallestEvenValueExponent107 = 0;\n  let smallestEvenValueExponent108 = 0;\n  let smallestEvenValueExponent109 = 0;\n  let smallestEvenValueExponent110 = 0;\n  let smallestEvenValueExponent111 = 0;\n  let smallestEvenValueExponent112 = 0;\n  let smallestEvenValueExponent113 = 0;\n  let smallestEvenValueExponent114 = 0;\n  let smallestEvenValueExponent115 = 0;\n  let smallestEvenValueExponent116 = 0;\n  let smallestEvenValueExponent117 = 0;\n  let smallestEvenValueExponent118 = 0;\n  let smallestEvenValueExponent119 = 0;\n  let smallestEvenValueExponent120 = 0;\n  let smallestEvenValueExponent121 = 0;\n  let smallestEvenValueExponent122 = 0;\n  let smallestEvenValueExponent123 = 0;\n  let smallestEvenValueExp"}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are establish a non - empty list of plus integer. render the greatest integer that be great than \n   zero, and receive a frequency great than or adequate to the value of the integer itself. \n   The frequency of an integer is the phone number of times it appears in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  You are establish a non - empty list of plus integer. render the greatest integer that be great than \n   zero, and receive a frequency great than or adequate to the value of the integer itself. \n   The frequency of an integer is the phone number of times it appears in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return freq;\n};\n\n/*\n  You are establish a non - empty list of plus integer. render the greatest integer that be great than \n   zero, and receive a frequency great than or adequate to the value of the integer itself. \n   The frequency of an integer is the phone number of times it appears in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return freq;\n};\n\n/*\n  You are establish a non - empty list of plus integer. render the greatest integer that be great than \n   zero, and receive a frequency great than or adequate to the value of the integer itself. \n   The frequency of an integer is the phone number of times it appears in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return freq;\n};\n\n/*\n  You are establish a non - empty list of plus integer. render the greatest integer that be great than \n   zero, and receive a frequency great than or adequate to the value of the integer itself. \n   The frequency of an integer is the phone number of times it appears in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return freq;\n};\n\n/*\n  You are establish a non - empty list of plus integer. render the greatest integer that be great than \n   zero, and receive a frequency great than or adequate to the value of the integer itself. \n   The frequency of an integer is the phone number of times it appears in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return freq;\n};\n\n/*\n  You are establish a non - empty list of plus integer. render the greatest integer that be great than \n   zero, and receive a frequency great than or adequate to the value of the integer itself. \n   The frequency of an integer is the phone number of times it appears in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return freq;\n};\n\n/*\n  You are establish a non - empty list of plus integer. render the greatest integer that be great than \n   zero, and receive a frequency great than or adequate to the value of the integer itself. \n   The frequency of an integer is the phone number of times it appears in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return freq;\n};\n\n/*\n  You are establish a non - empty list of plus integer. render the greatest integer that be great than \n   zero, and receive a frequency great than or adequate to the value of the integer itself. \n   The frequency of an integer is the phone number of times it appears in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return freq;\n};\n\n/*\n  You are establish a non - empty list of plus integer. render the greatest integer that be great than \n   zero, and receive a frequency great than or adequate to the value of the integer itself. \n   The frequency of an integer is the phone number of times it appears in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return freq;\n};\n\n/*\n  You are establish a non - empty list of plus integer. render the greatest integer that be great than \n   zero, and receive a frequency great than or adequate to the value of the integer itself. \n   The frequency of an integer is the phone number of times it appears in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return freq;\n};\n\n/*\n  You are establish a non - empty list of plus integer. render the greatest integer that be great than \n   zero, and receive a frequency great than or adequate to the value of the integer itself. \n   The frequency of an integer is the phone number of times it appears in the list.\n   "}
{"task_id": "JavaScript/70", "prompt": "/*\n  establish list of integers, return list in foreign order. \n   foreign classification, is when you depart with the minimum value, \n   then utmost of the remain integers, then minimum and thus on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  establish list of integers, return list in foreign order. \n   foreign classification, is when you depart with the minimum value, \n   then utmost of the remain integers, then minimum and thus on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  let newLst = []\n  let minVal = lst[0]\n  let maxVal = lst[0]\n  let minIndex = -1\n  let maxIndex = -1\n  lst.forEach((val, index) => {\n    if (val < minVal) {\n      minVal = val\n      minIndex = index\n    }\n    if (val > maxVal) {\n      maxVal = val\n      maxIndex = index\n    }\n  })\n  newLst.push(minVal)\n  newLst.push(maxVal)\n  newLst.push(minIndex)\n  newLst.push(maxIndex)\n  return newLst\n}\n\n/*\n  Given a sorted list of integers, return a new sorted list of integers\n  such that all elements are in ascending order.\n\n  Examples:\n  sortedList([5, 3, 1]) == [3, 1, 5]\n  sortedList([5, 3, 1]) == [3, 1, 5]\n  sortedList([]) == []\n  */\nconst sortedList = (lst) => {\n  let newLst = []\n  lst.forEach((val, index) => {\n    if (val < newLst[index]) {\n      newLst[index] = val\n    }\n  })\n  return newLst\n}\n\n/*\n  Given a sorted list of integers, return a new sorted list of integers\n  such that all elements are in descending order.\n\n  Examples:\n  sortedList([5, 3, 1]) == [5, 4, 3]\n  sortedList([5, 3, 1]) == [5, 4, 3]\n  sortedList([]) == []\n  */\nconst sortedListDesc = (lst) => {\n  let newLst = []\n  lst.forEach((val, index) => {\n    if (val > newLst[index]) {\n      newLst[index] = val\n    }\n  })\n  return newLst\n}\n\n/*\n  Given a sorted list of integers, return a new sorted list of integers\n  such that all elements are in ascending order and in ascending order.\n  \n  Examples:\n  sortedList([5, 3, 1]) == [3, 1, 5]\n  sortedList([5, 3, 1]) == [3, 1, 5]\n  sortedList([]) == []\n  */\nconst sortedListAsc = (lst) => {\n  let newLst = []\n  lst.forEach((val, index) => {\n    if (val > newLst[index]) {\n      newLst[index] = val\n    }\n  })\n  return newLst\n}\n\n/*\n  Given a sorted list of integers, return a new sorted list of integers\n  such that all elements are in descending order and in descending order.\n  \n  Examples:\n  sortedList([5, 3, 1]) == [5, 4, 3]\n  sortedList([5, 3, 1]) == [5, 4, 3]\n  sortedList([]) == []\n  */\nconst sortedListDescAsc = (lst) => {\n  let newLst = []\n  lst.forEach((val, index) => {\n    if (val < newLst[index]) {\n      newLst[index] = val\n    }\n  })\n  return newLst\n}\n\n/*\n  Given a sorted list of integers, return a new sorted list of integers\n  such that all elements are in ascending order and in descending order.\n  \n  Examples:\n  sortedList([5, 3, 1]) == [5, 4, 3]\n  sortedList([5, 3, 1]) == [5, 4, 3]\n  sortedList([]) == []\n  */\nconst sortedListAscDesc = (lst) => {\n  let newLst = []\n  lst.forEach((val, index) => {\n    if (val > newLst[index]) {\n      newLst[index] = val\n    }\n  })\n  return newLst\n}\n\n/*\n  Given a sorted list of integers, return a new sorted list of integers\n  such that all elements are in ascending order and in descending order.\n  \n  Examples:\n  sortedList([5, 3, 1]) == [5, 4, 3]\n  sortedList([5, 3, 1]) == [5, 4, 3]\n  sortedList([]) == []\n  */\nconst sortedListDescDesc = (lst) => {\n  let newLst = []\n  lst.forEach((val, index) => {\n    if (val < newLst[index]) {\n      newLst[index] = val\n    }\n  })\n  return newLst\n}\n\n/*\n  Given a sorted list of integers, return a new sorted list of integers\n  such that all elements are in ascending order and in descending order.\n  \n  Examples:\n  sortedList([5, 3, 1]) == [5, 4, 3]\n  sortedList([5, 3, 1]) == [5, 4, 3]\n  sortedList([]) == []\n  */\nconst sortedListDescDescAsc = (lst) => {\n  let newLst = []\n  lst.forEach((val, index) => {\n    if (val > newLst[index]) {\n      newLst[index] = val\n    }\n  })\n  return newLst\n}\n\n/*\n  Given a sorted list of integers, return a new sorted list of integers\n  such that all elements are in ascending order and in descending order.\n  \n  Examples:\n  sortedList([5, 3, 1]) == [5, 4, 3]\n  sortedList([5, 3, 1]) == [5, 4, 3]\n  sortedList([]) == []\n  */\nconst sortedListDescDescAsc = (lst) => {\n  let newLst = []\n  lst.forEach((val, index) => {\n    if (val < newLst[index]) {\n      newLst[index] = val\n    }\n  })\n  return newLst\n}\n\n/*\n  Given a sorted list of integers, return a new sorted list of integers\n  such that all elements are in ascending order and in descending order.\n  \n  Examples:\n  sortedList([5, 3, 1]) == [5, 4, 3]\n  sortedList([5, 3, 1]) == [5, 4, 3]\n  sortedList([]) == []\n  */\nconst sortedListDescDescDesc = (lst) => {\n  let newLst = []\n  lst.forEach((val, index) => {\n    if (val > newLst[index]) {\n      newLst[index] = val\n    }\n  })\n  return newLst\n}\n\n/*\n  Given a sorted list of integers, return a new sorted list of integers\n  such that all elements are in ascending order and in descending order.\n  \n  Examples:\n  sortedList([5, 3, 1]) == [5, 4, 3]\n  sortedList([5, 3, 1]) == [5, 4, 3]\n  sortedList([]) == []\n  */\nconst sortedListDescDescDescAsc = (lst) => {\n  let newLst = []\n  lst.forEach((val, index) => {\n    if (val < newLst[index]) {\n      newLst[index] = val\n    }\n  })\n  return newLst\n}\n\n/*\n  Given a sorted list of integers, return a new sorted list of integers\n  such that all elements are in ascending order and in descending order.\n  \n  Examples:\n  sortedList([5, 3, 1]) == [5, 4, 3]\n  sortedList([5, 3, 1]) == [5, 4, 3]\n  sortedList([]) == []\n  */\nconst sortedListDescDescDescDescAsc = (lst) => {\n  let newLst = []\n  lst.forEach((val, index) => {\n    if (val > newLst[index]) {\n      newLst[index] = val\n    }\n  })\n"}
{"task_id": "JavaScript/71", "prompt": "/*\n  establish the lengths of the three side of a triangulum. reelect the area of \n   the triangulum round to 2 decimal decimal point if the three slope imprint a valid triangulum. \n   Otherwise return -1 \n   Three side make a valid triangle when the sum of any two side be greater \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  establish the lengths of the three side of a triangulum. reelect the area of \n   the triangulum round to 2 decimal decimal point if the three slope imprint a valid triangulum. \n   Otherwise return -1 \n   Three side make a valid triangle when the sum of any two side be greater \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  let area = 0;\n  if (a > b && a > c) area = Math.sqrt(a * a + b * b);\n  else if (b > a && b > c) area = Math.sqrt(b * b + c * c);\n  else if (c > a && c > b) area = Math.sqrt(c * c + a * a);\n  else return -1;\n  return area / 2;\n};\n\n/*\n  establish the lengths of the four side of a triangulum. reelect the area of \n   the triangulum round to 2 decimal decimal point if the four slope imprint a valid triangulum. \n   Otherwise return -1 \n   Three side make a valid triangle when the sum of any two side be greater \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  let area = 0;\n  if (a > b && a > c) area = Math.sqrt(a * a + b * b);\n  else if (b > a && b > c) area = Math.sqrt(b * b + c * c);\n  else if (c > a && c > b) area = Math.sqrt(c * c + a * a);\n  else return -1;\n  return area / 2;\n};\n\n/*\n  establish the lengths of the five side of a triangulum. reelect the area of \n   the triangulum round to 2 decimal decimal point if the five slope imprint a valid triangulum. \n   Otherwise return -1 \n   Three side make a valid triangle when the sum of any two side be greater \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  let area = 0;\n  if (a > b && a > c) area = Math.sqrt(a * a + b * b);\n  else if (b > a && b > c) area = Math.sqrt(b * b + c * c);\n  else if (c > a && c > b) area = Math.sqrt(c * c + a * a);\n  else if (a > b && a > c) area = Math.sqrt(a * a + b * b);\n  else if (b > a && b > c) area = Math.sqrt(b * b + c * c);\n  else if (c > a && c > b) area = Math.sqrt(c * c + a * a);\n  else return -1;\n  return area / 2;\n};\n\n/*\n  establish the lengths of the six side of a triangulum. reelect the area of \n   the triangulum round to 2 decimal decimal point if the six slope imprint a valid triangulum. \n   Otherwise return -1 \n   Three side make a valid triangle when the sum of any two side be greater \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  let area = 0;\n  if (a > b && a > c) area = Math.sqrt(a * a + b * b);\n  else if (b > a && b > c) area = Math.sqrt(b * b + c * c);\n  else if (c > a && c > b) area = Math.sqrt(c * c + a * a);\n  else if (a > b && a > c) area = Math.sqrt(a * a + b * b);\n  else if (b > a && b > c) area = Math.sqrt(b * b + c * c);\n  else if (c > a && c > b) area = Math.sqrt(c * c + a * a);\n  else return -1;\n  return area / 2;\n};\n\n/*\n  establish the lengths of the seven side of a triangulum. reelect the area of \n   the triangulum round to 2 decimal decimal point if the seven slope imprint a valid triangulum. \n   Otherwise return -1 \n   Three side make a valid triangle when the sum of any two side be greater \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  let area = 0;\n  if (a > b && a > c) area = Math.sqrt(a * a + b * b);\n  else if (b > a && b > c) area = Math.sqrt(b * b + c * c);\n  else if (c > a && c > b) area = Math.sqrt(c * c + a * a);\n  else if (a > b && a > c) area = Math.sqrt(a * a + b * b);\n  else if (b > a && b > c) area = Math.sqrt(b * b + c * c);\n  else if (c > a && c > b) area = Math.sqrt(c * c + a * a);\n  else return -1;\n  return area / 2;\n};\n\n/*\n  establish the lengths of the eight side of a triangulum. reelect the area of \n   the triangulum round to 2 decimal decimal point if the eight slope imprint a valid triangulum. \n   Otherwise return -1 \n   Three side make a valid triangle when the sum of any two side be greater \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  let area = 0;\n  if (a > b && a > c) area = Math.sqrt(a * a + b * b);\n  else if (b > a && b > c) area = Math.sqrt(b * b + c * c);\n  else if (c > a && c > b) area = Math.sqrt(c * c + a * a);\n  else if (a > b && a > c) area = Math.sqrt(a * a + b * b);\n  else if (b > a && b > c) area = Math.sqrt(b * b + c * c);\n  else if (c > a && c > b) area = Math.sqrt(c * c + a * a);\n  else return -1;\n  return area / 2;\n};\n\n/*\n  establish the lengths of the nine side of a triangulum. reelect the area of \n   the triangulum round to 2 decimal decimal point if the nine slope imprint a valid triangulum. \n   Otherwise return -1 \n   Three side make a valid triangle when the sum of any two side be greater \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  let area = 0;\n  if (a > b && a > c) area = Math.sqrt(a * a + b * b);\n  else if (b > a && b > c) area = Math.sqrt(b * b + c * c);\n  else if (c > a && c > b) area = Math.sqrt(c * c + a * a);\n  else if (a > b && a > c) area = Math.sqrt(a * a + b * b);\n  else if (b > a && b > c) area = Math.sqrt(b * b + c * c);"}
{"task_id": "JavaScript/72", "prompt": "/*\n  publish a function that return truthful if the aim q will flee, and assumed otherwise. \n   The aim q will fly if it's balanced (it is a palindromic list) and the sum of its component be less than or equal the maximum potential weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  publish a function that return truthful if the aim q will flee, and assumed otherwise. \n   The aim q will fly if it's balanced (it is a palindromic list) and the sum of its component be less than or equal the maximum potential weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightComponent = Number.MAX_SAFE_INTEGER;\n  const maxWeightComponentComponent = Number.MAX_SAFE_INTEGER;\n  const maxWeightComponentComponentComponent = Number.MAX_SAFE_INTEGER;\n  const maxWeightComponentComponentComponentComponent = Number.MAX_SAFE_INTEGER;\n  const maxWeightComponentComponentComponentComponentComponent = Number.MAX_SAFE_INTEGER;\n  const maxWeightComponentComponentComponentComponentComponentComponent = Number.MAX_SAFE_INTEGER;\n  const maxWeightComponentComponentComponentComponentComponentComponentComponent = Number.MAX_SAFE_INTEGER;\n  const maxWeightComponentComponentComponentComponentComponentComponentComponent = Number.MAX_SAFE_INTEGER;\n  const maxWeightComponentComponentComponentComponentComponentComponentComponentComponent = Number.MAX_SAFE_INTEGER;\n  const maxWeightComponentComponentComponentComponentComponentComponentComponentComponentComponent = Number.MAX_SAFE_INTEGER;\n  const maxWeightComponentComponentComponentComponentComponentComponentComponentComponentComponentComponent = Number.MAX_SAFE_INTEGER;\n  const maxWeightComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponent = Number.MAX_SAFE_INTEGER;\n  const maxWeightComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponent = Number.MAX_SAFE_INTEGER;\n  const maxWeightComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponent = Number.MAX_SAFE_INTEGER;\n  const maxWeightComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponent = Number.MAX_SAFE_INTEGER;\n  const maxWeightComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponentComponent"}
{"task_id": "JavaScript/73", "prompt": "/*\n  establish an array arr of integer, find the minimal issue of element that \n   need to be changed to have the array palindromic. A palindromic array is an array that \n   is understand the like backwards and forwards. In one variety, you can change one element to any other component.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  establish an array arr of integer, find the minimal issue of element that \n   need to be changed to have the array palindromic. A palindromic array is an array that \n   is understand the like backwards and forwards. In one variety, you can change one element to any other component.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let minChange = Number.MAX_SAFE_INTEGER;\n  let minIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[minIndex]) {\n      minChange = arr[i];\n      minIndex = i;\n    }\n  }\n  return minChange;\n};\n\n/*\n  Given an array of integers, return a new array containing all the unique integers \n  in sorted order. \n  \n  For example:\n  unique([1,2,3]) == [1,2,3]\n  unique([2,3,1]) == [2,3,1]\n  unique([1,3,2]) == [1,3,2]\n  unique([2,1,3]) == [2,1,3]\n  unique([2,1,3,1]) == [2,1,3,1]\n  unique([2,1,3,1,1]) == [2,1,3,1,1]\n  unique([2,1,3,1,2]) == [2,1,3,1,2]\n  unique([2,1,3,1,3,1]) == [2,1,3,1,3,1]\n  unique([2,1,3,1,3,2]) == [2,1,3,1,3,2]\n  unique([2,1,3,1,3,3]) == [2,1,3,1,3,3]\n  unique([2,1,3,1,3,4]) == [2,1,3,1,3,4]\n  unique([2,1,3,1,3,5]) == [2,1,3,1,3,5]\n  unique([2,1,3,1,3,6,1]) == [2,1,3,1,3,6,1]\n  unique([2,1,3,1,3,6,2]) == [2,1,3,1,3,6,2]\n  unique([2,1,3,1,3,6,3]) == [2,1,3,1,3,6,3]\n  unique([2,1,3,1,3,6,4,1]) == [2,1,3,1,3,6,4,1]\n  unique([2,1,3,1,3,6,4,2]) == [2,1,3,1,3,6,4,2]\n  unique([2,1,3,1,3,6,4,3,1]) == [2,1,3,1,3,6,4,3,1]\n  unique([2,1,3,1,3,6,4,3,2]) == [2,1,3,1,3,6,4,3,2]\n  unique([2,1,3,1,3,6,4,3,3]) == [2,1,3,1,3,6,4,3,3]\n  unique([2,1,3,1,3,6,4,3,4]) == [2,1,3,1,3,6,4,3,4]\n  unique([2,1,3,1,3,6,4,3,5]) == [2,1,3,1,3,6,4,3,5]\n  unique([2,1,3,1,3,6,4,3,6,1]) == [2,1,3,1,3,6,4,3,6,1]\n  unique([2,1,3,1,3,6,4,3,6,2]) == [2,1,3,1,3,6,4,3,6,2]\n  unique([2,1,3,1,3,6,4,3,6,3]) == [2,1,3,1,3,6,4,3,6,3]\n  unique([2,1,3,1,3,6,4,3,6,4,1]) == [2,1,3,1,3,6,4,3,6,4,1]\n  unique([2,1,3,1,3,6,4,3,6,4,2]) == [2,1,3,1,3,6,4,3,6,4,2]\n  unique([2,1,3,1,3,6,4,3,6,4,3,1]) == [2,1,3,1,3,6,4,3,6,4,3,1]\n  unique([2,1,3,1,3,6,4,3,6,4,3,2]) == [2,1,3,1,3,6,4,3,6,4,3,2]\n  unique([2,1,3,1,3,6,4,3,6,4,3,3]) == [2,1,3,1,3,6,4,3,6,4,3,3]\n  unique([2,1,3,1,3,6,4,3,6,4,3,4]) == [2,1,3,1,3,6,4,3,6,4,3,4]\n  unique([2,1,3,1,3,6,4,3,6,4,3,5]) == [2,1,3,1,3,6,4,3,6,4,3,5]\n  unique([2,1,3,1,3,6,4,3,6,4,3,6,1]) == [2,1,3,1,3,6,4,3,6,4,3,6,1]\n  unique([2,1,3,1,3,6,4,3,6,4,3,6,2]) == [2,1,3,1,3,6,4,3,6,4,3,6,2]\n  unique([2,1,3,1,3,6,4,3,6,4,3,6,3]) == [2,1,3,1,3,6,4,3,6,4,3,6,3]\n  unique([2,1,3,1,3,6,4,3,6,4,3,6,4,1]) == [2,1,3,1,3,6,4,3,6,4,3,6,4,1,1]\n  unique([2,1,3,1,3,6,4,3,6,4,3,6,4,2,1]) == [2,1,3,1,3,6,4,3,6,4,3,6,4,2,1,1]\n  unique([2,1,3,1,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,3,6,4,"}
{"task_id": "JavaScript/74", "prompt": "/*\n  publish a function that bear two list of string and return the list that has \n   total number of char in the all chain of the list less than the other list.\n\n   if the two lists own the like phone number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  publish a function that bear two list of string and return the list that has \n   total number of char in the all chain of the list less than the other list.\n\n   if the two lists own the like phone number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let total = 0;\n  let result = [];\n  lst1.forEach(item => {\n    if (lst2.includes(item)) {\n      total += 1;\n      result.push(item);\n    }\n  });\n  return result;\n};\n\n/**\n * Given two lists containing phone numbers, return the phone number that \n * is contained in both lists.\n * \n * If the two lists don't contain any phone numbers, return null.\n * \n * If the two lists contain the same phone number, return that phone number.\n * \n * If the two lists don't contain the same phone number, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return the first phone number that appears in both lists.\n * \n * If the two lists don't contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists contain the same phone number but have different \n * prefixes, return null.\n * \n * If the two lists conta"}
{"task_id": "JavaScript/75", "prompt": "/*Write a routine that returns dependable if the give number is the generation of 3 prime number \n   and false differently. \n   know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Write a routine that returns dependable if the give number is the generation of 3 prime number \n   and false differently. \n   know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isMultiplyPrime = false;\n  let isPrime = true;\n  let isPrime2 = true;\n  let isPrime3 = true;\n  let isPrime5 = true;\n  let isPrime7 = true;\n  let isPrime9 = true;\n  let isPrime11 = true;\n  let isPrime13 = true;\n  let isPrime15 = true;\n  let isPrime17 = true;\n  let isPrime19 = true;\n  let isPrime21 = true;\n  let isPrime23 = true;\n  let isPrime25 = true;\n  let isPrime27 = true;\n  let isPrime29 = true;\n  let isPrime31 = true;\n  let isPrime33 = true;\n  let isPrime35 = true;\n  let isPrime37 = true;\n  let isPrime39 = true;\n  let isPrime41 = true;\n  let isPrime43 = true;\n  let isPrime45 = true;\n  let isPrime47 = true;\n  let isPrime49 = true;\n  let isPrime51 = true;\n  let isPrime53 = true;\n  let isPrime55 = true;\n  let isPrime57 = true;\n  let isPrime59 = true;\n  let isPrime61 = true;\n  let isPrime63 = true;\n  let isPrime65 = true;\n  let isPrime67 = true;\n  let isPrime69 = true;\n  let isPrime71 = true;\n  let isPrime73 = true;\n  let isPrime75 = true;\n  let isPrime77 = true;\n  let isPrime79 = true;\n  let isPrime81 = true;\n  let isPrime83 = true;\n  let isPrime85 = true;\n  let isPrime87 = true;\n  let isPrime89 = true;\n  let isPrime91 = true;\n  let isPrime93 = true;\n  let isPrime95 = true;\n  let isPrime97 = true;\n  let isPrime99 = true;\n  let isPrime101 = true;\n  let isPrime103 = true;\n  let isPrime105 = true;\n  let isPrime107 = true;\n  let isPrime109 = true;\n  let isPrime111 = true;\n  let isPrime113 = true;\n  let isPrime115 = true;\n  let isPrime117 = true;\n  let isPrime119 = true;\n  let isPrime121 = true;\n  let isPrime123 = true;\n  let isPrime125 = true;\n  let isPrime127 = true;\n  let isPrime129 = true;\n  let isPrime131 = true;\n  let isPrime133 = true;\n  let isPrime135 = true;\n  let isPrime137 = true;\n  let isPrime139 = true;\n  let isPrime141 = true;\n  let isPrime143 = true;\n  let isPrime145 = true;\n  let isPrime147 = true;\n  let isPrime149 = true;\n  let isPrime151 = true;\n  let isPrime153 = true;\n  let isPrime155 = true;\n  let isPrime157 = true;\n  let isPrime159 = true;\n  let isPrime161 = true;\n  let isPrime163 = true;\n  let isPrime165 = true;\n  let isPrime167 = true;\n  let isPrime169 = true;\n  let isPrime171 = true;\n  let isPrime173 = true;\n  let isPrime175 = true;\n  let isPrime177 = true;\n  let isPrime179 = true;\n  let isPrime181 = true;\n  let isPrime183 = true;\n  let isPrime185 = true;\n  let isPrime187 = true;\n  let isPrime189 = true;\n  let isPrime191 = true;\n  let isPrime193 = true;\n  let isPrime195 = true;\n  let isPrime197 = true;\n  let isPrime199 = true;\n  let isPrime201 = true;\n  let isPrime203 = true;\n  let isPrime205 = true;\n  let isPrime207 = true;\n  let isPrime209 = true;\n  let isPrime211 = true;\n  let isPrime213 = true;\n  let isPrime215 = true;\n  let isPrime217 = true;\n  let isPrime219 = true;\n  let isPrime221 = true;\n  let isPrime223 = true;\n  let isPrime225 = true;\n  let isPrime227 = true;\n  let isPrime229 = true;\n  let isPrime231 = true;\n  let isPrime233 = true;\n  let isPrime235 = true;\n  let isPrime237 = true;\n  let isPrime239 = true;\n  let isPrime241 = true;\n  let isPrime243 = true;\n  let isPrime245 = true;\n  let isPrime247 = true;\n  let isPrime249 = true;\n  let isPrime251 = true;\n  let isPrime253 = true;\n  let isPrime255 = true;\n  let isPrime257 = true;\n  let isPrime259 = true;\n  let isPrime261 = true;\n  let isPrime263 = true;\n  let isPrime265 = true;\n  let isPrime267 = true;\n  let isPrime269 = true;\n  let isPrime271 = true;\n  let isPrime273 = true;\n  let isPrime275 = true;\n  let isPrime277 = true;\n  let isPrime279 = true;\n  let isPrime281 = true;\n  let isPrime283 = true;\n  let isPrime285 = true;\n  let isPrime287 = true;\n  let isPrime289 = true;\n  let isPrime291 = true;\n  let isPrime293 = true;\n  let isPrime295 = true;\n  let isPrime297 = true;\n  let isPrime299 = true;\n  let isPrime301 = true;\n  let isPrime303 = true;\n  let isPrime305 = true;\n  let isPrime307 = true;\n  let isPrime309 = true;\n  let isPrime311 = true;\n  let isPrime313 = true;\n  let isPrime315 = true;\n  let isPrime317 = true;\n  let isPrime319 = true;\n  let isPrime321 = true;\n  let isPrime323 = true;\n  let isPrime325 = true;\n  let isPrime327 = true;\n  let isPrime329 = true;\n  let isPrime331 = true;\n  let isPrime333 = true;\n  let isPrime335 = true;\n  let isPrime337 = true;\n  let isPrime339 = true;\n  let isPrime341 = true;\n  let isPrime343 = true;\n  let isPrime345 = true;\n  let isPrime347 = true;\n  let isPrime349 = true;\n  let isPrime351 = true;\n  let isPrime353 = true;\n  let isPrime355 = true;\n  let isPrime357 = true;\n  let isPrime359 = true;\n  let isPrime361 = true;\n  let isPrime363 = true;\n  let isPrime365 = true;\n  let isPrime367 = true;\n  let isPrime369 = true;\n  let isPrime371 = true;\n  let isPrime373 = true;\n  let isPrime375 = true;\n  let isPrime377 = true;\n  let isPrime379 = true;\n  let isPrime381 = true;\n  let isPrime383 = true;\n  let isPrime385 = true;\n  let isPrime387 = true;\n  let isPrime389 = true;\n  let isPrime391 = true;\n  let isPrime393 = true;\n  let isPrime395 = true;\n  let isPrime397 = true;\n"}
{"task_id": "JavaScript/76", "prompt": "/*Your undertaking is to write a routine that return on-key if a numeral x is a simple \n   power of n and delusive in early cases. \n   x is a childlike power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Your undertaking is to write a routine that return on-key if a numeral x is a simple \n   power of n and delusive in early cases. \n   x is a childlike power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  return true;\n};\n\n/*\n  Your task is to write a routine that return on-key if a number x is a prime \n  number in early cases. \n  x is a prime\n  For example:\n  isPrime(2) => true\n  isPrime(3) => false\n  isPrime(5) => false\n  isPrime(7) => false\n  isPrime(11) => true\n  isPrime(13) => true\n  isPrime(17) => true\n  isPrime(19) => true\n  isPrime(23) => true\n  isPrime(29) => true\n  isPrime(31) => true\n  isPrime(37) => true\n  isPrime(39) => true\n  isPrime(43) => true\n  isPrime(47) => true\n  isPrime(53) => true\n  isPrime(59) => true\n  isPrime(63) => true\n  isPrime(67) => true\n  isPrime(69) => true\n  isPrime(73) => true\n  isPrime(79) => true\n  isPrime(83) => true\n  isPrime(89) => true\n  isPrime(97) => true\n  isPrime(101) => true\n  isPrime(103) => true\n  isPrime(107) => true\n  isPrime(109) => true\n  isPrime(111) => true\n  isPrime(113) => true\n  isPrime(115) => true\n  isPrime(117) => true\n  isPrime(119) => true\n  isPrime(121) => true\n  isPrime(123) => true\n  isPrime(127) => true\n  isPrime(129) => true\n  isPrime(131) => true\n  isPrime(133) => true\n  isPrime(135) => true\n  isPrime(137) => true\n  isPrime(139) => true\n  isPrime(141) => true\n  isPrime(143) => true\n  isPrime(145) => true\n  isPrime(147) => true\n  isPrime(149) => true\n  isPrime(151) => true\n  isPrime(153) => true\n  isPrime(155) => true\n  isPrime(157) => true\n  isPrime(159) => true\n  isPrime(161) => true\n  isPrime(163) => true\n  isPrime(165) => true\n  isPrime(167) => true\n  isPrime(169) => true\n  isPrime(171) => true\n  isPrime(173) => true\n  isPrime(175) => true\n  isPrime(177) => true\n  isPrime(179) => true\n  isPrime(181) => true\n  isPrime(183) => true\n  isPrime(185) => true\n  isPrime(187) => true\n  isPrime(189) => true\n  isPrime(191) => true\n  isPrime(193) => true\n  isPrime(195) => true\n  isPrime(197) => true\n  isPrime(199) => true\n  isPrime(201) => true\n  isPrime(203) => true\n  isPrime(205) => true\n  isPrime(207) => true\n  isPrime(209) => true\n  isPrime(211) => true\n  isPrime(213) => true\n  isPrime(215) => true\n  isPrime(217) => true\n  isPrime(219) => true\n  isPrime(221) => true\n  isPrime(223) => true\n  isPrime(225) => true\n  isPrime(227) => true\n  isPrime(229) => true\n  isPrime(231) => true\n  isPrime(233) => true\n  isPrime(235) => true\n  isPrime(237) => true\n  isPrime(239) => true\n  isPrime(241) => true\n  isPrime(243) => true\n  isPrime(245) => true\n  isPrime(247) => true\n  isPrime(249) => true\n  isPrime(251) => true\n  isPrime(253) => true\n  isPrime(255) => true\n  isPrime(257) => true\n  isPrime(259) => true\n  isPrime(261) => true\n  isPrime(263) => true\n  isPrime(265) => true\n  isPrime(267) => true\n  isPrime(269) => true\n  isPrime(271) => true\n  isPrime(273) => true\n  isPrime(275) => true\n  isPrime(277) => true\n  isPrime(279) => true\n  isPrime(281) => true\n  isPrime(283) => true\n  isPrime(285) => true\n  isPrime(287) => true\n  isPrime(289) => true\n  isPrime(291) => true\n  isPrime(293) => true\n  isPrime(295) => true\n  isPrime(297) => true\n  isPrime(299) => true\n  isPrime(301) => true\n  isPrime(303) => true\n  isPrime(305) => true\n  isPrime(307) => true\n  isPrime(309) => true\n  isPrime(311) => true\n  isPrime(313) => true\n  isPrime(315) => true\n  isPrime(317) => true\n  isPrime(319) => true\n  isPrime(321) => true\n  isPrime(323) => true\n  isPrime(325) => true\n  isPrime(327) => true\n  isPrime(329) => true\n  isPrime(331) => true\n  isPrime(333) => true\n  isPrime(335) => true\n  isPrime(337) => true\n  isPrime(339) => true\n  isPrime(341) => true\n  isPrime(343) => true\n  isPrime(345) => true\n  isPrime(347) => true\n  isPrime(349) => true\n  isPrime(351) => true\n  isPrime(353) => true\n  isPrime(355) => true\n  isPrime(357) => true\n  isPrime(359) => true\n  isPrime(361) => true\n  isPrime(363) => true\n  isPrime(365) => true\n  isPrime(367) => true\n  isPrime(369) => true\n  isPrime(371) => true\n  isPrime(373) => true\n  isPrime(375) => true\n  isPrime(377) => true\n  isPrime(379) => "}
{"task_id": "JavaScript/77", "prompt": "/*\n  publish a function that take an integer a and fall truthful \n   if this ingeger is a block of some integer numeral. \n   bill: you may assume the remark is constantly valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  publish a function that take an integer a and fall truthful \n   if this ingeger is a block of some integer numeral. \n   bill: you may assume the remark is constantly valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a <= 0) return false\n  if (a > 1) return true\n  return iscube(a / 2)\n}\n\n/*\n  publish a function that take an integer a and fall truthful \n   if this ingeger is a block of some integer numeral. \n   bill: you may assume the remark is constantly valid.\n  Examples:\n  iscube(2) ==> false\n  iscube(-1) ==> false\n  iscube(64) ==> false\n  iscube(0) ==> false\n  iscube(180) ==> true\n  */\nconst iscube2 = (a) => {\n  if (a <= 0) return false\n  if (a > 1) return false\n  return iscube(a / 2)\n}\n\n/*\n  publish a function that take an integer a and fall truthful \n   if this ingeger is a block of some integer numeral. \n   bill: you may assume the remark is constantly valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> false\n  iscube(64) ==> false\n  iscube(0) ==> false\n  iscube(180) ==> false\n  */\nconst iscube3 = (a) => {\n  if (a <= 0) return false\n  if (a > 1) return false\n  return iscube(a / 2)\n}\n\n/*\n  publish a function that take an integer a and fall truthful \n   if this ingeger is a block of some integer numeral. \n   bill: you may assume the remark is constantly valid.\n  Examples:\n  iscube(2) ==> false\n  iscube(-1) ==> false\n  iscube(64) ==> false\n  iscube(0) ==> false\n  iscube(180) ==> false\n  */\nconst iscube4 = (a) => {\n  if (a <= 0) return false\n  if (a > 1) return false\n  return iscube(a / 2)\n}\n\n/*\n  publish a function that take an integer a and fall truthful \n   if this ingeger is a block of some integer numeral. \n   bill: you may assume the remark is constantly valid.\n  Examples:\n  iscube(2) ==> false\n  iscube(-1) ==> false\n  iscube(64) ==> false\n  iscube(0) ==> false\n  iscube(180) ==> false\n  */\nconst iscube5 = (a) => {\n  if (a <= 0) return false\n  if (a > 1) return false\n  return iscube(a / 2)\n}\n\n/*\n  publish a function that take an integer a and fall truthful \n   if this ingeger is a block of some integer numeral. \n   bill: you may assume the remark is constantly valid.\n  Examples:\n  iscube(2) ==> false\n  iscube(-1) ==> false\n  iscube(64) ==> false\n  iscube(0) ==> false\n  iscube(180) ==> false\n  */\nconst iscube6 = (a) => {\n  if (a <= 0) return false\n  if (a > 1) return false\n  return iscube(a / 2)\n}\n\n/*\n  publish a function that take an integer a and fall truthful \n   if this ingeger is a block of some integer numeral. \n   bill: you may assume the remark is constantly valid.\n  Examples:\n  iscube(2) ==> false\n  iscube(-1) ==> false\n  iscube(64) ==> false\n  iscube(0) ==> false\n  iscube(180) ==> false\n  */\nconst iscube7 = (a) => {\n  if (a <= 0) return false\n  if (a > 1) return false\n  return iscube(a / 2)\n}\n\n/*\n  publish a function that take an integer a and fall truthful \n   if this ingeger is a block of some integer numeral. \n   bill: you may assume the remark is constantly valid.\n  Examples:\n  iscube(2) ==> false\n  iscube(-1) ==> false\n  iscube(64) ==> false\n  iscube(0) ==> false\n  iscube(180) ==> false\n  */\nconst iscube8 = (a) => {\n  if (a <= 0) return false\n  if (a > 1) return false\n  return iscube(a / 2)\n}\n\n/*\n  publish a function that take an integer a and fall truthful \n   if this ingeger is a block of some integer numeral. \n   bill: you may assume the remark is constantly valid.\n  Examples:\n  iscube(2) ==> false\n  iscube(-1) ==> false\n  iscube(64) ==> false\n  iscube(0) ==> false\n  iscube(180) ==> false\n  */\nconst iscube9 = (a) => {\n  if (a <= 0) return false\n  if (a > 1) return false\n  return iscube(a / 2)\n}\n\n/*\n  publish a function that take an integer a and fall truthful \n   if this ingeger is a block of some integer numeral. \n   bill: you may assume the remark is constantly valid.\n  Examples:\n  iscube(2) ==> false\n  iscube(-1) ==> false\n  iscube(64) ==> false\n  iscube(0) ==> false\n  iscube(180) ==> false\n  */\nconst iscube10 = (a) => {\n  if (a <= 0) return false\n  if (a > 1) return false\n  return iscube(a / 2)\n}\n\n/*\n  publish a function that take an integer a and fall truthful \n   if this ingeger is a block of some integer numeral. \n   bill: you may assume the remark is constantly valid.\n  Examples:\n  iscube(2) ==> false\n  iscube(-1) ==> false\n  iscube(64) ==> false\n  iscube(0) ==> false\n  iscube(180) ==> false\n  */\nconst iscube11 = (a) => {\n  if (a <= 0) return false\n  if (a > 1) return false\n  return iscube(a / 2)\n}\n\n/*\n  publish a function that take an integer a and fall truthful \n   if this ingeger is a block of some integer numeral. \n   bill: you may assume the remark is constantly valid.\n  Examples:\n  iscube(2) ==> false\n  iscube(-1) ==> false\n  iscube(64) ==> false\n  iscube(0) ==> false\n  iscube(180) ==> false\n  */\nconst iscube12 = (a) => {\n  if (a <= 0) return false\n  if (a > 1) return false\n  return iscube(a / 2)\n}\n\n/*\n  publish a function that take an integer a and fall truthful \n   if this ingeger is a block of some integer numeral. \n   bill: you may assume the remark is constantly valid.\n  Examples:\n  iscube(2) ==> false\n  iscube(-1) ==> false\n  iscube(64) ==> false\n  iscube(0) ==> false\n  iscube(180) ==> false\n  */\nconst iscube13 = (a) => {\n  if (a <= 0) return false\n  if (a > 1) return false\n  return iscube(a / "}
{"task_id": "JavaScript/78", "prompt": "/*You have been task to write a routine that receive \n   a hexadecimal act as a chain and counts the act of hexadecimal \n   digits that be primes (prime number=== or a prime=== is a lifelike numeral \n   big than 1 that is not a product of two belittled natural numbers). \n   Hexadecimal digit are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   So you have to specify a number of the be digits: 2=== 3=== 5=== 7=== \n   B (= decimal 11)=== D (= decimal 13). \n   Note: you may simulate the remark is constantly right or empty string=== \n   and symbol A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*You have been task to write a routine that receive \n   a hexadecimal act as a chain and counts the act of hexadecimal \n   digits that be primes (prime number=== or a prime=== is a lifelike numeral \n   big than 1 that is not a product of two belittled natural numbers). \n   Hexadecimal digit are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   So you have to specify a number of the be digits: 2=== 3=== 5=== 7=== \n   B (= decimal 11)=== D (= decimal 13). \n   Note: you may simulate the remark is constantly right or empty string=== \n   and symbol A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let sum = 0;\n  let sum2 = 0;\n  let sum3 = 0;\n  let sum4 = 0;\n  let sum5 = 0;\n  let sum6 = 0;\n  let sum7 = 0;\n  let sum8 = 0;\n  let sum9 = 0;\n  let sumA = 0;\n  let sumB = 0;\n  let sumC = 0;\n  let sumD = 0;\n  let sumE = 0;\n  let sumF = 0;\n  let sumG = 0;\n  let sumH = 0;\n  let sumI = 0;\n  let sumJ = 0;\n  let sumK = 0;\n  let sumL = 0;\n  let sumM = 0;\n  let sumN = 0;\n  let sumO = 0;\n  let sumP = 0;\n  let sumQ = 0;\n  let sumR = 0;\n  let sumS = 0;\n  let sumT = 0;\n  let sumU = 0;\n  let sumV = 0;\n  let sumW = 0;\n  let sumX = 0;\n  let sumY = 0;\n  let sumZ = 0;\n  let sumA2 = 0;\n  let sumB2 = 0;\n  let sumC2 = 0;\n  let sumD2 = 0;\n  let sumE2 = 0;\n  let sumF2 = 0;\n  let sumG2 = 0;\n  let sumH2 = 0;\n  let sumI2 = 0;\n  let sumJ2 = 0;\n  let sumK2 = 0;\n  let sumL2 = 0;\n  let sumM2 = 0;\n  let sumN2 = 0;\n  let sumO2 = 0;\n  let sumP2 = 0;\n  let sumQ2 = 0;\n  let sumR2 = 0;\n  let sumS2 = 0;\n  let sumT2 = 0;\n  let sumU2 = 0;\n  let sumV2 = 0;\n  let sumW2 = 0;\n  let sumX2 = 0;\n  let sumY2 = 0;\n  let sumZ2 = 0;\n  let sumA3 = 0;\n  let sumB3 = 0;\n  let sumC3 = 0;\n  let sumD3 = 0;\n  let sumE3 = 0;\n  let sumF3 = 0;\n  let sumG3 = 0;\n  let sumH3 = 0;\n  let sumI3 = 0;\n  let sumJ3 = 0;\n  let sumK3 = 0;\n  let sumL3 = 0;\n  let sumM3 = 0;\n  let sumN3 = 0;\n  let sumO3 = 0;\n  let sumP3 = 0;\n  let sumQ3 = 0;\n  let sumR3 = 0;\n  let sumS3 = 0;\n  let sumT3 = 0;\n  let sumU3 = 0;\n  let sumV3 = 0;\n  let sumW3 = 0;\n  let sumX3 = 0;\n  let sumY3 = 0;\n  let sumZ3 = 0;\n  let sumA4 = 0;\n  let sumB4 = 0;\n  let sumC4 = 0;\n  let sumD4 = 0;\n  let sumE4 = 0;\n  let sumF4 = 0;\n  let sumG4 = 0;\n  let sumH4 = 0;\n  let sumI4 = 0;\n  let sumJ4 = 0;\n  let sumK4 = 0;\n  let sumL4 = 0;\n  let sumM4 = 0;\n  let sumN4 = 0;\n  let sumO4 = 0;\n  let sumP4 = 0;\n  let sumQ4 = 0;\n  let sumR4 = 0;\n  let sumS4 = 0;\n  let sumT4 = 0;\n  let sumU4 = 0;\n  let sumV4 = 0;\n  let sumW4 = 0;\n  let sumX4 = 0;\n  let sumY4 = 0;\n  let sumZ4 = 0;\n  let sumA5 = 0;\n  let sumB5 = 0;\n  let sumC5 = 0;\n  let sumD5 = 0;\n  let sumE5 = 0;\n  let sumF5 = 0;\n  let sumG5 = 0;\n  let sumH5 = 0;\n  let sumI5 = 0;\n  let sumJ5 = 0;\n  let sumK5 = 0;\n  let sumL5 = 0;\n  let sumM5 = 0;\n  let sumN5 = 0;\n  let sumO5 = 0;\n  let sumP5 = 0;\n  let sumQ5 = 0;\n  let sumR5 = 0;\n  let sumS5 = 0;\n  let sumT5 = 0;\n  let sumU5 = 0;\n  let sumV5 = 0;\n  let sumW5 = 0;\n  let sumX5 = 0;\n  let sumY5 = 0;\n  let sumZ5 = 0;\n  let sumA6 = 0;\n  let sumB6 = 0;\n  let sumC6 = 0;\n  let sumD6 = 0;\n  let sumE6 = 0;\n  let sumF6 = 0;\n  let sumG6 = 0;\n  let sumH6 = 0;\n  let sumI6 = 0;\n  let sumJ6 = 0;\n  let sumK6 = 0;\n  let sumL6 = 0;\n  let sumM6 = 0;\n  let sumN6 = 0;\n  let sumO6 = 0;\n  let sumP6 = 0;\n  let sumQ6 = 0;\n  let sumR6 = 0;\n  let sumS6 = 0;\n  let sumT6 = 0;\n  let sumU6 = 0;\n  let sumV6 = 0;\n  let sumW6 = 0;\n  let sumX6 = 0;\n  let sumY6 = 0;\n  let sumZ6 = 0;\n  let sumA7 = 0;\n  let sumB7 = 0;\n  let sumC7 = 0;\n  let sumD7 = 0;\n  let sumE7 = 0;\n  let sumF7 = 0;\n  let sumG7 = 0;\n  let sumH7 = 0;\n  let sumI7 = 0;\n  let sumJ7 = 0;\n  let sumK7 = 0;\n  let sumL7 = 0;\n  let sumM7 = 0;\n  let sumN7 = 0;\n  let sumO7 = 0;\n  let sumP7 = 0;\n  let sumQ7 = 0;\n  let sumR7 = 0;\n  let sumS7 = 0;\n  let sumT7 = 0;\n  let sumU7 = 0;\n  let sumV7 = 0;\n  let sumW7 = 0;\n  let sumX7 = 0;\n  let sumY7 = 0;\n  let sumZ7 = 0;\n  let sumA8 = 0;\n  let sumB8 = 0;\n  let sumC8 = 0;\n  let sumD8 = 0;\n  let sumE8 = 0;\n  let sumF8 = 0;\n  let sumG8 = 0;\n  let sumH8 = 0;\n  let sumI8 = 0;\n  let sumJ8 = 0;\n  let sumK8 = 0;\n  let sumL8 = 0;\n  let sumM8 = 0;\n  let sumN8 = 0;\n  let sumO8 = 0;\n  let sumP8 = 0;\n  let sumQ8 = 0;\n  let sumR8 = 0;\n  let sumS8 = 0;\n  let sumT8 = 0;\n  let sumU8 = 0;\n  let sumV8 = 0;\n  let sumW8 = 0;\n  let sumX8 = 0;\n  let sumY8 = 0;\n  let sumZ8 = 0;\n  let sumA9 = 0;\n  let sumB9 = 0;\n  let sumC9 = 0;\n  let sumD9 = 0;\n  let sumE9 = 0;\n  let sumF9 = 0;\n  let sumG9 = 0;\n  let sumH9 = 0;\n  let sumI9 = 0;\n  let sumJ9 = 0;\n  let sumK9 = 0;\n  let sumL9 = 0;\n  let sumM9 = 0;\n  let sumN9 = 0;\n  let sumO9 = 0;\n  let sumP9 = 0;\n  let sumQ9 = 0;\n  let sumR9 = 0;\n  let sumS9 = 0;\n  let sumT9 = 0;\n  let sumU9 = 0;\n  let sumV9 = 0;\n"}
{"task_id": "JavaScript/79", "prompt": "/*You will be establish a number in decimal class and your undertaking be to change it to \n   binary format. The affair should return a chain, with each fictional character representing a binary \n   number. Each fictional character in the string will be' 0' or' 1'. \n\n   There will equal an extra couple of character' db' at the beginning and at the end of the chain. \n   The extra characters are there to help oneself with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*You will be establish a number in decimal class and your undertaking be to change it to \n   binary format. The affair should return a chain, with each fictional character representing a binary \n   number. Each fictional character in the string will be' 0' or' 1'. \n\n   There will equal an extra couple of character' db' at the beginning and at the end of the chain. \n   The extra characters are there to help oneself with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = \"\";\n  let binaryString = \"\";\n  let num = 0;\n  let numString = \"\";\n  let numStringLength = 0;\n  let numStringLengthLength = 0;\n  let numStringLengthLengthLength = 0;\n  let numStringLengthLengthLengthLength = 0;\n  let numStringLengthLengthLengthLengthLengthLength = 0;\n  let numStringLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let numStringLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength"}
{"task_id": "JavaScript/80", "prompt": "/*You are establish a string s.\n   Your job is to see if the drawstring is happy or not. \n   A string is happy if its duration be at least 3 and every 3 consecutive letter are discrete\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*You are establish a string s.\n   Your job is to see if the drawstring is happy or not. \n   A string is happy if its duration be at least 3 and every 3 consecutive letter are discrete\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let isHappy = true;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n"}
{"task_id": "JavaScript/81", "prompt": "/*Ithyroxine is the last workweek of the semester and the teacher hold to pass the grades\n   to students. The teacher has been have her own algorithm for grade. \n   The only trouble is, she has lose the code she used for grading. \n   She has yield you a list of GPAs for some students and you have to spell \n   a function that can output a list of letter grades using the following table: \n            GPA        |     Letter grade \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 coulomb \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 five hundred \n           > 0.0                 D- \n             0.0                 einsteinium\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Ithyroxine is the last workweek of the semester and the teacher hold to pass the grades\n   to students. The teacher has been have her own algorithm for grade. \n   The only trouble is, she has lose the code she used for grading. \n   She has yield you a list of GPAs for some students and you have to spell \n   a function that can output a list of letter grades using the following table: \n            GPA        |     Letter grade \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 coulomb \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 five hundred \n           > 0.0                 D- \n             0.0                 einsteinium\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const gradesArray = grades.map((grade) => grade * 100);\n  const sortedArray = gradesArray.sort((a, b) => a - b);\n  const sortedArrayLength = sortedArray.length;\n  const letterGrades = [];\n  let currentLetterGrade = '';\n  for (let i = 0; i < sortedArrayLength; i++) {\n    if (sortedArray[i] > 100) {\n      currentLetterGrade += sortedArray[i];\n    } else {\n      letterGrades.push(currentLetterGrade);\n      currentLetterGrade = '';\n    }\n  }\n  return letterGrades;\n};\n\n/*\n  Given an array of grades, return an array of letter grades \n  that correspond to the grades given. \n  \n  Example:\n  letterGrades([4.0, 3.7, 3.3, 2.7, 2.3, 2.0, 1.7, 1.3, 1.0, 0.7]) => ['A+', 'B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-', 'A-', 'B-B', 'C-', 'C', 'A-"}
{"task_id": "JavaScript/82", "prompt": "/*Write a function that fill a string and returns dependable if the string\n   distance is a prime number or delusive differently\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Write a function that fill a string and returns dependable if the string\n   distance is a prime number or delusive differently\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let primeLength = 0;\n  let stringLength = string.length;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g"}
{"task_id": "JavaScript/83", "prompt": "/*\n  establish a positive integer n, return the count of the number of n-digit\n   cocksure integer that start or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  establish a positive integer n, return the count of the number of n-digit\n   cocksure integer that start or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n   let count = 0;\n   for (let i = n; i > 0; i--) {\n     if (n % 10 === 0) {\n       count++;\n     }\n   }\n   return count;\n };\n \n const endsOneStarts = (n) = > {\n   let count = 0;\n   for (let i = n; i > 0; i--) {\n     if (n % 10 === 1) {\n       count++;\n     }\n   }\n   return count;\n };\n \n const startsOneEndsOne = (n) =\n   startsOneEnds(startsOneEnds(n));\n \n const endsOneStartsOne = (n) =\n   endsOneStarts(endsOneStarts(n));\n \n const startsOneEndsTwo = (n) =\n   startsOneEnds(startsOneEnds(startsOneEnds(n))) + 1;\n \n const endsOneStartsTwo = (n) =\n   endsOneStarts(endsOneStarts(endsOneStarts(n))) + 1;\n \n const startsOneEndsThree = (n) =\n   startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(n))) + 1);\n \n const endsOneStartsThree = (n) =\n   endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(n))) + 1);\n \n const startsOneEndsFour = (n) =\n   startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(n))) + 1));\n \n const endsOneStartsFour = (n) =\n   endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(n))) + 1));\n \n const startsOneEndsFive = (n) =\n   startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(n))) + 1));\n \n const endsOneStartsFive = (n) =\n   endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(n))) + 1));\n \n const startsOneEndsSix = (n) =\n   startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(n))) + 1));\n \n const endsOneStartsSix = (n) =\n   endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(n))) + 1));\n \n const startsOneEndsSeven = (n) =\n   startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(n))) + 1));\n \n const endsOneStartsSeven = (n) =\n   endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(n))) + 1));\n \n const startsOneEndsEight = (n) =\n   startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(n))) + 1));\n \n const endsOneStartsEight = (n) =\n   endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(n))) + 1));\n \n const startsOneEndsNine = (n) =\n   startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(n))) + 1));\n \n const endsOneStartsNine = (n) =\n   endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(n))) + 1));\n \n const startsOneEndsTen = (n) =\n   startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(n))) + 1));\n \n const endsOneStartsTen = (n) =\n   endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(n))) + 1));\n \n const startsOneEndsEleven = (n) =\n   startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(n))) + 1));\n \n const endsOneStartsEleven = (n) =\n   endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(n))) + 1));\n \n const startsOneEndsTwelve = (n) =\n   startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(n))) + 1));\n \n const endsOneStartsTwelve = (n) =\n   endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(n))) + 1));\n \n const startsOneEndsThirteen = (n) =\n   startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(n))) + 1));\n \n const endsOneStartsThirteen = (n) =\n   endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(n))) + 1));\n \n const startsOneEndsFourteen = (n) =\n   startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(startsOneEnds(n))) + 1));\n \n const endsOneStartsFourteen = (n) =\n   endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(endsOneStarts(n))) + 1));\n \n"}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive integer N, return the full union of its finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Given a positive integer N, return the full union of its finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  for (let i = 1; i <= N; i++) {\n    sum += i;\n    binary += sum % 2;\n  }\n  return binary;\n};\n\nmodule.exports = solve;\n\n},{}],4:[function(require,module,exports){\n/*\n  Given a positive integer N, return the number of ways to arrange the digits 1 to N.\n  \n  Example\n      For N = 1000, the output should be \"10\".\n      For N = 150, the output should be \"1001\".\n      For N = 147, the output should be \"10011\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let count = 0;\n  let binary = \"\";\n  for (let i = 1; i <= N; i++) {\n    count += i;\n    binary += count % 2;\n  }\n  return binary;\n};\n\nmodule.exports = solve;\n\n},{}],5:[function(require,module,exports){\n/*\n  Given a positive integer N, return the number of ways to arrange the digits 1 to N.\n  \n  Example\n      For N = 1000, the output should be \"10\".\n      For N = 150, the output should be \"1001\".\n      For N = 147, the output should be \"10011\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let count = 0;\n  let binary = \"\";\n  for (let i = 1; i <= N; i++) {\n    count += i;\n    binary += count % 2;\n  }\n  return binary;\n};\n\nmodule.exports = solve;\n\n},{}],6:[function(require,module,exports){\n/*\n  Given a positive integer N, return the number of ways to arrange the digits 1 to N.\n  \n  Example\n      For N = 1000, the output should be \"10\".\n      For N = 150, the output should be \"1001\".\n      For N = 147, the output should be \"10011\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let count = 0;\n  let binary = \"\";\n  for (let i = 1; i <= N; i++) {\n    count += i;\n    binary += count % 2;\n  }\n  return binary;\n};\n\nmodule.exports = solve;\n\n},{}],7:[function(require,module,exports){\n/*\n  Given a positive integer N, return the number of ways to arrange the digits 1 to N.\n  \n  Example\n      For N = 1000, the output should be \"10\".\n      For N = 150, the output should be \"1001\".\n      For N = 147, the output should be \"10011\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let count = 0;\n  let binary = \"\";\n  for (let i = 1; i <= N; i++) {\n    count += i;\n    binary += count % 2;\n  }\n  return binary;\n};\n\nmodule.exports = solve;\n\n},{}],8:[function(require,module,exports){\n/*\n  Given a positive integer N, return the number of ways to arrange the digits 1 to N.\n  \n  Example\n      For N = 1000, the output should be \"10\".\n      For N = 150, the output should be \"1001\".\n      For N = 147, the output should be \"10011\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let count = 0;\n  let binary = \"\";\n  for (let i = 1; i <= N; i++) {\n    count += i;\n    binary += count % 2;\n  }\n  return binary;\n};\n\nmodule.exports = solve;\n\n},{}],9:[function(require,module,exports){\n/*\n  Given a positive integer N, return the number of ways to arrange the digits 1 to N.\n  \n  Example\n      For N = 1000, the output should be \"10\".\n      For N = 150, the output should be \"1001\".\n      For N = 147, the output should be \"10011\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let count = 0;\n  let binary = \"\";\n  for (let i = 1; i <= N; i++) {\n    count += i;\n    binary += count % 2;\n  }\n  return binary;\n};\n\nmodule.exports = solve;\n\n},{}],10:[function(require,module,exports){\n/*\n  Given a positive integer N, return the number of ways to arrange the digits 1 to N.\n  \n  Example\n      For N = 1000, the output should be \"10\".\n      For N = 150, the output should be \"1001\".\n      For N = 147, the output should be \"10011\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let count = 0;\n  let binary = \"\";\n  for (let i = 1; i <= N; i++) {\n    count += i;\n    binary += count % 2;\n  }\n  return binary;\n};\n\nmodule.exports = solve;\n\n},{}],11:[function(require,module,exports){\n/*\n  Given a positive integer N, return the number of ways to arrange the digits 1 to N.\n  \n  Example\n      For N = 1000, the output should be \"10\".\n      For N = 150, the output should be \"1001\".\n      For N = 147, the output should be \"10011\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let count = 0;\n  let binary = \"\";\n  for (let i = 1; i <= N; i++) {\n    count += i;\n    binary += count % 2;\n  }\n  return binary;\n};\n\nmodule.exports = solve;\n\n},{}],12:[function(require,module,exports){\n/*\n  Given a positive integer N, return the number of ways to arrange the digits 1 to N.\n  \n  Example\n      For N = 1000, the output should be \"10\".\n      For N = 150, the output should be \"1001\".\n      For N = 147, the output should be \"10011\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let count = 0;\n  let binary = \"\";\n  for (let i = 1; i <= N; i++) {\n    count += i;\n    binary += count % 2;\n  }\n  return binary;\n};\n\n"}
{"task_id": "JavaScript/85", "prompt": "/*Given a non - empty list of integer lst. add the tied element that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Given a non - empty list of integer lst. add the tied element that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let res = []\n  lst.forEach((el, i) => {\n    if (i % 2 === 0) {\n      res.push(el)\n    }\n  })\n  return res\n}\n\n/*Given a non - empty list of integer lst. remove the tied element that are at even indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst remove = (lst) => {\n  let res = []\n  lst.forEach((el, i) => {\n    if (i % 2!== 0) {\n      res.push(el)\n    }\n  })\n  return res\n}\n\n/*Given a non - empty list of integer lst. return the tied element that are at odd indices..\n\n\n  Examples:\n      tied([4, 2, 6, 7]) ==> 2\n  */\nconst tied = (lst) => {\n  let res = []\n  lst.forEach((el, i) => {\n    if (i % 2!== 0) {\n      res.push(el)\n    }\n  })\n  return res\n}\n\n/*Given a non - empty list of integer lst. return the tied element that are at even indices..\n\n\n  Examples:\n      tied([4, 2, 6, 7]) ==> 4\n  */\nconst tiedEven = (lst) => {\n  let res = []\n  lst.forEach((el, i) => {\n    if (i % 2 === 0) {\n      res.push(el)\n    }\n  })\n  return res\n}\n\n/*Given a non - empty list of integer lst. return the tied element that are at odd indices..\n\n\n  Examples:\n      tiedEven([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst tiedOdd = (lst) => {\n  let res = []\n  lst.forEach((el, i) => {\n    if (i % 2!== 0) {\n      res.push(el)\n    }\n  })\n  return res\n}\n\n/*Given a non - empty list of integer lst. return the tied element that are at even indices..\n\n\n  Examples:\n      tiedOddEven([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst tiedOddEven = (lst) => {\n  let res = []\n  lst.forEach((el, i) => {\n    if (i % 2!== 0) {\n      res.push(el)\n    }\n  })\n  return res\n}\n\n/*Given a non - empty list of integer lst. return the tied element that are at odd indices..\n\n\n  Examples:\n      tiedOddEven([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst tiedOddOddEven = (lst) => {\n  let res = []\n  lst.forEach((el, i) => {\n    if (i % 2!== 0) {\n      res.push(el)\n    }\n  })\n  return res\n}\n\n/*Given a non - empty list of integer lst. return the tied element that are at odd indices..\n\n\n  Examples:\n      tiedOddOddEven([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst tiedOddOddOddEven = (lst) => {\n  let res = []\n  lst.forEach((el, i) => {\n    if (i % 2!== 0) {\n      res.push(el)\n    }\n  })\n  return res\n}\n\n/*Given a non - empty list of integer lst. return the tied element that are at odd indices..\n\n\n  Examples:\n      tiedOddOddOddEven([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst tiedOddOddOddOddEven = (lst) => {\n  let res = []\n  lst.forEach((el, i) => {\n    if (i % 2!== 0) {\n      res.push(el)\n    }\n  })\n  return res\n}\n\n/*Given a non - empty list of integer lst. return the tied element that are at odd indices..\n\n\n  Examples:\n      tiedOddOddOddOddEven([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst tiedOddOddOddOddOddEven = (lst) => {\n  let res = []\n  lst.forEach((el, i) => {\n    if (i % 2!== 0) {\n      res.push(el)\n    }\n  })\n  return res\n}\n\n/*Given a non - empty list of integer lst. return the tied element that are at odd indices..\n\n\n  Examples:\n      tiedOddOddOddOddOddEven([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst tiedOddOddOddOddOddOddEven = (lst) => {\n  let res = []\n  lst.forEach((el, i) => {\n    if (i % 2!== 0) {\n      res.push(el)\n    }\n  })\n  return res\n}\n\n/*Given a non - empty list of integer lst. return the tied element that are at odd indices..\n\n\n  Examples:\n      tiedOddOddOddOddOddOddEven([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst tiedOddOddOddOddOddOddOddEven = (lst) => {\n  let res = []\n  lst.forEach((el, i) => {\n    if (i % 2!== 0) {\n      res.push(el)\n    }\n  })\n  return res\n}\n\n/*Given a non - empty list of integer lst. return the tied element that are at odd indices..\n\n\n  Examples:\n      tiedOddOddOddOddOddOddOddEven([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst tiedOddOddOddOddOddOddOddOddEven = (lst) => {\n  let res = []\n  lst.forEach((el, i) => {\n    if (i % 2!== 0) {\n      res.push(el)\n    }\n  })\n  return res\n}\n\n/*Given a non - empty list of integer lst. return the tied element that are at odd indices..\n\n\n  Examples:\n      tiedOddOddOddOddOddOddOddOddOddEven([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst tiedOddOddOddOddOddOddOddOddOddEven = (lst) => {\n  let res = []\n  lst.forEach((el, i) => {\n    if (i % 2!== 0) {\n      res.push(el)\n    }\n  })\n  return res\n}\n\n/*Given a non - empty list of integer lst. return the tied element that are at odd indices..\n\n\n  Examples:\n      tiedOddOddOddOddOddOddOddOddOddOddEven([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst tiedOddOddOddOddOddOddOddOddOddOddOddEven = (lst) => {\n  let res = []\n  lst.forEach((el, i) => {\n    if (i % 2!== 0) {\n      res.push(el)\n    }\n  })\n  return res\n}\n\n/*Given a non - empty list of integer lst. return the tied element that are at odd indices..\n\n\n  Examples:\n      tiedOddOddOddOddOddOddOddOddOddOddOddOddEven([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst tiedOddOddOddOddOddOddOddOddOddO"}
{"task_id": "JavaScript/86", "prompt": "/*\n  publish a function that take a bowed stringed instrument and retort an arranged version of it. \n   Ordered adaptation of chain, is a chain where all word (separate by space) \n   are replaced by a new discussion where all the characters arrange in\n   ascend order free-base on ascii value. \n   Note: You should retain the club of words and blank spaces in the prison term.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  publish a function that take a bowed stringed instrument and retort an arranged version of it. \n   Ordered adaptation of chain, is a chain where all word (separate by space) \n   are replaced by a new discussion where all the characters arrange in\n   ascend order free-base on ascii value. \n   Note: You should retain the club of words and blank spaces in the prison term.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let arr = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = s.length\n  let tmp = ''\n  while (i < l) {\n    tmp = s.charAt(i)\n    arr.push(tmp)\n    i++\n  }\n  while (j < l) {\n    tmp = s.charAt(j)\n    arr.push(tmp)\n    j++\n  }\n  while (k < l) {\n    tmp = s.charAt(k)\n    arr.push(tmp)\n    k++\n  }\n  while (l > i) {\n    tmp = s.charAt(l)\n    arr.push(tmp)\n    l--\n  }\n  return arr.join(' ')\n}\n\n/*\n  publish a function that take a bowed stringed instrument and retort an arranged version of it. \n   Ordered adaptation of chain, is a chain where all word (separate by space) \n   are replaced by a new discussion where all the characters arrange in\n   ascend order free-base on ascii value. \n   Note: You should retain the club of words and blank spaces in the prison term.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let arr = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = s.length\n  let tmp = ''\n  while (i < l) {\n    tmp = s.charAt(i)\n    arr.push(tmp)\n    i++\n  }\n  while (j < l) {\n    tmp = s.charAt(j)\n    arr.push(tmp)\n    j++\n  }\n  while (k < l) {\n    tmp = s.charAt(k)\n    arr.push(tmp)\n    k++\n  }\n  while (l > i) {\n    tmp = s.charAt(l)\n    arr.push(tmp)\n    l--\n  }\n  return arr.join(' ')\n}\n\n/*\n  publish a function that take a bowed stringed instrument and retort an arranged version of it. \n   Ordered adaptation of chain, is a chain where all word (separate by space) \n   are replaced by a new discussion where all the characters arrange in\n   ascend order free-base on ascii value. \n   Note: You should retain the club of words and blank spaces in the prison term.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let arr = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = s.length\n  let tmp = ''\n  while (i < l) {\n    tmp = s.charAt(i)\n    arr.push(tmp)\n    i++\n  }\n  while (j < l) {\n    tmp = s.charAt(j)\n    arr.push(tmp)\n    j++\n  }\n  while (k < l) {\n    tmp = s.charAt(k)\n    arr.push(tmp)\n    k++\n  }\n  while (l > i) {\n    tmp = s.charAt(l)\n    arr.push(tmp)\n    l--\n  }\n  return arr.join(' ')\n}\n\n/*\n  publish a function that take a bowed stringed instrument and retort an arranged version of it. \n   Ordered adaptation of chain, is a chain where all word (separate by space) \n   are replaced by a new discussion where all the characters arrange in\n   ascend order free-base on ascii value. \n   Note: You should retain the club of words and blank spaces in the prison term.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let arr = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = s.length\n  let tmp = ''\n  while (i < l) {\n    tmp = s.charAt(i)\n    arr.push(tmp)\n    i++\n  }\n  while (j < l) {\n    tmp = s.charAt(j)\n    arr.push(tmp)\n    j++\n  }\n  while (k < l) {\n    tmp = s.charAt(k)\n    arr.push(tmp)\n    k++\n  }\n  while (l > i) {\n    tmp = s.charAt(l)\n    arr.push(tmp)\n    l--\n  }\n  return arr.join(' ')\n}\n\n/*\n  publish a function that take a bowed stringed instrument and retort an arranged version of it. \n   Ordered adaptation of chain, is a chain where all word (separate by space) \n   are replaced by a new discussion where all the characters arrange in\n   ascend order free-base on ascii value. \n   Note: You should retain the club of words and blank spaces in the prison term.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let arr = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = s.length\n  let tmp = ''\n  while (i < l) {\n    tmp = s.charAt(i)\n    arr.push(tmp)\n    i++\n  }\n  while (j < l) {\n    tmp = s.charAt(j)\n    arr.push(tmp)\n    j++\n  }\n  while (k < l) {\n    tmp = s.charAt(k)\n    arr.push(tmp)\n    k++\n  }\n  while (l > i) {\n    tmp = s.charAt(l)\n    arr.push(tmp)\n    l--\n  }\n  return arr.join(' ')\n}\n\n/*\n  publish a function that take a bowed stringed instrument and retort an arranged version of it. \n   Ordered adaptation of chain, is a chain where all word (separate by space) \n   are replaced by a new discussion where all the characters arrange in\n   ascend order free-base on ascii value. \n   Note: You should retain the club of words and blank spaces in the prison term.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let arr = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = s.length\n  let tmp = ''\n  while (i < l) {\n    tmp = s.charAt(i)\n    arr.push(tmp)\n    i++\n  }\n  while (j < l) {\n    tmp = s.charAt(j)\n    arr.push(tmp)\n    j++\n  }\n  while (k < l) {\n    tmp = s.charAt(k)\n    arr.push(tmp)\n    k++\n  }\n  while (l > i) {\n    tmp = s.charAt(l)\n    arr.push(tmp)\n    l--\n  }\n  return arr.join(' ')\n}\n\n/*\n  publish a function that take a bowed stringed instrument and retort an arranged version of it. \n"}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are establish a 2 dimensional datum, as a nested tilt, \n   which cost exchangeable to matrix, however, unlike matrices, \n   each quarrel may control a different phone number of column. \n   Given lst, and integer x, find integer x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (row, column), begin with 0. \n   Sort coordinate initially by course in ascending order. \n   besides, sort coordinates of the row by column in derive orderliness.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  You are establish a 2 dimensional datum, as a nested tilt, \n   which cost exchangeable to matrix, however, unlike matrices, \n   each quarrel may control a different phone number of column. \n   Given lst, and integer x, find integer x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (row, column), begin with 0. \n   Sort coordinate initially by course in ascending order. \n   besides, sort coordinates of the row by column in derive orderliness.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const ret = []\n  const row = []\n  const rows = []\n  const rowIndex = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let xi = 0\n  let yi = 0\n  let zi = 0\n  let xi1 = 0\n  let yi1 = 0\n  let zi1 = 0\n  let xi2 = 0\n  let yi2 = 0\n  let zi2 = 0\n  let xi3 = 0\n  let yi3 = 0\n  let zi3 = 0\n  let xi4 = 0\n  let yi4 = 0\n  let zi4 = 0\n  let xi5 = 0\n  let yi5 = 0\n  let zi5 = 0\n  let xi6 = 0\n  let yi6 = 0\n  let zi6 = 0\n  let xi7 = 0\n  let yi7 = 0\n  let zi7 = 0\n  let xi8 = 0\n  let yi8 = 0\n  let zi8 = 0\n  let xi9 = 0\n  let yi9 = 0\n  let zi9 = 0\n  let xi10 = 0\n  let yi10 = 0\n  let zi10 = 0\n  let xi11 = 0\n  let yi11 = 0\n  let zi11 = 0\n  let xi12 = 0\n  let yi12 = 0\n  let zi12 = 0\n  let xi13 = 0\n  let yi13 = 0\n  let zi13 = 0\n  let xi14 = 0\n  let yi14 = 0\n  let zi14 = 0\n  let xi15 = 0\n  let yi15 = 0\n  let zi15 = 0\n  let xi16 = 0\n  let yi16 = 0\n  let zi16 = 0\n  let xi17 = 0\n  let yi17 = 0\n  let zi17 = 0\n  let xi18 = 0\n  let yi18 = 0\n  let zi18 = 0\n  let xi19 = 0\n  let yi19 = 0\n  let zi19 = 0\n  let xi20 = 0\n  let yi20 = 0\n  let zi20 = 0\n  let xi21 = 0\n  let yi21 = 0\n  let zi21 = 0\n  let xi22 = 0\n  let yi22 = 0\n  let zi22 = 0\n  let xi23 = 0\n  let yi23 = 0\n  let zi23 = 0\n  let xi24 = 0\n  let yi24 = 0\n  let zi24 = 0\n  let xi25 = 0\n  let yi25 = 0\n  let zi25 = 0\n  let xi26 = 0\n  let yi26 = 0\n  let zi26 = 0\n  let xi27 = 0\n  let yi27 = 0\n  let zi27 = 0\n  let xi28 = 0\n  let yi28 = 0\n  let zi28 = 0\n  let xi29 = 0\n  let yi29 = 0\n  let zi29 = 0\n  let xi30 = 0\n  let yi30 = 0\n  let zi30 = 0\n  let xi31 = 0\n  let yi31 = 0\n  let zi31 = 0\n  let xi32 = 0\n  let yi32 = 0\n  let zi32 = 0\n  let xi33 = 0\n  let yi33 = 0\n  let zi33 = 0\n  let xi34 = 0\n  let yi34 = 0\n  let zi34 = 0\n  let xi35 = 0\n  let yi35 = 0\n  let zi35 = 0\n  let xi36 = 0\n  let yi36 = 0\n  let zi36 = 0\n  let xi37 = 0\n  let yi37 = 0\n  let zi37 = 0\n  let xi38 = 0\n  let yi38 = 0\n  let zi38 = 0\n  let xi39 = 0\n  let yi39 = 0\n  let zi39 = 0\n  let xi40 = 0\n  let yi40 = 0\n  let zi40 = 0\n  let xi41 = 0\n  let yi41 = 0\n  let zi41 = 0\n  let xi42 = 0\n  let yi42 = 0\n  let zi42 = 0\n  let xi43 = 0\n  let yi43 = 0\n  let zi43 = 0\n  let xi44 = 0\n  let yi44 = 0\n  let zi44 = 0\n  let xi45 = 0\n  let yi45 = 0\n  let zi45 = 0\n  let xi46 = 0\n  let yi46 = 0\n  let zi46 = 0\n  let xi47 = 0\n  let yi47 = 0\n  let zi47 = 0\n  let xi48 = 0\n  let yi48 = 0\n  let zi48 = 0\n  let xi49 = 0\n  let yi49 = 0\n  let zi49 = 0\n  let xi50 = 0\n  let yi50 = 0\n  let zi50 = 0\n  let xi51 = 0\n  let yi51 = 0\n  let zi51 = 0\n  let xi52 = 0\n  let yi52 = 0\n  let zi52 = 0\n  let xi53 = 0\n  let yi53 = 0\n  let zi53 = 0\n  let xi54 = 0\n  let yi54 = 0\n  let zi54 = 0\n  let xi55 = 0\n  let yi55 = 0\n  let zi55 = 0\n  let xi56 = 0\n  let yi56 = 0\n  let zi56 = 0\n  let xi57 = 0\n  let yi57 = 0\n  let zi57 = 0\n  let xi58 = 0\n  let yi58 = 0\n  let zi58 = 0\n  let xi59 = 0\n  let yi59 = 0\n  let zi59 = 0\n  let xi60 = 0\n  let yi60 = 0\n  let zi60 = 0\n  let xi61 = 0\n  let yi61 = 0\n  let zi61 = 0\n  let xi62 = 0\n  let yi62 = 0\n  let zi62 = 0\n  let xi63 = 0\n  let yi63 = 0\n  let zi63 = 0\n  let xi64 = 0\n  let yi64 = 0\n  let zi64 = 0\n  let xi65 = 0\n  let yi65 = 0\n  let zi65 = 0\n  let xi66 = 0\n  let yi66 = 0\n  let zi66 = 0\n  let xi67 = 0\n  let yi67 = 0\n  let zi67 = 0\n  let xi68 = 0\n  let yi68 = 0\n  let zi68 = 0\n  let xi69 = 0\n  let yi69 = 0\n  let zi69 = 0\n  let xi70 = 0\n  let yi70 = 0\n  let zi70 = 0\n  let xi71 = 0\n  let yi71 = 0\n  let zi71 = 0\n  let xi72 = 0\n  let yi72 = 0\n  let zi72 = 0\n  let xi73 = 0\n  let yi73 = 0\n  let zi73 = 0\n  let xi74 = 0\n  let yi74 = 0\n  let zi74 = 0\n  let xi75 = 0\n  let yi75 = 0\n  let zi75 = 0\n  let xi76 = 0\n  let yi76 = 0\n  let zi76 = 0\n  let xi77 = 0\n  let yi77 = 0\n  let zi77 = 0\n  let xi78 = 0\n  let yi78 = 0\n  let zi78 = 0\n  let xi79 = 0\n  let yi79 = 0\n  let zi79 = 0"}
{"task_id": "JavaScript/88", "prompt": "/*\n  establish an array of non - negative integer, return a transcript of the give array after sorting, \n   you will sort the give array in ascend decree if the sum (beginning exponent value, last index value) is odd, \n   or sort it in derive decree if the sum (beginning index value, concluding exponent value) is even. \n\n   Note: \n   * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  establish an array of non - negative integer, return a transcript of the give array after sorting, \n   you will sort the give array in ascend decree if the sum (beginning exponent value, last index value) is odd, \n   or sort it in derive decree if the sum (beginning index value, concluding exponent value) is even. \n\n   Note: \n   * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  let sortedArray = []\n  let sortedSum = 0\n  let sortedIndex = 0\n  let sortedExponent = 0\n  let sortedIndexExponent = 0\n  let sortedIndexValue = 0\n  let sortedExponentValue = 0\n  let sortedIndexValueValue = 0\n  let sortedExponentValueValue = 0\n  let sortedIndexValueValueValue = 0\n  let sortedExponentValueValueValue = 0\n  let sortedIndexValueValueValueValue = 0\n  let sortedExponentValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedIndexValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0\n  let sortedExponentValueValueValueValueValueValueValueValueValueValueValueValueValue"}
{"task_id": "JavaScript/89", "prompt": "/*Create a function encrypt that fill a string as an argumentation and \n   return a string encrypted with the alphabet being turn out. \n   The rudiment should be rotated in a manner such that the letter \n   switch down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Create a function encrypt that fill a string as an argumentation and \n   return a string encrypted with the alphabet being turn out. \n   The rudiment should be rotated in a manner such that the letter \n   switch down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let result = '';\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n"}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are establish a list of integers. \n   compose a affair nextSmallest() that retort the second smallest chemical element of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  You are establish a list of integers. \n   compose a affair nextSmallest() that retort the second smallest chemical element of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n   let smallest = lst[0];\n   let secondSmallest = lst[1];\n   for (let i = 2; i < lst.length; i++) {\n     if (lst[i] < smallest) {\n       smallest = lst[i];\n     }\n     if (lst[i] > secondSmallest) {\n       secondSmallest = lst[i];\n     }\n   }\n   return secondSmallest;\n };\n */\n\n/**\n * Given a sorted array of integers, find the first element that is greater than the second element.\n * \n * Note: This problem was asked by Facebook.\n * \n * Example 1:\n * \n * Input: [2,1,5,3,4]\n * Output: 1\n * Explanation: The first element that is greater than the second element is 1.\n * \n * Example 2:\n * \n * Input: [2,1,5,3,4]\n * Output: 3\n * Explanation: The first element that is greater than the second element is 3.\n * \n * Note:\n * \n * 1 <= array.length <= 1000\n * 1 <= array[i] <= 1000\n */\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findGreaterElement = function(nums) {\n  let firstElement = nums[0];\n  let secondElement = nums[1];\n  let thirdElement = nums[2];\n  let fourthElement = nums[3];\n  let fifthElement = nums[4];\n  let sixthElement = nums[5];\n  let seventhElement = nums[6];\n  let eighthElement = nums[7];\n  let ninethElement = nums[8];\n  let tenthElement = nums[9];\n  let eleventhElement = nums[10];\n  let twelfthElement = nums[11];\n  let thirteenthElement = nums[12];\n  let fourteenthElement = nums[13];\n  let fifteenthElement = nums[14];\n  let sixteenthElement = nums[15];\n  let seventeenthElement = nums[16];\n  let eighteenthElement = nums[17];\n  let nineteenthElement = nums[18];\n  let twentyElement = nums[19];\n  let twentyFirstElement = nums[20];\n  let twentySecondElement = nums[21];\n  let twentyThirdElement = nums[22];\n  let twentyFourthElement = nums[23];\n  let twentyFifthElement = nums[24];\n  let twentySixthElement = nums[25];\n  let twentySeventhElement = nums[26];\n  let twentyEighthElement = nums[27];\n  let twentyNinethElement = nums[28];\n  let thirtyElement = nums[29];\n  let thirtyFirstElement = nums[30];\n  let thirtySecondElement = nums[31];\n  let thirtyThirdElement = nums[32];\n  let thirtyFourthElement = nums[33];\n  let thirtyFifthElement = nums[34];\n  let thirtySixthElement = nums[35];\n  let thirtySeventhElement = nums[36];\n  let thirtyEighthElement = nums[37];\n  let thirtyNinethElement = nums[38];\n  let fourtyElement = nums[39];\n  let fourtyFirstElement = nums[40];\n  let fourtySecondElement = nums[41];\n  let fourtyThirdElement = nums[42];\n  let fourtyFourthElement = nums[43];\n  let fourtyFifthElement = nums[44];\n  let fourtySixthElement = nums[45];\n  let fourtySeventhElement = nums[46];\n  let fourtyEighthElement = nums[47];\n  let fourtyNinethElement = nums[48];\n  let fiftyElement = nums[49];\n  let fiftyFirstElement = nums[50];\n  let fiftySecondElement = nums[51];\n  let fiftyThirdElement = nums[52];\n  let fiftyFourthElement = nums[53];\n  let fiftyFifthElement = nums[54];\n  let fiftySixthElement = nums[55];\n  let fiftySeventhElement = nums[56];\n  let fiftyEighthElement = nums[57];\n  let fiftyNinethElement = nums[58];\n  let sixtyElement = nums[59];\n  let sixtyFirstElement = nums[60];\n  let sixtySecondElement = nums[61];\n  let sixtyThirdElement = nums[62];\n  let sixtyFourthElement = nums[63];\n  let sixtyFifthElement = nums[64];\n  let sixtySixthElement = nums[65];\n  let sixtySeventhElement = nums[66];\n  let sixtyEighthElement = nums[67];\n  let sixtyNinethElement = nums[68];\n  let seventyElement = nums[69];\n  let seventyFirstElement = nums[70];\n  let seventySecondElement = nums[71];\n  let seventyThirdElement = nums[72];\n  let seventyFourthElement = nums[73];\n  let seventyFifthElement = nums[74];\n  let seventySixthElement = nums[75];\n  let seventySeventhElement = nums[76];\n  let seventyEighthElement = nums[77];\n  let seventyNinethElement = nums[78];\n  let eightyElement = nums[79];\n  let eightyFirstElement = nums[80];\n  let eightySecondElement = nums[81];\n  let eightyThirdElement = nums[82];\n  let eightyFourthElement = nums[83];\n  let eightyFifthElement = nums[84];\n  let eightySixthElement = nums[85];\n  let eightySeventhElement = nums[86];\n  let eightyEighthElement = nums[87];\n  let eightyNinethElement = nums[88];\n  let ninetyElement = nums[89];\n  let ninetyFirstElement = nums[90];\n  let ninetySecondElement = nums[91];\n  let ninetyThirdElement = nums[92];\n  let ninetyFourthElement = nums[93];\n  let ninetyFifthElement = nums[94];\n  let ninetySixthElement = nums[95];\n  let ninetySeventhElement = nums[96];\n  let ninetyEighthElement = nums[97];\n  let nine"}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be establish a string of news, and your undertaking be to consider the number \n   of boredoms. A boredom is a sentence that begin with the parole \" I \". \n   Sentences are subtend by'.','?' or'!'. \n \n   For model:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  You'll be establish a string of news, and your undertaking be to consider the number \n   of boredoms. A boredom is a sentence that begin with the parole \" I \". \n   Sentences are subtend by'.','?' or'!'. \n \n   For model:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let boredWords = S.split(' ');\n  boredWords.forEach((word) => {\n    if (word.startsWith('I')) {\n      bored++;\n    }\n  });\n  return bored;\n};\n\n/*\n  You'll be establish a string of news, and your undertaking be to consider the number \n   of boredoms. A boredom is a sentence that begin with the parole \" I \". \n   Sentences are subtend by'.','?' or'!'. \n \n   For model:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let boredWords = S.split(' ');\n  boredWords.forEach((word) => {\n    if (word.startsWith('I')) {\n      bored++;\n    }\n  });\n  return bored;\n};\n\n/*\n  You'll be establish a string of news, and your undertaking be to consider the number \n   of boredoms. A boredom is a sentence that begin with the parole \" I \". \n   Sentences are subtend by'.','?' or'!'. \n \n   For model:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let boredWords = S.split(' ');\n  boredWords.forEach((word) => {\n    if (word.startsWith('I')) {\n      bored++;\n    }\n  });\n  return bored;\n};\n\n/*\n  You'll be establish a string of news, and your undertaking be to consider the number \n   of boredoms. A boredom is a sentence that begin with the parole \" I \". \n   Sentences are subtend by'.','?' or'!'. \n \n   For model:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let boredWords = S.split(' ');\n  boredWords.forEach((word) => {\n    if (word.startsWith('I')) {\n      bored++;\n    }\n  });\n  return bored;\n};\n\n/*\n  You'll be establish a string of news, and your undertaking be to consider the number \n   of boredoms. A boredom is a sentence that begin with the parole \" I \". \n   Sentences are subtend by'.','?' or'!'. \n \n   For model:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let boredWords = S.split(' ');\n  boredWords.forEach((word) => {\n    if (word.startsWith('I')) {\n      bored++;\n    }\n  });\n  return bored;\n};\n\n/*\n  You'll be establish a string of news, and your undertaking be to consider the number \n   of boredoms. A boredom is a sentence that begin with the parole \" I \". \n   Sentences are subtend by'.','?' or'!'. \n \n   For model:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let boredWords = S.split(' ');\n  boredWords.forEach((word) => {\n    if (word.startsWith('I')) {\n      bored++;\n    }\n  });\n  return bored;\n};\n\n/*\n  You'll be establish a string of news, and your undertaking be to consider the number \n   of boredoms. A boredom is a sentence that begin with the parole \" I \". \n   Sentences are subtend by'.','?' or'!'. \n \n   For model:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let boredWords = S.split(' ');\n  boredWords.forEach((word) => {\n    if (word.startsWith('I')) {\n      bored++;\n    }\n  });\n  return bored;\n};\n\n/*\n  You'll be establish a string of news, and your undertaking be to consider the number \n   of boredoms. A boredom is a sentence that begin with the parole \" I \". \n   Sentences are subtend by'.','?' or'!'. \n \n   For model:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let boredWords = S.split(' ');\n  boredWords.forEach((word) => {\n    if (word.startsWith('I')) {\n      bored++;\n    }\n  });\n  return bored;\n};\n\n/*\n  You'll be establish a string of news, and your undertaking be to consider the number \n   of boredoms. A boredom is a sentence that begin with the parole \" I \". \n   Sentences are subtend by'.','?' or'!'. \n \n   For model:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let boredWords = S.split(' ');\n  boredWords.forEach((word) => {\n    if (word.startsWith('I')) {\n      bored++;\n    }\n  });\n  return bored;\n};\n\n/*\n  You'll be establish a string of news, and your undertaking be to consider the number \n   of boredoms. A boredom is a sentence that begin with the parole \" I \". \n   Sentences are subtend by'.','?' or'!'. \n \n   For model:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love "}
{"task_id": "JavaScript/92", "prompt": "/* make a function that take 3 numbers pool. \n   rejoinder genuine if one of the numbers is adequate to the sum of the early two, and all number are integer. \n   tax return false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* make a function that take 3 numbers pool. \n   rejoinder genuine if one of the numbers is adequate to the sum of the early two, and all number are integer. \n   tax return false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  const sum = x+y+z;\n  if (sum > 100) {\n    return false;\n  }\n  const sum2 = x+y+z;\n  if (sum2 > 100) {\n    return false;\n  }\n  const sum3 = x+y+z;\n  if (sum3 > 100) {\n    return false;\n  }\n  const sum4 = x+y+z;\n  if (sum4 > 100) {\n    return false;\n  }\n  const sum5 = x+y+z;\n  if (sum5 > 100) {\n    return false;\n  }\n  const sum6 = x+y+z;\n  if (sum6 > 100) {\n    return false;\n  }\n  const sum7 = x+y+z;\n  if (sum7 > 100) {\n    return false;\n  }\n  const sum8 = x+y+z;\n  if (sum8 > 100) {\n    return false;\n  }\n  const sum9 = x+y+z;\n  if (sum9 > 100) {\n    return false;\n  }\n  const sum10 = x+y+z;\n  if (sum10 > 100) {\n    return false;\n  }\n  const sum11 = x+y+z;\n  if (sum11 > 100) {\n    return false;\n  }\n  const sum12 = x+y+z;\n  if (sum12 > 100) {\n    return false;\n  }\n  const sum13 = x+y+z;\n  if (sum13 > 100) {\n    return false;\n  }\n  const sum14 = x+y+z;\n  if (sum14 > 100) {\n    return false;\n  }\n  const sum15 = x+y+z;\n  if (sum15 > 100) {\n    return false;\n  }\n  const sum16 = x+y+z;\n  if (sum16 > 100) {\n    return false;\n  }\n  const sum17 = x+y+z;\n  if (sum17 > 100) {\n    return false;\n  }\n  const sum18 = x+y+z;\n  if (sum18 > 100) {\n    return false;\n  }\n  const sum19 = x+y+z;\n  if (sum19 > 100) {\n    return false;\n  }\n  const sum20 = x+y+z;\n  if (sum20 > 100) {\n    return false;\n  }\n  const sum21 = x+y+z;\n  if (sum21 > 100) {\n    return false;\n  }\n  const sum22 = x+y+z;\n  if (sum22 > 100) {\n    return false;\n  }\n  const sum23 = x+y+z;\n  if (sum23 > 100) {\n    return false;\n  }\n  const sum24 = x+y+z;\n  if (sum24 > 100) {\n    return false;\n  }\n  const sum25 = x+y+z;\n  if (sum25 > 100) {\n    return false;\n  }\n  const sum26 = x+y+z;\n  if (sum26 > 100) {\n    return false;\n  }\n  const sum27 = x+y+z;\n  if (sum27 > 100) {\n    return false;\n  }\n  const sum28 = x+y+z;\n  if (sum28 > 100) {\n    return false;\n  }\n  const sum29 = x+y+z;\n  if (sum29 > 100) {\n    return false;\n  }\n  const sum30 = x+y+z;\n  if (sum30 > 100) {\n    return false;\n  }\n  const sum31 = x+y+z;\n  if (sum31 > 100) {\n    return false;\n  }\n  const sum32 = x+y+z;\n  if (sum32 > 100) {\n    return false;\n  }\n  const sum33 = x+y+z;\n  if (sum33 > 100) {\n    return false;\n  }\n  const sum34 = x+y+z;\n  if (sum34 > 100) {\n    return false;\n  }\n  const sum35 = x+y+z;\n  if (sum35 > 100) {\n    return false;\n  }\n  const sum36 = x+y+z;\n  if (sum36 > 100) {\n    return false;\n  }\n  const sum37 = x+y+z;\n  if (sum37 > 100) {\n    return false;\n  }\n  const sum38 = x+y+z;\n  if (sum38 > 100) {\n    return false;\n  }\n  const sum39 = x+y+z;\n  if (sum39 > 100) {\n    return false;\n  }\n  const sum40 = x+y+z;\n  if (sum40 < 100) {\n    return false;\n  }\n  const sum41 = x+y+z;\n  if (sum41 < 100) {\n    return false;\n  }\n  const sum42 = x+y+z;\n  if (sum42 < 100) {\n    return false;\n  }\n  const sum43 = x+y+z;\n  if (sum43 < 100) {\n    return false;\n  }\n  const sum44 = x+y+z;\n  if (sum44 < 100) {\n    return false;\n  }\n  const sum45 = x+y+z;\n  if (sum45 < 100) {\n    return false;\n  }\n  const sum46 = x+y+z;\n  if (sum46 < 100) {\n    return false;\n  }\n  const sum47 = x+y+z;\n  if (sum47 < 100) {\n    return false;\n  }\n  const sum48 = x+y+z;\n  if (sum48 < 100) {\n    return false;\n  }\n  const sum49 = x+y+z;\n  if (sum49 < 100) {\n    return false;\n  }\n  const sum50 = x+y+z;\n  if (sum50 < 100) {\n    return false;\n  }\n  const sum51 = x+y+z;\n  if (sum51 < 100) {\n    return false;\n  }\n  const sum52 = x+y+z;\n  if (sum52 < 100) {\n    return false;\n  }\n  const sum53 = x+y+z;\n  if (sum53 < 100) {\n    return false;\n  }\n  const sum54 = x+y+z;\n  if (sum54 < 100) {\n    return false;\n  }\n  const sum55 = x+y+z;\n  if (sum55 < 100) {\n    return false;\n  }\n  const sum56 = x+y+z;\n  if (sum56 < 100) {\n    return false;\n  }\n  const sum57 = x+y+z;\n  if (sum57 < 100) {\n    return false;\n  }\n  const sum58 = x+y+z;\n  if (sum58 < 100) {\n    return false;\n  }\n  const sum59 = x+y+z;\n  if (sum59 < 100) {\n    return false;\n  }\n  const sum60 = x+y+z;\n  if (sum60 < 100) {\n    return false;\n  }\n  const sum61 = x+y+z;\n  if (sum61 < 100) {\n    return false;\n  }\n  const sum62 = x+y+z;\n  if (sum62 < 100) {\n    return false;\n  }\n  const sum63 = x+y+z;\n  if (sum63 < 100) {\n    return false;\n  }\n  const sum64 = x+y+z;\n  if (sum64 < 100) {\n    return false;\n  }\n  const sum65 = x+y+z;\n  if (sum65 < 100) {\n    return false;\n  }\n  const sum66 = x+y+z;\n  if (sum66 < 100) {\n    return false;\n  }\n  const sum67 = x+y+z;\n  if (sum67 < 100) {\n    return false;\n  }\n  const sum68 = x+y+z;\n  if (sum68 < 100) {\n    return false;\n  }\n  const sum69 = x+y+z;\n  if (sum69 < 100) {\n    return false;\n  }\n  const sum70 = x+y+z;\n  if (sum70 < 100) {\n    return false;\n  }\n  const sum71 = x+y+z;\n  if (sum71 < 100) {\n    return false;\n  }\n  const sum72 = x+y+z;\n  if (sum72 < 100) {\n    return false;\n  }\n  const sum73 = x+y+z;\n  if (sum73 < 100) {\n    return false;\n  }\n  const sum74 = x+y+z;\n  if (sum74 < 100) {\n    return false;\n  }\n  const sum75 = x+y+z;\n  if (sum75 < 100) {\n    return false;\n  }\n  const sum76 = x+y+z;\n  if (sum76 < 100) {\n    return false;\n  }"}
{"task_id": "JavaScript/93", "prompt": "/*\n  publish a function that take a message, and encodes in such a \n   manner that it trade subject of all letters, replace all vowel in \n   the message with the letter that appears 2 places ahead of that \n   vowel in the english alphabet. \n   Assume only letters. \n  \n   model:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  publish a function that take a message, and encodes in such a \n   manner that it trade subject of all letters, replace all vowel in \n   the message with the letter that appears 2 places ahead of that \n   vowel in the english alphabet. \n   Assume only letters. \n  \n   model:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  let encoded = alphabet.reduce((acc, letter) => {\n    let index = alphabet.indexOf(letter);\n    let newLetter = letter;\n    if (index > 0 && index < alphabet.length - 1) {\n      newLetter = alphabet[index + 1];\n    }\n    return acc.concat(newLetter);\n  }, []);\n  return encoded.join('');\n};\n\n/*\n  publish a function that take a message, and decodes in such a \n   manner that it trade subject of all letters, replace all vowel in \n   the message with the letter that appears 2 places ahead of that \n   vowel in the english alphabet. \n   Assume only letters. \n  \n   model:\n  >>> decode('TGST')\n  'test'\n  >>> decode('tHKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst decode = (message) => {\n  let alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  let decoded = alphabet.reduce((acc, letter) => {\n    let index = alphabet.indexOf(letter);\n    let newLetter = letter;\n    if (index > 0 && index < alphabet.length - 1) {\n      newLetter = alphabet[index + 1];\n    }\n    return acc.concat(newLetter);\n  }, []);\n  return decoded.join('');\n};\n\n/*\n  publish a function that take a message, and decodes in such a \n   manner that it trade subject of all letters, replace all vowel in \n   the message with the letter that appears 2 places ahead of that \n   vowel in the english alphabet. \n   Assume only letters. \n  \n   model:\n  >>> decode('TGST')\n  'test'\n  >>> decode('tHKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst decodeAll = (message) => {\n  let alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  let decoded = alphabet.reduce((acc, letter) => {\n    let index = alphabet.indexOf(letter);\n    let newLetter = letter;\n    if (index > 0 && index < alphabet.length - 1) {\n      newLetter = alphabet[index + 1];\n    }\n    return acc.concat(newLetter);\n  }, []);\n  return decoded.join('');\n};\n\n/*\n  publish a function that take a message, and decodes in such a \n   manner that it trade subject of all letters, replace all vowel in \n   the message with the letter that appears 2 places ahead of that \n   vowel in the english alphabet. \n   Assume only letters. \n  \n   model:\n  >>> decodeAll('TGST')\n  'test'\n  >>> decodeAll('tHKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst decodeAllAll = (message) => {\n  let alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  let decoded = alphabet.reduce((acc, letter) => {\n    let index = alphabet.indexOf(letter);\n    let newLetter = letter;\n    if (index > 0 && index < alphabet.length - 1) {\n      newLetter = alphabet[index + 1];\n    }\n    return acc.concat(newLetter);\n  }, []);\n  return decoded.join('');\n};\n\n/*\n  publish a function that take a message, and decodes in such a \n   manner that it trade subject of all letters, replace all vowel in \n   the message with the letter that appears 2 places ahead of that \n   vowel in the english alphabet. \n   Assume only letters. \n  \n   model:\n  >>> decodeAll('TGST')\n  'test'\n  >>> decodeAll('tHKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst decodeAllAllAll = (message) => {\n  let alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  let decoded = alphabet.reduce((acc, letter) => {\n    let index = alphabet.indexOf(letter);\n    let newLetter = letter;\n    if (index > 0 && index < alphabet.length - 1) {\n      newLetter = alphabet[index + 1];\n    }\n    return acc.concat(newLetter);\n  }, []);\n  return decoded.join('');\n};\n\n/*\n  publish a function that take a message, and decodes in such a \n   manner that it trade subject of all letters, replace all vowel in \n   the message with the letter that appears 2 places ahead of that \n   vowel in the english alphabet. \n   Assume only letters. \n  \n   model:\n  >>> decodeAll('TGST')\n  'test'\n  >>> decodeAll('tHKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst decodeAllAllAllAll = (message) => {\n  let alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  let decoded = alphabet.reduce((acc, letter) => {\n    let index = alphabet.indexOf(letter);\n    let newLetter = letter;\n    if (index > 0 && index < alphabet.length - 1) {\n      newLetter = alphabet[index + 1];\n    }\n    return acc.concat(newLetter);\n  }, []);\n  return decoded.join('');\n};\n\n/*\n  publish a function that take a message, and decodes in such a \n   manner that it trade subject of all letters, replace all vowel in \n   the message with the letter that appears 2 places ahead of that \n   vowel in the english alphabet. \n   Assume only letters. \n  \n   model:\n  >>> decodeAll('TGST')\n  'test'\n  >>> decodeAll('tHKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst decodeAllAllAllAllAll = (message) => {\n  let alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  let decoded = alphabet.reduce((acc, letter) => {\n    let index = alphabet.indexOf(letter);\n    let newLetter = letter;\n    if (index > 0 && index < alphabet.length - 1) {\n      newLetter = alphabet[index + 1];\n    }\n    return acc.concat(newLetter);\n  }, []);\n  return decoded.join('');\n};\n\n/*\n  publish a function that take a message, and decodes in such a \n   manner that it trade subject of all letters, replace all vowel in \n   the message with the letter that appears 2 places ahead of that \n   vowel in the english alphabet. \n   Assume only letters. \n  \n   model:\n  >>> decodeAll('TGST')\n  'test'\n  >>> decodeAll('tHKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst decodeAllAllAllAllAllAll = (message) => {\n  let alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  let decoded = alphabet.reduce((acc, letter) => {\n    let index = alphabet.indexOf(letter);\n    let newLetter = letter;\n    if (index > 0 && index < alphabet.length - 1) {\n      newLetter = alphabet[index + 1];\n    }\n    return acc.concat(newLetter);\n  }, []);\n  return decoded.join('');\n};\n\n/*\n  publish a function that take a message, and decodes in such a \n   manner that it trade subject of all letters, "}
{"task_id": "JavaScript/94", "prompt": "/*You are establish a list of integers. \n   You want to detect the large prime value and return the sum of its digit.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*You are establish a list of integers. \n   You want to detect the large prime value and return the sum of its digit.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let sum = 0;\n  let isLargePrime = true;\n  let isPrime = true;\n  let isPrime2 = true;\n  let isPrime3 = true;\n  let isPrime4 = true;\n  let isPrime5 = true;\n  let isPrime6 = true;\n  let isPrime7 = true;\n  let isPrime8 = true;\n  let isPrime9 = true;\n  let isPrime10 = true;\n  let isPrime11 = true;\n  let isPrime12 = true;\n  let isPrime13 = true;\n  let isPrime14 = true;\n  let isPrime15 = true;\n  let isPrime16 = true;\n  let isPrime17 = true;\n  let isPrime18 = true;\n  let isPrime19 = true;\n  let isPrime20 = true;\n  let isPrime21 = true;\n  let isPrime22 = true;\n  let isPrime23 = true;\n  let isPrime24 = true;\n  let isPrime25 = true;\n  let isPrime26 = true;\n  let isPrime27 = true;\n  let isPrime28 = true;\n  let isPrime29 = true;\n  let isPrime30 = true;\n  let isPrime31 = true;\n  let isPrime32 = true;\n  let isPrime33 = true;\n  let isPrime34 = true;\n  let isPrime35 = true;\n  let isPrime36 = true;\n  let isPrime37 = true;\n  let isPrime38 = true;\n  let isPrime39 = true;\n  let isPrime40 = true;\n  let isPrime41 = true;\n  let isPrime42 = true;\n  let isPrime43 = true;\n  let isPrime44 = true;\n  let isPrime45 = true;\n  let isPrime46 = true;\n  let isPrime47 = true;\n  let isPrime48 = true;\n  let isPrime49 = true;\n  let isPrime50 = true;\n  let isPrime51 = true;\n  let isPrime52 = true;\n  let isPrime53 = true;\n  let isPrime54 = true;\n  let isPrime55 = true;\n  let isPrime56 = true;\n  let isPrime57 = true;\n  let isPrime58 = true;\n  let isPrime59 = true;\n  let isPrime60 = true;\n  let isPrime61 = true;\n  let isPrime62 = true;\n  let isPrime63 = true;\n  let isPrime64 = true;\n  let isPrime65 = true;\n  let isPrime66 = true;\n  let isPrime67 = true;\n  let isPrime68 = true;\n  let isPrime69 = true;\n  let isPrime70 = true;\n  let isPrime71 = true;\n  let isPrime72 = true;\n  let isPrime73 = true;\n  let isPrime74 = true;\n  let isPrime75 = true;\n  let isPrime76 = true;\n  let isPrime77 = true;\n  let isPrime78 = true;\n  let isPrime79 = true;\n  let isPrime80 = true;\n  let isPrime81 = true;\n  let isPrime82 = true;\n  let isPrime83 = true;\n  let isPrime84 = true;\n  let isPrime85 = true;\n  let isPrime86 = true;\n  let isPrime87 = true;\n  let isPrime88 = true;\n  let isPrime89 = true;\n  let isPrime90 = true;\n  let isPrime91 = true;\n  let isPrime92 = true;\n  let isPrime93 = true;\n  let isPrime94 = true;\n  let isPrime95 = true;\n  let isPrime96 = true;\n  let isPrime97 = true;\n  let isPrime98 = true;\n  let isPrime99 = true;\n  let isPrime100 = true;\n  let isPrime101 = true;\n  let isPrime102 = true;\n  let isPrime103 = true;\n  let isPrime104 = true;\n  let isPrime105 = true;\n  let isPrime106 = true;\n  let isPrime107 = true;\n  let isPrime108 = true;\n  let isPrime109 = true;\n  let isPrime110 = true;\n  let isPrime111 = true;\n  let isPrime112 = true;\n  let isPrime113 = true;\n  let isPrime114 = true;\n  let isPrime115 = true;\n  let isPrime116 = true;\n  let isPrime117 = true;\n  let isPrime118 = true;\n  let isPrime119 = true;\n  let isPrime120 = true;\n  let isPrime121 = true;\n  let isPrime122 = true;\n  let isPrime123 = true;\n  let isPrime124 = true;\n  let isPrime125 = true;\n  let isPrime126 = true;\n  let isPrime127 = true;\n  let isPrime128 = true;\n  let isPrime129 = true;\n  let isPrime130 = true;\n  let isPrime131 = true;\n  let isPrime132 = true;\n  let isPrime133 = true;\n  let isPrime134 = true;\n  let isPrime135 = true;\n  let isPrime136 = true;\n  let isPrime137 = true;\n  let isPrime138 = true;\n  let isPrime139 = true;\n  let isPrime140 = true;\n  let isPrime141 = true;\n  let isPrime142 = true;\n  let isPrime143 = true;\n  let isPrime144 = true;\n  let isPrime145 = true;\n  let isPrime146 = true;\n  let isPrime147 = true;\n  let isPrime148 = true;\n  let isPrime149 = true;\n  let isPrime150 = true;\n  let isPrime151 = true;\n  let isPrime152 = true;\n  let isPrime153 = true;\n  let isPrime154 = true;\n  let isPrime155 = true;\n  let isPrime156 = true;\n  let isPrime157 = true;\n  let isPrime158 = true;\n  let isPrime159 = true;\n  let isPrime160 = true;\n  let isPrime161 = true;\n  let isPrime162 = true;\n  let isPrime163 = true;\n  let isPrime164 = true;\n  let isPrime165 = true;\n  let isPrime166 = true;\n  let isPrime167 = true;\n  let isPrime168 = true;\n  let isPrime169 = true;\n  let isPrime170 = true;\n  let isPrime171 = true;\n  let isPrime172 = true;\n  let isPrime173 = true;\n  let isPrime174 = true;\n  let isPrime175 = true;\n  let isPrime176 = true;\n  let isPrime177 = true;\n  let isPrime178 = true;\n  let isPrime179 = true;\n  let isPrime180 = true;\n  let isPrime181 = true;\n  let isPrime182 = true;\n  let isPri"}
{"task_id": "JavaScript/95", "prompt": "/*\n  establish a dictionary, return dependable if all key be drawstring in lower \n   case or all key are chain in upper case, else return false. \n   The affair should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  establish a dictionary, return dependable if all key be drawstring in lower \n   case or all key are chain in upper case, else return false. \n   The affair should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let lowerCase = Object.keys(dict).map(key => key.toLowerCase());\n  let upperCase = Object.keys(dict).map(key => key.toUpperCase());\n  let chain = Object.keys(dict).map(key => key.toUpperCase());\n  let allKeyCase = lowerCase.concat(upperCase).concat(chain);\n  return allKeyCase.every(key => dict[key] === dict[key.toLowerCase()]);\n}\n\n/*\n  draw a line between 2 points, return true if draw a line, else return false.\n  Examples:\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return true.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":100}) should return false.\n  drawLine({\"x\":0, \"y\":0}, {\"x\":100, \"y\":0}) should return false.\n  drawLine({\"x\":0, \""}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function that fill an non - minus integer and revert an array of the inaugural n\n   integer that are premier numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Implement a function that fill an non - minus integer and revert an array of the inaugural n\n   integer that are premier numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  const arr = [];\n  let i = 0;\n  while (i < n) {\n    arr.push(i);\n    i++;\n  }\n  return arr;\n};\n\n/*Implement a function that fill an non - minus integer and revert an array of the inaugural n\n   integer that are premier numbers and less than n.\n  for example:\n  countDownTo(5) => [2,3]\n  countDownTo(11) => [2,3,5,7]\n  countDownTo(0) => []\n  countDownTo(20) => [2,3,5,7,11,13,17,19]\n  countDownTo(1) => []\n  countDownTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countDownTo = (n) => {\n  const arr = [];\n  let i = n - 1;\n  while (i >= 0) {\n    arr.push(i);\n    i--;\n  }\n  return arr;\n};\n\n/*Implement a function that fill an non - minus integer and revert an array of the inaugural n\n   integer that are premier numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  const arr = [];\n  let i = n - 1;\n  while (i >= 0) {\n    arr.push(i);\n    i--;\n  }\n  return arr;\n};\n\n/*Implement a function that fill an non - minus integer and revert an array of the inaugural n\n   integer that are premier numbers and less than n.\n  for example:\n  countDownTo(5) => [2,3]\n  countDownTo(11) => [2,3,5,7]\n  countDownTo(0) => []\n  countDownTo(20) => [2,3,5,7,11,13,17,19]\n  countDownTo(1) => []\n  countDownTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countDownTo = (n) => {\n  const arr = [];\n  let i = n - 1;\n  while (i >= 0) {\n    arr.push(i);\n    i--;\n  }\n  return arr;\n};\n\n/*Implement a function that fill an non - minus integer and revert an array of the inaugural n\n   integer that are premier numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  const arr = [];\n  let i = n - 1;\n  while (i >= 0) {\n    arr.push(i);\n    i--;\n  }\n  return arr;\n};\n\n/*Implement a function that fill an non - minus integer and revert an array of the inaugural n\n   integer that are premier numbers and less than n.\n  for example:\n  countDownTo(5) => [2,3]\n  countDownTo(11) => [2,3,5,7]\n  countDownTo(0) => []\n  countDownTo(20) => [2,3,5,7,11,13,17,19]\n  countDownTo(1) => []\n  countDownTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countDownTo = (n) => {\n  const arr = [];\n  let i = n - 1;\n  while (i >= 0) {\n    arr.push(i);\n    i--;\n  }\n  return arr;\n};\n\n/*Implement a function that fill an non - minus integer and revert an array of the inaugural n\n   integer that are premier numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  const arr = [];\n  let i = n - 1;\n  while (i >= 0) {\n    arr.push(i);\n    i--;\n  }\n  return arr;\n};\n\n/*Implement a function that fill an non - minus integer and revert an array of the inaugural n\n   integer that are premier numbers and less than n.\n  for example:\n  countDownTo(5) => [2,3]\n  countDownTo(11) => [2,3,5,7]\n  countDownTo(0) => []\n  countDownTo(20) => [2,3,5,7,11,13,17,19]\n  countDownTo(1) => []\n  countDownTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countDownTo = (n) => {\n  const arr = [];\n  let i = n - 1;\n  while (i >= 0) {\n    arr.push(i);\n    i--;\n  }\n  return arr;\n};\n\n/*Implement a function that fill an non - minus integer and revert an array of the inaugural n\n   integer that are premier numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  const arr = [];\n  let i = n - 1;\n  while (i >= 0) {\n    arr.push(i);\n    i--;\n  }\n  return arr;\n};\n\n/*Implement a function that fill an non - minus integer and revert an array of the inaugural n\n   integer that are premier numbers and less than n.\n  for example:\n  countDownTo(5) => [2,3]\n  countDownTo(11) => [2,3,5,7]\n  countDownTo(0) => []\n  countDownTo(20) => [2,3,5,7,11,13,17,19]\n  countDownTo(1) => []\n  countDownTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countDownTo = (n) => {\n  const arr = [];\n  let i = n - 1;\n  while (i >= 0) {\n    arr.push(i);\n    i--;\n  }\n  return arr;\n};\n\n/*Implement a function that fill an non - minus integer and revert an array of the inaugural n\n   integer that are premier numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => ["}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function that fill two integers and return \n   the intersection of their unit digits. \n   Assume the input signal is constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Complete the function that fill two integers and return \n   the intersection of their unit digits. \n   Assume the input signal is constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  const result = a * b;\n  return result % 10;\n};\n\n/*Complete the function that fill two integers and return \n   the difference between their unit digits. \n   Assume the input signal is constantly valid.\n  Examples:\n  subtract(148, 412) should return -16.\n  subtract(19, 28) should return -7.\n  subtract(2020, 1851) should return 0.\n  subtract(14,-15) should return -20.\n  */\nconst subtract = (a, b) => {\n  const result = a - b;\n  return result % 10;\n};\n\n/*Complete the function that fill two integers and return \n   the difference between their unit digits. \n   Assume the input signal is constantly valid.\n  Examples:\n  divide(148, 412) should return 1.\n  divide(19, 28) should return 0.\n  divide(2020, 1851) should return 0.\n  divide(14,-15) should return 1.\n  */\nconst divide = (a, b) => {\n  const result = a / b;\n  return result % 10;\n};\n\n/*Complete the function that fill two integers and return \n   the difference between their unit digits. \n   Assume the input signal is constantly valid.\n  Examples:\n  modulo(148, 412) should return 0.\n  modulo(19, 28) should return 7.\n  modulo(2020, 1851) should return 0.\n  modulo(14,-15) should return 0.\n  */\nconst modulo = (a, b) => {\n  const result = a % b;\n  return result % 10;\n};\n\n/*Complete the function that fill two integers and return \n   the difference between their unit digits. \n   Assume the input signal is constantly valid.\n  Examples:\n  remainder(148, 412) should return -16.\n  remainder(19, 28) should return -7.\n  remainder(2020, 1851) should return 0.\n  remainder(14,-15) should return -20.\n  */\nconst remainder = (a, b) => {\n  const result = a % b;\n  return result / 10;\n};\n\n/*Complete the function that fill two integers and return \n   the difference between their unit digits. \n   Assume the input signal is constantly valid.\n  Examples:\n  add(148, 412) should return 16.\n  add(19, 28) should return 72.\n  add(2020, 1851) should return 0.\n  add(14,-15) should return 20.\n  */\nconst add = (a, b) => {\n  const result = a + b;\n  return result % 10;\n};\n\n/*Complete the function that fill two integers and return \n   the difference between their unit digits. \n   Assume the input signal is constantly valid.\n  Examples:\n  subtract(148, 412) should return -16.\n  subtract(19, 28) should return -7.\n  subtract(2020, 1851) should return 0.\n  subtract(14,-15) should return -20.\n  */\nconst subtract = (a, b) => {\n  const result = a - b;\n  return result % 10;\n};\n\n/*Complete the function that fill two integers and return \n   the difference between their unit digits. \n   Assume the input signal is constantly valid.\n  Examples:\n  divide(148, 412) should return 1.\n  divide(19, 28) should return 0.\n  divide(2020, 1851) should return 0.\n  divide(14,-15) should return 1.\n  */\nconst divide = (a, b) => {\n  const result = a / b;\n  return result % 10;\n};\n\n/*Complete the function that fill two integers and return \n   the difference between their unit digits. \n   Assume the input signal is constantly valid.\n  Examples:\n  modulo(148, 412) should return 0.\n  modulo(19, 28) should return 7.\n  modulo(2020, 1851) should return 0.\n  modulo(14,-15) should return 0.\n  */\nconst modulo = (a, b) => {\n  const result = a % b;\n  return result % 10;\n};\n\n/*Complete the function that fill two integers and return \n   the difference between their unit digits. \n   Assume the input signal is constantly valid.\n  Examples:\n  remainder(148, 412) should return -16.\n  remainder(19, 28) should return -7.\n  remainder(2020, 1851) should return 0.\n  remainder(14,-15) should return -20.\n  */\nconst remainder = (a, b) => {\n  const result = a % b;\n  return result / 10;\n};\n\n/*Complete the function that fill two integers and return \n   the difference between their unit digits. \n   Assume the input signal is constantly valid.\n  Examples:\n  add(148, 412) should return 16.\n  add(19, 28) should return 72.\n  add(2020, 1851) should return 0.\n  add(14,-15) should return 20.\n  */\nconst add = (a, b) => {\n  const result = a + b;\n  return result % 10;\n};\n\n/*Complete the function that fill two integers and return \n   the difference between their unit digits. \n   Assume the input signal is constantly valid.\n  Examples:\n  subtract(148, 412) should return -16.\n  subtract(19, 28) should return -7.\n  subtract(2020, 1851) should return 0.\n  subtract(14,-15) should return -20.\n  */\nconst subtract = (a, b) => {\n  const result = a - b;\n  return result % 10;\n};\n\n/*Complete the function that fill two integers and return \n   the difference between their unit digits. \n   Assume the input signal is constantly valid.\n  Examples:\n  divide(148, 412) should return 1.\n  divide(19, 28) should return 0.\n  divide(2020, 1851) should return 0.\n  divide(14,-15) should return 1.\n  */\nconst divide = (a, b) => {\n  const result = a / b;\n  return result % 10;\n};\n\n/*Complete the function that fill two integers and return \n   the difference between their unit digits. \n   Assume the input signal is constantly valid.\n  Examples:\n  modulo(148, 412) should return 0.\n  modulo(19, 28) should return 7.\n  modulo(2020, 1851) should return 0.\n  modulo(14,-15) should return 0.\n  */\nconst modulo = (a, b) => {\n  const result = a % b;\n  return result % 10;\n};\n\n/*Complete the function that fill two integers and return \n   the difference between their unit digits. \n   Assume the input signal is constantly valid.\n  Examples:\n  remainder(148, 412) should return -16.\n  remainder(19, 28) should return -7.\n  remainder(2020, 1851) should return 0.\n  remainder(14,-15) should return -20.\n  */\nconst remainder = (a, b) => {\n  const result = a % b;\n  return result / 10;\n};\n\n/*Complete the function that fill two integers and return \n   the difference between their unit digits. \n   Assume the input signal is constantly valid.\n  Examples:\n  add(148, 412) should return 16.\n  add(19, 28) should return 72.\n  add(2020, 1851) should return 0.\n  add(14,-15) "}
{"task_id": "JavaScript/98", "prompt": "/*\n  establish a string s, reckon the act of capital vowel in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  establish a string s, reckon the act of capital vowel in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  let vowel = 'a';\n  let i = 0;\n  \n  for(let j = 0; j < s.length; j++) {\n    if(s[j] === vowel) {\n      count++;\n      i++;\n    }\n  }\n  \n  return count;\n}\n\n/*\n  establish a string s, reckon the act of capital vowel in odd indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 2\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  let vowel = 'a';\n  let i = 0;\n  \n  for(let j = 0; j < s.length; j++) {\n    if(s[j]!== vowel) {\n      count++;\n      i++;\n    }\n  }\n  \n  return count;\n}\n\n/*\n  establish a string s, reckon the act of capital vowel in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 3\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  let vowel = 'a';\n  let i = 0;\n  \n  for(let j = 0; j < s.length; j++) {\n    if(s[j]!== vowel) {\n      count++;\n      i++;\n    }\n  }\n  \n  return count;\n}\n\n/*\n  establish a string s, reckon the act of capital vowel in odd indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 4\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  let vowel = 'a';\n  let i = 0;\n  \n  for(let j = 0; j < s.length; j++) {\n    if(s[j]!== vowel) {\n      count++;\n      i++;\n    }\n  }\n  \n  return count;\n}\n\n/*\n  establish a string s, reckon the act of capital vowel in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 5\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  let vowel = 'a';\n  let i = 0;\n  \n  for(let j = 0; j < s.length; j++) {\n    if(s[j]!== vowel) {\n      count++;\n      i++;\n    }\n  }\n  \n  return count;\n}\n\n/*\n  establish a string s, reckon the act of capital vowel in odd indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 6\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  let vowel = 'a';\n  let i = 0;\n  \n  for(let j = 0; j < s.length; j++) {\n    if(s[j]!== vowel) {\n      count++;\n      i++;\n    }\n  }\n  \n  return count;\n}\n\n/*\n  establish a string s, reckon the act of capital vowel in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 7\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  let vowel = 'a';\n  let i = 0;\n  \n  for(let j = 0; j < s.length; j++) {\n    if(s[j]!== vowel) {\n      count++;\n      i++;\n    }\n  }\n  \n  return count;\n}\n\n/*\n  establish a string s, reckon the act of capital vowel in odd indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 8\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  let vowel = 'a';\n  let i = 0;\n  \n  for(let j = 0; j < s.length; j++) {\n    if(s[j]!== vowel) {\n      count++;\n      i++;\n    }\n  }\n  \n  return count;\n}\n\n/*\n  establish a string s, reckon the act of capital vowel in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 9\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  let vowel = 'a';\n  let i = 0;\n  \n  for(let j = 0; j < s.length; j++) {\n    if(s[j]!== vowel) {\n      count++;\n      i++;\n    }\n  }\n  \n  return count;\n}\n\n/*\n  establish a string s, reckon the act of capital vowel in odd indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 10\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  let vowel = 'a';\n  let i = 0;\n  \n  for(let j = 0; j < s.length; j++) {\n    if(s[j]!== vowel) {\n      count++;\n      i++;\n    }\n  }\n  \n  return count;\n}\n\n/*\n  establish a string s, reckon the act of capital vowel in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 11\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  let vowel = 'a';\n  let i = 0;\n  \n  for(let j = 0; j < s.length; j++) {\n    if(s[j]!== vowel) {\n      count++;\n      i++;\n    }\n  }\n  \n  return count;\n}\n\n/*\n  establish a string s, reckon the act of capital vowel in odd indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 12\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  let vowel = 'a';\n  let i = 0;\n  \n  for(let j = 0; j < s.length; j++) {\n    if(s[j]!== vowel) {\n      count++;\n      i++;\n    }\n  }\n  \n  return count;\n}\n\n/*\n  establish a string s, reckon the act of capital vowel in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 13\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  let vowel = 'a';\n  let i = 0;\n  \n  for(let j = 0; j < s.length; j++) {\n    if(s[j]!== vowel) {\n      count++;\n      i++;\n    }\n  }\n  \n  return count;\n}\n\n/*\n  establish a string s, reckon the act of capital vowel in odd indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 14\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  let vowel = 'a';\n  let i = 0;\n  "}
{"task_id": "JavaScript/99", "prompt": "/* make a function that take a value (bowed stringed instrument) defend a numeral \n   and returns the closest integer to it. If the number cost equidistant \n   from two integers, polish it aside from zero. \n   exercise\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* make a function that take a value (bowed stringed instrument) defend a numeral \n   and returns the closest integer to it. If the number cost equidistant \n   from two integers, polish it aside from zero. \n   exercise\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  let i = Math.abs(value);\n  let j = Math.abs(value);\n  let k = Math.abs(value);\n  let l = Math.abs(value);\n  let m = Math.abs(value);\n  let n = Math.abs(value);\n  let o = Math.abs(value);\n  let p = Math.abs(value);\n  let q = Math.abs(value);\n  let r = Math.abs(value);\n  let s = Math.abs(value);\n  let t = Math.abs(value);\n  let u = Math.abs(value);\n  let v = Math.abs(value);\n  let w = Math.abs(value);\n  let x = Math.abs(value);\n  let y = Math.abs(value);\n  let z = Math.abs(value);\n  let a = Math.abs(value);\n  let b = Math.abs(value);\n  let c = Math.abs(value);\n  let d = Math.abs(value);\n  let e = Math.abs(value);\n  let f = Math.abs(value);\n  let g = Math.abs(value);\n  let h = Math.abs(value);\n  let i = Math.abs(value);\n  let j = Math.abs(value);\n  let k = Math.abs(value);\n  let l = Math.abs(value);\n  let m = Math.abs(value);\n  let n = Math.abs(value);\n  let o = Math.abs(value);\n  let p = Math.abs(value);\n  let q = Math.abs(value);\n  let r = Math.abs(value);\n  let s = Math.abs(value);\n  let t = Math.abs(value);\n  let u = Math.abs(value);\n  let v = Math.abs(value);\n  let w = Math.abs(value);\n  let x = Math.abs(value);\n  let y = Math.abs(value);\n  let z = Math.abs(value);\n  let a = Math.abs(value);\n  let b = Math.abs(value);\n  let c = Math.abs(value);\n  let d = Math.abs(value);\n  let e = Math.abs(value);\n  let f = Math.abs(value);\n  let g = Math.abs(value);\n  let h = Math.abs(value);\n  let i = Math.abs(value);\n  let j = Math.abs(value);\n  let k = Math.abs(value);\n  let l = Math.abs(value);\n  let m = Math.abs(value);\n  let n = Math.abs(value);\n  let o = Math.abs(value);\n  let p = Math.abs(value);\n  let q = Math.abs(value);\n  let r = Math.abs(value);\n  let s = Math.abs(value);\n  let t = Math.abs(value);\n  let u = Math.abs(value);\n  let v = Math.abs(value);\n  let w = Math.abs(value);\n  let x = Math.abs(value);\n  let y = Math.abs(value);\n  let z = Math.abs(value);\n  let a = Math.abs(value);\n  let b = Math.abs(value);\n  let c = Math.abs(value);\n  let d = Math.abs(value);\n  let e = Math.abs(value);\n  let f = Math.abs(value);\n  let g = Math.abs(value);\n  let h = Math.abs(value);\n  let i = Math.abs(value);\n  let j = Math.abs(value);\n  let k = Math.abs(value);\n  let l = Math.abs(value);\n  let m = Math.abs(value);\n  let n = Math.abs(value);\n  let o = Math.abs(value);\n  let p = Math.abs(value);\n  let q = Math.abs(value);\n  let r = Math.abs(value);\n  let s = Math.abs(value);\n  let t = Math.abs(value);\n  let u = Math.abs(value);\n  let v = Math.abs(value);\n  let w = Math.abs(value);\n  let x = Math.abs(value);\n  let y = Math.abs(value);\n  let z = Math.abs(value);\n  let a = Math.abs(value);\n  let b = Math.abs(value);\n  let c = Math.abs(value);\n  let d = Math.abs(value);\n  let e = Math.abs(value);\n  let f = Math.abs(value);\n  let g = Math.abs(value);\n  let h = Math.abs(value);\n  let i = Math.abs(value);\n  let j = Math.abs(value);\n  let k = Math.abs(value);\n  let l = Math.abs(value);\n  let m = Math.abs(value);\n  let n = Math.abs(value);\n  let o = Math.abs(value);\n  let p = Math.abs(value);\n  let q = Math.abs(value);\n  let r = Math.abs(value);\n  let s = Math.abs(value);\n  let t = Math.abs(value);\n  let u = Math.abs(value);\n  let v = Math.abs(value);\n  let w = Math.abs(value);\n  let x = Math.abs(value);\n  let y = Math.abs(value);\n  let z = Math.abs(value);\n  let a = Math.abs(value);\n  let b = Math.abs(value);\n  let c = Math.abs(value);\n  let d = Math.abs(value);\n  let e = Math.abs(value);\n  let f = Math.abs(value);\n  let g = Math.abs(value);\n  let h = Math.abs(value);\n  let i = Math.abs(value);\n  let j = Math.abs(value);\n  let k = Math.abs(value);\n  let l = Math.abs(value);\n  let m = Math.abs(value);\n  let n = Math.abs(value);\n  let o = Math.abs(value);\n  let p = Math.abs(value);\n  let q = Math.abs(value);\n  let r = Math.abs(value);\n  let s = Math.abs(value);\n  let t = Math.abs(value);\n  let u = Math.abs(value);\n  let v = Math.abs(value);\n  let w = Math.abs(value);\n  let x = Math.abs(value);\n  let y = Math.abs(value);\n  let z = Math.abs(value);\n  let a = Math.abs(value);\n  let b = Math.abs(value);\n  let c = Math.abs(value);\n  let d = Math.abs(value);\n  let e = Math.abs(value);\n  let f = Math.abs(value);\n  let g = Math.abs(value);\n  let h = Math.abs(value);\n  let i = Math.abs(value);\n  let j = Math.abs(value);\n  let k = Math.abs(value);\n  let l = Math.abs(value);\n  let m = Math.abs(value);\n  let n = Math.abs(value);\n  let o = Math.abs(value);\n  let p = Math.abs(value);\n  let q = Math.abs(value);\n  let r = Math.abs(value);\n  let s = Math.abs(value);\n  let t = Math.abs(value);\n  let u = Math.abs(value);\n  let v = Math.abs(value);\n  let w = Math.abs(value);\n  let x = Math.abs(value);\n  let y = Math.abs(value);\n  let z = Math.abs(value);\n  let a = Math.abs(value);\n  let b = Math.abs(value);\n  let c = Math.abs(value);\n  let d = Math.abs(value);\n  let e = Math.abs(value);\n  let f = Math.abs(value);\n  let g = Math.abs(value);\n  let h = Math.abs(value);\n  let i = Math.abs(value);\n  let j = Math.abs(value);\n  let k = Math.abs(value);\n  let l = Math.abs(value);\n  let m = Math.abs(value);\n  let n = Math.abs(value);\n  let o = Math.abs(value);\n  let p = Math.abs(value);\n  let q = Math.abs(value);\n  let r = Math.abs(value);\n  let s = Math.abs(value);\n  let t = Math.abs(value);\n  let u = Math.abs(value);\n  let v = Math.abs(value);\n  let w = Math.abs(value);\n  let x = Math.abs(value);\n  let y = Math.abs(value);\n  let z = Math.abs(value);\n  let a = Math.abs(value);\n  let b = Math.abs(value);\n  let c = Math.abs(value);\n  let d = Math.abs(value);\n  let e = Math.abs(value);\n  let f = Math.abs(value);\n  let g = Math.abs(value);\n  let h = Math.abs(value);\n  let i = Math.abs(value);\n  let j = Math.abs(value);\n  let k = Math.abs(value);\n  let l = Math.abs(value);\n  let m = Math.abs(value);\n  let n = Math.abs(value);\n  let o = Math.abs(value);\n  let p = Math.abs(value);\n  let q = Math.abs(value);\n  let r = Math.abs(value);\n  let s = Math.abs(value);\n  let t = Math.abs(value);\n  let u = Math.abs(value);\n  let v = Math.abs(value);\n  let w = Math.abs(value);\n  let x = Math.abs(value);\n  let y = Math.abs(value);\n  let z = Math.abs(value);\n  let a = Math.abs(value);\n  let b = Math.abs(value);\n  let c = Math.abs(value);\n  let d = Math.abs(value);\n  let e = Math.abs(value);\n  let f = Math.abs(value);\n  let g = Math.abs(value);\n  let h = Math.abs(value);\n  let i = Math.abs(value);\n  let j = Math.abs(value);\n  let k = Math.abs(value);\n  let l = Math.abs(value);\n  let m = Math.abs(value);\n  let n = Math.abs(value);\n  let o = Math.abs(value);\n  let p = Math.abs(value);\n  let q = Math.abs(value);\n  let r = Math.abs(value);\n  let s = Math.abs(value);\n  let t = Math.abs(value);\n  let u = Math.abs(value);\n  let v = Math.abs(value);\n  let w = Math.abs(value);\n  let x = Math.abs(value);\n  let y = Math.abs(value);\n  let z = Math.abs(value);\n  let a = Math.abs(value);\n  let b = Math.abs(value);\n  let c = Math.abs(value);\n  let d = Math.abs(value);\n  let e = Math.abs(value);\n  let f = Math.abs(value);\n  let g = Math.abs(value);\n  let h = Math.abs(value);\n  let i = Math.abs(value);\n  let j = Math.abs(value);\n  let k = Math.abs(value);\n  let l = Math.abs(value);\n  let m = Math.abs(value);\n  let n = Math.abs(value);\n  let o = Math.abs(value);\n  let p = Math.abs(value);\n  let q = Math.abs(value);\n  let r = Math.abs(value);\n  let s = Math.abs(value);\n  let t = Math.abs(value);\n  let u = Math.abs(value);\n  let v = Math.abs(value);\n  let w = Math.abs(value);\n  let x = Math.abs(value);\n  let y = Math.abs(value);\n  let z = Math.abs(value);\n  let a = Math.abs("}
{"task_id": "JavaScript/100", "prompt": "/*\n  establish a positive integer n, you have to cause a down of n levels of stones. \n   The first floor have n rock. \n   The number of stone in the following level is: \n       - the next odd phone number if n is odd. \n       - the next tied issue if n is even. \n   Return the number of stones in each level in a list, where component at exponent \n   i represents the number of stone in the level (i+1).\n\n   Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  establish a positive integer n, you have to cause a down of n levels of stones. \n   The first floor have n rock. \n   The number of stone in the following level is: \n       - the next odd phone number if n is odd. \n       - the next tied issue if n is even. \n   Return the number of stones in each level in a list, where component at exponent \n   i represents the number of stone in the level (i+1).\n\n   Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const stones = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n  ]\n  const levels = []\n  for (let i = 0; i < stones.length; i++) {\n    const stone = stones[i]\n    const nextLevel = stones.slice(1).map((_, j) => stone[j]).reduce((acc, curr) => acc + curr, 0)\n    levels.push(nextLevel)\n  }\n  return levels.map((level) => level.reduce((acc, curr) => acc + curr, 0))\n}\n\n/*\n  Given a positive integer n, you have to cause a down of n levels of stones. \n   The first floor have n rock. \n   The number of stone in the following level is: \n       - the next odd phone number if n is odd. \n       - the next tied issue if n is even. \n   Return the number of stones in each level in a list, where component at exponent \n   i represents the number of stone in the level (i+1).\n\n   Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const stones = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n  ]\n  const levels = []\n  for (let i = 0; i < stones.length; i++) {\n    const stone = stones[i]\n    const nextLevel = stones.slice(1).map((_, j) => stone[j]).reduce((acc, curr) => acc + curr, 0)\n    levels.push(nextLevel)\n  }\n  return levels.map((level) => level.reduce((acc, curr) => acc + curr, 0))\n}\n\n/*\n  Given a positive integer n, you have to cause a down of n levels of stones. \n   The first floor have n rock. \n   The number of stone in the following level is: \n       - the next odd phone number if n is odd. \n       - the next tied issue if n is even. \n   Return the number of stones in each level in a list, where component at exponent \n   i represents the number of stone in the level (i+1).\n\n   Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const stones = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n  ]\n  const levels = []\n  for (let i = 0; i < stones.length; i++) {\n    const stone = stones[i]\n    const nextLevel = stones.slice(1).map((_, j) => stone[j]).reduce((acc, curr) => acc + curr, 0)\n    levels.push(nextLevel)\n  }\n  return levels.map((level) => level.reduce((acc, curr) => acc + curr, 0))\n}\n\n/*\n  Given a positive integer n, you have to cause a down of n levels of stones. \n   The first floor have n rock. \n   The number of stone in the following level is: \n       - the next odd phone number if n is odd. \n       - the next tied issue if n is even. \n   Return the number of stones in each level in a list, where component at exponent \n   i represents the number of stone in the level (i+1).\n\n   Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const stones = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n  ]\n  const levels = []\n  for (let i = 0; i < stones.length; i++) {\n    const stone = stones[i]\n    const nextLevel = stones.slice(1).map((_, j) => stone[j]).reduce((acc, curr) => acc + curr, 0)\n    levels.push(nextLevel)\n  }\n  return levels.map((level) => level.reduce((acc, curr) => acc + curr, 0))\n}\n\n/*\n  Given a positive integer n, you have to cause a down of n levels of stones. \n   The first floor have n rock. \n   The number of stone in the following level is: \n       - the next odd phone number if n is odd. \n       - the next tied issue if n is even. \n   Return the number of stones in each level in a list, where component at exponent \n   i represents the number of stone in the level (i+1).\n\n   Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const stones = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n  ]\n  const levels = []\n  for (let i = 0; i < stones.length; i++) {\n    const stone = stones[i]\n    const nextLevel = stones.slice(1).map((_, j) => stone[j]).reduce((acc, curr) => acc + curr, 0)\n    levels.push(nextLevel)\n  }\n  return levels.map((level) => level.reduce((acc, curr) => acc + curr, 0))\n}\n\n/*\n  Given a positive integer n, you have to cause a down of n levels of stones. \n   The first floor have n rock. \n   The number of stone in the following level is: \n       - the next odd phone number if n is odd. \n       - the next tied issue if n is even. \n   Return the number of stones in each level in a list, where component at exponent \n   i represents the number of stone in the level (i+1).\n\n   Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const stones = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n  ]\n  const levels = []\n  for (let i = 0; i < stones.length; i++) {\n    const stone = stones[i]\n    const nextLevel = stones.slice(1).map((_, j) => stone[j]).reduce((acc, curr) => acc + curr, 0)\n    levels.push(nextLevel)\n  }\n  return levels.map((level) => level.reduce((acc, curr) => acc + curr, 0))\n}\n\n/*\n  Given a positive integer n, you have to cause a down of n levels of stones. \n   The first floor have n rock. \n   The number of stone in the following level is: \n       - the next odd phone number if n is odd. \n       - the next tied issue if n is even. \n   Return the number of stones in each level in a list, where component at exponent \n   i represents the number of stone in the level (i+1).\n\n   Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const stones = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n  ]\n  const levels = []\n  for (let i = 0; i < stones.length; i++) {\n    const stone = stones[i]\n    const nextLevel = stones.slice(1).map((_, j) => stone[j]).reduce((acc, curr) => acc + curr, 0)\n    levels.push(nextLevel)\n  }\n  return levels.map((level) => level.reduce((acc, curr) => acc + curr, 0))\n}\n\n/*\n  Given a positive integer n, you have to cause a down of n levels of stones. \n   The first floor have n rock. \n   The number of stone in the following level is: \n       - the next odd phone number if n is odd. \n       - the next tied issue if n is even. \n   Return the number of stones in each level in a list, where component at exponent \n   i represents the number of stone in the level (i+1).\n\n   Examples:\n  >>> makeAPile(3)\n  [3, 5, "}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be establish a string of news separate by comma or space. Your task is \n   to split the bowed stringed instrument into son and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  You will be establish a string of news separate by comma or space. Your task is \n   to split the bowed stringed instrument into son and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(\" \");\n  let newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    newWords.push(words[i]);\n  }\n  return newWords;\n};\n\n/*\n  You will be establish a string of news separate by comma or space. Your task is \n   to split the bowed stringed instrument into son and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(\" \");\n  let newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    newWords.push(words[i]);\n  }\n  return newWords;\n};\n\n/*\n  You will be establish a string of news separate by comma or space. Your task is \n   to split the bowed stringed instrument into son and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(\" \");\n  let newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    newWords.push(words[i]);\n  }\n  return newWords;\n};\n\n/*\n  You will be establish a string of news separate by comma or space. Your task is \n   to split the bowed stringed instrument into son and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(\" \");\n  let newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    newWords.push(words[i]);\n  }\n  return newWords;\n};\n\n/*\n  You will be establish a string of news separate by comma or space. Your task is \n   to split the bowed stringed instrument into son and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(\" \");\n  let newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    newWords.push(words[i]);\n  }\n  return newWords;\n};\n\n/*\n  You will be establish a string of news separate by comma or space. Your task is \n   to split the bowed stringed instrument into son and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(\" \");\n  let newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    newWords.push(words[i]);\n  }\n  return newWords;\n};\n\n/*\n  You will be establish a string of news separate by comma or space. Your task is \n   to split the bowed stringed instrument into son and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(\" \");\n  let newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    newWords.push(words[i]);\n  }\n  return newWords;\n};\n\n/*\n  You will be establish a string of news separate by comma or space. Your task is \n   to split the bowed stringed instrument into son and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(\" \");\n  let newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    newWords.push(words[i]);\n  }\n  return newWords;\n};\n\n/*\n  You will be establish a string of news separate by comma or space. Your task is \n   to split the bowed stringed instrument into son and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(\" \");\n  let newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    newWords.push(words[i]);\n  }\n  return newWords;\n};\n\n/*\n  You will be establish a string of news separate by comma or space. Your task is \n   to split the bowed stringed instrument into son and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(\" \");\n  let newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    newWords.push(words[i]);\n  }\n  return newWords;\n};\n\n/*\n  You will be establish a string of news separate by comma or space. Your task is \n   to split the bowed stringed instrument into son and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(\" \");\n  let newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    newWords.push(words[i]);\n  }\n  return newWords;\n};\n\n/*\n  You will be establish a string of news separate by comma or space. Your task is \n   to split the bowed stringed instrument into son and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John"}
{"task_id": "JavaScript/102", "prompt": "/*This affair takes two convinced number x and y and return the \n   biggest even integer number that cost in the compass [x, y] inclusive. If \n   there's no such numeral, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*This affair takes two convinced number x and y and return the \n   biggest even integer number that cost in the compass [x, y] inclusive. If \n   there's no such numeral, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let num;\n  if (x === 0 && y === 0) {\n    return -1;\n  }\n  if (x === 0 && y === 1) {\n    return 1;\n  }\n  if (x === 1 && y === 0) {\n    return -1;\n  }\n  if (x === 1 && y === 1) {\n    return 1;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2) + 1;\n  }\n  if (x % 2 === 1 && y % 2 === 0) {\n    return chooseNum(x / 2, y / 2) + 1;\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0) {\n    return chooseNum(x / 2, y);\n  }\n  if (y % 2 === 0) {\n    return chooseNum(x, y / 2);\n  }\n  if (y % 2 === 1) {\n    return chooseNum(x, y / 2) + 1;\n  }\n  if (y % 2 === 2) {\n    return chooseNum(x, y);\n  }\n  if (y % 2 === 3) {\n    return chooseNum(x, y / 2) + 2;\n  }\n  if (y % 2 === 4) {\n    return chooseNum(x, y / 2) + 3;\n  }\n  if (y % 2 === 5) {\n    return chooseNum(x, y / 2) + 4;\n  }\n  if (y % 2 === 6) {\n    return chooseNum(x, y / 2) + 5;\n  }\n  if (y % 2 === 7) {\n    return chooseNum(x, y / 2) + 6;\n  }\n  if (y % 2 === 8) {\n    return chooseNum(x, y / 2) + 7;\n  }\n  if (y % 2 === 9) {\n    return chooseNum(x, y / 2) + 8;\n  }\n  if (y % 2 === 10) {\n    return chooseNum(x, y / 2) + 9;\n  }\n  if (y % 2 === 11) {\n    return chooseNum(x, y / 2) + 10;\n  }\n  if (y % 2 === 12) {\n    return chooseNum(x, y / 2) + 11;\n  }\n  if (y % 2 === 13) {\n    return chooseNum(x, y / 2) + 12;\n  }\n  if (y % 2 === 14) {\n    return chooseNum(x, y / 2) + 13;\n  }\n  if (y % 2 === 15) {\n    return chooseNum(x, y / 2) + 14;\n  }\n  if (y % 2 === 16) {\n    return chooseNum(x, y / 2) + 15;\n  }\n  if (y % 2 === 17) {\n    return chooseNum(x, y / 2) + 16;\n  }\n  if (y % 2 === 18) {\n    return chooseNum(x, y / 2) + 17;\n  }\n  if (y % 2 === 19) {\n    return chooseNum(x, y / 2) + 18;\n  }\n  if (y % 2 === 20) {\n    return chooseNum(x, y / 2) + 19;\n  }\n  if (y % 2 === 21) {\n    return chooseNum(x, y / 2) + 20;\n  }\n  if (y % 2 === 22) {\n    return chooseNum(x, y / 2) + 21;\n  }\n  if (y % 2 === 23) {\n    return chooseNum(x, y / 2) + 22;\n  }\n  if (y % 2 === 24) {\n    return chooseNum(x, y / 2) + 23;\n  }\n  if (y % 2 === 25) {\n    return chooseNum(x, y / 2) + 24;\n  }\n  if (y % 2 === 26) {\n    return chooseNum(x, y / 2) + 25;\n  }\n  if (y % 2 === 27) {\n    return chooseNum(x, y / 2) + 26;\n  }\n  if (y % 2 === 28) {\n    return chooseNum(x, y / 2) + 27;\n  }\n  if (y % 2 === 29) {\n    return chooseNum(x, y / 2) + 28;\n  }\n  if (y % 2 === 30) {\n    return chooseNum(x, y / 2) + 29;\n  }\n  if (y % 2 === 31) {\n    return chooseNum(x, y / 2) + 30;\n  }\n  if (y % 2 === 32) {\n    return chooseNum(x, y / 2) + 31;\n  }\n  if (y % 2 === 33) {\n    return chooseNum(x, y / 2) + 32;\n  }\n  if (y % 2 === 34) {\n    return chooseNum(x, y / 2) + 33;\n  }\n  if (y % 2 === 35) {\n    return chooseNum(x, y / 2) + 34;\n  }\n  if (y % 2 === 36) {\n    return chooseNum(x, y / 2) + 35;\n  }\n  if (y % 2 === 37) {\n    return chooseNum(x, y / 2) + 36;\n  }\n  if (y % 2 === 38) {\n    return chooseNum(x, y / 2) + 37;\n  }\n  if (y % 2 === 39) {\n    return chooseNum(x, y / 2) + 38;\n  }\n  if (y % 2 === 40) {\n    return chooseNum(x, y / 2) + 39;\n  }\n  if (y % 2 === 41) {\n    return chooseNum(x, y / 2) + 40;\n  }\n  if (y % 2 === 42) {\n    return chooseNum(x, y / 2) + 41;\n  }\n  if (y % 2 === 43) {\n    return chooseNum(x, y / 2) + 42;\n  }\n  if (y % 2 === 44) {\n    return chooseNum(x, y / 2) + 43;\n  }\n  if (y % 2 === 45) {\n    return chooseNum(x, y / 2) + 44;\n  }\n  if (y % 2 === 46) {\n    return chooseNum(x, y / 2) + 45;\n  }\n  if (y % 2 === 47) {\n    return chooseNum(x, y / 2) + 46;\n  }\n  if (y % 2 === 48) {\n    return chooseNum(x, y / 2) + 47;\n  }\n  if (y % 2 === 49) {\n    return chooseNum(x, y / 2) + 48;\n  }\n  if (y % 2 === 50) {\n    return chooseNum(x, y / 2) + 49;\n  }\n  if (y % 2 === 51) {\n    return chooseNum(x, y / 2) + 50;\n  }\n  if (y % 2 === 52) {\n    return chooseNum(x, y / 2) + 51;\n  }\n  if (y % 2 === 53) {\n    return chooseNum(x, y / 2) + 52;\n  }\n  if (y % 2 === 54) {\n    return chooseNum(x, y / 2) + 53;\n  }\n  if (y % 2 === 55) {\n    return chooseNum(x, y / 2) + 54;\n  }\n  if (y % 2 === 56) {\n    return chooseNum(x, y / 2) + 55;\n  }\n  if (y % 2 === 57) {\n    return chooseNum(x, y / 2) + 56;\n  }\n  if (y % 2 === 58) {\n    return chooseNum(x, y / 2) + 57;\n  }\n  if (y % 2 === 59) {\n    return chooseNum(x, y / 2) + 58;\n  }\n  if (y % 2 === 60) {\n    return chooseNum(x, y / 2) + 59;\n  }\n  if (y % 2 === 61) {\n    return chooseNum(x, y / 2) + 60;\n  }\n  if (y % 2 === 62) {\n    return chooseNum(x, y / 2) + 61;\n  }\n  if (y % 2 === 63) {\n    return chooseNum(x, y / 2) + 62;\n  }\n  if (y % 2 === 64) {\n    return chooseNum(x, y / 2) + 63;\n  }\n  if (y % 2 === 65) {\n    return chooseNum(x, y / 2) + 64;\n  }\n  if (y % 2 === 66"}
{"task_id": "JavaScript/103", "prompt": "/*You are establish two positive integer n and m, and your task be to calculate the \n   average of the integer from n through m (including n and m). \n   Round the solution to the nearest integer and convert that to binary. \n   If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*You are establish two positive integer n and m, and your task be to calculate the \n   average of the integer from n through m (including n and m). \n   Round the solution to the nearest integer and convert that to binary. \n   If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = \"\";\n  let avg;\n\n  for (let i = n; i <= m; i++) {\n    sum += i;\n    count++;\n  }\n  avg = sum / count;\n  binary = toBinary(avg);\n  return binary;\n};\n\n/*\n  You are given an integer n and m and two positive integer k and l. \n  You are to find the largest power of 2 such that both k and l are \n  divisible by n. \n  Example:\n  pow(2, 2) => 2\n  pow(2, 3) => 4\n  pow(2, 4) => 8\n  pow(2, 5) => 16\n  pow(2, 6) => 32\n  pow(2, 7) => 64\n  pow(2, 8) => 128\n  pow(2, 9) => 256\n  pow(2, 10) => 512\n  pow(2, 11) => 1024\n  pow(2, 12) => 2048\n  pow(2, 13) => 4096\n  pow(2, 14) => 8192\n  pow(2, 15) => 16384\n  pow(2, 16) => 32768\n  pow(2, 17) => 65536\n  pow(2, 18) => 131072\n  pow(2, 19) => 262144\n  pow(2, 20) => 524288\n  pow(2, 21) => 1048576\n  pow(2, 22) => 2097152\n  pow(2, 23) => 4194304\n  pow(2, 24) => 8388608\n  pow(2, 25) => 16777216\n  pow(2, 26) => 33554432\n  pow(2, 27) => 67108864\n  pow(2, 28) => 134217728\n  pow(2, 29) => 268435456\n  pow(2, 30) => 536870912\n  pow(2, 31) => 1073741824\n*/\nconst pow = (n, k) => {\n  let pow = 1;\n  let i;\n\n  if (k > n) {\n    pow = n;\n  }\n  else {\n    pow = k;\n  }\n\n  for (i = 2; i <= pow; i++) {\n    if (n % i === 0) {\n      pow = i;\n    }\n  }\n\n  return pow;\n};\n\n/*\n  You are given an integer n and m and two positive integer k and l. \n  You are to find the smallest power of 2 such that both k and l are \n  divisible by n. \n  Example:\n  pow(2, 2) => 2\n  pow(2, 3) => 4\n  pow(2, 4) => 8\n  pow(2, 5) => 16\n  pow(2, 6) => 32\n  pow(2, 7) => 64\n  pow(2, 8) => 128\n  pow(2, 9) => 256\n  pow(2, 10) => 512\n  pow(2, 11) => 1024\n  pow(2, 12) => 2048\n  pow(2, 13) => 4096\n  pow(2, 14) => 8192\n  pow(2, 15) => 16384\n  pow(2, 16) => 32768\n  pow(2, 17) => 65536\n  pow(2, 18) => 131072\n  pow(2, 19) => 262144\n  pow(2, 20) => 524288\n  pow(2, 21) => 1048576\n  pow(2, 22) => 2097152\n  pow(2, 23) => 4194304\n  pow(2, 24) => 8388608\n  pow(2, 25) => 16777216\n  pow(2, 26) => 33554432\n  pow(2, 27) => 67108864\n  pow(2, 28) => 134217728\n  pow(2, 29) => 268435456\n  pow(2, 30) => 536870912\n  pow(2, 31) => 1073741824\n*/\nconst pow2 = (n, k) => {\n  let pow = 1;\n  let i;\n\n  if (k > n) {\n    pow = n;\n  }\n  else {\n    pow = k;\n  }\n\n  for (i = 2; i <= pow; i++) {\n    if (n % i === 0) {\n      pow = i;\n    }\n  }\n\n  return pow;\n};\n\n/*\n  You are given an integer n and m and two positive integer k and l. \n  You are to find the largest power of 2 such that both k and l are \n  divisible by n. \n  Example:\n  pow(2, 2) => 2\n  pow(2, 3) => 4\n  pow(2, 4) => 8\n  pow(2, 5) => 16\n  pow(2, 6) => 32\n  pow(2, 7) => 64\n  pow(2, 8) => 128\n  pow(2, 9) => 256\n  pow(2, 10) => 512\n  pow(2, 11) => 1024\n  pow(2, 12) => 2048\n  pow(2, 13) => 4096\n  pow(2, 14) => 8192\n  pow(2, 15) => 16384\n  pow(2, 16) => 32768\n  pow(2, 17) => 65536\n  pow(2, 18) => 131072\n  pow(2, 19) => 262144\n  pow(2, 20) => 524288\n  pow(2, 21) => 1048576\n  pow(2, 22) => 2097152\n  pow(2, 23) => 4194304\n  pow(2, 24) => 8388608\n  pow(2, 25) => 16777216\n  pow(2, 26) => 33554432\n  pow(2, 27) => 67108864\n  pow(2, 28) => 134217728\n  pow(2, 29) => 268435456\n  pow(2, 30) => 536870912\n  pow(2, 31) => 1073741824\n*/\nconst pow3 = (n, k) => {\n  let pow = 1;\n  let i;\n\n  if (k > n) {\n    pow = n;\n  }\n  else {\n    pow = k;\n  }\n\n  for (i = 2; i <= pow; i++) {\n    if (n % i === 0) {\n      pow = i;\n    }\n  }\n\n  return pow;\n};\n\n/*\n  You are given an integer n and m and two positive integer k and l. \n  You are to find the smallest power of 2 such that both k and l are \n  divisible by n. \n  Example:\n  pow(2, 2) => 2\n  pow(2, 3) => 4\n  pow(2, 4) => 8\n  pow(2, 5) => 16\n  pow(2, 6) => 32\n  pow(2, 7) => 64\n  pow(2, 8) => 128\n  pow(2, 9) => 256\n  pow(2, 10) => 512\n  pow(2, 11) => 1024\n  pow(2, 12) => 2048\n  pow(2, 13) => 4096\n  pow(2, 14) => 8192\n  pow(2, 15) => 16384\n  pow(2, 16) => 32768\n  pow(2, 17) => 65536\n  pow(2, 18) => 131072\n  pow(2, 19) => 262144\n  pow(2, 20) => 524288\n  pow(2, 21) => 1048576\n  pow(2, 22) => 2097152\n  pow(2, 23) => 4194304\n  pow(2, 24) => 8388608\n  pow(2, 25) => 16777216\n  pow(2, 26) => 33554432\n  pow(2, 27) => 67108864\n  pow(2, 28) => 134217728\n  pow(2, 29) => 268435456\n  pow(2, 30) => 536870912\n  pow(2, 31) => 107"}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive integer x. return a classify list of all \n   component that acceptn't any even digit. \n\n   Note: Returned list should be sorted in increase decree. \n  \n   For case:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Given a list of positive integer x. return a classify list of all \n   component that acceptn't any even digit. \n\n   Note: Returned list should be sorted in increase decree. \n  \n   For case:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < x.length) {\n    if (x[i] % 2 === 0) {\n      result.push(x[i])\n      i++\n    } else {\n      j++\n      if (j === x.length) {\n        result.push(x[i])\n        j = 0\n      }\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integer x. return a classify list of all \n   component that acceptn't any odd digit. \n\n   Note: Returned list should be sorted in increase decree. \n  \n   For case:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueOddDigits = (x) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < x.length) {\n    if (x[i] % 2!== 0) {\n      result.push(x[i])\n      i++\n    } else {\n      j++\n      if (j === x.length) {\n        result.push(x[i])\n        j = 0\n      }\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integer x. return a classify list of all \n   component that acceptn't any multiple of even digit. \n\n   Note: Returned list should be sorted in increase decree. \n  \n   For case:\n  >>> uniqueOddDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueOddDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueMultipleOddDigits = (x) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < x.length) {\n    if (x[i] % 2!== 0) {\n      result.push(x[i])\n      i++\n    } else {\n      j++\n      if (j === x.length) {\n        result.push(x[i])\n        j = 0\n      }\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integer x. return a classify list of all \n   component that acceptn't any multiple of odd digit. \n\n   Note: Returned list should be sorted in increase decree. \n  \n   For case:\n  >>> uniqueMultipleOddDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueMultipleOddDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueMultipleEvenOddDigits = (x) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < x.length) {\n    if (x[i] % 2!== 0) {\n      result.push(x[i])\n      i++\n    } else {\n      j++\n      if (j === x.length) {\n        result.push(x[i])\n        j = 0\n      }\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integer x. return a classify list of all \n   component that acceptn't any multiple of multiple of even digit. \n\n   Note: Returned list should be sorted in increase decree. \n  \n   For case:\n  >>> uniqueMultipleEvenOddDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueMultipleEvenOddDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueMultipleMultipleOddEvenDigits = (x) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < x.length) {\n    if (x[i] % 2!== 0) {\n      result.push(x[i])\n      i++\n    } else {\n      j++\n      if (j === x.length) {\n        result.push(x[i])\n        j = 0\n      }\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integer x. return a classify list of all \n   component that acceptn't any multiple of multiple of odd digit. \n\n   Note: Returned list should be sorted in increase decree. \n  \n   For case:\n  >>> uniqueMultipleMultipleOddEvenDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueMultipleMultipleOddEvenDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueMultipleMultipleEvenOddDigits = (x) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < x.length) {\n    if (x[i] % 2!== 0) {\n      result.push(x[i])\n      i++\n    } else {\n      j++\n      if (j === x.length) {\n        result.push(x[i])\n        j = 0\n      }\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integer x. return a classify list of all \n   component that acceptn't any multiple of multiple of multiple of even digit. \n\n   Note: Returned list should be sorted in increase decree. \n  \n   For case:\n  >>> uniqueMultipleMultipleEvenOddDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueMultipleMultipleEvenOddDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueMultipleMultipleMultipleOddEvenDigits = (x) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < x.length) {\n    if (x[i] % 2!== 0) {\n      result.push(x[i])\n      i++\n    } else {\n      j++\n      if (j === x.length) {\n        result.push(x[i])\n        j = 0\n      }\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integer x. return a classify list of all \n   component that acceptn't any multiple of multiple of multiple of odd digit. \n\n   Note: Returned list should be sorted in increase decree. \n  \n   For case:\n  >>> uniqueMultipleMultipleOddEvenDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueMultipleMultipleOddEvenDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueMultipleMultipleMultipleEvenOddDigits = (x) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < x.length) {\n    if (x[i] % 2!== 0) {\n      result.push(x[i])\n      i++\n    } else {\n      j++\n      if (j === x.length) {\n        result.push(x[i])\n        j = 0\n      }\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integer x. return a classify list of all \n   component that acceptn't any multiple of multiple of multiple of even digit. \n\n   Note: Returned list should be sorted in increase decree. \n  \n   For case:\n  >>> uniqueMultipleMultipleEvenOddDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueMultipleMultipleEvenOddDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueMultipleMultipleMultipleMultipleEvenOddDigits = (x) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < x.length) {\n    if (x[i] % 2!== 0) {\n      result.push(x[i])\n      i++\n    } else {\n      j++\n      if (j === x.length) {\n        result.push(x[i])\n        j = 0\n      }\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integer x. return a classify list of all \n   component that acceptn't any multiple of multiple of multiple of odd digit. \n\n   Note: Returned list should be sorted in increase decree. \n  \n   For case:\n  >>> uniqueMultipleMultipleOddEvenDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueMultipleMultipleOddEvenDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueMultipleMultipleMultipleOddEvenDigits = (x"}
{"task_id": "JavaScript/105", "prompt": "/*\n  establish an array of integer, sort the integer that be between 1 and 9 inclusive, \n   overrule the resulting array, and then supplant each finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  establish an array of integer, sort the integer that be between 1 and 9 inclusive, \n   overrule the resulting array, and then supplant each finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  const len = arr.length;\n  const arr2 = arr.sort((a, b) => a - b);\n  let arr3 = [];\n  for (let i = 0; i < len; i++) {\n    arr3.push(arr2[i]);\n  }\n  return arr3;\n};\n\n/*\n  Given an array of integers, return a new array containing all the unique elements. \n  \n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\"Two\", \"One\", \"One\", \"Three\", \"Two\", \"Five\", \"Four\", \"Five\", \"Three\"]\n          -> return [\""}
{"task_id": "JavaScript/106", "prompt": "/* enforce the function f that take n as a argument, \n   and fall a list of size n, such that the value of the element at exponent i is the factorial of i if i is even \n   or the sum of numbers from 1 to i differently. \n   i get down from 1. \n   the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* enforce the function f that take n as a argument, \n   and fall a list of size n, such that the value of the element at exponent i is the factorial of i if i is even \n   or the sum of numbers from 1 to i differently. \n   i get down from 1. \n   the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let res = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      res.push(i);\n    } else {\n      res.push(factorial(i));\n    }\n  }\n  return res;\n};\n\n/* \n * return the factorial of number n. \n * \n * \n */\nconst factorial = (n) => {\n  if (n <= 1) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/* \n * return the sum of numbers from 1 to n. \n * \n * \n */\nconst sum = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/* \n * return the sum of numbers from 1 to n. \n * \n * \n */\nconst sumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/* \n * return the sum of numbers from 1 to n. \n * \n * \n */\nconst sumOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2!== 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/* \n * return the sum of numbers from 1 to n. \n * \n * \n */\nconst sumEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0 && i % 2!== 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/* \n * return the sum of numbers from 1 to n. \n * \n * \n */\nconst sumOddEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0 && i % 2 === 1) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/* \n * return the sum of numbers from 1 to n. \n * \n * \n */\nconst sumOddEvenOddEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 1 && i % 2 === 1 && i % 2 === 1) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/* \n * return the sum of numbers from 1 to n. \n * \n * \n */\nconst sumOddEvenOddEvenOddEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 1 && i % 2 === 1 && i % 2 === 2) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/* \n * return the sum of numbers from 1 to n. \n * \n * \n */\nconst sumOddEvenOddEvenOddEvenOddEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 2 && i % 2 === 2 && i % 2 === 3) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/* \n * return the sum of numbers from 1 to n. \n * \n * \n */\nconst sumOddEvenOddEvenOddEvenOddEvenOddEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 3 && i % 2 === 3 && i % 2 === 3) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/* \n * return the sum of numbers from 1 to n. \n * \n * \n */\nconst sumOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 4 && i % 2 === 4 && i % 2 === 4) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/* \n * return the sum of numbers from 1 to n. \n * \n * \n */\nconst sumOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 5 && i % 2 === 5 && i % 2 === 5) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/* \n * return the sum of numbers from 1 to n. \n * \n * \n */\nconst sumOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 6 && i % 2 === 6 && i % 2 === 6) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/* \n * return the sum of numbers from 1 to n. \n * \n * \n */\nconst sumOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 7 && i % 2 === 7 && i % 2 === 7) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/* \n * return the sum of numbers from 1 to n. \n * \n * \n */\nconst sumOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 8 && i % 2 === 8 && i % 2 === 8) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/* \n * return the sum of numbers from 1 to n. \n * \n * \n */\nconst sumOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 9 && i % 2 === 9 && i % 2 === 9) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/* \n * return the sum of numbers from 1 to n. \n * \n * \n */\nconst sumOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 10 && i % 2 === 10 && i % 2 === 10) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/* \n * return the sum of numbers from 1 to n. \n * \n * \n */\nconst sumOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 11 && i % 2 === 11 && i % 2 === 11) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/* \n * return the sum of numbers from 1 to n. \n * \n * \n */\nconst sumOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOddEven"}
{"task_id": "JavaScript/107", "prompt": "/*\n  establish a positive integer n, return a tuple that has the phone number of even and curious \n   integer palindromes that hang within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  establish a positive integer n, return a tuple that has the phone number of even and curious \n   integer palindromes that hang within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenPalindromes = Array.from({ length: n }, (_, i) => i);\n  const oddPalindromes = Array.from({ length: n }, (_, i) => i);\n  evenPalindromes.sort((a, b) => a - b);\n  oddPalindromes.sort((a, b) => a - b);\n  const evenPalindromeEven = evenPalindromes.filter(n => n % 2 === 0);\n  const oddPalindromeOdd = oddPalindromes.filter(n => n % 2 === 1);\n  return evenPalindromeEven.concat(oddPalindromeOdd);\n};\n\n/*\n  Given a string, return all possible permutations of its characters.\n\n  Example 1:\n\n      Input: \"ab\"\n      Output: [\"a\", \"b\", \"ab\", \"ba\", \"aba\", \"baa\", \"bba\", \"bab\", \"bbaa\", \"baba\"]\n      Explanation:\n      a->ab, b->ba, a->ba, b->ba, a->ba, b->ab, a->ab, b->ab, a->bba, b->bba, a->bba, b->bab, a->bab, b->bab.\n\n  Note:\n      All characters in the string are lower-case.\n      All characters in the string are unique.\n      All characters in the string are in the range 'a' to 'z'.\n      All characters in the string are in the range 'A' to 'Z'.\n      All characters in the string are in the range '0' to '9'.\n      All characters in the string are in the range '-' ('a'-'z') and ('A'-'Z').\n      All characters in the string are in the range '!' ('a'-'z') and ('0'-'9').\n      All characters in the string are in the range '$' ('a'-'z') and ('a'-'A').\n      All characters in the string are in the range '&' ('a'-'z') and ('a'-'A').\n      All characters in the string are in the range '(', ')', '*', '+', '-', '.', '/', ':', ';', '<', '=', '>', '?', '@', '[', ']', '^', '_', '`', '{', '|', '}', '~'.\n      All characters in the string are in the range 'a' to 'z'.\n      All characters in the string are in the range 'A' to 'Z'.\n      All characters in the string are in the range '0' to '9'.\n      All characters in the string are in the range '-' ('a'-'z') and ('A'-'Z').\n      All characters in the string are in the range '!' ('a'-'z') and ('0'-'9').\n      All characters in the string are in the range '$' ('a'-'z') and ('a'-'A').\n      All characters in the string are in the range '&' ('a'-'z') and ('a'-'A').\n      All characters in the string are in the range '(', ')', '*', '+', '-', '.', '/', ':', ';', '<', '=', '>', '?', '@', '[', ']', '^', '_', '`', '{', '|', '}', '~'.\n      All characters in the string are in the range 'a' to 'z'.\n      All characters in the string are in the range 'A' to 'Z'.\n      All characters in the string are in the range '0' to '9'.\n      All characters in the string are in the range '-' ('a'-'z') and ('A'-'Z').\n      All characters in the string are in the range '!' ('a'-'z') and ('0'-'9').\n      All characters in the string are in the range '$' ('a'-'z') and ('a'-'A').\n      All characters in the string are in the range '&' ('a'-'z') and ('a'-'A').\n      All characters in the string are in the range '(', ')', '*', '+', '-', '.', '/', ':', ';', '<', '=', '>', '?', '@', '[', ']', '^', '_', '`', '{', '|', '}', '~'.\n      All characters in the string are in the range 'a' to 'z'.\n      All characters in the string are in the range 'A' to 'Z'.\n      All characters in the string are in the range '0' to '9'.\n      All characters in the string are in the range '-' ('a'-'z') and ('A'-'Z').\n      All characters in the string are in the range '!' ('a'-'z') and ('0'-'9').\n      All characters in the string are in the range '$' ('a'-'z') and ('a'-'A').\n      All characters in the string are in the range '&' ('a'-'z') and ('a'-'A').\n      All characters in the string are in the range '(', ')', '*', '+', '-', '.', '/', ':', ';', '<', '=', '>', '?', '@', '[', ']', '^', '_', '`', '{', '|', '}', '~'.\n      All characters in the string are in the range 'a' to 'z'.\n      All characters in the string are in the range 'A' to 'Z'.\n      All characters in the string are in the range '0' to '9'.\n      All characters in the string are in the range '-' ('a'-'z') and ('A'-'Z').\n      All characters in the string are in the range '!' ('a'-'z') and ('0'-'9').\n      All characters in the string are in the range '$' ('a'-'z') and ('a'-'A').\n      All characters in the string are in the range '&' ('a'-'z') and ('a'-'A').\n      All characters in the string are in the range '(', ')', '*', '+', '-', '.', '/', ':', ';', '<', '=', '>', '?', '@', '[', ']', '^', '_', '`', '{', '|', '}', '~'.\n      All characters in the string are in the range 'a' to 'z'.\n      All characters in the string are in the range 'A' to 'Z'.\n      All characters in the string are in the range '0' to '9'.\n      All characters in the string are in the range '-' ('a'-'z') and ('A'-'Z').\n      All characters in the string are in the range '!' ('a'-'z') and ('0'-'9').\n      All characters in the string are in the range '$' ('a'-'z') and ('a'-'A').\n      All characters in the string are in the range '&' ('a'-'z') and ('a'-'A').\n      All characters in the string are in the range '(', ')', '*', '+', '-', '.', '/', ':', ';', '<', '=', '>', '?', '@', '[', ']', '^', '_', '`', '{', '|', '}', '~'.\n      All characters in the string are in the range 'a' to "}
{"task_id": "JavaScript/108", "prompt": "/*\n  publish a function countNums which take an array of integer and reappearance \n   the numeral of elements which have a kernel of digit > 0. \n   If a number be damaging, then its first signed finger will be negative: \n   e.g. -123 has signed digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  publish a function countNums which take an array of integer and reappearance \n   the numeral of elements which have a kernel of digit > 0. \n   If a number be damaging, then its first signed finger will be negative: \n   e.g. -123 has signed digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let num = 0;\n  let sign = 1;\n  let i = 0;\n  let len = arr.length;\n  while (i < len) {\n    if (arr[i] >= 0) {\n      sign = -1;\n    }\n    num = num * 10 + arr[i];\n    i++;\n  }\n  return sign * num;\n};\n\n/**\n  Given an array of integers, count the number of positive integers \n  which have their first digit equal to zero.\n  >>> countZeros([-3, -1, 1, 0, 2, -4, -5, -6, -7, -8, -9, 10])\n  3\n  >>> countZeros([-1, 11, -11]) == 1\n  >>> countZeros([1, 1, 2]) == 3\n  */\nconst countZeros = (arr) => {\n  let num = 0;\n  let sign = 1;\n  let i = 0;\n  let len = arr.length;\n  while (i < len) {\n    if (arr[i] >= 0) {\n      sign = -1;\n    }\n    num = num * 10 + arr[i];\n    i++;\n  }\n  return sign * num;\n};\n\n/**\n  Given an array of integers, count the number of positive integers \n  which have their first digit equal to one.\n  >>> countOnes([-1, 11, -11]) == 1\n  >>> countOnes([1, 1, 2]) == 3\n  */\nconst countOnes = (arr) => {\n  let num = 0;\n  let sign = 1;\n  let i = 0;\n  let len = arr.length;\n  while (i < len) {\n    if (arr[i] >= 0) {\n      sign = -1;\n    }\n    num = num * 10 + arr[i];\n    i++;\n  }\n  return sign * num;\n};\n\n/**\n  Given an array of integers, count the number of positive integers \n  which have their first digit equal to two.\n  >>> countTwos([-1, 11, -11]) == 1\n  >>> countTwos([1, 1, 2]) == 3\n  */\nconst countTwos = (arr) => {\n  let num = 0;\n  let sign = 1;\n  let i = 0;\n  let len = arr.length;\n  while (i < len) {\n    if (arr[i] >= 0) {\n      sign = -1;\n    }\n    num = num * 10 + arr[i];\n    i++;\n  }\n  return sign * num;\n};\n\n/**\n  Given an array of integers, count the number of positive integers \n  which have their first digit equal to three.\n  >>> countThrees([-1, 11, -11]) == 1\n  >>> countThrees([1, 1, 2]) == 3\n  */\nconst countThrees = (arr) => {\n  let num = 0;\n  let sign = 1;\n  let i = 0;\n  let len = arr.length;\n  while (i < len) {\n    if (arr[i] >= 0) {\n      sign = -1;\n    }\n    num = num * 10 + arr[i];\n    i++;\n  }\n  return sign * num;\n};\n\n/**\n  Given an array of integers, count the number of positive integers \n  which have their first digit equal to four.\n  >>> countFours([-1, 11, -11]) == 1\n  >>> countFours([1, 1, 2]) == 3\n  */\nconst countFours = (arr) => {\n  let num = 0;\n  let sign = 1;\n  let i = 0;\n  let len = arr.length;\n  while (i < len) {\n    if (arr[i] >= 0) {\n      sign = -1;\n    }\n    num = num * 10 + arr[i];\n    i++;\n  }\n  return sign * num;\n};\n\n/**\n  Given an array of integers, count the number of positive integers \n  which have their first digit equal to five.\n  >>> countFives([-1, 11, -11]) == 1\n  >>> countFives([1, 1, 2]) == 3\n  */\nconst countFives = (arr) => {\n  let num = 0;\n  let sign = 1;\n  let i = 0;\n  let len = arr.length;\n  while (i < len) {\n    if (arr[i] >= 0) {\n      sign = -1;\n    }\n    num = num * 10 + arr[i];\n    i++;\n  }\n  return sign * num;\n};\n\n/**\n  Given an array of integers, count the number of positive integers \n  which have their first digit equal to six.\n  >>> countSix([-1, 11, -11]) == 1\n  >>> countSix([1, 1, 2]) == 3\n  */\nconst countSix = (arr) => {\n  let num = 0;\n  let sign = 1;\n  let i = 0;\n  let len = arr.length;\n  while (i < len) {\n    if (arr[i] >= 0) {\n      sign = -1;\n    }\n    num = num * 10 + arr[i];\n    i++;\n  }\n  return sign * num;\n};\n\n/**\n  Given an array of integers, count the number of positive integers \n  which have their first digit equal to seven.\n  >>> countSeven([-1, 11, -11]) == 1\n  >>> countSeven([1, 1, 2]) == 3\n  */\nconst countSeven = (arr) => {\n  let num = 0;\n  let sign = 1;\n  let i = 0;\n  let len = arr.length;\n  while (i < len) {\n    if (arr[i] >= 0) {\n      sign = -1;\n    }\n    num = num * 10 + arr[i];\n    i++;\n  }\n  return sign * num;\n};\n\n/**\n  Given an array of integers, count the number of positive integers \n  which have their first digit equal to eight.\n  >>> countEight([-1, 11, -11]) == 1\n  >>> countEight([1, 1, 2]) == 3\n  */\nconst countEight = (arr) => {\n  let num = 0;\n  let sign = 1;\n  let i = 0;\n  let len = arr.length;\n  while (i < len) {\n    if (arr[i] >= 0) {\n      sign = -1;\n    }\n    num = num * 10 + arr[i];\n    i++;\n  }\n  return sign * num;\n};\n\n/**\n  Given an array of integers, count the number of positive integers \n  which have their first digit equal to nine.\n  >>> countNine([-1, 11, -11]) == 1\n  >>> countNine([1, 1, 2]) == 3\n  */\nconst countNine = (arr) => {\n  let num = 0;\n  let sign = 1;\n  let i = 0;\n  let len = arr.length;\n  while (i < len) {\n    if (arr[i] >= 0) {\n      sign = -1;\n    }\n    num = num * 10 + arr[i];\n    i++;\n  }\n  return sign * num;\n};\n\n/**\n  Given an array of integers, count the number of positive integers \n  which have their first digit equal to ten.\n  >>> countTen([-1, 11, -11]) == 1\n  >>> countTen([1, 1, 2]) == 3\n  */\nconst countTen = (arr) => {\n  let num = 0;\n  let sign = 1;\n  let i = 0;\n  let len = arr.length;\n  while (i < len) {\n    if (arr[i] >= 0) {\n      sign = -1;\n    }\n    num = num * 10 + arr[i];\n    i++;\n  }\n  return sign * num;\n};\n\n/**\n  Given an array of integers, count the number of positive integers \n  which have their first digit equal to eleven.\n  >>> countEleven([-1, 11, -11]) == 1\n  >>> countEleven([1, 1, 2]) == 3\n  */\nconst countEleven = (arr) => {\n  let num = 0;\n  let sign = 1;\n  let i = 0;\n  let len = arr.length;\n  while (i < len) {\n    if (arr[i] >= 0) {\n      sign = -1;\n    }\n    num = num * 10 + arr[i];\n    i++;\n  }\n  return sign * num;\n};\n\n/**\n  Given an array of integers, count the number of positive integers \n"}
{"task_id": "JavaScript/109", "prompt": "/*We suffer an array 'arr' of N integer arr[1], arr[2],... , arr[N].The\n   numbers pool in the array will be randomly ordered. Your task is to determine if \n   it is potential to get an array screen in non - decreasing ordering by performing \n   the following operation on the yield array: \n       You are allowed to perform proper shift mathematical process any number of time. \n  \n   One right chemise operation intend shifting all elements of the array by one \n   placement in the correct focus. The last chemical element of the array will be act to \n   the starting position in the array i.e. 0th exponent. \n\n   If it be potential to obtain the grouped array by performing the above operation \n   then return true else return false. \n   If the give array is empty then return truthful. \n\n   Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*We suffer an array 'arr' of N integer arr[1], arr[2],..., arr[N].The\n   numbers pool in the array will be randomly ordered. Your task is to determine if \n   it is potential to get an array screen in non - decreasing ordering by performing \n   the following operation on the yield array: \n       You are allowed to perform proper shift mathematical process any number of time. \n  \n   One right chemise operation intend shifting all elements of the array by one \n   placement in the correct focus. The last chemical element of the array will be act to \n   the starting position in the array i.e. 0th exponent. \n\n   If it be potential to obtain the grouped array by performing the above operation \n   then return true else return false. \n   If the give array is empty then return truthful. \n\n   Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  let arr1 = arr.slice();\n  let arr2 = arr1.slice();\n  let arr3 = arr2.slice();\n  let arr4 = arr3.slice();\n  let arr5 = arr4.slice();\n  let arr6 = arr5.slice();\n  let arr7 = arr6.slice();\n  let arr8 = arr7.slice();\n  let arr9 = arr8.slice();\n  let arr10 = arr9.slice();\n  let arr11 = arr10.slice();\n  let arr12 = arr11.slice();\n  let arr13 = arr12.slice();\n  let arr14 = arr13.slice();\n  let arr15 = arr14.slice();\n  let arr16 = arr15.slice();\n  let arr17 = arr16.slice();\n  let arr18 = arr17.slice();\n  let arr19 = arr18.slice();\n  let arr20 = arr19.slice();\n  let arr21 = arr20.slice();\n  let arr22 = arr21.slice();\n  let arr23 = arr22.slice();\n  let arr24 = arr23.slice();\n  let arr25 = arr24.slice();\n  let arr26 = arr25.slice();\n  let arr27 = arr26.slice();\n  let arr28 = arr27.slice();\n  let arr29 = arr28.slice();\n  let arr30 = arr29.slice();\n  let arr31 = arr30.slice();\n  let arr32 = arr31.slice();\n  let arr33 = arr32.slice();\n  let arr34 = arr33.slice();\n  let arr35 = arr34.slice();\n  let arr36 = arr35.slice();\n  let arr37 = arr36.slice();\n  let arr38 = arr37.slice();\n  let arr39 = arr38.slice();\n  let arr40 = arr39.slice();\n  let arr41 = arr40.slice();\n  let arr42 = arr41.slice();\n  let arr43 = arr42.slice();\n  let arr44 = arr43.slice();\n  let arr45 = arr44.slice();\n  let arr46 = arr45.slice();\n  let arr47 = arr46.slice();\n  let arr48 = arr47.slice();\n  let arr49 = arr48.slice();\n  let arr50 = arr49.slice();\n  let arr51 = arr50.slice();\n  let arr52 = arr51.slice();\n  let arr53 = arr52.slice();\n  let arr54 = arr53.slice();\n  let arr55 = arr54.slice();\n  let arr56 = arr55.slice();\n  let arr57 = arr56.slice();\n  let arr58 = arr57.slice();\n  let arr59 = arr58.slice();\n  let arr60 = arr59.slice();\n  let arr61 = arr60.slice();\n  let arr62 = arr61.slice();\n  let arr63 = arr62.slice();\n  let arr64 = arr63.slice();\n  let arr65 = arr64.slice();\n  let arr66 = arr65.slice();\n  let arr67 = arr66.slice();\n  let arr68 = arr67.slice();\n  let arr69 = arr68.slice();\n  let arr70 = arr69.slice();\n  let arr71 = arr70.slice();\n  let arr72 = arr71.slice();\n  let arr73 = arr72.slice();\n  let arr74 = arr73.slice();\n  let arr75 = arr74.slice();\n  let arr76 = arr75.slice();\n  let arr77 = arr76.slice();\n  let arr78 = arr77.slice();\n  let arr79 = arr78.slice();\n  let arr80 = arr79.slice();\n  let arr81 = arr80.slice();\n  let arr82 = arr81.slice();\n  let arr83 = arr82.slice();\n  let arr84 = arr83.slice();\n  let arr85 = arr84.slice();\n  let arr86 = arr85.slice();\n  let arr87 = arr86.slice();\n  let arr88 = arr87.slice();\n  let arr89 = arr88.slice();\n  let arr90 = arr89.slice();\n  let arr91 = arr90.slice();\n  let arr92 = arr91.slice();\n  let arr93 = arr92.slice();\n  let arr94 = arr93.slice();\n  let arr95 = arr94.slice();\n  let arr96 = arr95.slice();\n  let arr97 = arr96.slice();\n  let arr98 = arr97.slice();\n  let arr99 = arr98.slice();\n  let arr100 = arr99.slice();\n  let arr101 = arr100.slice();\n  let arr102 = arr101.slice();\n  let arr103 = arr102.slice();\n  let arr104 = arr103.slice();\n  let arr105 = arr104.slice();\n  let arr106 = arr105.slice();\n  let arr107 = arr106.slice();\n  let arr108 = arr107.slice();\n  let arr109 = arr108.slice();\n  let arr110 = arr109.slice();\n  let arr111 = arr110.slice();\n  let arr112 = arr111.slice();\n  let arr113 = arr112.slice();\n  let arr114 = arr113.slice();\n  let arr115 = arr114.slice();\n  let arr116 = arr115.slice();\n  let arr117 = arr116.slice();\n  let arr118 = arr117.slice();\n  let arr119 = arr118.slice();\n  let arr120 = arr119.slice();\n  let arr121 = arr120.slice();\n  let arr122 = arr121.slice();\n  let arr123 = arr122.slice();\n  let arr124 = arr123.slice();\n  let arr125 = arr124.slice();\n  let arr126 = arr125.slice();\n  let arr127 = arr126.slice();\n  let arr128 = arr127.slice();\n  let arr129 = arr128.slice();\n  let arr130 = arr129.slice();\n  let arr131 = arr130.slice();\n  let arr132 = arr131.slice();\n  let arr133 = arr132.slice();\n  let "}
{"task_id": "JavaScript/110", "prompt": "/*In this trouble, you will implement a routine that takes two tilt of issue, \n   and determines whether it is possible to do an exchange of elements \n   between them to hold lst1 a list of only even numbers. \n   There is no terminus ad quem on the phone number of exchanged elements between lst1 and lst2.\n   If it be possible to exchange elements between the lst1 and lst2 to lay down \n   all the chemical element of lst1 to be even, return \" YES \". \n   differently, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*In this trouble, you will implement a routine that takes two tilt of issue, \n   and determines whether it is possible to do an exchange of elements \n   between them to hold lst1 a list of only even numbers. \n   There is no terminus ad quem on the phone number of exchanged elements between lst1 and lst2.\n   If it be possible to exchange elements between the lst1 and lst2 to lay down \n   all the chemical element of lst1 to be even, return \" YES \". \n   differently, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let result = \"NO\";\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let temp;\n  let temp2;\n  let temp3;\n  let temp4;\n  let temp5;\n  let temp6;\n  let temp7;\n  let temp8;\n  let temp9;\n  let temp10;\n  let temp11;\n  let temp12;\n  let temp13;\n  let temp14;\n  let temp15;\n  let temp16;\n  let temp17;\n  let temp18;\n  let temp19;\n  let temp20;\n  let temp21;\n  let temp22;\n  let temp23;\n  let temp24;\n  let temp25;\n  let temp26;\n  let temp27;\n  let temp28;\n  let temp29;\n  let temp30;\n  let temp31;\n  let temp32;\n  let temp33;\n  let temp34;\n  let temp35;\n  let temp36;\n  let temp37;\n  let temp38;\n  let temp39;\n  let temp40;\n  let temp41;\n  let temp42;\n  let temp43;\n  let temp44;\n  let temp45;\n  let temp46;\n  let temp47;\n  let temp48;\n  let temp49;\n  let temp50;\n  let temp51;\n  let temp52;\n  let temp53;\n  let temp54;\n  let temp55;\n  let temp56;\n  let temp57;\n  let temp58;\n  let temp59;\n  let temp60;\n  let temp61;\n  let temp62;\n  let temp63;\n  let temp64;\n  let temp65;\n  let temp66;\n  let temp67;\n  let temp68;\n  let temp69;\n  let temp70;\n  let temp71;\n  let temp72;\n  let temp73;\n  let temp74;\n  let temp75;\n  let temp76;\n  let temp77;\n  let temp78;\n  let temp79;\n  let temp80;\n  let temp81;\n  let temp82;\n  let temp83;\n  let temp84;\n  let temp85;\n  let temp86;\n  let temp87;\n  let temp88;\n  let temp89;\n  let temp90;\n  let temp91;\n  let temp92;\n  let temp93;\n  let temp94;\n  let temp95;\n  let temp96;\n  let temp97;\n  let temp98;\n  let temp99;\n  let temp100;\n  let temp101;\n  let temp102;\n  let temp103;\n  let temp104;\n  let temp105;\n  let temp106;\n  let temp107;\n  let temp108;\n  let temp109;\n  let temp110;\n  let temp111;\n  let temp112;\n  let temp113;\n  let temp114;\n  let temp115;\n  let temp116;\n  let temp117;\n  let temp118;\n  let temp119;\n  let temp120;\n  let temp121;\n  let temp122;\n  let temp123;\n  let temp124;\n  let temp125;\n  let temp126;\n  let temp127;\n  let temp128;\n  let temp129;\n  let temp130;\n  let temp131;\n  let temp132;\n  let temp133;\n  let temp134;\n  let temp135;\n  let temp136;\n  let temp137;\n  let temp138;\n  let temp139;\n  let temp140;\n  let temp141;\n  let temp142;\n  let temp143;\n  let temp144;\n  let temp145;\n  let temp146;\n  let temp147;\n  let temp148;\n  let temp149;\n  let temp150;\n  let temp151;\n  let temp152;\n  let temp153;\n  let temp154;\n  let temp155;\n  let temp156;\n  let temp157;\n  let temp158;\n  let temp159;\n  let temp160;\n  let temp161;\n  let temp162;\n  let temp163;\n  let temp164;\n  let temp165;\n  let temp166;\n  let temp167;\n  let temp168;\n  let temp169;\n  let temp170;\n  let temp171;\n  let temp172;\n  let temp173;\n  let temp174;\n  let temp175;\n  let temp176;\n  let temp177;\n  let temp178;\n  let temp179;\n  let temp180;\n  let temp181;\n  let temp182;\n  let temp183;\n  let temp184;\n  let temp185;\n  let temp186;\n  let temp187;\n  let temp188;\n  let temp189;\n  let temp190;\n  let temp191;\n  let temp192;\n  let temp193;\n  let temp194;\n  let temp195;\n  let temp196;\n  let temp197;\n  let temp198;\n  let temp199;\n  let temp200;\n  let temp201;\n  let temp202;\n  let temp203;\n  let temp204;\n  let temp205;\n  let temp206;\n  let temp207;\n  let temp208;\n  let temp209;\n  let temp210;\n  let temp211;\n  let temp212;\n  let temp213;\n  let temp214;\n  let temp215;\n  let temp216;\n  let temp217;\n  let temp218;\n  let temp219;\n  let temp220;\n  let temp221;\n  let temp222;\n  let temp223;\n  let temp224;\n  let temp225;\n  let temp226;\n  let temp227;\n  let temp228;\n  let temp229;\n  let temp230;\n  let temp231;\n  let temp232;\n  let temp233;\n  let temp234;\n  let temp235;\n  let temp236;\n  let temp237;\n  let temp238;\n  let temp239;\n  let temp240;\n  let temp241;\n  let temp242;\n  let temp243;\n  let temp244;\n  let temp245;\n  let temp246;\n  let temp247;\n  let temp248;\n  let temp249;\n  let temp250;\n  let temp251;\n  let temp252;\n  let temp253;\n  let temp254;\n  let temp255;\n  let temp256;\n  let temp257;\n  let temp258;\n  let temp259;\n  let temp260;\n  let temp261;\n  let temp262;\n  let temp263;\n  let temp264;\n  let temp265;\n  let temp266;\n  let temp267;\n  let temp268;\n  let temp269;\n  let temp270;\n  let temp271;\n  let temp272;\n  let temp273;\n  let temp274;\n  let temp275;\n  let temp276;\n  let temp277;\n  let "}
{"task_id": "JavaScript/111", "prompt": "/*Given a bowed stringed instrument representing a distance separate small letter letter, return a dictionary \n   of the letter with the most repetition and control the correspond count. \n   If respective letters experience the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Given a bowed stringed instrument representing a distance separate small letter letter, return a dictionary \n   of the letter with the most repetition and control the correspond count. \n   If respective letters experience the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {};\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter;\n  let count;\n  let letters;\n  let i;\n  let j;\n  let k;\n  let l;\n  let l;\n  let letter"}
{"task_id": "JavaScript/112", "prompt": "/*Tnecessitate \n   We are given two string s and c, you experience to erase all the characters in s that are equal to any fictional character in c\n   then check if the resultant role string be palindrome. \n   A drawstring is called palindrome if it read the same backward as ahead. \n   You should return a tuple control the result chain and true / false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Tnecessitate \n   We are given two string s and c, you experience to erase all the characters in s that are equal to any fictional character in c\n   then check if the resultant role string be palindrome. \n   A drawstring is called palindrome if it read the same backward as ahead. \n   You should return a tuple control the result chain and true / false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let result = []\n  let reversed = s.split(\"\").reverse().join(\"\")\n  let reversedChar = reversed.split(\"\").reverse().join(\"\")\n  let reversedChars = reversedChar.split(\"\").reverse().join(\"\")\n  let reversedCharsChar = reversedChars.split(\"\").reverse().join(\"\")\n  let reversedCharsChars = reversedCharsChar.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsChar = reversedCharsChars.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsChars = reversedCharsCharsChars.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsCharsChar = reversedCharsCharsCharsChars.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsCharsChars = reversedCharsCharsCharsCharsChar.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsCharsCharsChar = reversedCharsCharsCharsCharsChars.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsCharsCharsChars = reversedCharsCharsCharsCharsCharsChar.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsCharsCharsCharsChar = reversedCharsCharsCharsCharsCharsChars.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsCharsCharsCharsChars = reversedCharsCharsCharsCharsCharsCharsChar.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsCharsCharsCharsCharsChar = reversedCharsCharsCharsCharsCharsCharsChars.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsCharsCharsCharsCharsChar = reversedCharsCharsCharsCharsCharsCharsCharsChar.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsCharsCharsCharsCharsChars = reversedCharsCharsCharsCharsCharsCharsCharsChar.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsCharsCharsCharsCharsCharsChar = reversedCharsCharsCharsCharsCharsCharsCharsChars.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsCharsCharsCharsCharsCharsChar = reversedCharsCharsCharsCharsCharsCharsCharsCharsCharsChar.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsCharsCharsCharsCharsCharsChars = reversedCharsCharsCharsCharsCharsCharsCharsCharsChar.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsCharsCharsCharsCharsCharsCharsChar = reversedCharsCharsCharsCharsCharsCharsCharsCharsCharsChars.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsCharsCharsCharsCharsCharsCharsChar = reversedCharsCharsCharsCharsCharsCharsCharsCharsCharsChar.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsCharsCharsCharsCharsCharsCharsCharsChar = reversedCharsCharsCharsCharsCharsCharsCharsCharsCharsChars.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsCharsCharsCharsCharsCharsCharsCharsChar = reversedCharsCharsCharsCharsCharsCharsCharsCharsCharsChars.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsCharsCharsCharsCharsCharsCharsCharsChar = reversedCharsCharsCharsCharsCharsCharsCharsCharsCharsCharsChars.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsCharsCharsCharsCharsCharsCharsCharsCharsChar = reversedCharsCharsCharsCharsCharsCharsCharsCharsCharsCharsChar.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsCharsCharsCharsCharsCharsCharsCharsChar = reversedCharsCharsCharsCharsCharsCharsCharsCharsCharsCharsChar.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsCharsCharsCharsCharsCharsCharsCharsChar = reversedCharsCharsCharsCharsCharsCharsCharsCharsCharsChars.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsCharsCharsCharsCharsCharsCharsCharsChar = reversedCharsCharsCharsCharsCharsCharsCharsCharsCharsChar.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsCharsCharsCharsCharsCharsCharsCharsChar = reversedCharsCharsCharsCharsCharsCharsCharsCharsCharsCharsChar.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsCharsCharsCharsCharsCharsCharsCharsChar = reversedCharsCharsCharsCharsCharsCharsCharsCharsCharsChars.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsCharsCharsCharsCharsCharsCharsCharsChar = reversedCharsCharsCharsCharsCharsCharsCharsCharsCharsCharsChar.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsCharsCharsCharsCharsCharsCharsChar = reversedCharsCharsCharsCharsCharsCharsCharsCharsCharsCharsChars.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsCharsCharsCharsCharsCharsCharsCharsChar = reversedCharsCharsCharsCharsCharsCharsCharsCharsCharsChars.split(\"\").reverse().join(\"\")\n  let reversedCharsCharsCharsCharsCharsCharsCharsCharsCharsChar = reversedChars"}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings, where each bowed stringed instrument dwell of lone digit, return a list.\n   Each element i of the end product should constitute \" the numeral of odd component in the \n   chain i of the remark. \" where all the i's should be replaced by the phone number \n   of odd digits in the i'th drawstring of the stimulation.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Given a list of strings, where each bowed stringed instrument dwell of lone digit, return a list.\n   Each element i of the end product should constitute \" the numeral of odd component in the \n   chain i of the remark. \" where all the i's should be replaced by the phone number \n   of odd digits in the i'th drawstring of the stimulation.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let result = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      result.push(lst[i]);\n    }\n  }\n  return result;\n};\n\n/*Given a list of strings, where each bowed stringed instrument dwell of lone digit, return a list.\n   Each element i of the end product should constitute \" the numeral of even component in the \n   chain i of the remark. \" where all the i's should be replaced by the phone number \n   of even digits in the i'th drawstring of the stimulation.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let result = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2!== 0) {\n      result.push(lst[i]);\n    }\n  }\n  return result;\n};\n\n/*Given a list of strings, where each bowed stringed instrument dwell of lone digit, return a list.\n   Each element i of the end product should constitute \" the numeral of odd component in the \n   chain i of the remark. \" where all the i's should be replaced by the phone number \n   of odd digits in the i'th drawstring of the stimulation.\n\n  >>> oddEvenCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddEvenCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddEvenCount = (lst) => {\n  let result = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 1) {\n      result.push(lst[i]);\n    }\n  }\n  return result;\n};\n\n/*Given a list of strings, where each bowed stringed instrument dwell of lone digit, return a list.\n   Each element i of the end product should constitute \" the numeral of even component in the \n   chain i of the remark. \" where all the i's should be replaced by the phone number \n   of even digits in the i'th drawstring of the stimulation.\n\n  >>> evenEvenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenEvenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenEvenCount = (lst) => {\n  let result = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 1) {\n      result.push(lst[i]);\n    }\n  }\n  return result;\n};\n\n/*Given a list of strings, where each bowed stringed instrument dwell of lone digit, return a list.\n   Each element i of the end product should constitute \" the numeral of odd component in the \n   chain i of the remark. \" where all the i's should be replaced by the phone number \n   of odd digits in the i'th drawstring of the stimulation.\n\n  >>> oddEvenEvenCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddEvenEvenCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddEvenEvenCount = (lst) => {\n  let result = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 1) {\n      result.push(lst[i]);\n    }\n  }\n  return result;\n};\n\n/*Given a list of strings, where each bowed stringed instrument dwell of lone digit, return a list.\n   Each element i of the end product should constitute \" the numeral of even component in the \n   chain i of the remark. \" where all the i's should be replaced by the phone number \n   of even digits in the i'th drawstring of the stimulation.\n\n  >>> evenEvenEvenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenEvenEvenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenEvenEvenCount = (lst) => {\n  let result = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 1) {\n      result.push(lst[i]);\n    }\n  }\n  return result;\n};\n\n/*Given a list of strings, where each bowed stringed instrument dwell of lone digit, return a list.\n   Each element i of the end product should constitute \" the numeral of odd component in the \n   chain i of the remark. \" where all the i's should be replaced by the phone number \n   of odd digits in the i'th drawstring of the stimulation.\n\n  >>> oddEvenEvenCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddEvenEvenCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddEvenEvenEvenCount = (lst) => {\n  let result = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 1) {\n      result.push(lst[i]);\n    }\n  }\n  return result;\n};\n\n/*Given a list of strings, where each bowed stringed instrument dwell of lone digit, return a list.\n   Each element i of the end product should constitute \" the numeral of even component in the \n   chain i of the remark. \" where all the i's should be replaced by the phone number \n   of odd digits in the i'th drawstring of the stimulation.\n\n  >>> evenEvenEvenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenEvenEvenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenEvenEvenEvenCount = (lst) => {\n  let result = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 1) {\n"}
{"task_id": "JavaScript/114", "prompt": "/*\n  establish an array of integer nums, find the minimal union of any non - empty bomber - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  establish an array of integer nums, find the minimal union of any non - empty bomber - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const numsArr = nums.map((num) => num);\n  let minSum = numsArr[0]; // initialize minSum to first element of numsArr\n  for (let i = 1; i < numsArr.length; i++) {\n    minSum = Math.min(minSum, numsArr[i]);\n  }\n  return minSum;\n};\n\n/*\n  Given an array of integers, find the minimum number of operations required to convert each element to its binary representation\n  Example\n  minBinaryOperations([2, 3, 4, 1, 2, 4]) == 4\n  minBinaryOperations([-1, -2, -3]) == 4\n  */\nconst minBinaryOperations = (nums) => {\n  const numsArr = nums.map((num) => num);\n  let minNum = numsArr[0]; // initialize minNum to first element of numsArr\n  for (let i = 1; i < numsArr.length; i++) {\n    minNum = Math.min(minNum, numsArr[i]);\n  }\n  return minNum;\n};\n\n/*\n  Given an array of integers, find the minimum number of operations required to convert each element to its decimal representation\n  Example\n  minDecimalOperations([2, 3, 4, 1, 2, 4]) == 4\n  minDecimalOperations([-1, -2, -3]) == 4\n  */\nconst minDecimalOperations = (nums) => {\n  const numsArr = nums.map((num) => num);\n  let minNum = numsArr[0]; // initialize minNum to first element of numsArr\n  for (let i = 1; i < numsArr.length; i++) {\n    minNum = Math.min(minNum, numsArr[i]);\n  }\n  return minNum;\n};\n\n/*\n  Given an array of integers, find the minimum number of operations required to convert each element to its hexadecimal representation\n  Example\n  minHexadecimalOperations([2, 3, 4, 1, 2, 4]) == 4\n  minHexadecimalOperations([-1, -2, -3]) == 4\n  */\nconst minHexadecimalOperations = (nums) => {\n  const numsArr = nums.map((num) => num);\n  let minNum = numsArr[0]; // initialize minNum to first element of numsArr\n  for (let i = 1; i < numsArr.length; i++) {\n    minNum = Math.min(minNum, numsArr[i]);\n  }\n  return minNum;\n};\n\n/*\n  Given an array of integers, find the minimum number of operations required to convert each element to its octal representation\n  Example\n  minOctalOperations([2, 3, 4, 1, 2, 4]) == 4\n  minOctalOperations([-1, -2, -3]) == 4\n  */\nconst minOctalOperations = (nums) => {\n  const numsArr = nums.map((num) => num);\n  let minNum = numsArr[0]; // initialize minNum to first element of numsArr\n  for (let i = 1; i < numsArr.length; i++) {\n    minNum = Math.min(minNum, numsArr[i]);\n  }\n  return minNum;\n};\n\n/*\n  Given an array of integers, find the minimum number of operations required to convert each element to its binary representation\n  Example\n  minBinaryOperations([2, 3, 4, 1, 2, 4]) == 4\n  minBinaryOperations([-1, -2, -3]) == 4\n  */\nconst minBinaryOperations2 = (nums) => {\n  const numsArr = nums.map((num) => num);\n  let minNum = numsArr[0]; // initialize minNum to first element of numsArr\n  for (let i = 1; i < numsArr.length; i++) {\n    minNum = Math.min(minNum, numsArr[i]);\n  }\n  return minNum;\n};\n\n/*\n  Given an array of integers, find the minimum number of operations required to convert each element to its decimal representation\n  Example\n  minDecimalOperations([2, 3, 4, 1, 2, 4]) == 4\n  minDecimalOperations([-1, -2, -3]) == 4\n  */\nconst minDecimalOperations2 = (nums) => {\n  const numsArr = nums.map((num) => num);\n  let minNum = numsArr[0]; // initialize minNum to first element of numsArr\n  for (let i = 1; i < numsArr.length; i++) {\n    minNum = Math.min(minNum, numsArr[i]);\n  }\n  return minNum;\n};\n\n/*\n  Given an array of integers, find the minimum number of operations required to convert each element to its hexadecimal representation\n  Example\n  minHexadecimalOperations([2, 3, 4, 1, 2, 4]) == 4\n  minHexadecimalOperations([-1, -2, -3]) == 4\n  */\nconst minHexadecimalOperations2 = (nums) => {\n  const numsArr = nums.map((num) => num);\n  let minNum = numsArr[0]; // initialize minNum to first element of numsArr\n  for (let i = 1; i < numsArr.length; i++) {\n    minNum = Math.min(minNum, numsArr[i]);\n  }\n  return minNum;\n};\n\n/*\n  Given an array of integers, find the minimum number of operations required to convert each element to its octal representation\n  Example\n  minOctalOperations([2, 3, 4, 1, 2, 4]) == 4\n  minOctalOperations([-1, -2, -3]) == 4\n  */\nconst minOctalOperations2 = (nums) => {\n  const numsArr = nums.map((num) => num);\n  let minNum = numsArr[0]; // initialize minNum to first element of numsArr\n  for (let i = 1; i < numsArr.length; i++) {\n    minNum = Math.min(minNum, numsArr[i]);\n  }\n  return minNum;\n};\n\n/*\n  Given an array of integers, find the minimum number of operations required to convert each element to its binary representation\n  Example\n  minBinaryOperations([2, 3, 4, 1, 2, 4]) == 4\n  minBinaryOperations([-1, -2, -3]) == 4\n  */\nconst minBinaryOperations3 = (nums) => {\n  const numsArr = nums.map((num) => num);\n  let minNum = numsArr[0]; // initialize minNum to first element of numsArr\n  for (let i = 1; i < numsArr.length; i++) {\n    minNum = Math.min(minNum, numsArr[i]);\n  }\n  return minNum;\n};\n\n/*\n  Given an array of integers, find the minimum number of operations required to convert each element to its decimal representation\n  Example\n  minDecimalOperations([2, 3, 4, 1, 2, 4]) == 4\n  minDecimalOperations([-1, -2, -3]) == 4\n  */\nconst minDecimalOperations3 = (nums) => {\n  const numsArr = nums.map((num) => num);\n  let minNum = numsArr[0]; // initialize minNum to first element of numsArr\n  for (let i = 1; i < numsArr.length; i++) {\n    minNum = Math.min(minNum, numsArr[i]);\n  }\n  return minNum;\n};\n\n/*\n  Given an array of integers, find the minimum number of operations required to convert each element to its hexadecimal representation\n  Example\n  minHexadecimalOperations([2, 3, 4, 1, 2, 4]) == 4\n  minHexadecimalOperations([-1, -2, -3]) == 4\n  */\nconst minHexadecimalOperations3 = (nums) => {\n  const numsArr = nums.map((num) => num);\n  let minNum = numsArr[0]; // initialize minNum to first element of numsArr\n  for (let i = 1; i < numsArr.length; i++) {\n    minNum = Math.min(minNum, numsArr[i]);\n  }\n  return minNum"}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are establish a rectangular grid of well. Each quarrel represent a individual well, \n   and each 1 in a quarrel stage a individual unit of water system. \n   Each well has a corresponding bucket that can be used to distill water from it, \n   and all buckets consume the like capacity.\n   Your task is to practice the bucket to evacuate the wells. \n   end product the number of time you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  You are establish a rectangular grid of well. Each quarrel represent a individual well, \n   and each 1 in a quarrel stage a individual unit of water system. \n   Each well has a corresponding bucket that can be used to distill water from it, \n   and all buckets consume the like capacity.\n   Your task is to practice the bucket to evacuate the wells. \n   end product the number of time you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n    const buckets = grid.map((row, rowIndex) => {\n        const bucket = row.map((col, colIndex) => {\n            return colIndex === 0? 0 : 1;\n        });\n        return bucket;\n    });\n    const bucketsLength = buckets.length;\n    const bucketCapacity = capacity - bucketsLength;\n    const fillBuckets = buckets.map((bucket, bucketIndex) => {\n        const fill = bucket.map((col, colIndex) => {\n            return colIndex === 0? 0 : 1;\n        });\n        return fill;\n    });\n    const fillBucketsLength = fillBuckets.length;\n    const fillBucketCapacity = bucketCapacity - fillBucketsLength;\n    const fillBucketsCapacity = fillBucketCapacity - fillBuckets.length;\n    const fillBucketsCapacityCapacity = fillBucketsCapacity - fillBucketsCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacityCapacity;\n    const fillBucketsCapacityCapacity = fillBucketsCapacityCapacity - fillBucketsCapacity"}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you suffer to classify an array of non - damaging integer according to \n   numeral of ones in their binary theatrical performance in ascending order. \n   For like act of ones, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  In this Kata, you suffer to classify an array of non - damaging integer according to \n   numeral of ones in their binary theatrical performance in ascending order. \n   For like act of ones, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  let sortedArr = [];\n  let sortedArrIndex = 0;\n  let sortedArrLength = 0;\n  let sortedArrValue = 0;\n  let sortedArrValueIndex = 0;\n  let sortedArrValueLength = 0;\n  let sortedArrValueValue = 0;\n  let sortedArrValueValueIndex = 0;\n  let sortedArrValueValueLength = 0;\n  let sortedArrValueValueValue = 0;\n  let sortedArrValueValueValueIndex = 0;\n  let sortedArrValueValueValueLength = 0;\n  let sortedArrValueValueValueValue = 0;\n  let sortedArrValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let sortedArrValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let "}
{"task_id": "JavaScript/117", "prompt": "/*Given a string s and a lifelike issue n, you have been tax to follow through \n   a function that returns a list of all words from bowed stringed instrument s that control precisely \n   n consonants, in order these lyric appear in the string s.\n   If the string s is empty then the function should return an empty list.\n   Note: you may wear the input chain contains only letters and space.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Given a string s and a lifelike issue n, you have been tax to follow through \n   a function that returns a list of all words from bowed stringed instrument s that control precisely \n   n consonants, in order these lyric appear in the string s.\n   If the string s is empty then the function should return an empty list.\n   Note: you may wear the input chain contains only letters and space.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let "}
{"task_id": "JavaScript/118", "prompt": "/*You are establish a word. Your task is to discover the close vowel that stand between \n   two consonants from the right slope of the word (subject sensible). \n  \n   Vowels in the beginning and end doesn't consider. Return empty string if you didn't \n   find oneself any vowel met the above circumstance. \n\n   You may simulate that the given string contains English letter entirely.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*You are establish a word. Your task is to discover the close vowel that stand between \n   two consonants from the right slope of the word (subject sensible). \n  \n   Vowels in the beginning and end doesn't consider. Return empty string if you didn't \n   find oneself any vowel met the above circumstance. \n\n   You may simulate that the given string contains English letter entirely.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowelsArray = vowels.map(v => v.toLowerCase());\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayLength = vowelsArray.length;\n  let "}
{"task_id": "JavaScript/119", "prompt": "/* You are establish a list of two strings, both string dwell of overt \n   parenthesis' (' or cheeseparing parentheses')' merely. \n   Your caper is to match if it is potential to concatenate the two strings in\n   some order, that the resulting string will equal good. \n   A string S is consider to equal good if and only if all parentheses in S \n   exist balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* You are establish a list of two strings, both string dwell of overt \n   parenthesis' (' or cheeseparing parentheses')' merely. \n   Your caper is to match if it is potential to concatenate the two strings in\n   some order, that the resulting string will equal good. \n   A string S is consider to equal good if and only if all parentheses in S \n   exist balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let res = [];\n  let re = new RegExp(`(${lst.join('|')})`, 'g');\n  let match;\n  while ((match = re.exec(lst))!== null) {\n    if (match.index === re.lastIndex) {\n      re.lastIndex++;\n    }\n    res.push(match[0]);\n  }\n  return res.join('') === 'Yes';\n};\n\n/* \n  You are given a string S of parentheses, where each pair of parentheses \n  is surrounded by parentheses. \n  Your goal is to find out whether there is a way to concatenate two \n  strings in some order. \n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  concatParens(['(', ')']) == 'Yes'\n  concatParens([')', ')']) == 'No'\n  */\nconst concatParens = (lst) => {\n  let res = [];\n  let re = new RegExp(`(${lst.join('|')})`, 'g');\n  let match;\n  while ((match = re.exec(lst))!== null) {\n    if (match.index === re.lastIndex) {\n      re.lastIndex++;\n    }\n    res.push(match[0]);\n  }\n  return res.join('') === 'Yes';\n};\n\n/* \n  You are given a string S of parentheses, where each pair of parentheses \n  is surrounded by parentheses. \n  Your goal is to find out whether there is a way to concatenate two \n  strings in some order. \n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  concatParens(['(', ')']) == 'Yes'\n  concatParens([')', ')']) == 'No'\n  */\nconst matchParens2 = (lst, str) => {\n  let res = [];\n  let re = new RegExp(`(${lst.join('|')})`, 'g');\n  let match;\n  while ((match = re.exec(lst))!== null) {\n    if (match.index === re.lastIndex) {\n      re.lastIndex++;\n    }\n    res.push(match[0]);\n  }\n  return res.join('') === str;\n};\n\n/* \n  You are given a string S of parentheses, where each pair of parentheses \n  is surrounded by parentheses. \n  Your goal is to find out whether there is a way to concatenate two \n  strings in some order. \n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  concatParens(['(', ')']) == 'Yes'\n  concatParens([')', ')']) == 'No'\n  */\nconst matchParens3 = (lst, str) => {\n  let res = [];\n  let re = new RegExp(`(${lst.join('|')})`, 'g');\n  let match;\n  while ((match = re.exec(lst))!== null) {\n    if (match.index === re.lastIndex) {\n      re.lastIndex++;\n    }\n    res.push(match[0]);\n  }\n  return res.join('') === str;\n};\n\n/* \n  You are given a string S of parentheses, where each pair of parentheses \n  is surrounded by parentheses. \n  Your goal is to find out whether there is a way to concatenate two \n  strings in some order. \n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  concatParens(['(', ')']) == 'Yes'\n  concatParens([')', ')']) == 'No'\n  */\nconst matchParens4 = (lst) => {\n  let res = [];\n  let re = new RegExp(`(${lst.join('|')})`, 'g');\n  let match;\n  while ((match = re.exec(lst))!== null) {\n    if (match.index === re.lastIndex) {\n      re.lastIndex++;\n    }\n    res.push(match[0]);\n  }\n  return res.join('') === 'Yes';\n};\n\n/* \n  You are given a string S of parentheses, where each pair of parentheses \n  is surrounded by parentheses. \n  Your goal is to find out whether there is a way to concatenate two \n  strings in some order. \n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  concatParens(['(', ')']) == 'Yes'\n  concatParens([')', ')']) == 'No'\n  */\nconst matchParens5 = (lst) => {\n  let res = [];\n  let re = new RegExp(`(${lst.join('|')})`, 'g');\n  let match;\n  while ((match = re.exec(lst))!== null) {\n    if (match.index === re.lastIndex) {\n      re.lastIndex++;\n    }\n    res.push(match[0]);\n  }\n  return res.join('') === 'Yes';\n};\n\n/* \n  You are given a string S of parentheses, where each pair of parentheses \n  is surrounded by parentheses. \n  Your goal is to find out whether there is a way to concatenate two \n  strings in some order. \n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  concatParens(['(', ')']) == 'Yes'\n  concatParens([')', ')']) == 'No'\n  */\nconst matchParens6 = (lst, str) => {\n  let res = [];\n  let re = new RegExp(`(${lst.join('|')})`, 'g');\n  let match;\n  while ((match = re.exec(lst))!== null) {\n    if (match.index === re.lastIndex) {\n      re.lastIndex++;\n    }\n    res.push(match[0]);\n  }\n  return res.join('') === str;\n};\n\n/* \n  You are given a string S of parentheses, where each pair of parentheses \n  is surrounded by parentheses. \n  Your goal is to find out whether there is a way to concatenate two \n  strings in some order. \n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  concatParens(['(', ')']) == 'Yes'\n  concatParens([')', ')']) == 'No'\n  */\nconst matchParens7 = (lst) => {\n  let res = [];\n  let re = new RegExp(`(${lst.join('|')})`, 'g');\n  let match;\n  while ((match = re.exec(lst))!== null) {\n    if (match.index === re.lastIndex) {\n      re.lastIndex++;\n    }\n    res.push(match[0]);\n  }\n  return res.join('') === 'Yes';\n};\n\n/* \n  You are given a string S of parentheses, where each pair of parentheses \n  is surrounded by parentheses. \n  Your goal is to find out whether there is a way to concatenate two \n  strings in some order. \n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  concatParens(['(', ')']) == 'Yes'\n  concatParens([')', ')']) == 'No'\n  */\nconst matchParens8 = (lst) => {\n  let res = [];\n  let re = new RegExp(`(${lst.join('|')})`, 'g');\n  let match;\n  while ((match = re.exec(lst))!== null) {\n    if (match.index === re.lastIndex) {\n      re.lastIndex++;\n    }\n"}
{"task_id": "JavaScript/120", "prompt": "/*\n  establish an array arr of integer and a positive integer k, return a classify list \n   of duration k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  establish an array arr of integer and a positive integer k, return a classify list \n   of duration k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const len = arr.length;\n  let max = 0;\n  let maxIdx = 0;\n  for (let i = 0; i < len; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIdx = i;\n    }\n  }\n  return [arr[maxIdx], maxIdx];\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-a-given-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxSubArraySum = function(nums) {\n  let maxSum = 0;\n  let maxIdx = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > maxSum) {\n      maxSum = nums[i];\n      maxIdx = i;\n    }\n  }\n  return maxSum;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-a-given-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxSubArraySum = function(nums) {\n  let maxSum = 0;\n  let maxIdx = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > maxSum) {\n      maxSum = nums[i];\n      maxIdx = i;\n    }\n  }\n  return maxSum;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-a-given-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxSubArraySum = function(nums) {\n  let maxSum = 0;\n  let maxIdx = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > maxSum) {\n      maxSum = nums[i];\n      maxIdx = i;\n    }\n  }\n  return maxSum;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-a-given-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxSubArraySum = function(nums) {\n  let maxSum = 0;\n  let maxIdx = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > maxSum) {\n      maxSum = nums[i];\n      maxIdx = i;\n    }\n  }\n  return maxSum;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-a-given-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxSubArraySum = function(nums) {\n  let maxSum = 0;\n  let maxIdx = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > maxSum) {\n      maxSum = nums[i];\n      maxIdx = i;\n    }\n  }\n  return maxSum;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-a-given-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxSubArraySum = function(nums) {\n  let maxSum = 0;\n  let maxIdx = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > maxSum) {\n      maxSum = nums[i];\n      maxIdx = i;\n    }\n  }\n  return maxSum;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-a-given-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxSubArraySum = function(nums) {\n  let maxSum = 0;\n  let maxIdx = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > maxSum) {\n      maxSum = nums[i];\n      maxIdx = i;\n    }\n  }\n  return maxSum;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-a-given-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxSubArraySum = function(nums) {\n  let maxSum = 0;\n  let maxIdx = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > maxSum) {\n      maxSum = nums[i];\n      maxIdx = i;\n    }\n  }\n  return maxSum;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-a-given-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxSubArraySum = function(nums) {\n  let maxSum = 0;\n  let maxIdx = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > maxSum) {\n      maxSum = nums[i];\n      maxIdx = i;\n    }\n  }\n  return maxSum;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-a-given-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxSubArraySum = function(nums) {\n  let maxSum = 0;\n  let maxIdx = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > maxSum) {\n      maxSum = nums[i];\n      maxIdx = i;\n    }\n  }\n  return maxSum;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-a-given-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxSubArraySum = function(nums) {\n  let maxSum = 0;\n  let maxIdx = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > maxSum) {\n      maxSum = nums[i];\n      maxIdx = i;\n    }\n  }\n  return maxSum;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-a-given-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxSubArraySum = function(nums) {\n  let maxSum = 0;\n  let maxIdx = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > maxSum) {\n      maxSum = nums[i];\n      maxIdx = i;\n    }\n  }\n  return maxSum;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-a-given-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxSubArraySum = function(nums) {\n  let maxSum = 0;\n  let maxIdx = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > maxSum) {\n      maxSum = nums[i];\n      maxIdx = i;\n    }\n  }\n  return maxSum;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-a-given-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxSubArraySum = function(nums) {\n  let maxSum = 0;\n  let maxIdx = 0;\n  for (let i = 0; i < num"}
{"task_id": "JavaScript/121", "prompt": "/*Given a non - empty list of integer, return the kernel of all of the curious chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Given a non - empty list of integer, return the kernel of all of the curious chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      res = res + lst[i];\n    }\n  }\n  return res;\n};\n\n/*Given a non - empty list of integer, return the kernel of all of the curious chemical element that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solutionOdd = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      res = res + lst[i];\n    }\n  }\n  return res;\n};\n\n/*Given a non - empty list of integer, return the kernel of all of the curious chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solutionEven = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      res = res + lst[i];\n    }\n  }\n  return res;\n};\n\n/*Given a non - empty list of integer, return the kernel of all of the curious chemical element that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solutionOddEven = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      res = res + lst[i];\n    }\n  }\n  return res;\n};\n\n/*Given a non - empty list of integer, return the kernel of all of the curious chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solutionOddEvenEven = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      res = res + lst[i];\n    }\n  }\n  return res;\n};\n\n/*Given a non - empty list of integer, return the kernel of all of the curious chemical element that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solutionOddEvenEvenEven = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      res = res + lst[i];\n    }\n  }\n  return res;\n};\n\n/*Given a non - empty list of integer, return the kernel of all of the curious chemical element that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solutionOddEvenEvenEvenEvenEven = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      res = res + lst[i];\n    }\n  }\n  return res;\n};\n\n/*Given a non - empty list of integer, return the kernel of all of the curious chemical element that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solutionOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEven"}
{"task_id": "JavaScript/122", "prompt": "/*\n  establish a non - empty array of integer arr and an integer k, return\n   the sum of the elements with at most two digit from the inaugural k element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  establish a non - empty array of integer arr and an integer k, return\n   the sum of the elements with at most two digit from the inaugural k element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let arrSum = 0;\n  let arrLen = arr.length;\n  let arrIndex = 0;\n  let arrTemp = [];\n  while (arrIndex < arrLen) {\n    let arrElem = arr[arrIndex];\n    if (arrElem % 10 === 0) {\n      arrTemp.push(arrElem);\n    }\n    if (arrElem % 10 === 1) {\n      arrSum = arrSum + arrElem;\n    }\n    arrIndex++;\n  }\n  return arrSum;\n};\n\n/*\n  establish a non - empty array of integer arr and an integer k, return\n   the sum of the elements with at most three digit from the inaugural k element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 36 # sum of 31 + 4\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let arrSum = 0;\n  let arrLen = arr.length;\n  let arrIndex = 0;\n  let arrTemp = [];\n  while (arrIndex < arrLen) {\n    let arrElem = arr[arrIndex];\n    if (arrElem % 10 === 0) {\n      arrTemp.push(arrElem);\n    }\n    if (arrElem % 10 === 1) {\n      arrSum = arrSum + arrElem;\n    }\n    if (arrElem % 10 === 2) {\n      arrSum = arrSum + arrElem;\n    }\n    arrIndex++;\n  }\n  return arrSum;\n};\n\n/*\n  establish a non - empty array of integer arr and an integer k, return\n   the sum of the elements with at most four digit from the inaugural k element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 56 # sum of 51 + 6\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let arrSum = 0;\n  let arrLen = arr.length;\n  let arrIndex = 0;\n  let arrTemp = [];\n  while (arrIndex < arrLen) {\n    let arrElem = arr[arrIndex];\n    if (arrElem % 10 === 0) {\n      arrTemp.push(arrElem);\n    }\n    if (arrElem % 10 === 1) {\n      arrSum = arrSum + arrElem;\n    }\n    if (arrElem % 10 === 2) {\n      arrSum = arrSum + arrElem;\n    }\n    if (arrElem % 10 === 3) {\n      arrSum = arrSum + arrElem;\n    }\n    arrIndex++;\n  }\n  return arrSum;\n};\n\n/*\n  establish a non - empty array of integer arr and an integer k, return\n   the sum of the elements with at most five digit from the inaugural k element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 71 # sum of 71 + 8\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let arrSum = 0;\n  let arrLen = arr.length;\n  let arrIndex = 0;\n  let arrTemp = [];\n  while (arrIndex < arrLen) {\n    let arrElem = arr[arrIndex];\n    if (arrElem % 10 === 0) {\n      arrTemp.push(arrElem);\n    }\n    if (arrElem % 10 === 1) {\n      arrSum = arrSum + arrElem;\n    }\n    if (arrElem % 10 === 2) {\n      arrSum = arrSum + arrElem;\n    }\n    if (arrElem % 10 === 3) {\n      arrSum = arrSum + arrElem;\n    }\n    if (arrElem % 10 === 4) {\n      arrSum = arrSum + arrElem;\n    }\n    arrIndex++;\n  }\n  return arrSum;\n};\n\n/*\n  establish a non - empty array of integer arr and an integer k, return\n   the sum of the elements with at most six digit from the inaugural k element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 101 # sum of 101 + 11\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let arrSum = 0;\n  let arrLen = arr.length;\n  let arrIndex = 0;\n  let arrTemp = [];\n  while (arrIndex < arrLen) {\n    let arrElem = arr[arrIndex];\n    if (arrElem % 10 === 0) {\n      arrTemp.push(arrElem);\n    }\n    if (arrElem % 10 === 1) {\n      arrSum = arrSum + arrElem;\n    }\n    if (arrElem % 10 === 2) {\n      arrSum = arrSum + arrElem;\n    }\n    if (arrElem % 10 === 3) {\n      arrSum = arrSum + arrElem;\n    }\n    if (arrElem % 10 === 4) {\n      arrSum = arrSum + arrElem;\n    }\n    if (arrElem % 10 === 5) {\n      arrSum = arrSum + arrElem;\n    }\n    arrIndex++;\n  }\n  return arrSum;\n};\n\n/*\n  establish a non - empty array of integer arr and an integer k, return\n   the sum of the elements with at most seven digit from the inaugural k element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 151 # sum of 151 + 16\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let arrSum = 0;\n  let arrLen = arr.length;\n  let arrIndex = 0;\n  let arrTemp = [];\n  while (arrIndex < arrLen) {\n    let arrElem = arr[arrIndex];\n    if (arrElem % 10 === 0) {\n      arrTemp.push(arrElem);\n    }\n    if (arrElem % 10 === 1) {\n      arrSum = arrSum + arrElem;\n    }\n    if (arrElem % 10 === 2) {\n      arrSum = arrSum + arrElem;\n    }\n    if (arrElem % 10 === 3) {\n      arrSum = arrSum + arrElem;\n    }\n    if (arrElem % 10 === 4) {\n      arrSum = arrSum + arrElem;\n    }\n    if (arrElem % 10 === 5) {\n      arrSum = arrSum + arrElem;\n    }\n    if (arrElem % 10 === 6) {\n      arrSum = arrSum + arrElem;\n    }\n    arrIndex++;\n  }\n  return arrSum;\n};\n\n/*\n  establish a non - empty array of integer arr and an integer k, return\n   the sum of the elements with at most eight digit from the inaugural k element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,"}
{"task_id": "JavaScript/123", "prompt": "/*\n  establish a positive integer n, return a sorted list that have the leftover numbers in collatz sequence. \n\n   The Collatz speculation is a speculation in mathematics that concerns a sequence define \n   as follow: start with any positive integer n. Then each term is obtained from the \n   previous term as take after: if the previous terminus is even, the following condition is one half of \n   the former condition. If the previous term be leftover, the adjacent condition is 3 time the previous \n   condition plus 1. The speculation is that no matter what value of n, the sequence will always achieve 1. \n\n   eminence: \n       1. Collatz(1) is [ 1 ]. \n       2. return list classify in increase order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  establish a positive integer n, return a sorted list that have the leftover numbers in collatz sequence. \n\n   The Collatz speculation is a speculation in mathematics that concerns a sequence define \n   as follow: start with any positive integer n. Then each term is obtained from the \n   previous term as take after: if the previous terminus is even, the following condition is one half of \n   the former condition. If the previous term be leftover, the adjacent condition is 3 time the previous \n   condition plus 1. The speculation is that no matter what value of n, the sequence will always achieve 1. \n\n   eminence: \n       1. Collatz(1) is [ 1 ]. \n       2. return list classify in increase order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let collatz = [1, 1];\n  let count = 0;\n  while (count < n) {\n    collatz = [...collatz,...collatz.slice(0, -1)];\n    count++;\n  }\n  return collatz;\n};\n\n/*\n  establish a positive integer n, return a sorted list that have the leftover numbers in collatz sequence. \n\n   The Collatz speculation is a speculation in mathematics that concerns a sequence define \n   as follow: start with any positive integer n. Then each term is obtained from the \n   previous term as take after: if the previous terminus is even, the following condition is one half of \n   the former condition. If the previous term be leftover, the adjacent condition is 3 time the previous \n   condition plus 1. The speculation is that no matter what value of n, the sequence will always achieve 1. \n\n   eminence: \n       1. Collatz(1) is [ 1 ]. \n       2. return list classify in decrease order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  let collatz = [1, 1];\n  let count = 0;\n  while (count < n) {\n    collatz = [...collatz,...collatz.slice(0, -1)];\n    count++;\n  }\n  return collatz;\n};\n\n/*\n  establish a positive integer n, return a sorted list that have the leftover numbers in collatz sequence. \n\n   The Collatz speculation is a speculation in mathematics that concerns a sequence define \n   as follow: start with any positive integer n. Then each term is obtained from the \n   previous term as take after: if the previous terminus is even, the following condition is one half of \n   the former condition. If the previous term be leftover, the adjacent condition is 3 time the previous \n   condition plus 1. The speculation is that no matter what value of n, the sequence will always achieve 1. \n\n   eminence: \n       1. Collatz(1) is [ 1 ]. \n       2. return list classify in decrease order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let collatz = [1, 1];\n  let count = 0;\n  while (count < n) {\n    collatz = [...collatz,...collatz.slice(0, -1)];\n    count++;\n  }\n  return collatz;\n};\n\n/*\n  establish a positive integer n, return a sorted list that have the leftover numbers in collatz sequence. \n\n   The Collatz speculation is a speculation in mathematics that concerns a sequence define \n   as follow: start with any positive integer n. Then each term is obtained from the \n   previous term as take after: if the previous terminus is even, the following condition is one half of \n   the former condition. If the previous term be leftover, the adjacent condition is 3 time the previous \n   condition plus 1. The speculation is that no matter what value of n, the sequence will always achieve 1. \n\n   eminence: \n       1. Collatz(1) is [ 1 ]. \n       2. return list classify in decrease order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  let collatz = [1, 1];\n  let count = 0;\n  while (count < n) {\n    collatz = [...collatz,...collatz.slice(0, -1)];\n    count++;\n  }\n  return collatz;\n};\n\n/*\n  establish a positive integer n, return a sorted list that have the leftover numbers in collatz sequence. \n\n   The Collatz speculation is a speculation in mathematics that concerns a sequence define \n   as follow: start with any positive integer n. Then each term is obtained from the \n   previous term as take after: if the previous terminus is even, the following condition is one half of \n   the former condition. If the previous term be leftover, the adjacent condition is 3 time the previous \n   condition plus 1. The speculation is that no matter what value of n, the sequence will always achieve 1. \n\n   eminence: \n       1. Collatz(1) is [ 1 ]. \n       2. return list classify in decrease order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let collatz = [1, 1];\n  let count = 0;\n  while (count < n) {\n    collatz = [...collatz,...collatz.slice(0, -1)];\n    count++;\n  }\n  return collatz;\n};\n\n/*\n  establish a positive integer n, return a sorted list that have the leftover numbers in collatz sequence. \n\n   The Collatz speculation is a speculation in mathematics that concerns a sequence define \n   as follow: start with any positive integer n. Then each term is obtained from the \n   previous term as take after: if the previous terminus is even, the following condition is one half of \n   the former condition. If the previous term be leftover, the adjacent condition is 3 time the previous \n   condition plus 1. The speculation is that no matter what value of n, the sequence will always achieve 1. \n\n   eminence: \n       1. Collatz(1) is [ 1 ]. \n       2. return list classify in decrease order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  let collatz = [1, 1];\n  let count = 0;\n  while (count < n) {\n    collatz = [...collatz,...collatz.slice(0, -1)];\n    count++;\n  }\n  return collatz;\n};\n\n/*\n  establish a positive integer n, return a sorted list that have the leftover numbers in collatz sequence. \n\n   The Collatz speculation is a speculation"}
{"task_id": "JavaScript/124", "prompt": "/*You suffer to compose a affair which validate a give date string and \n   returns truthful if the date be valid otherwise false. \n   The date is valid if all of the follow rules are satisfied: \n   1. The date drawstring is not empty. \n   2. The number of day is not less than 1 or higher than 31 day for months 1,3,5,7,8,10,12. And the issue of days is not less than 1 or higher than 30 days for month 4,6,9,11. And, the number of days is not less than 1 or eminent than 29 for the calendar month 2. \n   3. The month should not cost less than 1 or high than 12. \n   4. The date should constitute in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*You suffer to compose a affair which validate a give date string and \n   returns truthful if the date be valid otherwise false. \n   The date is valid if all of the follow rules are satisfied: \n   1. The date drawstring is not empty. \n   2. The number of day is not less than 1 or higher than 31 day for months 1,3,5,7,8,10,12. And the issue of days is not less than 1 or higher than 30 days for month 4,6,9,11. And, the number of days is not less than 1 or eminent than 29 for the calendar month 2. \n   3. The month should not cost less than 1 or high than 12. \n   4. The date should constitute in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const reg = /^(\\d{1,2})[-\\/](\\d{1,2})[-\\/](\\d{4})$/;\n  const reg2 = /^(\\d{1,2})[-\\/](\\d{1,2})[-\\/](\\d{4})[-\\/](\\d{1,2})$/;\n  const reg3 = /^(\\d{1,2})[-\\/](\\d{1,2})[-\\/](\\d{4})$/;\n  const reg4 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg5 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg6 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg7 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg8 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg9 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg10 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg11 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg12 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg13 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg14 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg15 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg16 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg17 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg18 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg19 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg20 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg21 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg22 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg23 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg24 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg25 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg26 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg27 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg28 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg29 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg30 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg31 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg32 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg33 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg34 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg35 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg36 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg37 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg38 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg39 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg40 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg41 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg42 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg43 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg44 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg45 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg46 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg47 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg48 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg49 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg50 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg51 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg52 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg53 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg54 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg55 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg56 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg57 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg58 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg59 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg60 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg61 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg62 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg63 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg64 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg65 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg66 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg67 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg68 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg69 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg70 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg71 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg72 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg73 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg74 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg75 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg76 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg77 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg78 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg79 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg80 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg81 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg82 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg83 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg84 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg85 = /^(\\d{1,2})[-\\/](\\d{1,2})$/;\n  const reg86 = /^(\\d{1,2})"}
{"task_id": "JavaScript/125", "prompt": "/* establish a string of news, return a list of lyric burst on whitespace, if no whitespaces exist in the text you \n   should burst on comma',' if no commas exist you should return the act of lower - case letters with leftover order in the \n   alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* establish a string of news, return a list of lyric burst on whitespace, if no whitespaces exist in the text you \n   should burst on comma',' if no commas exist you should return the act of lower - case letters with leftover order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  let words = txt.split(' ');\n  let news = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;"}
{"task_id": "JavaScript/126", "prompt": "/* establish a list of numbers, return whether or not they are classify \n   in ascend holy order. If list take more than 1 extra of the same \n   act, return false. Assume no minus numbers pool and only integers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* establish a list of numbers, return whether or not they are classify \n   in ascend holy order. If list take more than 1 extra of the same \n   act, return false. Assume no minus numbers pool and only integers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  let isSorted = true\n  let num = 0\n  let nums = []\n  let numsCopy = []\n  let numsCopy2 = []\n  let numsCopy3 = []\n  let numsCopy4 = []\n  let numsCopy5 = []\n  let numsCopy6 = []\n  let numsCopy7 = []\n  let numsCopy8 = []\n  let numsCopy9 = []\n  let numsCopy10 = []\n  let numsCopy11 = []\n  let numsCopy12 = []\n  let numsCopy13 = []\n  let numsCopy14 = []\n  let numsCopy15 = []\n  let numsCopy16 = []\n  let numsCopy17 = []\n  let numsCopy18 = []\n  let numsCopy19 = []\n  let numsCopy20 = []\n  let numsCopy21 = []\n  let numsCopy22 = []\n  let numsCopy23 = []\n  let numsCopy24 = []\n  let numsCopy25 = []\n  let numsCopy26 = []\n  let numsCopy27 = []\n  let numsCopy28 = []\n  let numsCopy29 = []\n  let numsCopy30 = []\n  let numsCopy31 = []\n  let numsCopy32 = []\n  let numsCopy33 = []\n  let numsCopy34 = []\n  let numsCopy35 = []\n  let numsCopy36 = []\n  let numsCopy37 = []\n  let numsCopy38 = []\n  let numsCopy39 = []\n  let numsCopy40 = []\n  let numsCopy41 = []\n  let numsCopy42 = []\n  let numsCopy43 = []\n  let numsCopy44 = []\n  let numsCopy45 = []\n  let numsCopy46 = []\n  let numsCopy47 = []\n  let numsCopy48 = []\n  let numsCopy49 = []\n  let numsCopy50 = []\n  let numsCopy51 = []\n  let numsCopy52 = []\n  let numsCopy53 = []\n  let numsCopy54 = []\n  let numsCopy55 = []\n  let numsCopy56 = []\n  let numsCopy57 = []\n  let numsCopy58 = []\n  let numsCopy59 = []\n  let numsCopy60 = []\n  let numsCopy61 = []\n  let numsCopy62 = []\n  let numsCopy63 = []\n  let numsCopy64 = []\n  let numsCopy65 = []\n  let numsCopy66 = []\n  let numsCopy67 = []\n  let numsCopy68 = []\n  let numsCopy69 = []\n  let numsCopy70 = []\n  let numsCopy71 = []\n  let numsCopy72 = []\n  let numsCopy73 = []\n  let numsCopy74 = []\n  let numsCopy75 = []\n  let numsCopy76 = []\n  let numsCopy77 = []\n  let numsCopy78 = []\n  let numsCopy79 = []\n  let numsCopy80 = []\n  let numsCopy81 = []\n  let numsCopy82 = []\n  let numsCopy83 = []\n  let numsCopy84 = []\n  let numsCopy85 = []\n  let numsCopy86 = []\n  let numsCopy87 = []\n  let numsCopy88 = []\n  let numsCopy89 = []\n  let numsCopy90 = []\n  let numsCopy91 = []\n  let numsCopy92 = []\n  let numsCopy93 = []\n  let numsCopy94 = []\n  let numsCopy95 = []\n  let numsCopy96 = []\n  let numsCopy97 = []\n  let numsCopy98 = []\n  let numsCopy99 = []\n  let numsCopy100 = []\n  let numsCopy101 = []\n  let numsCopy102 = []\n  let numsCopy103 = []\n  let numsCopy104 = []\n  let numsCopy105 = []\n  let numsCopy106 = []\n  let numsCopy107 = []\n  let numsCopy108 = []\n  let numsCopy109 = []\n  let numsCopy110 = []\n  let numsCopy111 = []\n  let numsCopy112 = []\n  let numsCopy113 = []\n  let numsCopy114 = []\n  let numsCopy115 = []\n  let numsCopy116 = []\n  let numsCopy117 = []\n  let numsCopy118 = []\n  let numsCopy119 = []\n  let numsCopy120 = []\n  let numsCopy121 = []\n  let numsCopy122 = []\n  let numsCopy123 = []\n  let numsCopy124 = []\n  let numsCopy125 = []\n  let numsCopy126 = []\n  let numsCopy127 = []\n  let numsCopy128 = []\n  let numsCopy129 = []\n  let numsCopy130 = []\n  let numsCopy131 = []\n  let numsCopy132 = []\n  let numsCopy133 = []\n  let numsCopy134 = []\n  let numsCopy135 = []\n  let numsCopy136 = []\n  let numsCopy137 = []\n  let numsCopy138 = []\n  let numsCopy139 = []\n  let numsCopy140 = []\n  let numsCopy141 = []\n  let numsCopy142 = []\n  let numsCopy143 = []\n  let numsCopy144 = []\n  let numsCopy145 = []\n  let numsCopy146 = []\n  let numsCopy147 = []\n  let numsCopy148 = []\n  let numsCopy149 = []\n  let numsCopy150 = []\n  let numsCopy151 = []\n  let numsCopy152 = []\n  let numsCopy153 = []\n  let numsCopy154 = []\n  let numsCopy155 = []\n  let numsCopy156 = []\n  let numsCopy157 = []\n  let numsCopy158 = []\n  let numsCopy159 = []\n  let numsCopy160 = []\n  let numsCopy161 = []\n  let numsCopy162 = []\n  let numsCopy163 = []\n  let numsCopy164 = []\n  let numsCopy165 = []\n  let numsCopy166 = []\n  let numsCopy167 = []\n  let numsCopy168 = []\n  let numsCopy169 = []\n  let numsCopy170 = []\n  let numsCopy171 = []\n  let numsCopy172 = []\n  let numsCopy173 = []\n  let numsCopy174 = []\n  let numsCopy175 = []\n  let numsCopy176 = []\n  let numsCopy177 = []\n  let numsCopy178 = []\n  let numsCopy179 = []\n  let numsCopy180 = []\n  let numsCopy181 = []\n  let numsCopy182 = []\n  let numsCopy183 = []\n  let numsCopy184 = []\n  let numsCopy185 = []\n  let numsCopy186 = []\n  let numsCopy187"}
{"task_id": "JavaScript/127", "prompt": "/*You are establish two intervals, \n   where each interval be a couple of integer. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*You are establish two intervals, \n   where each interval be a couple of integer. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  let [start1, end1] = interval1;\n  let [start2, end2] = interval2;\n  let [start3, end3] = interval1;\n  let [start4, end4] = interval2;\n  let [start5, end5] = interval1;\n  let [start6, end6] = interval2;\n  let [start7, end7] = interval1;\n  let [start8, end8] = interval2;\n  let [start9, end9] = interval1;\n  let [start10, end10] = interval2;\n  let [start11, end11] = interval1;\n  let [start12, end12] = interval2;\n  let [start13, end13] = interval1;\n  let [start14, end14] = interval2;\n  let [start15, end15] = interval1;\n  let [start16, end16] = interval2;\n  let [start17, end17] = interval1;\n  let [start18, end18] = interval2;\n  let [start19, end19] = interval1;\n  let [start20, end20] = interval2;\n  let [start21, end21] = interval1;\n  let [start22, end22] = interval2;\n  let [start23, end23] = interval1;\n  let [start24, end24] = interval2;\n  let [start25, end25] = interval1;\n  let [start26, end26] = interval2;\n  let [start27, end27] = interval1;\n  let [start28, end28] = interval2;\n  let [start29, end29] = interval1;\n  let [start30, end30] = interval2;\n  let [start31, end31] = interval1;\n  let [start32, end32] = interval2;\n  let [start33, end33] = interval1;\n  let [start34, end34] = interval2;\n  let [start35, end35] = interval1;\n  let [start36, end36] = interval2;\n  let [start37, end37] = interval1;\n  let [start38, end38] = interval2;\n  let [start39, end39] = interval1;\n  let [start40, end40] = interval2;\n  let [start41, end41] = interval1;\n  let [start42, end42] = interval2;\n  let [start43, end43] = interval1;\n  let [start44, end44] = interval2;\n  let [start45, end45] = interval1;\n  let [start46, end46] = interval2;\n  let [start47, end47] = interval1;\n  let [start48, end48] = interval2;\n  let [start49, end49] = interval1;\n  let [start50, end50] = interval2;\n  let [start51, end51] = interval1;\n  let [start52, end52] = interval2;\n  let [start53, end53] = interval1;\n  let [start54, end54] = interval2;\n  let [start55, end55] = interval1;\n  let [start56, end56] = interval2;\n  let [start57, end57] = interval1;\n  let [start58, end58] = interval2;\n  let [start59, end59] = interval1;\n  let [start60, end60] = interval2;\n  let [start61, end61] = interval1;\n  let [start62, end62] = interval2;\n  let [start63, end63] = interval1;\n  let [start64, end64] = interval2;\n  let [start65, end65] = interval1;\n  let [start66, end66] = interval2;\n  let [start67, end67] = interval1;\n  let [start68, end68] = interval2;\n  let [start69, end69] = interval1;\n  let [start70, end70] = interval2;\n  let [start71, end71] = interval1;\n  let [start72, end72] = interval2;\n  let [start73, end73] = interval1;\n  let [start74, end74] = interval2;\n  let [start75, end75] = interval1;\n  let [start76, end76] = interval2;\n  let [start77, end77] = interval1;\n  let [start78, end78] = interval2;\n  let [start79, end79] = interval1;\n  let [start80, end80] = interval2;\n  let [start81, end81] = interval1;\n  let [start82, end82] = interval2;\n  let [start83, end83] = interval1;\n  let [start84, end84] = interval2;\n  let [start85, end85] = interval1;\n  let [start86, end86] = interval2;\n  let [start87, end87] = interval1;\n  let [start88, end88] = interval2;\n  let [start89, end89] = interval1;\n  let [start90, end90] = interval2;\n  let [start91, end91] = interval1;\n  let [start92, end92] = interval2;\n  let [start93, end93] = interval1;\n  let [start94, end94] = interval2;\n  let [start95, end95] = interval1;\n  let [start96, end96] = interval2;\n  let [start97, end97] = interval1;\n  let [start98, end98] = interval2;\n  let [start99, end99] = interval1;\n  let [start100, end100] = interval2;\n  let [start101, end101] = interval1;\n  let [start102, end102] = interval2;\n  let [start103, end103] = interval1;\n  let [start104, end104] = interval2;\n  let [start105, end105] = interval1;\n  let [start106, end106] = interval2;\n  let [start107, end107] = interval1;\n  let [start108, end108] = interval2;\n  let [start109, end109] = interval1;\n  let [start110, end110] = interval2;\n  let [start111, end111] = interval1;\n  let [start112, end112] = interval2;\n  let [start113, end113] = interval1;\n  let [start114, end114] = interval2;\n  let [start115, end115] = interval1;\n  let [start116, end116] = interval2;\n  let [start117, end117] = interval1;\n  let [start118, end118] = interval2;\n  let [start119, end119] = interval1;\n  let [start120, end120] = interval2;\n  let [start121, end121] = interval1;\n  let [start122, end122] = interval2;\n  let [start123, end123] = interval1;\n  let [start124, end124] = interval2;\n  let [start125, end125] = interval1;\n  let [start126, end126] = interval2;\n  let [start127, end127] = interval1;\n  let [start128, end128] = interval2;\n  let [start129, end129] = interval1;\n  let "}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are establish an array arr of integer and you need to return\n   union of order of magnitude of integers multiplied by product of all sign of the zodiac \n   of each numeral in the array, represented by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  You are establish an array arr of integer and you need to return\n   union of order of magnitude of integers multiplied by product of all sign of the zodiac \n   of each numeral in the array, represented by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  let sign = 0;\n  let signs = [];\n  let signsLength = 0;\n  let signsIndex = 0;\n  let signsLengthIndex = 0;\n  let signsIndexLength = 0;\n  let signsIndexLengthIndex = 0;\n  let signsIndexLengthIndex2 = 0;\n  let signsIndexLengthIndex2 = 0;\n  let signsIndexLengthIndex3 = 0;\n  let signsIndexLengthIndex3 = 0;\n  let signsIndexLengthIndex4 = 0;\n  let signsIndexLengthIndex4 = 0;\n  let signsIndexLengthIndex5 = 0;\n  let signsIndexLengthIndex5 = 0;\n  let signsIndexLengthIndex6 = 0;\n  let signsIndexLengthIndex6 = 0;\n  let signsIndexLengthIndex7 = 0;\n  let signsIndexLengthIndex7 = 0;\n  let signsIndexLengthIndex8 = 0;\n  let signsIndexLengthIndex8 = 0;\n  let signsIndexLengthIndex9 = 0;\n  let signsIndexLengthIndex9 = 0;\n  let signsIndexLengthIndex10 = 0;\n  let signsIndexLengthIndex10 = 0;\n  let signsIndexLengthIndex11 = 0;\n  let signsIndexLengthIndex11 = 0;\n  let signsIndexLengthIndex12 = 0;\n  let signsIndexLengthIndex12 = 0;\n  let signsIndexLengthIndex13 = 0;\n  let signsIndexLengthIndex13 = 0;\n  let signsIndexLengthIndex14 = 0;\n  let signsIndexLengthIndex14 = 0;\n  let signsIndexLengthIndex15 = 0;\n  let signsIndexLengthIndex15 = 0;\n  let signsIndexLengthIndex16 = 0;\n  let signsIndexLengthIndex16 = 0;\n  let signsIndexLengthIndex17 = 0;\n  let signsIndexLengthIndex17 = 0;\n  let signsIndexLengthIndex18 = 0;\n  let signsIndexLengthIndex18 = 0;\n  let signsIndexLengthIndex19 = 0;\n  let signsIndexLengthIndex19 = 0;\n  let signsIndexLengthIndex20 = 0;\n  let signsIndexLengthIndex20 = 0;\n  let signsIndexLengthIndex21 = 0;\n  let signsIndexLengthIndex21 = 0;\n  let signsIndexLengthIndex22 = 0;\n  let signsIndexLengthIndex22 = 0;\n  let signsIndexLengthIndex23 = 0;\n  let signsIndexLengthIndex23 = 0;\n  let signsIndexLengthIndex24 = 0;\n  let signsIndexLengthIndex24 = 0;\n  let signsIndexLengthIndex25 = 0;\n  let signsIndexLengthIndex25 = 0;\n  let signsIndexLengthIndex26 = 0;\n  let signsIndexLengthIndex26 = 0;\n  let signsIndexLengthIndex27 = 0;\n  let signsIndexLengthIndex27 = 0;\n  let signsIndexLengthIndex28 = 0;\n  let signsIndexLengthIndex28 = 0;\n  let signsIndexLengthIndex29 = 0;\n  let signsIndexLengthIndex29 = 0;\n  let signsIndexLengthIndex30 = 0;\n  let signsIndexLengthIndex30 = 0;\n  let signsIndexLengthIndex31 = 0;\n  let signsIndexLengthIndex31 = 0;\n  let signsIndexLengthIndex32 = 0;\n  let signsIndexLengthIndex32 = 0;\n  let signsIndexLengthIndex33 = 0;\n  let signsIndexLengthIndex33 = 0;\n  let signsIndexLengthIndex34 = 0;\n  let signsIndexLengthIndex34 = 0;\n  let signsIndexLengthIndex35 = 0;\n  let signsIndexLengthIndex35 = 0;\n  let signsIndexLengthIndex36 = 0;\n  let signsIndexLengthIndex36 = 0;\n  let signsIndexLengthIndex37 = 0;\n  let signsIndexLengthIndex37 = 0;\n  let signsIndexLengthIndex38 = 0;\n  let signsIndexLengthIndex38 = 0;\n  let signsIndexLengthIndex39 = 0;\n  let signsIndexLengthIndex39 = 0;\n  let signsIndexLengthIndex40 = 0;\n  let signsIndexLengthIndex40 = 0;\n  let signsIndexLengthIndex41 = 0;\n  let signsIndexLengthIndex41 = 0;\n  let signsIndexLengthIndex42 = 0;\n  let signsIndexLengthIndex42 = 0;\n  let signsIndexLengthIndex43 = 0;\n  let signsIndexLengthIndex43 = 0;\n  let signsIndexLengthIndex44 = 0;\n  let signsIndexLengthIndex44 = 0;\n  let signsIndexLengthIndex45 = 0;\n  let signsIndexLengthIndex45 = 0;\n  let signsIndexLengthIndex46 = 0;\n  let signsIndexLengthIndex46 = 0;\n  let signsIndexLengthIndex47 = 0;\n  let signsIndexLengthIndex47 = 0;\n  let signsIndexLengthIndex48 = 0;\n  let signsIndexLengthIndex48 = 0;\n  let signsIndexLengthIndex49 = 0;\n  let signsIndexLengthIndex49 = 0;\n  let signsIndexLengthIndex50 = 0;\n  let signsIndexLengthIndex50 = 0;\n  let signsIndexLengthIndex51 = 0;\n  let signsIndexLengthIndex51 = 0;\n  let signsIndexLengthIndex52 = 0;\n  let signsIndexLengthIndex52 = 0;\n  let signsIndexLengthIndex53 = 0;\n  let signsIndexLengthIndex53 = 0;\n  let signsIndexLengthIndex54 = 0;\n  let signsIndexLengthIndex54 = 0;\n  let signsIndexLengthIndex55 = 0;\n  let signsIndexLengthIndex55 = 0;\n  let signsIndexLengthIndex56 = 0;\n  let signsIndexLengthIndex56 = 0;\n  let signsIndexLengthIndex57 = 0;\n  let signsIndexLengthIndex57 = 0;\n  let signsIndexLengthIndex58 = 0;\n  let signsIndexLengthIndex58 = 0;\n  let signsIndexLengthIndex59 = 0;\n  let signsIndexLengthIndex59 = 0;\n  let signsIndexLengthIndex60 = 0;\n  let signsIndexLengthIndex60 = 0;\n  let signsIndexLengthIndex61 = 0;\n  let signsIndexLengthIndex61 = 0;\n  let signsIndexLengthIndex62 = 0;\n  let signsIndexLengthIndex62 = 0;\n  let signsIndexLengthIndex63 = 0;\n  let signsIndexLengthIndex63 = 0;\n  let signsIndexLengthIndex64 = 0;\n  let signsIndexLengthIndex64 = 0;\n  let signsIndexLengthIndex65 = 0;\n  let signsIndexLengthIndex65 = 0;\n  let signsIndexLengthIndex66 = 0;\n  let signsIndexLengthIndex66 = 0;\n  let signsIndexLengthIndex67 = 0;\n  let signsIndexLengthIndex67 = 0;\n  let signsIndexLengthIndex68 = 0;\n  let signsIndexLengthIndex68 = 0;\n  let signsIndexLengthIndex69 = 0;\n  let signsIndexLengthIndex69 = 0;\n  let signsIndexLengthIndex70 = 0;\n  let signsIndexLengthIndex70 = 0;\n  let signsIndexLengthIndex71 = 0;\n  let signsIndexLengthIndex71 = 0;\n  let signsIndexLengthIndex72 = 0;\n  let signsIndexLengthIndex72 = 0;\n  let signsIndexLengthIndex73 = 0;\n  let signsIndexLengthIndex73 = 0;\n  let signsIndexLengthIndex74 = 0;\n  let signsIndexLengthIndex74 = 0;\n  let signsIndexLengthIndex75 = 0;\n  let signsIndexLengthIndex75 = 0;\n  let signsIndexLengthIndex76 = 0;\n  let signsIndexLengthIndex76 = 0;\n  let signsIndexLengthIndex77 = 0;\n  let signsIndexLengthIndex77 = 0;\n  let signsIndexLengthIndex78 = 0;\n  let signsIndexLengthIndex78 = 0;\n  let signsIndexLengthIndex79 = 0;\n  let signsIndexLengthIndex79 = 0;\n"}
{"task_id": "JavaScript/129", "prompt": "/*\n  establish a grid with N rows and N column (N > = 2) and a convinced integer k, \n   each cellular telephone of the grid contains a value. Every integer in the scope [ 1, N * N ] \n   inclusive appears precisely once on the cell of the grid.\n\n   You experience to find the minimum path of distance k in the grid. You can start \n   from any cell, and in each footprint you can be active to any of the neighbor cell, \n   in other word, you can go to cellular telephone which share an boundary with you current \n   cell. \n   Please note that a way of distance k mean visit precisely k cell (not \n   inevitably distinct). \n   You CANNOT go off the grid.\n   A way A (of length k) is considered less than a path bacillus (of distance k) if \n   after making the order tilt of the value on the cells that A and B go \n   through (permit's call them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in early words, there exist an integer index i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we hold \n   lst_A[j ] = lst_B[j ]. \n   It is guarantee that the solution is unique. \n   Return an ordered list of the values on the cell that the minimal path function through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  establish a grid with N rows and N column (N > = 2) and a convinced integer k, \n   each cellular telephone of the grid contains a value. Every integer in the scope [ 1, N * N ] \n   inclusive appears precisely once on the cell of the grid.\n\n   You experience to find the minimum path of distance k in the grid. You can start \n   from any cell, and in each footprint you can be active to any of the neighbor cell, \n   in other word, you can go to cellular telephone which share an boundary with you current \n   cell. \n   Please note that a way of distance k mean visit precisely k cell (not \n   inevitably distinct). \n   You CANNOT go off the grid.\n   A way A (of length k) is considered less than a path bacillus (of distance k) if \n   after making the order tilt of the value on the cells that A and B go \n   through (permit's call them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in early words, there exist an integer index i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we hold \n   lst_A[j ] = lst_B[j ]. \n   It is guarantee that the solution is unique. \n   Return an ordered list of the values on the cell that the minimal path function through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const [rows, cols] = grid.length;\n  const [cells, neighbors] = getNeighbors(grid, k);\n  const [path] = getPath(grid, cells, neighbors);\n  return path.sort((a, b) => a - b);\n};\n\n// getNeighbors returns the neighbors of cellular telephone in the grid \n// with integer k. \n// \n// Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n// Output: [[1,2], [3,4], [5,6], [7,8], [9,3]], neighbors = [ [1,2], [3,4], [5,6], [7,8] ]\nconst getNeighbors = (grid, k) => {\n  const [rows, cols] = grid.length;\n  const neighbors = [];\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === k) {\n        neighbors.push([i, j]);\n      }\n    }\n  }\n  return neighbors;\n};\n\n// getPath returns the path from cellular telephone to the cell with integer k. \n// \n// Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n// Output: [[1,2], [3,4], [5,6], [7,8], [9,3]], path = [ [1,2], [3,4], [5,6], [7,8] ]\nconst getPath = (grid, cells, neighbors) => {\n  const path = [];\n  for (let i = 0; i < cells.length; i++) {\n    for (let j = 0; j < cells[i].length; j++) {\n      if (neighbors.includes([i, j])) {\n        path.push([i, j]);\n      }\n    }\n  }\n  return path;\n};\n\n// getNeighbors returns the neighbors of cellular telephone in the grid \n// with integer k. \n// \n// Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n// Output: [[1,2], [3,4], [5,6], [7,8], [9,3]], neighbors = [ [1,2], [3,4], [5,6], [7,8] ]\nconst getNeighbors = (grid, k) => {\n  const [rows, cols] = grid.length;\n  const neighbors = [];\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === k) {\n        neighbors.push([i, j]);\n      }\n    }\n  }\n  return neighbors;\n};\n\n// getPath returns the path from cellular telephone to the cell with integer k. \n// \n// Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n// Output: [[1,2], [3,4], [5,6], [7,8], [9,3]], path = [ [1,2], [3,4], [5,6], [7,8] ]\nconst getPath = (grid, cells, neighbors) => {\n  const path = [];\n  for (let i = 0; i < cells.length; i++) {\n    for (let j = 0; j < cells[i].length; j++) {\n      if (neighbors.includes([i, j])) {\n        path.push([i, j]);\n      }\n    }\n  }\n  return path;\n};\n\n// getNeighbors returns the neighbors of cellular telephone in the grid \n// with integer k. \n// \n// Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n// Output: [[1,2], [3,4], [5,6], [7,8], [9,3]], neighbors = [ [1,2], [3,4], [5,6], [7,8] ]\nconst getNeighbors = (grid, k) => {\n  const [rows, cols] = grid.length;\n  const neighbors = [];\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === k) {\n        neighbors.push([i, j]);\n      }\n    }\n  }\n  return neighbors;\n};\n\n// getPath returns the path from cellular telephone to the cell with integer k. \n// \n// Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n// Output: [[1,2], [3,4], [5,6], [7,8], [9,3]], path = [ [1,2], [3,4], [5,6], [7,8] ]\nconst getPath = (grid, cells, neighbors) => {\n  const path = [];\n  for (let i = 0; i < cells.length; i++) {\n    for (let j = 0; j < cells[i].length; j++) {\n      if (neighbors.includes([i, j])) {\n        path.push([i, j]);\n      }\n    }\n  }\n  return path;\n};\n\n// getNeighbors returns the neighbors of cellular telephone in the grid \n// with integer k. \n// \n// Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n// Output: [[1,2], [3,4], [5,6], [7,8], [9,3]], neighbors = [ [1,2], [3,4], [5,6], [7,8] ]\nconst getNeighbors = (grid, k) => {\n  const [rows, cols] = grid.length;\n  const neighbors = [];\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === k) {\n        neighbors.push([i, j]);\n      }\n    }\n  }\n  return neighbors;\n};\n\n// getPath returns the path from cellular telephone to the cell with integer k. \n// \n// Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n// Output: [[1,2], [3,4], [5,6], [7,8], [9,3]], path = [ [1,2], [3,4], [5,6], [7,8] ]\nconst getPath = (grid, cells, neighbors) => {\n  const path = [];\n  for (let i = 0; i < cells.length; i++) {\n    for (let j = 0; j < cells[i].length; j++) {\n      if (neighbors.includes([i, j])) {\n        path.push([i, j]);\n      }\n    }\n  }\n  return path;\n};\n\n// getNeighbors returns the neighbors of cellular telephone in the grid \n// with integer k. \n// \n// Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n// Output: [[1,2], [3,4], [5,6], [7,8], [9,3]], neighbors = [ [1,2], [3,4], [5,6], [7,8] ]\nconst "}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows Fibonacci succession, it was analyze profoundly by mathematician in \n   the final couple centuries. However, what people don't acknowledge is Tribonacci succession. \n   Tribonacci sequence is define by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Everyone knows Fibonacci succession, it was analyze profoundly by mathematician in \n   the final couple centuries. However, what people don't acknowledge is Tribonacci succession. \n   Tribonacci sequence is define by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  if (n <= 1) return [];\n  return [tri(n - 1) + tri(n - 2) + tri(n + 1)];\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(3) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  fib(7) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n  fib(10) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597]\n  fib(21) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597,\n            2413, 3767, 7013, 9019, 18283, 36281, 51423, 87413, 134621, 171723, 241521,\n            348111, 393241, 433401, 465101, 524719, 640213, 821431, 904719, 1493091\n  ]\n*/\nconst fib = (n) => {\n  if (n <= 1) return [];\n  return [fib(n - 1) + fib(n - 2) + fib(n - 3)];\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(3) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  fib(7) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n  fib(10) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597]\n  fib(21) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597,\n            2413, 3767, 7013, 9019, 18283, 36281, 51423, 87413, 134621, 171723, 241521,\n            348111, 393241, 433401, 465101, 524719, 640213, 821431, 904719, 1493091\n  ]\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return [];\n  return [fibonacci(n - 1) + fibonacci(n - 2) + fibonacci(n - 3)];\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(3) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  fib(7) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n  fib(10) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597]\n  fib(21) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597,\n            2413, 3767, 7013, 9019, 18283, 36281, 51423, 87413, 134621, 171723, 241521,\n            348111, 393241, 433401, 465101, 524719, 640213, 821431, 904719, 1493091\n  ]\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return [];\n  return [fibonacci(n - 1) + fibonacci(n - 2) + fibonacci(n - 3)];\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(3) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  fib(7) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n  fib(10) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597]\n  fib(21) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597,\n            2413, 3767, 7013, 9019, 18283, 36281, 51423, 87413, 134621, 171723, 241521,\n            348111, 393241, 433401, 465101, 524719, 640213, 821431, 904719, 1493091\n  ]\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return [];\n  return [fibonacci(n - 1) + fibonacci(n - 2) + fibonacci(n - 3)];\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(3) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  fib(7) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n  fib(10) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597]\n  fib(21) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597,\n            2413, 3767, 7013, 9019, 18283, 36281, 51423, 87413, 134621, 171723, 241521,\n            348111, 393241, 433401, 465101, 524719, 640213, 821431, 904719, 1493091\n  ]\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return [];\n  return [fibonacci(n - 1) + fibonacci(n - 2) + fibonacci(n - 3)];\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(3) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  fib(7) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n  fib(10) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597]\n  fib(21) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 6"}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive integer n, return the intersection of the leftover digits.\n   Return 0 if all digits cost even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Given a positive integer n, return the intersection of the leftover digits.\n   Return 0 if all digits cost even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let sum = 0;\n  let carry = 0;\n  for (let i = n; i > 0; i--) {\n    sum += carry * 10;\n    carry = Math.floor(i / 10);\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the product of the leftover digits.\n   Return 0 if all digits cost even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst product = (n) => {\n  let product = 1;\n  let carry = 0;\n  for (let i = n; i > 0; i--) {\n    product *= carry * 10;\n    carry = Math.floor(i / 10);\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the least common multiple of the digits.\n   Return 0 if all digits cost even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst lcm = (n) => {\n  let result = 1;\n  let digits = digits(n);\n  for (let i = digits; i > 0; i--) {\n    result *= i;\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the least common multiple of the digits of n.\n   Return 0 if all digits cost even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst lcmDigits = (n) => {\n  let result = 1;\n  let digits = digits(n);\n  for (let i = digits; i > 0; i--) {\n    result *= i;\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the least common multiple of the digits of n.\n   Return 0 if all digits cost even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst lcmDigits_ = (n) => {\n  let result = 1;\n  let digits = digits(n);\n  for (let i = digits; i > 0; i--) {\n    result *= i;\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the least common multiple of the digits of n.\n   Return 0 if all digits cost even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst lcmDigits_digits = (n) => {\n  let result = 1;\n  let digits = digits(n);\n  for (let i = digits; i > 0; i--) {\n    result *= i;\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the least common multiple of the digits of n.\n   Return 0 if all digits cost even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst lcmDigits_digits_ = (n) => {\n  let result = 1;\n  let digits = digits(n);\n  for (let i = digits; i > 0; i--) {\n    result *= i;\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the least common multiple of the digits of n.\n   Return 0 if all digits cost even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst lcmDigits_digits_digits_ = (n) => {\n  let result = 1;\n  let digits = digits(n);\n  for (let i = digits; i > 0; i--) {\n    result *= i;\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the least common multiple of the digits of n.\n   Return 0 if all digits cost even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst lcmDigits_digits_digits_digits_ = (n) => {\n  let result = 1;\n  let digits = digits(n);\n  for (let i = digits; i > 0; i--) {\n    result *= i;\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the least common multiple of the digits of n.\n   Return 0 if all digits cost even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst lcmDigits_digits_digits_digits_digits_digits_ = (n) => {\n  let result = 1;\n  let digits = digits(n);\n  for (let i = digits; i > 0; i--) {\n    result *= i;\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the least common multiple of the digits of n.\n   Return 0 if all digits cost even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst lcmDigits_digits_digits_digits_digits_digits_digits_digits_ = (n) => {\n  let result = 1;\n  let digits = digits(n);\n  for (let i = digits; i > 0; i--) {\n    result *= i;\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the least common multiple of the digits of n.\n   Return 0 if all digits cost even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst lcmDigits_digits_digits_digits_digits_digits_digits_digits_digits_digits_ = (n) => {\n  let result = 1;\n  let digits = digits(n);\n  for (let i = digits; i > 0; i--) {\n    result *= i;\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the least common multiple of the digits of n.\n   Return 0 if all digits cost even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst lcmDigits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digit"}
{"task_id": "JavaScript/132", "prompt": "/*\n  make a function that take a string as input signal which check only square brackets. \n   The affair should return genuine if and merely if there is a valid subsequence of bracket \n   where at least one bracket in the subsequence is nested. \n   isNested('[[]]') ➞ true \n   isNested('[]]]]]]][[[[[]') ➞ delusive \n   isNested('[][]') ➞ fake \n   isNested('[]') ➞ delusive \n   isNested('[[][]]') ➞ true \n   isNested('[[]][[') ➞ dependable \n   * / \n const isNested = (string) = > {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  make a function that take a string as input signal which check only square brackets. \n   The affair should return genuine if and merely if there is a valid subsequence of bracket \n   where at least one bracket in the subsequence is nested. \n   isNested('[[]]') ➞ true \n   isNested('[]]]]]]][[[[[]') ➞ delusive \n   isNested('[][]') ➞ fake \n   isNested('[]') ➞ delusive \n   isNested('[[][]]') ➞ true \n   isNested('[[]][[') ➞ dependable \n   * / \n const isNested = (string) = > {\n   const [head,...tail] = string.split(']');\n   return head === '[' && tail.every(isNested);\n };\n \n const isNestedString = (string) => isNested(string);\n \n const isNestedArray = (string) => isNested(string);\n \n const isNestedObject = (string) => isNested(string);\n \n const isNestedArrayObject = (string) => isNested(string);\n \n const isNestedArrayObjectArray = (string) => isNested(string);\n \n const isNestedArrayObjectArrayArray = (string) => isNested(string);\n \n const isNestedArrayObjectArrayArrayArray = (string) => isNested(string);\n \n const isNestedArrayObjectArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray"}
{"task_id": "JavaScript/133", "prompt": "/*You are establish a list of numbers. \n   You want to return the kernel of squared issue in the given list,\n   round each component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*You are establish a list of numbers. \n   You want to return the kernel of squared issue in the given list,\n   round each component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let temp;\n  \n  for(let i = 0; i < lst.length; i++) {\n    temp = lst[i] * lst[i];\n    sum += temp;\n  }\n  \n  for(let j = 0; j < lst.length; j++) {\n    temp = lst[j] * lst[j];\n    sum += temp;\n  }\n  \n  return Math.ceil(sum);\n}\n\n/*\n  You are given two arrays, nums and dens. Write a function to compute the\n  difference between nums and dens.\n  Examples:\n  nums = [1,3,5,7] and dens = [2,4,6,8]\n  the output should be 6\n*/\nconst difference = (nums, dens) => {\n  let numsSum = 0;\n  let densSum = 0;\n  let difference = 0;\n  \n  for(let i = 0; i < nums.length; i++) {\n    numsSum += nums[i];\n  }\n  \n  for(let i = 0; i < dens.length; i++) {\n    densSum += dens[i];\n  }\n  \n  for(let i = 0; i < nums.length; i++) {\n    difference += nums[i] - dens[i];\n  }\n  \n  return difference;\n}\n\n/*\n  You are given two arrays, nums and dens. Write a function to compute the\n  difference between nums and dens.\n  Examples:\n  nums = [1,3,5,7] and dens = [2,4,6,8]\n  the output should be 6\n*/\nconst differenceSquare = (nums, dens) => {\n  let numsSum = 0;\n  let densSum = 0;\n  let difference = 0;\n  \n  for(let i = 0; i < nums.length; i++) {\n    numsSum += nums[i] * nums[i];\n  }\n  \n  for(let i = 0; i < dens.length; i++) {\n    densSum += dens[i] * dens[i];\n  }\n  \n  for(let i = 0; i < nums.length; i++) {\n    difference += nums[i] - dens[i] * dens[i];\n  }\n  \n  return difference;\n}\n\n/*\n  You are given two arrays, nums and dens. Write a function to compute the\n  difference between nums and dens.\n  Examples:\n  nums = [1,3,5,7] and dens = [2,4,6,8]\n  the output should be 6\n*/\nconst differenceSquareRoot = (nums, dens) => {\n  let numsSum = 0;\n  let densSum = 0;\n  let difference = 0;\n  \n  for(let i = 0; i < nums.length; i++) {\n    numsSum += Math.pow(nums[i], 2);\n  }\n  \n  for(let i = 0; i < dens.length; i++) {\n    densSum += Math.pow(dens[i], 2);\n  }\n  \n  for(let i = 0; i < nums.length; i++) {\n    difference += Math.pow(nums[i] - dens[i], 2);\n  }\n  \n  return difference;\n}\n\n/*\n  You are given two arrays, nums and dens. Write a function to compute the\n  difference between nums and dens.\n  Examples:\n  nums = [1,3,5,7] and dens = [2,4,6,8]\n  the output should be 6\n*/\nconst differenceToThePower = (nums, dens) => {\n  let numsSum = 0;\n  let densSum = 0;\n  let difference = 0;\n  \n  for(let i = 0; i < nums.length; i++) {\n    numsSum += Math.pow(nums[i], 2);\n  }\n  \n  for(let i = 0; i < dens.length; i++) {\n    densSum += Math.pow(dens[i], 2);\n  }\n  \n  for(let i = 0; i < nums.length; i++) {\n    difference += Math.pow(nums[i] - dens[i], 2);\n  }\n  \n  return difference;\n}\n\n/*\n  You are given two arrays, nums and dens. Write a function to compute the\n  difference between nums and dens.\n  Examples:\n  nums = [1,3,5,7] and dens = [2,4,6,8]\n  the output should be 6\n*/\nconst differenceToThePowerRoot = (nums, dens) => {\n  let numsSum = 0;\n  let densSum = 0;\n  let difference = 0;\n  \n  for(let i = 0; i < nums.length; i++) {\n    numsSum += Math.pow(nums[i], 2);\n  }\n  \n  for(let i = 0; i < dens.length; i++) {\n    densSum += Math.pow(dens[i], 2);\n  }\n  \n  for(let i = 0; i < nums.length; i++) {\n    difference += Math.pow(nums[i] - dens[i], 2);\n  }\n  \n  return Math.sqrt(difference);\n}\n\n/*\n  You are given two arrays, nums and dens. Write a function to compute the\n  difference between nums and dens.\n  Examples:\n  nums = [1,3,5,7] and dens = [2,4,6,8]\n  the output should be 6\n*/\nconst differenceToThePowerToThePower = (nums, dens) => {\n  let numsSum = 0;\n  let densSum = 0;\n  let difference = 0;\n  \n  for(let i = 0; i < nums.length; i++) {\n    numsSum += Math.pow(nums[i], 2);\n  }\n  \n  for(let i = 0; i < dens.length; i++) {\n    densSum += Math.pow(dens[i], 2);\n  }\n  \n  for(let i = 0; i < nums.length; i++) {\n    difference += Math.pow(nums[i] - dens[i], 2);\n  }\n  \n  return Math.pow(difference, 2);\n}\n\n/*\n  You are given two arrays, nums and dens. Write a function to compute the\n  difference between nums and dens.\n  Examples:\n  nums = [1,3,5,7] and dens = [2,4,6,8]\n  the output should be 6\n*/\nconst differenceToThePowerToThePowerRoot = (nums, dens) => {\n  let numsSum = 0;\n  let densSum = 0;\n  let difference = 0;\n  \n  for(let i = 0; i < nums.length; i++) {\n    numsSum += Math.pow(nums[i], 2);\n  }\n  \n  for(let i = 0; i < dens.length; i++) {\n    densSum += Math.pow(dens[i], 2);\n  }\n  \n  for(let i = 0; i < nums.length; i++) {\n    difference += Math.pow(nums[i] - dens[i], 2);\n  }\n  \n  return Math.pow(Math.sqrt(difference), 2);\n}\n\n/*\n  You are given two arrays, nums and dens. Write a function to compute the\n  difference between nums and dens.\n  Examples:\n  nums = [1,3,5,7] and dens = [2,4,6,8]\n  the output should be 6\n*/\nconst differenceToThePowerToThePowerToThePower = (nums, dens) => {\n  let numsSum = 0;\n  let densSum = 0;\n  let difference = 0;\n  \n  for(let i = 0; i < nums.length; i++) {\n    numsSum += Math.pow(nums[i], 2);\n  }\n  \n  for(let i = 0; i < dens.length; i++) {\n    densSum += Math.pow(dens[i], 2);\n  }\n  \n  for(let i = 0; i < nums.length; i++) {\n    difference += Math.pow(nums[i] - dens[i], 2);\n  }\n  \n  return Math.pow(Math.pow(difference, 2), 2);\n}\n\n/*\n  You are given two arrays, nums and dens. Write a function to compute the\n  difference between nums and dens.\n  Examples:\n  nums = [1,3,5,7] and dens = [2,4,6,8]\n  the output should be 6\n*/\nconst differenceToThePowerToThePowerToThePowerRoot = (nums, dens) => {\n  let numsSum = 0;\n  let densSum = 0;\n  let difference = 0;\n  "}
{"task_id": "JavaScript/134", "prompt": "/* make a function that return truthful if the final character \n   of a given string be an alphabetic fictional character and is not \n   a function of a news, and false otherwise. \n   Note: \" discussion \" is a group of characters divide by distance.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* make a function that return truthful if the final character \n   of a given string be an alphabetic fictional character and is not \n   a function of a news, and false otherwise. \n   Note: \" discussion \" is a group of characters divide by distance.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!== \" \" && lastChar!== \"discussion\" && lastChar!== \"discussions\" && lastChar!== \"discussions\" && lastChar!== \"discussion\";\n};\n\n/* make a function that return truthful if the final character \n   of a given string be an alphabetic fictional character and is not \n   a function of a news, and false otherwise. \n   Note: \" discussion \" is a group of characters divide by distance.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!== \" \" && lastChar!== \"discussion\" && lastChar!== \"discussions\" && lastChar!== \"discussions\" && lastChar!== \"discussion\";\n};\n\n/* make a function that return truthful if the final character \n   of a given string be an alphabetic fictional character and is not \n   a function of a news, and false otherwise. \n   Note: \" discussion \" is a group of characters divide by distance.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!== \" \" && lastChar!== \"discussion\" && lastChar!== \"discussions\" && lastChar!== \"discussions\" && lastChar!== \"discussion\";\n};\n\n/* make a function that return truthful if the final character \n   of a given string be an alphabetic fictional character and is not \n   a function of a news, and false otherwise. \n   Note: \" discussion \" is a group of characters divide by distance.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!== \" \" && lastChar!== \"discussion\" && lastChar!== \"discussions\" && lastChar!== \"discussions\" && lastChar!== \"discussion\";\n};\n\n/* make a function that return truthful if the final character \n   of a given string be an alphabetic fictional character and is not \n   a function of a news, and false otherwise. \n   Note: \" discussion \" is a group of characters divide by distance.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!== \" \" && lastChar!== \"discussion\" && lastChar!== \"discussions\" && lastChar!== \"discussions\" && lastChar!== \"discussion\";\n};\n\n/* make a function that return truthful if the final character \n   of a given string be an alphabetic fictional character and is not \n   a function of a news, and false otherwise. \n   Note: \" discussion \" is a group of characters divide by distance.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!== \" \" && lastChar!== \"discussion\" && lastChar!== \"discussions\" && lastChar!== \"discussions\" && lastChar!== \"discussion\";\n};\n\n/* make a function that return truthful if the final character \n   of a given string be an alphabetic fictional character and is not \n   a function of a news, and false otherwise. \n   Note: \" discussion \" is a group of characters divide by distance.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!== \" \" && lastChar!== \"discussion\" && lastChar!== \"discussions\" && lastChar!== \"discussions\" && lastChar!== \"discussion\";\n};\n\n/* make a function that return truthful if the final character \n   of a given string be an alphabetic fictional character and is not \n   a function of a news, and false otherwise. \n   Note: \" discussion \" is a group of characters divide by distance.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */"}
{"task_id": "JavaScript/135", "prompt": "/*Create a function which reelect the largest exponent of an component which \n   is not greater than or equal to the component immediately preceding it. If \n   no such element exist then return -1. The given array will not contain \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Create a function which reelect the largest exponent of an component which \n   is not greater than or equal to the component immediately preceding it. If \n   no such element exist then return -1. The given array will not contain \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxExp = -1\n  let maxExpIdx = 0\n  let maxExpIdxIdx = 0\n  let maxExpIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdxIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdxIdxIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdxIdxIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdx = 0\n  let maxExpIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdxIdx"}
{"task_id": "JavaScript/136", "prompt": "/* make a function that return a tuple (a, b), where 'a' cost \n   the big of damaging integers, and 'b' is the humble \n   of incontrovertible integer in a list.\n   If there is no negative or positive integer, return them as nothing.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* make a function that return a tuple (a, b), where 'a' cost \n   the big of damaging integers, and 'b' is the humble \n   of incontrovertible integer in a list.\n   If there is no negative or positive integer, return them as nothing.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let maxSmallest = null;\n  let maxValue = null;\n  let maxIndex = null;\n  let maxIndex2 = null;\n  let maxIndex3 = null;\n  let maxIndex4 = null;\n  let maxIndex5 = null;\n  let maxIndex6 = null;\n  let maxIndex7 = null;\n  let maxIndex8 = null;\n  let maxIndex9 = null;\n  let maxIndex10 = null;\n  let maxIndex11 = null;\n  let maxIndex12 = null;\n  let maxIndex13 = null;\n  let maxIndex14 = null;\n  let maxIndex15 = null;\n  let maxIndex16 = null;\n  let maxIndex17 = null;\n  let maxIndex18 = null;\n  let maxIndex19 = null;\n  let maxIndex20 = null;\n  let maxIndex21 = null;\n  let maxIndex22 = null;\n  let maxIndex23 = null;\n  let maxIndex24 = null;\n  let maxIndex25 = null;\n  let maxIndex26 = null;\n  let maxIndex27 = null;\n  let maxIndex28 = null;\n  let maxIndex29 = null;\n  let maxIndex30 = null;\n  let maxIndex31 = null;\n  let maxIndex32 = null;\n  let maxIndex33 = null;\n  let maxIndex34 = null;\n  let maxIndex35 = null;\n  let maxIndex36 = null;\n  let maxIndex37 = null;\n  let maxIndex38 = null;\n  let maxIndex39 = null;\n  let maxIndex40 = null;\n  let maxIndex41 = null;\n  let maxIndex42 = null;\n  let maxIndex43 = null;\n  let maxIndex44 = null;\n  let maxIndex45 = null;\n  let maxIndex46 = null;\n  let maxIndex47 = null;\n  let maxIndex48 = null;\n  let maxIndex49 = null;\n  let maxIndex50 = null;\n  let maxIndex51 = null;\n  let maxIndex52 = null;\n  let maxIndex53 = null;\n  let maxIndex54 = null;\n  let maxIndex55 = null;\n  let maxIndex56 = null;\n  let maxIndex57 = null;\n  let maxIndex58 = null;\n  let maxIndex59 = null;\n  let maxIndex60 = null;\n  let maxIndex61 = null;\n  let maxIndex62 = null;\n  let maxIndex63 = null;\n  let maxIndex64 = null;\n  let maxIndex65 = null;\n  let maxIndex66 = null;\n  let maxIndex67 = null;\n  let maxIndex68 = null;\n  let maxIndex69 = null;\n  let maxIndex70 = null;\n  let maxIndex71 = null;\n  let maxIndex72 = null;\n  let maxIndex73 = null;\n  let maxIndex74 = null;\n  let maxIndex75 = null;\n  let maxIndex76 = null;\n  let maxIndex77 = null;\n  let maxIndex78 = null;\n  let maxIndex79 = null;\n  let maxIndex80 = null;\n  let maxIndex81 = null;\n  let maxIndex82 = null;\n  let maxIndex83 = null;\n  let maxIndex84 = null;\n  let maxIndex85 = null;\n  let maxIndex86 = null;\n  let maxIndex87 = null;\n  let maxIndex88 = null;\n  let maxIndex89 = null;\n  let maxIndex90 = null;\n  let maxIndex91 = null;\n  let maxIndex92 = null;\n  let maxIndex93 = null;\n  let maxIndex94 = null;\n  let maxIndex95 = null;\n  let maxIndex96 = null;\n  let maxIndex97 = null;\n  let maxIndex98 = null;\n  let maxIndex99 = null;\n  let maxIndex100 = null;\n  let maxIndex101 = null;\n  let maxIndex102 = null;\n  let maxIndex103 = null;\n  let maxIndex104 = null;\n  let maxIndex105 = null;\n  let maxIndex106 = null;\n  let maxIndex107 = null;\n  let maxIndex108);\n  let maxIndex109);\n  let maxIndex110);\n  let maxIndex111);\n  let maxIndex112);\n  let maxIndex113);\n  let maxIndex114);\n  let maxIndex115);\n  let maxIndex116);\n  let maxIndex117);\n  let maxIndex118);\n  let maxIndex119);\n  let maxIndex120);\n  let maxIndex121);\n  let maxIndex122);\n  let maxIndex123);\n  let maxIndex124);\n  let maxIndex125);\n  let maxIndex126);\n  let maxIndex127);\n  let maxIndex128);\n  let maxIndex129);\n  let maxIndex130);\n  let maxIndex131);\n  let maxIndex132);\n  let maxIndex133);\n  let maxIndex134);\n  let maxIndex135);\n  let maxIndex136);\n  let maxIndex137);\n  let maxIndex138);\n  let maxIndex139);\n  let maxIndex140);\n  let maxIndex141);\n  let maxIndex142);\n  let maxIndex143);\n  let maxIndex144);\n  let maxIndex145);\n  let maxIndex146);\n  let maxIndex147);\n  let maxIndex148);\n  let maxIndex149);\n  let maxIndex150);\n  let maxIndex151);\n  let maxIndex152);\n  let maxIndex153);\n  let maxIndex154);\n  let maxIndex155);\n  let maxIndex156);\n  let maxIndex157);\n  let maxIndex158);\n  let maxIndex159);\n  let maxIndex160);\n  let maxIndex161);\n  let maxIndex162);\n  let maxIndex163);\n  let maxIndex164);\n  let maxIndex165);\n  let maxIndex166);\n  let maxIndex167);\n  let maxIndex168);\n  let maxIndex169);\n  let maxIndex170);\n  let maxIndex171);\n  let maxIndex172);\n  let maxIndex173);\n  let maxIndex174);\n  let maxIndex175);\n  let maxIndex176);\n  let maxIndex177);\n  let maxIndex178);\n  let maxIndex179);\n  let maxIndex180);\n  let maxIndex181);\n  let maxIndex182);\n  let maxIndex183);\n  let maxIndex184);\n  let maxIndex185);\n  let maxIndex186);\n  let maxIndex187);\n  let maxIndex188);\n  let maxIndex189);\n  let maxIndex190);\n  let maxIndex191);\n  let maxIndex192);\n  let maxIndex193);\n  let maxIndex194);\n  let maxIndex195);\n  let maxIndex196);\n  let maxIndex197);\n  let maxIndex198);\n  let maxIndex199);\n  let maxIndex200);\n  let maxIndex201);\n  let maxIndex202);\n  let maxIndex203);\n  let maxIndex204);\n  let maxIndex205);\n  let maxIndex206);\n  let maxIndex207);\n  let maxIndex208);\n  let maxIndex209);\n  let maxIndex210);\n  let maxIndex211);\n  let maxIndex212);\n  let maxIndex213);\n  let maxIndex214);\n  let maxIndex215);\n  let maxIndex216);\n  let maxIndex217);\n  let maxIndex218);\n  let maxIndex219);\n  let maxIndex220);\n  let maxIndex221);\n  let maxIndex222);\n  let maxIndex223);\n  let maxIndex224);\n  let maxIndex225);\n  let maxIndex226);\n  let maxIndex227);\n  let maxIndex228);\n  let maxIndex229);\n  let maxIndex230);\n  let max"}
{"task_id": "JavaScript/137", "prompt": "/*\n  make a function that take integer, float, or drawstring representing \n   real phone number, and render the large variable in its give varying type. \n   Return null if the values are adequate. \n   Note: If a real number is represented as a chain, the floating compass point might be. or, \n\n   compareOne(1, 2.5) ➞ 2.5 \n   compareOne(1, \" 2,3 \") ➞ \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \") ➞ \" 6 \" \n   compareOne(\"1\", 1) ➞ null \n   * / \n const compareOne = (a, b) = > {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  make a function that take integer, float, or drawstring representing \n   real phone number, and render the large variable in its give varying type. \n   Return null if the values are adequate. \n   Note: If a real number is represented as a chain, the floating compass point might be. or, \n\n   compareOne(1, 2.5) ➞ 2.5 \n   compareOne(1, \" 2,3 \") ➞ \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \") ➞ \" 6 \" \n   compareOne(\"1\", 1) ➞ null \n   * / \n const compareOne = (a, b) = > {\n   const isFloat = typeof(a) === \"number\" && typeof(b) === \"number\";\n   const isString = typeof(a) === \"string\" && typeof(b) === \"string\";\n   const isChain = typeof(a) === \"object\" && typeof(b) === \"object\";\n   const isRealNumber = isFloat || isString || isChain;\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite(a) && isFinite(b) && isFinite(a) && isFinite(b);\n   const isRealNumber = isRealNumber && isFinite"}
{"task_id": "JavaScript/138", "prompt": "/*Emeasure whether the given issue n can be written as the union of precisely 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Emeasure whether the given issue n can be written as the union of precisely 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  if (n <= 0) return false;\n  if (n <= 1) return true;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return true;\n  return isEqualToSumEven(n - 1) + isEqualToSumEven(n - 2);\n};\n\n/*\n  Given a number n, return the number of ways to write n as a sum of even numbers.\n  Example\n  sumEvens(4) == 4\n  sumEvens(6) == 6\n  sumEvens(8) == 8\n  sumEvens(10) == 10\n  sumEvens(12) == 12\n  sumEvens(14) == 14\n  sumEvens(16) == 16\n  sumEvens(18) == 18\n  sumEvens(20) == 20\n  sumEvens(22) == 22\n  sumEvens(24) == 24\n  sumEvens(26) == 26\n  sumEvens(28) == 28\n  sumEvens(30) == 30\n  sumEvens(32) == 32\n  sumEvens(34) == 34\n  sumEvens(36) == 36\n  sumEvens(38) == 38\n  sumEvens(40) == 40\n  sumEvens(42) == 42\n  sumEvens(44) == 44\n  sumEvens(46) == 46\n  sumEvens(48) == 48\n  sumEvens(50) == 50\n  sumEvens(52) == 52\n  sumEvens(54) == 54\n  sumEvens(56) == 56\n  sumEvens(58) == 58\n  sumEvens(60) == 60\n  sumEvens(62) == 62\n  sumEvens(64) == 64\n  sumEvens(66) == 66\n  sumEvens(68) == 68\n  sumEvens(70) == 70\n  sumEvens(72) == 72\n  sumEvens(74) == 74\n  sumEvens(76) == 76\n  sumEvens(78) == 78\n  sumEvens(80) == 80\n  sumEvens(82) == 82\n  sumEvens(84) == 84\n  sumEvens(86) == 86\n  sumEvens(88) == 88\n  sumEvens(90) == 90\n  sumEvens(92) == 92\n  sumEvens(94) == 94\n  sumEvens(96) == 96\n  sumEvens(98) == 98\n  sumEvens(100) == 100\n  sumEvens(102) == 102\n  sumEvens(104) == 104\n  sumEvens(106) == 106\n  sumEvens(108) == 108\n  sumEvens(110) == 110\n  sumEvens(112) == 112\n  sumEvens(114) == 114\n  sumEvens(116) == 116\n  sumEvens(118) == 118\n  sumEvens(120) == 120\n  sumEvens(122) == 122\n  sumEvens(124) == 124\n  sumEvens(126) == 126\n  sumEvens(128) == 128\n  sumEvens(130) == 130\n  sumEvens(132) == 132\n  sumEvens(134) == 134\n  sumEvens(136) == 136\n  sumEvens(138) == 138\n  sumEvens(140) == 140\n  sumEvens(142) == 142\n  sumEvens(144) == 144\n  sumEvens(146) == 146\n  sumEvens(148) == 148\n  sumEvens(150) == 150\n  sumEvens(152) == 152\n  sumEvens(154) == 154\n  sumEvens(156) == 156\n  sumEvens(158) == 158\n  sumEvens(160) == 160\n  sumEvens(162) == 162\n  sumEvens(164) == 164\n  sumEvens(166) == 166\n  sumEvens(168) == 168\n  sumEvens(170) == 170\n  sumEvens(172) == 172\n  sumEvens(174) == 174\n  sumEvens(176) == 176\n  sumEvens(178) == 178\n  sumEvens(180) == 180\n  sumEvens(182) == 182\n  sumEvens(184) == 184\n  sumEvens(186) == 186\n  sumEvens(188) == 188\n  sumEvens(190) == 190\n  sumEvens(192) == 192\n  sumEvens(194) == 194\n  sumEvens(196) == 196\n  sumEvens(198) == 198\n  sumEvens(200) == 200\n  sumEvens(202) == 202\n  sumEvens(204) == 204\n  sumEvens(206) == 206\n  sumEvens(208) == 208\n  sumEvens(210) == 210\n  sumEvens(212) == 212\n  sumEvens(214) == 214\n  sumEvens(216) == 216\n  sumEvens(218) == 218\n  sumEvens(220) == 220\n  sumEvens(222) == 222\n  sumEvens(224) == 224\n  sumEvens(226) == 226\n  sumEvens(228) == 228\n  sumEvens(230) == 230\n  sumEvens(232) == 232\n  sumEvens(234) == 234\n  sumEvens(236) == 236\n  sumEvens(238) == 238\n  sumEvens(240) == 240\n  sumEvens(242) == 242\n  sumEvens(244) == 244\n  sumEvens(246) == 246\n  sumEvens(248) == 248\n  sumEvens(250) == 250\n  sumEvens(252) == 252\n  sumEvens(254) == 254\n  sumEvens(256) == 256\n  sumEvens(258) == 258\n  sumEvens(260) == 260\n  sumEvens(262) == 262\n  sumEvens(264) == 264\n  sumEvens(266) == 266\n  sumEvens(268) == 268\n  sumEvens(270) == 270\n  sumEvens(272) == 272\n  sumEvens(274) == 274\n  sumEvens(276) == 276\n  sumEvens(278) == 278\n  sumEvens(280) == 280\n  sumEvens(282) == 282\n  sumEvens(284) == 284\n  sumEvens(286) == 286\n  sumEvens(288) == 288\n  sumEvens(290) == 290\n  sumEvens(292) == 292\n  sumEvens(294) == 294\n  sumEvens(296) == 296\n  sumEvens(298) == 298\n  sumEvens(300) == 300\n  sumEvens(302) == 302\n  sumEvens(304) == 304\n  sumEvens(306) == 306\n  sumEvens(308) == 308\n  sumEvens(310) == 310\n  sumEvens(312) == 312\n  sumEvens(314) == 314\n  sumEvens(316) == 316\n  sumEvens(318) == 318\n  sumEvens(320) == 320\n  sumEvens(322) == 322\n  sumEvens(324) == 324\n  sumEvens(326) == 326\n  sumEvens(328) == 328\n  sumEvens(330) == 330\n  sumEvens(332) == 332\n  sumEvens(334) == 334\n  sumEvens(336) == 336\n  sumEvens(338) == 338\n  sumEvens(340) == 340\n  sumEvens(342) == 342\n  sumEvens(344) == "}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is define as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For exercise:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*The Brazilian factorial is define as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For exercise:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * "}
{"task_id": "JavaScript/140", "prompt": "/*\n  establish a string text, replace all space in it with underscore, \n   and if a chain has more than 2 back-to-back space, \n   then substitute all back-to-back spaces with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  establish a string text, replace all space in it with underscore, \n   and if a chain has more than 2 back-to-back space, \n   then substitute all back-to-back spaces with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  let newText = text;\n  newText = newText.replace(/\\s/g, \"_\");\n  newText = newText.replace(/\\s{2,}/g, \" \");\n  return newText;\n};\n\n/*\n  Given a string, return true if it starts with a capital letter\n  \n  fixCapital(\"Example\") -> true\n  fixCapital(\"Example1\") -> false\n  fixCapital(\"Example2\") -> false\n  fixCapital(\"Example3\") -> false\n  fixCapital(\"Example4\") -> false\n  fixCapital(\"Example5\") -> false\n  fixCapital(\"Example6\") -> false\n  fixCapital(\"Example7\") -> false\n  fixCapital(\"Example8\") -> false\n  fixCapital(\"Example9\") -> false\n  fixCapital(\"Example10\") -> false\n  fixCapital(\"Example11\") -> false\n  fixCapital(\"Example12\") -> false\n  fixCapital(\"Example13\") -> false\n  fixCapital(\"Example14\") -> false\n  fixCapital(\"Example15\") -> false\n  fixCapital(\"Example16\") -> false\n  fixCapital(\"Example17\") -> false\n  fixCapital(\"Example18\") -> false\n  fixCapital(\"Example19\") -> false\n  fixCapital(\"Example20\") -> false\n  fixCapital(\"Example21\") -> false\n  fixCapital(\"Example22\") -> false\n  fixCapital(\"Example23\") -> false\n  fixCapital(\"Example24\") -> false\n  fixCapital(\"Example25\") -> false\n  fixCapital(\"Example26\") -> false\n  fixCapital(\"Example27\") -> false\n  fixCapital(\"Example28\") -> false\n  fixCapital(\"Example29\") -> false\n  fixCapital(\"Example30\") -> false\n  fixCapital(\"Example31\") -> false\n  fixCapital(\"Example32\") -> false\n  fixCapital(\"Example33\") -> false\n  fixCapital(\"Example34\") -> false\n  fixCapital(\"Example35\") -> false\n  fixCapital(\"Example36\") -> false\n  fixCapital(\"Example37\") -> false\n  fixCapital(\"Example38\") -> false\n  fixCapital(\"Example39\") -> false\n  fixCapital(\"Example40\") -> false\n  fixCapital(\"Example41\") -> false\n  fixCapital(\"Example42\") -> false\n  fixCapital(\"Example43\") -> false\n  fixCapital(\"Example44\") -> false\n  fixCapital(\"Example45\") -> false\n  fixCapital(\"Example46\") -> false\n  fixCapital(\"Example47\") -> false\n  fixCapital(\"Example48\") -> false\n  fixCapital(\"Example49\") -> false\n  fixCapital(\"Example50\") -> false\n  fixCapital(\"Example51\") -> false\n  fixCapital(\"Example52\") -> false\n  fixCapital(\"Example53\") -> false\n  fixCapital(\"Example54\") -> false\n  fixCapital(\"Example55\") -> false\n  fixCapital(\"Example56\") -> false\n  fixCapital(\"Example57\") -> false\n  fixCapital(\"Example58\") -> false\n  fixCapital(\"Example59\") -> false\n  fixCapital(\"Example60\") -> false\n  fixCapital(\"Example61\") -> false\n  fixCapital(\"Example62\") -> false\n  fixCapital(\"Example63\") -> false\n  fixCapital(\"Example64\") -> false\n  fixCapital(\"Example65\") -> false\n  fixCapital(\"Example66\") -> false\n  fixCapital(\"Example67\") -> false\n  fixCapital(\"Example68\") -> false\n  fixCapital(\"Example69\") -> false\n  fixCapital(\"Example70\") -> false\n  fixCapital(\"Example71\") -> false\n  fixCapital(\"Example72\") -> false\n  fixCapital(\"Example73\") -> false\n  fixCapital(\"Example74\") -> false\n  fixCapital(\"Example75\") -> false\n  fixCapital(\"Example76\") -> false\n  fixCapital(\"Example77\") -> false\n  fixCapital(\"Example78\") -> false\n  fixCapital(\"Example79\") -> false\n  fixCapital(\"Example80\") -> false\n  fixCapital(\"Example81\") -> false\n  fixCapital(\"Example82\") -> false\n  fixCapital(\"Example83\") -> false\n  fixCapital(\"Example84\") -> false\n  fixCapital(\"Example85\") -> false\n  fixCapital(\"Example86\") -> false\n  fixCapital(\"Example87\") -> false\n  fixCapital(\"Example88\") -> false\n  fixCapital(\"Example89\") -> false\n  fixCapital(\"Example90\") -> false\n  fixCapital(\"Example91\") -> false\n  fixCapital(\"Example92\") -> false\n  fixCapital(\"Example93\") -> false\n  fixCapital(\"Example94\") -> false\n  fixCapital(\"Example95\") -> false\n  fixCapital(\"Example96\") -> false\n  fixCapital(\"Example97\") -> false\n  fixCapital(\"Example98\") -> false\n  fixCapital(\"Example99\") -> false\n  fixCapital(\"Example100\") -> false\n  fixCapital(\"Example101\") -> false\n  fixCapital(\"Example102\") -> false\n  fixCapital(\"Example103\") -> false\n  fixCapital(\"Example104\") -> false\n  fixCapital(\"Example105\") -> false\n  fixCapital(\"Example106\") -> false\n  fixCapital(\"Example107\") -> false\n  fixCapital(\"Example108\") -> false\n  fixCapital(\"Example109\") -> false\n  fixCapital(\"Example110\") -> false\n  fixCapital(\"Example111\") -> false\n  fixCapital(\"Example112\") -> false\n  fixCapital(\"Example113\") -> false\n  fixCapital(\"Example114\") -> false\n  fixCapital(\"Example115\") -> false\n  fixCapital(\"Example116\") -> false\n  fixCapital(\"Example117\") -> false\n  fixCapital(\"Example118\") -> false\n  fixCapital(\"Example119\") -> false\n  fixCapital(\"Example120\") -> false\n  fixCapital(\"Example121\") -> false\n  fixCapital(\"Example122\") -> false\n  fixCapital(\"Example123\") -> false\n  fixCapital(\"Example124\") -> false\n  fixCapital(\"Example125\") -> false\n"}
{"task_id": "JavaScript/141", "prompt": "/*Create a function which fill a string typify a file's name, and revert \n  ' Yes' if the the file's name is valid, and return' No' otherwise. \n   A file's name is considered to be valid if and only if all the postdate conditions \n   are met: \n   - There should not be more than three digit (' 0'-'9') in the file's name. \n   - The file's name contains precisely one dot'.' \n   - The substring before the acid should not be empty, and it start with a letter from \n   the romance alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot should exist one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Create a function which fill a string typify a file's name, and revert \n 'Yes' if the the file's name is valid, and return' No' otherwise. \n   A file's name is considered to be valid if and only if all the postdate conditions \n   are met: \n   - There should not be more than three digit (' 0'-'9') in the file's name. \n   - The file's name contains precisely one dot'.' \n   - The substring before the acid should not be empty, and it start with a letter from \n   the romance alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot should exist one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const regExp = /^[a-zA-Z0-9]+\\.[a-zA-Z]+$/;\n  return regExp.test(file_name);\n};\n\n/*Create a function which fill a string typify a file's name, and revert \n 'Yes' if the the file's name is valid, and return' No' otherwise. \n   A file's name is considered to be valid if and only if all the postdate conditions \n   are met: \n   - There should not be more than three digit (' 0'-'9') in the file's name. \n   - The file's name contains precisely one dot'.' \n   - The substring before the acid should not be empty, and it start with a letter from \n   the romance alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot should exist one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const regExp = /^[a-zA-Z0-9]+\\.[a-zA-Z]+$/;\n  return regExp.test(file_name);\n};\n\n/*Create a function which fill a string typify a file's name, and revert \n 'Yes' if the the file's name is valid, and return' No' otherwise. \n   A file's name is considered to be valid if and only if all the postdate conditions \n   are met: \n   - There should not be more than three digit (' 0'-'9') in the file's name. \n   - The file's name contains precisely one dot'.' \n   - The substring before the acid should not be empty, and it start with a letter from \n   the romance alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot should exist one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const regExp = /^[a-zA-Z0-9]+\\.[a-zA-Z]+$/;\n  return regExp.test(file_name);\n};\n\n/*Create a function which fill a string typify a file's name, and revert \n 'Yes' if the the file's name is valid, and return' No' otherwise. \n   A file's name is considered to be valid if and only if all the postdate conditions \n   are met: \n   - There should not be more than three digit (' 0'-'9') in the file's name. \n   - The file's name contains precisely one dot'.' \n   - The substring before the acid should not be empty, and it start with a letter from \n   the romance alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot should exist one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const regExp = /^[a-zA-Z0-9]+\\.[a-zA-Z]+$/;\n  return regExp.test(file_name);\n};\n\n/*Create a function which fill a string typify a file's name, and revert \n 'Yes' if the the file's name is valid, and return' No' otherwise. \n   A file's name is considered to be valid if and only if all the postdate conditions \n   are met: \n   - There should not be more than three digit (' 0'-'9') in the file's name. \n   - The file's name contains precisely one dot'.' \n   - The substring before the acid should not be empty, and it start with a letter from \n   the romance alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot should exist one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const regExp = /^[a-zA-Z0-9]+\\.[a-zA-Z]+$/;\n  return regExp.test(file_name);\n};\n\n/*Create a function which fill a string typify a file's name, and revert \n 'Yes' if the the file's name is valid, and return' No' otherwise. \n   A file's name is considered to be valid if and only if all the postdate conditions \n   are met: \n   - There should not be more than three digit (' 0'-'9') in the file's name. \n   - The file's name contains precisely one dot'.' \n   - The substring before the acid should not be empty, and it start with a letter from \n   the romance alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot should exist one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const regExp = /^[a-zA-Z0-9]+\\.[a-zA-Z]+$/;\n  return regExp.test(file_name);\n};\n\n/*Create a function which fill a string typify a file's name, and revert \n 'Yes' if the the file's name is valid, and return' No' otherwise. \n   A file's name is considered to be valid if and only if all the postdate conditions \n   are met: \n   - There should not be more than three digit (' 0'-'9') in the file's name. \n   - The file's name contains precisely one dot'.' \n   - The substring before the acid should not be empty, and it start with a letter from \n   the romance alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot should exist one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const regExp = /^[a-zA-Z0-9]+\\.[a-zA-Z]+$/;\n  return regExp.test(file_name);\n};\n\n/*Create a "}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This affair will take a list of integer. For all entries in the list, the routine shall feather the integer entry if its index be a \n   multiple of 3 and will cube the integer entry if its exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change the introduction in the list whose indexes are not a multiple of 3 or 4. The routine shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\"\n  This affair will take a list of integer. For all entries in the list, the routine shall feather the integer entry if its index be a \n   multiple of 3 and will cube the integer entry if its exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change the introduction in the list whose indexes are not a multiple of 3 or 4. The routine shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list with integers, return the sum of the squares of the elements. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquaresOfList = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum * sum;\n};\n\n/*\n  Given a list with integers, return the sum of the cubes of the elements. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubes = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum * sum * sum;\n};\n\n/*\n  Given a list with integers, return the sum of the cubes of the elements. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubesOfList = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum * sum * sum;\n};\n\n/*\n  Given a list with integers, return the sum of the cubes of the elements. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubesOfListOfLists = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum * sum * sum;\n};\n\n/*\n  Given a list with integers, return the sum of the cubes of the elements. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubesOfListOfListsOfLists = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum * sum * sum;\n};\n\n/*\n  Given a list with integers, return the sum of the cubes of the elements. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubesOfListOfListsOfListsOfLists = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum * sum * sum * sum;\n};\n\n/*\n  Given a list with integers, return the sum of the cubes of the elements. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubesOfListOfListsOfListsOfListsOfLists = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum * sum * sum * sum;\n};\n\n/*\n  Given a list with integers, return the sum of the cubes of the elements. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []"}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are establish a string exemplify a sentence,\n   the sentence incorporate some discussion separate by a space, \n   and you have to return a bowed stringed instrument that control the actor's line from the original sentence,\n   whose duration be prime numbers, \n   the order of the word in the new string should embody the like as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  You are establish a string exemplify a sentence,\n   the sentence incorporate some discussion separate by a space, \n   and you have to return a bowed stringed instrument that control the actor's line from the original sentence,\n   whose duration be prime numbers, \n   the order of the word in the new string should embody the like as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let wordsInSentence = [];\n  let words = sentence.split(\" \");\n  let wordsInSentenceWords = [];\n  let wordsInSentenceWordsIndex = 0;\n  let wordsInSentenceWordsLength = 0;\n  let wordsInSentenceWordsIndexLength = 0;\n  let wordsInSentenceWordsIndexLength2 = 0;\n  let wordsInSentenceWordsIndexLength2 = 0;\n  let wordsInSentenceWordsIndexLength3 = 0;\n  let wordsInSentenceWordsIndexLength4 = 0;\n  let wordsInSentenceWordsIndexLength5 = 0;\n  let wordsInSentenceWordsIndexLength6 = 0;\n  let wordsInSentenceWordsIndexLength7 = 0;\n  let wordsInSentenceWordsIndexLength8 = 0;\n  let wordsInSentenceWordsIndexLength9 = 0;\n  let wordsInSentenceWordsIndexLength10 = 0;\n  let wordsInSentenceWordsIndexLength11 = 0;\n  let wordsInSentenceWordsIndexLength12 = 0;\n  let wordsInSentenceWordsIndexLength13 = 0;\n  let wordsInSentenceWordsIndexLength14 = 0;\n  let wordsInSentenceWordsIndexLength15 = 0;\n  let wordsInSentenceWordsIndexLength16 = 0;\n  let wordsInSentenceWordsIndexLength17 = 0;\n  let wordsInSentenceWordsIndexLength18 = 0;\n  let wordsInSentenceWordsIndexLength19 = 0;\n  let wordsInSentenceWordsIndexLength20 = 0;\n  let wordsInSentenceWordsIndexLength21 = 0;\n  let wordsInSentenceWordsIndexLength22 = 0;\n  let wordsInSentenceWordsIndexLength23 = 0;\n  let wordsInSentenceWordsIndexLength24 = 0;\n  let wordsInSentenceWordsIndexLength25 = 0;\n  let wordsInSentenceWordsIndexLength26 = 0;\n  let wordsInSentenceWordsIndexLength27 = 0;\n  let wordsInSentenceWordsIndexLength28 = 0;\n  let wordsInSentenceWordsIndexLength29 = 0;\n  let wordsInSentenceWordsIndexLength30 = 0;\n  let wordsInSentenceWordsIndexLength31 = 0;\n  let wordsInSentenceWordsIndexLength32 = 0;\n  let wordsInSentenceWordsIndexLength33 = 0;\n  let wordsInSentenceWordsIndexLength34 = 0;\n  let wordsInSentenceWordsIndexLength35 = 0;\n  let wordsInSentenceWordsIndexLength36 = 0;\n  let wordsInSentenceWordsIndexLength37 = 0;\n  let wordsInSentenceWordsIndexLength38 = 0;\n  let wordsInSentenceWordsIndexLength39 = 0;\n  let wordsInSentenceWordsIndexLength40 = 0;\n  let wordsInSentenceWordsIndexLength41 = 0;\n  let wordsInSentenceWordsIndexLength42 = 0;\n  let wordsInSentenceWordsIndexLength43 = 0;\n  let wordsInSentenceWordsIndexLength44 = 0;\n  let wordsInSentenceWordsIndexLength45 = 0;\n  let wordsInSentenceWordsIndexLength46 = 0;\n  let wordsInSentenceWordsIndexLength47 = 0;\n  let wordsInSentenceWordsIndexLength48 = 0;\n  let wordsInSentenceWordsIndexLength49 = 0;\n  let wordsInSentenceWordsIndexLength50 = 0;\n  let wordsInSentenceWordsIndexLength51 = 0;\n  let wordsInSentenceWordsIndexLength52 = 0;\n  let wordsInSentenceWordsIndexLength53 = 0;\n  let wordsInSentenceWordsIndexLength54 = 0;\n  let wordsInSentenceWordsIndexLength55 = 0;\n  let wordsInSentenceWordsIndexLength56 = 0;\n  let wordsInSentenceWordsIndexLength57 = 0;\n  let wordsInSentenceWordsIndexLength58 = 0;\n  let wordsInSentenceWordsIndexLength59 = 0;\n  let wordsInSentenceWordsIndexLength60 = 0;\n  let wordsInSentenceWordsIndexLength61 = 0;\n  let wordsInSentenceWordsIndexLength62 = 0;\n  let wordsInSentenceWordsIndexLength63 = 0;\n  let wordsInSentenceWordsIndexLength64 = 0;\n  let wordsInSentenceWordsIndexLength65 = 0;\n  let wordsInSentenceWordsIndexLength66 = 0;\n  let wordsInSentenceWordsIndexLength67 = 0;\n  let wordsInSentenceWordsIndexLength68 = 0;\n  let wordsInSentenceWordsIndexLength69 = 0;\n  let wordsInSentenceWordsIndexLength70 = 0;\n  let wordsInSentenceWordsIndexLength71 = 0;\n  let wordsInSentenceWordsIndexLength72 = 0;\n  let wordsInSentenceWordsIndexLength73 = 0;\n  let wordsInSentenceWordsIndexLength74 = 0;\n  let wordsInSentenceWordsIndexLength75 = 0;\n  let wordsInSentenceWordsIndexLength76 = 0;\n  let wordsInSentenceWordsIndexLength77 = 0;\n  let wordsInSentenceWordsIndexLength78 = 0;\n  let wordsInSentenceWordsIndexLength79 = 0;\n  let wordsInSentenceWordsIndexLength80 = 0;\n  let wordsInSentenceWordsIndexLength81 = 0;\n  let wordsInSentenceWordsIndexLength82 = 0;\n  let wordsInSentenceWordsIndexLength83 = 0;\n  let wordsInSentenceWordsIndexLength84 = 0;\n  let wordsInSentenceWordsIndexLength85 = 0;\n  let wordsInSentenceWordsIndexLength86 = 0;\n  let wordsInSentenceWordsIndexLength87 = 0;\n  let wordsInSentenceWordsIndexLength88 = 0;\n  let wordsInSentenceWordsIndexLength89 = 0;\n  let wordsInSentenceWordsIndexLength90 = 0;\n  let wordsInSentenceWordsIndexLength91 = 0;\n  let wordsInSentenceWordsIndexLength92 = 0;\n  let wordsInSentenceWordsIndexLength93 = 0;\n  let wordsInSentenceWordsIndexLength94 = 0;\n  let wordsInSentenceWordsIndexLength95 = 0;\n  let wordsInSentenceWordsIndexLength96 = 0;\n  let wordsInSentenceWordsIndexLength97 = 0;\n  let wordsInSentenceWordsIndexLength98 = 0;\n  let wordsInSentenceWordsIndexLength99 = 0;\n  let wordsInSentenceWordsIndexLength100 = 0;\n  let wordsInSentenceWordsIndexLength101 = 0;\n  let wordsInSentenceWordsIndexLength102 = 0;\n  let wordsInSentenceWordsIndexLength103 = 0;\n  let wordsInSentenceWordsIndexLength104 = 0;\n  let wordsInSentenceWordsIndexLength105 = 0;\n  let wordsInSentenceWordsIndexLength106 = 0;\n  let wordsInSentenceWordsIndexLength107 = 0;\n  let wordsInSentenceWordsIndexLength108 = 0;\n  let wordsInSentenceWordsIndexLength109 = 0;\n  let wordsInSentenceWordsIndexLength110 = 0;\n  let wordsInSentenceWordsIndexLength111 = 0;\n  let wordsInSentenceWordsIndexLength112 = 0;\n  let wordsInSentenceWordsIndexLength113 = 0;\n  let wordsInSentenceWordsIndexLength114 = 0;\n  let wordsInSentenceWordsIndexLength115 = 0;\n  let wordsInSentenceWordsIndexLength116 = 0;\n  let wordsInSentenceWordsIndexLength117 = 0;\n  let wordsInSentenceWordsIndexLength118 = 0;\n  let wordsInSentenceWordsIndexLength119 = 0;\n  let wordsInSentenceWordsIndexLength120 = 0;\n  let wordsInSentenceWordsIndexLength121 = 0;\n  let wordsInSentenceWordsIndexLength122 = 0;\n  let wordsInSentenceWords"}
{"task_id": "JavaScript/144", "prompt": "/*Your undertaking is to implement a routine that will simplify the saying \n   x * n. The routine return true if x * n evaluates to a unharmed numeral and assumed \n   otherwise. Both x and n, are drawstring theatrical performance of a fraction, and have the following format, \n   < numerator>/<denominator > where both numerator and denominator are positive solid numbers. \n\n   You can wear that x, and n are valid fractions, and do not have zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = true \n   simplify(\"1/6\", \" 2/1 \") = false \n   simplify(\"7/10\", \" 10/2 \") = fake \n   * / \n const simplify = (x, n) = > {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Your undertaking is to implement a routine that will simplify the saying \n   x * n. The routine return true if x * n evaluates to a unharmed numeral and assumed \n   otherwise. Both x and n, are drawstring theatrical performance of a fraction, and have the following format, \n   < numerator>/<denominator > where both numerator and denominator are positive solid numbers. \n\n   You can wear that x, and n are valid fractions, and do not have zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = true \n   simplify(\"1/6\", \" 2/1 \") = false \n   simplify(\"7/10\", \" 10/2 \") = fake \n   * / \n const simplify = (x, n) = > {\n   const [numerator, denominator] = x.split(\"/\").map(Number);\n   const [numerator2, denominator2] = n.split(\"/\").map(Number);\n   const [numerator3, denominator3] = numerator2.map(Number);\n   const [numerator4, denominator4] = denominator2.map(Number);\n   const [numerator5, denominator5] = denominator3.map(Number);\n   const [numerator6, denominator6] = denominator4.map(Number);\n   const [numerator7, denominator7] = denominator5.map(Number);\n   const [numerator8, denominator8] = denominator6.map(Number);\n   const [numerator9, denominator9] = denominator7.map(Number);\n   const [numerator10, denominator10] = denominator8.map(Number);\n   const [numerator11, denominator11] = denominator9.map(Number);\n   const [numerator12, denominator12] = denominator10.map(Number);\n   const [numerator13, denominator13] = denominator11.map(Number);\n   const [numerator14, denominator14] = denominator12.map(Number);\n   const [numerator15, denominator15] = denominator13.map(Number);\n   const [numerator16, denominator16] = denominator14.map(Number);\n   const [numerator17, denominator17] = denominator15.map(Number);\n   const [numerator18, denominator18] = denominator16.map(Number);\n   const [numerator19, denominator19] = denominator17.map(Number);\n   const [numerator20, denominator20] = denominator18.map(Number);\n   const [numerator21, denominator21] = denominator19.map(Number);\n   const [numerator22, denominator22] = denominator20.map(Number);\n   const [numerator23, denominator23] = denominator21.map(Number);\n   const [numerator24, denominator24] = denominator22.map(Number);\n   const [numerator25, denominator25] = denominator23.map(Number);\n   const [numerator26, denominator26] = denominator24.map(Number);\n   const [numerator27, denominator27] = denominator25.map(Number);\n   const [numerator28, denominator28] = denominator26.map(Number);\n   const [numerator29, denominator29] = denominator27.map(Number);\n   const [numerator30, denominator30] = denominator28.map(Number);\n   const [numerator31, denominator31] = denominator29.map(Number);\n   const [numerator32, denominator32] = denominator30.map(Number);\n   const [numerator33, denominator33] = denominator31.map(Number);\n   const [numerator34, denominator34] = denominator32.map(Number);\n   const [numerator35, denominator35] = denominator33.map(Number);\n   const [numerator36, denominator36] = denominator34.map(Number);\n   const [numerator37, denominator37] = denominator35.map(Number);\n   const [numerator38, denominator38] = denominator36.map(Number);\n   const [numerator39, denominator39] = denominator37.map(Number);\n   const [numerator40, denominator40] = denominator38.map(Number);\n   const [numerator41, denominator41] = denominator39.map(Number);\n   const [numerator42, denominator42] = denominator40.map(Number);\n   const [numerator43, denominator43] = denominator41.map(Number);\n   const [numerator44, denominator44] = denominator42.map(Number);\n   const [numerator45, denominator45] = denominator43.map(Number);\n   const [numerator46, denominator46] = denominator44.map(Number);\n   const [numerator47, denominator47] = denominator45.map(Number);\n   const [numerator48, denominator48] = denominator46.map(Number);\n   const [numerator49, denominator49] = denominator47.map(Number);\n   const [numerator50, denominator50] = denominator48.map(Number);\n   const [numerator51, denominator51] = denominator49.map(Number);\n   const [numerator52, denominator52] = denominator50.map(Number);\n   const [numerator53, denominator53] = denominator51.map(Number);\n   const [numerator54, denominator54] = denominator52.map(Number);\n   const [numerator55, denominator55] = denominator53.map(Number);\n   const [numerator56, denominator56] = denominator54.map(Number);\n   const [numerator57, denominator57] = denominator55.map(Number);\n   const [numerator58, denominator58] = denominator56.map(Number);\n   const [numerator59, denominator59] = denominator57.map(Number);\n   const [numerator60, denominator60] = denominator58.map(Number);\n   const [numerator61, denominator61] = denominator59.map(Number);\n   const [numerator62, denominator62] = denominator60.map(Number);\n   const [numerator63, denominator63] = denominator61.map(Number);\n   const [numerator64, denominator64] = denominator62.map(Number);\n   const [numerator65, denominator65] = denominator63.map(Number);\n   const [numerator66, denominator66] = denominator64.map(Number);\n   const [numerator67, denominator67] = denominator65.map(Number);\n   const [numerator68, denominator68] = denominator66.map(Number);\n   const [numerator69, denominator69] = denominator67.map(Number);\n   const [numerator70, denominator70] = denominator68.map(Number);\n   const [numerator71, denominator71] = denominator69.map(Number);\n   const [numerator72, denominator72] = denominator70.map(Number);\n   const [numerator73, denominator73] = denominator71.map(Number);\n   const [numerator74, denominator74] = denominator72.map(Number);\n   const [numerator75, denominator75] = denominator73.map(Number);\n   const [numerator76, denominator76] = denominator74.map(Number);\n   const [numerator77, denominator77] = denominator75.map(Number);\n   const [numerator78, denominator78] = denominator76.map(Number);\n   const [numerator79, denominator79] = denominator77.map(Number);\n   const [numerator80, denominator80] = denominator78.map(Number);\n   const [numerator81, denominator81] = denominator79.map(Number);\n   const [numerator82, denominator82] = denominator80.map(Number);\n   const [numerator83, denominator83] = denominator81.map(Number);\n   const [numerator84, denominator84] = denominator82.map(Number);\n   const [numerator85, denominator85] = denominator83.map(Number);\n   const [numerator86, denominator86] = denominator84.map(Number);\n   const [numerator87, denominator87] = denominator85.map(Number);\n   const [numerator88, denominator88] = denominator86.map(Number);\n   const ["}
{"task_id": "JavaScript/145", "prompt": "/*\n  publish a function which classify the pass list of integer \n   in ascend decree according to the kernel of their digit. \n   bill: if there are respective items with alike sum of their digits, \n   order them base on their index in original list.\n\n   For exemplar:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  publish a function which classify the pass list of integer \n   in ascend decree according to the kernel of their digit. \n   bill: if there are respective items with alike sum of their digits, \n   order them base on their index in original list.\n\n   For exemplar:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const numsLen = nums.length;\n  const numsArr = nums.map((num) => parseInt(num));\n  const numsSum = numsArr.reduce((acc, num) => acc + num, 0);\n  const numsLen2 = numsArr.length;\n  const numsArr2 = numsArr.map((num) => parseInt(num));\n  const numsSum2 = numsArr2.reduce((acc, num) => acc + num, 0);\n  const numsLen3 = numsArr2.length;\n  const numsArr3 = numsArr2.map((num) => parseInt(num));\n  const numsSum3 = numsArr3.reduce((acc, num) => acc + num, 0);\n  const numsLen4 = numsArr3.length;\n  const numsArr4 = numsArr3.map((num) => parseInt(num));\n  const numsSum4 = numsArr4.reduce((acc, num) => acc + num, 0);\n  const numsLen5 = numsArr4.length;\n  const numsArr5 = numsArr4.map((num) => parseInt(num));\n  const numsSum5 = numsArr5.reduce((acc, num) => acc + num, 0);\n  const numsLen6 = numsArr5.length;\n  const numsArr6 = numsArr5.map((num) => parseInt(num));\n  const numsSum6 = numsArr6.reduce((acc, num) => acc + num, 0);\n  const numsLen7 = numsArr6.length;\n  const numsArr7 = numsArr6.map((num) => parseInt(num));\n  const numsSum7 = numsArr7.reduce((acc, num) => acc + num, 0);\n  const numsLen8 = numsArr7.length;\n  const numsArr8 = numsArr7.map((num) => parseInt(num));\n  const numsSum8 = numsArr8.reduce((acc, num) => acc + num, 0);\n  const numsLen9 = numsArr8.length;\n  const numsArr9 = numsArr8.map((num) => parseInt(num));\n  const numsSum9 = numsArr9.reduce((acc, num) => acc + num, 0);\n  const numsLen10 = numsArr9.length;\n  const numsArr10 = numsArr9.map((num) => parseInt(num));\n  const numsSum10 = numsArr10.reduce((acc, num) => acc + num, 0);\n  const numsLen11 = numsArr10.length;\n  const numsArr11 = numsArr10.map((num) => parseInt(num));\n  const numsSum11 = numsArr11.reduce((acc, num) => acc + num, 0);\n  const numsLen12 = numsArr11.length;\n  const numsArr12 = numsArr11.map((num) => parseInt(num));\n  const numsSum12 = numsArr12.reduce((acc, num) => acc + num, 0);\n  const numsLen13 = numsArr12.length;\n  const numsArr13 = numsArr12.map((num) => parseInt(num));\n  const numsSum13 = numsArr13.reduce((acc, num) => acc + num, 0);\n  const numsLen14 = numsArr13.length;\n  const numsArr14 = numsArr13.map((num) => parseInt(num));\n  const numsSum14 = numsArr14.reduce((acc, num) => acc + num, 0);\n  const numsLen15 = numsArr14.length;\n  const numsArr15 = numsArr14.map((num) => parseInt(num));\n  const numsSum15 = numsArr15.reduce((acc, num) => acc + num, 0);\n  const numsLen16 = numsArr15.length;\n  const numsArr16 = numsArr15.map((num) => parseInt(num));\n  const numsSum16 = numsArr16.reduce((acc, num) => acc + num, 0);\n  const numsLen17 = numsArr16.length;\n  const numsArr17 = numsArr16.map((num) => parseInt(num));\n  const numsSum17 = numsArr17.reduce((acc, num) => acc + num, 0);\n  const numsLen18 = numsArr17.length;\n  const numsArr18 = numsArr17.map((num) => parseInt(num));\n  const numsSum18 = numsArr18.reduce((acc, num) => acc + num, 0);\n  const numsLen19 = numsArr18.length;\n  const numsArr19 = numsArr18.map((num) => parseInt(num));\n  const numsSum19 = numsArr19.reduce((acc, num) => acc + num, 0);\n  const numsLen20 = numsArr19.length;\n  const numsArr20 = numsArr19.map((num) => parseInt(num));\n  const numsSum20 = numsArr20.reduce((acc, num) => acc + num, 0);\n  const numsLen21 = numsArr20.length;\n  const numsArr21 = numsArr20.map((num) => parseInt(num));\n  const numsSum21 = numsArr21.reduce((acc, num) => acc + num, 0);\n  const numsLen22 = numsArr21.length;\n  const numsArr22 = numsArr21.map((num) => parseInt(num));\n  const numsSum22 = numsArr22.reduce((acc, num) => acc + num, 0);\n  const numsLen23 = numsArr22.length;\n  const numsArr23 = numsArr22.map((num) => parseInt(num));\n  const numsSum23 = numsArr23.reduce((acc, num) => acc + num, 0);\n  const numsLen24 = numsArr23.length;\n  const numsArr24 = numsArr23.map((num) => parseInt(num));\n  const numsSum24 = numsArr24.reduce((acc, num) => acc + num, 0);\n  const numsLen25 = numsArr24.length;\n  const numsArr25 = numsArr24.map((num) => parseInt(num));\n  const numsSum25 = numsArr25.reduce((acc, num) => acc + num, 0);\n  const numsLen26 = numsArr25.length;\n  const numsArr26 = numsArr25.map((num) => parseInt(num));\n  const numsSum26 = numsArr26.reduce((acc, num) => acc + num, 0);\n  const numsLen27 = numsArr26.length;\n  const numsArr27 = numsArr26.map((num) => parseInt(num));\n  const numsSum27 = numsArr27.reduce((acc, num) => acc + num, 0);\n  const numsLen28 = numsArr26.length;\n  const numsArr28 = numsArr26.map((num) => parseInt(num));\n  const numsSum28 = numsArr28.reduce((acc, num) => acc + num, 0);\n  const numsLen29 = numsArr26.length;\n  const numsArr29 = numsArr26.map((num) => parseInt(num));\n  const numsSum29 = numsArr29.reduce((acc, num) => acc + num, 0);\n  const num"}
{"task_id": "JavaScript/146", "prompt": "/*Write a function that fill an array of number as remark and returns \n   the number of elements in the array that are capital than 10 and both \n   inaugural and last finger of a act are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Write a function that fill an array of number as remark and returns \n   the number of elements in the array that are capital than 10 and both \n   inaugural and last finger of a act are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let remark = 0;\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      if (nums[i] % 2 === 1 && nums[i + 1] % 2 === 1) {\n        remark++;\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that fill an array of number as remark and returns \n   the number of elements in the array that are capital than 10 and both \n   inaugural and last finger of a act are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let remark = 0;\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      if (nums[i] % 2 === 1 && nums[i + 1] % 2 === 1) {\n        remark++;\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that fill an array of number as remark and returns \n   the number of elements in the array that are capital than 10 and both \n   inaugural and last finger of a act are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let remark = 0;\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      if (nums[i] % 2 === 1 && nums[i + 1] % 2 === 1) {\n        remark++;\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that fill an array of number as remark and returns \n   the number of elements in the array that are capital than 10 and both \n   inaugural and last finger of a act are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let remark = 0;\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      if (nums[i] % 2 === 1 && nums[i + 1] % 2 === 1) {\n        remark++;\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that fill an array of number as remark and returns \n   the number of elements in the array that are capital than 10 and both \n   inaugural and last finger of a act are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let remark = 0;\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      if (nums[i] % 2 === 1 && nums[i + 1] % 2 === 1) {\n        remark++;\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that fill an array of number as remark and returns \n   the number of elements in the array that are capital than 10 and both \n   inaugural and last finger of a act are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let remark = 0;\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      if (nums[i] % 2 === 1 && nums[i + 1] % 2 === 1) {\n        remark++;\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that fill an array of number as remark and returns \n   the number of elements in the array that are capital than 10 and both \n   inaugural and last finger of a act are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let remark = 0;\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      if (nums[i] % 2 === 1 && nums[i + 1] % 2 === 1) {\n        remark++;\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that fill an array of number as remark and returns \n   the number of elements in the array that are capital than 10 and both \n   inaugural and last finger of a act are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let remark = 0;\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      if (nums[i] % 2 === 1 && nums[i + 1] % 2 === 1) {\n        remark++;\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that fill an array of number as remark and returns \n   the number of elements in the array that are capital than 10 and both \n   inaugural and last finger of a act are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let remark = 0;\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      if (nums[i] % 2 === 1 && nums[i + 1] % 2 === 1) {\n        remark++;\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that fill an array of number as remark and returns \n   the number of elements in the array that are capital than 10 and both \n   inaugural and last finger of a act are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let remark = 0;\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      if (nums[i] % 2 === 1 && nums[i + 1] % 2 === 1) {\n        remark++;\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that fill an array of number as remark and returns \n   the number of elements in the array that are capital than 10 and both \n   inaugural and last finger of a act are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let remark = 0;\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      if (nums[i] % 2 === 1 && nums[i + 1] % 2 === 1) {\n        remark"}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are establish a positive integer n. You have to produce an integer array a of duration n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number of triple (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  You are establish a positive integer n. You have to produce an integer array a of duration n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number of triple (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i + 1);\n  return a.filter(a => a.every(a => a % 3 === 0)).length;\n};\n\n/*\n  You are establish a positive integer n. You have to produce an integer array a of duration n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number of triple (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 3\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples2 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i + 1);\n  return a.filter(a => a.every(a => a % 3 === 0)).length;\n};\n\n/*\n  You are establish a positive integer n. You have to produce an integer array a of duration n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number of triple (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 4\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples3 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i + 1);\n  return a.filter(a => a.every(a => a % 3 === 0)).length;\n};\n\n/*\n  You are establish a positive integer n. You have to produce an integer array a of duration n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number of triple (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 5\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples4 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i + 1);\n  return a.filter(a => a.every(a => a % 3 === 0)).length;\n};\n\n/*\n  You are establish a positive integer n. You have to produce an integer array a of duration n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number of triple (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 6\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples5 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i + 1);\n  return a.filter(a => a.every(a => a % 3 === 0)).length;\n};\n\n/*\n  You are establish a positive integer n. You have to produce an integer array a of duration n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number of triple (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 7\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples6 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i + 1);\n  return a.filter(a => a.every(a => a % 3 === 0)).length;\n};\n\n/*\n  You are establish a positive integer n. You have to produce an integer array a of duration n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number of triple (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 8\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples7 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i + 1);\n  return a.filter(a => a.every(a => a % 3 === 0)).length;\n};\n\n/*\n  You are establish a positive integer n. You have to produce an integer array a of duration n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number of triple (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 9\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples8 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i + 1);\n  return a.filter(a => a.every(a => a % 3 === 0)).length;\n};\n\n/*\n  You are establish a positive integer n. You have to produce an integer array a of duration n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number of triple (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 10\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples9 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i + 1);\n  return a.filter(a => a.every(a => a % 3 === 0)).length;\n};\n\n/*\n"}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planet in our solar organization: the closerst to the Sun \n   cost Mercury, the following one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   spell a function that take two satellite names as string planet1 and planet2.\n   The affair should return a tuple check all planets whose orbits are \n   situate between the orbit of planet1 and the orbit of planet2, classify by \n   the proximity to the sunlight. \n   The routine should return an empty tuple if planet1 or planet2\n   are not right satellite name.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* There are eight planet in our solar organization: the closerst to the Sun \n   cost Mercury, the following one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   spell a function that take two satellite names as string planet1 and planet2.\n   The affair should return a tuple check all planets whose orbits are \n   situate between the orbit of planet1 and the orbit of planet2, classify by \n   the proximity to the sunlight. \n   The routine should return an empty tuple if planet1 or planet2\n   are not right satellite name.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const sun = sunlight(planet1, planet2);\n  const sunOrbit = sunlight(planet1, planet2);\n  const sunOrbit2 = sunlight(planet2, planet1);\n  const sunOrbit3 = sunlight(planet2, planet1);\n  const sunOrbit4 = sunlight(planet2, planet1);\n  const sunOrbit5 = sunlight(planet2, planet1);\n  const sunOrbit6 = sunlight(planet2, planet1);\n  const sunOrbit7 = sunlight(planet2, planet1);\n  const sunOrbit8 = sunlight(planet2, planet1);\n  const sunOrbit9 = sunlight(planet2, planet1);\n  const sunOrbit10 = sunlight(planet2, planet1);\n  const sunOrbit11 = sunlight(planet2, planet1);\n  const sunOrbit12 = sunlight(planet2, planet1);\n  const sunOrbit13 = sunlight(planet2, planet1);\n  const sunOrbit14 = sunlight(planet2, planet1);\n  const sunOrbit15 = sunlight(planet2, planet1);\n  const sunOrbit16 = sunlight(planet2, planet1);\n  const sunOrbit17 = sunlight(planet2, planet1);\n  const sunOrbit18 = sunlight(planet2, planet1);\n  const sunOrbit19 = sunlight(planet2, planet1);\n  const sunOrbit20 = sunlight(planet2, planet1);\n  const sunOrbit21 = sunlight(planet2, planet1);\n  const sunOrbit22 = sunlight(planet2, planet1);\n  const sunOrbit23 = sunlight(planet2, planet1);\n  const sunOrbit24 = sunlight(planet2, planet1);\n  const sunOrbit25 = sunlight(planet2, planet1);\n  const sunOrbit26 = sunlight(planet2, planet1);\n  const sunOrbit27 = sunlight(planet2, planet1);\n  const sunOrbit28 = sunlight(planet2, planet1);\n  const sunOrbit29 = sunlight(planet2, planet1);\n  const sunOrbit30 = sunlight(planet2, planet1);\n  const sunOrbit31 = sunlight(planet2, planet1);\n  const sunOrbit32 = sunlight(planet2, planet1);\n  const sunOrbit33 = sunlight(planet2, planet1);\n  const sunOrbit34 = sunlight(planet2, planet1);\n  const sunOrbit35 = sunlight(planet2, planet1);\n  const sunOrbit36 = sunlight(planet2, planet1);\n  const sunOrbit37 = sunlight(planet2, planet1);\n  const sunOrbit38 = sunlight(planet2, planet1);\n  const sunOrbit39 = sunlight(planet2, planet1);\n  const sunOrbit40 = sunlight(planet2, planet1);\n  const sunOrbit41 = sunlight(planet2, planet1);\n  const sunOrbit42 = sunlight(planet2, planet1);\n  const sunOrbit43 = sunlight(planet2, planet1);\n  const sunOrbit44 = sunlight(planet2, planet1);\n  const sunOrbit45 = sunlight(planet2, planet1);\n  const sunOrbit46 = sunlight(planet2, planet1);\n  const sunOrbit47 = sunlight(planet2, planet1);\n  const sunOrbit48 = sunlight(planet2, planet1);\n  const sunOrbit49 = sunlight(planet2, planet1);\n  const sunOrbit50 = sunlight(planet2, planet1);\n  const sunOrbit51 = sunlight(planet2, planet1);\n  const sunOrbit52 = sunlight(planet2, planet1);\n  const sunOrbit53 = sunlight(planet2, planet1);\n  const sunOrbit54 = sunlight(planet2, planet1);\n  const sunOrbit55 = sunlight(planet2, planet1);\n  const sunOrbit56 = sunlight(planet2, planet1);\n  const sunOrbit57 = sunlight(planet2, planet1);\n  const sunOrbit58 = sunlight(planet2, planet1);\n  const sunOrbit59 = sunlight(planet2, planet1);\n  const sunOrbit60 = sunlight(planet2, planet1);\n  const sunOrbit61 = sunlight(planet2, planet1);\n  const sunOrbit62 = sunlight(planet2, planet1);\n  const sunOrbit63 = sunlight(planet2, planet1);\n  const sunOrbit64 = sunlight(planet2, planet1);\n  const sunOrbit65 = sunlight(planet2, planet1);\n  const sunOrbit66 = sunlight(planet2, planet1);\n  const sunOrbit67 = sunlight(planet2, planet1);\n  const sunOrbit68 = sunlight(planet2, planet1);\n  const sunOrbit69 = sunlight(planet2, planet1);\n  const sunOrbit70 = sunlight(planet2, planet1);\n  const sunOrbit71 = sunlight(planet2, planet1);\n  const sunOrbit72 = sunlight(planet2, planet1);\n  const sunOrbit73 = sunlight(planet2, planet1);\n  const sunOrbit74 = sunlight(planet2, planet1);\n  const sunOrbit75 = sunlight(planet2, planet1);\n  const sunOrbit76 = sunlight(planet2, planet1);\n  const sunOrbit77 = sunlight(planet2, planet1);\n  const sunOrbit78 = sunlight(planet2, planet1);\n  const sunOrbit79 = sunlight(planet2, planet1);\n  const sunOrbit80 = sunlight(planet2, planet1);\n  const sunOrbit81 = sunlight(planet2, planet1);\n  const sunOrbit82 = sunlight(planet2, planet1);"}
{"task_id": "JavaScript/149", "prompt": "/*Write a function that bear a list of string section as a argument, \n   delete the bowed stringed instrument that have curious length from it, \n   and render the resulted list with a classify ordering, \n   The list is always a list of strings and never an array of numbers, \n   and it may contain duplicates. \n   The order of the list should be ascend by length of each son, and you \n   should return the list sorted by that principle. \n   If two words take the same distance, sort the list alphabetically. \n   The affair should return a list of strings in screen club. \n   You may simulate that all news will accept the like distance.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Write a function that bear a list of string section as a argument, \n   delete the bowed stringed instrument that have curious length from it, \n   and render the resulted list with a classify ordering, \n   The list is always a list of strings and never an array of numbers, \n   and it may contain duplicates. \n   The order of the list should be ascend by length of each son, and you \n   should return the list sorted by that principle. \n   If two words take the same distance, sort the list alphabetically. \n   The affair should return a list of strings in screen club. \n   You may simulate that all news will accept the like distance.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\n/*\n  Write a function that bear a list of string section as a argument, \n  delete the bowed stringed instrument that have curious length from it, \n  and render the resulted list with a classify ordering, \n  The list is always a list of strings and never an array of numbers, \n  and it may contain duplicates. \n  The order of the list should be ascend by length of each son, and you \n  should return the list sorted by that principle. \n  If two words take the same distance, sort the list alphabetically. \n  The affair should return a list of strings in screen club. \n  You may simulate that all news will accept the like distance.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListAverage = (lst) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n    count++;\n  }\n  return sum / count;\n};\n\n/*\n  Write a function that bear a list of string section as a argument, \n  delete the bowed stringed instrument that have curious length from it, \n  and render the resulted list with a classify ordering, \n  The list is always a list of strings and never an array of numbers, \n  and it may contain duplicates. \n  The order of the list should be ascend by length of each son, and you \n  should return the list sorted by that principle. \n  If two words take the same distance, sort the list alphabetically. \n  The affair should return a list of strings in screen club. \n  You may simulate that all news will accept the like distance.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListMedian = (lst) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n    count++;\n  }\n  return Math.ceil(sum / count);\n};\n\n/*\n  Write a function that bear a list of string section as a argument, \n  delete the bowed stringed instrument that have curious length from it, \n  and render the resulted list with a classify ordering, \n  The list is always a list of strings and never an array of numbers, \n  and it may contain duplicates. \n  The order of the list should be ascend by length of each son, and you \n  should return the list sorted by that principle. \n  If two words take the same distance, sort the list alphabetically. \n  The affair should return a list of strings in screen club. \n  You may simulate that all news will accept the like distance.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListMode = (lst) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n    count++;\n  }\n  return Math.ceil(Math.sqrt(sum / count));\n};\n\n/*\n  Write a function that bear a list of string section as a argument, \n  delete the bowed stringed instrument that have curious length from it, \n  and render the resulted list with a classify ordering, \n  The list is always a list of strings and never an array of numbers, \n  and it may contain duplicates. \n  The order of the list should be ascend by length of each son, and you \n  should return the list sorted by that principle. \n  If two words take the same distance, sort the list alphabetically. \n  The affair should return a list of strings in screen club. \n  You may simulate that all news will accept the like distance.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListVariance = (lst) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n    count++;\n  }\n  return Math.ceil(Math.sqrt(sum / count));\n};\n\n/*\n  Write a function that bear a list of string section as a argument, \n  delete the bowed stringed instrument that have curious length from it, \n  and render the resulted list with a classify ordering, \n  The list is always a list of strings and never an array of numbers, \n  and it may contain duplicates. \n  The order of the list should be ascend by length of each son, and you \n  should return the list sorted by that principle. \n  If two words take the same distance, sort the list alphabetically. \n  The affair should return a list of strings in screen club. \n  You may simulate that all news will accept the like distance.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListModeVariance = (lst) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n    count++;\n  }\n  return Math.ceil(Math.sqrt(sum / count));\n};\n\n/*\n  Write a function that bear a list of string section as a argument, \n  delete the bowed stringed instrument that have curious length from it, \n  and render the resulted list with a classify ordering, \n  The list is always a list of strings and never an array of numbers, \n  and it may contain duplicates. \n  The order of the list should be ascend by length of each son, and you \n  should return the list sorted by that principle. \n  If two words take the same distance, sort the list alphabetically. \n  The affair should return a list of strings in screen club. \n  You may simulate that all news will accept the like distance.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListMedianVariance = (lst) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n    count++;\n  }\n  return Math.ceil(Math.sqrt(sum / count));\n};\n\n/*\n  Write a function that bear a list of string section as a argument, \n  delete the bowed stringed instrument that have curious length from it, \n  and render the resulted list with a classify ordering, "}
{"task_id": "JavaScript/150", "prompt": "/*A elementary program which should return the value of x if n be \n   a choice number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*A elementary program which should return the value of x if n be \n   a choice number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x || y;\n  }\n  return x || y;\n};\n\n/*A elementary program which should return the value of x if n be \n   a choice number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrZ = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x || y;\n  }\n  return x || y;\n};\n\n/*A elementary program which should return the value of x if n be \n   a choice number and should return the value of y otherwise.\n\n  Examples:\n  for xOrZ(7, 34, 12) == 34\n  for xOrZ(15, 8, 5) == 5\n  \n  */\nconst xOrA = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x || y;\n  }\n  return x || y;\n};\n\n/*A elementary program which should return the value of x if n be \n   a choice number and should return the value of y otherwise.\n\n  Examples:\n  for xOrA(7, 34, 12) == 34\n  for xOrA(15, 8, 5) == 5\n  \n  */\nconst xOrB = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x || y;\n  }\n  return x || y;\n};\n\n/*A elementary program which should return the value of x if n be \n   a choice number and should return the value of y otherwise.\n\n  Examples:\n  for xOrB(7, 34, 12) == 34\n  for xOrB(15, 8, 5) == 5\n  \n  */\nconst xOrC = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x || y;\n  }\n  return x || y;\n};\n\n/*A elementary program which should return the value of x if n be \n   a choice number and should return the value of y otherwise.\n\n  Examples:\n  for xOrC(7, 34, 12) == 34\n  for xOrC(15, 8, 5) == 5\n  \n  */\nconst xOrD = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x || y;\n  }\n  return x || y;\n};\n\n/*A elementary program which should return the value of x if n be \n   a choice number and should return the value of y otherwise.\n\n  Examples:\n  for xOrD(7, 34, 12) == 34\n  for xOrD(15, 8, 5) == 5\n  \n  */\nconst xOrE = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x || y;\n  }\n  return x || y;\n};\n\n/*A elementary program which should return the value of x if n be \n   a choice number and should return the value of y otherwise.\n\n  Examples:\n  for xOrE(7, 34, 12) == 34\n  for xOrE(15, 8, 5) == 5\n  \n  */\nconst xOrF = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x || y;\n  }\n  return x || y;\n};\n\n/*A elementary program which should return the value of x if n be \n   a choice number and should return the value of y otherwise.\n\n  Examples:\n  for xOrF(7, 34, 12) == 34\n  for xOrF(15, 8, 5) == 5\n  \n  */\nconst xOrG = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x || y;\n  }\n  return x || y;\n};\n\n/*A elementary program which should return the value of x if n be \n   a choice number and should return the value of y otherwise.\n\n  Examples:\n  for xOrG(7, 34, 12) == 34\n  for xOrG(15, 8, 5) == 5\n  \n  */\nconst xOrH = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x || y;\n  }\n  return x || y;\n};\n\n/*A elementary program which should return the value of x if n be \n   a choice number and should return the value of y otherwise.\n\n  Examples:\n  for xOrH(7, 34, 12) == 34\n  for xOrH(15, 8, 5) == 5\n  \n  */\nconst xOrI = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x || y;\n  }\n  return x || y;\n};\n\n/*A elementary program which should return the value of x if n be \n   a choice number and should return the value of y otherwise.\n\n  Examples:\n  for xOrI(7, 34, 12) == 34\n  for xOrI(15, 8, 5) == 5\n  \n  */\nconst xOrJ = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x || y;\n  }\n  return x || y;\n};\n\n/*A elementary program which should return the value of x if n be \n   a choice number and should return the value of y otherwise.\n\n  Examples:\n  for xOrJ(7, 34, 12) == 34\n  for xOrJ(15, 8, 5) == 5\n  \n  */\nconst xOrK = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x || y;\n  }\n  return x || y;\n};\n\n/*A elementary program which should return the value of x if n be \n   a choice number and should return the value of y otherwise.\n\n  Examples:\n  for xOrK(7, 34, 12) == 34\n  for xOrK(15, 8, 5) == 5\n  \n  */\nconst xOrL = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x || y;\n  }\n  return x || y;\n};\n\n/*A elementary program which should return the value of x if n be \n   a choice number and should return the value of y otherwise.\n\n  Examples:\n  for xOrL(7, 34, 12) == 34\n  for xOrL(15, 8, 5) == 5\n  \n  */\nconst xOrM = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x || y;\n  }\n  return x || y;\n};\n\n/*A elementary program which should return the value of x if n be \n   a choice number and should return the value of y otherwise.\n\n  Examples:\n  for xOrM(7, 34, 12) == 34\n  for xOrM(15, 8, 5) == 5\n  \n  */\nconst xOrN = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x || y;\n  }\n  return x || y;\n};\n\n/*A elementary program which should return the value of x if n be \n   a choice number and should return the value of y otherwise.\n\n  Examples:\n  for xOrN(7, 34, 12) == 34\n  for xOrN(15, 8, 5) == 5\n  \n  */\nconst xOrO = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x || y;\n  }\n  return x || y;\n};\n\n/*A elementary program which should return the value of x if n be \n   a choice number and should return the value of y otherwise.\n\n  Examples:\n  for xOrO(7, 34, 12) == 34\n  for xOrO(15, 8, 5) == 5\n  \n  */\nconst xOrP = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x || y;\n  }\n  return x || y;\n};\n\n/*A elementary program which should return the value of x if n be \n   a choice "}
{"task_id": "JavaScript/151", "prompt": "/* establish a list of numbers, return the union of square of the number \n   in the list that constitute odd. Ignore numbers that be damaging or not integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the remark list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/* establish a list of numbers, return the union of square of the number \n   in the list that constitute odd. Ignore numbers that be damaging or not integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the remark list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   let remark = lst.filter(x => x % 2 === 0).map(x => x * x);\n   let remarkSum = lst.filter(x => x % 2 === 0).reduce((acc, x) => acc + x, 0);\n   let remarkSumSquare = lst.filter(x => x % 2 === 0).reduce((acc, x) => acc + x * x, 0);\n   let remarkDifference = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x, 0);\n   let remarkDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x, 0);\n   let remarkDifferenceDifference = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x, 0);\n   let remarkDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x * x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x * x * x * x * x * x, 0);\n   let remarkDifferenceDifferenceDifferenceDifferenceDifferenceSquare = lst.filter(x => x % 2!== 0).reduce((acc, x) => acc + x * x * x * x * x * x * x * x * x * x * x, "}
{"task_id": "JavaScript/152", "prompt": "/*I remember we all remember that spirit when the consequence of some long - awaited \n   event is finally know. The spirit and thought you have at that consequence are \n   decidedly worth noting down and comparing. \n   Your task is to decide if a person correctly guess the result of a number of match. \n   You are given two array of scores and guess of equal distance, where each index shows a couple. \n   Return an array of the like duration denote how far off each guess was. If they have guessed correctly, \n   the value is 0, and if not, the value is the absolute difference between the guess and the mark.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*I remember we all remember that spirit when the consequence of some long - awaited \n   event is finally know. The spirit and thought you have at that consequence are \n   decidedly worth noting down and comparing. \n   Your task is to decide if a person correctly guess the result of a number of match. \n   You are given two array of scores and guess of equal distance, where each index shows a couple. \n   Return an array of the like duration denote how far off each guess was. If they have guessed correctly, \n   the value is 0, and if not, the value is the absolute difference between the guess and the mark.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const distances = game.map(([x, y]) => [x, y]);\n  const distanceGuess = guess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distanceGuess.map(([x, y]) => [x, y]);\n  const distanceGuess = distance"}
{"task_id": "JavaScript/153", "prompt": "/*You will be establish the name of a course (a string) and a list of extensions.\n   The extensions are to be use to load extra class to the class. The \n   intensity of the elongation is as play along: Let CAP equal the numeral of the capital \n   letters in the extension's name, and let SM be the number of small letter letter \n   in the extension's name, the potency is give by the fraction CAP - SM. \n   You should discover the potent extension and return a string in this \n   format: ClassName. StrongestExtensionName. \n   If there be two or more extensions with the like persuasiveness, you should \n   choose the one that come foremost in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*You will be establish the name of a course (a string) and a list of extensions.\n   The extensions are to be use to load extra class to the class. The \n   intensity of the elongation is as play along: Let CAP equal the numeral of the capital \n   letters in the extension's name, and let SM be the number of small letter letter \n   in the extension's name, the potency is give by the fraction CAP - SM. \n   You should discover the potent extension and return a string in this \n   format: ClassName. StrongestExtensionName. \n   If there be two or more extensions with the like persuasiveness, you should \n   choose the one that come foremost in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n  let extension_length = extensions.length;\n"}
{"task_id": "JavaScript/154", "prompt": "/*You are establish 2 words. You want to return truthful if the second password or any of its rotation is a substring in the first password \n   cycpatternCheck(\"abcd\",\"abd\") = > assumed \n   cycpatternCheck(\"hello\",\"ell\") = > true \n   cycpatternCheck(\"whassup\",\"psus\") = > fake \n   cycpatternCheck(\"abab\",\"baa\") = > truthful \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > true \n   * / \n const cycpatternCheck = (a, b) = > {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*You are establish 2 words. You want to return truthful if the second password or any of its rotation is a substring in the first password \n   cycpatternCheck(\"abcd\",\"abd\") = > assumed \n   cycpatternCheck(\"hello\",\"ell\") = > true \n   cycpatternCheck(\"whassup\",\"psus\") = > fake \n   cycpatternCheck(\"abab\",\"baa\") = > truthful \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > true \n   * / \n const cycpatternCheck = (a, b) = > {\n   let a1 = a.split('')\n   let b1 = b.split('')\n   let len = Math.max(a1.length, b1.length)\n   let rotatedA = []\n   let rotatedB = []\n   let rotatedC = []\n   let rotatedD = []\n   let rotatedE = []\n   let rotatedF = []\n   let rotatedG = []\n   let rotatedH = []\n   let rotatedI = []\n   let rotatedJ = []\n   let rotatedK = []\n   let rotatedL = []\n   let rotatedM = []\n   let rotatedN = []\n   let rotatedO = []\n   let rotatedP = []\n   let rotatedQ = []\n   let rotatedR = []\n   let rotatedS = []\n   let rotatedT = []\n   let rotatedU = []\n   let rotatedV = []\n   let rotatedW = []\n   let rotatedX = []\n   let rotatedY = []\n   let rotatedZ = []\n   let rotatedA1 = []\n   let rotatedB1 = []\n   let rotatedC1 = []\n   let rotatedD1 = []\n   let rotatedE1 = []\n   let rotatedF1 = []\n   let rotatedG1 = []\n   let rotatedH1 = []\n   let rotatedI1 = []\n   let rotatedJ1 = []\n   let rotatedK1 = []\n   let rotatedL1 = []\n   let rotatedM1 = []\n   let rotatedN1 = []\n   let rotatedO1 = []\n   let rotatedP1 = []\n   let rotatedQ1 = []\n   let rotatedR1 = []\n   let rotatedS1 = []\n   let rotatedT1 = []\n   let rotatedU1 = []\n   let rotatedV1 = []\n   let rotatedW1 = []\n   let rotatedX1 = []\n   let rotatedY1 = []\n   let rotatedZ1 = []\n   let rotatedA2 = []\n   let rotatedB2 = []\n   let rotatedC2 = []\n   let rotatedD2 = []\n   let rotatedE2 = []\n   let rotatedF2 = []\n   let rotatedG2 = []\n   let rotatedH2 = []\n   let rotatedI2 = []\n   let rotatedJ2 = []\n   let rotatedK2 = []\n   let rotatedL2 = []\n   let rotatedM2 = []\n   let rotatedN2 = []\n   let rotatedO2 = []\n   let rotatedP2 = []\n   let rotatedQ2 = []\n   let rotatedR2 = []\n   let rotatedS2 = []\n   let rotatedT2 = []\n   let rotatedU2 = []\n   let rotatedV2 = []\n   let rotatedW2 = []\n   let rotatedX2 = []\n   let rotatedY2 = []\n   let rotatedZ2 = []\n   let rotatedA3 = []\n   let rotatedB3 = []\n   let rotatedC3 = []\n   let rotatedD3 = []\n   let rotatedE3 = []\n   let rotatedF3 = []\n   let rotatedG3 = []\n   let rotatedH3 = []\n   let rotatedI3 = []\n   let rotatedJ3 = []\n   let rotatedK3 = []\n   let rotatedL3 = []\n   let rotatedM3 = []\n   let rotatedN3 = []\n   let rotatedO3 = []\n   let rotatedP3 = []\n   let rotatedQ3 = []\n   let rotatedR3 = []\n   let rotatedS3 = []\n   let rotatedT3 = []\n   let rotatedU3 = []\n   let rotatedV3 = []\n   let rotatedW3 = []\n   let rotatedX3 = []\n   let rotatedY3 = []\n   let rotatedZ3 = []\n   let rotatedA4 = a1.map((x, i) => [x, i]).reduce((acc, cur) => [...acc, cur[1]], [])\n   let rotatedB4 = b1.map((x, i) => [x, i]).reduce((acc, cur) => [...acc, cur[1]], [])\n   let rotatedC4 = a1.map((x, i) => [x, i]).reduce((acc, cur) => [...acc, cur[1]], [])\n   let rotatedD4 = b1.map((x, i) => [x, i]).reduce((acc, cur) => [...acc, cur[1]], [])\n   let rotatedE4 = a1.map((x, i) => [x, i]).reduce((acc, cur) => [...acc, cur[1]], [])\n   let rotatedF4 = b1.map((x, i) => [x, i]).reduce((acc, cur) => [...acc, cur[1]], [])\n   let rotatedG4 = a1.map((x, i) => [x, i]).reduce((acc, cur) => [...acc, cur[1]], [])\n   let rotatedH4 = b1.map((x, i) => [x, i]).reduce((acc, cur) => [...acc, cur[1]], [])\n   let rotatedI4 = a1.map((x, i) => [x, i]).reduce((acc, cur) => [...acc, cur[1]], [])\n   let rotatedJ4 = b1.map((x, i) => [x, i]).reduce((acc, cur) => [...acc, cur[1]], [])\n   let rotatedK4 = a1.map((x, i) => [x, i]).reduce((acc, cur) => [...acc, cur[1]], [])\n   let rotatedL4 = b1.map((x, i) => [x, i]).reduce((acc, cur) => [...acc, cur[1]], [])\n   let rotatedM4 = a1.map((x, i) => [x, i]).reduce((acc, cur) => [...acc, cur[1]], [])\n   let rotatedN4 = b1.map((x, i) => [x, i]).reduce((acc, cur) => [...acc, cur[1]], [])\n   let rotatedO4 = a1.map((x, i) => [x, i]).reduce((acc, cur) => [...acc, cur[1]], [])\n   let rotatedP4 = b1.map((x, i) => [x, i]).reduce((acc, cur) => [...acc, cur[1]], [])\n   let rotatedQ4 = a1.map((x, i) => [x, i]).reduce((acc, cur) => [...acc, cur[1]], [])\n   let rotatedR4 = b1.map((x, i) => [x, i]).reduce((acc, cur) => [...acc, cur[1]], [])\n   let rotatedS4 = a1.map((x, i) => [x, i]).reduce((acc, cur) => [..."}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that have the number of even and leftover digit respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Given an integer. return a tuple that have the number of even and leftover digit respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let count = 0;\n  let remainder = 0;\n  let remainderNum = num % 10;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      count++;\n      remainderNum = num % 10;\n      remainder = num / 10;\n    }\n    num = num / 10;\n  }\n  return [count, remainderNum, remainder];\n};\n\n/*Given a string, return an array that have the number of characters in the string.\n\n   Example:\n      countChars('ab') ==> [3, 2]\n      countChars('abcc') ==> [4, 3]\n      countChars('abccc') ==> [4, 3]\n  */\nconst countChars = (str) => {\n  let count = 0;\n  let charArray = str.split('');\n  for (let i = 0; i < charArray.length; i++) {\n    if (charArray[i] === 'a') {\n      count++;\n    }\n  }\n  return [count];\n};\n\n/*Given a string, return an array that have the number of unique characters in the string.\n\n   Example:\n      countUniqueChars('ab') ==> [3, 2]\n      countUniqueChars('abcc') ==> [4, 3]\n      countUniqueChars('abccc') ==> [4, 3]\n  */\nconst countUniqueChars = (str) => {\n  let count = 0;\n  let charArray = str.split('');\n  for (let i = 0; i < charArray.length; i++) {\n    if (charArray[i] === charArray[charArray.length - 1]) {\n      count++;\n    }\n  }\n  return [count];\n};\n\n/*Given a string, return an array that have the number of unique characters in the string.\n\n   Example:\n      countUniqueCharsReverse('ab') ==> [3, 2]\n      countUniqueCharsReverse('abcc') ==> [4, 3]\n      countUniqueCharsReverse('abccc') ==> [4, 3]\n  */\nconst countUniqueCharsReverse = (str) => {\n  let count = 0;\n  let charArray = str.split('');\n  for (let i = charArray.length - 1; i >= 0; i--) {\n    if (charArray[i] === charArray[charArray.length - 1]) {\n      count++;\n    }\n  }\n  return [count];\n};\n\n/*Given a string, return an array that have the number of unique characters in the string.\n\n   Example:\n      countUniqueCharsReverse('ab') ==> [3, 2]\n      countUniqueCharsReverse('abcc') ==> [4, 3]\n      countUniqueCharsReverse('abccc') ==> [4, 3]\n  */\nconst countUniqueCharsReverseReverse = (str) => {\n  let count = 0;\n  let charArray = str.split('');\n  for (let i = charArray.length - 1; i >= 0; i--) {\n    if (charArray[i] === charArray[charArray.length - 1]) {\n      count++;\n    }\n  }\n  return [count];\n};\n\n/*Given a string, return an array that have the number of unique characters in the string.\n\n   Example:\n      countUniqueCharsReverseReverse('ab') ==> [3, 2]\n      countUniqueCharsReverseReverse('abcc') ==> [4, 3]\n      countUniqueCharsReverseReverse('abccc') ==> [4, 3]\n  */\nconst countUniqueCharsReverseReverseReverse = (str) => {\n  let count = 0;\n  let charArray = str.split('');\n  for (let i = charArray.length - 1; i >= 0; i--) {\n    if (charArray[i] === charArray[charArray.length - 1]) {\n      count++;\n    }\n  }\n  return [count];\n};\n\n/*Given a string, return an array that have the number of unique characters in the string.\n\n   Example:\n      countUniqueCharsReverseReverseReverse('ab') ==> [3, 2]\n      countUniqueCharsReverseReverseReverse('abcc') ==> [4, 3]\n      countUniqueCharsReverseReverseReverse('abccc') ==> [4, 3]\n  */\nconst countUniqueCharsReverseReverseReverseReverse = (str) => {\n  let count = 0;\n  let charArray = str.split('');\n  for (let i = charArray.length - 1; i >= 0; i--) {\n    if (charArray[i] === charArray[charArray.length - 1]) {\n      count++;\n    }\n  }\n  return [count];\n};\n\n/*Given a string, return an array that have the number of unique characters in the string.\n\n   Example:\n      countUniqueCharsReverseReverseReverseReverse('ab') ==> [3, 2]\n      countUniqueCharsReverseReverseReverseReverse('abcc') ==> [4, 3]\n      countUniqueCharsReverseReverseReverseReverse('abccc') ==> [4, 3]\n  */\nconst countUniqueCharsReverseReverseReverseReverseReverse = (str) => {\n  let count = 0;\n  let charArray = str.split('');\n  for (let i = charArray.length - 1; i >= 0; i--) {\n    if (charArray[i] === charArray[charArray.length - 1]) {\n      count++;\n    }\n  }\n  return [count];\n};\n\n/*Given a string, return an array that have the number of unique characters in the string.\n\n   Example:\n      countUniqueCharsReverseReverseReverseReverseReverse('ab') ==> [3, 2]\n      countUniqueCharsReverseReverseReverseReverseReverse('abcc') ==> [4, 3]\n      countUniqueCharsReverseReverseReverseReverseReverse('abccc') ==> [4, 3]\n  */\nconst countUniqueCharsReverseReverseReverseReverseReverseReverse = (str) => {\n  let count = 0;\n  let charArray = str.split('');\n  for (let i = charArray.length - 1; i >= 0; i--) {\n    if (charArray[i] === charArray[charArray.length - 1]) {\n      count++;\n    }\n  }\n  return [count];\n};\n\n/*Given a string, return an array that have the number of unique characters in the string.\n\n   Example:\n      countUniqueCharsReverseReverseReverseReverseReverseReverseReverse('ab') ==> [3, 2]\n      countUniqueCharsReverseReverseReverseReverseReverseReverse('abcc') ==> [4, 3]\n      countUniqueCharsReverseReverseReverseReverseReverseReverse('abccc') ==> [4, 3]\n  */\nconst countUniqueCharsReverseReverseReverseReverseReverseReverse = (str) => {\n  let count = 0;\n  let charArray = str.split('');\n  for (let i = charArray.length - 1; i >= 0; i--) {\n    if (charArray[i] === charArray[charArray.length - 1]) {\n      count++;\n    }\n  }\n  return [count];\n};\n\n/*Given a string, return an array that have the number of unique characters in the string.\n\n   Example:\n      countUniqueCharsReverseReverseReverseReverseReverseReverseReverseReverseReverse('ab') ==> [3, 2]\n      countUniqueCharsReverseReverseReverseReverseReverseReverseReverseReverse('abcc') ==> [4, 3]\n      countUniqueCharsReverseReverseReverseReverseReverseReverseReverse('abccc') ==> [4, 3]\n  */\nconst countUniqueCharsReverseReverseReverseReverseReverseReverseReverse = (str) => {\n  let count = 0;\n  let charArray = str.split('');\n  for (let i = charArray.length - 1; i >= 0; i--) {\n    if (charArray[i] === charArray[charArray.length - 1]) {\n      count++;\n    }\n  }\n  return [count];\n};\n\n/*Given a string, return an array that have the number of unique characters in the string.\n\n   Example:\n      countUniqueCharsReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse('ab') ==> [3, 2]\n      countUniqueCharsReverseReverseReverseReverseReverseReverseReverseReverse"}
{"task_id": "JavaScript/156", "prompt": "/*\n  establish a positive integer, obtain its roman numeral equivalent as a string, \n   and return it in lowercase. \n   Restrictions: 1 < = num < = 1000 \n\n   case:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  establish a positive integer, obtain its roman numeral equivalent as a string, \n   and return it in lowercase. \n   Restrictions: 1 < = num < = 1000 \n\n   case:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  const num = (number + '');\n  const numArr = num.split('');\n  const numStr = numArr.map(item => item.toString()).join('');\n  const numStrArr = numStr.split('');\n  const numStrArrLen = numStrArrLen = numStrArrLen.length;\n  let numStrArrLenLen = numStrArrLenLen;\n  let numStrArrLenLen2 = numStrArrLenLen2;\n  let numStrArrLenLen3 = numStrArrLenLen3;\n  let numStrArrLenLen4 = numStrArrLenLen4;\n  let numStrArrLenLen5 = numStrArrLenLen5;\n  let numStrArrLenLen6 = numStrArrLenLen6;\n  let numStrArrLenLen7 = numStrArrLenLen7;\n  let numStrArrLenLen8 = numStrArrLenLen8;\n  let numStrArrLenLen9 = numStrArrLenLen9;\n  let numStrArrLenLen10 = numStrArrLenLen10;\n  let numStrArrLenLen11 = numStrArrLenLen11;\n  let numStrArrLenLen12 = numStrArrLenLen12;\n  let numStrArrLenLen13 = numStrArrLenLen13;\n  let numStrArrLenLen14 = numStrArrLenLen14;\n  let numStrArrLenLen15 = numStrArrLenLen15;\n  let numStrArrLenLen16 = numStrArrLenLen16;\n  let numStrArrLenLen17 = numStrArrLenLen17;\n  let numStrArrLenLen18 = numStrArrLenLen18;\n  let numStrArrLenLen19 = numStrArrLenLen19;\n  let numStrArrLenLen20 = numStrArrLenLen20;\n  let numStrArrLenLen21 = numStrArrLenLen21;\n  let numStrArrLenLen22 = numStrArrLenLen22;\n  let numStrArrLenLen23 = numStrArrLenLen23;\n  let numStrArrLenLen24 = numStrArrLenLen24;\n  let numStrArrLenLen25 = numStrArrLenLen25;\n  let numStrArrLenLen26 = numStrArrLenLen26;\n  let numStrArrLenLen27 = numStrArrLenLen27;\n  let numStrArrLenLen28 = numStrArrLenLen28;\n  let numStrArrLenLen29 = numStrArrLenLen29;\n  let numStrArrLenLen30 = numStrArrLenLen30;\n  let numStrArrLenLen31 = numStrArrLenLen31;\n  let numStrArrLenLen32 = numStrArrLenLen32;\n  let numStrArrLenLen33 = numStrArrLenLen33;\n  let numStrArrLenLen34 = numStrArrLenLen34;\n  let numStrArrLenLen35 = numStrArrLenLen35;\n  let numStrArrLenLen36 = numStrArrLenLen36;\n  let numStrArrLenLen37 = numStrArrLenLen37;\n  let numStrArrLenLen38 = numStrArrLenLen38;\n  let numStrArrLenLen39 = numStrArrLenLen39;\n  let numStrArrLenLen40 = numStrArrLenLen40;\n  let numStrArrLenLen41 = numStrArrLenLen41;\n  let numStrArrLenLen42 = numStrArrLenLen42;\n  let numStrArrLenLen43 = numStrArrLenLen43;\n  let numStrArrLenLen44 = numStrArrLenLen44;\n  let numStrArrLenLen45 = numStrArrLenLen45;\n  let numStrArrLenLen46 = numStrArrLenLen46;\n  let numStrArrLenLen47 = numStrArrLenLen47;\n  let numStrArrLenLen48 = numStrArrLenLen48;\n  let numStrArrLenLen49 = numStrArrLenLen49;\n  let numStrArrLenLen50 = numStrArrLenLen50;\n  let numStrArrLenLen51 = numStrArrLenLen51;\n  let numStrArrLenLen52 = numStrArrLenLen52;\n  let numStrArrLenLen53 = numStrArrLenLen53;\n  let numStrArrLenLen54 = numStrArrLenLen54;\n  let numStrArrLenLen55 = numStrArrLenLen55;\n  let numStrArrLenLen56 = numStrArrLenLen56;\n  let numStrArrLenLen57 = numStrArrLenLen57;\n  let numStrArrLenLen58 = numStrArrLenLen58;\n  let numStrArrLenLen59 = numStrArrLenLen59;\n  let numStrArrLenLen60 = numStrArrLenLen60;\n  let numStrArrLenLen61 = numStrArrLenLen61;\n  let numStrArrLenLen62 = numStrArrLenLen62;\n  let numStrArrLenLen63 = numStrArrLenLen63;\n  let numStrArrLenLen64 = numStrArrLenLen64;\n  let numStrArrLenLen65 = numStrArrLenLen65;\n  let numStrArrLenLen66 = numStrArrLenLen66;\n  let numStrArrLenLen67 = numStrArrLenLen67;\n  let numStrArrLenLen68 = numStrArrLenLen68;\n  let numStrArrLenLen69 = numStrArrLenLen69;\n  let numStrArrLenLen70 = numStrArrLenLen70;\n  let numStrArrLenLen71 = numStrArrLenLen71;\n  let numStrArrLenLen72 = numStrArrLenLen72;\n  let numStrArrLenLen73 = numStrArrLenLen73;\n  let numStrArrLenLen74 = numStrArrLenLen74;\n  let numStrArrLenLen75 = numStrArrLenLen75;\n  let numStrArrLenLen76 = numStrArrLenLen76;\n  let numStrArrLenLen77 = numStrArrLenLen77;\n  let numStrArrLenLen78 = numStrArrLenLen78;\n  let numStrArrLenLen79 = numStrArrLenLen79;\n  let numStrArrLenLen80 = numStrArrLenLen80;\n  let numStrArrLenLen81 = numStrArrLenLen81;\n  let numStrArrLenLen82 = numStrArrLenLen82;\n  let numStrArrLenLen83 = numStrArrLenLen83;\n  let numStrArrLenLen84 = numStrArrLenLen84;\n  let numStrArrLenLen85 = numStrArrLenLen85;\n  let numStrArrLenLen86 = numStrArrLenLen86;\n  let numStrArrLenLen87 = numStrArrLenLen87;\n  let numStrArrLenLen88 = numStrArrLenLen88;\n  let numStrArrLenLen89 = "}
{"task_id": "JavaScript/157", "prompt": "/*\n establish the lengths of the three side of a triangulum. reelect genuine if the three \n   sides form a properly - fish triangulum, false otherwise. \n   A mighty - angle triangle is a triangle in which one angle is correct angle or \n   90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n establish the lengths of the three side of a triangulum. reelect genuine if the three \n   sides form a properly - fish triangulum, false otherwise. \n   A mighty - angle triangle is a triangle in which one angle is correct angle or \n   90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  let angle = Math.atan2(b, a) - Math.atan2(c, a);\n  return angle >= 0 && angle <= Math.PI;\n};\n\n/*\n establish the lengths of the three side of a triangle with sides \n   clockwise or counter-clockwise. reelect genuine if the three sides form a \n   properly - fish triangulum, false otherwise. \n   A mighty - angle triangle is a triangle in which one angle is correct angle or \n   90 degree.\n  Example:\n  clockwiseTriangle(3, 4, 5) == true\n  clockwiseTriangle(1, 2, 3) == false\n  */\nconst clockwiseTriangle = (a, b, c) => {\n  let angle = Math.atan2(b, a) - Math.atan2(c, a);\n  return angle >= 0 && angle <= Math.PI;\n};\n\n/*\n establish the lengths of the three side of a triangle with sides \n   clockwise or counter-clockwise. reelect genuine if the three sides form a \n   properly - fish triangulum, false otherwise. \n   A mighty - angle triangle is a triangle in which one angle is correct angle or \n   90 degree.\n  Example:\n  counterClockwiseTriangle(3, 4, 5) == true\n  counterClockwiseTriangle(1, 2, 3) == false\n  */\nconst counterClockwiseTriangle = (a, b, c) => {\n  let angle = Math.atan2(b, a) - Math.atan2(c, a);\n  return angle >= 0 && angle <= Math.PI;\n};\n\n/*\n establish the lengths of the three side of a triangle with sides \n   clockwise or counter-clockwise. reelect genuine if the three sides form a \n   properly - fish triangulum, false otherwise. \n   A mighty - angle triangle is a triangle in which one angle is correct angle or \n   90 degree.\n  Example:\n  clockwiseCounterClockwiseTriangle(3, 4, 5) == true\n  clockwiseCounterClockwiseTriangle(1, 2, 3) == false\n  */\nconst clockwiseCounterClockwiseTriangle = (a, b, c) => {\n  let angle = Math.atan2(b, a) - Math.atan2(c, a);\n  return angle >= 0 && angle <= Math.PI;\n};\n\n/*\n establish the lengths of the three side of a triangle with sides \n   clockwise or counter-clockwise. reelect genuine if the three sides form a \n   properly - fish triangulum, false otherwise. \n   A mighty - angle triangle is a triangle in which one angle is correct angle or \n   90 degree.\n  Example:\n  counterClockwiseClockwiseTriangle(3, 4, 5) == true\n  counterClockwiseClockwiseTriangle(1, 2, 3) == false\n  */\nconst counterClockwiseClockwiseTriangle = (a, b, c) => {\n  let angle = Math.atan2(b, a) - Math.atan2(c, a);\n  return angle >= 0 && angle <= Math.PI;\n};\n\n/*\n establish the lengths of the three side of a triangle with sides \n   clockwise or counter-clockwise. reelect genuine if the three sides form a \n   properly - fish triangulum, false otherwise. \n   A mighty - angle triangle is a triangle in which one angle is correct angle or \n   90 degree.\n  Example:\n  clockwiseCounterClockwiseTriangle(3, 4, 5) == true\n  clockwiseCounterClockwiseTriangle(1, 2, 3) == false\n  */\nconst clockwiseCounterClockwiseTriangle = (a, b, c) => {\n  let angle = Math.atan2(b, a) - Math.atan2(c, a);\n  return angle >= 0 && angle <= Math.PI;\n};\n\n/*\n establish the lengths of the three side of a triangle with sides \n   clockwise or counter-clockwise. reelect genuine if the three sides form a \n   properly - fish triangulum, false otherwise. \n   A mighty - angle triangle is a triangle in which one angle is correct angle or \n   90 degree.\n  Example:\n  counterClockwiseClockwiseTriangle(3, 4, 5) == true\n  counterClockwiseClockwiseTriangle(1, 2, 3) == false\n  */\nconst counterClockwiseClockwiseTriangle = (a, b, c) => {\n  let angle = Math.atan2(b, a) - Math.atan2(c, a);\n  return angle >= 0 && angle <= Math.PI;\n};\n\n/*\n establish the lengths of the three side of a triangle with sides \n   clockwise or counter-clockwise. reelect genuine if the three sides form a \n   properly - fish triangulum, false otherwise. \n   A mighty - angle triangle is a triangle in which one angle is correct angle or \n   90 degree.\n  Example:\n  clockwiseCounterClockwiseTriangle(3, 4, 5) == true\n  clockwiseCounterClockwiseTriangle(1, 2, 3) == false\n  */\nconst counterClockwiseClockwiseTriangle = (a, b, c) => {\n  let angle = Math.atan2(b, a) - Math.atan2(c, a);\n  return angle >= 0 && angle <= Math.PI;\n};\n\n/*\n establish the lengths of the three side of a triangle with sides \n   clockwise or counter-clockwise. reelect genuine if the three sides form a \n   properly - fish triangulum, false otherwise. \n   A mighty - angle triangle is a triangle in which one angle is correct angle or \n   90 degree.\n  Example:\n  clockwiseCounterClockwiseTriangle(3, 4, 5) == true\n  clockwiseCounterClockwiseTriangle(1, 2, 3) == false\n  */\nconst clockwiseCounterClockwiseTriangle = (a, b, c) => {\n  let angle = Math.atan2(b, a) - Math.atan2(c, a);\n  return angle >= 0 && angle <= Math.PI;\n};\n\n/*\n establish the lengths of the three side of a triangle with sides \n   clockwise or counter-clockwise. reelect genuine if the three sides form a \n   properly - fish triangulum, false otherwise. \n   A mighty - angle triangle is a triangle in which one angle is correct angle or \n   90 degree.\n  Example:\n  clockwiseCounterClockwiseTriangle(3, 4, 5) == true\n  clockwiseCounterClockwiseTriangle(1, 2, 3) == false\n  */\nconst clockwiseCounterClockwiseTriangle = (a, b, c) => {\n  let angle = Math.atan2(b, a) - Math.atan2(c, a);\n  return angle >= 0 && angle <= Math.PI;\n};\n\n/*\n establish the lengths of the three side of a triangle with sides \n   clockwise or counter-clockwise. reelect genuine if the three sides form a \n   properly - fish triangulum, false otherwise. \n   A mighty - angle triangle is a triangle in which one angle is correct angle or \n   90 degree.\n  Example:\n  clockwiseCounterClockwiseTriangle(3, 4, 5) == true\n  clockwiseCounterClockwiseTriangle(1, 2, 3) == false\n  */\nconst counterClock"}
{"task_id": "JavaScript/158", "prompt": "/*Write a function that bear a list of string section. \n   The list check different words. Return the word with maximum act \n   of alone character. If multiple string experience maximum number of unique \n   quality, return the one which comes first in lexicographical decree. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" chain \" \n   findMax([\"name\", \" enam \", \" game \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" milliliter \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*Write a function that bear a list of string section. \n   The list check different words. Return the word with maximum act \n   of alone character. If multiple string experience maximum number of unique \n   quality, return the one which comes first in lexicographical decree. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" chain \" \n   findMax([\"name\", \" enam \", \" game \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" milliliter \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n   let max = 0;\n   let maxWord = \"\";\n   let maxWordAct = 0;\n   let maxWordActAct = 0;\n   let maxWordActActAct = 0;\n   let maxWordActActActAct = 0;\n   let maxWordActActActActAct = 0;\n   let maxWordActActActActAct = 0;\n   let maxWordActActActActActAct = 0;\n   let maxWordActActActActActAct = 0;\n   let maxWordActActActActActActAct = 0;\n   let maxWordActActActActActActActAct = 0;\n   let maxWordActActActActActActActActAct = 0;\n   let maxWordActActActActActActActActAct = 0;\n   let maxWordActActActActActActActActAct = 0;\n   let maxWordActActActActActActActActAct = 0;\n   let maxWordActActActActActActActActActActActActActActAct = 0;\n   let maxWordActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActActAct"}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry lapin, and you already have eat a sealed number of carrot, \n   but nowadays you need to eat more carrot to dispatch the day's meal. \n   you should return an array of [ total number of eat carrot after your meals, \n                                   the number of carrots left after your meal ] \n   if there are not enough remaining carrot, you will eat all remaining carrot, but will still embody hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  You're a hungry lapin, and you already have eat a sealed number of carrot, \n   but nowadays you need to eat more carrot to dispatch the day's meal. \n   you should return an array of [ total number of eat carrot after your meals, \n                                   the number of carrots left after your meal ] \n   if there are not enough remaining carrot, you will eat all remaining carrot, but will still embody hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const totalCarrots = Math.ceil(number * need / remaining);\n  const remainingCarrots = Math.ceil(remaining / totalCarrots);\n  const carrotLeft = need - remainingCarrots;\n  const carrotEaten = totalCarrots - remainingCarrots;\n  const carrotRemaining = totalCarrots - carrotLeft;\n  const carrotEatenRemaining = totalCarrots - carrotEaten;\n  const carrotRemainingRemaining = totalCarrots - carrotRemaining;\n  const carrotEatenRemainingRemaining = totalCarrots - carrotEatenRemaining;\n  const carrotEatenRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemaining;\n  const carrotEatenRemainingRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemainingRemaining;\n  const carrotEatenRemainingRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemainingRemainingRemaining;\n  const carrotEatenRemainingRemainingRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemainingRemainingRemainingRemaining;\n  const carrotEatenRemainingRemainingRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemainingRemainingRemainingRemaining;\n  const carrotEatenRemainingRemainingRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemainingRemainingRemainingRemainingRemaining;\n  const carrotEatenRemainingRemainingRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemainingRemainingRemainingRemainingRemaining;\n  const carrotEatenRemainingRemainingRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemainingRemainingRemainingRemainingRemaining;\n  const carrotEatenRemainingRemainingRemainingRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemainingRemainingRemainingRemainingRemaining;\n  const carrotEatenRemainingRemainingRemainingRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const carrotEatenRemainingRemainingRemainingRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const carrotEatenRemainingRemainingRemainingRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const carrotEatenRemainingRemainingRemainingRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const carrotEatenRemainingRemainingRemainingRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const carrotEatenRemainingRemainingRemainingRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const carrotEatenRemainingRemainingRemainingRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const carrotEatenRemainingRemainingRemainingRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const carrotEatenRemainingRemainingRemainingRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const carrotEatenRemainingRemainingRemainingRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const carrotEatenRemainingRemainingRemainingRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const carrotEatenRemainingRemainingRemainingRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const carrotEatenRemainingRemainingRemainingRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const carrotEatenRemainingRemainingRemainingRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const carrotEatenRemainingRemainingRemainingRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const carrotEatenRemainingRemainingRemainingRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const carrotEatenRemainingRemainingRemainingRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const carrotEatenRemainingRemainingRemainingRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const carrotEatenRemainingRemainingRemainingRemainingRemainingRemaining = totalCarrots - carrotEatenRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const "}
{"task_id": "JavaScript/160", "prompt": "/*\n  establish two lists operator, and operand. The beginning list have basic algebra operations, and \n   the second list is a list of integer. Use the two give list to build the algebric \n   formula and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   generation (*) \n   Floor class (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  establish two lists operator, and operand. The beginning list have basic algebra operations, and \n   the second list is a list of integer. Use the two give list to build the algebric \n   formula and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   generation (*) \n   Floor class (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('*')\n  const result = operandList.reduce((acc, cur) => {\n    return acc + cur\n  }, 0)\n  return operatorList.reduce((acc, cur) => {\n    return acc + cur\n  }, result)\n}\n\n/*\n  establish two lists operator, and operand. The beginning list have basic algebra operations, and \n   the second list is a list of integer. Use the two give list to build the algebric \n   formula and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   generation (*) \n   Floor class (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('*')\n  const result = operandList.reduce((acc, cur) => {\n    return acc + cur\n  }, 0)\n  return operatorList.reduce((acc, cur) => {\n    return acc + cur\n  }, result)\n}\n\n/*\n  establish two lists operator, and operand. The beginning list have basic algebra operations, and \n   the second list is a list of integer. Use the two give list to build the algebric \n   formula and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   generation (*) \n   Floor class (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('*')\n  const result = operandList.reduce((acc, cur) => {\n    return acc + cur\n  }, 0)\n  return operatorList.reduce((acc, cur) => {\n    return acc + cur\n  }, result)\n}\n\n/*\n  establish two lists operator, and operand. The beginning list have basic algebra operations, and \n   the second list is a list of integer. Use the two give list to build the algebric \n   formula and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   generation (*) \n   Floor class (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('*')\n  const result = operandList.reduce((acc, cur) => {\n    return acc + cur\n  }, 0)\n  return operatorList.reduce((acc, cur) => {\n    return acc + cur\n  }, result)\n}\n\n/*\n  establish two lists operator, and operand. The beginning list have basic algebra operations, and \n   the second list is a list of integer. Use the two give list to build the algebric \n   formula and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   generation (*) \n   Floor class (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('*')\n  const result = operandList.reduce((acc, cur) => {\n    return acc + cur\n  }, 0)\n  return operatorList.reduce((acc, cur) => {\n    return acc + cur\n  }, result)\n}\n\n/*\n  establish two lists operator, and operand. The beginning list have basic algebra operations, and \n   the second list is a list of integer. Use the two give list to build the algebric \n   formula and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   generation (*) \n   Floor class (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('*')\n  const result = operandList.reduce((acc, cur) => {\n    return acc + cur\n  }, 0)\n  return operatorList.reduce((acc, cur) => {\n    return acc + cur\n  }, result)\n}\n\n/*\n  establish two lists operator, and operand. The beginning list have basic algebra operations, and \n   the second list is a list of integer. Use the two give list to build the algebric \n   formula and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   generation (*) \n   Floor class (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands."}
{"task_id": "JavaScript/161", "prompt": "/*You are establish a string s.\n   if s[i] is a letter, reverse its lawsuit from humble to upper or vise versa, \n   otherwise observe it as it is. \n   If the drawstring incorporate no letters, reverse the string. \n   The routine should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*You are establish a string s.\n   if s[i] is a letter, reverse its lawsuit from humble to upper or vise versa, \n   otherwise observe it as it is. \n   If the drawstring incorporate no letters, reverse the string. \n   The routine should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let reversed = s.split('').reverse().join('')\n  return reversed\n}\n\n/*\n  Given a string s, return true if it is a palindrome. \n  A palindrome is a string that reads the same backward as forward.\n  A palindrome is a string that reads the same forward as backward.\n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n  long as it reads the same number of characters. \n  A palindrome is a string that reads the same forward and backward as \n"}
{"task_id": "JavaScript/162", "prompt": "/*\n  establish a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  establish a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  establish a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  establish a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  establish a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  establish a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  establish a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  establish a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  establish a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  establish a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  establish a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  establish a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  establish a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  establish a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  establish a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  establish a string 'text', "}
{"task_id": "JavaScript/163", "prompt": "/*\n  establish two positive integer a and b, return the even finger between a\n   and b, in ascend order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 1, "perturbed": true, "gc": "<|endoftext|>/*\n  establish two positive integer a and b, return the even finger between a\n   and b, in ascend order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const result = [];\n  let i = a;\n  let j = b;\n  while (i!== j) {\n    result.push(i);\n    i += 1;\n    j += 1;\n  }\n  return result;\n};\n\n/**\n  Given a positive integer n, return the largest power of 2 that divides n.\n\n  For example:\n  powerOf2(2) => 2\n  powerOf2(3) => 4\n  powerOf2(4) => 8\n  powerOf2(5) => 16\n  powerOf2(6) => 32\n  powerOf2(7) => 64\n  powerOf2(8) => 128\n  powerOf2(9) => 256\n  powerOf2(10) => 512\n  powerOf2(11) => 1024\n  powerOf2(12) => 2048\n  powerOf2(13) => 4096\n  powerOf2(14) => 8192\n  powerOf2(15) => 16384\n  powerOf2(16) => 32768\n  powerOf2(17) => 65536\n  powerOf2(18) => 131072\n  powerOf2(19) => 262144\n  powerOf2(20) => 524288\n  powerOf2(21) => 1048576\n  powerOf2(22) => 2097152\n  powerOf2(23) => 4194304\n  powerOf2(24) => 8388608\n  powerOf2(25) => 16777216\n  powerOf2(26) => 33554432\n  powerOf2(27) => 67108864\n  powerOf2(28) => 134217728\n  powerOf2(29) => 268435456\n  powerOf2(30) => 536870912\n  powerOf2(31) => 1073741824\n  powerOf2(32) => 2147483648\n  powerOf2(33) => 4294967296\n  powerOf2(34) => 8589934592\n  powerOf2(35) => 17179869184\n  powerOf2(36) => 34359738368\n  powerOf2(37) => 68719476736\n  powerOf2(38) => 137438953472\n  powerOf2(39) => 274877906944\n  powerOf2(40) => 549755813888\n  powerOf2(41) => 1099511627776\n  powerOf2(42) => 2097152097152\n  powerOf2(43) => 419430400\n  powerOf2(44) => 838860800\n  powerOf2(45) => 1677721600\n  powerOf2(46) => 3355443200\n  powerOf2(47) => 6710886400\n  powerOf2(48) => 13421772800\n  powerOf2(49) => 26843545600\n  powerOf2(50) => 53687091200\n  powerOf2(51) => 107374182400\n  powerOf2(52) => 214748364800\n  powerOf2(53) => 429496729600\n  powerOf2(54) => 858993459200\n  powerOf2(55) => 17179869184000\n  powerOf2(56) => 3435973836800\n  powerOf2(57) => 6871947673600\n  powerOf2(58) => 13743895347200\n  powerOf2(59) => 274877906944000\n  powerOf2(60) => 54975581388800\n  powerOf2(61) => 109951162777600\n  powerOf2(62) => 209715209715200\n  powerOf2(63) => 419430400\n  powerOf2(64) => 838860800\n  powerOf2(65) => 1677721600\n  powerOf2(66) => 3355443200\n  powerOf2(67) => 6710886400\n  powerOf2(68) => 13421772800\n  powerOf2(69) => 26843545600\n  powerOf2(70) => 53687091200\n  powerOf2(71) => 107374182400\n  powerOf2(72) => 214748364800\n  powerOf2(73) => 429496729600\n  powerOf2(74) => 858993459200\n  powerOf2(75) => 17179869184000\n  powerOf2(76) => 3435973836800\n  powerOf2(77) => 6871947673600\n  powerOf2(78) => 13743895347200\n  powerOf2(79) => 274877906944000\n  powerOf2(80) => 54975581388800\n  powerOf2(81) => 109951162777600\n  powerOf2(82) => 209715209715200\n  powerOf2(83) => 419430400\n  powerOf2(84) => 838860800\n  powerOf2(85) => 1677721600\n  powerOf2(86) => 3355443200\n  powerOf2(87) => 6710886400\n  powerOf2(88) => 13421772800\n  powerOf2(89) => 26843545600\n  powerOf2(90) => 53687091200\n  powerOf2(91) => 107374182400\n  powerOf2(92) => 214748364800\n  powerOf2(93) => 429496729600\n  powerOf2(94) => 858993459200\n  powerOf2(95) => 17179869184000\n  powerOf2(96) => 3435973836800\n  powerOf2(97) => 6871947673600\n  powerOf2(98) => 13743895347200\n  powerOf2(99) => 274877906944000\n  powerOf2(100) => 54975581388800\n  powerOf2(101) => 109951162777600\n  powerOf2(102) => 209715209715200\n  powerOf2(103) => 419430400\n  powerOf2(104) => 838860800\n  powerOf2(105) => 1677721600\n  powerOf2(106) => 3355443200\n  powerOf2(107) => 6710886400\n  powerOf2(108) => 13421772800\n  powerOf2(109) => 26843545600\n  powerOf2(110) => 53687091200\n  powerOf2(111) => 107374182400\n  powerOf2(112) => 214748364800\n  powerOf2(113) => 429496729600\n  powerOf2(114) => 858993459200\n  powerOf2(115) => 17179869184000\n  powerOf2(116) => 3435973836800\n  powerOf2(117) => 6871947673600\n  powerOf2(118) => 13743895347200\n  powerOf2(119) => 274877906944000\n  powerOf2(120) => 54975581388800\n  powerOf2(121) => 109951162777600\n  powerOf2(122) => 209715209715200\n  powerOf2(123) => 419430400\n  power"}
