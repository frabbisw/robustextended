{"task_id": "JavaScript/0", "prompt": "/* Check if in given list of numbers, are any two numbers closer to each other than \n   grant threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Check if in given list of numbers, are any two numbers closer to each other than \n   grant threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  return numbers.some(number => {\n    const diff = Math.abs(number - threshold);\n    return diff < Math.abs(number) && diff > Math.abs(number) - threshold;\n  });\n};\n\n/**\n * Check if given list of numbers, are any two numbers closer to each other than \n   grant threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElementsOrEqual = (numbers, threshold) => {\n  return numbers.some(number => {\n    const diff = Math.abs(number - threshold);\n    return diff < Math.abs(number) || diff > Math.abs(number) - threshold;\n  });\n};\n\n/**\n * Check if given list of numbers, are any two numbers closer to each other than \n   grant threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElementsOrEqualOrGreaterThan = (numbers, threshold) => {\n  return numbers.some(number => {\n    const diff = Math.abs(number - threshold);\n    return diff < Math.abs(number) || diff > Math.abs(number) - threshold;\n  });\n};\n\n/**\n * Check if given list of numbers, are any two numbers closer to each other than \n   grant threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElementsOrEqualOrGreaterThan = (numbers, threshold) => {\n  return numbers.some(number => {\n    const diff = Math.abs(number - threshold);\n    return diff < Math.abs(number) || diff > Math.abs(number) - threshold;\n  });\n};\n\n/**\n * Check if given list of numbers, are any two numbers closer to each other than \n   grant threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElementsOrEqualOrLessThan = (numbers, threshold) => {\n  return numbers.some(number => {\n    const diff = Math.abs(number - threshold);\n    return diff < Math.abs(number) || diff > Math.abs(number) - threshold;\n  });\n};\n\n/**\n * Check if given list of numbers, are any two numbers closer to each other than \n   grant threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElementsOrEqualOrLessThanOrGreaterThan = (numbers, threshold) => {\n  return numbers.some(number => {\n    const diff = Math.abs(number - threshold);\n    return diff < Math.abs(number) || diff > Math.abs(number) - threshold;\n  });\n};\n\n/**\n * Check if given list of numbers, are any two numbers closer to each other than \n   grant threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElementsOrEqualOrLessThanOrGreaterThan = (numbers, threshold) => {\n  return numbers.some(number => {\n    const diff = Math.abs(number - threshold);\n    return diff < Math.abs(number) || diff > Math.abs(number) - threshold;\n  });\n};\n\n/**\n * Check if given list of numbers, are any two numbers closer to each other than \n   grant threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElementsOrEqualOrLessThanOrGreaterThanOrEqual = (numbers, threshold) => {\n  return numbers.some(number => {\n    const diff = Math.abs(number - threshold);\n    return diff < Math.abs(number) || diff > Math.abs(number) - threshold;\n  });\n};\n\n/**\n * Check if given list of numbers, are any two numbers closer to each other than \n   grant threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElementsOrEqualOrLessThanOrEqualOrGreaterThan = (numbers, threshold) => {\n  return numbers.some(number => {\n    const diff = Math.abs(number - threshold);\n    return diff < Math.abs(number) || diff > Math.abs(number) - threshold;\n  });\n};\n\n/**\n * Check if given list of numbers, are any two numbers closer to each other than \n   grant threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElementsOrEqualOrLessThanOrEqualOrGreaterThan = (numbers, threshold) => {\n  return numbers.some(number => {\n    const diff = Math.abs(number - threshold);\n    return diff < Math.abs(number) || diff > Math.abs(number) - threshold;\n  });\n};\n\n/**\n * Check if given list of numbers, are any two numbers closer to each other than \n   grant threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElementsOrEqualOrLessThanOrEqualOrLessThan = (numbers, threshold) => {\n  return numbers.some(number => {\n    const diff = Math.abs(number - threshold);\n    return diff < Math.abs(number) || diff > Math.abs(number) - threshold;\n  });\n};\n\n/**\n * Check if given list of numbers, are any two numbers closer to each other than \n   grant threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElementsOrEqualOrLessThanOrEqualOrLessThanOrEqual = (numbers, threshold) => {\n  return numbers.some(number => {\n    const diff = Math.abs(number - threshold);\n    return diff < Math.abs(number) || diff > Math.abs(number) - threshold;\n  });\n};\n\n/**\n * Check if given list of numbers, are any two numbers closer to each other than \n   grant threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElementsOrEqualOrLessThanOrEqualOrLessThanOrEqual = (numbers, threshold) => {\n  return numbers.some(number => {\n    const diff = Math.abs(number - threshold);\n    return diff < Math.abs(number) || diff > Math.abs(number) - threshold;\n  });\n};\n\n/**\n * Check if given list of numbers, are any two numbers closer to each other than \n   grant threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> has"}
{"task_id": "JavaScript/1", "prompt": "/* Input to this function is a string containing multiple groups of cuddle parenthesis. Your finish is to \n   separate those group into separate strings and return the list of those. \n   disjoined groups are balanced (each open couple is properly closed) and not nest within each other \n   Ignore any spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Input to this function is a string containing multiple groups of cuddle parenthesis. Your finish is to \n   separate those group into separate strings and return the list of those. \n   disjoined groups are balanced (each open couple is properly closed) and not nest within each other \n   Ignore any spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  let paren_groups = [];\n  let paren_group_stack = [];\n  let paren_group_stack_index = 0;\n  let paren_group_stack_count = 0;\n  let paren_group_stack_count2 = 0;\n  let paren_group_stack_count3 = 0;\n  let paren_group_stack_count4 = 0;\n  let paren_group_stack_count5 = 0;\n  let paren_group_stack_count6 = 0;\n  let paren_group_stack_count7 = 0;\n  let paren_group_stack_count8 = 0;\n  let paren_group_stack_count9 = 0;\n  let paren_group_stack_count10 = 0;\n  let paren_group_stack_count11 = 0;\n  let paren_group_stack_count12 = 0;\n  let paren_group_stack_count13 = 0;\n  let paren_group_stack_count14 = 0;\n  let paren_group_stack_count15 = 0;\n  let paren_group_stack_count16 = 0;\n  let paren_group_stack_count17 = 0;\n  let paren_group_stack_count18 = 0;\n  let paren_group_stack_count19 = 0;\n  let paren_group_stack_count20 = 0;\n  let paren_group_stack_count21 = 0;\n  let paren_group_stack_count22 = 0;\n  let paren_group_stack_count23 = 0;\n  let paren_group_stack_count24 = 0;\n  let paren_group_stack_count25 = 0;\n  let paren_group_stack_count26 = 0;\n  let paren_group_stack_count27 = 0;\n  let paren_group_stack_count28 = 0;\n  let paren_group_stack_count29 = 0;\n  let paren_group_stack_count30 = 0;\n  let paren_group_stack_count31 = 0;\n  let paren_group_stack_count32 = 0;\n  let paren_group_stack_count33 = 0;\n  let paren_group_stack_count34 = 0;\n  let paren_group_stack_count35 = 0;\n  let paren_group_stack_count36 = 0;\n  let paren_group_stack_count37 = 0;\n  let paren_group_stack_count38 = 0;\n  let paren_group_stack_count39 = 0;\n  let paren_group_stack_count40 = 0;\n  let paren_group_stack_count41 = 0;\n  let paren_group_stack_count42 = 0;\n  let paren_group_stack_count43 = 0;\n  let paren_group_stack_count44 = 0;\n  let paren_group_stack_count45 = 0;\n  let paren_group_stack_count46 = 0;\n  let paren_group_stack_count47 = 0;\n  let paren_group_stack_count48 = 0;\n  let paren_group_stack_count49 = 0;\n  let paren_group_stack_count50 = 0;\n  let paren_group_stack_count51 = 0;\n  let paren_group_stack_count52 = 0;\n  let paren_group_stack_count53 = 0;\n  let paren_group_stack_count54 = 0;\n  let paren_group_stack_count55 = 0;\n  let paren_group_stack_count56 = 0;\n  let paren_group_stack_count57 = 0;\n  let paren_group_stack_count58 = 0;\n  let paren_group_stack_count59 = 0;\n  let paren_group_stack_count60 = 0;\n  let paren_group_stack_count61 = 0;\n  let paren_group_stack_count62 = 0;\n  let paren_group_stack_count63 = 0;\n  let paren_group_stack_count64 = 0;\n  let paren_group_stack_count65 = 0;\n  let paren_group_stack_count66 = 0;\n  let paren_group_stack_count67 = 0;\n  let paren_group_stack_count68 = 0;\n  let paren_group_stack_count69 = 0;\n  let paren_group_stack_count70 = 0;\n  let paren_group_stack_count71 = 0;\n  let paren_group_stack_count72 = 0;\n  let paren_group_stack_count73 = 0;\n  let paren_group_stack_count74 = 0;\n  let paren_group_stack_count75 = 0;\n  let paren_group_stack_count76 = 0;\n  let paren_group_stack_count77 = 0;\n  let paren_group_stack_count78 = 0;\n  let paren_group_stack_count79 = 0;\n  let paren_group_stack_count80 = 0;\n  let paren_group_stack_count81 = 0;\n  let paren_group_stack_count82 = 0;\n  let paren_group_stack_count83 = 0;\n  let paren_group_stack_count84 = 0;\n  let paren_group_stack_count85 = 0;\n  let paren_group_stack_count86 = 0;\n  let paren_group_stack_count87 = 0;\n  let paren_group_stack_count88 = 0;\n  let paren_group_stack_count89 = 0;\n  let paren_group_stack_count90 = 0;\n  let paren_group_stack_count91 = 0;\n  let paren_group_stack_count92 = 0;\n  let paren_group_stack_count93 = 0;\n  let paren_group_stack_count94 = 0;\n  let paren_group_stack_count95 = 0;\n  let paren_group_stack_count96 = 0;\n  let paren_group_stack_count97 = 0;\n  let paren_group_stack_count98 = 0;\n  let paren_group_stack_count99 = 0;\n  let paren_group_stack_count100 = 0;\n  let paren_group_stack_count101 = 0;\n  let paren_group_stack_count102 = 0;\n  let paren_group_stack_count103 = 0;\n  let paren_group_stack_count104 = 0;\n  let paren_group_stack_count105 = 0;\n  let paren_group_stack_count106 = 0;\n  let paren_group_stack_count107 = 0;\n  let paren_group_stack_count108 = 0;\n  let paren_group_stack_count109 = 0;\n  let paren_group_stack_count110 = 0;\n  let paren_group_stack_count111 = 0;\n  let paren_group_stack_count112 = 0;\n  let paren_group_stack_count113 = 0;\n  let paren_group_stack_count114 = 0;\n  let paren_group_stack_count115 = 0;\n  let paren_group_stack_count116 = 0;\n  let paren_group_stack_count117 = 0;\n  let paren_group_stack_count118 = 0;\n  let paren_group_stack_count119 = 0;\n  let paren_group_stack_count120 = 0;\n  let paren_group_stack_count121 = 0;\n  let paren_group_stack_count122 = 0;\n  let paren_group_stack_count123 = 0;\n  let paren_group_stack_count124 = 0;\n  let paren_group_stack_count125 = 0;\n  let paren_group_stack_count126 = 0;\n  let paren_group_stack_count127 = 0;\n  let paren_group_stack_count128 = 0;\n  let paren_group_stack_count129 = 0;\n  let paren_group_stack_count130 = 0;\n  let paren_group_stack_count131 = 0;\n  let paren_group_stack_count132 = 0;\n  let paren_group_stack_count133 = 0;\n  let paren_group_stack_count134 = 0;\n  let paren_group_stack_count135 = 0;\n  let paren_group_stack_count136 = 0;\n  let paren_group_stack_count137 = 0;\n  let paren_group_stack_count138 = 0;\n  let paren_group_stack_count139 = 0;\n  let paren_group_stack_count140 = 0;\n  let paren_group_stack_count141 = 0;\n  let paren_group_stack_count142 = 0;\n  let paren_group_stack_count143 = 0;\n  let paren_group_stack_count144 = 0;\n  let paren_group_stack_count145 = 0;\n  let paren_group_stack_count146 = 0;\n  let paren_group_stack_count147 = 0;\n  let paren_group_stack_count148 = 0;\n  let paren_group_stack_count149 = 0;\n  let paren_group_stack_count150 = 0;\n  let paren_group_stack_count151 = 0;\n  let paren_group_stack_count152 = 0;\n  let paren_group_stack_count153 = 0;\n  let paren_group_stack_count154 = 0;\n  let paren_group_stack_count155 = 0;\n  let paren_group_stack_count156 = 0;\n  let paren_group_stack_count157 = 0;\n  let paren_"}
{"task_id": "JavaScript/2", "prompt": "/* Given a positive floating point number, it can be disintegrate into \n   and integer region (largest integer smaller than given number) and decimals \n   (leftover function always little than 1). \n\n   Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Given a positive floating point number, it can be disintegrate into \n   and integer region (largest integer smaller than given number) and decimals \n   (leftover function always little than 1). \n\n   Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal * Math.pow(10, remainder);\n};\n\n/* Given a positive floating point number, it can be disintegrate into \n   and integer region (largest integer smaller than given number) and decimals \n   (leftover function always little than 1). \n\n   Return the integer part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateIntegerNumber = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal * Math.pow(10, remainder);\n};\n\n/* Given a positive floating point number, it can be disintegrate into \n   and integer region (largest integer smaller than given number) and decimals \n   (leftover function always little than 1). \n\n   Return the fractional part of the number.\n  >>> truncateFraction(3.5)\n  0.5\n  */\nconst truncateFraction = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal * Math.pow(10, remainder);\n};\n\n/* Given a positive floating point number, it can be disintegrate into \n   and integer region (largest integer smaller than given number) and decimals \n   (leftover function always little than 1). \n\n   Return the exponent part of the number.\n  >>> truncateExponent(3.5)\n  3\n  */\nconst truncateExponent = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal * Math.pow(10, remainder);\n};\n\n/* Given a positive floating point number, it can be disintegrate into \n   and integer region (largest integer smaller than given number) and decimals \n   (leftover function always little than 1). \n\n   Return the mantissa part of the number.\n  >>> truncateMantissa(3.5)\n  3.5\n  */\nconst truncateMantissa = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal * Math.pow(10, remainder);\n};\n\n/* Given a positive floating point number, it can be disintegrate into \n   and integer region (largest integer smaller than given number) and decimals \n   (leftover function always little than 1). \n\n   Return the sign of the number.\n  >>> truncateSign(3.5)\n  1\n  */\nconst truncateSign = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal * Math.pow(10, remainder);\n};\n\n/* Given a positive floating point number, it can be disintegrate into \n   and integer region (largest integer smaller than given number) and decimals \n   (leftover function always little than 1). \n\n   Return the exponent of the number.\n  >>> truncateExponent(3.5)\n  3\n  */\nconst truncateExponent = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal * Math.pow(10, remainder);\n};\n\n/* Given a positive floating point number, it can be disintegrate into \n   and integer region (largest integer smaller than given number) and decimals \n   (leftover function always little than 1). \n\n   Return the mantissa of the number.\n  >>> truncateMantissa(3.5)\n  3.5\n  */\nconst truncateMantissa = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal * Math.pow(10, remainder);\n};\n\n/* Given a positive floating point number, it can be disintegrate into \n   and integer region (largest integer smaller than given number) and decimals \n   (leftover function always little than 1). \n\n   Return the sign of the number.\n  >>> truncateSign(3.5)\n  1\n  */\nconst truncateSign = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal * Math.pow(10, remainder);\n};\n\n/* Given a positive floating point number, it can be disintegrate into \n   and integer region (largest integer smaller than given number) and decimals \n   (leftover function always little than 1). \n\n   Return the exponent of the number.\n  >>> truncateExponent(3.5)\n  3\n  */\nconst truncateExponent = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal * Math.pow(10, remainder);\n};\n\n/* Given a positive floating point number, it can be disintegrate into \n   and integer region (largest integer smaller than given number) and decimals \n   (leftover function always little than 1). \n\n   Return the mantissa of the number.\n  >>> truncateMantissa(3.5)\n  3.5\n  */\nconst truncateMantissa = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal * Math.pow(10, remainder);\n};\n\n/* Given a positive floating point number, it can be disintegrate into \n   and integer region (largest integer smaller than given number) and decimals \n   (leftover function always little than 1). \n\n   Return the sign of the number.\n  >>> truncateSign(3.5)\n  1\n  */\nconst truncateSign = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal * Math.pow(10, remainder);\n};\n\n/* Given a positive floating point number, it can be disintegrate into \n   and integer region (largest integer smaller than given number) and decimals \n   (leftover function always little than 1). \n\n   Return the exponent of the number.\n  >>> truncateExponent(3.5)\n  3\n  */\nconst truncateExponent = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal * Math.pow(10, remainder);\n};\n\n/* Given a positive floating point number, it can be disintegrate into \n   and integer region (largest integer smaller than given number) and decimals \n   (leftover function always little than 1). \n\n   Return the mantissa of the number.\n  >>> truncateMantissa(3.5)\n  3.5\n  */\nconst truncateMantissa = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal * Math.pow(10, remainder);\n};\n\n/* Given a positive floating point number, it can be disintegrate into \n   and integer region (largest integer smaller than given number) and decimals \n   (leftover function always little than 1). \n\n   Return the sign of the number.\n  >>> truncateSign(3.5)\n  1\n  */\nconst truncateSign = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal * Math.pow(10, remainder);\n};\n\n/* Given a positive floating point number, it can be disintegrate into \n   and integer region (largest integer smaller than given number) and decimals \n   (leftover function always little than 1). \n\n   Return the exponent of the number.\n  >>> truncateExponent(3.5)\n  3\n  */\nconst truncateExponent = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal * Math.pow(10, remainder);\n};\n\n/* Given a positive floating point number, it can be disintegrate into \n   and integer region (largest integer smaller than given number) and decimals \n   (leftover function always little than 1). \n\n   Return the man"}
{"task_id": "JavaScript/3", "prompt": "/* You're given a list of deposit and withdrawal operations on a bank bill that start with \n   zero balance. Your task is to detect if at any distributor point the balance of account fallls below zero, and \n   at that degree routine should return true. differently it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* You're given a list of deposit and withdrawal operations on a bank bill that start with \n   zero balance. Your task is to detect if at any distributor point the balance of account fallls below zero, and \n   at that degree routine should return true. differently it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank bill that start with \n   zero balance. Your task is to detect if at any distributor point the balance of account fallls below zero, and \n   at that degree routine should return true. differently it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance > 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank bill that start with \n   zero balance. Your task is to detect if at any distributor point the balance of account fallls below zero, and \n   at that degree routine should return true. differently it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank bill that start with \n   zero balance. Your task is to detect if at any distributor point the balance of account fallls below zero, and \n   at that degree routine should return true. differently it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance > 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank bill that start with \n   zero balance. Your task is to detect if at any distributor point the balance of account fallls below zero, and \n   at that degree routine should return true. differently it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank bill that start with \n   zero balance. Your task is to detect if at any distributor point the balance of account fallls below zero, and \n   at that degree routine should return true. differently it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance > 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank bill that start with \n   zero balance. Your task is to detect if at any distributor point the balance of account fallls below zero, and \n   at that degree routine should return true. differently it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank bill that start with \n   zero balance. Your task is to detect if at any distributor point the balance of account fallls below zero, and \n   at that degree routine should return true. differently it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance > 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank bill that start with \n   zero balance. Your task is to detect if at any distributor point the balance of account fallls below zero, and \n   at that degree routine should return true. differently it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank bill that start with \n   zero balance. Your task is to detect if at any distributor point the balance of account fallls below zero, and \n   at that degree routine should return true. differently it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance "}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average absolute difference between each \n   element and a centerpoint (mean in this case ): \n   MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* For a given list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average absolute difference between each \n   element and a centerpoint (mean in this case ): \n   MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const means = numbers.map(n => Math.round(n));\n  const meansSquared = numbers.map(n => n * n);\n  const meansMean = numbers.reduce((a, b) => a + b, 0) / numbers.length;\n  const meansMeanSquared = numbers.reduce((a, b) => a + b * b, 0) / numbers.length;\n  const meansMeanSquaredDifference = meansSquared - meansMeanSquared;\n  const meansMeanSquaredDifferenceSquared = meansMeanSquaredDifference * meansMeanSquaredDifference;\n  const meansMeanSquaredDifferenceSquared2 = meansMeanSquaredDifferenceSquared * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared3 = meansMeanSquaredDifferenceSquared2 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared4 = meansMeanSquaredDifferenceSquared3 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared5 = meansMeanSquaredDifferenceSquared4 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared6 = meansMeanSquaredDifferenceSquared5 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared7 = meansMeanSquaredDifferenceSquared6 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared8 = meansMeanSquaredDifferenceSquared7 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared9 = meansMeanSquaredDifferenceSquared8 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared10 = meansMeanSquaredDifferenceSquared9 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared11 = meansMeanSquaredDifferenceSquared10 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared12 = meansMeanSquaredDifferenceSquared11 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared13 = meansMeanSquaredDifferenceSquared12 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared14 = meansMeanSquaredDifferenceSquared13 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared15 = meansMeanSquaredDifferenceSquared14 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared16 = meansMeanSquaredDifferenceSquared15 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared17 = meansMeanSquaredDifferenceSquared16 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared18 = meansMeanSquaredDifferenceSquared17 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared19 = meansMeanSquaredDifferenceSquared18 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared20 = meansMeanSquaredDifferenceSquared19 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared21 = meansMeanSquaredDifferenceSquared20 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared22 = meansMeanSquaredDifferenceSquared21 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared23 = meansMeanSquaredDifferenceSquared22 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared24 = meansMeanSquaredDifferenceSquared23 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared25 = meansMeanSquaredDifferenceSquared24 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared26 = meansMeanSquaredDifferenceSquared25 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared27 = meansMeanSquaredDifferenceSquared26 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared28 = meansMeanSquaredDifferenceSquared27 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared29 = meansMeanSquaredDifferenceSquared28 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared30 = meansMeanSquaredDifferenceSquared29 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared31 = meansMeanSquaredDifferenceSquared30 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared32 = meansMeanSquaredDifferenceSquared31 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared33 = meansMeanSquaredDifferenceSquared32 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared34 = meansMeanSquaredDifferenceSquared33 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared35 = meansMeanSquaredDifferenceSquared34 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared36 = meansMeanSquaredDifferenceSquared35 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared37 = meansMeanSquaredDifferenceSquared36 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared38 = meansMeanSquaredDifferenceSquared37 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared39 = meansMeanSquaredDifferenceSquared38 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared40 = meansMeanSquaredDifferenceSquared39 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared41 = meansMeanSquaredDifferenceSquared40 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared42 = meansMeanSquaredDifferenceSquared41 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared43 = meansMeanSquaredDifferenceSquared42 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared44 = meansMeanSquaredDifferenceSquared43 * meansMeanSquaredDifferenceSquared;\n  const meansMeanSquaredDifferenceSquared45 = meansMeanSquaredDifferenceSquared44 * meansMeanSqu"}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  const result = [];\n  let i = 0;\n  let j = 0;\n  while (i < numbers.length) {\n    if (numbers[i] < delimeter) {\n      result.push(numbers[i]);\n      i++;\n    } else {\n      result.push(delimeter);\n      j++;\n      if (j === numbers.length) {\n        result.push(numbers[i]);\n        i++;\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Returns a new list containing all but the first `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst dropWhile = (list, count) => {\n  if (count < 1) {\n    return [];\n  }\n  const result = [];\n  let i = 0;\n  while (i < list.length) {\n    if (list[i] < count) {\n      result.push(list[i]);\n      i++;\n    } else {\n      break;\n    }\n  }\n  return result;\n};\n\n/**\n * Returns a new list containing all but the last `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst takeWhile = (list, count) => {\n  if (count < 1) {\n    return [];\n  }\n  const result = [];\n  let i = 0;\n  while (i < list.length) {\n    if (list[i] < count) {\n      result.push(list[i]);\n    } else {\n      break;\n    }\n    i++;\n  }\n  return result;\n};\n\n/**\n * Returns a new list containing all but the first `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst dropLastWhile = (list, count) => {\n  if (count < 1) {\n    return [];\n  }\n  const result = [];\n  let i = 0;\n  while (i < list.length) {\n    if (list[i] < count) {\n      result.push(list[i]);\n    } else {\n      break;\n    }\n    i++;\n  }\n  return result;\n};\n\n/**\n * Returns a new list containing all but the last `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst takeLastWhile = (list, count) => {\n  if (count < 1) {\n    return [];\n  }\n  const result = [];\n  let i = 0;\n  while (i < list.length) {\n    if (list[i] < count) {\n      result.push(list[i]);\n    } else {\n      break;\n    }\n    i++;\n  }\n  return result;\n};\n\n/**\n * Returns a new list containing all but the first `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst dropLast = (list, count) => {\n  if (count < 1) {\n    return [];\n  }\n  const result = [];\n  let i = 0;\n  while (i < list.length) {\n    if (list[i] < count) {\n      result.push(list[i]);\n    } else {\n      break;\n    }\n    i++;\n  }\n  return result;\n};\n\n/**\n * Returns a new list containing all but the last `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst takeLast = (list, count) => {\n  if (count < 1) {\n    return [];\n  }\n  const result = [];\n  let i = 0;\n  while (i < list.length) {\n    if (list[i] < count) {\n      result.push(list[i]);\n    } else {\n      break;\n    }\n    i++;\n  }\n  return result;\n};\n\n/**\n * Returns a new list containing all but the first `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst drop = (list, count) => {\n  if (count < 1) {\n    return [];\n  }\n  const result = [];\n  let i = 0;\n  while (i < list.length) {\n    if (list[i] < count) {\n      result.push(list[i]);\n    } else {\n      break;\n    }\n    i++;\n  }\n  return result;\n};\n\n/**\n * Returns a new list containing all but the last `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst take = (list, count) => {\n  if (count < 1) {\n    return [];\n  }\n  const result = [];\n  let i = 0;\n  while (i < list.length) {\n    if (list[i] < count) {\n      result.push(list[i]);\n    } else {\n      break;\n    }\n    i++;\n  }\n  return result;\n};\n\n/**\n * Returns a new list containing all but the first `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst dropLast = (list, count) => {\n  if (count < 1) {\n    return [];\n  }\n  const result = [];\n  let i = 0;\n  while (i < list.length) {\n    if (list[i] < count) {\n      result.push(list[i]);\n    } else {\n      break;\n    }\n    i++;\n  }\n  return result;\n};\n\n/**\n * Returns a new list containing all but the last `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst takeLast = (list, count) => {\n  if (count < 1) {\n    return [];\n  }\n  const result = [];\n  let i = 0;\n  while (i < list.length) {\n    if (list[i] < count) {\n      result.push(list[i]);\n    } else {\n      break;\n    }\n    i++;\n  }\n  return result;\n};\n\n/**\n * Returns a new list containing all but the first `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst dropWhile = (list, count) => {\n  if (count < 1) {\n    return [];\n  }\n  const result = [];\n  let i = 0;\n  while (i < list.length) {\n    if (list[i] < count) {\n      result.push(list[i]);\n    } else {\n      break;\n    }\n    i++;\n  }\n  return result;\n};\n\n/**\n * Returns a new list containing all but the last `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst takeWhile = (list, count) => {\n  if (count < 1) {\n    return [];\n  }\n  const result = [];\n  let i = 0;\n  while (i < list.length) {\n    if (list[i] < count) {\n      result.push(list[i]);\n    } else {\n      break;\n    }\n    i++;\n  }\n  return result;\n};\n\n/**\n * Returns a new list containing all but the first `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst dropLastWhile = (list, count) => {\n  if (count < 1) {\n    return [];\n  }\n  const result = [];\n  let i = 0;\n  while (i < list.length) {\n    if (list[i] < count) {\n      result.push(list[i]);\n    } else {\n      break;\n    }\n    i++;\n  }\n  return result;\n};\n\n/**\n * Returns a new list containing all but the last `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst takeLastWhile = (list, count) => {\n  if (count < 1) {\n    return [];\n  }\n  const result = [];\n  let i = 0;\n  while (i < list.length) {\n    if (list[i] < count) {\n      result.push(list[i]);\n    } else {\n      break;\n    }\n    i++;\n  }\n  return result;\n};\n\n/**\n * Returns a new list containing all but the first `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst dropLast = (list, count) => {\n  if (count < 1) {\n    return [];\n  }\n  const result = [];\n  let i = 0;\n  while (i < list.length) {\n    if (list[i] < count) {\n      result.push(list[i]);\n    } else {\n      break;\n    }\n    i++"}
{"task_id": "JavaScript/6", "prompt": "/* Input to this function is a string represented multiple groups for nested parentheses separated by space. \n   For each of the group, output the thick grade of nesting of digression. \n   E.g. (() ()) has maximum two levels of nesting while (( ()) ) receive three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Input to this function is a string represented multiple groups for nested parentheses separated by space. \n   For each of the group, output the thick grade of nesting of digression. \n   E.g. (() ()) has maximum two levels of nesting while (( ()) ) receive three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/g);\n  const result = [];\n  for (let i = 0; i < paren_groups.length; i++) {\n    const paren_group = paren_groups[i];\n    const paren_group_split = paren_group.split(\" \");\n    const paren_group_split_length = paren_group_split.length;\n    const paren_group_split_index = 0;\n    const paren_group_split_length_index = paren_group_split_length - 1;\n    const paren_group_split_length_max = paren_group_split_length_index + 1;\n    const paren_group_split_length_min = paren_group_split_length_index - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren_group_split_length_max = paren_group_split_length_max - 1;\n    const paren_group_split_length_min = paren_group_split_length_max - 1;\n    const paren"}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input list of strings only for ones that contain grant substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Filter an input list of strings only for ones that contain grant substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1);\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a substring\n  >>> filterFirstOccurrence([], 'a')\n  []\n  >>> filterFirstOccurrence(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde']\n  */\nconst filterFirstOccurrence = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a substring\n  >>> filterFirstOccurrenceWith([], 'a')\n  []\n  >>> filterFirstOccurrenceWith(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde']\n  */\nconst filterFirstOccurrenceWith = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0 && string.length > 0);\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a substring\n  >>> filterFirstOccurrenceWith([], 'a', 1)\n  []\n  >>> filterFirstOccurrenceWith(['abc', 'bacd', 'cde', 'array'], 'a', 1)\n  ['abc', 'bacd', 'cde']\n  */\nconst filterFirstOccurrenceWith = (strings, substring, startIndex) => {\n  return strings.filter(string => string.indexOf(substring, startIndex) === 0);\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a substring\n  >>> filterFirstOccurrenceWith([], 'a', 1, 2)\n  []\n  >>> filterFirstOccurrenceWith(['abc', 'bacd', 'cde', 'array'], 'a', 1, 2)\n  ['abc', 'bacd', 'cde']\n  */\nconst filterFirstOccurrenceWith = (strings, substring, startIndex, endIndex) => {\n  return strings.filter(string => string.indexOf(substring, startIndex) === 0 && string.length > 0 && string[string.length - 1] === endIndex);\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a substring\n  >>> filterFirstOccurrenceWith([], 'a', 1, 2)\n  []\n  >>> filterFirstOccurrenceWith(['abc', 'bacd', 'cde', 'array'], 'a', 1, 2)\n  ['abc', 'bacd', 'cde']\n  */\nconst filterFirstOccurrenceWith = (strings, substring, startIndex, endIndex, startsWith) => {\n  return strings.filter(string => string.indexOf(substring, startIndex) === 0 && string.length > 0 && string[string.length - 1] === endIndex && startsWith(string, substring));\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a substring\n  >>> filterFirstOccurrenceWith([], 'a', 1, 2)\n  []\n  >>> filterFirstOccurrenceWith(['abc', 'bacd', 'cde', 'array'], 'a', 1, 2)\n  ['abc', 'bacd', 'cde']\n  */\nconst filterFirstOccurrenceWith = (strings, substring, startIndex, endIndex, startsWith, includesSubstring) => {\n  return strings.filter(string => string.indexOf(substring, startIndex) === 0 && string.length > 0 && string[string.length - 1] === endIndex && startsWith(string, substring) && includesSubstring(string, substring));\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a substring\n  >>> filterFirstOccurrenceWith([], 'a', 1, 2)\n  []\n  >>> filterFirstOccurrenceWith(['abc', 'bacd', 'cde', 'array'], 'a', 1, 2)\n  ['abc', 'bacd', 'cde']\n  */\nconst filterFirstOccurrenceWith = (strings, substring, startIndex, endIndex, startsWith, includesSubstring, includesSubstring2) => {\n  return strings.filter(string => string.indexOf(substring, startIndex) === 0 && string.length > 0 && string[string.length - 1] === endIndex && startsWith(string, substring) && includesSubstring(string, substring) && includesSubstring2(string, substring));\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a substring\n  >>> filterFirstOccurrenceWith([], 'a', 1, 2)\n  []\n  >>> filterFirstOccurrenceWith(['abc', 'bacd', 'cde', 'array'], 'a', 1, 2)\n  ['abc', 'bacd', 'cde']\n  */\nconst filterFirstOccurrenceWith = (strings, substring, startIndex, endIndex, startsWith, includesSubstring, includesSubstring2, includesSubstring3) => {\n  return strings.filter(string => string.indexOf(substring, startIndex) === 0 && string.length > 0 && string[string.length - 1] === endIndex && startsWith(string, substring) && includesSubstring(string, substring) && includesSubstring2(string, substring) && includesSubstring3(string, substring));\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a substring\n  >>> filterFirstOccurrenceWith([], 'a', 1, 2)\n  []\n  >>> filterFirstOccurrenceWith(['abc', 'bacd', 'cde', 'array'], 'a', 1, 2)\n  ['abc', 'bacd', 'cde']\n  */\nconst filterFirstOccurrenceWith = (strings, substring, startIndex, endIndex, startsWith, includesSubstring, includesSubstring2, includesSubstring3, includesSubstring4) => {\n  return strings.filter(string => string.indexOf(substring, startIndex) === 0 && string.length > 0 && string[string.length - 1] === endIndex && startsWith(string, substring) && includesSubstring(string, substring) && includesSubstring2(string, substring) && includesSubstring3(string, substring) && includesSubstring4(string, substring));\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a substring\n  >>> filterFirstOccurrenceWith([], 'a', 1, 2)\n  []\n  >>> filterFirstOccurrenceWith(['abc', 'bacd', 'cde', 'array'], 'a', 1, 2)\n  ['abc', 'bacd', 'cde']\n  */\nconst filterFirstOccurrenceWith = (strings, substring, startIndex, endIndex, startsWith, includesSubstring, includesSubstring2, includesSubstring3, includesSubstring4, includesSubstring5, includesSubstring6) => {\n  return strings.filter(string => string.indexOf(substring, startIndex) === 0 && string.length > 0 && string[string.length - 1] === endIndex && startsWith(string, substring) && includesSubstring(string, substring) && includesSubstring2(string, substring) && includesSubstring3(string, substring) && includesSubstring4(string, substring) && includesSubstring5(string, substring) && includesSubstring6(string, substring));\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a substring\n  >>> filterFirstOccurrenceWith([], 'a', 1, 2)\n  []\n  >>> filterFirstOccurrenceWith(['abc', 'bacd', 'cde', 'array'], 'a', 1, 2)\n  ['abc', 'bacd', 'cde']\n  */\nconst filterFirstOccurrenceWith = (strings, substring, startIndex, endIndex, startsWith, includesSubstring, includesSubstring2, includesSubstring3, includesSubstring4, includesSubstring5, includesSubstring6, includesSubstring7) => {\n  return strings.filter(string => string.indexOf(substring, startIndex) === 0 && string.length > 0 && string[string.length - 1] === endIndex && startsWith(string, substring) && includesSubstring(string, substring) && includesSubstring2(string, substring) && includesSubstring3(string, substring) && includesSubstring4(string, substring) && "}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisting of a sum and a intersection of all the integer in a list.\n   Empty kernel should exist adequate to 0 and empty merchandise should embody equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* For a given list of integers, return a tuple consisting of a sum and a intersection of all the integer in a list.\n   Empty kernel should exist adequate to 0 and empty merchandise should embody equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let intersection = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    if (numbers[i] > 0) {\n      intersection += numbers[i];\n    }\n  }\n  return [sum, intersection];\n};\n\n/* Given a list of integers, return the product of all the integers in a list.\n   Empty kernel should exist adequate to 0 and empty merchandise should embody equal to 1.\n  >>> productProduct([])\n  1\n  >>> productProduct([1, 2, 3, 4])\n  24\n  */\nconst productProduct = (numbers, int) => {\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i];\n  }\n  return product;\n};\n\n/* Given a list of integers, return the product of all the integers in a list.\n   Empty kernel should exist adequate to 0 and empty merchandise should embody equal to 1.\n  >>> productProduct([1,2,3])\n  6\n  >>> productProduct([1,2,3], 2)\n  24\n  */\nconst productProductWithZero = (numbers, int) => {\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i];\n    if (numbers[i] === 0) {\n      return 0;\n    }\n  }\n  return product;\n};\n\n/* Given a list of integers, return the product of all the integers in a list.\n   Empty kernel should exist adequate to 0 and empty merchandise should embody equal to 1.\n  >>> productProductWithZero([1,2,3])\n  6\n  >>> productProductWithZero([1,2,3], 2)\n  24\n  */\nconst productProductWithZeroAndZero = (numbers, int) => {\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i];\n    if (numbers[i] === 0) {\n      return 0;\n    }\n  }\n  return product;\n};\n\n/* Given a list of integers, return the product of all the integers in a list.\n   Empty kernel should exist adequate to 0 and empty merchandise should embody equal to 1.\n  >>> productProductWithZeroAndZero([1,2,3])\n  6\n  >>> productProductWithZeroAndZero([1,2,3], 2)\n  24\n  */\nconst productProductWithZeroAndOne = (numbers, int) => {\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i];\n    if (numbers[i] === 1) {\n      return 1;\n    }\n  }\n  return product;\n};\n\n/* Given a list of integers, return the product of all the integers in a list.\n   Empty kernel should exist adequate to 0 and empty merchandise should embody equal to 1.\n  >>> productProductWithZeroAndOne([1,2,3])\n  6\n  >>> productProductWithZeroAndOne([1,2,3], 2)\n  24\n  */\nconst productProductWithZeroAndOneAndZero = (numbers, int) => {\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i];\n    if (numbers[i] === 1) {\n      return 0;\n    }\n  }\n  return product;\n};\n\n/* Given a list of integers, return the product of all the integers in a list.\n   Empty kernel should exist adequate to 0 and empty merchandise should embody equal to 1.\n  >>> productProductWithZeroAndOneAndZero([1,2,3])\n  6\n  >>> productProductWithZeroAndOneAndZero([1,2,3], 2)\n  24\n  */\nconst productProductWithZeroAndOneAndOne = (numbers, int) => {\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i];\n    if (numbers[i] === 1) {\n      return 1;\n    }\n  }\n  return product;\n};\n\n/* Given a list of integers, return the product of all the integers in a list.\n   Empty kernel should exist adequate to 0 and empty merchandise should embody equal to 1.\n  >>> productProductWithZeroAndOneAndOne([1,2,3])\n  6\n  >>> productProductWithZeroAndOneAndOne([1,2,3], 2)\n  24\n  */\nconst productProductWithZeroAndOneAndTwo = (numbers, int) => {\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i];\n    if (numbers[i] === 1) {\n      return 2;\n    }\n  }\n  return product;\n};\n\n/* Given a list of integers, return the product of all the integers in a list.\n   Empty kernel should exist adequate to 0 and empty merchandise should embody equal to 1.\n  >>> productProductWithZeroAndOneAndTwo([1,2,3])\n  6\n  >>> productProductWithZeroAndOneAndTwo([1,2,3], 2)\n  24\n  */\nconst productProductWithZeroAndOneAndThree = (numbers, int) => {\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i];\n    if (numbers[i] === 1) {\n      return 3;\n    }\n  }\n  return product;\n};\n\n/* Given a list of integers, return the product of all the integers in a list.\n   Empty kernel should exist adequate to 0 and empty merchandise should embody equal to 1.\n  >>> productProductWithZeroAndOneAndThree([1,2,3])\n  6\n  >>> productProductWithZeroAndOneAndThree([1,2,3], 2)\n  24\n  */\nconst productProductWithZeroAndOneAndFour = (numbers, int) => {\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i];\n    if (numbers[i] === 1) {\n      return 4;\n    }\n  }\n  return product;\n};\n\n/* Given a list of integers, return the product of all the integers in a list.\n   Empty kernel should exist adequate to 0 and empty merchandise should embody equal to 1.\n  >>> productProductWithZeroAndOneAndFour([1,2,3])\n  6\n  >>> productProductWithZeroAndOneAndFour([1,2,3], 2)\n  24\n  */\nconst productProductWithZeroAndOneAndFive = (numbers, int) => {\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i];\n    if (numbers[i] === 1) {\n      return 5;\n    }\n  }\n  return product;\n};\n\n/* Given a list of integers, return the product of all the integers in a list.\n   Empty kernel should exist adequate to 0 and empty merchandise should embody equal to 1.\n  >>> productProductWithZeroAndOneAndFive([1,2,3])\n  6\n  >>> productProductWithZeroAndOneAndFive([1,2,3], 2)\n  24\n  */\nconst productProductWithZeroAndOneAndSix = (numbers, int) => {\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i];\n    if (numbers[i] === 1) {\n      return 6;\n    }\n  }\n  return product;\n};\n\n/* Given a list of integers, return the product of all the integers in a list.\n   Empty kernel should exist adequate to 0 and empty merchandise should embody equal to 1.\n  >>> productProductWithZeroAndOneAndSix([1,2,3])\n  6\n  >>> productProductWithZeroAndOneAndSix([1,2,3], 2)\n  24\n  */\nconst productProductWithZeroAndOneAndSeven = (numbers, int) => {\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i];\n    if (numbers[i] === 1) {\n      return 7;\n    }\n  }\n  return product;\n};\n\n/* Given a list of integers, return the product of all the integers in a list.\n   Empty kernel should exist adequate to 0 and empty merchandi"}
{"task_id": "JavaScript/9", "prompt": "/* From a given list of integers, generate a list of rolling maximal element determine until establish here and now \n   in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* From a given list of integers, generate a list of rolling maximal element determine until establish here and now \n   in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  let max = 0;\n  let maxIndex = 0;\n  let maxValue = 0;\n  let maxIndexValue = 0;\n  let maxIndexValue2 = 0;\n  let maxIndexValue3 = 0;\n  let maxIndexValue4 = 0;\n  let maxIndexValue5 = 0;\n  let maxIndexValue6 = 0;\n  let maxIndexValue7 = 0;\n  let maxIndexValue8 = 0;\n  let maxIndexValue9 = 0;\n  let maxIndexValue10 = 0;\n  let maxIndexValue11 = 0;\n  let maxIndexValue12 = 0;\n  let maxIndexValue13 = 0;\n  let maxIndexValue14 = 0;\n  let maxIndexValue15 = 0;\n  let maxIndexValue16 = 0;\n  let maxIndexValue17 = 0;\n  let maxIndexValue18 = 0;\n  let maxIndexValue19 = 0;\n  let maxIndexValue20 = 0;\n  let maxIndexValue21 = 0;\n  let maxIndexValue22 = 0;\n  let maxIndexValue23 = 0;\n  let maxIndexValue24 = 0;\n  let maxIndexValue25 = 0;\n  let maxIndexValue26 = 0;\n  let maxIndexValue27 = 0;\n  let maxIndexValue28 = 0;\n  let maxIndexValue29 = 0;\n  let maxIndexValue30 = 0;\n  let maxIndexValue31 = 0;\n  let maxIndexValue32 = 0;\n  let maxIndexValue33 = 0;\n  let maxIndexValue34 = 0;\n  let maxIndexValue35 = 0;\n  let maxIndexValue36 = 0;\n  let maxIndexValue37 = 0;\n  let maxIndexValue38 = 0;\n  let maxIndexValue39 = 0;\n  let maxIndexValue40 = 0;\n  let maxIndexValue41 = 0;\n  let maxIndexValue42 = 0;\n  let maxIndexValue43 = 0;\n  let maxIndexValue44 = 0;\n  let maxIndexValue45 = 0;\n  let maxIndexValue46 = 0;\n  let maxIndexValue47 = 0;\n  let maxIndexValue48 = 0;\n  let maxIndexValue49 = 0;\n  let maxIndexValue50 = 0;\n  let maxIndexValue51 = 0;\n  let maxIndexValue52 = 0;\n  let maxIndexValue53 = 0;\n  let maxIndexValue54 = 0;\n  let maxIndexValue55 = 0;\n  let maxIndexValue56 = 0;\n  let maxIndexValue57 = 0;\n  let maxIndexValue58 = 0;\n  let maxIndexValue59 = 0;\n  let maxIndexValue60 = 0;\n  let maxIndexValue61 = 0;\n  let maxIndexValue62 = 0;\n  let maxIndexValue63 = 0;\n  let maxIndexValue64 = 0;\n  let maxIndexValue65 = 0;\n  let maxIndexValue66 = 0;\n  let maxIndexValue67 = 0;\n  let maxIndexValue68 = 0;\n  let maxIndexValue69 = 0;\n  let maxIndexValue70 = 0;\n  let maxIndexValue71 = 0;\n  let maxIndexValue72 = 0;\n  let maxIndexValue73 = 0;\n  let maxIndexValue74 = 0;\n  let maxIndexValue75 = 0;\n  let maxIndexValue76 = 0;\n  let maxIndexValue77 = 0;\n  let maxIndexValue78 = 0;\n  let maxIndexValue79 = 0;\n  let maxIndexValue80 = 0;\n  let maxIndexValue81 = 0;\n  let maxIndexValue82 = 0;\n  let maxIndexValue83 = 0;\n  let maxIndexValue84 = 0;\n  let maxIndexValue85 = 0;\n  let maxIndexValue86 = 0;\n  let maxIndexValue87 = 0;\n  let maxIndexValue88 = 0;\n  let maxIndexValue89 = 0;\n  let maxIndexValue90 = 0;\n  let maxIndexValue91 = 0;\n  let maxIndexValue92 = 0;\n  let maxIndexValue93 = 0;\n  let maxIndexValue94 = 0;\n  let maxIndexValue95 = 0;\n  let maxIndexValue96 = 0;\n  let maxIndexValue97 = 0;\n  let maxIndexValue98 = 0;\n  let maxIndexValue99 = 0;\n  let maxIndexValue100 = 0;\n  let maxIndexValue101 = 0;\n  let maxIndexValue102 = 0;\n  let maxIndexValue103 = 0;\n  let maxIndexValue104 = 0;\n  let maxIndexValue105 = 0;\n  let maxIndexValue106 = 0;\n  let maxIndexValue107 = 0;\n  let maxIndexValue108 = 0;\n  let maxIndexValue109 = 0;\n  let maxIndexValue110 = 0;\n  let maxIndexValue111 = 0;\n  let maxIndexValue112 = 0;\n  let maxIndexValue113 = 0;\n  let maxIndexValue114 = 0;\n  let maxIndexValue115 = 0;\n  let maxIndexValue116 = 0;\n  let maxIndexValue117 = 0;\n  let maxIndexValue118 = 0;\n  let maxIndexValue119 = 0;\n  let maxIndexValue120 = 0;\n  let maxIndexValue121 = 0;\n  let maxIndexValue122 = 0;\n  let maxIndexValue123 = 0;\n  let maxIndexValue124 = 0;\n  let maxIndexValue125 = 0;\n  let maxIndexValue126 = 0;\n  let maxIndexValue127 = 0;\n  let maxIndexValue128 = 0;\n  let maxIndexValue129 = 0;\n  let maxIndexValue130 = 0;\n  let maxIndexValue131 = 0;\n  let maxIndexValue132 = 0;\n  let maxIndexValue133 = 0;\n  let maxIndexValue134 = 0;\n  let maxIndexValue135 = 0;\n  let maxIndexValue136 = 0;\n  let maxIndexValue137 = 0;\n  let maxIndexValue138 = 0;\n  let maxIndexValue139 = 0;\n  let maxIndexValue140 = 0;\n  let maxIndexValue141 = 0;\n  let maxIndexValue142 = 0;\n  let maxIndexValue143 = 0;\n  let maxIndexValue144 = 0;\n  let maxIndexValue145 = 0;\n  let maxIndexValue146 = 0;\n  let maxIndexValue147 = 0;\n  let maxIndexValue148 = 0;\n  let maxIndexValue149 = 0;\n  let maxIndexValue150 = 0;\n  let maxIndexValue151 = 0;\n  let maxIndexValue152 = 0;\n  let maxIndexValue153 = 0;\n  let maxIndexValue154 = 0;\n  let maxIndexValue155 = 0;\n  let maxIndexValue156 = 0;\n  let maxIndexValue157 = 0;\n  let maxIndexValue158 = 0;\n  let maxIndexValue159 = 0;\n  let maxIndexValue160 = 0;\n  let maxIndexValue161 = 0;\n  let maxIndexValue162 = 0;\n  let maxIndexValue163 = 0;\n  let maxIndexValue164 = 0;\n  let maxIndexValue165 = 0;\n  let maxIndexValue166 = 0;\n  let maxIndexValue167 = 0;\n  let maxIndexValue168 = 0;\n  let maxIndexValue169 = 0;\n  let maxIndexValue170 = 0;\n  let maxIndexValue171 = 0;\n  let maxIndexValue172 = 0;\n  let maxIndexValue173 = 0;\n  let maxIndexValue174 = 0;\n  let maxIndexValue175 = 0;\n  let maxIndexValue176 = 0;\n  let maxIndexValue177 = 0;\n  let maxIndexValue178 = 0;\n  let maxIndexValue179 = 0;\n  let maxIndexValue180 = 0;\n  let maxIndexValue181 = 0;\n  let maxIndexValue182 = 0;\n  let maxIndexValue183 = 0;\n  let maxIndexValue184 = 0;\n  let maxIndexValue185 = 0;\n  let maxIndexValue186 = 0;\n  let maxIndexValue187 = 0;\n  let maxIndexValue188 = 0;\n  let maxIndexValue189 = 0;\n  let maxIndexValue190 = 0;\n  let maxIndexValue191 = 0;\n  let maxIndexValue192 = 0;\n  let maxIndexValue193 = 0;\n  let maxIndexValue194 = 0;\n  let maxIndexValue195 = 0;\n  let maxIndexValue196 = 0;\n  let maxIndexValue197 = 0;\n  let maxIndexValue198 = 0;\n  let maxIndexValue199 = 0;\n  let maxIndexValue200 = 0;\n  let maxIndexValue201 = 0;\n  let maxIndexValue202 = 0;\n  let maxIndexValue203 = 0;\n  let maxIndexValue204 = 0;\n  let maxIndexValue205 = 0;\n  let maxIndexValue206 = 0;\n  let maxIndexValue207 = 0;\n  let maxIndexValue208 = 0;\n  let maxIndexValue209 = 0;\n  let maxIndexValue210 = 0;\n  let maxIndexValue"}
{"task_id": "JavaScript/10", "prompt": "/* Test if gniven strig is a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* rule the brusque palindrome that begins with a issue string.\n   Algorithm idea is bare: \n   - Find the long postfix of supplied string that is a palindrome. \n   - Append to the conclusion of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Test if gniven strig is a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* rule the brusque palindrome that begins with a issue string.\n   Algorithm idea is bare: \n   - Find the long postfix of supplied string that is a palindrome. \n   - Append to the conclusion of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let palindrome = '';\n  let reversedString = string.reverse();\n  let postfix = reversedString.split('').reverse().join('');\n  let prefix = postfix.split('').slice(0, -1).join('');\n  let suffix = postfix.split('').slice(-1)[0];\n  \n  if(isPalindrome(prefix) && isPalindrome(suffix)) {\n    palindrome = prefix + suffix;\n  }\n  return palindrome;\n}\n\n/* rule the brusque palindrome that begins with a issue string.\n   Algorithm idea is bare: \n   - Find the long postfix of supplied string that is a palindrome. \n   - Append to the conclusion of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let palindrome = '';\n  let reversedString = string.reverse();\n  let postfix = reversedString.split('').reverse().join('');\n  let prefix = postfix.split('').slice(0, -1).join('');\n  let suffix = postfix.split('').slice(-1)[0];\n  \n  if(isPalindrome(prefix) && isPalindrome(suffix)) {\n    palindrome = prefix + suffix;\n  }\n  return palindrome;\n}\n\n/* rule the brusque palindrome that begins with a issue string.\n   Algorithm idea is bare: \n   - Find the long postfix of supplied string that is a palindrome. \n   - Append to the conclusion of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let palindrome = '';\n  let reversedString = string.reverse();\n  let postfix = reversedString.split('').reverse().join('');\n  let prefix = postfix.split('').slice(0, -1).join('');\n  let suffix = postfix.split('').slice(-1)[0];\n  \n  if(isPalindrome(prefix) && isPalindrome(suffix)) {\n    palindrome = prefix + suffix;\n  }\n  return palindrome;\n}\n\n/* rule the brusque palindrome that begins with a issue string.\n   Algorithm idea is bare: \n   - Find the long postfix of supplied string that is a palindrome. \n   - Append to the conclusion of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let palindrome = '';\n  let reversedString = string.reverse();\n  let postfix = reversedString.split('').reverse().join('');\n  let prefix = postfix.split('').slice(0, -1).join('');\n  let suffix = postfix.split('').slice(-1)[0];\n  \n  if(isPalindrome(prefix) && isPalindrome(suffix)) {\n    palindrome = prefix + suffix;\n  }\n  return palindrome;\n}\n\n/* rule the brusque palindrome that begins with a issue string.\n   Algorithm idea is bare: \n   - Find the long postfix of supplied string that is a palindrome. \n   - Append to the conclusion of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let palindrome = '';\n  let reversedString = string.reverse();\n  let postfix = reversedString.split('').reverse().join('');\n  let prefix = postfix.split('').slice(0, -1).join('');\n  let suffix = postfix.split('').slice(-1)[0];\n  \n  if(isPalindrome(prefix) && isPalindrome(suffix)) {\n    palindrome = prefix + suffix;\n  }\n  return palindrome;\n}\n\n/* rule the brusque palindrome that begins with a issue string.\n   Algorithm idea is bare: \n   - Find the long postfix of supplied string that is a palindrome. \n   - Append to the conclusion of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let palindrome = '';\n  let reversedString = string.reverse();\n  let postfix = reversedString.split('').reverse().join('');\n  let prefix = postfix.split('').slice(0, -1).join('');\n  let suffix = postfix.split('').slice(-1)[0];\n  \n  if(isPalindrome(prefix) && isPalindrome(suffix)) {\n    palindrome = prefix + suffix;\n  }\n  return palindrome;\n}\n\n/* rule the brusque palindrome that begins with a issue string.\n   Algorithm idea is bare: \n   - Find the long postfix of supplied string that is a palindrome. \n   - Append to the conclusion of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let palindrome = '';\n  let reversedString = string.reverse();\n  let postfix = reversedString.split('').reverse().join('');\n  let prefix = postfix.split('').slice(0, -1).join('');\n  let suffix = postfix.split('').slice(-1)[0];\n  \n  if(isPalindrome(prefix) && isPalindrome(suffix)) {\n    palin"}
{"task_id": "JavaScript/11", "prompt": "/* Input are two strings a and b consisting only of 1s and zero. \n   Perform binary XOR on these inputs and return result besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Input are two strings a and b consisting only of 1s and zero. \n   Perform binary XOR on these inputs and return result besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] ^ b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and zero. \n   Perform binary AND on these inputs and return result besides as a string.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] & b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and zero. \n   Perform binary OR on these inputs and return result besides as a string.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] | b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and zero. \n   Perform binary XOR on these inputs and return result besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] ^ b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and zero. \n   Perform binary AND on these inputs and return result besides as a string.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] & b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and zero. \n   Perform binary OR on these inputs and return result besides as a string.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] | b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and zero. \n   Perform binary XOR on these inputs and return result besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] ^ b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and zero. \n   Perform binary AND on these inputs and return result besides as a string.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] & b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and zero. \n   Perform binary OR on these inputs and return result besides as a string.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] | b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and zero. \n   Perform binary XOR on these inputs and return result besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] ^ b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and zero. \n   Perform binary AND on these inputs and return result besides as a string.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] & b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and zero. \n   Perform binary OR on these inputs and return result besides as a string.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] | b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and zero. \n   Perform binary XOR on these inputs and return result besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] ^ b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and zero. \n   Perform binary AND on these inputs and return result besides as a string.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] & b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and zero. \n   Perform binary OR on these inputs and return result besides as a string.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] | b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and zero. \n   Perform binary XOR on these inputs and return result besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] ^ b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and zero. \n   Perform binary AND on these inputs and return result besides as a string.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] & b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and zero. \n   Perform binary OR on these inputs and return result besides as a string.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode"}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Return the first one in case of multiple \n   strings of the same duration. Return nothing in lawsuit the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Out of list of strings, return the longest one. Return the first one in case of multiple \n   strings of the same duration. Return nothing in lawsuit the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  let longestString = '';\n  let longestDuration = 0;\n  let longestLength = 0;\n\n  strings.forEach((string) => {\n    if (string.length > longestLength) {\n      longestString = string;\n      longestDuration = string.length;\n      longestLength = string.length;\n    }\n  });\n\n  return longestString;\n};\n\n/* Given a string, return its length in number of characters. \n  >>> length('a')\n  3\n  >>> length('aa')\n  2\n  >>> length('aaa')\n  1\n  */\nconst length = (string) => {\n  return string.length;\n};\n\n/* Given a string, return its first character in uppercase. \n  >>> first('a')\n  'A'\n  >>> first('aa')\n  'A'\n  >>> first('aaa')\n  'A'\n  */\nconst first = (string) => {\n  return string.charAt(0).toUpperCase();\n};\n\n/* Given a string, return its last character in uppercase. \n  >>> last('a')\n  'Z'\n  >>> last('aa')\n  'Z'\n  >>> last('aaa')\n  'Z'\n  */\nconst last = (string) => {\n  return string.charAt(string.length - 1).toUpperCase();\n};\n\n/* Given a string, return its first character in lowercase. \n  >>> first('a')\n  'a'\n  >>> first('aa')\n  'a'\n  >>> first('aaa')\n  'a'\n  */\nconst firstLower = (string) => {\n  return string.charAt(0).toLowerCase();\n};\n\n/* Given a string, return its last character in lowercase. \n  >>> last('a')\n  'z'\n  >>> last('aa')\n  'z'\n  >>> last('aaa')\n  'z'\n  */\nconst lastLower = (string) => {\n  return string.charAt(string.length - 1).toLowerCase();\n};\n\n/* Given a string, return its first character in lowercase. \n  >>> first('a')\n  'a'\n  >>> first('aa')\n  'a'\n  >>> first('aaa')\n  'a'\n  */\nconst firstUpper = (string) => {\n  return string.charAt(0).toUpperCase();\n};\n\n/* Given a string, return its last character in lowercase. \n  >>> last('a')\n  'Z'\n  >>> last('aa')\n  'Z'\n  >>> last('aaa')\n  'Z'\n  */\nconst lastUpper = (string) => {\n  return string.charAt(string.length - 1).toUpperCase();\n};\n\n/* Given a string, return its first character in uppercase. \n  >>> first('a')\n  'A'\n  >>> first('aa')\n  'A'\n  >>> first('aaa')\n  'A'\n  */\nconst firstUpperLower = (string) => {\n  return string.charAt(0).toUpperCase();\n};\n\n/* Given a string, return its last character in uppercase. \n  >>> last('a')\n  'Z'\n  >>> last('aa')\n  'Z'\n  >>> last('aaa')\n  'Z'\n  */\nconst lastUpperLower = (string) => {\n  return string.charAt(string.length - 1).toUpperCase();\n};\n\n/* Given a string, return its first character in uppercase. \n  >>> first('a')\n  'A'\n  >>> first('aa')\n  'A'\n  >>> first('aaa')\n  'A'\n  */\nconst firstUpperUpper = (string) => {\n  return string.charAt(0).toUpperCase();\n};\n\n/* Given a string, return its last character in uppercase. \n  >>> last('a')\n  'Z'\n  >>> last('aa')\n  'Z'\n  >>> last('aaa')\n  'Z'\n  */\nconst lastUpperUpper = (string) => {\n  return string.charAt(string.length - 1).toUpperCase();\n};\n\n/* Given a string, return its first character in lowercase. \n  >>> first('a')\n  'a'\n  >>> first('aa')\n  'a'\n  >>> first('aaa')\n  'a'\n  */\nconst firstLower = (string) => {\n  return string.charAt(0).toLowerCase();\n};\n\n/* Given a string, return its last character in lowercase. \n  >>> last('a')\n  'z'\n  >>> last('aa')\n  'z'\n  >>> last('aaa')\n  'z'\n  */\nconst lastLower = (string) => {\n  return string.charAt(string.length - 1).toLowerCase();\n};\n\n/* Given a string, return its first character in lowercase. \n  >>> first('a')\n  'a'\n  >>> first('aa')\n  'a'\n  >>> first('aaa')\n  'a'\n  */\nconst firstUpper = (string) => {\n  return string.charAt(0).toUpperCase();\n};\n\n/* Given a string, return its last character in lowercase. \n  >>> last('a')\n  'Z'\n  >>> last('aa')\n  'Z'\n  >>> last('aaa')\n  'Z'\n  */\nconst lastUpper = (string) => {\n  return string.charAt(string.length - 1).toUpperCase();\n};\n\n/* Given a string, return its first character in uppercase. \n  >>> first('a')\n  'A'\n  >>> first('aa')\n  'A'\n  >>> first('aaa')\n  'A'\n  */\nconst firstUpperLower = (string) => {\n  return string.charAt(0).toUpperCase();\n};\n\n/* Given a string, return its last character in uppercase. \n  >>> last('a')\n  'Z'\n  >>> last('aa')\n  'Z'\n  >>> last('aaa')\n  'Z'\n  */\nconst lastUpperLower = (string) => {\n  return string.charAt(string.length - 1).toUpperCase();\n};\n\n/* Given a string, return its first character in uppercase. \n  >>> first('a')\n  'A'\n  >>> first('aa')\n  'A'\n  >>> first('aaa')\n  'A'\n  */\nconst firstUpperUpper = (string) => {\n  return string.charAt(0).toUpperCase();\n};\n\n/* Given a string, return its last character in uppercase. \n  >>> last('a')\n  'Z'\n  >>> last('aa')\n  'Z'\n  >>> last('aaa')\n  'Z'\n  */\nconst lastUpperUpper = (string) => {\n  return string.charAt(string.length - 1).toUpperCase();\n};\n\n/* Given a string, return its first character in lowercase. \n  >>> first('a')\n  'a'\n  >>> first('aa')\n  'a'\n  >>> first('aaa')\n  'a'\n  */\nconst firstLower = (string) => {\n  return string.charAt(0).toLowerCase();\n};\n\n/* Given a string, return its last character in lowercase. \n  >>> last('a')\n  'z'\n  >>> last('aa')\n  'z'\n  >>> last('aaa')\n  'z'\n  */\nconst lastLower = (string) => {\n  return string.charAt(string.length - 1).toLowerCase();\n};\n\n/* Given a string, return its first character in lowercase. \n  >>> first('a')\n  'a'\n  >>> first('aa')\n  'a'\n  >>> first('aaa')\n  'a'\n  */\nconst firstUpper = (string) => {\n  return string.charAt(0).toUpperCase();\n};\n\n/* Given a string, return its last character in lowercase. \n  >>> last('a')\n  'Z'\n  >>> last('aa')\n  'Z'"}
{"task_id": "JavaScript/13", "prompt": "/* Return a greatest common divisor of two integer a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Return a greatest common divisor of two integer a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (a === 0 || b === 0) {\n    return a;\n  }\n  return gcd(a, b).reduce((a, b) => a % b, 1);\n};\n\n/**\n * Return a random integer between a and b\n * >>> randomInt(1, 100)\n * 1\n * >>> randomInt(1, 100)\n * 50\n * >>> randomInt(1, 100)\n * 100\n */\nconst randomInt = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * Return a random integer between a and b\n * >>> randomInt(1, 100)\n * 1\n * >>> randomInt(1, 100)\n * 50\n * >>> randomInt(1, 100)\n * 100\n */\nconst randomIntBetween = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * Return a random float between a and b\n * >>> randomFloat(1, 100)\n * 1\n * >>> randomFloat(1, 100)\n * 50\n * >>> randomFloat(1, 100)\n * 100\n */\nconst randomFloat = (min, max) => {\n  return Math.random() * (max - min + 1) + min;\n};\n\n/**\n * Return a random float between a and b\n * >>> randomFloat(1, 100)\n * 1\n * >>> randomFloat(1, 100)\n * 50\n * >>> randomFloat(1, 100)\n * 100\n */\nconst randomFloatBetween = (min, max) => {\n  return Math.random() * (max - min + 1) + min;\n};\n\n/**\n * Return a random string between a and b\n * >>> randomString(1, 100)\n * 'a'\n * >>> randomString(1, 100)\n * 'b'\n * >>> randomString(1, 100)\n * 'c'\n * >>> randomString(1, 100)\n * 'd'\n */\nconst randomString = (min, max) => {\n  return Math.random().toString(36).substr(2, max - min + 1);\n};\n\n/**\n * Return a random string between a and b\n * >>> randomString(1, 100)\n * 'a'\n * >>> randomString(1, 100)\n * 'b'\n * >>> randomString(1, 100)\n * 'c'\n * >>> randomString(1, 100)\n * 'd'\n */\nconst randomStringBetween = (min, max) => {\n  return Math.random().toString(36).substr(2, max - min + 1);\n};\n\n/**\n * Return a random boolean between a and b\n * >>> randomBoolean(1, 100)\n * true\n * >>> randomBoolean(1, 100)\n * false\n * >>> randomBoolean(1, 100)\n * true\n * >>> randomBoolean(1, 100)\n * false\n */\nconst randomBoolean = (min, max) => {\n  return Math.random() * (max - min + 1) + min;\n};\n\n/**\n * Return a random boolean between a and b\n * >>> randomBoolean(1, 100)\n * true\n * >>> randomBoolean(1, 100)\n * false\n * >>> randomBoolean(1, 100)\n * true\n * >>> randomBoolean(1, 100)\n * false\n */\nconst randomBooleanBetween = (min, max) => {\n  return Math.random() * (max - min + 1) + min;\n};\n\n/**\n * Return a random object between a and b\n * >>> randomObject(1, 100)\n * { a: 1 }\n * >>> randomObject(1, 100)\n * { a: 2 }\n * >>> randomObject(1, 100)\n * { a: 3 }\n * >>> randomObject(1, 100)\n * { a: 4 }\n * >>> randomObject(1, 100)\n * { a: 5 }\n */\nconst randomObject = (min, max) => {\n  return { a: randomInt(min, max) };\n};\n\n/**\n * Return a random object between a and b\n * >>> randomObject(1, 100)\n * { a: 1 }\n * >>> randomObject(1, 100)\n * { a: 2 }\n * >>> randomObject(1, 100)\n * { a: 3 }\n * >>> randomObject(1, 100)\n * { a: 4 }\n * >>> randomObject(1, 100)\n * { a: 5 }\n */\nconst randomObjectBetween = (min, max) => {\n  return { a: randomInt(min, max) };\n};\n\n/**\n * Return a random array between a and b\n * >>> randomArray(1, 100)\n * [ 1, 2, 3, 4, 5 ]\n * >>> randomArray(1, 100)\n * [ 1, 2, 3, 4, 5 ]\n * >>> randomArray(1, 100)\n * [ 1, 2, 3, 4, 5 ]\n * >>> randomArray(1, 100)\n * [ 1, 2, 3, 4, 5 ]\n */\nconst randomArray = (min, max) => {\n  return [randomInt(min, max), randomInt(min, max)];\n};\n\n/**\n * Return a random array between a and b\n * >>> randomArray(1, 100)\n * [ 1, 2, 3, 4, 5 ]\n * >>> randomArray(1, 100)\n * [ 1, 2, 3, 4, 5 ]\n * >>> randomArray(1, 100)\n * [ 1, 2, 3, 4, 5 ]\n * >>> randomArray(1, 100)\n * [ 1, 2, 3, 4, 5 ]\n */\nconst randomArrayBetween = (min, max) => {\n  return [randomInt(min, max), randomInt(min, max)];\n};\n\n/**\n * Return a random string between a and b\n * >>> randomStringBetween(1, 100)\n * 'a'\n * >>> randomStringBetween(1, 100)\n * 'b'\n * >>> randomStringBetween(1, 100)\n * 'c'\n * >>> randomStringBetween(1, 100)\n * 'd'\n */\nconst randomStringBetween = (min, max) => {\n  return randomString(min, max);\n};\n\n/**\n * Return a random string between a and b\n * >>> randomStringBetween(1, 100)\n * 'a'\n * >>> randomStringBetween(1, 100)\n * 'b'\n * >>> randomStringBetween(1, 100)\n * 'c'\n * >>> randomStringBetween(1, 100)\n * 'd'\n */\nconst randomStringBetweenBetween = (min, max) => {\n  return randomString(min, max);\n};\n\n/**\n * Return a random integer between a and b\n * >>> randomIntBetween(1, 100)\n * 1\n * >>> randomIntBetween(1, 100)\n * 50\n * >>> randomIntBetween(1, 100)\n * 100\n */\nconst randomIntBetweenBetween = (min, max) => {\n  return randomInt(min, max);\n};\n\n/**\n * Return a random float between a and b\n * >>> randomFloatBetween(1, 100)\n * 1\n * >>> randomFloatBetween(1, 100)\n * 50\n * >>> randomFloatBetween(1, 100)\n * 100\n */\nconst randomFloatBetweenBetween = (min, max) => {\n  return randomFloat(min, max);\n};\n\n/**\n * Return a random float between a and b\n * >>> randomFloatBetween(1, 100)\n * 1\n * >>> randomFloatBetween(1, 100)\n * 50\n * >>> randomFloatBetween(1, 100)\n * 100\n */\nconst randomFloatBetweenBetweenBetween = (min, max) => {\n  return randomFloat(min, max);\n};\n\n/**\n * Return a random string between a and b\n * >>> randomStringBetweenBetween(1, 100)\n * 'a'\n * >>> randomStringBetweenBetween(1, 100)\n * 'b'\n * >>> randomStringBetweenBetween(1, 100)\n * 'c'\n * >>> randomStringBetweenBetween(1, 100)\n * 'd'\n */\nconst randomStringBetweenBetween = (min, max) => {\n  return randomStringBetween(min, max);\n};\n\n/**\n * Return a random string between a and b\n * >>> randomStringBetweenBetween(1, 100)\n * 'a'\n * >>> randomStringBetweenBetween(1, 100)\n * 'b'\n * >>> randomStringBetweenBetween(1, 100)\n * 'c'\n * >>> randomStringBetweenBetween(1, 100)\n * 'd'\n */\nconst randomStringBetweenBetweenBetween = (min, max) => {\n  return "}
{"task_id": "JavaScript/14", "prompt": "/* Return list of all prefixes from shortest to longest of the remark string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Return list of all prefixes from shortest to longest of the remark string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  let prefixes = [];\n  let currentPrefix = string;\n  while (currentPrefix.length > 0) {\n    prefixes.push(currentPrefix.substring(0, currentPrefix.length - 1));\n    currentPrefix = currentPrefix.substring(currentPrefix.length - 1);\n  }\n  return prefixes;\n};\n\n/* Return list of all suffixes from shortest to longest of the remark string\n  >>> allSuffixes('abc')\n  ['c', 'ba', 'abc']\n  */\nconst allSuffixes = (string) => {\n  let suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.push(currentSuffix.substring(0, currentSuffix.length - 1));\n    currentSuffix = currentSuffix.substring(currentSuffix.length - 1);\n  }\n  return suffixes;\n};\n\n/* Return list of all remark strings from shortest to longest of the remark string\n  >>> allRemarks('abc')\n  ['abc', 'ab', 'abc']\n  */\nconst allRemarks = (string) => {\n  let remarks = [];\n  let currentRemark = string;\n  while (currentRemark.length > 0) {\n    remarks.push(currentRemark);\n    currentRemark = currentRemark.substring(currentRemark.length - 1);\n  }\n  return remarks;\n};\n\n/* Return list of all remark strings from shortest to longest of the remark string\n  >>> allRemarks('abc')\n  ['abc', 'ab', 'abc']\n  */\nconst allRemarksNoCase = (string) => {\n  let remarks = [];\n  let currentRemark = string;\n  while (currentRemark.length > 0) {\n    remarks.push(currentRemark);\n    currentRemark = currentRemark.substring(currentRemark.length - 1);\n  }\n  return remarks;\n};\n\n/* Return list of all remark strings from shortest to longest of the remark string\n  >>> allRemarksNoCase('abc')\n  ['abc', 'ab', 'abc']\n  */\nconst allRemarksNoCaseIgnoreCase = (string) => {\n  let remarks = [];\n  let currentRemark = string;\n  while (currentRemark.length > 0) {\n    remarks.push(currentRemark);\n    currentRemark = currentRemark.substring(currentRemark.length - 1);\n  }\n  return remarks;\n};\n\n/* Return list of all remark strings from shortest to longest of the remark string\n  >>> allRemarksNoCaseIgnoreCase('abc')\n  ['abc', 'ab', 'abc']\n  */\nconst allRemarksNoCaseIgnoreCaseIgnoreCase = (string) => {\n  let remarks = [];\n  let currentRemark = string;\n  while (currentRemark.length > 0) {\n    remarks.push(currentRemark);\n    currentRemark = currentRemark.substring(currentRemark.length - 1);\n  }\n  return remarks;\n};\n\n/* Return list of all remark strings from shortest to longest of the remark string\n  >>> allRemarksNoCaseIgnoreCaseIgnoreCaseIgnoreCase('abc')\n  ['abc', 'ab', 'abc']\n  */\nconst allRemarksNoCaseIgnoreCaseIgnoreCaseIgnoreCase = (string) => {\n  let remarks = [];\n  let currentRemark = string;\n  while (currentRemark.length > 0) {\n    remarks.push(currentRemark);\n    currentRemark = currentRemark.substring(currentRemark.length - 1);\n  }\n  return remarks;\n};\n\n/* Return list of all remark strings from shortest to longest of the remark string\n  >>> allRemarksNoCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase"}
{"task_id": "JavaScript/15", "prompt": "/* Return a string containing space - subtend number starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Return a string containing space - subtend number starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Return a string containing space - subtend number starting from 0 upto n inclusive.\n * If n is less than or equal to zero, return an empty string.\n * If n is greater than or equal to zero, return '0'.\n */\nconst stringSequenceZero = (n) => {\n  if (n <= 0) {\n    return '';\n  }\n  return stringSequence(n);\n};\n\n/**\n * Return a string containing space - subtend number starting from 0 upto n inclusive.\n * If n is less than or equal to zero, return an empty string.\n * If n is greater than or equal to zero, return '0'.\n * If n is greater than or equal to zero, return '0'.\n */\nconst stringSequenceOne = (n) => {\n  if (n <= 0) {\n    return '';\n  }\n  return stringSequence(n - 1);\n};\n\n/**\n * Return a string containing space - subtend number starting from 0 upto n inclusive.\n * If n is less than or equal to zero, return an empty string.\n * If n is greater than or equal to zero, return '0'.\n * If n is greater than or equal to zero, return '0'.\n */\nconst stringSequenceTwo = (n) => {\n  if (n <= 0) {\n    return '';\n  }\n  return stringSequence(n - 2);\n};\n\n/**\n * Return a string containing space - subtend number starting from 0 upto n inclusive.\n * If n is less than or equal to zero, return an empty string.\n * If n is greater than or equal to zero, return '0'.\n * If n is greater than or equal to zero, return '0'.\n */\nconst stringSequenceThree = (n) => {\n  if (n <= 0) {\n    return '';\n  }\n  return stringSequence(n - 3);\n};\n\n/**\n * Return a string containing space - subtend number starting from 0 upto n inclusive.\n * If n is less than or equal to zero, return an empty string.\n * If n is greater than or equal to zero, return '0'.\n * If n is greater than or equal to zero, return '0'.\n */\nconst stringSequenceFour = (n) => {\n  if (n <= 0) {\n    return '';\n  }\n  return stringSequence(n - 4);\n};\n\n/**\n * Return a string containing space - subtend number starting from 0 upto n inclusive.\n * If n is less than or equal to zero, return an empty string.\n * If n is greater than or equal to zero, return '0'.\n * If n is greater than or equal to zero, return '0'.\n */\nconst stringSequenceFive = (n) => {\n  if (n <= 0) {\n    return '';\n  }\n  return stringSequence(n - 5);\n};\n\n/**\n * Return a string containing space - subtend number starting from 0 upto n inclusive.\n * If n is less than or equal to zero, return an empty string.\n * If n is greater than or equal to zero, return '0'.\n * If n is greater than or equal to zero, return '0'.\n */\nconst stringSequenceSix = (n) => {\n  if (n <= 0) {\n    return '';\n  }\n  return stringSequence(n - 6);\n};\n\n/**\n * Return a string containing space - subtend number starting from 0 upto n inclusive.\n * If n is less than or equal to zero, return an empty string.\n * If n is greater than or equal to zero, return '0'.\n * If n is greater than or equal to zero, return '0'.\n */\nconst stringSequenceSeven = (n) => {\n  if (n <= 0) {\n    return '';\n  }\n  return stringSequence(n - 7);\n};\n\n/**\n * Return a string containing space - subtend number starting from 0 upto n inclusive.\n * If n is less than or equal to zero, return an empty string.\n * If n is greater than or equal to zero, return '0'.\n * If n is greater than or equal to zero, return '0'.\n */\nconst stringSequenceEight = (n) => {\n  if (n <= 0) {\n    return '';\n  }\n  return stringSequence(n - 8);\n};\n\n/**\n * Return a string containing space - subtend number starting from 0 upto n inclusive.\n * If n is less than or equal to zero, return an empty string.\n * If n is greater than or equal to zero, return '0'.\n * If n is greater than or equal to zero, return '0'.\n */\nconst stringSequenceNine = (n) => {\n  if (n <= 0) {\n    return '';\n  }\n  return stringSequence(n - 9);\n};\n\n/**\n * Return a string containing space - subtend number starting from 0 upto n inclusive.\n * If n is less than or equal to zero, return an empty string.\n * If n is greater than or equal to zero, return '0'.\n * If n is greater than or equal to zero, return '0'.\n */\nconst stringSequenceZeroOne = (n) => {\n  if (n <= 0) {\n    return '';\n  }\n  return stringSequence(n - 1);\n};\n\n/**\n * Return a string containing space - subtend number starting from 0 upto n inclusive.\n * If n is less than or equal to zero, return an empty string.\n * If n is greater than or equal to zero, return '0'.\n * If n is greater than or equal to zero, return '0'.\n */\nconst stringSequenceZeroTwo = (n) => {\n  if (n <= 0) {\n    return '';\n  }\n  return stringSequence(n - 2);\n};\n\n/**\n * Return a string containing space - subtend number starting from 0 upto n inclusive.\n * If n is less than or equal to zero, return an empty string.\n * If n is greater than or equal to zero, return '0'.\n * If n is greater than or equal to zero, return '0'.\n */\nconst stringSequenceZeroThree = (n) => {\n  if (n <= 0) {\n    return '';\n  }\n  return stringSequence(n - 3);\n};\n\n/**\n * Return a string containing space - subtend number starting from 0 upto n inclusive.\n * If n is less than or equal to zero, return an empty string.\n * If n is greater than or equal to zero, return '0'.\n * If n is greater than or equal to zero, return '0'.\n */\nconst stringSequenceZeroFour = (n) => {\n  if (n <= 0) {\n    return '';\n  }\n  return stringSequence(n - 4);\n};\n\n/**\n * Return a string containing space - subtend number starting from 0 upto n inclusive.\n * If n is less than or equal to zero, return an empty string.\n * If n is greater than or equal to zero, return '0'.\n * If n is greater than or equal to zero, return '0'.\n */\nconst stringSequenceZeroFive = (n) => {\n  if (n <= 0) {\n    return '';\n  }\n  return stringSequence(n - 5);\n};\n\n/**\n * Return a string containing space - subtend number starting from 0 upto n inclusive.\n * If n is less than or equal to zero, return an empty string.\n * If n is greater than or equal to zero, return '0'.\n * If n is greater than or equal to zero, return '0'.\n */\nconst stringSequenceZeroSix = (n) => {\n  if (n <= 0) {\n    return '';\n  }\n  return stringSequence(n - 6);\n};\n\n/**\n * Return a string containing space - subtend number starting from 0 upto n inclusive.\n * If n is "}
{"task_id": "JavaScript/16", "prompt": "/* Given a string, find out how many clear-cut character (regardless of case) does it dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Given a string, find out how many clear-cut character (regardless of case) does it dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let count = 0;\n  let char;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let A;\n  let B;\n  let C;\n  let D;\n  let E;\n  let F;\n  let G;\n  let H;\n  let I;\n  let J;\n  let K;\n  let L;\n  let M;\n  let N;\n  let O;\n  let P;\n  let Q;\n  let R;\n  let S;\n  let T;\n  let U;\n  let V;\n  let W;\n  let X;\n  let Y;\n  let Z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let A;\n  let B;\n  let C;\n  let D;\n  let E;\n  let F;\n  let G;\n  let H;\n  let I;\n  let J;\n  let K;\n  let L;\n  let M;\n  let N;\n  let O;\n  let P;\n  let Q;\n  let R;\n  let S;\n  let T;\n  let U;\n  let V;\n  let W;\n  let X;\n  let Y;\n  let Z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let A;\n  let B;\n  let C;\n  let D;\n  let E;\n  let F;\n  let G;\n  let H;\n  let I;\n  let J;\n  let K;\n  let L;\n  let M;\n  let N;\n  let O;\n  let P;\n  let Q;\n  let R;\n  let S;\n  let T;\n  let U;\n  let V;\n  let W;\n  let X;\n  let Y;\n  let Z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let A;\n  let B;\n  let C;\n  let D;\n  let E;\n  let F;\n  let G;\n  let H;\n  let I;\n  let J;\n  let K;\n  let L;\n  let M;\n  let N;\n  let O;\n  let P;\n  let Q;\n  let R;\n  let S;\n  let T;\n  let U;\n  let V;\n  let W;\n  let X;\n  let Y;\n  let Z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let A;\n  let B;\n  let C;\n  let D;\n  let E;\n  let F;\n  let G;\n  let H;\n  let I;\n  let J;\n  let K;\n  let L;\n  let M;\n  let N;\n  let O;\n  let P;\n  let Q;\n  let R;\n  let S;\n  let T;\n  let U;\n  let V;\n  let W;\n  let X;\n  let Y;\n  let Z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let A;\n  let B;\n  let C;\n  let D;\n  let E;\n  let F;\n  let G;\n  let H;\n  let I;\n  let J;\n  let K;\n  let L;\n  let M;\n  let N;\n  let O;\n  let P;\n  let Q;\n  let R;\n  let S;\n  let T;\n  let U;\n  let V;\n  let W;\n  let X;\n  let Y;\n  let Z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let A;\n  let B;\n  let C;\n  let D;\n  let E;\n  let F;\n  let G;\n  let H;\n  let I;\n  let J;\n  let K;\n  let L;\n  let M;\n  let N;\n  let O;\n  let P;\n  let Q;\n  let R;\n  let S;\n  let T;\n  let U;\n  let V;\n  let W;\n  let X;\n  let Y;\n  let Z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let A;\n  let B;\n  let C;\n  let D;\n  let E;\n  let F;\n  let G;\n  let H;\n  let I;\n  let J;\n  let K;\n  let L;\n  let M;\n  let N;\n  let O;\n  let P;\n  let Q;\n  let R;\n  let S;\n  let T;\n  let U;\n  let V;\n  let W;\n  let X;\n  let Y;\n  let Z;\n  let a;"}
{"task_id": "JavaScript/17", "prompt": "/* Input to this function is a string representing melodious notes in a particular ASCII format. \n   Your task is to parse this string and return list of integers equate to how many beats does each \n   not concluding. \n\n   Here is a legend: \n  ' oxygen' - whole bill, lasts four beats \n  ' o|' - one-half bill, lasts two pulse \n  ' .|' - quater eminence, lasts one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Input to this function is a string representing melodious notes in a particular ASCII format. \n   Your task is to parse this string and return list of integers equate to how many beats does each \n   not concluding. \n\n   Here is a legend: \n 'oxygen' - whole bill, lasts four beats \n 'o|' - one-half bill, lasts two pulse \n  '.|' - quater eminence, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes = music_string.split('|');\n  const notes_length = notes.length;\n  const notes_array = [];\n  for (let i = 0; i < notes_length; i++) {\n    const note = notes[i];\n    const note_index = note.indexOf('o');\n    const note_index = note_index > -1? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? note_index : note.length;\n    const note_index = note_index > 0? "}
{"task_id": "JavaScript/18", "prompt": "/* Find how many times a given substring can be find oneself in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Find how many times a given substring can be find oneself in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l && j < m) {\n    if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i)!== substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else {\n      i++;\n      j++;\n    }\n  }\n\n  return count;\n};\n\n// Expose `howManyTimes`\nmodule.exports = howManyTimes;\n\n},{}],9:[function(require,module,exports){\n'use strict';\n\nconst _ = require('lodash');\n\n/**\n * Return a new string with every character replaced by its unicode code point.\n * If no replacement is specified, return an empty string.\n *\n * >>> replaceWithCodePoint('abc', '\\uD800\\uDC00')\n * '\\uD800\\uDC00'\n * >>> replaceWithCodePoint('abc', '\\uD800\\uDC00', '\\uD800\\uDC01')\n * '\\uD800\\uDC01'\n * >>> replaceWithCodePoint('abc', '\\uD800\\uDC00', '\\uD800\\uDC01', '\\uD800\\uDC02')\n * '\\uD800\\uDC02'\n * >>> replaceWithCodePoint('abc', '\\uD800\\uDC00', '\\uD800\\uDC01', '\\uD800\\uDC02', '\\uD800\\uDC03')\n * '\\uD800\\uDC03'\n * >>> replaceWithCodePoint('abc', '\\uD800\\uDC00', '\\uD800\\uDC01', '\\uD800\\uDC02', '\\uD800\\uDC03', '\\uD800\\uDC04')\n * '\\uD800\\uDC04'\n * >>> replaceWithCodePoint('abc', '\\uD800\\uDC00', '\\uD800\\uDC01', '\\uD800\\uDC02', '\\uD800\\uDC03', '\\uD800\\uDC04', '\\uD800\\uDC05')\n * '\\uD800\\uDC05'\n * >>> replaceWithCodePoint('abc', '\\uD800\\uDC00', '\\uD800\\uDC01', '\\uD800\\uDC02', '\\uD800\\uDC03', '\\uD800\\uDC04', '\\uD800\\uDC05', '\\uD800\\uDC06')\n * '\\uD800\\uDC06'\n * >>> replaceWithCodePoint('abc', '\\uD800\\uDC00', '\\uD800\\uDC01', '\\uD800\\uDC02', '\\uD800\\uDC03', '\\uD800\\uDC04', '\\uD800\\uDC05', '\\uD800\\uDC06', '\\uD800\\uDC07')\n * '\\uD800\\uDC07'\n * >>> replaceWithCodePoint('abc', '\\uD800\\uDC00', '\\uD800\\uDC01', '\\uD800\\uDC02', '\\uD800\\uDC03', '\\uD800\\uDC04', '\\uD800\\uDC05', '\\uD800\\uDC06', '\\uD800\\uDC07', '\\uD800\\uDC08')\n * '\\uD800\\uDC08'\n * >>> replaceWithCodePoint('abc', '\\uD800\\uDC00', '\\uD800\\uDC01', '\\uD800\\uDC02', '\\uD800\\uDC03', '\\uD800\\uDC04', '\\uD800\\uDC05', '\\uD800\\uDC06', '\\uD800\\uDC07', '\\uD800\\uDC08', '\\uD800\\uDC09')\n * '\\uD800\\uDC09'\n * >>> replaceWithCodePoint('abc', '\\uD800\\uDC00', '\\uD800\\uDC01', '\\uD800\\uDC02', '\\uD800\\uDC03', '\\uD800\\uDC04', '\\uD800\\uDC05', '\\uD800\\uDC06', '\\uD800\\uDC07', '\\uD800\\uDC08', '\\uD800\\uDC09', '\\uD800\\uDC0A')\n * '\\uD800\\uDC0A'\n * >>> replaceWithCodePoint('abc', '\\uD800\\uDC00', '\\uD800\\uDC01', '\\uD800\\uDC02', '\\uD800\\uDC03', '\\uD800\\uDC04', '\\uD800\\uDC05', '\\uD800\\uDC06', '\\uD800\\uDC07', '\\uD800\\uDC08', '\\uD800\\uDC09', '\\uD800\\uDC0A', '\\uD800\\uDC0B')\n * '\\uD800\\uDC0B'\n * >>> replaceWithCodePoint('abc', '\\uD800\\uDC00', '\\uD800\\uDC01', '\\uD800\\uDC02', '\\uD800\\uDC03', '\\uD800\\uDC04', '\\uD800\\uDC05', '\\uD800\\uDC06', '\\uD800\\uDC07', '\\uD800\\uDC08', '\\uD800\\uDC09', '\\uD800\\uDC0A', '\\uD800\\uDC0B', '\\uD800\\uDC0C')\n * '\\uD800\\uDC0C'\n * >>> replaceWithCodePoint('abc', '\\uD800\\uDC00', '\\uD800\\uDC01', '\\uD800\\uDC02', '\\uD800\\uDC03', '\\uD800\\uDC04', '\\uD800\\uDC05', '\\uD800\\uDC06', '\\uD800\\uDC07', '\\uD800\\uDC08', '\\uD800\\uDC09', '\\uD800\\uDC0A', '\\uD800\\uDC0B', '\\uD800\\uDC0C', '\\uD800\\uDC0D')\n * '\\uD800\\uDC0D'\n * >>> replaceWithCodePoint('abc', '\\uD800\\uDC00', '\\uD800\\uDC01', '\\uD800\\uDC02', '\\uD800\\uDC03', '\\uD800\\uDC04', '\\uD800\\uDC05', '\\uD800\\uDC06', '\\uD800\\uDC07', '\\uD800\\uDC08', '\\uD800\\uDC09', '\\uD800\\uDC0A', '\\uD800\\uDC0B', '\\uD800\\uDC0C', '\\uD800\\uDC0D', '\\uD800\\uDC0E')\n * '\\uD800\\uDC0E'\n * >>> replaceWithCodePoint('abc', '\\uD800\\uDC00', '\\uD800\\uDC01', '\\uD800\\uDC02', '\\uD800\\uDC03', '\\uD800\\uDC04', '\\uD800\\uDC05', '\\uD800\\uDC06', '\\uD800\\uDC07', '\\uD800\\uDC08', '\\uD800\\uDC09', '\\uD800\\uDC0A', '\\uD800\\uDC0B', '\\uD800\\uDC0C', '\\uD800\\uDC0D', '\\uD800\\uDC0E', '\\uD800\\uDC0F')\n * '\\uD800\\uDC0F'"}
{"task_id": "JavaScript/19", "prompt": "/* Input is a space - delimited string of numberals from' zero' to' nine'. \n   Valid option are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   revert the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Input is a space - delimited string of numberals from' zero' to' nine'. \n   Valid option are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   revert the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let numberArray = numbers.split(' ');\n  let sortedArray = [];\n  numberArray.forEach((number) => {\n    let number = parseInt(number);\n    if (number > 9) {\n      sortedArray.push(number);\n    }\n  });\n  sortedArray.sort((a, b) => a - b);\n  return sortedArray.join(' ');\n};\n\n/* Input is a space - delimited string of numberals from' zero' to' nine'. \n   Valid option are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   reverse the string with numbers sorted from largest to smallest\n  >>> sortNumbers('three one five')\n  'five three one'\n  */\nconst sortNumbersReverse = (numbers) => {\n  let numberArray = numbers.split(' ');\n  let sortedArray = [];\n  numberArray.forEach((number) => {\n    let number = parseInt(number);\n    if (number > 9) {\n      sortedArray.push(number);\n    }\n  });\n  sortedArray.sort((a, b) => b - a);\n  return sortedArray.join(' ');\n};\n\n/* Input is a space - delimited string of numberals from' zero' to' nine'. \n   Valid option are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   reverse the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'five three one'\n  */\nconst sortNumbersReverseReverse = (numbers) => {\n  let numberArray = numbers.split(' ');\n  let sortedArray = [];\n  numberArray.forEach((number) => {\n    let number = parseInt(number);\n    if (number > 9) {\n      sortedArray.push(number);\n    }\n  });\n  sortedArray.sort((a, b) => b - a);\n  return sortedArray.join(' ');\n};\n\n/* Input is a space - delimited string of numberals from' zero' to' nine'. \n   Valid option are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   reverse the string with numbers sorted from largest to smallest\n  >>> sortNumbers('three one five')\n  'five three one'\n  */\nconst sortNumbersReverseReverseReverse = (numbers) => {\n  let numberArray = numbers.split(' ');\n  let sortedArray = [];\n  numberArray.forEach((number) => {\n    let number = parseInt(number);\n    if (number > 9) {\n      sortedArray.push(number);\n    }\n  });\n  sortedArray.sort((a, b) => b - a);\n  return sortedArray.join(' ');\n};\n\n/* Input is a space - delimited string of numberals from' zero' to' nine'. \n   Valid option are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   reverse the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'five three one'\n  */\nconst sortNumbersReverseReverseReverseReverse = (numbers) => {\n  let numberArray = numbers.split(' ');\n  let sortedArray = [];\n  numberArray.forEach((number) => {\n    let number = parseInt(number);\n    if (number > 9) {\n      sortedArray.push(number);\n    }\n  });\n  sortedArray.sort((a, b) => b - a);\n  return sortedArray.join(' ');\n};\n\n/* Input is a space - delimited string of numberals from' zero' to' nine'. \n   Valid option are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   reverse the string with numbers sorted from largest to smallest\n  >>> sortNumbers('three one five')\n  'five three one'\n  */\nconst sortNumbersReverseReverseReverseReverseReverse = (numbers) => {\n  let numberArray = numbers.split(' ');\n  let sortedArray = [];\n  numberArray.forEach((number) => {\n    let number = parseInt(number);\n    if (number > 9) {\n      sortedArray.push(number);\n    }\n  });\n  sortedArray.sort((a, b) => b - a);\n  return sortedArray.join(' ');\n};\n\n/* Input is a space - delimited string of numberals from' zero' to' nine'. \n   Valid option are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   reverse the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'five three one'\n  */\nconst sortNumbersReverseReverseReverseReverseReverseReverse = (numbers) => {\n  let numberArray = numbers.split(' ');\n  let sortedArray = [];\n  numberArray.forEach((number) => {\n    let number = parseInt(number);\n    if (number > 9) {\n      sortedArray.push(number);\n    }\n  });\n  sortedArray.sort((a, b) => b - a);\n  return sortedArray.join(' ');\n};\n\n/* Input is a space - delimited string of numberals from' zero' to' nine'. \n   Valid option are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   reverse the string with numbers sorted from largest to smallest\n  >>> sortNumbers('three one five')\n  'five three one'\n  */\nconst sortNumbersReverseReverseReverseReverseReverseReverseReverseReverse = (numbers) => {\n  let numberArray = numbers.split(' ');\n  let sortedArray = [];\n  numberArray.forEach((number) => {\n    let number = parseInt(number);\n    if (number > 9) {\n      sortedArray.push(number);\n    }\n  });\n  sortedArray.sort((a, b) => b - a);\n  return sortedArray.join(' ');\n};\n\n/* Input is a space - delimited string of numberals from' zero' to' nine'. \n   Valid option are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   reverse the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'five three one'\n  */\nconst sortNumbersReverseReverseReverseReverseReverseReverseReverseReverseReverse = (numbers) => {\n  let numberArray = numbers.split(' ');\n  let sortedArray = [];\n  numberArray.forEach((number) => {\n    let number = parseInt(number);\n    if (number > 9) {\n      sortedArray.push(number);\n    }\n  });"}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied list of numbers (of length at least two) blue-ribbon and return two that be the closest to each \n   other and return them in order (smaller number, larger phone number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* From a supplied list of numbers (of length at least two) blue-ribbon and return two that be the closest to each \n   other and return them in order (smaller number, larger phone number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  let minDistance = Number.MAX_VALUE;\n  let minElement = undefined;\n  let minIndex = undefined;\n  let minPhoneNumber = undefined;\n  let minBlueRibBrand = undefined;\n  let minBlueRibBrandIndex = undefined;\n  let minBlueRibBrandPhoneNumber = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRibBrandName = undefined;\n  let minBlueRib"}
{"task_id": "JavaScript/21", "prompt": "/* Given list of numbers (of at least two elements), enforce a analogue transform to that list,\n   such that the minor number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Given list of numbers (of at least two elements), enforce a analogue transform to that list,\n   such that the minor number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const [min, max] = numbers;\n  const [min, max] = [min, max].sort((a, b) => a - b);\n  const [major, minor] = max - min;\n  const [major, minor] = [major, minor].map(Math.round);\n  return [major, minor];\n};\n\nconst getMinor = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return minor - 1;\n};\n\nconst getMajor = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfMajors = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfMinors = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return minor - 1;\n};\n\nconst getNumberOfNumbers = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfUnits = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfDecimals = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfSignificantDigits = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfExponents = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfSignificantFigures = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfExponentsSignificantFigures = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfSignificantDecimals = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfExponentsSignificantDecimals = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfDecimalsSignificantFigures = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfSignificantDecimalsSignificantFigures = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfExponentsSignificantDecimalsSignificantFigures = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfDecimalsSignificantDecimalsSignificantFigures = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfSignificantDecimalsSignificantFiguresSignificantFigures = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfExponentsSignificantDecimalsSignificantFiguresSignificantFigures = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfDecimalsSignificantDecimalsSignificantFiguresSignificantFigures = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfSignificantDecimalsSignificantFiguresSignificantFiguresSignificantFigures = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfExponentsSignificantDecimalsSignificantFiguresSignificantFiguresSignificantFigures = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfDecimalsSignificantDecimalsSignificantFiguresSignificantFiguresSignificantFigures = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfSignificantDecimalsSignificantFiguresSignificantFiguresSignificantFiguresSignificantFigures = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfExponentsSignificantDecimalsSignificantFiguresSignificantFiguresSignificantFiguresSignificantFigures = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfDecimalsSignificantDecimalsSignificantFiguresSignificantFiguresSignificantFiguresSignificantFigures = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfSignificantDecimalsSignificantFiguresSignificantFiguresSignificantFiguresSignificantFiguresSignificantFigures = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfExponentsSignificantDecimalsSignificantFiguresSignificantFiguresSignificantFiguresSignificantFiguresSignificantFigures = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfDecimalsSignificantDecimalsSignificantFiguresSignificantFiguresSignificantFiguresSignificantFiguresSignificantFigures = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfSignificantDecimalsSignificantFiguresSignificantFiguresSignificantFiguresSignificantFiguresSignificantFiguresSignificantFigures = (number) => {\n  const [major, minor] = rescaleToUnit(number);\n  return major + 1;\n};\n\nconst getNumberOfExponentsSignificantDecimalsSignificantFiguresSignificantFiguresSignificantFiguresSignificantFiguresSignificantFiguresSignificantFigures = (number) => {\n  const [major, minor] = rescale"}
{"task_id": "JavaScript/22", "prompt": "/* Filter given list of any python values only for integer\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Filter given list of any python values only for integer\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(value => typeof value === 'number');\n};\n\n/**\n * Filter given list of any python values only for float\n  >>> filterFloats(['a', 3.14, 5])\n  [3.14]\n  >>> filterFloats([1, 2, 3, 'abc', {}, []])\n  [3.14, 1, 2, 3]\n  */\nconst filterFloats = (values) => {\n  return values.filter(value => typeof value === 'number');\n};\n\n/**\n * Filter given list of any python values only for string\n  >>> filterStrings(['a', 3.14, 5])\n  ['a', 3.14]\n  >>> filterStrings([1, 2, 3, 'abc', {}, []])\n  ['a', 3.14, 1, 2, 3]\n  */\nconst filterStrings = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filter given list of any python values only for boolean\n  >>> filterBooleans(['a', 3.14, 5])\n  [true, false]\n  >>> filterBooleans([1, 2, 3, 'abc', {}, []])\n  [true, false, 1, 2, 3]\n  */\nconst filterBooleans = (values) => {\n  return values.filter(value => typeof value === 'boolean');\n};\n\n/**\n * Filter given list of any python values only for None\n  >>> filterNones(['a', 3.14, 5])\n  []\n  >>> filterNones([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterNones = (values) => {\n  return values.filter(value => value === null);\n};\n\n/**\n * Filter given list of any python values only for empty list\n  >>> filterEmptyLists(['a', 3.14, 5])\n  []\n  >>> filterEmptyLists([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptyLists = (values) => {\n  return values.filter(value => value === []);\n};\n\n/**\n * Filter given list of any python values only for empty dict\n  >>> filterEmptyDicts(['a', 3.14, 5])\n  []\n  >>> filterEmptyDicts([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptyDicts = (values) => {\n  return values.filter(value => value === {});\n};\n\n/**\n * Filter given list of any python values only for empty string\n  >>> filterEmptyStrings(['a', 3.14, 5])\n  []\n  >>> filterEmptyStrings([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptyStrings = (values) => {\n  return values.filter(value => value === '');\n};\n\n/**\n * Filter given list of any python values only for empty integer\n  >>> filterEmptyIntegers(['a', 3.14, 5])\n  []\n  >>> filterEmptyIntegers([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptyIntegers = (values) => {\n  return values.filter(value => value === 0);\n};\n\n/**\n * Filter given list of any python values only for empty float\n  >>> filterEmptyFloats(['a', 3.14, 5])\n  []\n  >>> filterEmptyFloats([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptyFloats = (values) => {\n  return values.filter(value => value === 0.0);\n};\n\n/**\n * Filter given list of any python values only for empty string\n  >>> filterEmptyStrings(['a', 3.14, 5])\n  []\n  >>> filterEmptyStrings([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptyStrings = (values) => {\n  return values.filter(value => value === '');\n};\n\n/**\n * Filter given list of any python values only for empty boolean\n  >>> filterEmptyBooleans(['a', 3.14, 5])\n  []\n  >>> filterEmptyBooleans([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptyBooleans = (values) => {\n  return values.filter(value => value === false);\n};\n\n/**\n * Filter given list of any python values only for empty None\n  >>> filterEmptyNones(['a', 3.14, 5])\n  []\n  >>> filterEmptyNones([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptyNones = (values) => {\n  return values.filter(value => value === undefined);\n};\n\n/**\n * Filter given list of any python values only for empty list\n  >>> filterEmptyLists(['a', 3.14, 5])\n  []\n  >>> filterEmptyLists([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptyLists = (values) => {\n  return values.filter(value => value === []);\n};\n\n/**\n * Filter given list of any python values only for empty dict\n  >>> filterEmptyDicts(['a', 3.14, 5])\n  []\n  >>> filterEmptyDicts([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptyDicts = (values) => {\n  return values.filter(value => value === {});\n};\n\n/**\n * Filter given list of any python values only for empty string\n  >>> filterEmptyStrings(['a', 3.14, 5])\n  []\n  >>> filterEmptyStrings([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptyStrings = (values) => {\n  return values.filter(value => value === '');\n};\n\n/**\n * Filter given list of any python values only for empty integer\n  >>> filterEmptyIntegers(['a', 3.14, 5])\n  []\n  >>> filterEmptyIntegers([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptyIntegers = (values) => {\n  return values.filter(value => value === 0);\n};\n\n/**\n * Filter given list of any python values only for empty float\n  >>> filterEmptyFloats(['a', 3.14, 5])\n  []\n  >>> filterEmptyFloats([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptyFloats = (values) => {\n  return values.filter(value => value === 0.0);\n};\n\n/**\n * Filter given list of any python values only for empty string\n  >>> filterEmptyStrings(['a', 3.14, 5])\n  []\n  >>> filterEmptyStrings([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptyStrings = (values) => {\n  return values.filter(value => value === '');\n};\n\n/**\n * Filter given list of any python values only for empty boolean\n  >>> filterEmptyBooleans(['a', 3.14, 5])\n  []\n  >>> filterEmptyBooleans([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptyBooleans = (values) => {\n  return values.filter(value => value === false);\n};\n\n/**\n * Filter given list of any python values only for empty None\n  >>> filterEmptyNones(['a', 3.14, 5])\n  []\n  >>> filterEmptyNones([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptyNones = (values) => {\n  return values.filter(value => value === undefined);\n};\n\n/**\n * Filter given list of any python values only for empty list\n  >>> filterEmptyLists(['a', 3.14, 5])\n  []\n  >>> filterEmptyLists([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptyLists = (values) => {\n  return values.filter(value => value === []);\n};\n\n/**\n * Filter given list of any python values only for empty dict\n  >>> filterEmptyDicts(['a', 3.14, 5])\n  []\n  >>> filterEmptyDicts([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptyDicts = (values) => {\n  return values.filter(value => value === {});\n};\n\n/**\n"}
{"task_id": "JavaScript/23", "prompt": "/* Return length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/* Return length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length\n}\n\n/**\n * Return true if given string starts with given prefix\n * >>> startsWith('abc', 'a')\n  true\n  >>> startsWith('abc', 'b')\n  false\n  */\nconst startsWith = (string, prefix) => {\n  return string.indexOf(prefix) === 0\n}\n\n/**\n * Return true if given string ends with given suffix\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1\n}\n\n/**\n * Return true if given string starts with given prefix\n * >>> startsWith('abc', 'b')\n  true\n  >>> startsWith('abc', 'a')\n  false\n  */\nconst startsWithIgnoreCase = (string, prefix) => {\n  return string.indexOf(prefix) === 0 && string[0].toLowerCase() === prefix[0].toLowerCase()\n}\n\n/**\n * Return true if given string ends with given suffix\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWithIgnoreCase = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1 && string[0].toLowerCase() === suffix[0].toLowerCase()\n}\n\n/**\n * Return true if given string starts with given prefix\n * >>> startsWithIgnoreCase('abc', 'b')\n  true\n  >>> startsWithIgnoreCase('abc', 'a')\n  false\n  */\nconst startsWithIgnoreCaseIgnoreCase = (string, prefix) => {\n  return string.indexOf(prefix) === 0 && string[0].toLowerCase() === prefix[0].toLowerCase() && string[0].toLowerCase() === prefix[0].toLowerCase()\n}\n\n/**\n * Return true if given string ends with given suffix\n * >>> endsWithIgnoreCase('abc', 'b')\n  true\n  >>> endsWithIgnoreCase('abc', 'a')\n  false\n  */\nconst endsWithIgnoreCaseIgnoreCase = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1 && string[0].toLowerCase() === suffix[0].toLowerCase() && string[0].toLowerCase() === suffix[0].toLowerCase()\n}\n\n/**\n * Return true if given string starts with given prefix\n * >>> startsWithIgnoreCaseIgnoreCase('abc', 'b')\n  true\n  >>> startsWithIgnoreCaseIgnoreCase('abc', 'a')\n  false\n  */\nconst startsWithIgnoreCaseIgnoreCaseIgnoreCase = (string, prefix) => {\n  return string.indexOf(prefix) === 0 && string[0].toLowerCase() === prefix[0].toLowerCase() && string[0].toLowerCase() === prefix[0].toLowerCase()\n}\n\n/**\n * Return true if given string ends with given suffix\n * >>> endsWithIgnoreCaseIgnoreCase('abc', 'b')\n  true\n  >>> endsWithIgnoreCaseIgnoreCase('abc', 'a')\n  false\n  */\nconst endsWithIgnoreCaseIgnoreCaseIgnoreCase = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1 && string[0].toLowerCase() === suffix[0].toLowerCase() && string[0].toLowerCase() === suffix[0].toLowerCase()\n}\n\n/**\n * Return true if given string starts with given prefix\n * >>> startsWithIgnoreCaseIgnoreCaseIgnoreCase('abc', 'b')\n  true\n  >>> startsWithIgnoreCaseIgnoreCaseIgnoreCase('abc', 'a')\n  false\n  */\nconst startsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (string, prefix) => {\n  return string.indexOf(prefix) === 0 && string[0].toLowerCase() === prefix[0].toLowerCase() && string[0].toLowerCase() === prefix[0].toLowerCase()\n}\n\n/**\n * Return true if given string ends with given suffix\n * >>> endsWithIgnoreCaseIgnoreCaseIgnoreCase('abc', 'b')\n  true\n  >>> endsWithIgnoreCaseIgnoreCaseIgnoreCase('abc', 'a')\n  false\n  */\nconst endsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1 && string[0].toLowerCase() === suffix[0].toLowerCase() && string[0].toLowerCase() === suffix[0].toLowerCase()\n}\n\n/**\n * Return true if given string starts with given prefix\n * >>> startsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase('abc', 'b')\n  true\n  >>> startsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase('abc', 'a')\n  false\n  */\nconst startsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (string, prefix) => {\n  return string.indexOf(prefix) === 0 && string[0].toLowerCase() === prefix[0].toLowerCase() && string[0].toLowerCase() === prefix[0].toLowerCase()\n}\n\n/**\n * Return true if given string ends with given suffix\n * >>> endsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase('abc', 'b')\n  true\n  >>> endsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase('abc', 'a')\n  false\n  */\nconst endsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1 && string[0].toLowerCase() === suffix[0].toLowerCase() && string[0].toLowerCase() === suffix[0].toLowerCase()\n}\n\n/**\n * Return true if given string starts with given prefix\n * >>> startsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase('abc', 'b')\n  true\n  >>> startsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase('abc', 'a')\n  false\n  */\nconst startsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (string, prefix) => {\n  return string.indexOf(prefix) === 0 && string[0].toLowerCase() === prefix[0].toLowerCase() && string[0].toLowerCase() === prefix[0].toLowerCase()\n}\n\n/**\n * Return true if given string ends with given suffix\n * >>> endsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase('abc', 'b')\n  true\n  >>> endsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase('abc', 'a')\n  false\n  */\nconst endsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1 && string[0].toLowerCase() === suffix[0].toLowerCase() && string[0].toLowerCase() === suffix[0].toLowerCase()\n}\n\n/**\n * Return true if given string starts with given prefix\n * >>> startsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnore"}
{"task_id": "JavaScript/24", "prompt": "/* For a given number n, find the largest phone number that divide n evenly, little than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* For a given number n, find the largest phone number that divide n evenly, little than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 0;\n  let divisor = 1;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      maxDivisor = divisor;\n      divisor *= 10;\n    }\n  }\n  return maxDivisor;\n};\n\n// Given a phone number, return its area code\nconst areaCode = (phoneNumber) => {\n  let areaCode = 0;\n  let areaCodeIndex = 0;\n  let areaCodeLength = 0;\n  let areaCodeIndexLength = 0;\n  let areaCodeLengthIndex = 0;\n  let areaCodeLengthIndexLength = 0;\n  let areaCodeLengthIndexLength2 = 0;\n  let areaCodeLengthIndexLength2 = 0;\n  let areaCodeLengthIndexLength3 = 0;\n  let areaCodeLengthIndexLength4 = 0;\n  let areaCodeLengthIndexLength5 = 0;\n  let areaCodeLengthIndexLength6 = 0;\n  let areaCodeLengthIndexLength7 = 0;\n  let areaCodeLengthIndexLength8 = 0;\n  let areaCodeLengthIndexLength9 = 0;\n  let areaCodeLengthIndexLength10 = 0;\n  let areaCodeLengthIndexLength11 = 0;\n  let areaCodeLengthIndexLength12 = 0;\n  let areaCodeLengthIndexLength13 = 0;\n  let areaCodeLengthIndexLength14 = 0;\n  let areaCodeLengthIndexLength15 = 0;\n  let areaCodeLengthIndexLength16 = 0;\n  let areaCodeLengthIndexLength17 = 0;\n  let areaCodeLengthIndexLength18 = 0;\n  let areaCodeLengthIndexLength19 = 0;\n  let areaCodeLengthIndexLength20 = 0;\n  let areaCodeLengthIndexLength21 = 0;\n  let areaCodeLengthIndexLength22 = 0;\n  let areaCodeLengthIndexLength23 = 0;\n  let areaCodeLengthIndexLength24 = 0;\n  let areaCodeLengthIndexLength25 = 0;\n  let areaCodeLengthIndexLength26 = 0;\n  let areaCodeLengthIndexLength27 = 0;\n  let areaCodeLengthIndexLength28 = 0;\n  let areaCodeLengthIndexLength29 = 0;\n  let areaCodeLengthIndexLength30 = 0;\n  let areaCodeLengthIndexLength31 = 0;\n  let areaCodeLengthIndexLength32 = 0;\n  let areaCodeLengthIndexLength33 = 0;\n  let areaCodeLengthIndexLength34 = 0;\n  let areaCodeLengthIndexLength35 = 0;\n  let areaCodeLengthIndexLength36 = 0;\n  let areaCodeLengthIndexLength37 = 0;\n  let areaCodeLengthIndexLength38 = 0;\n  let areaCodeLengthIndexLength39 = 0;\n  let areaCodeLengthIndexLength40 = 0;\n  let areaCodeLengthIndexLength41 = 0;\n  let areaCodeLengthIndexLength42 = 0;\n  let areaCodeLengthIndexLength43 = 0;\n  let areaCodeLengthIndexLength44 = 0;\n  let areaCodeLengthIndexLength45 = 0;\n  let areaCodeLengthIndexLength46 = 0;\n  let areaCodeLengthIndexLength47 = 0;\n  let areaCodeLengthIndexLength48 = 0;\n  let areaCodeLengthIndexLength49 = 0;\n  let areaCodeLengthIndexLength50 = 0;\n  let areaCodeLengthIndexLength51 = 0;\n  let areaCodeLengthIndexLength52 = 0;\n  let areaCodeLengthIndexLength53 = 0;\n  let areaCodeLengthIndexLength54 = 0;\n  let areaCodeLengthIndexLength55 = 0;\n  let areaCodeLengthIndexLength56 = 0;\n  let areaCodeLengthIndexLength57 = 0;\n  let areaCodeLengthIndexLength58 = 0;\n  let areaCodeLengthIndexLength59 = 0;\n  let areaCodeLengthIndexLength60 = 0;\n  let areaCodeLengthIndexLength61 = 0;\n  let areaCodeLengthIndexLength62 = 0;\n  let areaCodeLengthIndexLength63 = 0;\n  let areaCodeLengthIndexLength64 = 0;\n  let areaCodeLengthIndexLength65 = 0;\n  let areaCodeLengthIndexLength66 = 0;\n  let areaCodeLengthIndexLength67 = 0;\n  let areaCodeLengthIndexLength68 = 0;\n  let areaCodeLengthIndexLength69 = 0;\n  let areaCodeLengthIndexLength70 = 0;\n  let areaCodeLengthIndexLength71 = 0;\n  let areaCodeLengthIndexLength72 = 0;\n  let areaCodeLengthIndexLength73 = 0;\n  let areaCodeLengthIndexLength74 = 0;\n  let areaCodeLengthIndexLength75 = 0;\n  let areaCodeLengthIndexLength76 = 0;\n  let areaCodeLengthIndexLength77 = 0;\n  let areaCodeLengthIndexLength78 = 0;\n  let areaCodeLengthIndexLength79 = 0;\n  let areaCodeLengthIndexLength80 = 0;\n  let areaCodeLengthIndexLength81 = 0;\n  let areaCodeLengthIndexLength82 = 0;\n  let areaCodeLengthIndexLength83 = 0;\n  let areaCodeLengthIndexLength84 = 0;\n  let areaCodeLengthIndexLength85 = 0;\n  let areaCodeLengthIndexLength86 = 0;\n  let areaCodeLengthIndexLength87 = 0;\n  let areaCodeLengthIndexLength88 = 0;\n  let areaCodeLengthIndexLength89 = 0;\n  let areaCodeLengthIndexLength90 = 0;\n  let areaCodeLengthIndexLength91 = 0;\n  let areaCodeLengthIndexLength92 = 0;\n  let areaCodeLengthIndexLength93 = 0;\n  let areaCodeLengthIndexLength94 = 0;\n  let areaCodeLengthIndexLength95 = 0;\n  let areaCodeLengthIndexLength96 = 0;\n  let areaCodeLengthIndexLength97 = 0;\n  let areaCodeLengthIndexLength98 = 0;\n  let areaCodeLengthIndexLength99 = 0;\n  let areaCodeLengthIndexLength100 = 0;\n  let areaCodeLengthIndexLength101 = 0;\n  let areaCodeLengthIndexLength102 = 0;\n  let areaCodeLengthIndexLength103 = 0;\n  let areaCodeLengthIndexLength104 = 0;\n  let areaCodeLengthIndexLength105 = 0;\n  let areaCodeLengthIndexLength106 = 0;\n  let areaCodeLengthIndexLength107 = 0;\n  let areaCodeLengthIndexLength108 = 0;\n  let areaCodeLengthIndexLength109 = 0;\n  let areaCodeLengthIndexLength110 = 0;\n  let areaCodeLengthIndexLength111 = 0;\n  let areaCodeLengthIndexLength112 = 0;\n  let areaCodeLengthIndexLength113 = 0;\n  let areaCodeLengthIndexLength114 = 0;\n  let areaCodeLengthIndexLength115 = 0;\n  let areaCodeLengthIndexLength116 = 0;\n  let areaCodeLengthIndexLength117 = 0;\n  let areaCodeLengthIndexLength118 = 0;\n  let areaCodeLengthIndexLength119 = 0;\n  let areaCodeLengthIndexLength120 = 0;\n  let areaCodeLengthIndexLength121 = 0;\n  let areaCodeLengthIndexLength122 = 0;\n  let areaCodeLengthIndexLength123 = 0;\n  let areaCodeLengthIndexLength124 = 0;\n  let areaCodeLengthIndexLength125 = 0;\n  let areaCodeLengthIndexLength126 = 0;\n  let areaCodeLengthIndexLength127 = 0;\n  let areaCodeLengthIndexLength128 = 0;\n  let areaCodeLengthIndexLength129 = 0;\n  let areaCodeLengthIndexLength130 = 0;\n  let areaCodeLengthIndexLength131 = 0;\n  let areaCodeLengthIndexLength132 = 0;\n  let areaCodeLengthIndexLength133 = 0;\n  let areaCodeLengthIndexLength134 = 0;\n  let areaCodeLengthIndexLength135 = 0;\n  let areaCodeLengthIndexLength136 = 0;\n  let areaCodeLengthIndexLength137 = 0;\n  let areaCodeLengthIndexLength138 = 0;\n  let areaCodeLengthIndexLength139 = 0;\n  let areaCodeLengthIndexLength140 = 0;\n  let areaCodeLengthIndexLength141 = 0;\n  let areaCodeLengthIndexLength142 = 0;\n  let areaCodeLengthIndexLength143 = 0;\n  let areaCodeLengthIndexLength144 = 0;\n  let areaCodeLengthIndexLength145 = 0;\n  let areaCodeLengthIndexLength146 = 0;\n  let areaCodeLengthIndexLength147 = 0;\n  let areaCodeLengthIndexLength148 = 0;\n  let areaCodeLengthIndexLength149 = 0;\n  let areaCodeLengthIndexLength150 = 0;\n  let areaCodeLengthIndexLength151 = 0;\n  let areaCodeLengthIndexLength152 = 0;\n  let areaCodeLengthIndexLength153 = 0;\n  let areaCodeLengthIndexLength154 = 0;\n  let areaCodeLengthIndexLength155 = 0;\n"}
{"task_id": "JavaScript/25", "prompt": "/* Return list of prime factors of given integer in the order from little to big. \n   Each of the gene should be listed phone number of times equate to how many times it look in factorization. \n   Input issue should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Return list of prime factors of given integer in the order from little to big. \n   Each of the gene should be listed phone number of times equate to how many times it look in factorization. \n   Input issue should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const primeFactors = [];\n  let factor = 1;\n  let i;\n  \n  while (n) {\n    i = Math.floor(Math.sqrt(n));\n    \n    if (n % i === 0) {\n      primeFactors.push(factor);\n      n = n / i;\n      factor = 1;\n    } else {\n      factor *= i;\n    }\n  }\n  \n  return primeFactors;\n};\n\n/* Return list of prime factors of given integer in the order from big to little. \n   Each of the gene should be listed phone number of times equate to how many times it look in factorization. \n   Input issue should be equal to the product of all factors\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorizeReverse = (n) => {\n  const primeFactors = [];\n  let factor = 1;\n  let i;\n  \n  while (n) {\n    i = Math.floor(Math.sqrt(n));\n    \n    if (n % i === 0) {\n      primeFactors.push(factor);\n      n = n / i;\n      factor = 1;\n    } else {\n      factor *= i;\n    }\n  }\n  \n  return primeFactors;\n};\n\n/* Return list of prime factors of given integer in the order from big to little. \n   Each of the gene should be listed phone number of times equate to how many times it look in factorization. \n   Input issue should be equal to the product of all factors\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorizeReverseReverse = (n) => {\n  const primeFactors = [];\n  let factor = 1;\n  let i;\n  \n  while (n) {\n    i = Math.floor(Math.sqrt(n));\n    \n    if (n % i === 0) {\n      primeFactors.push(factor);\n      n = n / i;\n      factor = 1;\n    } else {\n      factor *= i;\n    }\n  }\n  \n  return primeFactors;\n};\n\n/* Return list of prime factors of given integer in the order from big to little. \n   Each of the gene should be listed phone number of times equate to how many times it look in factorization. \n   Input issue should be equal to the product of all factors\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorizeReverseReverseReverse = (n) => {\n  const primeFactors = [];\n  let factor = 1;\n  let i;\n  \n  while (n) {\n    i = Math.floor(Math.sqrt(n));\n    \n    if (n % i === 0) {\n      primeFactors.push(factor);\n      n = n / i;\n      factor = 1;\n    } else {\n      factor *= i;\n    }\n  }\n  \n  return primeFactors;\n};\n\n/* Return list of prime factors of given integer in the order from big to little. \n   Each of the gene should be listed phone number of times equate to how many times it look in factorization. \n   Input issue should be equal to the product of all factors\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorizeReverseReverseReverse = (n) => {\n  const primeFactors = [];\n  let factor = 1;\n  let i;\n  \n  while (n) {\n    i = Math.floor(Math.sqrt(n));\n    \n    if (n % i === 0) {\n      primeFactors.push(factor);\n      n = n / i;\n      factor = 1;\n    } else {\n      factor *= i;\n    }\n  }\n  \n  return primeFactors;\n};\n\n/* Return list of prime factors of given integer in the order from big to little. \n   Each of the gene should be listed phone number of times equate to how many times it look in factorization. \n   Input issue should be equal to the product of all factors\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorizeReverseReverseReverseReverse = (n) => {\n  const primeFactors = [];\n  let factor = 1;\n  let i;\n  \n  while (n) {\n    i = Math.floor(Math.sqrt(n));\n    \n    if (n % i === 0) {\n      primeFactors.push(factor);\n      n = n / i;\n      factor = 1;\n    } else {\n      factor *= i;\n    }\n  }\n  \n  return primeFactors;\n};\n\n/* Return list of prime factors of given integer in the order from big to little. \n   Each of the gene should be listed phone number of times equate to how many times it look in factorization. \n   Input issue should be equal to the product of all factors\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorizeReverseReverseReverseReverseReverse = (n) => {\n  const primeFactors = [];\n  let factor = 1;\n  let i;\n  \n  while (n) {\n    i = Math.floor(Math.sqrt(n));\n    \n    if (n % i === 0) {\n      primeFactors.push(factor);\n      n = n / i;\n      factor = 1;\n    } else {\n      factor *= i;\n    }\n  }\n  \n  return primeFactors;\n};\n\n/* Return list of prime factors of given integer in the order from big to little. \n   Each of the gene should be listed phone number of times equate to how many times it look in factorization. \n   Input issue should be equal to the product of all factors\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorizeReverseReverseReverseReverseReverseReverse = (n) => {\n  const primeFactors = [];\n  let factor = 1;\n  let i;\n  \n  while (n) {\n    i = Math.floor(Math.sqrt(n));\n    \n    if (n % i === 0) {\n      primeFactors.push(factor);\n      n = n / i;\n      factor = 1;\n    } else {\n      factor *= i;\n    }\n  }\n  \n  return primeFactors;\n};\n\n/* Return list of prime factors of given integer in the order from big to little. \n   Each of the gene should be listed phone number of times equate to how many times it look in factorization. \n   Input issue should be equal to the product of all factors\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorizeReverseReverseReverseReverseReverseReverseReverse = (n) => {\n  const primeFactors = [];\n  let factor = 1;\n  let i;\n  \n  while (n) {\n    i = Math.floor(Math.sqrt(n));\n    \n    if (n % i === 0) {\n      primeFactors.push(factor);\n      n = n / i;\n      factor = 1;\n    } else {\n      factor *= i;\n    }\n  }\n  \n  return primeFactors;\n};\n\n/* Return list of prime factors of given integer in the order from big to little. \n   Each of the gene should be listed phone number of times equate to how many times it look in factorization. \n   Input issue should be equal to the product of all factors\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorizeReverseReverseReverseReverseReverseReverseReverse = (n) => {\n  const primeFactors = [];\n  let factor = 1;\n  let i;\n  \n  while (n) {\n    i = Math.floor(Math.sqrt(n));\n    \n    if (n % i === 0) {\n      primeFactors.push(factor);\n      n = n / i;\n      factor = 1;\n    } else {\n      factor *= i;\n    }\n  }\n  \n  return primeFactors;"}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers, remove all elements that occur more than once. \n   observe holy order of element left the like as in the remark.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* From a list of integers, remove all elements that occur more than once. \n   observe holy order of element left the like as in the remark.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    let number = numbers[i];\n    if (!(number in seen)) {\n      seen[number] = true;\n      result.push(number);\n    }\n  }\n  return result;\n};\n\n/* From a list of integers, remove all elements that occur more than once. \n   observe holy order of element left the like as in the remark.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSet = (numbers) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    let number = numbers[i];\n    if (!(number in seen)) {\n      seen[number] = true;\n      result.push(number);\n    }\n  }\n  return result;\n};\n\n/* From a list of integers, remove all elements that occur more than once. \n   observe holy order of element left the like as in the remark.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSet2 = numberList => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    let number = numberList[i];\n    if (!(number in seen)) {\n      seen[number] = true;\n      result.push(number);\n    }\n  }\n  return result;\n};\n\n/* From a list of integers, remove all elements that occur more than once. \n   observe holy order of element left the like as in the remark.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSet3 = numberList => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    let number = numberList[i];\n    if (!(number in seen)) {\n      seen[number] = true;\n      result.push(number);\n    }\n  }\n  return result;\n};\n\n/* From a list of integers, remove all elements that occur more than once. \n   observe holy order of element left the like as in the remark.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSet4 = numberList => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    let number = numberList[i];\n    if (!(number in seen)) {\n      seen[number] = true;\n      result.push(number);\n    }\n  }\n  return result;\n};\n\n/* From a list of integers, remove all elements that occur more than once. \n   observe holy order of element left the like as in the remark.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSet5 = numberList => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    let number = numberList[i];\n    if (!(number in seen)) {\n      seen[number] = true;\n      result.push(number);\n    }\n  }\n  return result;\n};\n\n/* From a list of integers, remove all elements that occur more than once. \n   observe holy order of element left the like as in the remark.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSet6 = numberList => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    let number = numberList[i];\n    if (!(number in seen)) {\n      seen[number] = true;\n      result.push(number);\n    }\n  }\n  return result;\n};\n\n/* From a list of integers, remove all elements that occur more than once. \n   observe holy order of element left the like as in the remark.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSet7 = numberList => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    let number = numberList[i];\n    if (!(number in seen)) {\n      seen[number] = true;\n      result.push(number);\n    }\n  }\n  return result;\n};\n\n/* From a list of integers, remove all elements that occur more than once. \n   observe holy order of element left the like as in the remark.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSet8 = numberList => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    let number = numberList[i];\n    if (!(number in seen)) {\n      seen[number] = true;\n      result.push(number);\n    }\n  }\n  return result;\n};\n\n/* From a list of integers, remove all elements that occur more than once. \n   observe holy order of element left the like as in the remark.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSet9 = numberList => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    let number = numberList[i];\n    if (!(number in seen)) {\n      seen[number] = true;\n      result.push(number);\n    }\n  }\n  return result;\n};\n\n/* From a list of integers, remove all elements that occur more than once. \n   observe holy order of element left the like as in the remark.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSet10 = numberList => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    let number = numberList[i];\n    if (!(number in seen)) {\n      seen[number] = true;\n      result.push(number);\n    }\n  }\n  return result;\n};\n\n/* From a list of integers, remove all elements that occur more than once. \n   observe holy order of element left the like as in the remark.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSet11 = numberList => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    let number = numberList[i];\n    if (!(number in seen)) {\n      seen[number] = true;\n      result.push(number);\n    }\n  }\n  return result;\n};\n\n/* From a list of integers, remove all elements that occur more than once. \n   observe holy order of element left the like as in the remark.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSet12 = numberList => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    let number = numberList[i];\n    if (!(number in seen)) {\n      seen[number] = true;\n      result.push(number);\n    }\n  }\n  return result;\n};\n\n/* From a list of integers, remove all elements that occur more than once. \n   observe holy order of element left the like as in the remark.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSet13 = numberList => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    let number = numberList[i];\n    if (!(number in seen)) {\n      seen[number] = true;\n      result.push(number);\n    }\n  }\n  return result;\n};\n\n/* From a list of integers, remove all elements that occur more than once. \n   observe holy order of element left the like as in the remark.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSet14 = numberList => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    let number = numberList[i];\n    if (!(number in seen)) {\n      "}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip lowercase character to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* For a given string, flip lowercase character to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.toLowerCase().split('')\n   .map(c => c.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, return the first letter of the string that is a vowel.\n * If no vowels are found, return an empty string.\n * If there are multiple vowels, return the first letter of the string that is a vowel.\n * If there are multiple vowels and the first letter of the string is not a vowel, return an empty string.\n * If there are multiple vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels, return an empty string.\n * If there are multiple vowels and the first letter of the string is not a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is not a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter of the string that is a vowel.\n * If there are no vowels and the first letter of the string is a vowel, return the first letter "}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, curr) => acc + (curr || ''))\n}\n\n/* Convert string to number\n  >>> toNumber(null)\n  0\n  >>> toNumber('123')\n  123\n  >>> toNumber('123.456')\n  123.456\n  >>> toNumber('123.45')\n  123.45\n  >>> toNumber('123.45.67')\n  123.4567\n  >>> toNumber('123.4567')\n  123.4567\n  >>> toNumber('123.4567.89')\n  123.456789\n  >>> toNumber('123.4567.89')\n  123.456789\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> toNumber('123.4567.89.1')\n  123.456789.1\n  >>> to"}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list of strings only for ones that start with a grant prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Filter an input list of strings only for ones that start with a grant prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix))\n}\n\n/**\n  Filter an input list of strings based on a regular expression.\n  >>> filterByRegex([], 'a')\n  []\n  >>> filterByRegex(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByRegex = (strings, regex) => {\n  return strings.filter(string => regex.test(string))\n}\n\n/**\n  Filter an input list of strings based on a regular expression against a string.\n  >>> filterByRegex(['abc', 'bcd', 'cde', 'array'], 'ab|cd')\n  ['abc', 'cde', 'array']\n  */\nconst filterByRegexString = (strings, regex, options) => {\n  const { caseSensitive, ignoreCase, multiline, global: glob } = options\n  return strings.filter(string => {\n    const regex = new RegExp(regex, caseSensitive? '' : 'i')\n    return regex.test(string, ignoreCase? ignoreCase : glob)\n  })\n}\n\n/**\n  Filter an input list of strings based on a regular expression against a string.\n  >>> filterByRegexString([\n ...   'abc',\n ...   'bcd',\n ...   'cde',\n ...   'array',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|cd',\n ...   'ab|"}
{"task_id": "JavaScript/30", "prompt": "/*Return only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Return only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0).map(n => +n)\n}\n\n/*Return only negative numbers in the list.\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0).map(n => -n)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible = (l) => {\n  return l.filter(n => n % 3 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 5.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible5 = (l) => {\n  return l.filter(n => n % 5 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 7.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible7 = (l) => {\n  return l.filter(n => n % 7 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 9.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible9 = (l) => {\n  return l.filter(n => n % 9 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 11.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible11 = (l) => {\n  return l.filter(n => n % 11 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 13.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible13 = (l) => {\n  return l.filter(n => n % 13 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 15.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible15 = (l) => {\n  return l.filter(n => n % 15 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 17.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible17 = (l) => {\n  return l.filter(n => n % 17 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 19.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible19 = (l) => {\n  return l.filter(n => n % 19 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 23.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible23 = (l) => {\n  return l.filter(n => n % 23 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 29.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible29 = (l) => {\n  return l.filter(n => n % 29 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 31.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible31 = (l) => {\n  return l.filter(n => n % 31 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 35.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible35 = (l) => {\n  return l.filter(n => n % 35 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 37.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible37 = (l) => {\n  return l.filter(n => n % 37 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 39.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible39 = (l) => {\n  return l.filter(n => n % 39 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 42.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible42 = (l) => {\n  return l.filter(n => n % 4"}
{"task_id": "JavaScript/31", "prompt": "/*Return true if a given number equal choice, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Return true if a given number equal choice, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < Math.sqrt(n); i++) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\n/*\n  Given a number, return its prime factors.\n  >>> factors(6)\n  [2, 3, 5]\n  >>> factors(101)\n  [2, 3, 5]\n  >>> factors(11)\n  [2, 3, 5]\n  >>> factors(13441)\n  [2, 3, 5]\n  >>> factors(61)\n  [2, 3, 5]\n  >>> factors(4)\n  [2, 3, 5]\n  >>> factors(1)\n  [2, 3, 5]\n*/\nconst factors = (n) => {\n  let factors = [];\n  let i = 2;\n  while (n % i!== 0) {\n    factors.push(i);\n    i = i * 2;\n  }\n  return factors;\n};\n\n/*\n  Given a number, return its prime factorizations.\n  >>> factorizations(6)\n  [2, 3, 5]\n  >>> factorizations(101)\n  [2, 3, 5]\n  >>> factorizations(11)\n  [2, 3, 5]\n  >>> factorizations(13441)\n  [2, 3, 5]\n  >>> factorizations(61)\n  [2, 3, 5]\n  >>> factorizations(4)\n  [2, 3, 5]\n  >>> factorizations(1)\n  [2, 3, 5]\n*/\nconst factorizations = (n) => {\n  let factorizations = [];\n  let i = 2;\n  while (n % i!== 0) {\n    factorizations.push(i);\n    i = i * 2;\n  }\n  return factorizations;\n};\n\n/*\n  Given a number, return its prime factorizations.\n  >>> factorizations(6)\n  [2, 3, 5]\n  >>> factorizations(101)\n  [2, 3, 5]\n  >>> factorizations(11)\n  [2, 3, 5]\n  >>> factorizations(13441)\n  [2, 3, 5]\n  >>> factorizations(61)\n  [2, 3, 5]\n  >>> factorizations(4)\n  [2, 3, 5]\n  >>> factorizations(1)\n  [2, 3, 5]\n*/\nconst factorization = (n) => {\n  let factorizations = [];\n  let i = 2;\n  while (n % i!== 0) {\n    factorizations.push(i);\n    i = i * 2;\n  }\n  return factorizations;\n};\n\n/*\n  Given a number, return its prime factorizations.\n  >>> factorizations(6)\n  [2, 3, 5]\n  >>> factorizations(101)\n  [2, 3, 5]\n  >>> factorizations(11)\n  [2, 3, 5]\n  >>> factorizations(13441)\n  [2, 3, 5]\n  >>> factorizations(61)\n  [2, 3, 5]\n  >>> factorizations(4)\n  [2, 3, 5]\n  >>> factorizations(1)\n  [2, 3, 5]\n*/\nconst factorizations = (num) => {\n  let factorizations = [];\n  let i = 2;\n  while (num % i!== 0) {\n    factorizations.push(i);\n    i = i * 2;\n  }\n  return factorizations;\n};\n\n/*\n  Given a number, return its prime factorizations.\n  >>> factorizations(6)\n  [2, 3, 5]\n  >>> factorizations(101)\n  [2, 3, 5]\n  >>> factorizations(11)\n  [2, 3, 5]\n  >>> factorizations(13441)\n  [2, 3, 5]\n  >>> factorizations(61)\n  [2, 3, 5]\n  >>> factorizations(4)\n  [2, 3, 5]\n  >>> factorizations(1)\n  [2, 3, 5]\n*/\nconst factorization = (num) => {\n  let factorizations = [];\n  let i = 2;\n  while (num % i!== 0) {\n    factorizations.push(i);\n    i = i * 2;\n  }\n  return factorizations;\n};\n\n/*\n  Given a number, return its prime factorizations.\n  >>> factorizations(6)\n  [2, 3, 5]\n  >>> factorizations(101)\n  [2, 3, 5]\n  >>> factorizations(11)\n  [2, 3, 5]\n  >>> factorizations(13441)\n  [2, 3, 5]\n  >>> factorizations(61)\n  [2, 3, 5]\n  >>> factorizations(4)\n  [2, 3, 5]\n  >>> factorizations(1)\n  [2, 3, 5]\n*/\nconst factorizations = (num) => {\n  let factorizations = [];\n  let i = 2;\n  while (num % i!== 0) {\n    factorizations.push(i);\n    i = i * 2;\n  }\n  return factorizations;\n};\n\n/*\n  Given a number, return its prime factorizations.\n  >>> factorizations(6)\n  [2, 3, 5]\n  >>> factorizations(101)\n  [2, 3, 5]\n  >>> factorizations(11)\n  [2, 3, 5]\n  >>> factorizations(13441)\n  [2, 3, 5]\n  >>> factorizations(61)\n  [2, 3, 5]\n  >>> factorizations(4)\n  [2, 3, 5]\n  >>> factorizations(1)\n  [2, 3, 5]\n*/\nconst factorization = (num) => {\n  let factorizations = [];\n  let i = 2;\n  while (num % i!== 0) {\n    factorizations.push(i);\n    i = i * 2;\n  }\n  return factorizations;\n};\n\n/*\n  Given a number, return its prime factorizations.\n  >>> factorizations(6)\n  [2, 3, 5]\n  >>> factorizations(101)\n  [2, 3, 5]\n  >>> factorizations(11)\n  [2, 3, 5]\n  >>> factorizations(13441)\n  [2, 3, 5]\n  >>> factorizations(61)\n  [2, 3, 5]\n  >>> factorizations(4)\n  [2, 3, 5]\n  >>> factorizations(1)\n  [2, 3, 5]\n*/\nconst factorizations = (num) => {\n  let factorizations = [];\n  let i = 2;\n  while (num % i!== 0) {\n    factorizations.push(i);\n    i = i * 2;\n  }\n  return factorizations;\n};\n\n/*\n  Given a number, return its prime factorizations.\n  >>> factorizations(6)\n  [2, 3, 5]\n  >>> factorizations(101)\n  [2, 3, 5]\n  >>> factorizations(11)\n  [2, 3, 5]\n  >>> factorizations(13441)\n  [2, 3, 5]\n  >>> factorizations(61)\n  [2, 3, 5]\n  >>> factorizations(4)\n  [2, 3, 5]\n  >>> factorizations(1)\n  [2, 3, 5]\n*/\nconst factorization = (num) => {\n  let factorizations = [];\n  let i = 2;\n  while (num % i!== 0) {\n    factorizations.push(i);\n    i = i * 2;\n  }\n  return factorizations;\n};\n\n/*\n  Given a number, return its prime factorizations.\n  >>> factorizations(6)\n  [2, 3, 5]\n  >>> factorizations(101)\n  [2, 3, 5]\n  >>> factorizations(11)\n  [2, 3, 5]\n  >>> factorizations(13441)\n  [2, 3, 5]\n  >>> factorizations(61)\n  [2, 3, 5]\n  >>> factorizations(4)\n  [2, 3, 5]\n  >>> factorizations(1)\n  [2, 3, 5]\n*/\nconst factorizations = (num) => {\n  let factorizations = [];\n  let i = 2;\n  while (num % i!== 0) {\n    factorizations.push(i);\n    i = i * 2;\n  }\n  return factorizations;\n};\n\n/*\n  Given a number, return its prime factorizations.\n  >>> factorizations(6)\n  [2, 3, 5]\n  >>> factorizations(10"}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficients xs at point x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients of a polynomial. \n   findZero find x such that poly(x) = 0. \n   findZero recurrence only entirely zero point, even if there exist many. \n   Moreover, findZero only carry list xs having even number of coefficient \n   and largest non zero coefficient as it guarantee \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Evaluates polynomial with coefficients xs at point x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients of a polynomial. \n   findZero find x such that poly(x) = 0. \n   findZero recurrence only entirely zero point, even if there exist many. \n   Moreover, findZero only carry list xs having even number of coefficient \n   and largest non zero coefficient as it guarantee \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  const zero = xs.reduce((prev, item, index) => prev + item * Math.pow(0, index), 0);\n  return xs.reduce((prev, item, index) => prev + item * Math.pow(x, index), zero);\n};\n\n/**\n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * "}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns a list l' such that \n   l' is identical to l in the indicies that constitute not divisible by three, while its value at the indicies that are divisible by three are equal \n   to the value of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that \n   l' is identical to l in the indicies that constitute not divisible by three, while its value at the indicies that are divisible by three are equal \n   to the value of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  let l2 = l.slice();\n  l2.sort((a, b) => a - b);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that \n   l' is identical to l in the indicies that constitute not divisible by five, while its value at the indicies that are divisible by five are equal \n   to the value of the corresponding indicies of l, but sorted.\n  >>> sortFifth([1, 2, 3])\n  [1, 2, 3]\n  >>> sortFifth([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortFifth = (l) => {\n  let l2 = l.slice();\n  l2.sort((a, b) => a - b);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that \n   l' is identical to l in the indicies that constitute not divisible by nine, while its value at the indicies that are divisible by nine are equal \n   to the value of the corresponding indicies of l, but sorted.\n  >>> sortNinth([1, 2, 3])\n  [1, 2, 3]\n  >>> sortNinth([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortNinth = (l) => {\n  let l2 = l.slice();\n  l2.sort((a, b) => a - b);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that \n   l' is identical to l in the indicies that constitute not divisible by ten, while its value at the indicies that are divisible by ten are equal \n   to the value of the corresponding indicies of l, but sorted.\n  >>> sortTenth([1, 2, 3])\n  [1, 2, 3]\n  >>> sortTenth([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortTenth = (l) => {\n  let l2 = l.slice();\n  l2.sort((a, b) => a - b);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that \n   l' is identical to l in the indicies that constitute not divisible by eleven, while its value at the indicies that are divisible by eleven are equal \n   to the value of the corresponding indicies of l, but sorted.\n  >>> sortEleventh([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEleventh([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortEleventh = (l) => {\n  let l2 = l.slice();\n  l2.sort((a, b) => a - b);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that \n   l' is identical to l in the indicies that constitute not divisible by twelve, while its value at the indicies that are divisible by twelve are equal \n   to the value of the corresponding indicies of l, but sorted.\n  >>> sortTwelveth([1, 2, 3])\n  [1, 2, 3]\n  >>> sortTwelveth([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortTwelveth = (l) => {\n  let l2 = l.slice();\n  l2.sort((a, b) => a - b);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that \n   l' is identical to l in the indicies that constitute not divisible by thirteen, while its value at the indicies that are divisible by thirteen are equal \n   to the value of the corresponding indicies of l, but sorted.\n  >>> sortThirteenth([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThirteenth([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThirteenth = (l) => {\n  let l2 = l.slice();\n  l2.sort((a, b) => a - b);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that \n   l' is identical to l in the indicies that constitute not divisible by fourteen, while its value at the indicies that are divisible by fourteen are equal \n   to the value of the corresponding indicies of l, but sorted.\n  >>> sortFourteenth([1, 2, 3])\n  [1, 2, 3]\n  >>> sortFourteenth([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortFourteenth = (l) => {\n  let l2 = l.slice();\n  l2.sort((a, b) => a - b);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that \n   l' is identical to l in the indicies that constitute not divisible by fifteen, while its value at the indicies that are divisible by fifteen are equal \n   to the value of the corresponding indicies of l, but sorted.\n  >>> sortFifteenth([1, 2, 3])\n  [1, 2, 3]\n  >>> sortFifteenth([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortFifteenth = (l) => {\n  let l2 = l.slice();\n  l2.sort((a, b) => a - b);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that \n   l' is identical to l in the indicies that constitute not divisible by sixteen, while its value at the indicies that are divisible by sixteen are equal \n   to the value of the corresponding indicies of l, but sorted.\n  >>> sortSixteenth([1, 2, 3])\n  [1, 2, 3]\n  >>> sortSixteenth([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortSixteenth = (l) => {\n  let l2 = l.slice();\n  l2.sort((a, b) => a - b);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that \n   l' is identical to l in the indicies that constitute not divisible by seventeen, while its value at the indicies that are divisible by seventeen are equal \n   to the value of the corresponding indicies of l, but sorted.\n  >>> sortSeventeenth([1, 2, 3])\n  [1, 2, 3]\n  >>> sortSeventeenth([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortSeventeenth = (l) => {\n  let l2 = l.slice();\n  l2.sort((a, b) => a - b);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that \n   l' is identical to l in the indicies that constitute not divisible by eighteen, while its value at the indicies that are divisible by eighteen are equal \n   to the value of the corresponding indicies of l, but sorted.\n  >>> sortEighteenth([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEighteenth([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortEighteenth = (l) => {\n  let l2 = l.slice"}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let seen = {}\n  return l.filter((v, i, a) => {\n    if (!seen[v]) {\n      seen[v] = true\n      return false\n    }\n    return true\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (key, l) => {\n  let seen = {}\n  return l.filter((v, i, a) => {\n    if (!seen[key]) {\n      seen[key] = true\n      return false\n    }\n    return true\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key, l) => {\n  let seen = {}\n  return l.filter((v, i, a) => {\n    if (!seen[key]) {\n      seen[key] = true\n      return false\n    }\n    return true\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key, l) => {\n  let seen = {}\n  return l.filter((v, i, a) => {\n    if (!seen[key]) {\n      seen[key] = true\n      return false\n    }\n    return true\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key, l) => {\n  let seen = {}\n  return l.filter((v, i, a) => {\n    if (!seen[key]) {\n      seen[key] = true\n      return false\n    }\n    return true\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key, l) => {\n  let seen = {}\n  return l.filter((v, i, a) => {\n    if (!seen[key]) {\n      seen[key] = true\n      return false\n    }\n    return true\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key, l) => {\n  let seen = {}\n  return l.filter((v, i, a) => {\n    if (!seen[key]) {\n      seen[key] = true\n      return false\n    }\n    return true\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key, l) => {\n  let seen = {}\n  return l.filter((v, i, a) => {\n    if (!seen[key]) {\n      seen[key] = true\n      return false\n    }\n    return true\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key, l) => {\n  let seen = {}\n  return l.filter((v, i, a) => {\n    if (!seen[key]) {\n      seen[key] = true\n      return false\n    }\n    return true\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key, l) => {\n  let seen = {}\n  return l.filter((v, i, a) => {\n    if (!seen[key]) {\n      seen[key] = true\n      return false\n    }\n    return true\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key, l) => {\n  let seen = {}\n  return l.filter((v, i, a) => {\n    if (!seen[key]) {\n      seen[key] = true\n      return false\n    }\n    return true\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key, l) => {\n  let seen = {}\n  return l.filter((v, i, a) => {\n    if (!seen[key]) {\n      seen[key] = true\n      return false\n    }\n    return true\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key, l) => {\n  let seen = {}\n  return l.filter((v, i, a) => {\n    if (!seen[key]) {\n      seen[key] = true\n      return false\n    }\n    return true\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key, l) => {\n  let seen = {}\n  return l.filter((v, i, a) => {\n    if (!seen[key]) {\n      seen[key] = true\n      return false\n    }\n    return true\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key, l) => {\n  let seen = {}\n  return l.filter((v, i, a) => {\n    if (!seen[key]) {\n      seen[key] = true\n      return false\n    }\n    return true\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key, l) => {\n  let seen = {}\n  return l.filter((v, i, a) => {\n    if (!seen[key]) {\n      seen[key] = true\n      return false\n    }\n    return true\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key, l) => {\n  let seen = {}\n  return l.filter((v, i, a) => {\n    if (!seen[key]) {\n      seen[key] = true\n      return false\n    }\n    return true\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key, l) => {\n  let seen = {}\n  return l.filter((v, i, a) => {\n    if (!seen[key]) {\n      seen[key] = true\n      return false\n    }\n    return true\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueBy = (key, l) => {\n  let seen = {}\n  return l.filter((v, i, "}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Return maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  return l.length > 0? l[l.length - 1] : undefined;\n};\n\n/*Return minimum element in the list.\n  >>> minElement([1, 2, 3])\n  1\n  >>> minElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -5\n  */\nconst minElement = (l) => {\n  return l.length > 0? l[0] : undefined;\n};\n\n/*Return element at position i in the list.\n  >>> elementAt([1, 2, 3], 1)\n  2\n  >>> elementAt([1, 2, 3], 2)\n  3\n  >>> elementAt([1, 2, 3], 3)\n  undefined\n  */\nconst elementAt = (l, i) => {\n  return l.length > i? l[i] : undefined;\n};\n\n/*Return element at position i in the list starting from position j.\n  >>> elementAtStart([1, 2, 3], 1)\n  2\n  >>> elementAtStart([1, 2, 3], 2)\n  3\n  >>> elementAtStart([1, 2, 3], 3)\n  undefined\n  */\nconst elementAtStart = (l, j) => {\n  return l.length > j? l[j] : undefined;\n};\n\n/*Return element at position i in the list starting from position j.\n  >>> elementAtEnd([1, 2, 3], 1)\n  3\n  >>> elementAtEnd([1, 2, 3], 2)\n  2\n  >>> elementAtEnd([1, 2, 3], 3)\n  undefined\n  */\nconst elementAtEnd = (l, j) => {\n  return l.length > j? l[j + 1] : undefined;\n};\n\n/*Return element at position i in the list starting from position j.\n  >>> elementAtBothStart([1, 2, 3], 1)\n  2\n  >>> elementAtBothStart([1, 2, 3], 2)\n  3\n  >>> elementAtBothStart([1, 2, 3], 3)\n  undefined\n  */\nconst elementAtBothStart = (l, j) => {\n  return l.length > j? l[j] : undefined;\n};\n\n/*Return element at position i in the list starting from position j.\n  >>> elementAtBothEnd([1, 2, 3], 1)\n  3\n  >>> elementAtBothEnd([1, 2, 3], 2)\n  2\n  >>> elementAtBothEnd([1, 2, 3], 3)\n  undefined\n  */\nconst elementAtBothEnd = (l, j) => {\n  return l.length > j? l[j + 1] : undefined;\n};\n\n/*Return element at position i in the list starting from position j.\n  >>> elementAtBothBothStart([1, 2, 3], 1)\n  2\n  >>> elementAtBothBothStart([1, 2, 3], 2)\n  3\n  >>> elementAtBothBothStart([1, 2, 3], 3)\n  undefined\n  */\nconst elementAtBothBothStart = (l, j) => {\n  return l.length > j? l[j] : undefined;\n};\n\n/*Return element at position i in the list starting from position j.\n  >>> elementAtBothBothEnd([1, 2, 3], 1)\n  3\n  >>> elementAtBothBothEnd([1, 2, 3], 2)\n  2\n  >>> elementAtBothBothEnd([1, 2, 3], 3)\n  undefined\n  */\nconst elementAtBothBothEnd = (l, j) => {\n  return l.length > j? l[j + 1] : undefined;\n};\n\n/*Return element at position i in the list starting from position j.\n  >>> elementAtBothBothBothStart([1, 2, 3], 1)\n  2\n  >>> elementAtBothBothStart([1, 2, 3], 2)\n  3\n  >>> elementAtBothBothStart([1, 2, 3], 3)\n  undefined\n  */\nconst elementAtBothBothEnd = (l, j) => {\n  return l.length > j? l[j + 1] : undefined;\n};\n\n/*Return element at position i in the list starting from position j.\n  >>> elementAtBothBothBothStart([1, 2, 3], 1)\n  2\n  >>> elementAtBothBothStart([1, 2, 3], 2)\n  3\n  >>> elementAtBothBothStart([1, 2, 3], 3)\n  undefined\n  */\nconst elementAtBothBothBothEnd = (l, j) => {\n  return l.length > j? l[j + 1] : undefined;\n};\n\n/*Return element at position i in the list starting from position j.\n  >>> elementAtBothBothBothStart([1, 2, 3], 1)\n  2\n  >>> elementAtBothBothStart([1, 2, 3], 2)\n  3\n  >>> elementAtBothBothStart([1, 2, 3], 3)\n  undefined\n  */\nconst elementAtBothBothBothEnd = (l, j) => {\n  return l.length > j? l[j + 1] : undefined;\n};\n\n/*Return element at position i in the list starting from position j.\n  >>> elementAtBothBothStart([1, 2, 3], 1)\n  2\n  >>> elementAtBothBothStart([1, 2, 3], 2)\n  3\n  >>> elementAtBothBothStart([1, 2, 3], 3)\n  undefined\n  */\nconst elementAtBothBothEnd = (l, j) => {\n  return l.length > j? l[j + 1] : undefined;\n};\n\n/*Return element at position i in the list starting from position j.\n  >>> elementAtBothBothStart([1, 2, 3], 1)\n  2\n  >>> elementAtBothBothStart([1, 2, 3], 2)\n  3\n  >>> elementAtBothBothStart([1, 2, 3], 3)\n  undefined\n  */\nconst elementAtBothBothEnd = (l, j) => {\n  return l.length > j? l[j + 1] : undefined;\n};\n\n/*Return element at position i in the list starting from position j.\n  >>> elementAtBothBothStart([1, 2, 3], 1)\n  2\n  >>> elementAtBothBothStart([1, 2, 3], 2)\n  3\n  >>> elementAtBothBothStart([1, 2, 3], 3)\n  undefined\n  */\nconst elementAtBothBothEnd = (l, j) => {\n  return l.length > j? l[j + 1] : undefined;\n};\n\n/*Return element at position i in the list starting from position j.\n  >>> elementAtBothBothStart([1, 2, 3], 1)\n  2\n  >>> elementAtBothBothStart([1, 2, 3], 2)\n  3\n  >>> elementAtBothBothStart([1, 2, 3], 3)\n  undefined\n  */\nconst elementAtBothBothEnd = (l, j) => {\n  return l.length > j? l[j + 1] : undefined;\n};\n\n/*Return element at position i in the list starting from position j.\n  >>> elementAtBothBothStart([1, 2, 3], 1)\n  2\n  >>> elementAtBothBothStart([1, 2, 3], 2)\n  3\n  >>> elementAtBothBothStart([1, 2, 3], 3)\n  undefined\n  */\nconst elementAtBothBothEnd = (l, j) => {\n  return l.length > j? l[j + 1] : undefined;\n};\n\n/*Return element at position i in the list starting from position j.\n  >>> elementAtBothBothStart([1, 2, 3], 1)\n  2\n  >>> elementAtBothBothStart([1, 2, 3], 2)\n  3\n  >>> elementAtBothBothStart([1, 2, 3], 3)\n  undefined\n  */\nconst elementAtBothBothEnd = (l, j) => {\n  return l.length > j? l[j + 1] : undefined;\n};\n\n/*Return element at position i in the list starting from position j.\n  >>> elementAtBothBothStart([1, 2, 3], 1)\n  2\n  >>> elementAtBothBothStart([1, 2, 3], 2)\n  3\n  >>> elementAtBothBothStart([1, 2, 3], 3)\n  undefined\n  */\nconst elementAtBothBothEnd = (l, j) => {\n  return l.length > j? l[j + 1] : undefined;\n};\n\n/*Return element at position i in the list starting from position j.\n  >>> elementAtBothBothStart([1, 2, 3], 1)\n  2\n  >>> elementAtBothBothStart([1, 2, "}
{"task_id": "JavaScript/36", "prompt": "/*Return the number of times the digit 7 appear in integer less than n which be divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Return the number of times the digit 7 appear in integer less than n which be divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 8 appear in integer less than n which be divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 8) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 9 appear in integer less than n which be divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 9) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 0 appear in integer less than n which be divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 0) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 1 appear in integer less than n which be divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 1) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 2 appear in integer less than n which be divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 2) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 3 appear in integer less than n which be divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 3) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 4 appear in integer less than n which be divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 4) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 5 appear in integer less than n which be divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 5) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 6 appear in integer less than n which be divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 6) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 7 appear in integer less than n which be divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 8 appear in integer less than n which be divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 8) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 9 appear in integer less than n which be divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 9) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 0 appear in integer less than n which be divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3"}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and returns a list l' such that \n   l' is identical to l in the odd indicies, while its values at the even indicies constitute equal \n   to the value of the even indicies of l, but classify.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that \n   l' is identical to l in the odd indicies, while its values at the even indicies constitute equal \n   to the value of the even indicies of l, but classify.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  let even = l.filter((item, index) => index % 2 === 0);\n  let odd = l.filter((item, index) => index % 2!== 0);\n  return [...odd,...even];\n};\n\n/*This function takes a list l and returns a list l' such that \n   l' is identical to l in the even indicies, while its values at the odd indicies constitute \n   equal to the value of the odd indicies of l, but classify.\n  >>> sortOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortOdd([5, 6, 3, 4])\n  [4, 3, 2, 1]\n  */\nconst sortOdd = (l) => {\n  let even = l.filter((item, index) => index % 2 === 0);\n  let odd = l.filter((item, index) => index % 2!== 0);\n  return [...even,...odd];\n};\n\n/*This function takes a list l and returns a list l' such that \n   l' is identical to l in the even and odd indicies, while its values at the even indicies \n   constitute equal to the value of the even indicies of l, but classify.\n  >>> sortEvenOdd([1, 2, 3])\n  [1, 2, 3, 5]\n  >>> sortEvenOdd([5, 6, 3, 4])\n  [5, 6, 3, 4, 1]\n  */\nconst sortEvenOdd = (l) => {\n  let even = l.filter((item, index) => index % 2 === 0);\n  let odd = l.filter((item, index) => index % 2!== 0);\n  return [...odd,...even];\n};\n\n/*This function takes a list l and returns a list l' such that \n   l' is identical to l in the even and odd indicies, while its values at the odd indicies \n   constitute equal to the value of the odd indicies of l, but classify.\n  >>> sortEvenOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sortEvenOddOdd([5, 6, 3, 4])\n  [5, 6, 3, 4, 1, 2]\n  */\nconst sortEvenOddOdd = (l) => {\n  let even = l.filter((item, index) => index % 2 === 0);\n  let odd = l.filter((item, index) => index % 2!== 0);\n  return [...odd,...even];\n};\n\n/*This function takes a list l and returns a list l' such that \n   l' is identical to l in the even and odd indicies, while its values at the even indicies \n   constitute equal to the value of the even indicies of l, but classify.\n  >>> sortEvenOddOddOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6, 4]\n  >>> sortEvenOddOddOddOdd([5, 6, 3, 4])\n  [5, 6, 3, 4, 1, 2, 2]\n  */\nconst sortEvenOddOddOdd = (l) => {\n  let even = l.filter((item, index) => index % 2 === 0);\n  let odd = l.filter((item, index) => index % 2!== 0);\n  return [...odd,...even];\n};\n\n/*This function takes a list l and returns a list l' such that \n   l' is identical to l in the even and odd indicies, while its values at the odd indicies \n   constitute equal to the value of the odd indicies of l, but classify.\n  >>> sortEvenOddOddOddOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6, 4, 2]\n  >>> sortEvenOddOddOddOddOddOdd([5, 6, 3, 4])\n  [5, 6, 3, 4, 1, 2, 2, 2]\n  */\nconst sortEvenOddOddOddOdd = (l) => {\n  let even = l.filter((item, index) => index % 2 === 0);\n  let odd = l.filter((item, index) => index % 2!== 0);\n  return [...odd,...even];\n};\n\n/*This function takes a list l and returns a list l' such that \n   l' is identical to l in the even and odd indicies, while its values at the odd indicies \n   constitute equal to the value of the odd indicies of l, but classify.\n  >>> sortEvenOddOddOddOddOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6, 4, 2]\n  >>> sortEvenOddOddOddOddOddOdd([5, 6, 3, 4])\n  [5, 6, 3, 4, 1, 2, 2, 2]\n  */\nconst sortEvenOddOddOddOddOdd = (l) => {\n  let even = l.filter((item, index) => index % 2 === 0);\n  let odd = l.filter((item, index) => index % 2!== 0);\n  return [...odd,...even];\n};\n\n/*This function takes a list l and returns a list l' such that \n   l' is identical to l in the even and odd indicies, while its values at the odd indicies \n   constitute equal to the value of the odd indicies of l, but classify.\n  >>> sortEvenOddOddOddOddOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6, 4, 2]\n  >>> sortEvenOddOddOddOddOddOdd([5, 6, 3, 4])\n  [5, 6, 3, 4, 1, 2, 2, 2]\n  */\nconst sortEvenOddOddOddOddOddOdd = (l) => {\n  let even = l.filter((item, index) => index % 2 === 0);\n  let odd = l.filter((item, index) => index % 2!== 0);\n  return [...odd,...even];\n};\n\n/*This function takes a list l and returns a list l' such that \n   l' is identical to l in the even and odd indicies, while its values at the odd indicies \n   constitute equal to the value of the odd indicies of l, but classify.\n  >>> sortEvenOddOddOddOddOddOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6, 4, 2]\n  >>> sortEvenOddOddOddOddOddOddOdd([5, 6, 3, 4])\n  [5, 6, 3, 4, 1, 2, 2, 2]\n  */\nconst sortEvenOddOddOddOddOddOddOdd = (l) => {\n  let even = l.filter((item, index) => index % 2 === 0);\n  let odd = l.filter((item, index) => index % 2!== 0);\n  return [...odd,...even];\n};\n\n/*This function takes a list l and returns a list l' such that \n   l' is identical to l in the even and odd indicies, while its values at the odd indicies \n   constitute equal to the value of the odd indicies of l, but classify.\n  >>> sortEvenOddOddOddOddOddOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6, 4, 2]\n  >>> sortEvenOddOddOddOddOddOddOddOdd([5, 6, 3, 4])\n  [5, 6, 3, 4, 1, 2, 2, 2]\n  */\nconst sortEvenOddOddOddOddOddOddOdd = (l) => {\n  let even = l.filter((item, index) => index % 2 === 0);\n  let odd = l.filter((item, index) => index % 2!== 0);\n  return ["}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoded string by cycling groups of three character. \n   * / \n const encodeCyclic = (s) = > { \n   volt-ampere groups = [ ], groups2 = [ ]; \n   for (permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes as input string encode with encode_cyclic routine. Returns decode string. \n   * / \n const decodeCyclic = (s) = > {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  returns encoded string by cycling groups of three character. \n   * / \n const encodeCyclic = (s) = > { \n   volt-ampere groups = [ ], groups2 = [ ]; \n   for (permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes as input string encode with encode_cyclic routine. Returns decode string. \n   * / \n const decodeCyclic = (s) = > {\n   volt-ampere groups = [ ], groups2 = [ ]; \n   for (permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2;\n}\n*/\n\n/*\n  returns true if string contains only letters, digits and underscore. \n   * / \n const isAlpha = (s) = > { \n   const chars = s.split('');\n   for (let i = 0; i < chars.length; i++) { \n     if (chars[i].match(/[a-zA-Z0-9_]/)) { \n       return true; \n     } \n   } \n   return false; \n}\n\n/*\n  returns true if string contains only letters, digits and underscore. \n   * / \n const isAlpha = (s) = > { \n   const chars = s.split('');\n   for (let i = 0; i < chars.length; i++) { \n     if (chars[i].match(/[a-zA-Z0-9_]/)) { \n       return true; \n     } \n   } \n   return false; \n}\n\n/*\n  returns true if string contains only letters, digits and underscore. \n   * / \n const isAlpha = (s) = > { \n   const chars = s.split('');\n   for (let i = 0; i < chars.length; i++) { \n     if (chars[i].match(/[a-zA-Z0-9_]/)) { \n       return true; \n     } \n   } \n   return false; \n}\n\n/*\n  returns true if string contains only letters, digits and underscore. \n   * / \n const isAlpha = (s) = > { \n   const chars = s.split('');\n   for (let i = 0; i < chars.length; i++) { \n     if (chars[i].match(/[a-zA-Z0-9_]/)) { \n       return true; \n     } \n   } \n   return false; \n}\n\n/*\n  returns true if string contains only letters, digits and underscore. \n   * / \n const isAlpha = (s) = > { \n   const chars = s.split('');\n   for (let i = 0; i < chars.length; i++) { \n     if (chars[i].match(/[a-zA-Z0-9_]/)) { \n       return true; \n     } \n   } \n   return false; \n}\n\n/*\n  returns true if string contains only letters, digits and underscore. \n   * / \n const isAlpha = (s) = > { \n   const chars = s.split('');\n   for (let i = 0; i < chars.length; i++) { \n     if (chars[i].match(/[a-zA-Z0-9_]/)) { \n       return true; \n     } \n   } \n   return false; \n}\n\n/*\n  returns true if string contains only letters, digits and underscore. \n   * / \n const isAlpha = (s) = > { \n   const chars = s.split('');\n   for (let i = 0; i < chars.length; i++) { \n     if (chars[i].match(/[a-zA-Z0-9_]/)) { \n       return true; \n     } \n   } \n   return false; \n}\n\n/*\n  returns true if string contains only letters, digits and underscore. \n   * / \n const isAlpha = (s) = > { \n   const chars = s.split('');\n   for (let i = 0; i < chars.length; i++) { \n     if (chars[i].match(/[a-zA-Z0-9_]/)) { \n       return true; \n     } \n   } \n   return false; \n}\n\n/*\n  returns true if string contains only letters, digits and underscore. \n   * / \n const isAlpha = (s) = > { \n   const chars = s.split('');\n   for (let i = 0; i < chars.length; i++) { \n     if (chars[i].match(/[a-zA-Z0-9_]/)) { \n       return true; \n     } \n   } \n   return false; \n}\n\n/*\n  returns true if string contains only letters, digits and underscore. \n   * / \n const isAlpha = (s) = > { \n   const chars = s.split('');\n   for (let i = 0; i < chars.length; i++) { \n     if (chars[i].match(/[a-zA-Z0-9_]/)) { \n       return true; \n     } \n   } \n   return false; \n}\n\n/*\n  returns true if string contains only letters, digits and underscore. \n   * / \n const isAlpha = (s) = > { \n   const chars = s.split('');\n   for (let i = 0; i < chars.length; i++) { \n     if (chars[i].match(/[a-zA-Z0-9_]/)) { \n       return true; \n     } \n   } \n   return false; \n}\n\n/*\n  returns true if string contains only letters, digits and underscore. \n   * / \n const isAlpha = (s) = > { \n   const chars = s.split('');\n   for (let i = 0; i < chars.length; i++) { \n     if (chars[i].match(/[a-zA-Z0-9_]/)) { \n       return true; \n     } \n   } \n   return false; \n}\n\n/*\n  returns true if string contains only letters, digits and underscore. \n   * / \n const isAlpha = (s) = > { \n   const chars = s.split('');\n   for (let i = 0; i < chars.length; i++) { \n     if (chars[i].match(/[a-zA-Z0-9_]/)) { \n       return true; \n     } \n   } \n   return false; \n}\n\n/*\n  returns true if string contains only letters, digits and underscore. \n   * / \n const isAlpha = (s) = > { \n   const chars = s.split('');\n   for (let i = 0; i < chars.length; i++) { \n     if (chars[i].match(/[a-zA-Z0-9_]/)) { \n       return true; \n     } \n   } \n   return false; \n}\n\n/*\n  returns true if string contains only letters, digits and underscore. \n   * / \n const isAlpha = (s) = > { \n   const chars = s.split('');\n   for (let i = 0; i < chars.length; i++) { \n     if (chars[i].match(/[a-zA-Z0-9_]/)) { \n       return true; \n     } \n   } \n   return false; \n}\n\n/*\n  returns true if string contains only letters, digits and underscore. \n   * / \n const isAlpha = (s) = > { \n   const chars = s.split('');\n   for (let i = 0; i < chars.length; i++) { \n     if (chars[i].match(/[a-zA-Z0-9_]/)) { \n       return true; \n     } \n   } \n   return false; \n}\n\n/*\n  returns true if string contains only letters, digits and underscore. \n   * / \n const isAlpha = (s) = > { \n   const chars = s.split('');\n   for (let i = 0; i < chars.length; i++) { \n     if (chars[i].match(/[a-zA-Z0-9_]/)) { \n       return true; \n     } \n   } \n   return false; \n}\n\n/*\n  returns true if string contains only letters, digits and underscore. \n   * / \n const isAlpha = (s) = > { \n   const chars = s.split('');\n"}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns n-th number that is a Fibonacci number and it's also premier.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  primeFib returns n-th number that is a Fibonacci number and it's also premier.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  let a = 1, b = 1, c = 1, d = 1;\n  do {\n    const d = a + b;\n    if (d === n) {\n      return d;\n    }\n    c += d;\n    a = b;\n    b = d;\n  } while (c < n);\n};\n\n/*\n  primeFib returns n-th number that is a Fibonacci number and it's also premier.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFibPremier = (prime, n) => {\n  let a = 1, b = 1, c = 1, d = 1;\n  do {\n    const d = a + b;\n    if (d === n) {\n      return d;\n    }\n    c += d;\n    a = b;\n    b = d;\n  } while (c < n);\n};\n\n/*\n  primeFib returns n-th number that is a Fibonacci number and it's also premier.\n  >>> primeFibPremier(1, 5)\n  2\n  >>> primeFibPremier(2, 5)\n  3\n  >>> primeFibPremier(3, 5)\n  5\n  >>> primeFibPremier(4, 5)\n  13\n  >>> primeFibPremier(5, 5)\n  89\n  */\nconst primeFibPremierPremier = (prime, n) => {\n  let a = 1, b = 1, c = 1, d = 1;\n  do {\n    const d = a + b;\n    if (d === n) {\n      return d;\n    }\n    c += d;\n    a = b;\n    b = d;\n  } while (c < n);\n};\n\n/*\n  primeFib returns n-th number that is a Fibonacci number and it's also premier.\n  >>> primeFibPremierPremier(1, 5)\n  2\n  >>> primeFibPremierPremier(2, 5)\n  3\n  >>> primeFibPremierPremier(3, 5)\n  5\n  >>> primeFibPremierPremier(4, 5)\n  13\n  >>> primeFibPremierPremier(5, 5)\n  89\n  */\nconst primeFibPremierPremierPremier = (prime, n) => {\n  let a = 1, b = 1, c = 1, d = 1;\n  do {\n    const d = a + b;\n    if (d === n) {\n      return d;\n    }\n    c += d;\n    a = b;\n    b = d;\n  } while (c < n);\n};\n\n/*\n  primeFib returns n-th number that is a Fibonacci number and it's also premier.\n  >>> primeFibPremierPremierPremier(1, 5)\n  2\n  >>> primeFibPremierPremierPremier(2, 5)\n  3\n  >>> primeFibPremierPremierPremier(3, 5)\n  5\n  >>> primeFibPremierPremierPremier(4, 5)\n  13\n  >>> primeFibPremierPremierPremier(5, 5)\n  89\n  */\nconst primeFibPremierPremierPremierPremier = (prime, n) => {\n  let a = 1, b = 1, c = 1, d = 1;\n  do {\n    const d = a + b;\n    if (d === n) {\n      return d;\n    }\n    c += d;\n    a = b;\n    b = d;\n  } while (c < n);\n};\n\n/*\n  primeFib returns n-th number that is a Fibonacci number and it's also premier.\n  >>> primeFibPremierPremierPremierPremier(1, 5)\n  2\n  >>> primeFibPremierPremierPremierPremier(2, 5)\n  3\n  >>> primeFibPremierPremierPremierPremier(3, 5)\n  5\n  >>> primeFibPremierPremierPremierPremier(4, 5)\n  13\n  >>> primeFibPremierPremierPremierPremier(5, 5)\n  89\n  */\nconst primeFibPremierPremierPremierPremierPremier = (prime, n) => {\n  let a = 1, b = 1, c = 1, d = 1;\n  do {\n    const d = a + b;\n    if (d === n) {\n      return d;\n    }\n    c += d;\n    a = b;\n    b = d;\n  } while (c < n);\n};\n\n/*\n  primeFib returns n-th number that is a Fibonacci number and it's also premier.\n  >>> primeFibPremierPremierPremierPremierPremier(1, 5)\n  2\n  >>> primeFibPremierPremierPremierPremierPremier(2, 5)\n  3\n  >>> primeFibPremierPremierPremierPremierPremier(3, 5)\n  5\n  >>> primeFibPremierPremierPremierPremierPremier(4, 5)\n  13\n  >>> primeFibPremierPremierPremierPremierPremier(5, 5)\n  89\n  */\nconst primeFibPremierPremierPremierPremierPremierPremier = (prime, n) => {\n  let a = 1, b = 1, c = 1, d = 1;\n  do {\n    const d = a + b;\n    if (d === n) {\n      return d;\n    }\n    c += d;\n    a = b;\n    b = d;\n  } while (c < n);\n};\n\n/*\n  primeFib returns n-th number that is a Fibonacci number and it's also premier.\n  >>> primeFibPremierPremierPremierPremierPremier(1, 5)\n  2\n  >>> primeFibPremierPremierPremierPremierPremier(2, 5)\n  3\n  >>> primeFibPremierPremierPremierPremierPremier(3, 5)\n  5\n  >>> primeFibPremierPremierPremierPremierPremier(4, 5)\n  13\n  >>> primeFibPremierPremierPremierPremierPremier(5, 5)\n  89\n  */\nconst primeFibPremierPremierPremierPremierPremierPremier = (prime, n) => {\n  let a = 1, b = 1, c = 1, d = 1;\n  do {\n    const d = a + b;\n    if (d === n) {\n      return d;\n    }\n    c += d;\n    a = b;\n    b = d;\n  } while (c < n);\n};\n\n/*\n  primeFib returns n-th number that is a Fibonacci number and it's also premier.\n  >>> primeFibPremierPremierPremierPremierPremierPremier(1, 5)\n  2\n  >>> primeFibPremierPremierPremierPremierPremierPremier(2, 5)\n  3\n  >>> primeFibPremierPremierPremierPremierPremierPremier(3, 5)\n  5\n  >>> primeFibPremierPremierPremi"}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes a list of integers as an input. \n   it returns dependable if there be three distinct elements in the list that \n   kernel to zero, and false differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  triplesSumToZero takes a list of integers as an input. \n   it returns dependable if there be three distinct elements in the list that \n   kernel to zero, and false differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) sum += l[i];\n  }\n  return sum === 0;\n};\n\n/*\n  triplesSumToOne takes a list of integers as an input. \n   it returns dependable if there be three distinct elements in the list that \n   kernel to one, and false differently.\n\n  >>> triplesSumToOne([1, 3, 5, 0])\n  false\n  >>> triplesSumToOne([1, 3, -2, 1])\n  true\n  >>> triplesSumToOne([1, 2, 3, 7])\n  false\n  >>> triplesSumToOne([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToOne([1])\n  false\n  */\nconst triplesSumToOne = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) sum += l[i];\n  }\n  return sum === 1;\n};\n\n/*\n  triplesSumToTwo takes a list of integers as an input. \n   it returns dependable if there be three distinct elements in the list that \n   kernel to two, and false differently.\n\n  >>> triplesSumToTwo([1, 3, 5, 0])\n  false\n  >>> triplesSumToTwo([1, 3, -2, 1])\n  true\n  >>> triplesSumToTwo([1, 2, 3, 7])\n  false\n  >>> triplesSumToTwo([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToTwo([1])\n  false\n  */\nconst triplesSumToTwo = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) sum += l[i];\n  }\n  return sum === 2;\n};\n\n/*\n  triplesSumToThree takes a list of integers as an input. \n   it returns dependable if there be three distinct elements in the list that \n   kernel to three, and false differently.\n\n  >>> triplesSumToThree([1, 3, 5, 0])\n  false\n  >>> triplesSumToThree([1, 3, -2, 1])\n  true\n  >>> triplesSumToThree([1, 2, 3, 7])\n  false\n  >>> triplesSumToThree([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToThree([1])\n  false\n  */\nconst triplesSumToThree = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) sum += l[i];\n  }\n  return sum === 3;\n};\n\n/*\n  triplesSumToFour takes a list of integers as an input. \n   it returns dependable if there be three distinct elements in the list that \n   kernel to four, and false differently.\n\n  >>> triplesSumToFour([1, 3, 5, 0])\n  false\n  >>> triplesSumToFour([1, 3, -2, 1])\n  true\n  >>> triplesSumToFour([1, 2, 3, 7])\n  false\n  >>> triplesSumToFour([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToFour([1])\n  false\n  */\nconst triplesSumToFour = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) sum += l[i];\n  }\n  return sum === 4;\n};\n\n/*\n  triplesSumToFive takes a list of integers as an input. \n   it returns dependable if there be three distinct elements in the list that \n   kernel to five, and false differently.\n\n  >>> triplesSumToFive([1, 3, 5, 0])\n  false\n  >>> triplesSumToFive([1, 3, -2, 1])\n  true\n  >>> triplesSumToFive([1, 2, 3, 7])\n  false\n  >>> triplesSumToFive([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToFive([1])\n  false\n  */\nconst triplesSumToFive = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) sum += l[i];\n  }\n  return sum === 5;\n};\n\n/*\n  triplesSumToSix takes a list of integers as an input. \n   it returns dependable if there be three distinct elements in the list that \n   kernel to six, and false differently.\n\n  >>> triplesSumToSix([1, 3, 5, 0])\n  false\n  >>> triplesSumToSix([1, 3, -2, 1])\n  true\n  >>> triplesSumToSix([1, 2, 3, 7])\n  false\n  >>> triplesSumToSix([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToSix([1])\n  false\n  */\nconst triplesSumToSix = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) sum += l[i];\n  }\n  return sum === 6;\n};\n\n/*\n  triplesSumToSeven takes a list of integers as an input. \n   it returns dependable if there be three distinct elements in the list that \n   kernel to seven, and false differently.\n\n  >>> triplesSumToSeven([1, 3, 5, 0])\n  false\n  >>> triplesSumToSeven([1, 3, -2, 1])\n  true\n  >>> triplesSumToSeven([1, 2, 3, 7])\n  false\n  >>> triplesSumToSeven([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToSeven([1])\n  false\n  */\nconst triplesSumToSeven = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) sum += l[i];\n  }\n  return sum === 7;\n};\n\n/*\n  triplesSumToEight takes a list of integers as an input. \n   it returns dependable if there be three distinct elements in the list that \n   kernel to eight, and false differently.\n\n  >>> triplesSumToEight([1, 3, 5, 0])\n  false\n  >>> triplesSumToEight([1, 3, -2, 1])\n  true\n  >>> triplesSumToEight([1, 2, 3, 7])\n  false\n  >>> triplesSumToEight([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToEight([1])\n  false\n  */\nconst triplesSumToEight = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) sum += l[i];\n  }\n  return sum === 8;\n};\n\n/*\n  triplesSumToNine takes a list of integers as an input. \n   it returns dependable if there be three distinct elements in the list that \n   kernel to nine, and false differently.\n\n  >>> triplesSumToNine([1, 3, 5, 0])\n  false\n  >>> triplesSumToNine([1, 3, -2, 1])\n  true\n  >>> triplesSumToNine([1, 2, 3, 7])\n  false\n  >>> triplesSumToNine([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumTo"}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a perfectly square boundlessly long line. \n   n car are drive exit to correctly;   simultaneously, a unlike set of n car \n   are drive right to left.    The two sets of cars start out be very far from \n   each early.   All cars motivate in the like amphetamine.   Two cars are said to clash \n   when a car that's move left to proper hit a car that's move good to left. \n   However, the cars are infinitely sturdy and hard; as a solution, they continue be active \n   in their trajectory as if they did not clash. \n\n   This function output the number of such collisions. \n   * / \n const carRaceCollision = (n) = > {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Imagine a road that's a perfectly square boundlessly long line. \n   n car are drive exit to correctly;   simultaneously, a unlike set of n car \n   are drive right to left.    The two sets of cars start out be very far from \n   each early.   All cars motivate in the like amphetamine.   Two cars are said to clash \n   when a car that's move left to proper hit a car that's move good to left. \n   However, the cars are infinitely sturdy and hard; as a solution, they continue be active \n   in their trajectory as if they did not clash. \n\n   This function output the number of such collisions. \n   * / \n const carRaceCollision = (n) = > {\n   let collisions = 0;\n   let car1 = {x: 0, y: 0};\n   let car2 = {x: 0, y: 0};\n   let car3 = {x: 0, y: 0};\n   let car4 = {x: 0, y: 0};\n   let car5 = {x: 0, y: 0};\n   let car6 = {x: 0, y: 0};\n   let car7 = {x: 0, y: 0};\n   let car8 = {x: 0, y: 0};\n   let car9 = {x: 0, y: 0};\n   let car10 = {x: 0, y: 0};\n   let car11 = {x: 0, y: 0};\n   let car12 = {x: 0, y: 0};\n   let car13 = {x: 0, y: 0};\n   let car14 = {x: 0, y: 0};\n   let car15 = {x: 0, y: 0};\n   let car16 = {x: 0, y: 0};\n   let car17 = {x: 0, y: 0};\n   let car18 = {x: 0, y: 0};\n   let car19 = {x: 0, y: 0};\n   let car20 = {x: 0, y: 0};\n   let car21 = {x: 0, y: 0};\n   let car22 = {x: 0, y: 0};\n   let car23 = {x: 0, y: 0};\n   let car24 = {x: 0, y: 0};\n   let car25 = {x: 0, y: 0};\n   let car26 = {x: 0, y: 0};\n   let car27 = {x: 0, y: 0};\n   let car28 = {x: 0, y: 0};\n   let car29 = {x: 0, y: 0};\n   let car30 = {x: 0, y: 0};\n   let car31 = {x: 0, y: 0};\n   let car32 = {x: 0, y: 0};\n   let car33 = {x: 0, y: 0};\n   let car34 = {x: 0, y: 0};\n   let car35 = {x: 0, y: 0};\n   let car36 = {x: 0, y: 0};\n   let car37 = {x: 0, y: 0};\n   let car38 = {x: 0, y: 0};\n   let car39 = {x: 0, y: 0};\n   let car40 = {x: 0, y: 0};\n   let car41 = {x: 0, y: 0};\n   let car42 = {x: 0, y: 0};\n   let car43 = {x: 0, y: 0};\n   let car44 = {x: 0, y: 0};\n   let car45 = {x: 0, y: 0};\n   let car46 = {x: 0, y: 0};\n   let car47 = {x: 0, y: 0};\n   let car48 = {x: 0, y: 0};\n   let car49 = {x: 0, y: 0};\n   let car50 = {x: 0, y: 0};\n   let car51 = {x: 0, y: 0};\n   let car52 = {x: 0, y: 0};\n   let car53 = {x: 0, y: 0};\n   let car54 = {x: 0, y: 0};\n   let car55 = {x: 0, y: 0};\n   let car56 = {x: 0, y: 0};\n   let car57 = {x: 0, y: 0};\n   let car58 = {x: 0, y: 0};\n   let car59 = {x: 0, y: 0};\n   let car60 = {x: 0, y: 0};\n   let car61 = {x: 0, y: 0};\n   let car62 = {x: 0, y: 0};\n   let car63 = {x: 0, y: 0};\n   let car64 = {x: 0, y: 0};\n   let car65 = {x: 0, y: 0};\n   let car66 = {x: 0, y: 0};\n   let car67 = {x: 0, y: 0};\n   let car68 = {x: 0, y: 0};\n   let car69 = {x: 0, y: 0};\n   let car70 = {x: 0, y: 0};\n   let car71 = {x: 0, y: 0};\n   let car72 = {x: 0, y: 0};\n   let car73 = {x: 0, y: 0};\n   let car74 = {x: 0, y: 0};\n   let car75 = {x: 0, y: 0};\n   let car76 = {x: 0, y: 0};\n   let car77 = {x: 0, y: 0};\n   let car78 = {x: 0, y: 0};\n   let car79 = {x: 0, y: 0};\n   let car80 = {x: 0, y: 0};\n   let car81 = {x: 0, y: 0};\n   let car82 = {x: 0, y: 0};\n   let car83 = {x: 0, y: 0};\n   let car84 = {x: 0, y: 0};\n   let car85 = {x: 0, y: 0};\n   let car86 = {x: 0, y: 0};\n   let car87 = {x: 0, y: 0};\n   let car88 = {x: 0, y: 0};\n   let car89 = {x: 0, y: 0};\n   let car90 = {x: 0, y: 0};\n   let car91 = {x: 0, y: 0};\n   let car92 = {x: 0, y: 0};\n   let car93 = {x: 0, y: 0};\n   let car94 = {x: 0, y: 0};\n   let car95 = {x: 0, y: 0};\n   let car96 = {x: 0, y: 0};\n   let car97 = {x: 0, y: 0};\n   let car98 = {x: 0, y: 0};\n   let car99 = {x: 0, y: 0};\n   let car100 = {x: 0, y: 0};\n   let car101 = {x: 0, y: 0};\n   let car102 = {x: 0, y: 0};\n   let car103 = {x: 0, y: 0};\n   let car104 = {x: 0, y: 0};\n   let car105 = {x: 0, y: 0};\n   let car106 = {x: 0, y: 0};\n   let car107 = {x: 0, y: 0};\n   let car108 = {x: 0, y: 0};\n   let car109 = {x: 0, y: 0};\n   let car110 = {x: 0, y: 0};\n   let car111 = {x: 0, y: 0};\n   let car112 = {x: 0, y: 0};\n   let car113 = {x: 0, y: 0};\n   let car114 = {x: 0, y: 0};\n   let car115 = {x: 0, y: 0};\n   let car116 = {x: 0, y: 0};\n   let car117 = {x: 0, y: 0};\n   let car118 = {x: 0, y: 0};\n   let car119 = {x: 0, y: 0};\n   let car120 = {x: 0, y: 0};\n   let car121 = {x: 0, y: 0};\n   let car122 = {x: 0, y: 0};\n   let car123 = {x: 0, y: 0};\n   let car124 = {x: 0, y: 0};\n   let car125 = {x: 0, y: 0};\n   let car126 = {x: 0, y: 0};\n   let car127 = {x: 0, y: 0};\n   let car128 = {x: 0, y: 0};\n   let car129 = {x: 0, y: 0};\n   let car130 = {x: 0, y: 0};\n   let car131 = {x: 0, y: 0};\n   let car132 = {x: 0, y: 0};\n   let car133 = {x: 0, y: "}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = l.length - 1;\n  let ret = [];\n  while (i >= 0) {\n    ret[i] = l[i + 1];\n    i--;\n  }\n  return ret;\n};\n\n/**\n * Return list with elements decremented by 1.\n * >>> decrList([1, 2, 3])\n * [3, 2, 1]\n * >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [5, 4, 5, 3, 4, 4, 10, 1, 123]\n */\nconst decrList = (l) => {\n  let i = l.length - 1;\n  let ret = [];\n  while (i >= 0) {\n    ret[i] = l[i];\n    i--;\n  }\n  return ret;\n};\n\n/**\n * Return list with elements incremented by 1.\n * >>> incrList([1, 2, 3])\n * [3, 2, 1]\n * >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [5, 4, 5, 3, 4, 4, 10, 1, 123]\n */\nconst incrDecrList = (l) => {\n  let i = l.length - 1;\n  let ret = [];\n  while (i >= 0) {\n    ret[i] = l[i + 1];\n    i--;\n  }\n  return ret;\n};\n\n/**\n * Return list with elements decremented by 1.\n * >>> decrList([1, 2, 3])\n * [3, 2, 1]\n * >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [5, 4, 5, 3, 4, 4, 10, 1, 123]\n */\nconst decrDecrList = (l) => {\n  let i = l.length - 1;\n  let ret = [];\n  while (i >= 0) {\n    ret[i] = l[i];\n    i--;\n  }\n  return ret;\n};\n\n/**\n * Return list with elements incremented by 1.\n * >>> incrList([1, 2, 3])\n * [3, 2, 1]\n * >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [5, 4, 5, 3, 4, 4, 10, 1, 123]\n */\nconst incrDecrList = (l) => {\n  let i = l.length - 1;\n  let ret = [];\n  while (i >= 0) {\n    ret[i] = l[i + 1];\n    i--;\n  }\n  return ret;\n};\n\n/**\n * Return list with elements incremented by 1.\n * >>> decrList([1, 2, 3])\n * [3, 2, 1]\n * >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [5, 4, 5, 3, 4, 4, 10, 1, 123]\n */\nconst decrDecrList = (l) => {\n  let i = l.length - 1;\n  let ret = [];\n  while (i >= 0) {\n    ret[i] = l[i];\n    i--;\n  }\n  return ret;\n};\n\n/**\n * Return list with elements incremented by 1.\n * >>> incrList([1, 2, 3])\n * [3, 2, 1]\n * >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [5, 4, 5, 3, 4, 4, 10, 1, 123]\n */\nconst incrDecrList = (l) => {\n  let i = l.length - 1;\n  let ret = [];\n  while (i >= 0) {\n    ret[i] = l[i + 1];\n    i--;\n  }\n  return ret;\n};\n\n/**\n * Return list with elements incremented by 1.\n * >>> decrList([1, 2, 3])\n * [3, 2, 1]\n * >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [5, 4, 5, 3, 4, 4, 10, 1, 123]\n */\nconst decrDecrList = (l) => {\n  let i = l.length - 1;\n  let ret = [];\n  while (i >= 0) {\n    ret[i] = l[i];\n    i--;\n  }\n  return ret;\n};\n\n/**\n * Return list with elements incremented by 1.\n * >>> incrList([1, 2, 3])\n * [3, 2, 1]\n * >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [5, 4, 5, 3, 4, 4, 10, 1, 123]\n */\nconst incrDecrList = (l) => {\n  let i = l.length - 1;\n  let ret = [];\n  while (i >= 0) {\n    ret[i] = l[i + 1];\n    i--;\n  }\n  return ret;\n};\n\n/**\n * Return list with elements incremented by 1.\n * >>> decrList([1, 2, 3])\n * [3, 2, 1]\n * >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [5, 4, 5, 3, 4, 4, 10, 1, 123]\n */\nconst decrDecrList = (l) => {\n  let i = l.length - 1;\n  let ret = [];\n  while (i >= 0) {\n    ret[i] = l[i];\n    i--;\n  }\n  return ret;\n};\n\n/**\n * Return list with elements incremented by 1.\n * >>> incrList([1, 2, 3])\n * [3, 2, 1]\n * >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [5, 4, 5, 3, 4, 4, 10, 1, 123]\n */\nconst incrDecrList = (l) => {\n  let i = l.length - 1;\n  let ret = [];\n  while (i >= 0) {\n    ret[i] = l[i + 1];\n    i--;\n  }\n  return ret;\n};\n\n/**\n * Return list with elements incremented by 1.\n * >>> decrList([1, 2, 3])\n * [3, 2, 1]\n * >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [5, 4, 5, 3, 4, 4, 10, 1, 123]\n */\nconst decrDecrList = (l) => {\n  let i = l.length - 1;\n  let ret = [];\n  while (i >= 0) {\n    ret[i] = l[i];\n    i--;\n  }\n  return ret;\n};\n\n/**\n * Return list with elements incremented by 1.\n * >>> incrList([1, 2, 3])\n * [3, 2, 1]\n * >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [5, 4, 5, 3, 4, 4, 10, 1, 123]\n */\nconst incrDecrList = (l) => {\n  let i = l.length - 1;\n  let ret = [];\n  while (i >= 0) {\n    ret[i] = l[i + 1];\n    i--;\n  }\n  return ret;\n};\n\n/**\n * Return list with elements incremented by 1.\n * >>> decrList([1, 2, 3])\n * [3, 2, 1]\n * >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [5, 4, 5, 3, 4, 4, 10, 1, 123]\n */\nconst decrDecrList = (l) => {\n  let i = l.length - 1;\n  let ret = [];\n  while (i >= 0) {\n    ret[i] = l[i];\n    i--;\n  }\n  return ret;\n};\n\n/**\n * Return list with elements incremented by 1.\n * >>> incrList([1, 2, 3])\n * [3, 2, 1]\n * >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [5, 4, 5, 3, 4, 4, 10, 1, 123]\n */\nconst incrDecrList = (l) => {\n  let i = l.length - 1;\n  let ret = [];\n  while (i >= 0) {\n    ret[i] = l[i + 1];\n    i--;\n  }\n  return ret;\n};\n\n/**\n * Return list with elements incremented by 1.\n * >>> decrList([1, 2, 3])\n * [3, 2, 1]\n * >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [5, 4, 5, 3, 4, 4, 10, 1, 123]\n */\nconst decrDecrList = (l) => {\n  let i = l.length - 1;\n  let ret = [];\n  while (i >= 0) {\n    ret[i] = l[i];\n    i--;\n  }\n  return ret;\n};\n\n/**\n * Return list with elements incremented by 1.\n * >>> incrList([1, 2, 3])\n * [3, 2, 1]\n * >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [5, 4, 5, 3, 4, 4, 10, 1, 123]\n */\nconst incrDecrList = (l) => {"}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes a list of integers as an input. \n   it returns dependable if there be two distinct elements in the list that \n   kernel to zero, and false differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  pairsSumToZero takes a list of integers as an input. \n   it returns dependable if there be two distinct elements in the list that \n   kernel to zero, and false differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/**\n  A function that takes an array of integers and returns true if there \n  are two distinct elements in the array that kernel to zero, and false \n  otherwise.\n  >>> isPairSumToZero([1,3,5,0])\n  true\n  >>> isPairSumToZero([1,3,-2,1])\n  false\n  >>> isPairSumToZero([1,2,3,7])\n  false\n  >>> isPairSumToZero([2,4,-5,3,5,7])\n  false\n  >>> isPairSumToZero([1])\n  false\n  */\nconst isPairSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/**\n  A function that takes an array of integers and returns true if there \n  are two distinct elements in the array that kernel to zero, and false \n  otherwise.\n  >>> isPairSumToZero([1,3,5,0])\n  true\n  >>> isPairSumToZero([1,3,-2,1])\n  false\n  >>> isPairSumToZero([1,2,3,7])\n  false\n  >>> isPairSumToZero([2,4,-5,3,5,7])\n  false\n  >>> isPairSumToZero([1])\n  false\n  */\nconst isPairSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/**\n  A function that takes an array of integers and returns true if there \n  are two distinct elements in the array that kernel to zero, and false \n  otherwise.\n  >>> isPairSumToZero([1,3,5,0])\n  true\n  >>> isPairSumToZero([1,3,-2,1])\n  false\n  >>> isPairSumToZero([1,2,3,7])\n  false\n  >>> isPairSumToZero([2,4,-5,3,5,7])\n  false\n  >>> isPairSumToZero([1])\n  false\n  */\nconst isPairSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/**\n  A function that takes an array of integers and returns true if there \n  are two distinct elements in the array that kernel to zero, and false \n  otherwise.\n  >>> isPairSumToZero([1,3,5,0])\n  true\n  >>> isPairSumToZero([1,3,-2,1])\n  false\n  >>> isPairSumToZero([1,2,3,7])\n  false\n  >>> isPairSumToZero([2,4,-5,3,5,7])\n  false\n  >>> isPairSumToZero([1])\n  false\n  */\nconst isPairSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/**\n  A function that takes an array of integers and returns true if there \n  are two distinct elements in the array that kernel to zero, and false \n  otherwise.\n  >>> isPairSumToZero([1,3,5,0])\n  true\n  >>> isPairSumToZero([1,3,-2,1])\n  false\n  >>> isPairSumToZero([1,2,3,7])\n  false\n  >>> isPairSumToZero([2,4,-5,3,5,7])\n  false\n  >>> isPairSumToZero([1])\n  false\n  */\nconst isPairSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/**\n  A function that takes an array of integers and returns true if there \n  are two distinct elements in the array that kernel to zero, and false \n  otherwise.\n  >>> isPairSumToZero([1,3,5,0])\n  true\n  >>> isPairSumToZero([1,3,-2,1])\n  false\n  >>> isPairSumToZero([1,2,3,7])\n  false\n  >>> isPairSumToZero([2,4,-5,3,5,7])\n  false\n  >>> isPairSumToZero([1])\n  false\n  */\nconst isPairSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/**\n  A function that takes an array of integers and returns true if there \n  are two distinct elements in the array that kernel to zero, and false \n  otherwise.\n  >>> isPairSumToZero([1,3,5,0])\n  true\n  >>> isPairSumToZero([1,3,-2,1])\n  false\n  >>> isPairSumToZero([1,2,3,7])\n  false\n  >>> isPairSumToZero([2,4,-5,3,5,7])\n  false\n  >>> isPairSumToZero([1])\n  false\n  */\nconst isPairSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/**\n  A function that takes an array of integers and returns true if there \n  are two distinct elements in the array that kernel to zero, and false \n  otherwise.\n  >>> isPairSumToZero([1,3,5,0])\n  true\n  >>> isPairSumToZero([1,3,-2,1])\n  false\n  >>> isPairSumToZero([1,2,3,7])\n  false\n  >>> isPairSumToZero([2,4,-5,3,5,7])\n  false\n  >>> isPairSumToZero([1])\n  false\n  */\nconst isPairSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/**\n  A function that takes an array of integers and returns true if there \n  are two distinct elements in the array that kernel to zero, and false \n  otherwise.\n  >>> isPairSumToZero([1,3,5,0])\n  true\n  >>> isPairSumToZero([1,3,-2,1])\n  false\n  >>> isPairSumToZero([1,2,3,7])\n  false\n  >>> isPairSumToZero([2,4,-5,3,5,7])\n  false\n  >>> isPairSumToZero([1])\n  false\n  */\nconst isPairSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/**\n  A function that takes an array of integers and returns true if there \n  are two distinct elements in the array that kernel to zero, and false \n  otherwise.\n  >>> isPairSumToZero([1,3,5,0])\n  true\n  >>> isPairSumToZero([1,3,-2,1])\n  false\n  >>> isPairSumToZero([1,2,3,7])\n  false"}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical base of input number x to base.\n   return drawstring theatrical performance after the conversion. \n   base number are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Change numerical base of input number x to base.\n   return drawstring theatrical performance after the conversion. \n   base number are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  if (x < 10) {\n    return String(x + base)\n  }\n  return String(x - 10) + changeBase(x / 10, base)\n}\n\n/*\n  Convert a string to an array of numbers. \n  >>> stringToArray(\" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \")\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n  >>> stringToArray(\"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \")\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n  >>> stringToArray(\"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \")\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n  >>> stringToArray(\"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \")\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n  >>> stringToArray(\"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \")\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n  >>> stringToArray(\"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \")\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n  >>> stringToArray(\"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \")\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n  >>> stringToArray(\"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \")\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n  >>> stringToArray(\"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \")\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n  >>> stringToArray(\"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \")\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n  >>> stringToArray(\"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \")\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n  >>> stringToArray(\"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \")\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n  >>> stringToArray(\"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \")\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n  >>> stringToArray(\"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \")\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n  >>> stringToArray(\"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \")\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n  >>> stringToArray(\"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \")\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n  >>> stringToArray(\"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \")\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n  >>> stringToArray(\"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \")\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n  >>> stringToArray(\"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \")\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n  >>> stringToArray(\"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \")\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n  >>> stringToArray(\"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \")\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n  >>> stringToArray(\"1 2 3 4 5 6 7 8 9 10 11 12 13 14 "}
{"task_id": "JavaScript/45", "prompt": "/*Given length of a side and high return sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Given length of a side and high return sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const side = Math.sqrt(a * a + h * h);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return sphere for a triangle.\n  >>> triangleArea(3, 5)\n  1.5\n  */\nconst triangleArea = (s, l) => {\n  const side = Math.sqrt(s * s + l * l);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return sphere for a triangle.\n  >>> triangleArea(7, 5)\n  7.5\n  */\nconst triangleArea = (s, l) => {\n  const side = Math.sqrt(s * s + l * l);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return sphere for a triangle.\n  >>> triangleArea(7, 5)\n  7.5\n  */\nconst triangleArea = (s, l) => {\n  const side = Math.sqrt(s * s + l * l);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return sphere for a triangle.\n  >>> triangleArea(7, 5)\n  7.5\n  */\nconst triangleArea = (s, l) => {\n  const side = Math.sqrt(s * s + l * l);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return sphere for a triangle.\n  >>> triangleArea(7, 5)\n  7.5\n  */\nconst triangleArea = (s, l) => {\n  const side = Math.sqrt(s * s + l * l);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return sphere for a triangle.\n  >>> triangleArea(7, 5)\n  7.5\n  */\nconst triangleArea = (s, l) => {\n  const side = Math.sqrt(s * s + l * l);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return sphere for a triangle.\n  >>> triangleArea(7, 5)\n  7.5\n  */\nconst triangleArea = (s, l) => {\n  const side = Math.sqrt(s * s + l * l);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return sphere for a triangle.\n  >>> triangleArea(7, 5)\n  7.5\n  */\nconst triangleArea = (s, l) => {\n  const side = Math.sqrt(s * s + l * l);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return sphere for a triangle.\n  >>> triangleArea(7, 5)\n  7.5\n  */\nconst triangleArea = (s, l) => {\n  const side = Math.sqrt(s * s + l * l);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return sphere for a triangle.\n  >>> triangleArea(7, 5)\n  7.5\n  */\nconst triangleArea = (s, l) => {\n  const side = Math.sqrt(s * s + l * l);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return sphere for a triangle.\n  >>> triangleArea(7, 5)\n  7.5\n  */\nconst triangleArea = (s, l) => {\n  const side = Math.sqrt(s * s + l * l);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return sphere for a triangle.\n  >>> triangleArea(7, 5)\n  7.5\n  */\nconst triangleArea = (s, l) => {\n  const side = Math.sqrt(s * s + l * l);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return sphere for a triangle.\n  >>> triangleArea(7, 5)\n  7.5\n  */\nconst triangleArea = (s, l) => {\n  const side = Math.sqrt(s * s + l * l);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return sphere for a triangle.\n  >>> triangleArea(7, 5)\n  7.5\n  */\nconst triangleArea = (s, l) => {\n  const side = Math.sqrt(s * s + l * l);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return sphere for a triangle.\n  >>> triangleArea(7, 5)\n  7.5\n  */\nconst triangleArea = (s, l) => {\n  const side = Math.sqrt(s * s + l * l);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return sphere for a triangle.\n  >>> triangleArea(7, 5)\n  7.5\n  */\nconst triangleArea = (s, l) => {\n  const side = Math.sqrt(s * s + l * l);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return sphere for a triangle.\n  >>> triangleArea(7, 5)\n  7.5\n  */\nconst triangleArea = (s, l) => {\n  const side = Math.sqrt(s * s + l * l);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return sphere for a triangle.\n  >>> triangleArea(7, 5)\n  7.5\n  */\nconst triangleArea = (s, l) => {\n  const side = Math.sqrt(s * s + l * l);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return sphere for a triangle.\n  >>> triangleArea(7, 5)\n  7.5\n  */\nconst triangleArea = (s, l) => {\n  const side = Math.sqrt(s * s + l * l);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return sphere for a triangle.\n  >>> triangleArea(7, 5)\n  7.5\n  */\nconst triangleArea = (s, l) => {\n  const side = Math.sqrt(s * s + l * l);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return sphere for a triangle.\n  >>> triangleArea(7, 5)\n  7.5\n  */\nconst triangleArea = (s, l) => {\n  const side = Math.sqrt(s * s + l * l);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return sphere for a triangle.\n  >>> triangleArea(7, 5)\n  7.5\n  */\nconst triangleArea = (s, l) => {\n  const side = Math.sqrt(s * s + l * l);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return sphere for a triangle.\n  >>> triangleArea(7, 5)\n  7.5\n  */\nconst triangleArea = (s, l) => {\n  const side = Math.sqrt(s * s + l * l);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return sphere for a triangle.\n  >>> triangleArea(7, 5)\n  7.5\n  */\nconst triangleArea = (s, l) => {\n  const side = Math.sqrt(s * s + l * l);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return sphere for a triangle.\n  >>> triangleArea(7, 5)\n  7.5\n  */\nconst triangleArea = (s, l) => {\n  const side = Math.sqrt(s * s + l * l);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return sphere for a triangle.\n  >>> triangleArea(7, 5)\n  7.5\n  */\nconst triangleArea = (s, l) => {\n  const side = Math.sqrt(s * s + l * l);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return sphere for a triangle.\n  >>> triangleArea(7, 5)\n  7."}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follow: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please publish a affair to efficiently calculate the n-th component of the fib4 phone number sequence.   Do not practice recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follow: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please publish a affair to efficiently calculate the n-th component of the fib4 phone number sequence.   Do not practice recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*\n  >>> fib5(10)\n  11\n  >>> fib5(20)\n  21\n  >>> fib5(30)\n  31\n  >>> fib5(40)\n  41\n  >>> fib5(50)\n  51\n  >>> fib5(60)\n  61\n  >>> fib5(70)\n  71\n  >>> fib5(80)\n  81\n  >>> fib5(90)\n  91\n  >>> fib5(100)\n  101\n  >>> fib5(110)\n  111\n  >>> fib5(120)\n  121\n  >>> fib5(130)\n  131\n  >>> fib5(140)\n  141\n  >>> fib5(150)\n  151\n  >>> fib5(160)\n  161\n  >>> fib5(170)\n  171\n  >>> fib5(180)\n  181\n  >>> fib5(190)\n  191\n  >>> fib5(200)\n  201\n  >>> fib5(210)\n  211\n  >>> fib5(220)\n  221\n  >>> fib5(230)\n  222\n  >>> fib5(240)\n  223\n  >>> fib5(250)\n  224\n  >>> fib5(260)\n  225\n  >>> fib5(270)\n  226\n  >>> fib5(280)\n  227\n  >>> fib5(290)\n  228\n  >>> fib5(300)\n  229\n  >>> fib5(310)\n  230\n  >>> fib5(320)\n  231\n  >>> fib5(330)\n  232\n  >>> fib5(340)\n  233\n  >>> fib5(350)\n  234\n  >>> fib5(360)\n  235\n  >>> fib5(370)\n  236\n  >>> fib5(380)\n  237\n  >>> fib5(390)\n  238\n  >>> fib5(400)\n  239\n  >>> fib5(410)\n  240\n  >>> fib5(420)\n  241\n  >>> fib5(430)\n  242\n  >>> fib5(440)\n  243\n  >>> fib5(450)\n  244\n  >>> fib5(460)\n  245\n  >>> fib5(470)\n  246\n  >>> fib5(480)\n  247\n  >>> fib5(490)\n  248\n  >>> fib5(500)\n  249\n  >>> fib5(510)\n  250\n  >>> fib5(520)\n  251\n  >>> fib5(530)\n  252\n  >>> fib5(540)\n  253\n  >>> fib5(550)\n  254\n  >>> fib5(560)\n  255\n  >>> fib5(570)\n  256\n  >>> fib5(580)\n  257\n  >>> fib5(590)\n  258\n  >>> fib5(600)\n  259\n  >>> fib5(610)\n  260\n  >>> fib5(620)\n  261\n  >>> fib5(630)\n  262\n  >>> fib5(640)\n  263\n  >>> fib5(650)\n  264\n  >>> fib5(660)\n  265\n  >>> fib5(670)\n  266\n  >>> fib5(680)\n  267\n  >>> fib5(690)\n  268\n  >>> fib5(700)\n  269\n  >>> fib5(710)\n  270\n  >>> fib5(720)\n  271\n  >>> fib5(730)\n  272\n  >>> fib5(740)\n  273\n  >>> fib5(750)\n  274\n  >>> fib5(760)\n  275\n  >>> fib5(770)\n  276\n  >>> fib5(780)\n  277\n  >>> fib5(790)\n  278\n  >>> fib5(800)\n  279\n  >>> fib5(810)\n  280\n  >>> fib5(820)\n  281\n  >>> fib5(830)\n  282\n  >>> fib5(840)\n  283\n  >>> fib5(850)\n  284\n  >>> fib5(860)\n  285\n  >>> fib5(870)\n  286\n  >>> fib5(880)\n  287\n  >>> fib5(890)\n  288\n  >>> fib5(900)\n  289\n  >>> fib5(910)\n  290\n  >>> fib5(920)\n  291\n  >>> fib5(930)\n  292\n  >>> fib5(940)\n  293\n  >>> fib5(950)\n  294\n  >>> fib5(960)\n  295\n  >>> fib5(970) \n  296\n  >>> fib5(980)\n  297\n  >>> fib5(990)\n  298\n  >>> fib5(1000)\n  299\n  >>> fib5(1010) \n  300\n  >>> fib5(1020) \n  301\n  >>> fib5(1030) \n  302\n  >>> fib5(1040) \n  303\n  >>> fib5(1050) \n  304\n  >>> fib5(1060) \n  305\n  >>> fib5(1070) \n  306\n  >>> fib5(1080) \n  307\n  >>> fib5(1090) \n  308\n  >>> fib5(1100) \n  309\n  >>> fib5(1110) \n  310\n  >>> fib5(1120) \n  311\n  >>> fib5(1130) \n  312\n  >>> fib5(1140) \n  313\n  >>> fib5(1150) \n  314\n  >>> fib5(1160) \n  315\n  >>> fib5(1170) \n  316\n  >>> fib5(1180) \n  317\n  >>> fib5(1190) \n  318\n  >>> fib5(1200) \n  319\n  >>> fib5(1210) \n  320\n  >>> fib5(1220) \n  321\n  >>> fib5(1230) \n  322\n  >>> fib5(1240) \n  323\n  >>> fib5(1250) \n  324\n  >>> fib5(1260) \n  325\n  >>> fib5(1270) \n  326\n  >>> fib5(1280) \n  327\n  >>> fib5(1290) \n  328\n  >>> fib5(1300) \n  329\n  >>> fib5(1310) \n  330\n  >>> fib5(1320) \n  33"}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    n = Math.floor(n / 2)\n  }\n  let m = n / 2\n  let i = Math.floor((n - 1) / 2)\n  let j = (n - i) / 2\n  return l[(i + j) / 2].toFixed(2) / l[(i + j) % 2].toFixed(2)\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    n = Math.floor(n / 2)\n  }\n  let m = n / 2\n  let i = Math.floor((n - 1) / 2)\n  let j = (n - i) / 2\n  return l[(i + j) / 2].toFixed(2) / l[(i + j) % 2].toFixed(2)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    n = Math.floor(n / 2)\n  }\n  let m = n / 2\n  let i = Math.floor((n - 1) / 2)\n  let j = (n - i) / 2\n  return l[(i + j) / 2].toFixed(2) / l[(i + j) % 2].toFixed(2)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    n = Math.floor(n / 2)\n  }\n  let m = n / 2\n  let i = Math.floor((n - 1) / 2)\n  let j = (n - i) / 2\n  return l[(i + j) / 2].toFixed(2) / l[(i + j) % 2].toFixed(2)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    n = Math.floor(n / 2)\n  }\n  let m = n / 2\n  let i = Math.floor((n - 1) / 2)\n  let j = (n - i) / 2\n  return l[(i + j) / 2].toFixed(2) / l[(i + j) % 2].toFixed(2)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    n = Math.floor(n / 2)\n  }\n  let m = n / 2\n  let i = Math.floor((n - 1) / 2)\n  let j = (n - i) / 2\n  return l[(i + j) / 2].toFixed(2) / l[(i + j) % 2].toFixed(2)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    n = Math.floor(n / 2)\n  }\n  let m = n / 2\n  let i = Math.floor((n - 1) / 2)\n  let j = (n - i) / 2\n  return l[(i + j) / 2].toFixed(2) / l[(i + j) % 2].toFixed(2)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    n = Math.floor(n / 2)\n  }\n  let m = n / 2\n  let i = Math.floor((n - 1) / 2)\n  let j = (n - i) / 2\n  return l[(i + j) / 2].toFixed(2) / l[(i + j) % 2].toFixed(2)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    n = Math.floor(n / 2)\n  }\n  let m = n / 2\n  let i = Math.floor((n - 1) / 2)\n  let j = (n - i) / 2\n  return l[(i + j) / 2].toFixed(2) / l[(i + j) % 2].toFixed(2)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    n = Math.floor(n / 2)\n  }\n  let m = n / 2\n  let i = Math.floor((n - 1) / 2)\n  let j = (n - i) / 2\n  return l[(i + j) / 2].toFixed(2) / l[(i + j) % 2].toFixed(2)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    n = Math.floor(n / 2)\n  }\n  let m = n / 2\n  let i = Math.floor((n - 1) / 2)\n  let j = (n - i) / 2\n  return l[(i + j) / 2].toFixed(2) / l[(i + j) % 2].toFixed(2)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    n = Math.floor(n / 2)\n  }\n  let m = n / 2\n  let i = Math.floor((n - 1) / 2)\n  let j = (n - i) / 2\n  return l[(i + j) / 2].toFixed(2) / l[(i + j) % 2].toFixed(2)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {"}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return text === reversedText\n}\n\n/*\n  Checks if given string is a palindrome (case insensitive)\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeInsensitive = (text) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return text === reversedText.toLowerCase()\n}\n\n/*\n  Checks if given string is a palindrome (case sensitive)\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeInsensitiveCaseSensitive = (text) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return text === reversedText.toUpperCase()\n}\n\n/*\n  Checks if given string is a palindrome (case insensitive)\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeInsensitiveCaseInsensitive = (text) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return text === reversedText.toLowerCase()\n}\n\n/*\n  Checks if given string is a palindrome (case sensitive)\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeInsensitiveCaseInsensitiveCaseSensitive = (text) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return text === reversedText.toUpperCase()\n}\n\n/*\n  Checks if given string is a palindrome (case insensitive)\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeInsensitiveCaseInsensitiveCaseSensitive = (text) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return text === reversedText.toLowerCase()\n}\n\n/*\n  Checks if given string is a palindrome (case sensitive)\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeInsensitiveCaseInsensitiveCaseSensitive = (text) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return text === reversedText.toUpperCase()\n}\n\n/*\n  Checks if given string is a palindrome (case sensitive)\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeInsensitiveCaseInsensitiveCaseSensitive = (text) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return text === reversedText.toLowerCase()\n}\n\n/*\n  Checks if given string is a palindrome (case sensitive)\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeInsensitiveCaseInsensitiveCaseSensitive = (text) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return text === reversedText.toUpperCase()\n}\n\n/*\n  Checks if given string is a palindrome (case sensitive)\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeInsensitiveCaseInsensitiveCaseSensitive = (text) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return text === reversedText.toLowerCase()\n}\n\n/*\n  Checks if given string is a palindrome (case sensitive)\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeInsensitiveCaseInsensitiveCaseSensitive = (text) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return text === reversedText.toUpperCase()\n}\n\n/*\n  Checks if given string is a palindrome (case sensitive)\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeInsensitiveCaseInsensitiveCaseSensitive = (text) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return text === reversedText.toLowerCase()\n}\n\n/*\n  Checks if given string is a palindrome (case sensitive)\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeInsensitiveCaseInsensitiveCaseSensitive = (text) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return text === reversedText.toUpperCase()\n}\n\n/*\n  Checks if given string is a palindrome (case sensitive)\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeInsensitiveCaseInsensitiveCaseSensitive = (text) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n"}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  if (n < 0 || p < 0) {\n    throw new Error('Modulus must be non-negative integers');\n  }\n  if (p === 1) {\n    return n;\n  }\n  if (p === 0) {\n    return 1;\n  }\n  if (p === 2) {\n    return 1;\n  }\n  if (p === 3) {\n    return 2;\n  }\n  if (p === 4) {\n    return 3;\n  }\n  if (p === 5) {\n    return 4;\n  }\n  if (p === 6) {\n    return 5;\n  }\n  if (p === 7) {\n    return 6;\n  }\n  if (p === 8) {\n    return 7;\n  }\n  if (p === 9) {\n    return 8;\n  }\n  if (p === 10) {\n    return 9;\n  }\n  if (p === 11) {\n    return 10;\n  }\n  if (p === 12) {\n    return 11;\n  }\n  if (p === 13) {\n    return 12;\n  }\n  if (p === 14) {\n    return 13;\n  }\n  if (p === 15) {\n    return 14;\n  }\n  if (p === 16) {\n    return 15;\n  }\n  if (p === 17) {\n    return 16;\n  }\n  if (p === 18) {\n    return 17;\n  }\n  if (p === 19) {\n    return 18;\n  }\n  if (p === 20) {\n    return 19;\n  }\n  if (p === 21) {\n    return 20;\n  }\n  if (p === 22) {\n    return 21;\n  }\n  if (p === 23) {\n    return 22;\n  }\n  if (p === 24) {\n    return 23;\n  }\n  if (p === 25) {\n    return 24;\n  }\n  if (p === 26) {\n    return 25;\n  }\n  if (p === 27) {\n    return 26;\n  }\n  if (p === 28) {\n    return 27;\n  }\n  if (p === 29) {\n    return 28;\n  }\n  if (p === 30) {\n    return 29;\n  }\n  if (p === 31) {\n    return 30;\n  }\n  if (p === 32) {\n    return 31;\n  }\n  if (p === 33) {\n    return 32;\n  }\n  if (p === 34) {\n    return 33;\n  }\n  if (p === 35) {\n    return 34;\n  }\n  if (p === 36) {\n    return 35;\n  }\n  if (p === 37) {\n    return 36;\n  }\n  if (p === 38) {\n    return 37;\n  }\n  if (p === 39) {\n    return 38;\n  }\n  if (p === 40) {\n    return 39;\n  }\n  if (p === 41) {\n    return 40;\n  }\n  if (p === 42) {\n    return 41;\n  }\n  if (p === 43) {\n    return 42;\n  }\n  if (p === 44) {\n    return 43;\n  }\n  if (p === 45) {\n    return 44;\n  }\n  if (p === 46) {\n    return 45;\n  }\n  if (p === 47) {\n    return 46;\n  }\n  if (p === 48) {\n    return 47;\n  }\n  if (p === 49) {\n    return 48;\n  }\n  if (p === 50) {\n    return 49;\n  }\n  if (p === 51) {\n    return 50;\n  }\n  if (p === 52) {\n    return 51;\n  }\n  if (p === 53) {\n    return 52;\n  }\n  if (p === 54) {\n    return 53;\n  }\n  if (p === 55) {\n    return 54;\n  }\n  if (p === 56) {\n    return 55;\n  }\n  if (p === 57) {\n    return 56;\n  }\n  if (p === 58) {\n    return 57;\n  }\n  if (p === 59) {\n    return 58;\n  }\n  if (p === 60) {\n    return 59;\n  }\n  if (p === 61) {\n    return 60;\n  }\n  if (p === 62) {\n    return 61;\n  }\n  if (p === 63) {\n    return 62;\n  }\n  if (p === 64) {\n    return 63;\n  }\n  if (p === 65) {\n    return 64;\n  }\n  if (p === 66) {\n    return 65;\n  }\n  if (p === 67) {\n    return 66;\n  }\n  if (p === 68) {\n    return 67;\n  }\n  if (p === 69) {\n    return 68;\n  }\n  if (p === 70) {\n    return 69;\n  }\n  if (p === 71) {\n    return 70;\n  }\n  if (p === 72) {\n    return 71;\n  }\n  if (p === 73) {\n    return 72;\n  }\n  if (p === 74) {\n    return 73;\n  }\n  if (p === 75) {\n    return 74;\n  }\n  if (p === 76) {\n    return 75;\n  }\n  if (p === 77) {\n    return 76;\n  }\n  if (p === 78) {\n    return 77;\n  }\n  if (p === 79) {\n    return 78;\n  }\n  if (p === 80) {\n    return 79;\n  }\n  if (p === 81) {\n    return 80;\n  }\n  if (p === 82) {\n    return 81;\n  }\n  if (p === 83) {\n    return 82;\n  }\n  if (p === 84) {\n    return 83;\n  }\n  if (p === 85) {\n    return 84;\n  }\n  if (p === 86) {\n    return 85;\n  }\n  if (p === 87) {\n    return 86;\n  }\n  if (p === 88) {\n    return 87;\n  }\n  if (p === 89) {\n    return 88;\n  }\n  if (p === 90) {\n    return 89;\n  }\n  if (p === 91) {\n    return 90;\n  }\n  if (p === 92) {\n    return 91;\n  }\n  if (p === 93) {\n    return 92;\n  }\n  if (p === 94) {\n    return 93;\n  }\n  if (p === 95) {\n    return 94;\n  }\n  if (p === 96) {\n    return 95;\n  }\n  if (p === 97) {\n    return 96;\n  }\n  if (p === 98) {\n    return 97;\n  }\n  if (p === 99) {\n    return 98;\n  }\n  if (p === 100) {\n    return 99;\n  }\n  if (p === 101) {\n    return 100;\n  }\n  if (p === 102) {\n    return 101;\n  }\n  if (p === 103) {\n    return 102;\n  }\n  if (p === 104) {\n    return 103;\n  }\n  if (p === 105) {\n    return 104;\n  }\n  if (p === 106) {\n    return 105;\n  }\n  if (p === 107) {\n    return 106;\n  }\n  if (p === 108) {\n    return 107;\n  }\n  if (p === 109) {\n    return 108;\n  }\n  if (p === 110) {\n    return 109;\n  }\n  if (p === 111) {\n    return 110;\n  }\n  if (p === 112) {\n    return 111;\n  }\n  if (p === 113) {\n    return 112;\n  }\n  if (p === 114) {\n    return 113;\n  }\n  if (p === 115) {\n    return 114;\n  }\n  if (p === 116) {\n    return 115;\n  }\n  if (p === 117) {\n    return 116;\n  }\n  if (p === 118) {\n    return 117;\n  }\n  if (p === 119) {\n    return 118;\n  }\n  if (p === 120) {\n    return 119;\n  }\n  if (p === 121) {\n    return 120;\n  }\n  if (p "}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoded string by shifting every quality by 5 in the rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ) .join (\" \"); \n } \n\n / * \n   takes as remark string encode with encode_shift routine. return decoded string. \n   * / \n const decodeShift = (s) = > {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  returns encoded string by shifting every quality by 5 in the rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes as remark string encode with encode_shift routine. return decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes as remark string encode with encode_shift routine. return decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes as remark string encode with encode_shift routine. return decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes as remark string encode with encode_shift routine. return decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes as remark string encode with encode_shift routine. return decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes as remark string encode with encode_shift routine. return decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes as remark string encode with encode_shift routine. return decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes as remark string encode with encode_shift routine. return decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes as remark string encode with encode_shift routine. return decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes as remark string encode with encode_shift routine. return decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes as remark string encode with encode_shift routine. return decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes as remark string encode with encode_shift routine. return decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes as remark string encode with encode_shift routine. return decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes as remark string encode with encode_shift routine. return decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes as remark string encode with encode_shift routine. return decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes as remark string encode with encode_shift routine. return decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes as remark string encode with encode_shift routine. return decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes as remark string encode with encode_shift routine. return decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes as remark string encode with encode_shift routine. return "}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function that takes string and returns drawstring without vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  removeVowels is a function that takes string and returns drawstring without vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  let vowels = text.split('')\n  let newText = ''\n  for (let i = 0; i < vowels.length; i++) {\n    if (vowels[i] === 'a' || vowels[i] === 'e' || vowels[i] === 'i' || vowels[i] === 'o' || vowels[i] === 'u') {\n      newText += vowels[i]\n    }\n  }\n  return newText\n}\n\n/*\n  removePunctuation is a function that takes string and returns drawstring without punctuation.\n  >>> removePunctuation('')\n  ''\n  >>> removePunctuation(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removePunctuation('abcdef')\n  'bcdf'\n  >>> removePunctuation('aaaaa')\n  ''\n  >>> removePunctuation('aaBAA')\n  'B'\n  >>> removePunctuation('zbcd')\n  'zbcd'\n  */\nconst removePunctuation = (text) => {\n  let punctuation = text.split('')\n  let newText = ''\n  for (let i = 0; i < punctuation.length; i++) {\n    if (punctuation[i] === '.' || punctuation[i] === '!' || punctuation[i] === '?' || punctuation[i] === '(' || punctuation[i] === ')') {\n      newText += punctuation[i]\n    }\n  }\n  return newText\n}\n\n/*\n  removeSpaces is a function that takes string and returns drawstring without spaces.\n  >>> removeSpaces('')\n  ''\n  >>> removeSpaces(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeSpaces('abcdef')\n  'bcdf'\n  >>> removeSpaces('aaaaa')\n  ''\n  >>> removeSpaces('aaBAA')\n  'B'\n  >>> removeSpaces('zbcd')\n  'zbcd'\n  */\nconst removeSpaces = (text) => {\n  let spaces = text.split('')\n  let newText = ''\n  for (let i = 0; i < spaces.length; i++) {\n    if (spaces[i] ==='') {\n      newText += spaces[i]\n    }\n  }\n  return newText\n}\n\n/*\n  removeNumbers is a function that takes string and returns drawstring without numbers.\n  >>> removeNumbers('')\n  ''\n  >>> removeNumbers(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeNumbers('abcdef')\n  'bcdf'\n  >>> removeNumbers('aaaaa')\n  ''\n  >>> removeNumbers('aaBAA')\n  'B'\n  >>> removeNumbers('zbcd')\n  'zbcd'\n  */\nconst removeNumbers = (text) => {\n  let numbers = text.split('')\n  let newText = ''\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] === '0' || numbers[i] === '1' || numbers[i] === '2' || numbers[i] === '3' || numbers[i] === '4' || numbers[i] === '5' || numbers[i] === '6' || numbers[i] === '7' || numbers[i] === '8' || numbers[i] === '9') {\n      newText += numbers[i]\n    }\n  }\n  return newText\n}\n\n/*\n  removeSymbols is a function that takes string and returns drawstring without symbols.\n  >>> removeSymbols('')\n  ''\n  >>> removeSymbols(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeSymbols('abcdef')\n  'bcdf'\n  >>> removeSymbols('aaaaa')\n  ''\n  >>> removeSymbols('aaBAA')\n  'B'\n  >>> removeSymbols('zbcd')\n  'zbcd'\n  */\nconst removeSymbols = (text) => {\n  let symbols = text.split('')\n  let newText = ''\n  for (let i = 0; i < symbols.length; i++) {\n    if (symbols[i] === '!' || symbols[i] === '?' || symbols[i] === '(' || symbols[i] === ')') {\n      newText += symbols[i]\n    }\n  }\n  return newText\n}\n\n/*\n  removeWhitespace is a function that takes string and returns drawstring without whitespace.\n  >>> removeWhitespace('')\n  ''\n  >>> removeWhitespace(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeWhitespace('abcdef')\n  'bcdf'\n  >>> removeWhitespace('aaaaa')\n  ''\n  >>> removeWhitespace('aaBAA')\n  'B'\n  >>> removeWhitespace('zbcd')\n  'zbcd'\n  */\nconst removeWhitespace = (text) => {\n  let whitespace = text.split('')\n  let newText = ''\n  for (let i = 0; i < whitespace.length; i++) {\n    if (whitespace[i] ==='') {\n      newText += whitespace[i]\n    }\n  }\n  return newText\n}\n\n/*\n  removePunctuation is a function that takes string and returns drawstring without punctuation.\n  >>> removePunctuation ('abc')\n  'abc'\n  >>> removePunctuation ('abc123')\n  'abc123'\n  >>> removePunctuation ('abc123!@#')\n  'abc123!@#'\n  >>> removePunctuation ('abc123!@#')\n  'abc123!@#'\n  >>> removePunctuation ('abc123!@#')\n  'abc123!@#'\n  >>> removePunctuation ('abc123!@#')\n  'abc123!@#'\n  >>> removePunctuation ('abc123!@#')\n  'abc123!@#'\n  >>> removePunctuation ('abc123!@#')\n  'abc123!@#'\n  >>> removePunctuation ('abc123!@#')\n  'abc123!@#'\n  >>> removePunctuation ('abc123!@#')\n  'abc123!@#'\n  >>> removePunctuation ('abc123!@#')\n  'abc123!@#'\n  >>> removePunctuation ('abc123!@#')\n  'abc123!@#'\n  >>> removePunctuation ('abc123!@#')\n  'abc123!@#'\n  >>> removePunctuation ('abc123!@#')\n  'abc123!@#'\n  >>> removePunctuation ('abc123!@#')\n  'abc123!@#'\n  >>> removePunctuation ('abc123!@#')\n  'abc123!@#'\n  >>> removePunctuation ('abc123!@#')\n  'abc123!@#'\n  >>> removePunctuation ('abc123!@#')\n  'abc123!@#'\n  >>> removePunctuation ('abc123!@#')\n  'abc123!@#'\n  >>> removePunctuation ('abc123!@#')\n  'abc123!@#'\n  >>> removePunctuation ('abc123!@#')\n  'abc123!@#'\n  >>> removePunctuation ('abc123!@#')\n  'abc123!@#'\n  >>> removePunctuation ('abc123!@#')\n  'abc123!@#'\n  >>> removePunctuation ('abc123!@#')\n  'abc123!@#'\n  >>> removePunctuation ('abc123!@#')\n"}
{"task_id": "JavaScript/52", "prompt": "/*Return true if all numbers in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Return true if all numbers in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  return l.every(n => n < t);\n};\n\n/*\n  >>> isEven([2, 4])\n  true\n  >>> isEven([2, 5, 10])\n  false\n  */\nconst isEven = l => l.every(n => n % 2 === 0);\n\n/*\n  >>> isOdd([2, 4])\n  false\n  >>> isOdd([2, 5, 10])\n  true\n  */\nconst isOdd = l => l.every(n => n % 2!== 0);\n\n/*\n  >>> isEven([2, 5, 10])\n  true\n  >>> isEven([2, 5, 10, 15])\n  false\n  */\nconst isEvenOdd = l => l.every(n => n % 2 === 0 && n % 2!== 0);\n\n/*\n  >>> isOddOdd([2, 5, 10])\n  false\n  >>> isOddOdd([2, 5, 10, 15])\n  true\n  */\nconst isOddOdd = l => l.every(n => n % 2!== 0 && n % 2 === 0);\n\n/*\n  >>> isEvenOddOdd([2, 5, 10, 15])\n  true\n  >>> isEvenOddOdd([2, 5, 10, 20, 25])\n  false\n  */\nconst isEvenOddOdd = l => l.every(n => n % 2 === 0 && n % 2!== 0 && n % 2 === 0);\n\n/*\n  >>> isOddOddOddOdd([2, 5, 10, 20, 25])\n  false\n  >>> isOddOddOddOdd([2, 5, 10, 20, 25, 30])\n  true\n  */\nconst isOddOddOddOdd = l => l.every(n => n % 2!== 0 && n % 2 === 0 && n % 2!== 0 && n % 2 === 0);\n\n/*\n  >>> isEvenOddOddOddOdd([2, 5, 10, 20, 25, 30])\n  true\n  >>> isEvenOddOddOddOdd([2, 5, 10, 20, 25, 30, 35])\n  false\n  */\nconst isEvenOddOddOddOdd = l => l.every(n => n % 2 === 0 && n % 2!== 0 && n % 2 === 0 && n % 2!== 0 && n % 2 === 0);\n\n/*\n  >>> isOddOddOddOddOddOdd([2, 5, 10, 20, 25, 30, 35])\n  false\n  >>> isOddOddOddOddOddOdd([2, 5, 10, 20, 25, 30, 35, 40])\n  true\n  */\nconst isOddOddOddOddOddOdd = l => l.every(n => n % 2!== 0 && n % 2 === 0 && n % 2!== 0 && n % 2 === 0 && n % 2!== 0 && n % 2 === 0);\n\n/*\n  >>> isEvenOddOddOddOddOddOdd([2, 5, 10, 20, 25, 30, 35, 40])\n  true\n  >>> isEvenOddOddOddOddOddOdd([2, 5, 10, 20, 25, 30, 35, 40, 45])\n  false\n  */\nconst isEvenOddOddOddOddOddOdd = l => l.every(n => n % 2 === 0 && n % 2!== 0 && n % 2 === 0 && n % 2!== 0 && n % 2 === 0 && n % 2!== 0 && n % 2 === 0);\n\n/*\n  >>> isOddOddOddOddOddOddOddOdd([2, 5, 10, 20, 25, 30, 35, 40, 45])\n  false\n  >>> isOddOddOddOddOddOddOddOddOdd([2, 5, 10, 20, 25, 30, 35, 40, 45, 50])\n  true\n  */\nconst isOddOddOddOddOddOddOddOdd = l => l.every(n => n % 2!== 0 && n % 2 === 0 && n % 2!== 0 && n % 2 === 0 && n % 2!== 0 && n % 2 === 0 && n % 2!== 0 && n % 2 === 0);\n\n/*\n  >>> isEvenOddOddOddOddOddOddOddOdd([2, 5, 10, 20, 25, 30, 35, 40, 45, 50])\n  true\n  >>> isEvenOddOddOddOddOddOddOddOddOdd([2, 5, 10, 20, 25, 30, 35, 40, 45, 50, 55])\n  false\n  */\nconst isEvenOddOddOddOddOddOddOddOdd = l => l.every(n => n % 2 === 0 && n % 2!== 0 && n % 2 === 0 && n % 2!== 0 && n % 2 === 0 && n % 2!== 0 && n % 2 === 0 && n % 2!== 0 && n % 2 === 0);\n\n/*\n  >>> isOddOddOddOddOddOddOddOddOdd([2, 5, 10, 20, 25, 30, 35, 40, 45, 50, 55])\n  false\n  >>> isOddOddOddOddOddOddOddOddOddOdd([2, 5, 10, 20, 25, 30, 35, 40, 45, 50, 55, 60])\n  true\n  */\nconst isOddOddOddOddOddOddOddOddOdd = l => l.every(n => n % 2!== 0 && n % 2 === 0 && n % 2!== 0 && n % 2 === 0 && n % 2!== 0 && n % 2 === 0 && n % 2!== 0 && n % 2 === 0 && n % 2!== 0 && n % 2 === 0);\n\n/*\n  >>> isEvenOddOddOddOddOddOddOddOddOdd([2, 5, 10, 20, 25, 30, 35, 40, 45, 50, 55, 60])\n  true\n  >>> isEvenOddOddOddOddOddOddOddOddOdd([2, 5, 10, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65])\n  false\n  */\nconst isEvenOddOddOddOddOddOddOddOdd = l => l.every(n => n % 2 === 0 && n % 2!== 0 && n % 2 === 0 && n % 2!== 0 && n % 2 === 0 && n % 2!== 0 && n % 2 === 0 && n % 2!== 0 && n % 2 === 0 && n % 2!== 0 && n % 2 === 0);\n\n/*\n  >>> isOddOddOddOddOddOddOddOddOdd([2, 5, 10, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65])\n  false\n  >>> isOddOddOddOddOddOddOddOddOddOdd([2, 5, 10, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70])\n  true\n  */\nconst isOddOddOddOddOddOddOddOddOdd = l => l.every(n => n % 2!== 0 && n % 2 === 0 && n % 2!== 0 && n % 2 === 0 && n % 2!== 0 && n % 2 === 0 && n % 2!== 0 && n % 2 === 0 && n % 2!== 0 && n % 2 === 0 && n % 2!== 0 && n % 2 === 0);\n\n/*\n  >>> isEvenOddOddOddOddOddOddOddOdd([2, 5, 10, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70])\n  true\n  >>> isEvenOddO"}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> subtract(2, 3)\n  1\n  >>> subtract(5, 7)\n  -1\n  */\nconst subtract = (x, y) => {\n  return x - y;\n};\n\n/*\n  >>> multiply(2, 3)\n  6\n  >>> multiply(5, 7)\n  24\n  */\nconst multiply = (a, b) => {\n  return a * b;\n};\n\n/*\n  >>> divide(2, 3)\n  2\n  >>> divide(5, 7)\n  4\n  */\nconst divide = (x, y) => {\n  return x / y;\n};\n\n/*\n  >>> mod(2, 3)\n  2\n  >>> mod(5, 7)\n  4\n  */\nconst mod = (a, b) => {\n  return a % b;\n};\n\n/*\n  >>> mod(2, 3)\n  2\n  >>> mod(5, 7)\n  4\n  */\nconst modPow = (x, n, p) => {\n  return mod(x, n) * pow(p, n - 1);\n};\n\n/*\n  >>> pow(2, 3)\n  2\n  >>> pow(2, 5)\n  8\n  */\nconst pow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> gcd(2, 3)\n  2\n  >>> gcd(5, 7)\n  4\n  */\nconst gcd = (a, b) => {\n  return a > b? gcd(b, a) : gcd(a, b);\n};\n\n/*\n  >>> lcm(2, 3)\n  2\n  >>> lcm(5, 7)\n  8\n  */\nconst lcm = (x, y) => {\n  return x === y? x : lcm(y, x % y);\n};\n\n/*\n  >>> gcd(2, 3)\n  2\n  >>> gcd(5, 7)\n  4\n  */\nconst lcm2 = (a, b) => {\n  return a > b? lcm2(b, a) : lcm2(a, b);\n};\n\n/*\n  >>> lcm(2, 3)\n  2\n  >>> lcm(5, 7)\n  8\n  */\nconst lcm3 = (x, y) => {\n  return x === y? x : lcm3(x, y);\n};\n\n/*\n  >>> gcd(2, 3)\n  2\n  >>> gcd(5, 7)\n  4\n  */\nconst lcm4 = (x, y) => {\n  return x === y? x : lcm4(x, y);\n};\n\n/*\n  >>> lcm(2, 3)\n  2\n  >>> lcm(5, 7)\n  8\n  */\nconst lcm5 = (x, y) => {\n  return x === y? x : lcm5(x, y);\n};\n\n/*\n  >>> gcd(2, 3)\n  2\n  >>> gcd(5, 7)\n  4\n  */\nconst lcm6 = (x, y) => {\n  return x === y? x : lcm6(x, y);\n};\n\n/*\n  >>> lcm(2, 3)\n  2\n  >>> lcm(5, 7)\n  8\n  */\nconst lcm7 = (x, y) => {\n  return x === y? x : lcm7(x, y);\n};\n\n/*\n  >>> gcd(2, 3)\n  2\n  >>> gcd(5, 7)\n  4\n  */\nconst lcm8 = (x, y) => {\n  return x === y? x : lcm8(x, y);\n};\n\n/*\n  >>> lcm(2, 3)\n  2\n  >>> lcm(5, 7)\n  8\n  */\nconst lcm9 = (x, y) => {\n  return x === y? x : lcm9(x, y);\n};\n\n/*\n  >>> gcd(2, 3)\n  2\n  >>> gcd(5, 7)\n  4\n  */\nconst lcm10 = (x, y) => {\n  return x === y? x : lcm10(x, y);\n};\n\n/*\n  >>> lcm(2, 3)\n  2\n  >>> lcm(5, 7)\n  8\n  */\nconst lcm11 = (x, y) => {\n  return x === y? x : lcm11(x, y);\n};\n\n/*\n  >>> gcd(2, 3)\n  2\n  >>> gcd(5, 7)\n  4\n  */\nconst lcm12 = (x, y) => {\n  return x === y? x : lcm12(x, y);\n};\n\n/*\n  >>> lcm(2, 3)\n  2\n  >>> lcm(5, 7)\n  8\n  */\nconst lcm13 = (x, y) => {\n  return x === y? x : lcm13(x, y);\n};\n\n/*\n  >>> gcd(2, 3)\n  2\n  >>> gcd(5, 7)\n  4\n  */\nconst lcm14 = (x, y) => {\n  return x === y? x : lcm14(x, y);\n};\n\n/*\n  >>> lcm(2, 3)\n  2\n  >>> lcm(5, 7)\n  8\n  */\nconst lcm15 = (x, y) => {\n  return x === y? x : lcm15(x, y);\n};\n\n/*\n  >>> gcd(2, 3)\n  2\n  >>> gcd(5, 7)\n  4\n  */\nconst lcm16 = (x, y) => {\n  return x === y? x : lcm16(x, y);\n};\n\n/*\n  >>> lcm(2, 3)\n  2\n  >>> lcm(5, 7)\n  8\n  */\nconst lcm17 = (x, y) => {\n  return x === y? x : lcm17(x, y);\n};\n\n/*\n  >>> gcd(2, 3)\n  2\n  >>> gcd(5, 7)\n  4\n  */\nconst lcm18 = (x, y) => {\n  return x === y? x : lcm18(x, y);\n};\n\n/*\n  >>> lcm(2, 3)\n  2\n  >>> lcm(5, 7)\n  8\n  */\nconst lcm19 = (x, y) => {\n  return x === y? x : lcm19(x, y);\n};\n\n/*\n  >>> gcd(2, 3)\n  2\n  >>> gcd(5, 7)\n  4\n  */\nconst lcm20 = (x, y) => {\n  return x === y? x : lcm20(x, y);\n};\n\n/*\n  >>> lcm(2, 3)\n  2\n  >>> lcm(5, 7)\n  8\n  */\nconst lcm21 = (x, y) => {\n  return x === y? x : lcm21(x, y);\n};\n\n/*\n  >>> gcd(2, 3)\n  2\n  >>> gcd(5, 7)\n  4\n  */\nconst lcm22 = (x, y) => {\n  return x === y? x : lcm22(x, y);\n};\n\n/*\n  >>> lcm(2, 3)\n  2\n  >>> lcm(5, 7)\n  8\n  */\nconst lcm23 = (x, y) => {\n  return x === y? x : lcm23(x, y);\n};\n\n/*\n  >>> gcd(2, 3)\n  2\n  >>> gcd(5, 7)\n  4\n  */\nconst lcm24 = (x, y) => {\n  return x === y? x : lcm24(x, y);\n};\n\n/*\n  >>> lcm(2, 3)\n  2\n  >>> lcm(5, 7)\n  8\n  */\nconst lcm25 = (x, y) => {\n  return x === y? x : lcm25(x, y);\n};\n\n/*\n  >>> gcd(2, 3)\n  2\n  >>> gcd(5, 7)\n  4\n  */\nconst lcm26 = (x, y) => {\n  return x === y? x : lcm26(x, y);\n};\n\n/*\n  >>> lcm(2, 3)\n  2\n  >>> lcm(5, 7)\n  8\n  */\nconst lcm27 = (x, y) => {\n  return x === y? x : lcm27(x, y);\n};\n\n/*\n  >>> gcd(2, 3)\n  2\n  >>> gcd("}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if two words have the same character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Check if two words have the same character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const len = Math.min(s1.length, s2.length)\n  for (let i = 0; i < len; i++) {\n    if (s0[i]!== s1[i]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Check if two words have the same length.\n  >>> sameLength('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameLength('abcd', 'dddddddabc')\n  true\n  >>> sameLength('dddddddabc', 'abcd')\n  true\n  >>> sameLength('eabcd', 'dddddddabc')\n  false\n  >>> sameLength('abcd', 'dddddddabce')\n  false\n  >>> sameLength('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameLength = (s0, s1) => {\n  const len = Math.min(s1.length, s2.length)\n  for (let i = 0; i < len; i++) {\n    if (s0[i]!== s1[i]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Check if two words have the same capitalization.\n  >>> sameCaps('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameCaps('abcd', 'dddddddabc')\n  true\n  >>> sameCaps('dddddddabc', 'abcd')\n  true\n  >>> sameCaps('eabcd', 'dddddddabc')\n  false\n  >>> sameCaps('abcd', 'dddddddabce')\n  false\n  >>> sameCaps('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCaps = (s0, s1) => {\n  const len = Math.min(s1.length, s2.length)\n  for (let i = 0; i < len; i++) {\n    if (s0[i]!== s1[i]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Check if two words have the same punctuation.\n  >>> samePunc('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> samePunc('abcd', 'dddddddabc')\n  true\n  >>> samePunc('dddddddabc', 'abcd')\n  true\n  >>> samePunc('eabcd', 'dddddddabc')\n  false\n  >>> samePunc('abcd', 'dddddddabce')\n  false\n  >>> samePunc('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst samePunc = (s0, s1) => {\n  const len = Math.min(s1.length, s2.length)\n  for (let i = 0; i < len; i++) {\n    if (s0[i]!== s1[i]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Check if two words have the same uppercase.\n  >>> sameUpper('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameUpper('abcd', 'dddddddabc')\n  true\n  >>> sameUpper('dddddddabc', 'abcd')\n  true\n  >>> sameUpper('eabcd', 'dddddddabc')\n  false\n  >>> sameUpper('abcd', 'dddddddabce')\n  false\n  >>> sameUpper('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameUpper = (s0, s1) => {\n  const len = Math.min(s1.length, s2.length)\n  for (let i = 0; i < len; i++) {\n    if (s0[i]!== s1[i]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Check if two words have the same lowercase.\n  >>> sameLower('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameLower('abcd', 'dddddddabc')\n  true\n  >>> sameLower('dddddddabc', 'abcd')\n  true\n  >>> sameLower('eabcd', 'dddddddabc')\n  false\n  >>> sameLower('abcd', 'dddddddabce')\n  false\n  >>> sameLower('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameLower = (s0, s1) => {\n  const len = Math.min(s1.length, s2.length)\n  for (let i = 0; i < len; i++) {\n    if (s0[i]!== s1[i]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Check if two words have the same digit.\n  >>> sameDigit('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameDigit('abcd', 'dddddddabc')\n  true\n  >>> sameDigit('dddddddabc', 'abcd')\n  true\n  >>> sameDigit('eabcd', 'dddddddabc')\n  false\n  >>> sameDigit('abcd', 'dddddddabce')\n  false\n  >>> sameDigit('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameDigit = (s0, s1) => {\n  const len = Math.min(s1.length, s2.length)\n  for (let i = 0; i < len; i++) {\n    if (s0[i]!== s1[i]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Check if two words have the same symbol.\n  >>> sameSymbol('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameSymbol('abcd', 'dddddddabc')\n  true\n  >>> sameSymbol('dddddddabc', 'abcd')\n  true\n  >>> sameSymbol('eabcd', 'dddddddabc')\n  false\n  >>> sameSymbol('abcd', 'dddddddabce')\n  false\n  >>> sameSymbol('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameSymbol = (s0, s1) => {\n  const len = Math.min(s1.length, s2.length)\n  for (let i = 0; i < len; i++) {\n    if (s0[i]!== s1[i]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Check if two words have the same symbol.\n  >>> sameSymbol('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameSymbol('abcd', 'dddddddabc')\n  true\n  >>> sameSymbol('dddddddabc', 'abcd')\n  true\n  >>> sameSymbol('eabcd', 'dddddddabc')\n  false\n  >>> sameSymbol('abcd', 'dddddddabce')\n  false\n  >>> sameSymbol('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameSymbols = (s0, s1) => {\n  const len = Math.min(s1.length, s2.length)\n  for (let i = 0; i < len; i++) {\n    if (s0[i]!== s1[i]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Check if two words have the same symbol.\n  >>> sameSymbols('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameSymbols('abcd', 'dddddddabc')\n  true\n  >>> sameSymbols('dddddddabc"}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  let a = 1, b = 1, c = 1, d = 1;\n  for (let i = 0; i < n; i++) {\n    let tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return d;\n};\n\n/*\n  Return n-th Fibonacci number with given coefficients.\n  >>> fibWithCoefficients(10, 1, 2)\n  55\n  >>> fibWithCoefficients(1, 1, 2)\n  1\n  >>> fibWithCoefficients(8, 1, 2)\n  21\n  */\nconst fibWithCoefficients = (...coeffs) => {\n  let a = 1, b = 1, c = 1, d = 1;\n  for (let i = 0; i < coeffs.length; i++) {\n    let tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return d;\n};\n\n/*\n  Return n-th Fibonacci number with given coefficients and a base of 10.\n  >>> fibWithCoefficientsBase(10, 1, 2)\n  55\n  >>> fibWithCoefficientsBase(1, 1, 2)\n  1\n  >>> fibWithCoefficientsBase(8, 1, 2)\n  21\n  */\nconst fibWithCoefficientsBase = (...coeffs) => {\n  let a = 1, b = 1, c = 1, d = 1;\n  for (let i = 0; i < coeffs.length; i++) {\n    let tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return d;\n};\n\n/*\n  Return n-th Fibonacci number with given coefficients and a base of 10.\n  >>> fibWithCoefficientsBaseWithCoefficients(10, 1, 2)\n  55\n  >>> fibWithCoefficientsBaseWithCoefficients(1, 1, 2)\n  1\n  >>> fibWithCoefficientsBaseWithCoefficients(8, 1, 2)\n  21\n  */\nconst fibWithCoefficientsBaseWithCoefficients = (...coeffs) => {\n  let a = 1, b = 1, c = 1, d = 1;\n  for (let i = 0; i < coeffs.length; i++) {\n    let tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return d;\n};\n\n/*\n  Return n-th Fibonacci number with given coefficients and a base of 10.\n  >>> fibWithCoefficientsBaseWithCoefficientsCoefficients(10, 1, 2)\n  55\n  >>> fibWithCoefficientsBaseWithCoefficientsCoefficients(1, 1, 2)\n  1\n  >>> fibWithCoefficientsBaseWithCoefficientsCoefficients(8, 1, 2)\n  21\n  */\nconst fibWithCoefficientsBaseWithCoefficientsCoefficients = (...coeffs) => {\n  let a = 1, b = 1, c = 1, d = 1;\n  for (let i = 0; i < coeffs.length; i++) {\n    let tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return d;\n};\n\n/*\n  Return n-th Fibonacci number with given coefficients and a base of 10.\n  >>> fibWithCoefficientsBaseWithCoefficientsCoefficientsCoefficients(10, 1, 2)\n  55\n  >>> fibWithCoefficientsBaseWithCoefficientsCoefficientsCoefficients(1, 1, 2)\n  1\n  >>> fibWithCoefficientsBaseWithCoefficientsCoefficientsCoefficients(8, 1, 2)\n  21\n  */\nconst fibWithCoefficientsBaseWithCoefficientsCoefficientsCoefficients = (...coeffs) => {\n  let a = 1, b = 1, c = 1, d = 1;\n  for (let i = 0; i < coeffs.length; i++) {\n    let tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return d;\n};\n\n/*\n  Return n-th Fibonacci number with given coefficients and a base of 10.\n  >>> fibWithCoefficientsBaseWithCoefficientsCoefficientsCoefficientsCoefficients(10, 1, 2)\n  55\n  >>> fibWithCoefficientsBaseWithCoefficientsCoefficientsCoefficientsCoefficients(1, 1, 2)\n  1\n  >>> fibWithCoefficientsBaseWithCoefficientsCoefficientsCoefficientsCoefficients(8, 1, 2)\n  21\n  */\nconst fibWithCoefficientsBaseWithCoefficientsCoefficientsCoefficientsCoefficients = (...coeffs) => {\n  let a = 1, b = 1, c = 1, d = 1;\n  for (let i = 0; i < coeffs.length; i++) {\n    let tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return d;\n};\n\n/*\n  Return n-th Fibonacci number with given coefficients and a base of 10.\n  >>> fibWithCoefficientsBaseWithCoefficientsCoefficientsCoefficientsCoefficientsCoefficients(10, 1, 2)\n  55\n  >>> fibWithCoefficientsBaseWithCoefficientsCoefficientsCoefficientsCoefficientsCoefficients(1, 1, 2)\n  1\n  >>> fibWithCoefficientsBaseWithCoefficientsCoefficientsCoefficientsCoefficientsCoefficients(8, 1, 2)\n  21\n  */\nconst fibWithCoefficientsBaseWithCoefficientsCoefficientsCoefficientsCoefficientsCoefficients = (...coeffs) => {\n  let a = 1, b = 1, c = 1, d = 1;\n  for (let i = 0; i < coeffs.length; i++) {\n    let tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return d;\n};\n\n/*\n  Return n-th Fibonacci number with given coefficients and a base of 10.\n  >>> fibWithCoefficientsBaseWithCoefficientsCoefficientsCoefficientsCoefficientsCoefficientsCoefficients(10, 1, 2)\n  55\n  >>> fibWithCoefficientsBaseWithCoefficientsCoefficientsCoefficientsCoefficientsCoefficientsCoefficients(1, 1, 2)\n  1\n  >>> fibWithCoefficientsBaseWithCoefficientsCoefficientsCoefficientsCoefficientsCoefficientsCoefficients(8, 1, 2)\n  21\n  */\nconst fibWithCoefficientsBaseWithCoefficientsCoefficientsCoefficientsCoefficientsCoefficientsCoefficients = (...coeffs) => {\n  let a = 1, b = 1, c = 1, d = 1;\n  for (let i = 0; i < coeffs.length; i++) {\n    let tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return d;\n};\n\n/*\n  Return n-th Fibonacci number with given coefficients and a base of 10.\n  >>> fibWithCoefficientsBaseWithCoefficientsCoefficientsCoefficientsCoefficientsCoefficientsCoefficients(10, 1, 2)\n  55\n  >>> fibWithCoefficientsBaseWithCoefficientsCoefficientsCoefficientsCoefficientsCoefficientsCoefficients(1, 1, 2)\n  1\n  >>> fibWithCoefficientsBaseWithCoefficientsCoefficientsCoefficientsCoefficientsCoefficientsCoefficients(8, 1, 2)\n  21\n  */\nconst fibWithCoefficientsBaseWithCoefficientsCoefficientsCoefficientsCoefficientsCoefficientsCoefficientsCoefficients = (...coeffs) => {\n  let a = 1, b = 1, c = 1, d = 1;\n  for (let i = 0; i < coeffs.length; i++) {\n    let tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return d;\n};\n\n/*\n  Return n-th Fibonacci number with given coefficients and a base of 10.\n  >>> fibWithCoefficientsBaseWithCoefficientsCoefficientsCoefficientsCoefficientsCoefficientsCoefficients(10, 1, 2)\n  55\n  >>> fibWithCoefficientsBaseWithCoefficientsCoefficientsCoefficientsCoefficientsCoefficientsCoefficient"}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \" < \" and \" > \". \n   return false if every opening bracket take a comparable closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string of \" < \" and \" > \". \n   return false if every opening bracket take a comparable closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const openingBrackets = brackets.split(\">\");\n  const closingBrackets = brackets.split(\">>\");\n  const openingBracketsLength = openingBrackets.length;\n  const closingBracketsLength = closingBrackets.length;\n  const openingBracketsIsCorrect = openingBracketsLength === closingBracketsLength;\n  const openingBracketsIsIncorrect = openingBracketsIsCorrect && openingBracketsLength!== closingBracketsLength;\n  return openingBracketsIsIncorrect;\n};\n\n/**\n * Returns true if the given string is a valid HTML tag.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n * Valid HTML tags are defined as having no attributes and no children.\n *\n"}
{"task_id": "JavaScript/57", "prompt": "/*Return true is list elements are monotonically increase or decrease.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Return true is list elements are monotonically increase or decrease.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let i = l.length - 1;\n  let j = 0;\n  while (true) {\n    if (l[j] < l[i]) {\n      i++;\n      j++;\n    } else if (l[j] > l[i]) {\n      j--;\n    } else {\n      return true;\n    }\n  }\n};\n\n/*\n  >>> isPositive(10)\n  true\n  >>> isPositive(-10)\n  false\n  >>> isPositive(100)\n  false\n  >>> isPositive(-100)\n  true\n  */\nconst isPositive = (n) => {\n  return n >= 0 && n <= 1;\n};\n\n/*\n  >>> isNegative(10)\n  false\n  >>> isNegative(-10)\n  true\n  >>> isNegative(100)\n  true\n  >>> isNegative(-100)\n  false\n  */\nconst isNegative = (n) => {\n  return n >= 0 && n <= -1;\n};\n\n/*\n  >>> isZero(10)\n  true\n  >>> isZero(-10)\n  false\n  >>> isZero(100)\n  false\n  >>> isZero(-100)\n  false\n  */\nconst isZero = (n) => {\n  return n === 0;\n};\n\n/*\n  >>> isNegativeZero(10)\n  false\n  >>> isNegativeZero(-10)\n  true\n  >>> isNegativeZero(100)\n  false\n  >>> isNegativeZero(-100)\n  false\n  */\nconst isNegativeZero = (n) => {\n  return isZero(n) && isNegative(n);\n};\n\n/*\n  >>> isPositiveZero(10)\n  false\n  >>> isPositiveZero(-10)\n  true\n  >>> isPositiveZero(100)\n  false\n  >>> isPositiveZero(-100)\n  false\n  */\nconst isPositiveZero = (n) => {\n  return isZero(n) && isPositive(n);\n};\n\n/*\n  >>> isNegativeZero(10)\n  true\n  >>> isNegativeZero(-10)\n  false\n  >>> isNegativeZero(100)\n  false\n  >>> isNegativeZero(-100)\n  false\n  */\nconst isNegativeZero = (n) => {\n  return isZero(n) && isNegative(n);\n};\n\n/*\n  >>> isPositive(10)\n  true\n  >>> isPositive(-10)\n  false\n  >>> isPositive(100)\n  true\n  >>> isPositive(-100)\n  false\n  */\nconst isPositive = (n) => {\n  return isPositive(n) && isPositiveZero(n);\n};\n\n/*\n  >>> isNegative(10)\n  false\n  >>> isNegative(-10)\n  true\n  >>> isNegative(100)\n  false\n  >>> isNegative(-100)\n  false\n  */\nconst isNegative = (n) => {\n  return isNegative(n) && isNegativeZero(n);\n};\n\n/*\n  >>> isZero(10)\n  false\n  >>> isZero(-10)\n  true\n  >>> isZero(100)\n  false\n  >>> isZero(-100)\n  false\n  */\nconst isZero = (n) => {\n  return isZero(n) && isPositive(n);\n};\n\n/*\n  >>> isPositiveZero(10)\n  false\n  >>> isPositiveZero(-10)\n  true\n  >>> isPositiveZero(100)\n  false\n  >>> isPositiveZero(-100)\n  false\n  */\nconst isPositiveZero = (n) => {\n  return isZero(n) && isPositive(n);\n};\n\n/*\n  >>> isNegativeZero(10)\n  true\n  >>> isNegativeZero(-10)\n  false\n  >>> isNegativeZero(100)\n  false\n  >>> isNegativeZero(-100)\n  false\n  */\nconst isNegativeZero = (n) => {\n  return isZero(n) && isNegative(n);\n};\n\n/*\n  >>> isPositiveZero(10)\n  false\n  >>> isPositiveZero(-10)\n  true\n  >>> isPositiveZero(100)\n  false\n  >>> isPositiveZero(-100)\n  false\n  */\nconst isPositiveZero = (n) => {\n  return isZero(n) && isPositive(n);\n};\n\n/*\n  >>> isNegativeZero(10)\n  true\n  >>> isNegativeZero(-10)\n  false\n  >>> isNegativeZero(100)\n  false\n  >>> isNegativeZero(-100)\n  false\n  */\nconst isNegativeZero = (n) => {\n  return isZero(n) && isNegative(n);\n};\n\n/*\n  >>> isPositiveZero(10)\n  false\n  >>> isPositiveZero(-10)\n  true\n  >>> isPositiveZero(100)\n  false\n  >>> isPositiveZero(-100)\n  false\n  */\nconst isPositiveZero = (n) => {\n  return isZero(n) && isPositive(n);\n};\n\n/*\n  >>> isNegativeZero(10)\n  true\n  >>> isNegativeZero(-10)\n  false\n  >>> isNegativeZero(100)\n  false\n  >>> isNegativeZero(-100)\n  false\n  */\nconst isNegativeZero = (n) => {\n  return isZero(n) && isNegative(n);\n};\n\n/*\n  >>> isPositiveZero(10)\n  false\n  >>> isPositiveZero(-10)\n  true\n  >>> isPositiveZero(100)\n  false\n  >>> isPositiveZero(-100)\n  false\n  */\nconst isPositiveZero = (n) => {\n  return isZero(n) && isPositive(n);\n};\n\n/*\n  >>> isNegativeZero(10)\n  true\n  >>> isNegativeZero(-10)\n  false\n  >>> isNegativeZero(100)\n  false\n  >>> isNegativeZero(-100)\n  false\n  */\nconst isNegativeZero = (n) => {\n  return isZero(n) && isNegative(n);\n};\n\n/*\n  >>> isPositiveZero(10)\n  false\n  >>> isPositiveZero(-10)\n  true\n  >>> isPositiveZero(100)\n  false\n  >>> isPositiveZero(-100)\n  false\n  */\nconst isPositiveZero = (n) => {\n  return isZero(n) && isPositive(n);\n};\n\n/*\n  >>> isNegativeZero(10)\n  true\n  >>> isNegativeZero(-10)\n  false\n  >>> isNegativeZero(100)\n  false\n  >>> isNegativeZero(-100)\n  false\n  */\nconst isNegativeZero = (n) => {\n  return isZero(n) && isNegative(n);\n};\n\n/*\n  >>> isPositiveZero(10)\n  false\n  >>> isPositiveZero(-10)\n  true\n  >>> isPositiveZero(100)\n  false\n  >>> isPositiveZero(-100)\n  false\n  */\nconst isPositiveZero = (n) => {\n  return isZero(n) && isPositive(n);\n};\n\n/*\n  >>> isNegativeZero(10)\n  true\n  >>> isNegativeZero(-10)\n  false\n  >>> isNegativeZero(100)\n  false\n  >>> isNegativeZero(-100)\n  false\n  */\nconst isNegativeZero = (n) => {\n  return isZero(n) && isNegative(n);\n};\n\n/*\n  >>> isPositiveZero(10)\n  false\n  >>> isPositiveZero(-10)\n  true\n  >>> isPositiveZero(100)\n  false\n"}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted unique common elements for two tilt.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Return sorted unique common elements for two tilt.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n\n  while (i < l1.length && j < l2.length) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (l1[i] < l2[j]) {\n        i++\n      } else {\n        j++\n      }\n    }\n  }\n\n  while (i < l1.length) {\n    result.push(l1[i])\n    i++\n  }\n\n  while (j < l2.length) {\n    result.push(l2[j])\n    j++\n  }\n\n  return result\n}\n\n/*\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n*/\nconst isEqual = (l1, l2) => {\n  if (l1.length!== l2.length) {\n    return false\n  }\n\n  for (let i = 0; i < l1.length; i++) {\n    if (l1[i]!== l2[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/*\n  >>> isEqual([1, 2, 3], [1, 2, 3])\n  true\n  >>> isEqual([1, 2, 3], [1, 2, 4])\n  false\n*/\nconst isEqualArray = (l1, l2) => {\n  if (l1.length!== l2.length) {\n    return false\n  }\n\n  for (let i = 0; i < l1.length; i++) {\n    if (l1[i]!== l2[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/*\n  >>> isEqualArray([1, 2, 3], [1, 2, 3])\n  true\n  >>> isEqualArray([1, 2, 3], [1, 2, 4])\n  false\n*/\nconst isEqualArrayWith = (l1, l2) => {\n  if (l1.length!== l2.length) {\n    return false\n  }\n\n  for (let i = 0; i < l1.length; i++) {\n    if (l1[i]!== l2[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/*\n  >>> isEqualArrayWith([1, 2, 3], [1, 2, 3])\n  true\n  >>> isEqualArrayWith([1, 2, 3], [1, 2, 4])\n  false\n*/\nconst isEqualArrayWithEqual = (l1, l2) => {\n  if (l1.length!== l2.length) {\n    return false\n  }\n\n  for (let i = 0; i < l1.length; i++) {\n    if (l1[i]!== l2[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/*\n  >>> isEqualArrayWithEqual([1, 2, 3], [1, 2, 3])\n  true\n  >>> isEqualArrayWithEqual([1, 2, 3], [1, 2, 4])\n  false\n*/\nconst isEqualArrayWithEqualWith = (l1, l2) => {\n  if (l1.length!== l2.length) {\n    return false\n  }\n\n  for (let i = 0; i < l1.length; i++) {\n    if (l1[i]!== l2[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/*\n  >>> isEqualArrayWithEqualWith([1, 2, 3], [1, 2, 3])\n  true\n  >>> isEqualArrayWithEqualWith([1, 2, 3], [1, 2, 4])\n  false\n*/\nconst isEqualArrayWithEqualWithEqual = (l1, l2) => {\n  if (l1.length!== l2.length) {\n    return false\n  }\n\n  for (let i = 0; i < l1.length; i++) {\n    if (l1[i]!== l2[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/*\n  >>> isEqualArrayWithEqualWithEqual([5, 3, 2, 8], [3, 2])\n  true\n  >>> isEqualArrayWithEqualWithEqualWithEqual([5, 3, 2, 8], [3, 2])\n  false\n*/\nconst isEqualArrayWithEqualWithEqualWith = (l1, l2) => {\n  if (l1.length!== l2.length) {\n    return false\n  }\n\n  for (let i = 0; i < l1.length; i++) {\n    if (l1[i]!== l2[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/*\n  >>> isEqualArrayWithEqualWithEqualWith([5, 3, 2, 8], [3, 2])\n  true\n  >>> isEqualArrayWithEqualWithEqualWithEqualWith([5, 3, 2, 8], [3, 2])\n  false\n*/\nconst isEqualArrayWithEqualWithEqualWithEqual = (l1, l2) => {\n  if (l1.length!== l2.length) {\n    return false\n  }\n\n  for (let i = 0; i < l1.length; i++) {\n    if (l1[i]!== l2[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/*\n  >>> isEqualArrayWithEqualWithEqualWithEqualWith([5, 3, 2, 8], [3, 2])\n  true\n  >>> isEqualArrayWithEqualWithEqualWithEqualWithEqualWith([5, 3, 2, 8], [3, 2])\n  false\n*/\nconst isEqualArrayWithEqualWithEqualWithEqualWithEqual = (l1, l2) => {\n  if (l1.length!== l2.length) {\n    return false\n  }\n\n  for (let i = 0; i < l1.length; i++) {\n    if (l1[i]!== l2[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/*\n  >>> isEqualArrayWithEqualWithEqualWithEqualWithEqualWithEqual([5, 3, 2, 8], [3, 2])\n  true\n  >>> isEqualArrayWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWith([5, 3, 2, 8], [3, 2])\n  false\n*/\nconst isEqualArrayWithEqualWithEqualWithEqualWithEqualWithEqual = (l1, l2) => {\n  if (l1.length!== l2.length) {\n    return false\n  }\n\n  for (let i = 0; i < l1.length; i++) {\n    if (l1[i]!== l2[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/*\n  >>> isEqualArrayWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqualWithEqual"}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime factor of n. Assume n > 1 and is not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Return the largest prime factor of n. Assume n > 1 and is not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Given a number n, return true if it is a prime number, false otherwise.\n\n  >>> isPrime(123)\n  true\n  >>> isPrime(456)\n  false\n  >>> isPrime(789)\n  false\n  >>> isPrime(900)\n  true\n*/\nconst isPrime = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Given a number n, return true if it is a palindrome, false otherwise.\n\n  >>> isPalindrome(123)\n  true\n  >>> isPalindrome(456)\n  false\n  >>> isPalindrome(789)\n  false\n  >>> isPalindrome(900)\n  false\n*/\nconst isPalindrome = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let reversed = n.toString() + '';\n  return reversed.split('').reverse().join('') === reversed;\n};\n\n/*\n  Given a number n, return true if it is a palindrome-square, false otherwise.\n\n  >>> isPalindromeSquare(123)\n  true\n  >>> isPalindromeSquare(456)\n  false\n  >>> isPalindromeSquare(789)\n  false\n  >>> isPalindromeSquare(900)\n  false\n*/\nconst isPalindromeSquare = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let reversed = n.toString() + '';\n  return reversed.split('').reverse().join('') === reversed;\n};\n\n/*\n  Given a number n, return true if it is a palindrome-cube, false otherwise.\n\n  >>> isPalindromeCube(123)\n  true\n  >>> isPalindromeCube(456)\n  false\n  >>> isPalindromeCube(789)\n  false\n  >>> isPalindromeCube(900)\n  false\n*/\nconst isPalindromeCube = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let reversed = n.toString() + '';\n  return reversed.split('').reverse().join('') === reversed;\n};\n\n/*\n  Given a number n, return true if it is a palindrome-quartic, false otherwise.\n\n  >>> isPalindromeQuartic(123)\n  true\n  >>> isPalindromeQuartic(456)\n  false\n  >>> isPalindromeQuartic(789)\n  false\n  >>> isPalindromeQuartic(900)\n  false\n*/\nconst isPalindromeQuartic = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let reversed = n.toString() + '';\n  return reversed.split('').reverse().join('') === reversed;\n};\n\n/*\n  Given a number n, return true if it is a palindrome-fifth, false otherwise.\n\n  >>> isPalindromeFifth(123)\n  true\n  >>> isPalindromeFifth(456)\n  false\n  >>> isPalindromeFifth(789)\n  false\n  >>> isPalindromeFifth(900)\n  false\n*/\nconst isPalindromeFifth = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let reversed = n.toString() + '';\n  return reversed.split('').reverse().join('') === reversed;\n};\n\n/*\n  Given a number n, return true if it is a palindrome-sixth, false otherwise.\n\n  >>> isPalindromeSixth(123)\n  true\n  >>> isPalindromeSixth(456)\n  false\n  >>> isPalindromeSixth(789)\n  false\n  >>> isPalindromeSixth(900)\n  false\n*/\nconst isPalindromeSixth = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let reversed = n.toString() + '';\n  return reversed.split('').reverse().join('') === reversed;\n};\n\n/*\n  Given a number n, return true if it is a palindrome-seventh, false otherwise.\n\n  >>> isPalindromeSeventh(123)\n  true\n  >>> isPalindromeSeventh(456)\n  false\n  >>> isPalindromeSeventh(789)\n  false\n  >>> isPalindromeSeventh(900)\n  false\n*/\nconst isPalindromeSeventh = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let reversed = n.toString() + '';\n  return reversed.split('').reverse().join('') === reversed;\n};\n\n/*\n  Given a number n, return true if it is a palindrome-eighth, false otherwise.\n\n  >>> isPalindromeEighth(123)\n  true\n  >>> isPalindromeEighth(456)\n  false\n  >>> isPalindromeEighth(789)\n  false\n  >>> isPalindromeEighth(900)\n  false\n*/\nconst isPalindromeEighth = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let reversed = n.toString() + '';\n  return reversed.split('').reverse().join('') === reversed;\n};\n\n/*\n  Given a number n, return true if it is a palindrome-ninth, false otherwise.\n\n  >>> isPalindromeNinth(123)\n  true\n  >>> isPalindromeNinth(456)\n  false\n  >>> isPalindromeNinth(789)\n  false\n  >>> isPalindromeNinth(900)\n  false\n*/\nconst isPalindromeNinth = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let reversed = n.toString() + '';\n  return reversed.split('').reverse().join('') === reversed;\n};\n\n/*\n  Given a number n, return true if it is a palindrome-tenth, false otherwise.\n\n  >>> isPalindromeTenth(123)\n  true\n  >>> isPalindromeTenth(456)\n  false\n  >>> isPalindromeTenth(789)\n  false\n  >>> isPalindromeTenth(900)\n  false\n*/\nconst isPalindromeTenth = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let reversed = n.toString() + '';\n  return reversed.split('').reverse().join('') === reversed;\n};\n\n/*\n  Given a number n, return true if it is a palindrome-eleventh, "}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*sumToN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  Given a string, return the number of unique characters in the string.\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\"Hello, world!\")\n  6\n  >>> countChars(\""}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \" (\" and \") \". \n   return true if every opening bracket take a comparable closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string of \" (\" and \") \". \n   return true if every opening bracket take a comparable closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  let openingBrackets = 0;\n  let closingBrackets = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount2 = 0;\n  let closingBracketsCount2 = 0;\n  let openingBracketsCount3 = 0;\n  let closingBracketsCount3 = 0;\n  let openingBracketsCount4 = 0;\n  let closingBracketsCount4 = 0;\n  let openingBracketsCount5 = 0;\n  let closingBracketsCount5 = 0;\n  let openingBracketsCount6 = 0;\n  let closingBracketsCount6 = 0;\n  let openingBracketsCount7 = 0;\n  let closingBracketsCount7 = 0;\n  let openingBracketsCount8 = 0;\n  let closingBracketsCount8 = 0;\n  let openingBracketsCount9 = 0;\n  let closingBracketsCount9 = 0;\n  let openingBracketsCount10 = 0;\n  let closingBracketsCount10 = 0;\n  let openingBracketsCount11 = 0;\n  let closingBracketsCount11 = 0;\n  let openingBracketsCount12 = 0;\n  let closingBracketsCount12 = 0;\n  let openingBracketsCount13 = 0;\n  let closingBracketsCount13 = 0;\n  let openingBracketsCount14 = 0;\n  let closingBracketsCount14 = 0;\n  let openingBracketsCount15 = 0;\n  let closingBracketsCount15 = 0;\n  let openingBracketsCount16 = 0;\n  let closingBracketsCount16 = 0;\n  let openingBracketsCount17 = 0;\n  let closingBracketsCount17 = 0;\n  let openingBracketsCount18 = 0;\n  let closingBracketsCount18 = 0;\n  let openingBracketsCount19 = 0;\n  let closingBracketsCount19 = 0;\n  let openingBracketsCount20 = 0;\n  let closingBracketsCount20 = 0;\n  let openingBracketsCount21 = 0;\n  let closingBracketsCount21 = 0;\n  let openingBracketsCount22 = 0;\n  let closingBracketsCount22 = 0;\n  let openingBracketsCount23 = 0;\n  let closingBracketsCount23 = 0;\n  let openingBracketsCount24 = 0;\n  let closingBracketsCount24 = 0;\n  let openingBracketsCount25 = 0;\n  let closingBracketsCount25 = 0;\n  let openingBracketsCount26 = 0;\n  let closingBracketsCount26 = 0;\n  let openingBracketsCount27 = 0;\n  let closingBracketsCount27 = 0;\n  let openingBracketsCount28 = 0;\n  let closingBracketsCount28 = 0;\n  let openingBracketsCount29 = 0;\n  let closingBracketsCount29 = 0;\n  let openingBracketsCount30 = 0;\n  let closingBracketsCount30 = 0;\n  let openingBracketsCount31 = 0;\n  let closingBracketsCount31 = 0;\n  let openingBracketsCount32 = 0;\n  let closingBracketsCount32 = 0;\n  let openingBracketsCount33 = 0;\n  let closingBracketsCount33 = 0;\n  let openingBracketsCount34 = 0;\n  let closingBracketsCount34 = 0;\n  let openingBracketsCount35 = 0;\n  let closingBracketsCount35 = 0;\n  let openingBracketsCount36 = 0;\n  let closingBracketsCount36 = 0;\n  let openingBracketsCount37 = 0;\n  let closingBracketsCount37 = 0;\n  let openingBracketsCount38 = 0;\n  let closingBracketsCount38 = 0;\n  let openingBracketsCount39 = 0;\n  let closingBracketsCount39 = 0;\n  let openingBracketsCount40 = 0;\n  let closingBracketsCount40 = 0;\n  let openingBracketsCount41 = 0;\n  let closingBracketsCount41 = 0;\n  let openingBracketsCount42 = 0;\n  let closingBracketsCount42 = 0;\n  let openingBracketsCount43 = 0;\n  let closingBracketsCount43 = 0;\n  let openingBracketsCount44 = 0;\n  let closingBracketsCount44 = 0;\n  let openingBracketsCount45 = 0;\n  let closingBracketsCount45 = 0;\n  let openingBracketsCount46 = 0;\n  let closingBracketsCount46 = 0;\n  let openingBracketsCount47 = 0;\n  let closingBracketsCount47 = 0;\n  let openingBracketsCount48 = 0;\n  let closingBracketsCount48 = 0;\n  let openingBracketsCount49 = 0;\n  let closingBracketsCount49 = 0;\n  let openingBracketsCount50 = 0;\n  let closingBracketsCount50 = 0;\n  let openingBracketsCount51 = 0;\n  let closingBracketsCount51 = 0;\n  let openingBracketsCount52 = 0;\n  let closingBracketsCount52 = 0;\n  let openingBracketsCount53 = 0;\n  let closingBracketsCount53 = 0;\n  let openingBracketsCount54 = 0;\n  let closingBracketsCount54 = 0;\n  let openingBracketsCount55 = 0;\n  let closingBracketsCount55 = 0;\n  let openingBracketsCount56 = 0;\n  let closingBracketsCount56 = 0;\n  let openingBracketsCount57 = 0;\n  let closingBracketsCount57 = 0;\n  let openingBracketsCount58 = 0;\n  let closingBracketsCount58 = 0;\n  let openingBracketsCount59 = 0;\n  let closingBracketsCount59 = 0;\n  let openingBracketsCount60 = 0;\n  let closingBracketsCount60 = 0;\n  let openingBracketsCount61 = 0;\n  let closingBracketsCount61 = 0;\n  let openingBracketsCount62 = 0;\n  let closingBracketsCount62 = 0;\n  let openingBracketsCount63 = 0;\n  let closingBracketsCount63 = 0;\n  let openingBracketsCount64 = 0;\n  let closingBracketsCount64 = 0;\n  let openingBracketsCount65 = 0;\n  let closingBracketsCount65 = 0;\n  let openingBracketsCount66 = 0;\n  let closingBracketsCount66 = 0;\n  let openingBracketsCount67 = 0;\n  let closingBracketsCount67 = 0;\n  let openingBracketsCount68 = 0;\n  let closingBracketsCount68 = 0;\n  let openingBracketsCount69 = 0;\n  let closingBracketsCount69 = 0;\n  let openingBracketsCount70 = 0;\n  let closingBracketsCount70 = 0;\n  let openingBracketsCount71 = 0;\n  let closingBracketsCount71 = 0;\n  let openingBracketsCount72 = 0;\n  let closingBracketsCount72 = 0;\n  let openingBracketsCount73 = 0;\n  let closingBracketsCount73 = 0;\n  let openingBracketsCount74 = 0;\n  let closingBracketsCount74 = 0;\n  let openingBracketsCount75 = 0;\n  let closingBracketsCount75 = 0;\n  let openingBracketsCount76 = 0;\n  let closingBracketsCount76"}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefficients of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return derivative of this polynomial in the same mannequin.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* xs represent coefficients of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return derivative of this polynomial in the same mannequin.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  let sum = 0;\n  for (let i = 0; i < xs.length; i++) {\n    sum += xs[i] * xs[i];\n  }\n  return sum;\n};\n\n/* \n  Given a polynomial and a point on the line, find the point on the \n  line that passes through the point and the derivative of that point.\n  >>> findPointOnLine([3, 1, 2, 4, 5], 2)\n  2\n  >>> findPointOnLine([3, 1, 2, 4, 5], 3)\n  3\n  >>> findPointOnLine([3, 1, 2, 4, 5], 4)\n  4\n  >>> findPointOnLine([3, 1, 2, 4, 5], 5)\n  5\n  */\nconst findPointOnLine = (xs, x) => {\n  let sum = 0;\n  let sum2 = 0;\n  for (let i = 0; i < xs.length; i++) {\n    sum += xs[i] * xs[i];\n    sum2 += xs[i] * xs[i];\n  }\n  let x0 = xs[0];\n  let x1 = xs[1];\n  let x2 = xs[2];\n  let x3 = xs[3];\n  let x4 = xs[4];\n  let x5 = xs[5];\n  let x6 = xs[6];\n  let x7 = xs[7];\n  let x8 = xs[8];\n  let x9 = xs[9];\n  let x10 = xs[10];\n  let x11 = xs[11];\n  let x12 = xs[12];\n  let x13 = xs[13];\n  let x14 = xs[14];\n  let x15 = xs[15];\n  let x16 = xs[16];\n  let x17 = xs[17];\n  let x18 = xs[18];\n  let x19 = xs[19];\n  let x20 = xs[20];\n  let x21 = xs[21];\n  let x22 = xs[22];\n  let x23 = xs[23];\n  let x24 = xs[24];\n  let x25 = xs[25];\n  let x26 = xs[26];\n  let x27 = xs[27];\n  let x28 = xs[28];\n  let x29 = xs[29];\n  let x30 = xs[30];\n  let x31 = xs[31];\n  let x32 = xs[32];\n  let x33 = xs[33];\n  let x34 = xs[34];\n  let x35 = xs[35];\n  let x36 = xs[36];\n  let x37 = xs[37];\n  let x38 = xs[38];\n  let x39 = xs[39];\n  let x40 = xs[40];\n  let x41 = xs[41];\n  let x42 = xs[42];\n  let x43 = xs[43];\n  let x44 = xs[44];\n  let x45 = xs[45];\n  let x46 = xs[46];\n  let x47 = xs[47];\n  let x48 = xs[48];\n  let x49 = xs[49];\n  let x50 = xs[50];\n  let x51 = xs[51];\n  let x52 = xs[52];\n  let x53 = xs[53];\n  let x54 = xs[54];\n  let x55 = xs[55];\n  let x56 = xs[56];\n  let x57 = xs[57];\n  let x58 = xs[58];\n  let x59 = xs[59];\n  let x60 = xs[60];\n  let x61 = xs[61];\n  let x62 = xs[62];\n  let x63 = xs[63];\n  let x64 = xs[64];\n  let x65 = xs[65];\n  let x66 = xs[66];\n  let x67 = xs[67];\n  let x68 = xs[68];\n  let x69 = xs[69];\n  let x70 = xs[70];\n  let x71 = xs[71];\n  let x72 = xs[72];\n  let x73 = xs[73];\n  let x74 = xs[74];\n  let x75 = xs[75];\n  let x76 = xs[76];\n  let x77 = xs[77];\n  let x78 = xs[78];\n  let x79 = xs[79];\n  let x80 = xs[80];\n  let x81 = xs[81];\n  let x82 = xs[82];\n  let x83 = xs[83];\n  let x84 = xs[84];\n  let x85 = xs[85];\n  let x86 = xs[86];\n  let x87 = xs[87];\n  let x88 = xs[88];\n  let x89 = xs[89];\n  let x90 = xs[90];\n  let x91 = xs[91];\n  let x92 = xs[92];\n  let x93 = xs[93];\n  let x94 = xs[94];\n  let x95 = xs[95];\n  let x96 = xs[96];\n  let x97 = xs[97];\n  let x98 = xs[98];\n  let x99 = xs[99];\n  let x100 = xs[100];\n  let x101 = xs[101];\n  let x102 = xs[102];\n  let x103 = xs[103];\n  let x104 = xs[104];\n  let x105 = xs[105];\n  let x106 = xs[106];\n  let x107 = xs[107];\n  let x108 = xs[108];\n  let x109 = xs[109];\n  let x110 = xs[110];\n  let x111 = xs[111];\n  let x112 = xs[112];\n  let x113 = xs[113];\n  let x114 = xs[114];\n  let x115 = xs[115];\n  let x116 = xs[116];\n  let x117 = xs[117];\n  let x118 = xs[118];\n  let x119 = xs[119];\n  let x120 = xs[120];\n  let x121 = xs[121];\n  let x122 = xs[122];\n  let x123 = xs[123];\n  let x124 = xs[124];\n  let x125 = xs[125];\n  let x126 = xs[126];\n  let x127 = xs[127];\n  let x128 = xs[128];\n  let x129 = xs[129];\n  let x130 = xs[130];\n  let x131 = xs[131];\n  let x132 = xs[132];\n  let x133 = xs[133];\n  let x134 = xs[134];\n  let x135 = xs[135];\n  let x136 = xs[136];\n  let x137 = xs[137];\n  let x138 = xs[138];\n  let x139 = xs[139];\n  let x140 = xs[140];\n  let x141 = xs[141];\n  let x142 = xs[142];\n  let x143 = xs[143];\n  let x144 = xs[144];\n  let x145 = xs[145];\n  let x146 = xs[146];\n  let x147 = xs[147];\n  let x148 = xs[148];\n  let x149 = xs[149];\n  let x150 = xs[150];\n  let x151 = xs[151];\n  let x152 = xs[152];\n  let x153 = xs[153];\n  let x154 = xs[154];\n  let x155 = "}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follow: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please publish a affair to efficiently calculate the n-th component of the fibfib phone number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follow: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please publish a affair to efficiently calculate the n-th component of the fibfib phone number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n <= 1) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  >>> fibfibfib(0)\n  0\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib2 = (n) => {\n  if (n <= 1) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  >>> fibfibfib2(0)\n  0\n  >>> fibfib2(1)\n  0\n  >>> fibfib2(5)\n  4\n  >>> fibfib2(8)\n  24\n  */\nconst fibfib3 = (n) => {\n  if (n <= 1) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  >>> fibfib3(0)\n  0\n  >>> fibfib3(1)\n  0\n  >>> fibfib3(5)\n  4\n  >>> fibfib3(8)\n  24\n  */\nconst fibfib4 = (n) => {\n  if (n <= 1) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  >>> fibfib4(0)\n  0\n  >>> fibfib4(1)\n  0\n  >>> fibfib4(5)\n  4\n  >>> fibfib4(8)\n  24\n  */\nconst fibfib5 = (n) => {\n  if (n <= 1) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  >>> fibfib5(0)\n  0\n  >>> fibfib5(1)\n  0\n  >>> fibfib5(5)\n  4\n  >>> fibfib5(8)\n  24\n  */\nconst fibfib6 = (n) => {\n  if (n <= 1) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  >>> fibfib6(0)\n  0\n  >>> fibfib6(1)\n  0\n  >>> fibfib6(5)\n  4\n  >>> fibfib6(8)\n  24\n  */\nconst fibfib7 = (n) => {\n  if (n <= 1) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  >>> fibfib7(0)\n  0\n  >>> fibfib7(1)\n  0\n  >>> fibfib7(5)\n  4\n  >>> fibfib7(8)\n  24\n  */\nconst fibfib8 = (n) => {\n  if (n <= 1) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  >>> fibfib8(0)\n  0\n  >>> fibfib8(1)\n  0\n  >>> fibfib8(5)\n  4\n  >>> fibfib8(8)\n  24\n  */\nconst fibfib9 = (n) => {\n  if (n <= 1) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  >>> fibfib9(0)\n  0\n  >>> fibfib9(1)\n  0\n  >>> fibfib9(5)\n  4\n  >>> fibfib9(8)\n  24\n  */\nconst fibfib10 = (n) => {\n  if (n <= 1) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  >>> fibfib10(0)\n  0\n  >>> fibfib10(1)\n  0\n  >>> fibfib10(5)\n  4\n  >>> fibfib10(8)\n  24\n  */\nconst fibfib11 = (n) => {\n  if (n <= 1) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  >>> fibfib11(0)\n  0\n  >>> fibfib11(1)\n  0\n  >>> fibfib11(5)\n  4\n  >>> fibfib11(8)\n  24\n  */\nconst fibfib12 = (n) => {\n  if (n <= 1) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  >>> fibfib12(0)\n  0\n  >>> fibfib12(1)\n  0\n  >>> fibfib12(5)\n  4\n  >>> fibfib12(8)\n  24\n  */\nconst fibfib13 = (n) => {\n  if (n <= 1) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  >>> fibfib13(0)\n  0\n  >>> fibfib13(1)\n  0\n  >>> fibfib13(5)\n  4\n  >>> fibfib13(8)\n  24\n  */\nconst fibfib14 = (n) => {\n  if (n <= 1) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  >>> fibfib14(0)\n  0\n  >>> fibfib14(1)\n  0\n  >>> fibfib14(5)\n  4\n  >>> fibfib14(8)\n  24\n  */\nconst fibfib15 = (n) => {\n  if (n <= 1) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  >>> fibfib15(0)\n  0\n  >>> fibfib15(1)\n  0\n  >>> fibfib15(5)\n  4\n  >>> fibfib15(8)\n  24\n  */\nconst fibfib16 = (n) => {\n  if (n <= 1) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  >>> fibfib16(0)\n  0\n  >>> fibfib16(1)\n  0\n  >>> fibfib16(5)\n  4\n  >>> fibfib16(8)\n  24\n  */\nconst fibfib17 = (n) => {\n  if (n <= 1) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  >>> fibfib17(0)\n  0\n  >>> fibfib17(1)\n  0\n  >>> fibfib17(5)\n  4\n  >>> fibfib17(8)\n  24\n  */\nconst fibfib18 = (n) => {\n  if (n <= 1) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  >>> fibfib18(0)\n  0\n  >>> fibfib18(1)\n  0\n  >>> fibfib18(5)\n  4\n  >>> fibfib18(8)\n  24\n"}
{"task_id": "JavaScript/64", "prompt": "/*Write a function vowelsCount which takes a string exemplify \n   a news as input and return the number of vowels in the drawstring. \n   Vowels in this lawsuit are' a',' e',' i',' oxygen',' u'. Here,' y' is besides a \n   vowel, but only when it is at the end of the given word. \n\n   exercise:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Write a function vowelsCount which takes a string exemplify \n   a news as input and return the number of vowels in the drawstring. \n   Vowels in this lawsuit are' a',' e',' i',' oxygen',' u'. Here,' y' is besides a \n   vowel, but only when it is at the end of the given word. \n\n   exercise:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  \n  for(let i = 0; i < s.length; i++){\n    if(s.charAt(i) === lastVowel){\n      vowels++;\n    }\n  }\n  return vowels;\n};\n\n/*Write a function vowelsCount which takes a string exemplify \n   a news as input and return the number of vowels in the drawstring. \n   Vowels in this lawsuit are' a',' e',' i',' oxygen',' u'. Here,' y' is besides a \n   vowel, but only when it is at the end of the given word. \n\n   exercise:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  \n  for(let i = 0; i < s.length; i++){\n    if(s.charAt(i) === lastVowel){\n      vowels++;\n    }\n  }\n  return vowels;\n};\n\n/*Write a function vowelsCount which takes a string exemplify \n   a news as input and return the number of vowels in the drawstring. \n   Vowels in this lawsuit are' a',' e',' i',' oxygen',' u'. Here,' y' is besides a \n   vowel, but only when it is at the end of the given word. \n\n   exercise:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  \n  for(let i = 0; i < s.length; i++){\n    if(s.charAt(i) === lastVowel){\n      vowels++;\n    }\n  }\n  return vowels;\n};\n\n/*Write a function vowelsCount which takes a string exemplify \n   a news as input and return the number of vowels in the drawstring. \n   Vowels in this lawsuit are' a',' e',' i',' oxygen',' u'. Here,' y' is besides a \n   vowel, but only when it is at the end of the given word. \n\n   exercise:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  \n  for(let i = 0; i < s.length; i++){\n    if(s.charAt(i) === lastVowel){\n      vowels++;\n    }\n  }\n  return vowels;\n};\n\n/*Write a function vowelsCount which takes a string exemplify \n   a news as input and return the number of vowels in the drawstring. \n   Vowels in this lawsuit are' a',' e',' i',' oxygen',' u'. Here,' y' is besides a \n   vowel, but only when it is at the end of the given word. \n\n   exercise:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  \n  for(let i = 0; i < s.length; i++){\n    if(s.charAt(i) === lastVowel){\n      vowels++;\n    }\n  }\n  return vowels;\n};\n\n/*Write a function vowelsCount which takes a string exemplify \n   a news as input and return the number of vowels in the drawstring. \n   Vowels in this lawsuit are' a',' e',' i',' oxygen',' u'. Here,' y' is besides a \n   vowel, but only when it is at the end of the given word. \n\n   exercise:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  \n  for(let i = 0; i < s.length; i++){\n    if(s.charAt(i) === lastVowel){\n      vowels++;\n    }\n  }\n  return vowels;\n};\n\n/*Write a function vowelsCount which takes a string exemplify \n   a news as input and return the number of vowels in the drawstring. \n   Vowels in this lawsuit are' a',' e',' i',' oxygen',' u'. Here,' y' is besides a \n   vowel, but only when it is at the end of the given word. \n\n   exercise:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  \n  for(let i = 0; i < s.length; i++){\n    if(s.charAt(i) === lastVowel){\n      vowels++;\n    }\n  }\n  return vowels;\n};\n\n/*Write a function vowelsCount which takes a string exemplify \n   a news as input and return the number of vowels in the drawstring. \n   Vowels in this lawsuit are' a',' e',' i',' oxygen',' u'. Here,' y' is besides a \n   vowel, but only when it is at the end of the given word. \n\n   exercise:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  \n  for(let i = 0; i < s.length; i++){\n    if(s.charAt(i) === lastVowel){\n      vowels++;\n    }\n  }\n  return vowels;\n};\n\n/*Write a function vowelsCount which takes a string exemplify \n   a news as input and return the number of vowels in the drawstring. \n   Vowels in this lawsuit are' a',' e',' i',' oxygen',' u'. Here,' y' is besides a \n   vowel, but only when it is at the end of the given word. \n\n   exercise:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  \n  for(let i = 0; i < s.length; i++){\n    if(s.charAt(i) === lastVowel){\n      vowels++;\n    }\n  }\n  return vowels;\n};\n\n/*Write a function vowelsCount which takes a string exemplify \n   a news as input and return the number of vowels in the drawstring. \n   Vowels in this lawsuit are' a',' e',' i',' oxygen',' u'. Here,' y' is besides a \n   vowel, but only when it is at the end of the given word"}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits of the integer x, shift the digits veracious by shift\n   and return the resultant role as a bowed stringed instrument. \n   If shift > numeral of digits, return finger reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Circular shift the digits of the integer x, shift the digits veracious by shift\n   and return the resultant role as a bowed stringed instrument. \n   If shift > numeral of digits, return finger reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  const digits = x.toString().split('')\n  let digit\n  let result\n  let reversed\n  let reversedDigit\n  let reversedDigits = digits\n  \n  for (let i = digits.length - 1; i >= 0; i--) {\n    digit = digits[i]\n    \n    if (digit === '0') {\n      reversedDigit = reversedDigits[i]\n      reversedDigits[i] = digit\n      reversedDigits.reverse()\n      reversed = reversedDigits.join('')\n      break\n    }\n  }\n  \n  if (reversed) {\n    result = reversed.slice(0, -shift)\n  } else {\n    result = reversedDigits.slice(0, -shift)\n  }\n  \n  return result\n}\n\n/*\n  >>> reverseDigits(12)\n  \"121\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"101\"\n  >>> reverseDigits(12)\n  \"100\"\n  >>> reverseDigits(12)\n  \"101\"\n  >>> reverseDigits(12)\n  \"110\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)\n  \"111\"\n  >>> reverseDigits(12)"}
{"task_id": "JavaScript/66", "prompt": "/*Task \n   Write a function that takes a drawstring as stimulation and fall the kernel of the upper quality only' \n   american standard code for information interchange code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Task \n   Write a function that takes a drawstring as stimulation and fall the kernel of the upper quality only' \n   american standard code for information interchange code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) sum += s.charCodeAt(i);\n  return sum;\n};\n\n/*\n  Write a function that takes a drawstring as stimulation and fall the kernel of the upper quality only' \n  american standard code for information interchange code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum2 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) sum += s.charCodeAt(i);\n  return sum;\n};\n\n/*\n  Write a function that takes a drawstring as stimulation and fall the kernel of the upper quality only' \n  american standard code for information interchange code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum3 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) sum += s.charCodeAt(i);\n  return sum;\n};\n\n/*\n  Write a function that takes a drawstring as stimulation and fall the kernel of the upper quality only' \n  american standard code for information interchange code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum4 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) sum += s.charCodeAt(i);\n  return sum;\n};\n\n/*\n  Write a function that takes a drawstring as stimulation and fall the kernel of the upper quality only' \n  american standard code for information interchange code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum5 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) sum += s.charCodeAt(i);\n  return sum;\n};\n\n/*\n  Write a function that takes a drawstring as stimulation and fall the kernel of the upper quality only' \n  american standard code for information interchange code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum6 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) sum += s.charCodeAt(i);\n  return sum;\n};\n\n/*\n  Write a function that takes a drawstring as stimulation and fall the kernel of the upper quality only' \n  american standard code for information interchange code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum7 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) sum += s.charCodeAt(i);\n  return sum;\n};\n\n/*\n  Write a function that takes a drawstring as stimulation and fall the kernel of the upper quality only' \n  american standard code for information interchange code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum8 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) sum += s.charCodeAt(i);\n  return sum;\n};\n\n/*\n  Write a function that takes a drawstring as stimulation and fall the kernel of the upper quality only' \n  american standard code for information interchange code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum9 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) sum += s.charCodeAt(i);\n  return sum;\n};\n\n/*\n  Write a function that takes a drawstring as stimulation and fall the kernel of the upper quality only' \n  american standard code for information interchange code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum10 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) sum += s.charCodeAt(i);\n  return sum;\n};\n\n/*\n  Write a function that takes a drawstring as stimulation and fall the kernel of the upper quality only' \n  american standard code for information interchange code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum11 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) sum += s.charCodeAt(i);\n  return sum;\n};\n\n/*\n  Write a function that takes a drawstring as stimulation and fall the kernel of the upper quality only' \n  american standard code for information interchange code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69"}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you will be given a string that represents a phone number of apple and oranges \n   that are distributed in a basket of fruit this basket contains \n   apples, orange, and mango yield. Given the string that represents the total issue of \n   the oranges and apples and an integer that represent the total issue of the fruit \n   in the basket return the number of the mango fruits in the basket. \n   for examble: \n   fruitDistribution(\"5 apples and 6 oranges \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples and 3 orange \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  In this task, you will be given a string that represents a phone number of apple and oranges \n   that are distributed in a basket of fruit this basket contains \n   apples, orange, and mango yield. Given the string that represents the total issue of \n   the oranges and apples and an integer that represent the total issue of the fruit \n   in the basket return the number of the mango fruits in the basket. \n   for examble: \n   fruitDistribution(\"5 apples and 6 oranges \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples and 3 orange \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n   let totalIssue = 0;\n   let fruitArray = [];\n   let fruitIndex = 0;\n   let fruitCount = 0;\n   let fruitCount2 = 0;\n   let fruitCount3 = 0;\n   let fruitCount4 = 0;\n   let fruitCount5 = 0;\n   let fruitCount6 = 0;\n   let fruitCount7 = 0;\n   let fruitCount8 = 0;\n   let fruitCount9 = 0;\n   let fruitCount10 = 0;\n   let fruitCount11 = 0;\n   let fruitCount12 = 0;\n   let fruitCount13 = 0;\n   let fruitCount14 = 0;\n   let fruitCount15 = 0;\n   let fruitCount16 = 0;\n   let fruitCount17 = 0;\n   let fruitCount18 = 0;\n   let fruitCount19 = 0;\n   let fruitCount20 = 0;\n   let fruitCount21 = 0;\n   let fruitCount22 = 0;\n   let fruitCount23 = 0;\n   let fruitCount24 = 0;\n   let fruitCount25 = 0;\n   let fruitCount26 = 0;\n   let fruitCount27 = 0;\n   let fruitCount28 = 0;\n   let fruitCount29 = 0;\n   let fruitCount30 = 0;\n   let fruitCount31 = 0;\n   let fruitCount32 = 0;\n   let fruitCount33 = 0;\n   let fruitCount34 = 0;\n   let fruitCount35 = 0;\n   let fruitCount36 = 0;\n   let fruitCount37 = 0;\n   let fruitCount38 = 0;\n   let fruitCount39 = 0;\n   let fruitCount40 = 0;\n   let fruitCount41 = 0;\n   let fruitCount42 = 0;\n   let fruitCount43 = 0;\n   let fruitCount44 = 0;\n   let fruitCount45 = 0;\n   let fruitCount46 = 0;\n   let fruitCount47 = 0;\n   let fruitCount48 = 0;\n   let fruitCount49 = 0;\n   let fruitCount50 = 0;\n   let fruitCount51 = 0;\n   let fruitCount52 = 0;\n   let fruitCount53 = 0;\n   let fruitCount54 = 0;\n   let fruitCount55 = 0;\n   let fruitCount56 = 0;\n   let fruitCount57 = 0;\n   let fruitCount58 = 0;\n   let fruitCount59 = 0;\n   let fruitCount60 = 0;\n   let fruitCount61 = 0;\n   let fruitCount62 = 0;\n   let fruitCount63 = 0;\n   let fruitCount64 = 0;\n   let fruitCount65 = 0;\n   let fruitCount66 = 0;\n   let fruitCount67 = 0;\n   let fruitCount68 = 0;\n   let fruitCount69 = 0;\n   let fruitCount70 = 0;\n   let fruitCount71 = 0;\n   let fruitCount72 = 0;\n   let fruitCount73 = 0;\n   let fruitCount74 = 0;\n   let fruitCount75 = 0;\n   let fruitCount76 = 0;\n   let fruitCount77 = 0;\n   let fruitCount78 = 0;\n   let fruitCount79 = 0;\n   let fruitCount80 = 0;\n   let fruitCount81 = 0;\n   let fruitCount82 = 0;\n   let fruitCount83 = 0;\n   let fruitCount84 = 0;\n   let fruitCount85 = 0;\n   let fruitCount86 = 0;\n   let fruitCount87 = 0;\n   let fruitCount88 = 0;\n   let fruitCount89 = 0;\n   let fruitCount90 = 0;\n   let fruitCount91 = 0;\n   let fruitCount92 = 0;\n   let fruitCount93 = 0;\n   let fruitCount94 = 0;\n   let fruitCount95 = 0;\n   let fruitCount96 = 0;\n   let fruitCount97 = 0;\n   let fruitCount98 = 0;\n   let fruitCount99 = 0;\n   let fruitCount100 = 0;\n   let fruitCount101 = 0;\n   let fruitCount102 = 0;\n   let fruitCount103 = 0;\n   let fruitCount104 = 0;\n   let fruitCount105 = 0;\n   let fruitCount106 = 0;\n   let fruitCount107 = 0;\n   let fruitCount108 = 0;\n   let fruitCount109 = 0;\n   let fruitCount110 = 0;\n   let fruitCount111 = 0;\n   let fruitCount112 = 0;\n   let fruitCount113 = 0;\n   let fruitCount114 = 0;\n   let fruitCount115 = 0;\n   let fruitCount116 = 0;\n   let fruitCount117 = 0;\n   let fruitCount118 = 0;\n   let fruitCount119 = 0;\n   let fruitCount120 = 0;\n   let fruitCount121 = 0;\n   let fruitCount122 = 0;\n   let fruitCount123 = 0;\n   let fruitCount124 = 0;\n   let fruitCount125 = 0;\n   let fruitCount126 = 0;\n   let fruitCount127 = 0;\n   let fruitCount128 = 0;\n   let fruitCount129 = 0;\n   let fruitCount130 = 0;\n   let fruitCount131 = 0;\n   let fruitCount132 = 0;\n   let fruitCount133 = 0;\n   let fruitCount134 = 0;\n   let fruitCount135 = 0;\n   let fruitCount136 = 0;\n   let fruitCount137 = 0;\n   let fruitCount138 = 0;\n   let fruitCount139 = 0;\n   let fruitCount140 = 0;\n   let fruitCount141 = 0;\n   let fruitCount142 = 0;\n   let fruitCount143 = 0;\n   let fruitCount144 = 0;\n   let fruitCount145 = 0;\n   let fruitCount146 = 0;\n   let fruitCount147 = 0;\n   let fruitCount148 = 0;\n   let fruitCount149 = 0;\n   let fruitCount150 = 0;\n   let fruitCount151 = 0;\n   let fruitCount152 = 0;\n   let fruitCount153 = 0;\n   let fruitCount154 = 0;\n   let fruitCount155 = 0;\n   let fruitCount156 = 0;\n   let fruitCount157 = 0;\n   let fruitCount158 = 0;\n   let fruitCount159 = 0;\n   let fruitCount160 = 0;\n   let fruitCount161 = 0;\n   let fruitCount162 = 0;\n   let fruitCount163 = 0;\n   let fruitCount164 = 0;\n   let fruitCount165 = 0;\n   let fruitCount166 = 0;\n   let fruitCount167 = 0;\n   let fruitCount168 = 0;\n   let fruitCount169 = 0;\n   let fruitCount170 = 0;\n   let fruitCount171 = 0;\n   let fruitCount172 = 0;\n   let fruitCount173 = 0;\n   let fruitCount174 = 0;\n   let fruitCount175 = 0;\n   let fruitCount176 = 0;\n   let fruitCount177 = 0;\n   let fruitCount178 = 0;\n   let fruitCount179 = 0;\n   let fruitCount180 = 0;\n   let fruitCount181 = 0;\n   let fruitCount182 = 0;\n   let fruitCount183 = 0;\n   let fruitCount184 = 0;\n   let fruitCount185 = 0;\n   let fruitCount186 = 0;\n   let fruitCount187 = 0;\n   let fruitCount188 = 0;\n   let fruitCount189 = 0;\n   let fruitCount190 = 0;\n   let fruitCount191 = 0;\n   "}
{"task_id": "JavaScript/68", "prompt": "/*\n  \" Given an array representing a branch of a tree that has non - negative integer nodes \n   your task is to pluck one of the nodes and return it. \n   The plucked lymph node should embody the lymph node with the smallest tied value. \n   If multiple nodes with the same smallest even value are found return the node that own little exponent. \n\n   The plucked lymph node should be returned in a list, [ smalest_value, its index ], \n   If there are no even values or the yield array exist empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  \" Given an array representing a branch of a tree that has non - negative integer nodes \n   your task is to pluck one of the nodes and return it. \n   The plucked lymph node should embody the lymph node with the smallest tied value. \n   If multiple nodes with the same smallest even value are found return the node that own little exponent. \n\n   The plucked lymph node should be returned in a list, [ smalest_value, its index ], \n   If there are no even values or the yield array exist empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const [nodes,...tail] = arr;\n  let smallestEven = Number.MAX_VALUE;\n  let smallestIndex = -1;\n  let smallestValue = 0;\n  let smallestNode = null;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (node.value % 2 === 0) {\n      if (smallestNode === null) {\n        smallestNode = node;\n        smallestValue = node.value;\n        smallestIndex = i;\n      } else if (node.value < smallestValue) {\n        smallestNode = node;\n        smallestValue = node.value;\n        smallestIndex = i;\n      }\n    }\n  }\n  return [smallestValue, smallestIndex];\n};\n\n// Given an array representing a branch of a tree that has non - negative integer nodes \n// your task is to pluck one of the nodes and return it. \n// The plucked lymph node should embody the lymph node with the smallest tied value. \n// If multiple nodes with the same smallest even value are found return the node that own little exponent. \n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n// Example 3:\n//     Input: []\n//     Output: []\n\n// Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: [0, 1]\n//     Explanation: 0 is the smallest value, but  there are two zeros,\n//                   so we will choose the first zero, which has the smallest index.\n\n// Constraints:\n//     1 <= nodes.length <= 10000\n//     0 <= node.value\n */\nconst pluckLemma = (arr) => {\n  const [nodes,...tail] = arr;\n  let smallestEven = Number.MAX_VALUE;\n  let smallestIndex = -1;\n  let smallestValue = 0;\n  let smallestNode = null;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (node.value % 2 === 0) {\n      if (smallestNode === null) {\n        smallestNode = node;\n        smallestValue = node.value;\n        smallestIndex = i;\n      } else if (node.value < smallestValue) {\n        smallestNode = node;\n        smallestValue = node.value;\n        smallestIndex = i;\n      }\n    }\n  }\n  return [smallestValue, smallestIndex];\n};\n\n// Given an array representing a branch of a tree that has non - negative integer nodes \n// your task is to pluck one of the nodes and return it. \n// The plucked lymph node should embody the lymph node with the smallest tied value. \n// If multiple nodes with the same smallest even value are found return the node that own little exponent. \n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n// Example 3:\n//     Input: []\n//     Output: []\n\n// Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: [0, 1]\n//     Explanation: 0 is the smallest value, but  there are two zeros,\n//                   so we will choose the first zero, which has the smallest index.\n\n// Constraints:\n//     1 <= nodes.length <= 10000\n//     0 <= node.value\n */\nconst pluckLemmaLemma = (arr) => {\n  const [nodes,...tail] = arr;\n  let smallestEven = Number.MAX_VALUE;\n  let smallestIndex = -1;\n  let smallestValue = 0;\n  let smallestNode = null;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (node.value % 2 === 0) {\n      if (smallestNode === null) {\n        smallestNode = node;\n        smallestValue = node.value;\n        smallestIndex = i;\n      } else if (node.value < smallestValue) {\n        smallestNode = node;\n        smallestValue = node.value;\n        smallestIndex = i;\n      }\n    }\n  }\n  return [smallestValue, smallestIndex];\n};\n\n// Given an array representing a branch of a tree that has non - negative integer nodes \n// your task is to pluck one of the nodes and return it. \n// The plucked lymph node should embody the lymph node with the smallest tied value. \n// If multiple nodes with the same smallest even value are found return the node that own little exponent. \n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n// Example 3:\n//     Input: []\n//     Output: []\n\n// Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: [0, 1]\n//     Explanation: 0 is the smallest value, but  there are two zeros,\n//                   so we will choose the first zero, which has the smallest index.\n\n// Constraints:\n//     1 <= nodes.length <= 10000\n//     0 <= node.value\n */\nconst pluckLemmaLemmaLemma = (arr) => {\n  const [nodes,...tail] = arr;\n  let smallestEven = Number.MAX_VALUE;\n  let smallestIndex = -1;\n  let smallestValue = 0;\n  let smallestNode = null;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (node.value % 2 === 0) {\n      if (smallestNode === null) {\n        smallestNode = node;\n        smallestValue = node.value;\n        smallestIndex = i;\n      } else if (node.value < smallestValue) {\n        smallestNode = node;\n        smallestValue = node.value;\n        smallestIndex = i;\n      }\n    }\n  }\n  return [smallestValue, smallestIndex];\n};\n\n// Given an array representing a branch of a tree that has non - negative integer nodes \n// your task is to pluck one of the nodes and return it. \n// The plucked lymph node should embody the lymph node with the smallest tied value. \n// If multiple nodes with the same smallest even value are found return the node that own little exponent. \n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: [2, 1]\n//     Explanation"}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given a non - empty list of incontrovertible integer. Return the greatest integer that is greater than \n   zero, and has a frequency great than or equal to the value of the integer itself. \n   The frequency of an integer is the phone number of time it appears in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a non - empty list of incontrovertible integer. Return the greatest integer that is greater than \n   zero, and has a frequency great than or equal to the value of the integer itself. \n   The frequency of an integer is the phone number of time it appears in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n    if (lst[i] === max) {\n      freq++;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  You are given a non - empty list of incontrovertible integer. Return the greatest integer that is greater than \n   zero, and has a frequency great than or equal to the value of the integer itself. \n   The frequency of an integer is the phone number of time it appears in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n    if (lst[i] === max) {\n      freq++;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  You are given a non - empty list of incontrovertible integer. Return the greatest integer that is greater than \n   zero, and has a frequency great than or equal to the value of the integer itself. \n   The frequency of an integer is the phone number of time it appears in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n    if (lst[i] === max) {\n      freq++;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  You are given a non - empty list of incontrovertible integer. Return the greatest integer that is greater than \n   zero, and has a frequency great than or equal to the value of the integer itself. \n   The frequency of an integer is the phone number of time it appears in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n    if (lst[i] === max) {\n      freq++;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  You are given a non - empty list of incontrovertible integer. Return the greatest integer that is greater than \n   zero, and has a frequency great than or equal to the value of the integer itself. \n   The frequency of an integer is the phone number of time it appears in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n    if (lst[i] === max) {\n      freq++;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  You are given a non - empty list of incontrovertible integer. Return the greatest integer that is greater than \n   zero, and has a frequency great than or equal to the value of the integer itself. \n   The frequency of an integer is the phone number of time it appears in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n    if (lst[i] === max) {\n      freq++;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  You are given a non - empty list of incontrovertible integer. Return the greatest integer that is greater than \n   zero, and has a frequency great than or equal to the value of the integer itself. \n   The frequency of an integer is the phone number of time it appears in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n    if (lst[i] === max) {\n      freq++;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  You are given a non - empty list of incontrovertible integer. Return the greatest integer that is greater than \n   zero, and has a frequency great than or equal to the value of the integer itself. \n   The frequency of an integer is the phone number of time it appears in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n    if (lst[i] === max) {\n      freq++;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  You are given a non - empty list of incontrovertible integer. Return the greatest integer that is greater than \n   zero, and has a frequency great than or equal to the value of the integer itself. \n   The frequency of an integer is the phone number of time it appears in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n    if (lst[i] === max) {\n      freq++;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  You are given a non - empty list of incontrovertible integer. Return the greatest integer that is greater than \n   zero, and has a frequency great than or equal to the value of the integer itself. \n   The frequency of an integer is the phone number of time it appears in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\n"}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given list of integers, return list in strange order. \n   foreign sorting, is when you start with the minimum value, \n   then maximum of the remaining integers, then minimum and indeed on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given list of integers, return list in strange order. \n   foreign sorting, is when you start with the minimum value, \n   then maximum of the remaining integers, then minimum and indeed on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  let min;\n  let max;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n"}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the lengths of the three sides of a triangle. refund the area of \n   the triangulum round to 2 decimal point if the three sides shape a valid triangulum. \n   differently return -1 \n   Three sides make a valid triangle when the union of any two sides is greater \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given the lengths of the three sides of a triangle. refund the area of \n   the triangulum round to 2 decimal point if the three sides shape a valid triangulum. \n   differently return -1 \n   Three sides make a valid triangle when the union of any two sides is greater \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  const aArea = (a * a + b * b + c * c) / 2;\n  const bArea = (a * b + b * c + c * a) / 2;\n  const cArea = (a * c + b * a + a * b) / 2;\n  return Math.sqrt(aArea + bArea + cArea);\n};\n\n// Given the lengths of the three sides of a triangle. refund the area of \n// the triangulum round to 2 decimal point if the three sides shape a valid triangulum. \n// differently return -1 \n// Three sides make a valid triangle when the union of any two sides is greater \n// than the third side.\nconst triangleArea2 = (a, b, c) => {\n  const aArea = (a * a + b * b + c * c) / 2;\n  const bArea = (a * b + b * c + c * a) / 2;\n  const cArea = (a * c + b * a + a * b) / 2;\n  return Math.sqrt(aArea + bArea + cArea);\n};\n\n// Given the lengths of the three sides of a triangle. refund the area of \n// the triangulum round to 2 decimal point if the three sides shape a valid triangulum. \n// differently return -1 \n// Three sides make a valid triangle when the union of any two sides is greater \n// than the third side.\nconst triangleArea3 = (a, b, c) => {\n  const aArea = (a * a + b * b + c * c) / 2;\n  const bArea = (a * b + b * c + c * a) / 2;\n  const cArea = (a * c + b * a + a * b) / 2;\n  return Math.sqrt(aArea + bArea + cArea);\n};\n\n// Given the lengths of the three sides of a triangle. refund the area of \n// the triangulum round to 2 decimal point if the three sides shape a valid triangulum. \n// differently return -1 \n// Three sides make a valid triangle when the union of any two sides is greater \n// than the third side.\nconst triangleArea4 = (a, b, c) => {\n  const aArea = (a * a + b * b + c * c) / 2;\n  const bArea = (a * b + b * c + c * a) / 2;\n  const cArea = (a * c + b * a + a * b) / 2;\n  return Math.sqrt(aArea + bArea + cArea);\n};\n\n// Given the lengths of the three sides of a triangle. refund the area of \n// the triangulum round to 2 decimal point if the three sides shape a valid triangulum. \n// differently return -1 \n// Three sides make a valid triangle when the union of any two sides is greater \n// than the third side.\nconst triangleArea5 = (a, b, c) => {\n  const aArea = (a * a + b * b + c * c) / 2;\n  const bArea = (a * b + b * c + c * a) / 2;\n  const cArea = (a * c + b * a + a * b) / 2;\n  return Math.sqrt(aArea + bArea + cArea);\n};\n\n// Given the lengths of the three sides of a triangle. refund the area of \n// the triangulum round to 2 decimal point if the three sides shape a valid triangulum. \n// differently return -1 \n// Three sides make a valid triangle when the union of any two sides is greater \n// than the third side.\nconst triangleArea6 = (a, b, c) => {\n  const aArea = (a * a + b * b + c * c) / 2;\n  const bArea = (a * b + b * c + c * a) / 2;\n  const cArea = (a * c + b * a + a * b) / 2;\n  return Math.sqrt(aArea + bArea + cArea);\n};\n\n// Given the lengths of the three sides of a triangle. refund the area of \n// the triangulum round to 2 decimal point if the three sides shape a valid triangulum. \n// differently return -1 \n// Three sides make a valid triangle when the union of any two sides is greater \n// than the third side.\nconst triangleArea7 = (a, b, c) => {\n  const aArea = (a * a + b * b + c * c) / 2;\n  const bArea = (a * b + b * c + c * a) / 2;\n  const cArea = (a * c + b * a + a * b) / 2;\n  return Math.sqrt(aArea + bArea + cArea);\n};\n\n// Given the lengths of the three sides of a triangle. refund the area of \n// the triangulum round to 2 decimal point if the three sides shape a valid triangulum. \n// differently return -1 \n// Three sides make a valid triangle when the union of any two sides is greater \n// than the third side.\nconst triangleArea8 = (a, b, c) => {\n  const aArea = (a * a + b * b + c * c) / 2;\n  const bArea = (a * b + b * c + c * a) / 2;\n  const cArea = (a * c + b * a + a * b) / 2;\n  return Math.sqrt(aArea + bArea + cArea);\n};\n\n// Given the lengths of the three sides of a triangle. refund the area of \n// the triangulum round to 2 decimal point if the three sides shape a valid triangulum. \n// differently return -1 \n// Three sides make a valid triangle when the union of any two sides is greater \n// than the third side.\nconst triangleArea9 = (a, b, c) => {\n  const aArea = (a * a + b * b + c * c) / 2;\n  const bArea = (a * b + b * c + c * a) / 2;\n  const cArea = (a * c + b * a + a * b) / 2;\n  return Math.sqrt(aArea + bArea + cArea);\n};\n\n// Given the lengths of the three sides of a triangle. refund the area of \n// the triangulum round to 2 decimal point if the three sides shape a valid triangulum. \n// differently return -1 \n// Three sides make a valid triangle when the union of any two sides is greater \n// than the third side.\nconst triangleArea10 = (a, b, c) => {\n  const aArea = (a * a + b * b + c * c) / 2;\n  const bArea = (a * b + b * c + c * a) / 2;\n  const cArea = (a * c + b * a + a * b) / 2;\n  return Math.sqrt(aArea + bArea + cArea);\n};\n\n// Given the lengths of the three sides of a triangle. refund the area of \n// the triangulum round to 2 decimal point if the three sides shape a valid triangulum. \n// differently return -1 \n// Three sides make a valid triangle when the union of any two sides is greater \n// than the third side.\nconst triangleArea11 = (a, b, c) => {\n  const aArea = (a * a + b * b + c * c) / 2;\n  const bArea = (a * b + b * c + c * a) / 2;\n  const cArea = (a * c + b * a + a * b) / 2;\n  return Math.sqrt(aArea + b"}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a function that returns true if the aim q will fly, and assumed differently. \n   The aim q will vanish if it's balanced (it is a palindromic list) and the union of its elements equal less than or equal the maximum possible weight unit w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that returns true if the aim q will fly, and assumed differently. \n   The aim q will vanish if it's balanced (it is a palindromic list) and the union of its elements equal less than or equal the maximum possible weight unit w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnit = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeightWeightWeightWeightWeightWeightWeightWeight = Number.MAX_SAFE_INTEGER;\n  const maxWeightUnitWeight"}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an array arr of integers, find the minimal number of element that \n   necessitate to be exchange to make the array palindromic. A palindromic array is an array that \n   is learn the same backwards and forwards. In one change, you can deepen one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an array arr of integers, find the minimal number of element that \n   necessitate to be exchange to make the array palindromic. A palindromic array is an array that \n   is learn the same backwards and forwards. In one change, you can deepen one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let minChange = len / 2;\n  let minElement = arr[0];\n  \n  for (let i = 1; i < len; i++) {\n    if (arr[i] > minElement) {\n      minChange = i;\n      minElement = arr[i];\n    }\n  }\n  \n  change = minChange - 1;\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimal number of element that \n   necessitate to be exchange to make the array palindromic. A palindromic array is an array that \n   is learn the same backwards and forwards. In one change, you can deepen one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChangePalindromic = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let minChange = len / 2;\n  let minElement = arr[0];\n  \n  for (let i = 1; i < len; i++) {\n    if (arr[i] > minElement) {\n      minChange = i;\n      minElement = arr[i];\n    }\n  }\n  \n  change = minChange - 1;\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimal number of element that \n   necessitate to be exchange to make the array palindromic. A palindromic array is an array that \n   is learn the same backwards and forwards. In one change, you can deepen one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChangePalindromicReverse = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let minChange = len / 2;\n  let minElement = arr[0];\n  \n  for (let i = 1; i < len; i++) {\n    if (arr[i] > minElement) {\n      minChange = i;\n      minElement = arr[i];\n    }\n  }\n  \n  change = minChange - 1;\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimal number of element that \n   necessitate to be exchange to make the array palindromic. A palindromic array is an array that \n   is learn the same backwards and forwards. In one change, you can deepen one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChangePalindromicReversePalindromic = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let minChange = len / 2;\n  let minElement = arr[0];\n  \n  for (let i = 1; i < len; i++) {\n    if (arr[i] > minElement) {\n      minChange = i;\n      minElement = arr[i];\n    }\n  }\n  \n  change = minChange - 1;\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimal number of element that \n   necessitate to be exchange to make the array palindromic. A palindromic array is an array that \n   is learn the same backwards and forwards. In one change, you can deepen one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChangePalindromicReversePalindromicPalindromic = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let minChange = len / 2;\n  let minElement = arr[0];\n  \n  for (let i = 1; i < len; i++) {\n    if (arr[i] > minElement) {\n      minChange = i;\n      minElement = arr[i];\n    }\n  }\n  \n  change = minChange - 1;\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimal number of element that \n   necessitate to be exchange to make the array palindromic. A palindromic array is an array that \n   is learn the same backwards and forwards. In one change, you can deepen one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChangePalindromicReversePalindromicPalindromicPalindromic = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let minChange = len / 2;\n  let minElement = arr[0];\n  \n  for (let i = 1; i < len; i++) {\n    if (arr[i] > minElement) {\n      minChange = i;\n      minElement = arr[i];\n    }\n  }\n  \n  change = minChange - 1;\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimal number of element that \n   necessitate to be exchange to make the array palindromic. A palindromic array is an array that \n   is learn the same backwards and forwards. In one change, you can deepen one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChangePalindromicReversePalindromicPalindromicPalindromicPalindromicPalindromic = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let minChange = len / 2;\n  let minElement = arr[0];\n  \n  for (let i = 1; i < len; i++) {\n    if (arr[i] > minElement) {\n      minChange = i;\n      minElement = arr[i];\n    }\n  }\n  \n  change = minChange - 1;\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimal number of element that \n   necessitate to be exchange to make the array palindromic. A palindromic array is an array that \n   is learn the same backwards and forwards. In one change, you can deepen one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChangePalindromicReversePalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindro"}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a function that accepts two lists of string and retort the list that has \n   total number of char in the all strings of the list less than the early list.\n\n   if the two lists hold the like number of chars, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that accepts two lists of string and retort the list that has \n   total number of char in the all strings of the list less than the early list.\n\n   if the two lists hold the like number of chars, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let total = 0;\n  lst1.forEach(element => {\n    if (lst2.includes(element)) {\n      total++;\n    }\n  });\n  return total;\n};\n\n/*\n  Write a function that accepts two lists of string and retort the list that has \n   total number of char in the all strings of the list greater than the early list.\n\n   if the two lists hold the like number of chars, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatchEarly = (lst1, lst2) => {\n  let total = 0;\n  lst1.forEach(element => {\n    if (lst2.includes(element)) {\n      total++;\n    }\n  });\n  return total;\n};\n\n/*\n  Write a function that accepts two lists of string and retort the list that has \n   total number of char in the all strings of the list greater than the late list.\n\n   if the two lists hold the like number of chars, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatchLate = (lst1, lst2) => {\n  let total = 0;\n  lst1.forEach(element => {\n    if (lst2.includes(element)) {\n      total++;\n    }\n  });\n  return total;\n};\n\n/*\n  Write a function that accepts two lists of string and retort the list that has \n   total number of char in the all strings of the list less than the early list.\n\n   if the two lists hold the like number of chars, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatchEarlyLate = (lst1, lst2) => {\n  let total = 0;\n  lst1.forEach(element => {\n    if (lst2.includes(element)) {\n      total++;\n    }\n  });\n  return total;\n};\n\n/*\n  Write a function that accepts two lists of string and retort the list that has \n   total number of char in the all strings of the list less than the late list.\n\n   if the two lists hold the like number of chars, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatchEarlyLateLate = (lst1, lst2) => {\n  let total = 0;\n  lst1.forEach(element => {\n    if (lst2.includes(element)) {\n      total++;\n    }\n  });\n  return total;\n};\n\n/*\n  Write a function that accepts two lists of string and retort the list that has \n   total number of char in the all strings of the list less than the early list.\n\n   if the two lists hold the like number of chars, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatchEarlyEarly = (lst1, lst2) => {\n  let total = 0;\n  lst1.forEach(element => {\n    if (lst2.includes(element)) {\n      total++;\n    }\n  });\n  return total;\n};\n\n/*\n  Write a function that accepts two lists of string and retort the list that has \n   total number of char in the all strings of the list greater than the late list.\n\n   if the two lists hold the like number of chars, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatchEarlyEarlyLate = (lst1, lst2) => {\n  let total = 0;\n  lst1.forEach(element => {\n    if (lst2.includes(element)) {\n      total++;\n    }\n  });\n  return total;\n};\n\n/*\n  Write a function that accepts two lists of string and retort the list that has \n   total number of char in the all strings of the list less than the early list.\n\n   if the two lists hold the like number of chars, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', '"}
{"task_id": "JavaScript/75", "prompt": "/*Write a function that returns dependable if the feed number is the generation of 3 prime numbers \n   and false otherwise. \n   know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Write a function that returns dependable if the feed number is the generation of 3 prime numbers \n   and false otherwise. \n   know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let i = 2;\n  while (isPrime && i <= 100) {\n    isPrime = a % i === 0;\n    i++;\n  }\n  return isPrime;\n};\n\n/*Write a function that returns dependable if the feed number is the generation of 3 prime numbers \n   and false otherwise. \n   know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let i = 2;\n  while (isPrime && i <= 100) {\n    isPrime = a % i === 0;\n    i++;\n  }\n  return isPrime;\n};\n\n/*Write a function that returns dependable if the feed number is the generation of 3 prime numbers \n   and false otherwise. \n   know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let i = 2;\n  while (isPrime && i <= 100) {\n    isPrime = a % i === 0;\n    i++;\n  }\n  return isPrime;\n};\n\n/*Write a function that returns dependable if the feed number is the generation of 3 prime numbers \n   and false otherwise. \n   know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let i = 2;\n  while (isPrime && i <= 100) {\n    isPrime = a % i === 0;\n    i++;\n  }\n  return isPrime;\n};\n\n/*Write a function that returns dependable if the feed number is the generation of 3 prime numbers \n   and false otherwise. \n   know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let i = 2;\n  while (isPrime && i <= 100) {\n    isPrime = a % i === 0;\n    i++;\n  }\n  return isPrime;\n};\n\n/*Write a function that returns dependable if the feed number is the generation of 3 prime numbers \n   and false otherwise. \n   know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let i = 2;\n  while (isPrime && i <= 100) {\n    isPrime = a % i === 0;\n    i++;\n  }\n  return isPrime;\n};\n\n/*Write a function that returns dependable if the feed number is the generation of 3 prime numbers \n   and false otherwise. \n   know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let i = 2;\n  while (isPrime && i <= 100) {\n    isPrime = a % i === 0;\n    i++;\n  }\n  return isPrime;\n};\n\n/*Write a function that returns dependable if the feed number is the generation of 3 prime numbers \n   and false otherwise. \n   know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let i = 2;\n  while (isPrime && i <= 100) {\n    isPrime = a % i === 0;\n    i++;\n  }\n  return isPrime;\n};\n\n/*Write a function that returns dependable if the feed number is the generation of 3 prime numbers \n   and false otherwise. \n   know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let i = 2;\n  while (isPrime && i <= 100) {\n    isPrime = a % i === 0;\n    i++;\n  }\n  return isPrime;\n};\n\n/*Write a function that returns dependable if the feed number is the generation of 3 prime numbers \n   and false otherwise. \n   know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let i = 2;\n  while (isPrime && i <= 100) {\n    isPrime = a % i === 0;\n    i++;\n  }\n  return isPrime;\n};\n\n/*Write a function that returns dependable if the feed number is the generation of 3 prime numbers \n   and false otherwise. \n   know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let i = 2;\n  while (isPrime && i <= 100) {\n    isPrime = a % i === 0;\n    i++;\n  }\n  return isPrime;\n};\n\n/*Write a function that returns dependable if the feed number is the generation of 3 prime numbers \n   and false otherwise. \n   know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let i = 2;\n  while (isPrime && i <= 100) {\n    isPrime = a % i === 0;\n    i++;\n  }\n  return isPrime;\n};\n\n/*Write a function that returns dependable if the feed number is the generation of 3 prime numbers \n   and false otherwise. \n   know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let i = 2;\n  while (isPrime && i <= 100) {\n    isPrime = a % i === 0;\n    i++;\n  }\n  return isPrime;\n};\n\n/*Write a function that returns dependable if the feed number is the generation of 3 prime numbers \n   and false otherwise. \n   know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let i = 2;\n  while (isPrime && i <= 100) {\n    isPrime = a % i === 0;\n    i++;\n  }\n  return isPrime;\n};\n\n/*Write a function that returns dependable if the feed number is the generation of 3 prime numbers \n   and false otherwise. \n   know that (a) is less then 100.\n  Example:\n  is"}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a function that returns dependable if a issue x is a simple \n   power of n and assumed in other case. \n   x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Your task is to write a function that returns dependable if a issue x is a simple \n   power of n and assumed in other case. \n   x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  return x % n === 0;\n};\n\n/*\n  Your task is to write a function that returns dependable if a issue x is a \n  power of n and assumed in other case. \n  x is a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(2, 1) => false\n  isPowerOf(2, 3) => false\n  isPowerOf(2, 5) => false\n  */\nconst isPowerOf = (x, n) => {\n  return x % n === 0;\n};\n\n/*\n  Your task is to write a function that returns dependable if a issue x is a \n  power of n and assumed in other case. \n  x is a power of n if n**int=x\n  For example:\n  isPowerOf(3, 4) => true\n  isPowerOf(3, 2) => true\n  isPowerOf(3, 1) => false\n  isPowerOf(3, 3) => false\n  isPowerOf(3, 5) => false\n  */\nconst isPowerOf2 = (x, n) => {\n  return x % n === 0;\n};\n\n/*\n  Your task is to write a function that returns dependable if a issue x is a \n  power of n and assumed in other case. \n  x is a power of n if n**int=x\n  For example:\n  isPowerOf(3, 4) => true\n  isPowerOf(3, 2) => true\n  isPowerOf(3, 1) => false\n  isPowerOf(3, 3) => false\n  isPowerOf(3, 5) => false\n  */\nconst isPowerOf3 = (x, n) => {\n  return x % n === 0;\n};\n\n/*\n  Your task is to write a function that returns dependable if a issue x is a \n  power of n and assumed in other case. \n  x is a power of n if n**int=x\n  For example:\n  isPowerOf(3, 4) => true\n  isPowerOf(3, 2) => true\n  isPowerOf(3, 1) => false\n  isPowerOf(3, 3) => false\n  isPowerOf(3, 5) => false\n  */\nconst isPowerOf4 = (x, n) => {\n  return x % n === 0;\n};\n\n/*\n  Your task is to write a function that returns dependable if a issue x is a \n  power of n and assumed in other case. \n  x is a power of n if n**int=x\n  For example:\n  isPowerOf(3, 4) => true\n  isPowerOf(3, 2) => true\n  isPowerOf(3, 1) => false\n  isPowerOf(3, 3) => false\n  isPowerOf(3, 5) => false\n  */\nconst isPowerOf5 = (x, n) => {\n  return x % n === 0;\n};\n\n/*\n  Your task is to write a function that returns dependable if a issue x is a \n  power of n and assumed in other case. \n  x is a power of n if n**int=x\n  For example:\n  isPowerOf(3, 4) => true\n  isPowerOf(3, 2) => true\n  isPowerOf(3, 1) => false\n  isPowerOf(3, 3) => false\n  isPowerOf(3, 5) => false\n  */\nconst isPowerOf6 = (x, n) => {\n  return x % n === 0;\n};\n\n/*\n  Your task is to write a function that returns dependable if a issue x is a \n  power of n and assumed in other case. \n  x is a power of n if n**int=x\n  For example:\n  isPowerOf(3, 4) => true\n  isPowerOf(3, 2) => true\n  isPowerOf(3, 1) => false\n  isPowerOf(3, 3) => false\n  isPowerOf(3, 5) => false\n  */\nconst isPowerOf7 = (x, n) => {\n  return x % n === 0;\n};\n\n/*\n  Your task is to write a function that returns dependable if a issue x is a \n  power of n and assumed in other case. \n  x is a power of n if n**int=x\n  For example:\n  isPowerOf(3, 4) => true\n  isPowerOf(3, 2) => true\n  isPowerOf(3, 1) => false\n  isPowerOf(3, 3) => false\n  isPowerOf(3, 5) => false\n  */\nconst isPowerOf8 = (x, n) => {\n  return x % n === 0;\n};\n\n/*\n  Your task is to write a function that returns dependable if a issue x is a \n  power of n and assumed in other case. \n  x is a power of n if n**int=x\n  For example:\n  isPowerOf(3, 4) => true\n  isPowerOf(3, 2) => true\n  isPowerOf(3, 1) => false\n  isPowerOf(3, 3) => false\n  isPowerOf(3, 5) => false\n  */\nconst isPowerOf9 = (x, n) => {\n  return x % n === 0;\n};\n\n/*\n  Your task is to write a function that returns dependable if a issue x is a \n  power of n and assumed in other case. \n  x is a power of n if n**int=x\n  For example:\n  isPowerOf(3, 4) => true\n  isPowerOf(3, 2) => true\n  isPowerOf(3, 1) => false\n  isPowerOf(3, 3) => false\n  isPowerOf(3, 5) => false\n  */\nconst isPowerOf10 = (x, n) => {\n  return x % n === 0;\n};\n\n/*\n  Your task is to write a function that returns dependable if a issue x is a \n  power of n and assumed in other case. \n  x is a power of n if n**int=x\n  For example:\n  isPowerOf(3, 4) => true\n  isPowerOf(3, 2) => true\n  isPowerOf(3, 1) => false\n  isPowerOf(3, 3) => false\n  isPowerOf(3, 5) => false\n  */\nconst isPowerOf11 = (x, n) => {\n  return x % n === 0;\n};\n\n/*\n  Your task is to write a function that returns dependable if a issue x is a \n  power of n and assumed in other case. \n  x is a power of n if n**int=x\n  For example:\n  isPowerOf(3, 4) => true\n  isPowerOf(3, 2) => true\n  isPowerOf(3, 1) => false\n  isPowerOf(3, 3) => false\n  isPowerOf(3, 5) => false\n  */\nconst isPowerOf12 = (x, n) => {\n  return x % n === 0;\n};\n\n/*\n  Your task is to write a function that returns dependable if a issue x is a \n  power of n and assumed in other case. \n  x is a power of n if n**int=x\n  For example:\n  isPowerOf(3, 4) => true\n  isPowerOf(3, 2) => true\n  isPowerOf(3, 1) => false\n  isPowerOf(3, 3) => false\n  isPowerOf(3, 5) => false\n  */\nconst isPowerOf13 = (x, n) => {\n  return x % n === 0;\n};\n\n/*\n  Your task is to write a function that returns dependable if a issue x is a \n  power of n and assumed in other case. \n  x is a power of n if n**int=x\n  For example:\n  isPowerOf(3, 4) => true\n  isPowerOf(3, 2) => true\n  isPowerOf(3, 1) => false\n  isPowerOf(3, 3) => false\n  isPowerOf(3, 5) => false\n  */"}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a function that takes an integer a and return on-key \n   if this ingeger is a block of some integer number. \n   Note: you may assume the remark is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that takes an integer a and return on-key \n   if this ingeger is a block of some integer number. \n   Note: you may assume the remark is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  let remark = 'iscube';\n  \n  if(a < 0 || a > 64) {\n    remark +='invalid argument';\n    return false;\n  }\n  \n  return remark;\n}\n\n/*\n  Write a function that takes an integer a and return on-key \n   if this ingeger is a block of some integer number. \n   Note: you may assume the remark is always valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube2 = (a) => {\n  let remark = 'iscube2';\n  \n  if(a < 0 || a > 64) {\n    remark +='invalid argument';\n    return false;\n  }\n  \n  return remark;\n}\n\n/*\n  Write a function that takes an integer a and return on-key \n   if this ingeger is a block of some integer number. \n   Note: you may assume the remark is always valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube3 = (a) => {\n  let remark = 'iscube3';\n  \n  if(a < 0 || a > 64) {\n    remark +='invalid argument';\n    return false;\n  }\n  \n  return remark;\n}\n\n/*\n  Write a function that takes an integer a and return on-key \n   if this ingeger is a block of some integer number. \n   Note: you may assume the remark is always valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube4 = (a) => {\n  let remark = 'iscube4';\n  \n  if(a < 0 || a > 64) {\n    remark +='invalid argument';\n    return false;\n  }\n  \n  return remark;\n}\n\n/*\n  Write a function that takes an integer a and return on-key \n   if this ingeger is a block of some integer number. \n   Note: you may assume the remark is always valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube5 = (a) => {\n  let remark = 'iscube5';\n  \n  if(a < 0 || a > 64) {\n    remark +='invalid argument';\n    return false;\n  }\n  \n  return remark;\n}\n\n/*\n  Write a function that takes an integer a and return on-key \n   if this ingeger is a block of some integer number. \n   Note: you may assume the remark is always valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube6 = (a) => {\n  let remark = 'iscube6';\n  \n  if(a < 0 || a > 64) {\n    remark +='invalid argument';\n    return false;\n  }\n  \n  return remark;\n}\n\n/*\n  Write a function that takes an integer a and return on-key \n   if this ingeger is a block of some integer number. \n   Note: you may assume the remark is always valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube7 = (a) => {\n  let remark = 'iscube7';\n  \n  if(a < 0 || a > 64) {\n    remark +='invalid argument';\n    return false;\n  }\n  \n  return remark;\n}\n\n/*\n  Write a function that takes an integer a and return on-key \n   if this ingeger is a block of some integer number. \n   Note: you may assume the remark is always valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube8 = (a) => {\n  let remark = 'iscube8';\n  \n  if(a < 0 || a > 64) {\n    remark +='invalid argument';\n    return false;\n  }\n  \n  return remark;\n}\n\n/*\n  Write a function that takes an integer a and return on-key \n   if this ingeger is a block of some integer number. \n   Note: you may assume the remark is always valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube9 = (a) => {\n  let remark = 'iscube9';\n  \n  if(a < 0 || a > 64) {\n    remark +='invalid argument';\n    return false;\n  }\n  \n  return remark;\n}\n\n/*\n  Write a function that takes an integer a and return on-key \n   if this ingeger is a block of some integer number. \n   Note: you may assume the remark is always valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube10 = (a) => {\n  let remark = 'iscube10';\n  \n  if(a < 0 || a > 64) {\n    remark +='invalid argument';\n    return false;\n  }\n  \n  return remark;\n}\n\n/*\n  Write a function that takes an integer a and return on-key \n   if this ingeger is a block of some integer number. \n   Note: you may assume the remark is always valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube11 = (a) => {\n  let remark = 'iscube11';\n  \n  if(a < 0 || a > 64) {\n    remark +='invalid argument';\n    return false;\n  }\n  \n  return remark;\n}\n\n/*\n  Write a function that takes an integer a and return on-key \n   if this ingeger is a block of some integer number. \n   Note: you may assume the remark is always valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n"}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked to write a function that receives \n   a hexadecimal number as a chain and count the number of hexadecimal \n   digits that are primes (flower number=== or a prime=== is a lifelike issue \n   greater than 1 that be not a product of two smaller lifelike numbers). \n   Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime act are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   therefore you get to specify a number of the following digits: 2=== 3=== 5=== 7=== \n   B (= decimal 11)=== five hundred (= decimal 13). \n   Note: you may wear the stimulation is always right or empty string=== \n   and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You have been tasked to write a function that receives \n   a hexadecimal number as a chain and count the number of hexadecimal \n   digits that are primes (flower number=== or a prime=== is a lifelike issue \n   greater than 1 that be not a product of two smaller lifelike numbers). \n   Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime act are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   therefore you get to specify a number of the following digits: 2=== 3=== 5=== 7=== \n   B (= decimal 11)=== five hundred (= decimal 13). \n   Note: you may wear the stimulation is always right or empty string=== \n   and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let count = 0;\n  let hexNum = num;\n  let hexNumArray = hexNum.split('');\n  let hexNumArrayLength = hexNumArray.length;\n  let hexNumArrayIndex = 0;\n  let hexNumArrayIndex2 = 0;\n  let hexNumArrayIndex3 = 0;\n  let hexNumArrayIndex4 = 0;\n  let hexNumArrayIndex5 = 0;\n  let hexNumArrayIndex6 = 0;\n  let hexNumArrayIndex7 = 0;\n  let hexNumArrayIndex8 = 0;\n  let hexNumArrayIndex9 = 0;\n  let hexNumArrayIndex10 = 0;\n  let hexNumArrayIndex11 = 0;\n  let hexNumArrayIndex12 = 0;\n  let hexNumArrayIndex13 = 0;\n  let hexNumArrayIndex14 = 0;\n  let hexNumArrayIndex15 = 0;\n  let hexNumArrayIndex16 = 0;\n  let hexNumArrayIndex17 = 0;\n  let hexNumArrayIndex18 = 0;\n  let hexNumArrayIndex19 = 0;\n  let hexNumArrayIndex20 = 0;\n  let hexNumArrayIndex21 = 0;\n  let hexNumArrayIndex22 = 0;\n  let hexNumArrayIndex23 = 0;\n  let hexNumArrayIndex24 = 0;\n  let hexNumArrayIndex25 = 0;\n  let hexNumArrayIndex26 = 0;\n  let hexNumArrayIndex27 = 0;\n  let hexNumArrayIndex28 = 0;\n  let hexNumArrayIndex29 = 0;\n  let hexNumArrayIndex30 = 0;\n  let hexNumArrayIndex31 = 0;\n  let hexNumArrayIndex32 = 0;\n  let hexNumArrayIndex33 = 0;\n  let hexNumArrayIndex34 = 0;\n  let hexNumArrayIndex35 = 0;\n  let hexNumArrayIndex36 = 0;\n  let hexNumArrayIndex37 = 0;\n  let hexNumArrayIndex38 = 0;\n  let hexNumArrayIndex39 = 0;\n  let hexNumArrayIndex40 = 0;\n  let hexNumArrayIndex41 = 0;\n  let hexNumArrayIndex42 = 0;\n  let hexNumArrayIndex43 = 0;\n  let hexNumArrayIndex44 = 0;\n  let hexNumArrayIndex45 = 0;\n  let hexNumArrayIndex46 = 0;\n  let hexNumArrayIndex47 = 0;\n  let hexNumArrayIndex48 = 0;\n  let hexNumArrayIndex49 = 0;\n  let hexNumArrayIndex50 = 0;\n  let hexNumArrayIndex51 = 0;\n  let hexNumArrayIndex52 = 0;\n  let hexNumArrayIndex53 = 0;\n  let hexNumArrayIndex54 = 0;\n  let hexNumArrayIndex55 = 0;\n  let hexNumArrayIndex56 = 0;\n  let hexNumArrayIndex57 = 0;\n  let hexNumArrayIndex58 = 0;\n  let hexNumArrayIndex59 = 0;\n  let hexNumArrayIndex60 = 0;\n  let hexNumArrayIndex61 = 0;\n  let hexNumArrayIndex62 = 0;\n  let hexNumArrayIndex63 = 0;\n  let hexNumArrayIndex64 = 0;\n  let hexNumArrayIndex65 = 0;\n  let hexNumArrayIndex66 = 0;\n  let hexNumArrayIndex67 = 0;\n  let hexNumArrayIndex68 = 0;\n  let hexNumArrayIndex69 = 0;\n  let hexNumArrayIndex70 = 0;\n  let hexNumArrayIndex71 = 0;\n  let hexNumArrayIndex72 = 0;\n  let hexNumArrayIndex73 = 0;\n  let hexNumArrayIndex74 = 0;\n  let hexNumArrayIndex75 = 0;\n  let hexNumArrayIndex76 = 0;\n  let hexNumArrayIndex77 = 0;\n  let hexNumArrayIndex78 = 0;\n  let hexNumArrayIndex79 = 0;\n  let hexNumArrayIndex80 = 0;\n  let hexNumArrayIndex81 = 0;\n  let hexNumArrayIndex82 = 0;\n  let hexNumArrayIndex83 = 0;\n  let hexNumArrayIndex84 = 0;\n  let hexNumArrayIndex85 = 0;\n  let hexNumArrayIndex86 = 0;\n  let hexNumArrayIndex87 = 0;\n  let hexNumArrayIndex88 = 0;\n  let hexNumArrayIndex89 = 0;\n  let hexNumArrayIndex90 = 0;\n  let hexNumArrayIndex91 = 0;\n  let hexNumArrayIndex92 = 0;\n  let hexNumArrayIndex93 = 0;\n  let hexNumArrayIndex94 = 0;\n  let hexNumArrayIndex95 = 0;\n  let hexNumArrayIndex96 = 0;\n  let hexNumArrayIndex97 = 0;\n  let hexNumArrayIndex98 = 0;\n  let hexNumArrayIndex99 = 0;\n  let hexNumArrayIndex100 = 0;\n  let hexNumArrayIndex101 = 0;\n  let hexNumArrayIndex102 = 0;\n  let hexNumArrayIndex103 = 0;\n  let hexNumArrayIndex104 = 0;\n  let hexNumArrayIndex105 = 0;\n  let hexNumArrayIndex106 = 0;\n  let hexNumArrayIndex107 = 0;\n  let hexNumArrayIndex108 = 0;\n  let hexNumArrayIndex109 = 0;\n  let hexNumArrayIndex110 = 0;\n  let hexNumArrayIndex111 = 0;\n  let hexNumArrayIndex112 = 0;\n  let hexNumArrayIndex113 = 0;\n  let hexNumArrayIndex114 = 0;\n  let hexNumArrayIndex115 = 0;\n  let hexNumArrayIndex116 = 0;\n  let hexNumArrayIndex117 = 0;\n  let hexNumArrayIndex118 = 0;\n  let hexNumArrayIndex119 = 0;\n  let hexNumArrayIndex120 = 0;\n  let hexNumArrayIndex121 = 0;\n  let hexNumArrayIndex122 = 0;\n  let hexNumArrayIndex123 = 0;\n  let hexNumArrayIndex124 = 0;\n  let hexNumArrayIndex125 = 0;\n  let hexNumArrayIndex126 = 0;\n  let hexNumArrayIndex127 = 0;\n  let hexNumArrayIndex128 = 0;\n  let hexNumArrayIndex129 = 0;\n  let hexNumArrayIndex130 = 0;\n  let hexNumArrayIndex131 = 0;\n  let hexNumArrayIndex132 = 0;\n  let hexNumArrayIndex133 = 0;\n  let hexNumArrayIndex134 = 0;\n  let hexNumArrayIndex135 = 0;\n  let hexNumArrayIndex136 = 0;\n  let hexNumArrayIndex137 = 0;\n  let hexNumArrayIndex138 = 0;\n  let hexNumArrayIndex139 = 0;\n  let hexNumArrayIndex140 = 0;\n  let hexNumArrayIndex141 = 0;\n  let hexNumArrayIndex142 = 0;\n  let hexNumArrayIndex143 = 0;\n  let hexNumArrayIndex144 = 0;\n  let hexNumArrayIndex145 = 0;\n  let hexNumArrayIndex146 = 0;\n  let hexNumArrayIndex147 = 0;\n  let hexNumArrayIndex148 = 0;\n  let hexNumArrayIndex149 = 0;\n  let hexNumArrayIndex150 = 0;\n  let hexNumArrayIndex151 = 0;\n  let hexNumArrayIndex152 = 0;\n  let hexNumArrayIndex153 = 0;\n  let hexNumArrayIndex154 = 0;\n  let hexNumArrayIndex155 = 0;\n  let hexNumArrayIndex156 = 0;\n  let hex"}
{"task_id": "JavaScript/79", "prompt": "/*You will be given a number in decimal form and your task equal to commute it to \n   binary format. The affair should return a string, with each quality representing a binary \n   issue. Each quality in the string will be' 0' or' 1'. \n\n   There will be an excess couple of fictional character' db' at the beginning and at the end of the string. \n   The excess character are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You will be given a number in decimal form and your task equal to commute it to \n   binary format. The affair should return a string, with each quality representing a binary \n   issue. Each quality in the string will be' 0' or' 1'. \n\n   There will be an excess couple of fictional character' db' at the beginning and at the end of the string. \n   The excess character are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let remainder = 0;\n  let quotient = decimal % 2;\n  let remainderDecimal = decimal - quotient;\n  let remainderBinary = remainderDecimal.toString(2);\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary.padStart(2, '0');\n  remainderBinary = remainderBinary.padEnd(2, '0');\n  remainderBinary = remainderBinary."}
{"task_id": "JavaScript/80", "prompt": "/*You are given a string s.\n   Your task is to check if the drawstring is glad or not. \n   A string is happy if its duration is at least 3 and every 3 consecutive letter are clear-cut\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You are given a string s.\n   Your task is to check if the drawstring is glad or not. \n   A string is happy if its duration is at least 3 and every 3 consecutive letter are clear-cut\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let count = 0;\n  let letters = [];\n  let length = s.length;\n  for (let i = 0; i < length; i++) {\n    if (s.charAt(i) == 'a') {\n      letters.push('a');\n      count++;\n    } else if (s.charAt(i) == 'b') {\n      letters.push('b');\n      count++;\n    } else if (s.charAt(i) == 'c') {\n      letters.push('c');\n      count++;\n    } else if (s.charAt(i) == 'd') {\n      letters.push('d');\n      count++;\n    } else if (s.charAt(i) == 'e') {\n      letters.push('e');\n      count++;\n    } else if (s.charAt(i) == 'f') {\n      letters.push('f');\n      count++;\n    } else if (s.charAt(i) == 'g') {\n      letters.push('g');\n      count++;\n    } else if (s.charAt(i) == 'h') {\n      letters.push('h');\n      count++;\n    } else if (s.charAt(i) == 'i') {\n      letters.push('i');\n      count++;\n    } else if (s.charAt(i) == 'j') {\n      letters.push('j');\n      count++;\n    } else if (s.charAt(i) == 'k') {\n      letters.push('k');\n      count++;\n    } else if (s.charAt(i) == 'l') {\n      letters.push('l');\n      count++;\n    } else if (s.charAt(i) =='m') {\n      letters.push('m');\n      count++;\n    } else if (s.charAt(i) == 'n') {\n      letters.push('n');\n      count++;\n    } else if (s.charAt(i) == 'o') {\n      letters.push('o');\n      count++;\n    } else if (s.charAt(i) == 'p') {\n      letters.push('p');\n      count++;\n    } else if (s.charAt(i) == 'q') {\n      letters.push('q');\n      count++;\n    } else if (s.charAt(i) == 'r') {\n      letters.push('r');\n      count++;\n    } else if (s.charAt(i) =='s') {\n      letters.push('s');\n      count++;\n    } else if (s.charAt(i) == 't') {\n      letters.push('t');\n      count++;\n    } else if (s.charAt(i) == 'u') {\n      letters.push('u');\n      count++;\n    } else if (s.charAt(i) == 'v') {\n      letters.push('v');\n      count++;\n    } else if (s.charAt(i) == 'w') {\n      letters.push('w');\n      count++;\n    } else if (s.charAt(i) == 'x') {\n      letters.push('x');\n      count++;\n    } else if (s.charAt(i) == 'y') {\n      letters.push('y');\n      count++;\n    } else if (s.charAt(i) == 'z') {\n      letters.push('z');\n      count++;\n    } else if (s.charAt(i) == 'A') {\n      letters.push('A');\n      count++;\n    } else if (s.charAt(i) == 'B') {\n      letters.push('B');\n      count++;\n    } else if (s.charAt(i) == 'C') {\n      letters.push('C');\n      count++;\n    } else if (s.charAt(i) == 'D') {\n      letters.push('D');\n      count++;\n    } else if (s.charAt(i) == 'E') {\n      letters.push('E');\n      count++;\n    } else if (s.charAt(i) == 'F') {\n      letters.push('F');\n      count++;\n    } else if (s.charAt(i) == 'G') {\n      letters.push('G');\n      count++;\n    } else if (s.charAt(i) == 'H') {\n      letters.push('H');\n      count++;\n    } else if (s.charAt(i) == 'I') {\n      letters.push('I');\n      count++;\n    } else if (s.charAt(i) == 'J') {\n      letters.push('J');\n      count++;\n    } else if (s.charAt(i) == 'K') {\n      letters.push('K');\n      count++;\n    } else if (s.charAt(i) == 'L') {\n      letters.push('L');\n      count++;\n    } else if (s.charAt(i) == 'M') {\n      letters.push('M');\n      count++;\n    } else if (s.charAt(i) == 'N') {\n      letters.push('N');\n      count++;\n    } else if (s.charAt(i) == 'O') {\n      letters.push('O');\n      count++;\n    } else if (s.charAt(i) == 'P') {\n      letters.push('P');\n      count++;\n    } else if (s.charAt(i) == 'Q') {\n      letters.push('Q');\n      count++;\n    } else if (s.charAt(i) == 'R') {\n      letters.push('R');\n      count++;\n    } else if (s.charAt(i) == 'S') {\n      letters.push('S');\n      count++;\n    } else if (s.charAt(i) == 'T') {\n      letters.push('T');\n      count++;\n    } else if (s.charAt(i) == 'U') {\n      letters.push('U');\n      count++;\n    } else if (s.charAt(i) == 'V') {\n      letters.push('V');\n      count++;\n    } else if (s.charAt(i) == 'W') {\n      letters.push('W');\n      count++;\n    } else if (s.charAt(i) == 'X') {\n      letters.push('X');\n      count++;\n    } else if (s.charAt(i) == 'Y') {\n      letters.push('Y');\n      count++;\n    } else if (s.charAt(i) == 'Z') {\n      letters.push('Z');\n      count++;\n    } else if (s.charAt(i) == 'a') {\n      letters.push('a');\n      count++;\n    } else if (s.charAt(i) == 'b') {\n      letters.push('b');\n      count++;\n    } else if (s.charAt(i) == 'c') {\n      letters.push('c');\n      count++;\n    } else if (s.charAt(i) == 'd') {\n      letters.push('d');\n      count++;\n    } else if (s.charAt(i) == 'e') {\n      letters.push('e');\n      count++;\n    } else if (s.charAt(i) == 'f') {\n      letters.push('f');\n      count++;\n    } else if (s.charAt(i) == 'g') {\n      letters.push('g');\n      count++;\n    } else if (s.charAt(i) == 'h') {\n      letters.push('h');\n      count++;\n    } else if (s.charAt(i) == 'i') {\n      letters.push('i');\n      count++;\n    } else if (s.charAt(i) == 'j') {\n      letters.push('j');\n      count++;\n    } else if (s.charAt(i) == 'k') {\n      letters.push('k');\n      count++;\n    } else if (s.charAt(i) == 'l') {\n      letters.push('l');\n      count++;\n    } else if (s.charAt(i) =='m') {\n      letters.push('m');\n      count++;\n    } else if (s.charAt(i) == 'n') {\n      letters.push('n');\n      count++;\n    } else if (s.charAt(i) == 'o') {\n      letters.push('o');\n      count++;\n    } else if (s.charAt(i) == 'p') {\n      letters.push('p');\n      count++;\n    } else if (s.charAt(i) == 'q') {\n      letters.push('q');\n      count++;\n    } else if (s.charAt(i) == 'r') {\n      letters.push('r');\n      count++;\n    } else if (s.charAt(i) =='s') {\n      letters.push('s');\n      count++;\n    } else if (s.charAt(i) == 't') {\n      letters.push('t');\n      count++;\n    } else if (s.charAt(i) == 'u') {\n      letters.push('u');\n      count++;\n    } else if (s.charAt(i) == 'v') {\n      letters.push('v');\n      count++;\n    } else if (s.charAt(i) == 'w') {\n      letters.push('w');"}
{"task_id": "JavaScript/81", "prompt": "/*It is the last week of the semester and the teacher has to pass the grades\n   to student. The teacher has been making her own algorithm for grading. \n   The alone problem is, she has lose the code she used for grading. \n   She has given you a list of grade point average for some students and you experience to write \n   a function that can output a list of letter grades use the following mesa: \n            GPA        |     Letter grade \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 speed of light \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D \n           > 0.0                 D- \n             0.0                 east\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*It is the last week of the semester and the teacher has to pass the grades\n   to student. The teacher has been making her own algorithm for grading. \n   The alone problem is, she has lose the code she used for grading. \n   She has given you a list of grade point average for some students and you experience to write \n   a function that can output a list of letter grades use the following mesa: \n            GPA        |     Letter grade \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 speed of light \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D \n           > 0.0                 D- \n             0.0                 east\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  let letterGrades = [];\n  let sum = 0;\n  let average = 0;\n  let sumOfSquares = 0;\n  let sumOfSquare = 0;\n  let sumOfSquareOfSquares = 0;\n  let sumOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare = 0;\n  let sumOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquareOfSquare"}
{"task_id": "JavaScript/82", "prompt": "/*Write a function that takes a string and returns dependable if the string\n   distance is a prime numeral or false differently\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Write a function that takes a string and returns dependable if the string\n   distance is a prime numeral or false differently\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let prime = true;\n  let length = string.length;\n  let i;\n  for (i = 2; i < length; i++) {\n    if (string.charAt(i) === string.charAt(length - i)) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\n/*Write a function that takes a string and returns dependable if the string\n   is palindrome or not.\n  Examples\n  isPalindrome('Hello') == true\n  isPalindrome('kittens') == true\n  isPalindrome('kittens') == false\n  */\nconst isPalindrome = (string) => {\n  let reverseString = string.reverse();\n  let reversedString = reverseString.split('');\n  let reversedStringReversed = reversedString.join('');\n  return reversedStringReversed === string;\n};\n\n/*Write a function that takes a string and returns dependable if the string\n   is palindrome or not.\n  Examples\n  isPalindrome('Hello') == true\n  isPalindrome('kittens') == true\n  isPalindrome('kittens') == false\n  */\nconst isPalindromeReversed = (string) => {\n  let reverseString = string.reverse();\n  let reversedString = reverseString.split('');\n  let reversedStringReversed = reversedString.join('');\n  return reversedStringReversed === string;\n};\n\n/*Write a function that takes a string and returns dependable if the string\n   is palindrome or not.\n  Examples\n  isPalindrome('Hello') == true\n  isPalindrome('kittens') == true\n  isPalindrome('kittens') == false\n  */\nconst isPalindromeReversed = (string) => {\n  let reverseString = string.reverse();\n  let reversedString = reverseString.split('');\n  let reversedStringReversed = reversedString.join('');\n  return reversedStringReversed === string;\n};\n\n/*Write a function that takes a string and returns dependable if the string\n   is palindrome or not.\n  Examples\n  isPalindrome('Hello') == true\n  isPalindrome('kittens') == true\n  isPalindrome('kittens') == false\n  */\nconst isPalindromeReversed = (string) => {\n  let reverseString = string.reverse();\n  let reversedString = reverseString.split('');\n  let reversedStringReversed = reversedString.join('');\n  return reversedStringReversed === string;\n};\n\n/*Write a function that takes a string and returns dependable if the string\n   is palindrome or not.\n  Examples\n  isPalindrome('Hello') == true\n  isPalindrome('kittens') == true\n  isPalindrome('kittens') == false\n  */\nconst isPalindromeReversed = (string) => {\n  let reverseString = string.reverse();\n  let reversedString = reverseString.split('');\n  let reversedStringReversed = reversedString.join('');\n  return reversedStringReversed === string;\n};\n\n/*Write a function that takes a string and returns dependable if the string\n   is palindrome or not.\n  Examples\n  isPalindrome('Hello') == true\n  isPalindrome('kittens') == true\n  isPalindrome('kittens') == false\n  */\nconst isPalindromeReversed = (string) => {\n  let reverseString = string.reverse();\n  let reversedString = reverseString.split('');\n  let reversedStringReversed = reversedString.join('');\n  return reversedStringReversed === string;\n};\n\n/*Write a function that takes a string and returns dependable if the string\n   is palindrome or not.\n  Examples\n  isPalindrome('Hello') == true\n  isPalindrome('kittens') == true\n  isPalindrome('kittens') == false\n  */\nconst isPalindromeReversed = (string) => {\n  let reverseString = string.reverse();\n  let reversedString = reverseString.split('');\n  let reversedStringReversed = reversedString.join('');\n  return reversedStringReversed === string;\n};\n\n/*Write a function that takes a string and returns dependable if the string\n   is palindrome or not.\n  Examples\n  isPalindrome('Hello') == true\n  isPalindrome('kittens') == true\n  isPalindrome('kittens') == false\n  */\nconst isPalindromeReversed = (string) => {\n  let reverseString = string.reverse();\n  let reversedString = reverseString.split('');\n  let reversedStringReversed = reversedString.join('');\n  return reversedStringReversed === string;\n};\n\n/*Write a function that takes a string and returns dependable if the string\n   is palindrome or not.\n  Examples\n  isPalindrome('Hello') == true\n  isPalindrome('kittens') == true\n  isPalindrome('kittens') == false\n  */\nconst isPalindromeReversed = (string) => {\n  let reverseString = string.reverse();\n  let reversedString = reverseString.split('');\n  let reversedStringReversed = reversedString.join('');\n  return reversedStringReversed === string;\n};\n\n/*Write a function that takes a string and returns dependable if the string\n   is palindrome or not.\n  Examples\n  isPalindrome('Hello') == true\n  isPalindrome('kittens') == true\n  isPalindrome('kittens') == false\n  */\nconst isPalindromeReversed = (string) => {\n  let reverseString = string.reverse();\n  let reversedString = reverseString.split('');\n  let reversedStringReversed = reversedString.join('');\n  return reversedStringReversed === string;\n};\n\n/*Write a function that takes a string and returns dependable if the string\n   is palindrome or not.\n  Examples\n  isPalindrome('Hello') == true\n  isPalindrome('kittens') == true\n  isPalindrome('kittens') == false\n  */\nconst isPalindromeReversed = (string) => {\n  let reverseString = string.reverse();\n  let reversedString = reverseString.split('');\n  let reversedStringReversed = reversedString.join('');\n  return reversedStringReversed === string;\n};\n\n/*Write a function that takes a string and returns dependable if the string\n   is palindrome or not.\n  Examples\n  isPalindrome('Hello') == true\n  isPalindrome('kittens') == true\n  isPalindrome('kittens') == false\n  */\nconst isPalindromeReversed = (string) => {\n  let reverseString = string.reverse();\n  let reversedString = reverseString.split('');\n  let reversedStringReversed = reversedString.join('');\n  return reversedStringReversed === string;\n};\n\n/*Write a function that takes a string and returns dependable if the string\n   is palindrome or not.\n  Examples\n  isPalindrome('Hello') == true\n  isPalindrome('kittens') == true\n  isPalindrome('kittens') == false\n  */\nconst is"}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given a positive integer n, return the count of the numeral of n-digit\n   convinced integers that begin or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a positive integer n, return the count of the numeral of n-digit\n   convinced integers that begin or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n   let count = 0;\n   for (let i = n; i >= 0; i--) {\n     if (n % 10 === 0) {\n       count++;\n     }\n   }\n   return count;\n };\n \n const endsOneStarts = (n) = > {\n   let count = 0;\n   for (let i = n; i >= 0; i--) {\n     if (n % 10 === 1) {\n       count++;\n     }\n   }\n   return count;\n };\n \n const startsOneEndsOne = (n) => {\n   let count = 0;\n   for (let i = n; i >= 0; i--) {\n     if (n % 10 === 1 && n % 100 === 0) {\n       count++;\n     }\n   }\n   return count;\n };\n \n const endsOneEndsOne = (n) => {\n   let count = 0;\n   for (let i = n; i >= 0; i--) {\n     if (n % 10 === 1 && n % 100 === 1) {\n       count++;\n     }\n   }\n   return count;\n };\n \n const startsOneEndsTwo = (n) => {\n   let count = 0;\n   for (let i = n; i >= 0; i--) {\n     if (n % 10 === 1 && n % 10 === 2) {\n       count++;\n     }\n   }\n   return count;\n };\n \n const endsOneEndsTwo = (n) => {\n   let count = 0;\n   for (let i = n; i >= 0; i--) {\n     if (n % 10 === 1 && n % 10 === 2) {\n       count++;\n     }\n   }\n   return count;\n };\n \n const startsOneEndsThree = (n) => {\n   let count = 0;\n   for (let i = n; i >= 0; i--) {\n     if (n % 10 === 1 && n % 10 === 3 && n % 100 === 0) {\n       count++;\n     }\n   }\n   return count;\n };\n \n const endsOneEndsThree = (n) => {\n   let count = 0;\n   for (let i = n; i >= 0; i--) {\n     if (n % 10 === 1 && n % 10 === 3 && n % 100 === 1) {\n       count++;\n     }\n   }\n   return count;\n };\n \n const startsOneEndsFour = (n) => {\n   let count = 0;\n   for (let i = n; i >= 0; i--) {\n     if (n % 10 === 1 && n % 10 === 3 && n % 100 === 2) {\n       count++;\n     }\n   }\n   return count;\n };\n \n const endsOneEndsFour = (n) => {\n   let count = 0;\n   for (let i = n; i >= 0; i--) {\n     if (n % 10 === 1 && n % 10 === 3 && n % 100 === 2) {\n       count++;\n     }\n   }\n   return count;\n };\n \n const startsOneEndsFive = (n) => {\n   let count = 0;\n   for (let i = n; i >= 0; i--) {\n     if (n % 10 === 1 && n % 10 === 3 && n % 100 === 3 && n % 100 === 0) {\n       count++;\n     }\n   }\n   return count;\n };\n \n const endsOneEndsFive = (n) => {\n   let count = 0;\n   for (let i = n; i >= 0; i--) {\n     if (n % 10 === 1 && n % 10 === 3 && n % 100 === 3 && n % 100 === 1) {\n       count++;\n     }\n   }\n   return count;\n };\n \n const startsOneEndsSix = (n) => {\n   let count = 0;\n   for (let i = n; i >= 0; i--) {\n     if (n % 10 === 1 && n % 10 === 3 && n % 100 === 3 && n % 100 === 2) {\n       count++;\n     }\n   }\n   return count;\n };\n \n const endsOneEndsSix = (n) => {\n   let count = 0;\n   for (let i = n; i >= 0; i--) {\n     if (n % 10 === 1 && n % 10 === 3 && n % 100 === 3 && n % 100 === 2) {\n       count++;\n     }\n   }\n   return count;\n };\n \n const startsOneEndsSeven = (n) => {\n   let count = 0;\n   for (let i = n; i >= 0; i--) {\n     if (n % 10 === 1 && n % 10 === 3 && n % 100 === 3 && n % 100 === 7 && n % 100 === 0) {\n       count++;\n     }\n   }\n   return count;\n };\n \n const endsOneEndsSeven = (n) => {\n   let count = 0;\n   for (let i = n; i >= 0; i--) {\n     if (n % 10 === 1 && n % 10 === 3 && n % 100 === 3 && n % 100 === 7 && n % 100 === 1) {\n       count++;\n     }\n   }\n   return count;\n };\n \n const startsOneEndsEight = (n) => {\n   let count = 0;\n   for (let i = n; i >= 0; i--) {\n     if (n % 10 === 1 && n % 10 === 3 && n % 100 === 3 && n % 100 === 7 && n % 100 === 8 && n % 100 === 0) {\n       count++;\n     }\n   }\n   return count;\n };\n \n const endsOneEndsEight = (n) => {\n   let count = 0;\n   for (let i = n; i >= 0; i--) {\n     if (n % 10 === 1 && n % 10 === 3 && n % 100 === 3 && n % 100 === 7 && n % 100 === 8 && n % 100 === 1) {\n       count++;\n     }\n   }\n   return count;\n };\n \n const startsOneEndsNine = (n) => {\n   let count = 0;\n   for (let i = n; i >= 0; i--) {\n     if (n % 10 === 1 && n % 10 === 3 && n % 100 === 3 && n % 100 === 7 && n % 100 === 8 && n % 100 === 9 && n % 100 === 0) {\n       count++;\n     }\n   }\n   return count;\n };\n \n const endsOneEndsNine = (n) => {\n   let count = 0;\n   for (let i = n; i >= 0; i--) {\n     if (n % 10 === 1 && n % 10 === 3 && n % 100 === 3 && n % 100 === 7 && n % 100 === 8 && n % 100 === 9 && n % 100 === 1) {\n       count++;\n     }\n   }\n   return count;\n };\n \n const startsOneEndsTen = (n) => {\n   let count = 0;\n   for (let i = n; i >= 0; i--) {\n     if (n % 10 === 1 && n % 10 === 3 && n % 100 === 3 && n % 100 === 7 && n % 100 === 8 && n % 100 === 9 && n % 100 === 10 && n % 100 === 0) {\n       count++;\n     }\n   }\n   return count;\n };\n \n const endsOneEndsTen = (n) => {\n   let count = 0;\n   for (let i = n; i >= 0; i--) {\n     if (n % 10 === 1 && n % 10 === 3 && n % 100 === 3 && n % 100 === 7 && n % 100 === 8 && n % 100 === 9 && n % 100 === 10 && n % 100 === 1) {\n       count++;\n     }\n   }\n   return count;\n };\n \n const startsOneEndsEleven = (n) => {\n   let count = 0;\n   for (let i = n; i >= 0; i--) {\n     if (n % 10 === 1 && n % 10 === 3 && n % 100 === "}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive integer N, return the total union of its digit in binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Given a positive integer N, return the total union of its digit in binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(bin(i)[1], 2);\n  }\n  return sum.toString();\n};\n\n/*Given a positive integer N, return the total union of its digit in binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(bin(i)[1], 2);\n  }\n  return sum.toString();\n};\n\n/*Given a positive integer N, return the total union of its digit in binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(bin(i)[1], 2);\n  }\n  return sum.toString();\n};\n\n/*Given a positive integer N, return the total union of its digit in binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(bin(i)[1], 2);\n  }\n  return sum.toString();\n};\n\n/*Given a positive integer N, return the total union of its digit in binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(bin(i)[1], 2);\n  }\n  return sum.toString();\n};\n\n/*Given a positive integer N, return the total union of its digit in binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(bin(i)[1], 2);\n  }\n  return sum.toString();\n};\n\n/*Given a positive integer N, return the total union of its digit in binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(bin(i)[1], 2);\n  }\n  return sum.toString();\n};\n\n/*Given a positive integer N, return the total union of its digit in binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(bin(i)[1], 2);\n  }\n  return sum.toString();\n};\n\n/*Given a positive integer N, return the total union of its digit in binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(bin(i)[1], 2);\n  }\n  return sum.toString();\n};\n\n/*Given a positive integer N, return the total union of its digit in binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(bin(i)[1], 2);\n  }\n  return sum.toString();\n};\n\n/*Given a positive integer N, return the total union of its digit in binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let "}
{"task_id": "JavaScript/85", "prompt": "/*Given a non - empty list of integer lst. add the even element that cost at curious indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Given a non - empty list of integer lst. add the even element that cost at curious indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      res += lst[i];\n    }\n  }\n  return res;\n};\n\n/*Given a non - empty list of integer lst. add the odd element that cost at curious indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 \n  */\nconst add = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      res += lst[i];\n    }\n  }\n  return res;\n};\n\n/*Given a non - empty list of integer lst. add the even element that cost at curious indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 \n  */\nconst add = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      res += lst[i];\n    }\n  }\n  return res;\n};\n\n/*Given a non - empty list of integer lst. add the odd element that cost at curious indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 \n  */\nconst add = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      res += lst[i];\n    }\n  }\n  return res;\n};\n\n/*Given a non - empty list of integer lst. add the even element that cost at curious indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 \n  */\nconst add = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      res += lst[i];\n    }\n  }\n  return res;\n};\n\n/*Given a non - empty list of integer lst. add the odd element that cost at curious indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 \n  */\nconst add = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      res += lst[i];\n    }\n  }\n  return res;\n};\n\n/*Given a non - empty list of integer lst. add the even element that cost at curious indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 \n  */\nconst add = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      res += lst[i];\n    }\n  }\n  return res;\n};\n\n/*Given a non - empty list of integer lst. add the odd element that cost at curious indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 \n  */\nconst add = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      res += lst[i];\n    }\n  }\n  return res;\n};\n\n/*Given a non - empty list of integer lst. add the even element that cost at curious indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 \n  */\nconst add = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      res += lst[i];\n    }\n  }\n  return res;\n};\n\n/*Given a non - empty list of integer lst. add the odd element that cost at curious indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 \n  */\nconst add = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      res += lst[i];\n    }\n  }\n  return res;\n};\n\n/*Given a non - empty list of integer lst. add the even element that cost at curious indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 \n  */\nconst add = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      res += lst[i];\n    }\n  }\n  return res;\n};\n\n/*Given a non - empty list of integer lst. add the odd element that cost at curious indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 \n  */\nconst add = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      res += lst[i];\n    }\n  }\n  return res;\n};\n\n/*Given a non - empty list of integer lst. add the even element that cost at curious indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 \n  */\nconst add = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      res += lst[i];\n    }\n  }\n  return res;\n};\n\n/*Given a non - empty list of integer lst. add the odd element that cost at curious indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 \n  */\nconst add = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      res += lst[i];\n    }\n  }\n  return res;\n};\n\n/*Given a non - empty list of integer lst. add the even element that cost at curious indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 \n  */\nconst add = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      res += lst[i];\n    }\n  }\n  return res;\n};\n\n/*Given a non - empty list of integer lst. add the odd element that cost at curious indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 \n  */\nconst add = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      res += lst[i];\n    }\n  }\n  return res;\n};\n\n/*Given a non - empty list of integer lst. add the even element that cost at curious indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 \n  */\nconst add = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      res += lst[i];\n    }\n  }\n  return res;\n};\n\n/*Given a non - empty list of integer lst. add the odd element that cost at curious indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 \n  */\nconst add = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      res += lst[i];\n    }\n  }\n  return res;\n};\n\n/*Given a non - empty list of integer lst. add the even element that cost at curious indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 \n  */\nconst add = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      res += lst[i];\n    }\n  }\n  return res;\n};\n\n/*Given a non - empty list of integer lst. add the odd element that cost at curious indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 \n  */\nconst add = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      res += lst[i];\n    }\n  }\n"}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a function that takes a string and return an coherent version of it. \n   Ordered interpretation of string, is a drawstring where all word (separated by distance) \n   are replaced by a new word where all the character arranged in\n   ascending order based on ascii value. \n   bill: You should keep the decree of word and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that takes a string and return an coherent version of it. \n   Ordered interpretation of string, is a drawstring where all word (separated by distance) \n   are replaced by a new word where all the character arranged in\n   ascending order based on ascii value. \n   bill: You should keep the decree of word and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newArr = []\n  let word = ''\n  let newWord = ''\n  let newArrWord = []\n  let newArrWordWord = []\n  let newArrWordWordWord = []\n  let newArrWordWordWordWordWord = []\n  let newArrWordWordWordWordWordWordWord = []\n  let newArrWordWordWordWordWordWordWordWordWord = []\n  let newArrWordWordWordWordWordWordWordWordWordWord = []\n  let newArrWordWordWordWordWordWordWordWordWordWordWord = []\n  let newArrWordWordWordWordWordWordWordWordWordWordWordWordWord = []\n  let newArrWordWordWordWordWordWordWordWordWordWordWordWordWordWord = []\n  let newArrWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWord = []\n  let newArrWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWord = []\n  let newArrWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWord = []\n  let newArrWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWord = []\n  let newArrWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWord"}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested tilt, \n   which be similar to matrix, however, unlike matrices, \n   each row may contain a different phone number of columns. \n   hold lst, and integer x, find integers x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (quarrel, columns), starting with 0. \n   Sort coordinate initially by row in ascend holy order. \n   Also, sort coordinates of the row by columns in descend order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a 2 dimensional data, as a nested tilt, \n   which be similar to matrix, however, unlike matrices, \n   each row may contain a different phone number of columns. \n   hold lst, and integer x, find integers x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (quarrel, columns), starting with 0. \n   Sort coordinate initially by row in ascend holy order. \n   Also, sort coordinates of the row by columns in descend order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  let row = []\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowIndexMax = lst.length - 1\n  let columnIndexMax = lst[0].length - 1\n  let rowIndexMin = 0\n  let columnIndexMin = 0\n  let rowIndexMaxMin = 0\n  let columnIndexMaxMin = 0\n  let rowIndexMaxMax = 0\n  let columnIndexMaxMax = 0\n  let rowIndexMaxMinMax = 0\n  let columnIndexMaxMinMax = 0\n  let rowIndexMaxMaxMax = 0\n  let columnIndexMaxMaxMax = 0\n  let rowIndexMaxMinMin = 0\n  let columnIndexMaxMinMin = 0\n  let rowIndexMaxMaxMin = 0\n  let columnIndexMaxMaxMin = 0\n  let rowIndexMaxMaxMaxMin = 0\n  let columnIndexMaxMaxMaxMin = 0\n  let rowIndexMaxMaxMaxMax = 0\n  let columnIndexMaxMaxMaxMax = 0\n  let rowIndexMaxMinMinMax = 0\n  let columnIndexMaxMinMinMax = 0\n  let rowIndexMaxMaxMinMax = 0\n  let columnIndexMaxMaxMinMax = 0\n  let rowIndexMaxMaxMaxMinMax = 0\n  let columnIndexMaxMaxMaxMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMax = 0\n  let columnIndexMaxMaxMaxMaxMinMax = 0\n  let rowIndexMaxMinMinMax = 0\n  let columnIndexMaxMinMinMax = 0\n  let rowIndexMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMinMinMax = 0\n  let columnIndexMaxMaxMaxMinMinMax = 0\n  let rowIndexMaxMaxMaxMaxMin"}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non - negative integer, return a copy of the give array after screen, \n   you will screen the given array in ascend order if the union (first exponent value, concluding index value) exist odd, \n   or sort it in descending order if the sum (beginning exponent value, final exponent value) embody even. \n\n   Note: \n   * don't change the yield array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an array of non - negative integer, return a copy of the give array after screen, \n   you will screen the given array in ascend order if the union (first exponent value, concluding index value) exist odd, \n   or sort it in descending order if the sum (beginning exponent value, final exponent value) embody even. \n\n   Note: \n   * don't change the yield array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const arrayCopy = array.slice();\n  const arrayCopySorted = arrayCopy.sort((a, b) => a - b);\n  return arrayCopySorted;\n};\n\n/**\n * Given an array of non - negative integer, return a copy of the give array after screen, \n   you will screen the given array in ascend order if the union (first exponent value, concluding index value) exist odd, \n   or sort it in descending order if the sum (beginning exponent value, final exponent value) embody even. \n\n   Note: \n   * don't change the yield array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayReversed = (array) => {\n  const arrayCopy = array.slice();\n  const arrayCopySorted = arrayCopy.sort((a, b) => b - a);\n  return arrayCopySorted;\n};\n\n/**\n * Given an array of non - negative integer, return a copy of the give array after screen, \n   you will screen the given array in ascend order if the union (first exponent value, concluding index value) exist odd, \n   or sort it in descending order if the sum (beginning exponent value, final exponent value) embody even. \n\n   Note: \n   * don't change the yield array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayReversedReversed = (array) => {\n  const arrayCopy = array.slice();\n  const arrayCopySorted = arrayCopy.sort((a, b) => b - a);\n  return arrayCopySorted;\n};\n\n/**\n * Given an array of non - negative integer, return a copy of the give array after screen, \n   you will screen the given array in ascend order if the union (first exponent value, concluding index value) exist odd, \n   or sort it in descending order if the sum (beginning exponent value, final exponent value) embody even. \n\n   Note: \n   * don't change the yield array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayReversedReversedReversed = (array) => {\n  const arrayCopy = array.slice();\n  const arrayCopySorted = arrayCopy.sort((a, b) => b - a);\n  return arrayCopySorted;\n};\n\n/**\n * Given an array of non - negative integer, return a copy of the give array after screen, \n   you will screen the given array in ascend order if the union (first exponent value, concluding index value) exist odd, \n   or sort it in descending order if the sum (beginning exponent value, final exponent value) embody even. \n\n   Note: \n   * don't change the yield array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayReversedReversedReversedReversed = (array) => {\n  const arrayCopy = array.slice();\n  const arrayCopySorted = arrayCopy.sort((a, b) => b - a);\n  return arrayCopySorted;\n};\n\n/**\n * Given an array of non - negative integer, return a copy of the give array after screen, \n   you will screen the given array in ascend order if the union (first exponent value, concluding index value) exist odd, \n   or sort it in descending order if the sum (beginning exponent value, final exponent value) embody even. \n\n   Note: \n   * don't change the yield array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayReversedReversedReversedReversedReversedReversed = (array) => {\n  const arrayCopy = array.slice();\n  const arrayCopySorted = arrayCopy.sort((a, b) => b - a);\n  return arrayCopySorted;\n};\n\n/**\n * Given an array of non - negative integer, return a copy of the give array after screen, \n   you will screen the given array in ascend order if the union (first exponent value, concluding index value) exist odd, \n   or sort it in descending order if the sum (beginning exponent value, final exponent value) embody even. \n\n   Note: \n   * don't change the yield array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed = (array) => {\n  const arrayCopy = array.slice();\n  const arrayCopySorted = arrayCopy.sort((a, b) => b - a);\n  return arrayCopySorted;\n};\n\n/**\n * Given an array of non - negative integer, return a copy of the give array after screen, \n   you will screen the given array in ascend order if the union (first exponent value, concluding index value) exist odd, \n   or sort it in descending order if the sum (beginning exponent value, final exponent value) embody even. \n\n   Note: \n   * don't change the yield array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed"}
{"task_id": "JavaScript/89", "prompt": "/*Create a function encrypt that takes a string as an argumentation and \n   retort a string encrypted with the rudiment being rotated. \n   The alphabet should be rotated in a manner such that the letter \n   switch down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Create a function encrypt that takes a string as an argumentation and \n   retort a string encrypted with the rudiment being rotated. \n   The alphabet should be rotated in a manner such that the letter \n   switch down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let rotated = '';\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let i;\n  let j;\n  let temp;\n  let temp2;\n  let temp3;\n  let temp4;\n  let temp5;\n  let temp6;\n  let temp7;\n  let temp8;\n  let temp9;\n  let temp10;\n  let temp11;\n  let temp12;\n  let temp13;\n  let temp14;\n  let temp15;\n  let temp16;\n  let temp17;\n  let temp18;\n  let temp19;\n  let temp20;\n  let temp21;\n  let temp22;\n  let temp23;\n  let temp24;\n  let temp25;\n  let temp26;\n  let temp27;\n  let temp28;\n  let temp29;\n  let temp30;\n  let temp31;\n  let temp32;\n  let temp33;\n  let temp34;\n  let temp35;\n  let temp36;\n  let temp37;\n  let temp38;\n  let temp39;\n  let temp40;\n  let temp41;\n  let temp42;\n  let temp43;\n  let temp44;\n  let temp45;\n  let temp46;\n  let temp47;\n  let temp48;\n  let temp49;\n  let temp50;\n  let temp51;\n  let temp52;\n  let temp53;\n  let temp54;\n  let temp55;\n  let temp56;\n  let temp57;\n  let temp58;\n  let temp59;\n  let temp60;\n  let temp61;\n  let temp62;\n  let temp63;\n  let temp64;\n  let temp65;\n  let temp66;\n  let temp67;\n  let temp68;\n  let temp69;\n  let temp70;\n  let temp71;\n  let temp72;\n  let temp73;\n  let temp74;\n  let temp75;\n  let temp76;\n  let temp77;\n  let temp78;\n  let temp79;\n  let temp80;\n  let temp81;\n  let temp82;\n  let temp83;\n  let temp84;\n  let temp85;\n  let temp86;\n  let temp87;\n  let temp88;\n  let temp89;\n  let temp90;\n  let temp91;\n  let temp92;\n  let temp93;\n  let temp94;\n  let temp95;\n  let temp96;\n  let temp97;\n  let temp98;\n  let temp99;\n  let temp100;\n  let temp101;\n  let temp102;\n  let temp103;\n  let temp104;\n  let temp105;\n  let temp106;\n  let temp107;\n  let temp108;\n  let temp109;\n  let temp110;\n  let temp111;\n  let temp112;\n  let temp113;\n  let temp114;\n  let temp115;\n  let temp116;\n  let temp117;\n  let temp118;\n  let temp119;\n  let temp120;\n  let temp121;\n  let temp122;\n  let temp123;\n  let temp124;\n  let temp125;\n  let temp126;\n  let temp127;\n  let temp128;\n  let temp129;\n  let temp130;\n  let temp131;\n  let temp132;\n  let temp133;\n  let temp134;\n  let temp135;\n  let temp136;\n  let temp137;\n  let temp138;\n  let temp139;\n  let temp140;\n  let temp141;\n  let temp142;\n  let temp143;\n  let temp144;\n  let temp145;\n  let temp146;\n  let temp147;\n  let temp148;\n  let temp149;\n  let temp150;\n  let temp151;\n  let temp152;\n  let temp153;\n  let temp154;\n  let temp155;\n  let temp156;\n  let temp157;\n  let temp158;\n  let temp159;\n  let temp160;\n  let temp161;\n  let temp162;\n  let temp163;\n  let temp164;\n  let temp165;\n  let temp166;\n  let temp167;\n  let temp168;\n  let temp169;\n  let temp170;\n  let temp171;\n  let temp172;\n  let temp173;\n  let temp174;\n  let temp175;\n  let temp176;\n  let temp177;\n  let temp178;\n  let temp179;\n  let temp180;\n  let temp181;\n  let temp182;\n  let temp183;\n  let temp184;\n  let temp185;\n  let temp186;\n  let temp187;\n  let temp188;\n  let temp189;\n  let temp190;\n  let temp191;\n  let temp192;\n  let temp193;\n  let temp194;\n  let temp195;\n  let temp196;\n  let temp197;\n  let temp198;\n  let temp199;\n  let temp200;\n  let temp201;\n  let temp202;\n  let temp203;\n  let temp204;\n  let temp205;\n  let temp206;\n  let temp207;\n  let temp208;\n  let temp209;\n  let temp210;\n  let temp211;\n  let temp212;\n  let temp213;\n  let temp214;\n  let temp215;\n  let temp216;\n  let temp217;\n  let temp218;\n  let temp219;\n  let temp220;\n  let temp221;\n  let temp222;\n  let temp223;\n  let temp224;\n  let temp225;\n  let temp226;\n  let temp227;\n  let temp228;\n  let temp229;\n  let temp230;\n  let temp231;\n  let temp232;\n  let temp233;\n  let temp234;\n  let temp235;\n  let temp236;\n  let temp237;\n  let temp238;\n  let temp239;\n  let temp240;\n  let temp241;\n  let temp242;\n  let temp243;\n  let temp244;\n  let temp245;\n  let temp246;\n  let temp247;\n  let temp248;\n  let temp249;\n  let temp250;\n  let temp251;\n  let temp252;\n  let temp253;\n  let temp254;\n  let temp255;\n  let temp256;\n  let temp257;\n  let temp258;\n  let temp259;\n  let temp260;\n  let temp261;\n  let temp262;\n  let temp263;\n  let temp264;\n  let temp265;\n  let temp266;\n  let temp267;\n  let temp268;\n  let temp269;\n  let temp270;\n  let temp271;\n  let temp272;\n  let temp273;\n  let temp274;\n  let temp275;\n  let temp276;\n  let temp277;\n  let temp278;\n  let temp279;\n  let temp280;\n  let temp281;\n  let temp282;\n  let temp283;\n  let temp284;"}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given a list of integers. \n   Write a function nextSmallest() that return the second smallest component of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a list of integers. \n   Write a function nextSmallest() that return the second smallest component of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n   let min = null;\n   let max = null;\n   let minIndex = -1;\n   let maxIndex = -1;\n   for (let i = 0; i < lst.length; i++) {\n     if (min === null || min > lst[i]) {\n       min = lst[i];\n       minIndex = i;\n     }\n     if (max === null || max < lst[i]) {\n       max = lst[i];\n       maxIndex = i;\n     }\n   }\n   if (min === null || max === null || minIndex === -1 || maxIndex === -1) {\n     return null;\n   }\n   return [min, minIndex];\n };\n*/\n\n/**\n * Given a sorted array and a target value, find the index of the target value if it is in the sorted array.\n * \n * Example 1:\n * \n * Input: [3,2,1,4,5], target: 3\n * Output: 1\n * \n * Example 2:\n * \n * Input: [3,2,1,4,5], target: 5\n * Output: -1\n * \n * Example 3:\n * \n * Input: [3,2,1,4,5], target: 4\n * Output: -1\n * \n * Note:\n * \n * The array is non-empty and the target is always valid, though not necessarily in the sorted order.\n * \n * Follow up:\n * \n * Could you solve it without using extra memory?\n * \n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar binarySearch = function (nums, target) {\n  const low = 0;\n  const high = nums.length - 1;\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    if (nums[mid] === target) {\n      return mid;\n    } else if (nums[mid] > target) {\n      high = mid - 1;\n    } else {\n      low = mid + 1;\n    }\n  }\n  return -1;\n};\n\n/**\n * Given a sorted array and a target value, find the index of the target value if it is in the sorted array.\n * \n * Example 1:\n * \n * Input: [3,2,1,4,5], target: 3\n * Output: 1\n * \n * Example 2:\n * \n * Input: [3,2,1,4,5], target: 5\n * Output: -1\n * \n * Example 3:\n * \n * Input: [3,2,1,4,5], target: 4\n * Output: -1\n * \n * Note:\n * \n * The array is non-empty and the target is always valid, though not necessarily in the sorted order.\n * \n * Follow up:\n * \n * Could you solve it without using extra memory?\n * \n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar binarySearch_1 = function (nums, target) {\n  const low = 0;\n  const high = nums.length - 1;\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    if (nums[mid] === target) {\n      return mid;\n    } else if (nums[mid] > target) {\n      high = mid - 1;\n    } else {\n      low = mid + 1;\n    }\n  }\n  return -1;\n};\n\n/**\n * Given a sorted array and a target value, find the index of the target value if it is in the sorted array.\n * \n * Example 1:\n * \n * Input: [3,2,1,4,5], target: 3\n * Output: 1\n * \n * Example 2:\n * \n * Input: [3,2,1,4,5], target: 5\n * Output: -1\n * \n * Example 3:\n * \n * Input: [3,2,1,4,5], target: 4\n * Output: -1\n * \n * Note:\n * \n * The array is non-empty and the target is always valid, though not necessarily in the sorted order.\n * \n * Follow up:\n * \n * Could you solve it without using extra memory?\n * \n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar binarySearch_2 = function (nums, target) {\n  const low = 0;\n  const high = nums.length - 1;\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    if (nums[mid] === target) {\n      return mid;\n    } else if (nums[mid] > target) {\n      high = mid - 1;\n    } else {\n      low = mid + 1;\n    }\n  }\n  return -1;\n};\n\n/**\n * Given a sorted array and a target value, find the index of the target value if it is in the sorted array.\n * \n * Example 1:\n * \n * Input: [3,2,1,4,5], target: 3\n * Output: 1\n * \n * Example 2:\n * \n * Input: [3,2,1,4,5], target: 5\n * Output: -1\n * \n * Example 3:\n * \n * Input: [3,2,1,4,5], target: 4\n * Output: -1\n * \n * Note:\n * \n * The array is non-empty and the target is always valid, though not necessarily in the sorted order.\n * \n * Follow up:\n * \n * Could you solve it without using extra memory?\n * \n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar binarySearch_3 = function (nums, target) {\n  const low = 0;\n  const high = nums.length - 1;\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    if (nums[mid] === target) {\n      return mid;\n    } else if (nums[mid] > target) {\n      high = mid - 1;\n    } else {\n      low = mid + 1;\n    }\n  }\n  return -1;\n};\n\n/**\n * Given a sorted array and a target value, find the index of the target value if it is in the sorted array.\n * \n * Example 1:\n * \n * Input: [3,2,1,4,5], target: 3\n * Output: 1\n * \n * Example 2:\n * \n * Input: [3,2,1,4,5], target: 5\n * Output: -1\n * \n * Example 3:\n * \n * Input: [3,2,1,4,5], target: 4\n * Output: -1\n * \n * Note:\n * \n * The array is non-empty and the target is always valid, though not necessarily in the sorted order.\n * \n * Follow up:\n * \n * Could you solve it without using extra memory?\n * \n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar binarySearch_4 = function (nums, target) {\n  const low = 0;\n  const high = nums.length - 1;\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    if (nums[mid] === target) {\n      return mid;\n    } else if (nums[mid] > target) {\n      high = mid - 1;\n    } else {\n      low = mid + 1;\n    }\n  }\n  return -1;\n};\n\n/**\n * Given a sorted array and a target value, find the index of the target value if it is in the sorted array.\n * \n * Example 1:\n * \n * Input: [3,2,1,4,5], target: 3\n * Output: 1\n * \n * Example 2:\n * \n * Input: [3,2,1,4,5], target: 5\n * Output: -1\n * \n * Example 3:\n * \n * Input: [3,2,1,4,5], target: 4\n * Output: -1\n * \n * Note:\n * \n * The array is non-empty and the target is always valid, though not necessarily in the sorted order.\n * \n * Follow up:\n * \n * Could you solve it without using extra memory?\n * \n * @param {number[]} num"}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be given a string of words, and your task equal to reckon the number \n   of boredoms. A boredom is a sentence that starts with the word \" I \". \n   Sentences are subtend by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You'll be given a string of words, and your task equal to reckon the number \n   of boredoms. A boredom is a sentence that starts with the word \" I \". \n   Sentences are subtend by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let words = S.split(' ');\n  words.forEach((word) => {\n    if (word.startsWith('I')) {\n      bored++;\n    }\n  });\n  return bored;\n};\n\n/*\n  You'll be given a string of words, and your task equal to reckon the number \n   of deaths. A death is a sentence that starts with the word \" I \". \n   Sentences are subtend by'.','?' or'!'. \n \n   For example:\n  >>> isDeath(\"Hello world\")\n  0\n  >>> isDeath(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isDeath = (S) => {\n  let deaths = 0;\n  let words = S.split(' ');\n  words.forEach((word) => {\n    if (word.startsWith('I')) {\n      deaths++;\n    }\n  });\n  return deaths;\n};\n\n/*\n  You'll be given a string of words, and your task equal to reckon the number \n   of reckonings. A reckoning is a sentence that starts with the word \" I \". \n   Sentences are subtend by'.','?' or'!'. \n \n   For example:\n  >>> isReckoning(\"Hello world\")\n  0\n  >>> isReckoning(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isReckoning = (S) => {\n  let reckonings = 0;\n  let words = S.split(' ');\n  words.forEach((word) => {\n    if (word.startsWith('I')) {\n      reckonings++;\n    }\n  });\n  return reckonings;\n};\n\n/*\n  You'll be given a string of words, and your task equal to reckon the number \n   of reckonings. A reckoning is a sentence that starts with the word \" I \". \n   Sentences are subtend by'.','?' or'!'. \n \n   For example:\n  >>> isReckoning(\"Hello world\")\n  0\n  >>> isReckoning(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isReckoning = (S) => {\n  let reckonings = 0;\n  let words = S.split(' ');\n  words.forEach((word) => {\n    if (word.startsWith('I')) {\n      reckonings++;\n    }\n  });\n  return reckonings;\n};\n\n/*\n  You'll be given a string of words, and your task equal to reckon the number \n   of reckonings. A reckoning is a sentence that starts with the word \" I \". \n   Sentences are subtend by'.','?' or'!'. \n \n   For example:\n  >>> isReckoning(\"Hello world\")\n  0\n  >>> isReckoning(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isReckoning = (S) => {\n  let reckonings = 0;\n  let words = S.split(' ');\n  words.forEach((word) => {\n    if (word.startsWith('I')) {\n      reckonings++;\n    }\n  });\n  return reckonings;\n};\n\n/*\n  You'll be given a string of words, and your task equal to reckon the number \n   of reckonings. A reckoning is a sentence that starts with the word \" I \". \n   Sentences are subtend by'.','?' or'!'. \n \n   For example:\n  >>> isReckoning(\"Hello world\")\n  0\n  >>> isReckoning(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isReckoning = (S) => {\n  let reckonings = 0;\n  let words = S.split(' ');\n  words.forEach((word) => {\n    if (word.startsWith('I')) {\n      reckonings++;\n    }\n  });\n  return reckonings;\n};\n\n/*\n  You'll be given a string of words, and your task equal to reckon the number \n   of reckonings. A reckoning is a sentence that starts with the word \" I \". \n   Sentences are subtend by'.','?' or'!'. \n \n   For example:\n  >>> isReckoning(\"Hello world\")\n  0\n  >>> isReckoning(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isReckoning = (S) => {\n  let reckonings = 0;\n  let words = S.split(' ');\n  words.forEach((word) => {\n    if (word.startsWith('I')) {\n      reckonings++;\n    }\n  });\n  return reckonings;\n};\n\n/*\n  You'll be given a string of words, and your task equal to reckon the number \n   of reckonings. A reckoning is a sentence that starts with the word \" I \". \n   Sentences are subtend by'.','?' or'!'. \n \n   For example:\n  >>> isReckoning(\"Hello world\")\n  0\n  >>> isReckoning(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isReckoning = (S) => {\n  let reckonings = 0;\n  let words = S.split(' ');\n  words.forEach((word) => {\n    if (word.startsWith('I')) {\n      reckonings++;\n    }\n  });\n  return reckonings;\n};\n\n/*\n  You'll be given a string of words, and your task equal to reckon the number \n   of reckonings. A reckoning is a sentence that starts with the word \" I \". \n   Sentences are subtend by'.','?' or'!'. \n \n   For example:\n  >>> isReckoning(\"Hello world\")\n  0\n  >>> isReckoning(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isReckoning = (S) => {\n  let reckonings = 0;\n  let words = S.split(' ');\n  words.forEach((word) => {\n    if (word.startsWith('I')) {\n      reckonings++;\n    }\n  });\n  return reckonings;\n};\n\n/*\n  You'll be given a string of words, and your task equal to reckon the number \n   of reckonings. A reckoning is a sentence that starts with the word \" I \". \n   Sentences are subtend by'.','?' or'!'. \n \n   For example:\n  >>> isReckoning(\"Hello world\")\n  0\n  >>> isReckoning(\""}
{"task_id": "JavaScript/92", "prompt": "/* Create a function that takes 3 numbers. \n   return on-key if one of the numbers is adequate to the sum of the other two, and all numbers are integer. \n   restitution fake in any other cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Create a function that takes 3 numbers. \n   return on-key if one of the numbers is adequate to the sum of the other two, and all numbers are integer. \n   restitution fake in any other cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  if (x < 0 || x > 100 || y < 0 || y > 100 || z < 0 || z > 100) {\n    return false\n  }\n  return true\n}\n\n/* Create a function that takes 3 numbers. \n   return on-key if one of the numbers is adequate to the sum of the other two, and all numbers are integer. \n   restitution fake in any other cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  if (x < 0 || x > 100 || y < 0 || y > 100 || z < 0 || z > 100) {\n    return false\n  }\n  return true\n}\n\n/* Create a function that takes 3 numbers. \n   return on-key if one of the numbers is adequate to the sum of the other two, and all numbers are integer. \n   restitution fake in any other cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  if (x < 0 || x > 100 || y < 0 || y > 100 || z < 0 || z > 100) {\n    return false\n  }\n  return true\n}\n\n/* Create a function that takes 3 numbers. \n   return on-key if one of the numbers is adequate to the sum of the other two, and all numbers are integer. \n   restitution fake in any other cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  if (x < 0 || x > 100 || y < 0 || y > 100 || z < 0 || z > 100) {\n    return false\n  }\n  return true\n}\n\n/* Create a function that takes 3 numbers. \n   return on-key if one of the numbers is adequate to the sum of the other two, and all numbers are integer. \n   restitution fake in any other cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  if (x < 0 || x > 100 || y < 0 || y > 100 || z < 0 || z > 100) {\n    return false\n  }\n  return true\n}\n\n/* Create a function that takes 3 numbers. \n   return on-key if one of the numbers is adequate to the sum of the other two, and all numbers are integer. \n   restitution fake in any other cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  if (x < 0 || x > 100 || y < 0 || y > 100 || z < 0 || z > 100) {\n    return false\n  }\n  return true\n}\n\n/* Create a function that takes 3 numbers. \n   return on-key if one of the numbers is adequate to the sum of the other two, and all numbers are integer. \n   restitution fake in any other cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  if (x < 0 || x > 100 || y < 0 || y > 100 || z < 0 || z > 100) {\n    return false\n  }\n  return true\n}\n\n/* Create a function that takes 3 numbers. \n   return on-key if one of the numbers is adequate to the sum of the other two, and all numbers are integer. \n   restitution fake in any other cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  if (x < 0 || x > 100 || y < 0 || y > 100 || z < 0 || z > 100) {\n    return false\n  }\n  return true\n}\n\n/* Create a function that takes 3 numbers. \n   return on-key if one of the numbers is adequate to the sum of the other two, and all numbers are integer. \n   restitution fake in any other cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  if (x < 0 || x > 100 || y < 0 || y > 100 || z < 0 || z > 100) {\n    return false\n  }\n  return true\n}\n\n/* Create a function that takes 3 numbers. \n   return on-key if one of the numbers is adequate to the sum of the other two, and all numbers are integer. \n   restitution fake in any other cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  if (x < 0 || x > 100 || y < 0 || y > 100 || z < 0 || z > 100) {\n    return false\n  }\n  return true\n}\n\n/* Create a function that takes 3 numbers. \n   return on-key if one of the numbers is adequate to the sum of the other two, and all numbers are integer. \n   restitution fake in any other cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  if (x < 0 || x > 100 || y < 0 || y > 100 || z < 0 || z > 100) {\n    return false\n  }\n  return true\n}\n\n/* Create a function that takes 3 numbers. \n   return on-key if one of the numbers is adequate to the sum of the other two, and all numbers are integer. \n   restitution fake in any other cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\n"}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a function that takes a message, and encodes in such a \n   means that it swap case of all letters, replace all vowels in \n   the message with the letter that appear 2 place ahead of that \n   vowel in the english alphabet. \n   Assume only letter. \n  \n   example:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that takes a message, and encodes in such a \n   means that it swap case of all letters, replace all vowels in \n   the message with the letter that appear 2 place ahead of that \n   vowel in the english alphabet. \n   Assume only letter. \n  \n   example:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let encoded = '';\n  let vowels = 'aeiouAEIOU';\n  let vowelsCount = vowels.length;\n  let messageCount = message.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let temp = '';\n  let tempCount = 0;\n  let tempCount2 = 0;\n  let tempCount3 = 0;\n  let tempCount4 = 0;\n  let tempCount5 = 0;\n  let tempCount6 = 0;\n  let tempCount7 = 0;\n  let tempCount8 = 0;\n  let tempCount9 = 0;\n  let tempCount10 = 0;\n  let tempCount11 = 0;\n  let tempCount12 = 0;\n  let tempCount13 = 0;\n  let tempCount14 = 0;\n  let tempCount15 = 0;\n  let tempCount16 = 0;\n  let tempCount17 = 0;\n  let tempCount18 = 0;\n  let tempCount19 = 0;\n  let tempCount20 = 0;\n  let tempCount21 = 0;\n  let tempCount22 = 0;\n  let tempCount23 = 0;\n  let tempCount24 = 0;\n  let tempCount25 = 0;\n  let tempCount26 = 0;\n  let tempCount27 = 0;\n  let tempCount28 = 0;\n  let tempCount29 = 0;\n  let tempCount30 = 0;\n  let tempCount31 = 0;\n  let tempCount32 = 0;\n  let tempCount33 = 0;\n  let tempCount34 = 0;\n  let tempCount35 = 0;\n  let tempCount36 = 0;\n  let tempCount37 = 0;\n  let tempCount38 = 0;\n  let tempCount39 = 0;\n  let tempCount40 = 0;\n  let tempCount41 = 0;\n  let tempCount42 = 0;\n  let tempCount43 = 0;\n  let tempCount44 = 0;\n  let tempCount45 = 0;\n  let tempCount46 = 0;\n  let tempCount47 = 0;\n  let tempCount48 = 0;\n  let tempCount49 = 0;\n  let tempCount50 = 0;\n  let tempCount51 = 0;\n  let tempCount52 = 0;\n  let tempCount53 = 0;\n  let tempCount54 = 0;\n  let tempCount55 = 0;\n  let tempCount56 = 0;\n  let tempCount57 = 0;\n  let tempCount58 = 0;\n  let tempCount59 = 0;\n  let tempCount60 = 0;\n  let tempCount61 = 0;\n  let tempCount62 = 0;\n  let tempCount63 = 0;\n  let tempCount64 = 0;\n  let tempCount65 = 0;\n  let tempCount66 = 0;\n  let tempCount67 = 0;\n  let tempCount68 = 0;\n  let tempCount69 = 0;\n  let tempCount70 = 0;\n  let tempCount71 = 0;\n  let tempCount72 = 0;\n  let tempCount73 = 0;\n  let tempCount74 = 0;\n  let tempCount75 = 0;\n  let tempCount76 = 0;\n  let tempCount77 = 0;\n  let tempCount78 = 0;\n  let tempCount79 = 0;\n  let tempCount80 = 0;\n  let tempCount81 = 0;\n  let tempCount82 = 0;\n  let tempCount83 = 0;\n  let tempCount84 = 0;\n  let tempCount85 = 0;\n  let tempCount86 = 0;\n  let tempCount87 = 0;\n  let tempCount88 = 0;\n  let tempCount89 = 0;\n  let tempCount90 = 0;\n  let tempCount91 = 0;\n  let tempCount92 = 0;\n  let tempCount93 = 0;\n  let tempCount94 = 0;\n  let tempCount95 = 0;\n  let tempCount96 = 0;\n  let tempCount97 = 0;\n  let tempCount98 = 0;\n  let tempCount99 = 0;\n  let tempCount100 = 0;\n  let tempCount101 = 0;\n  let tempCount102 = 0;\n  let tempCount103 = 0;\n  let tempCount104 = 0;\n  let tempCount105 = 0;\n  let tempCount106 = 0;\n  let tempCount107 = 0;\n  let tempCount108 = 0;\n  let tempCount109 = 0;\n  let tempCount110 = 0;\n  let tempCount111 = 0;\n  let tempCount112 = 0;\n  let tempCount113 = 0;\n  let tempCount114 = 0;\n  let tempCount115 = 0;\n  let tempCount116 = 0;\n  let tempCount117 = 0;\n  let tempCount118 = 0;\n  let tempCount119 = 0;\n  let tempCount120 = 0;\n  let tempCount121 = 0;\n  let tempCount122 = 0;\n  let tempCount123 = 0;\n  let tempCount124 = 0;\n  let tempCount125 = 0;\n  let tempCount126 = 0;\n  let tempCount127 = 0;\n  let tempCount128 = 0;\n  let tempCount129 = 0;\n  let tempCount130 = 0;\n  let tempCount131 = 0;\n  let tempCount132 = 0;\n  let tempCount133 = 0;\n  let tempCount134 = 0;\n  let tempCount135 = 0;\n  let tempCount136 = 0;\n  let tempCount137 = 0;\n  let tempCount138 = 0;\n  let tempCount139 = 0;\n  let tempCount140 = 0;\n  let tempCount141 = 0;\n  let tempCount142 = 0;\n  let tempCount143 = 0;\n  let tempCount144 = 0;\n  let tempCount145 = 0;\n  let tempCount146 = 0;\n  let tempCount147 = 0;\n  let tempCount148 = 0;\n  let tempCount149 = 0;\n  let tempCount150 = 0;\n  let tempCount151 = 0;\n  let tempCount152 = 0;\n  let tempCount153 = 0;\n  let tempCount154 = 0;\n  let tempCount155 = 0;\n  let tempCount156 = 0;\n  let tempCount157 = 0;\n  let tempCount158 = 0;\n  let tempCount159 = 0;\n  let tempCount160 = 0;\n  let tempCount161 = 0;\n  let tempCount162 = 0;\n  let tempCount163 = 0;\n  let tempCount164 = 0;\n  let tempCount165 = 0;\n  let tempCount166 = 0;\n  let tempCount167 = 0;\n  let tempCount168 = 0;\n  let tempCount169 = 0;\n  let tempCount170 = 0;\n  let tempCount171 = 0;\n  let tempCount172 = 0;\n  let tempCount173 = 0;\n  let tempCount174 = 0;\n  let tempCount175 = 0;\n  let tempCount176 = 0;\n  let tempCount177 = 0;\n  let tempCount178 = 0;\n  let tempCount179 = 0;\n  let tempCount180 = 0;\n  let tempCount181 = 0;\n  let tempCount182 = 0;\n  let tempCount183 = 0;\n  let tempCount184 = 0;\n  let tempCount185 = 0;\n  let tempCount186 = 0;\n  let tempCount187 = 0;\n  let tempCount188 = 0;\n  let tempCount189 = 0;\n  let tempCount190 = 0;\n  let tempCount191 = 0;\n  let tempCount192 = 0;\n  let tempCount193 = 0;\n  let tempCount194 = 0;\n  let tempCount195 = 0;\n  let tempCount196 = 0;\n  let tempCount197 = 0;\n  let tempCount198 = 0;\n  let tempCount199 = 0;\n  let tempCount200 = 0;\n  let tempCount201 = 0;\n  let tempCount202 = 0;\n  let tempCount203 = 0;\n  let tempCount204 = 0;\n  let tempCount205 = 0;\n  let tempCount206 = 0;\n  let tempCount207 = 0;\n  let tempCount208 = 0;\n  let tempCount209 = 0;\n  let tempCount210 = 0;\n  let tempCount211 = 0;\n  let tempCount212 = 0;\n  let tempCount213 = 0;\n  let tempCount214 = 0;\n  let tempCount215 = 0;\n  let tempCount216 = 0;\n  let tempCount217 = 0;\n  let tempCount218 = 0;\n  let tempCount219 = 0;\n  let tempCount220 = 0;\n  let tempCount221 = 0;\n  let tempCount222 = 0;\n  let tempCount223 = 0;\n  let tempCount224 = 0;\n  let tempCount225 = 0;\n  let tempCount226 = 0;\n  let tempCount227 = 0;\n  let tempCount228 = 0;\n  let tempCount229 = 0;\n  let tempCount230 = 0;\n  let tempCount231 = 0;\n  let tempCount232 = 0;\n  let tempCount233 = 0;\n  let tempCount"}
{"task_id": "JavaScript/94", "prompt": "/*You are given a list of integers. \n   You need to find the large choice value and return the sum of its digit.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You are given a list of integers. \n   You need to find the large choice value and return the sum of its digit.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let sum = 0;\n  let temp = 0;\n  let temp2 = 0;\n  let temp3 = 0;\n  let temp4 = 0;\n  let temp5 = 0;\n  let temp6 = 0;\n  let temp7 = 0;\n  let temp8 = 0;\n  let temp9 = 0;\n  let temp10 = 0;\n  let temp11 = 0;\n  let temp12 = 0;\n  let temp13 = 0;\n  let temp14 = 0;\n  let temp15 = 0;\n  let temp16 = 0;\n  let temp17 = 0;\n  let temp18 = 0;\n  let temp19 = 0;\n  let temp20 = 0;\n  let temp21 = 0;\n  let temp22 = 0;\n  let temp23 = 0;\n  let temp24 = 0;\n  let temp25 = 0;\n  let temp26 = 0;\n  let temp27 = 0;\n  let temp28 = 0;\n  let temp29 = 0;\n  let temp30 = 0;\n  let temp31 = 0;\n  let temp32 = 0;\n  let temp33 = 0;\n  let temp34 = 0;\n  let temp35 = 0;\n  let temp36 = 0;\n  let temp37 = 0;\n  let temp38 = 0;\n  let temp39 = 0;\n  let temp40 = 0;\n  let temp41 = 0;\n  let temp42 = 0;\n  let temp43 = 0;\n  let temp44 = 0;\n  let temp45 = 0;\n  let temp46 = 0;\n  let temp47 = 0;\n  let temp48 = 0;\n  let temp49 = 0;\n  let temp50 = 0;\n  let temp51 = 0;\n  let temp52 = 0;\n  let temp53 = 0;\n  let temp54 = 0;\n  let temp55 = 0;\n  let temp56 = 0;\n  let temp57 = 0;\n  let temp58 = 0;\n  let temp59 = 0;\n  let temp60 = 0;\n  let temp61 = 0;\n  let temp62 = 0;\n  let temp63 = 0;\n  let temp64 = 0;\n  let temp65 = 0;\n  let temp66 = 0;\n  let temp67 = 0;\n  let temp68 = 0;\n  let temp69 = 0;\n  let temp70 = 0;\n  let temp71 = 0;\n  let temp72 = 0;\n  let temp73 = 0;\n  let temp74 = 0;\n  let temp75 = 0;\n  let temp76 = 0;\n  let temp77 = 0;\n  let temp78 = 0;\n  let temp79 = 0;\n  let temp80 = 0;\n  let temp81 = 0;\n  let temp82 = 0;\n  let temp83 = 0;\n  let temp84 = 0;\n  let temp85 = 0;\n  let temp86 = 0;\n  let temp87 = 0;\n  let temp88 = 0;\n  let temp89 = 0;\n  let temp90 = 0;\n  let temp91 = 0;\n  let temp92 = 0;\n  let temp93 = 0;\n  let temp94 = 0;\n  let temp95 = 0;\n  let temp96 = 0;\n  let temp97 = 0;\n  let temp98 = 0;\n  let temp99 = 0;\n  let temp100 = 0;\n  let temp101 = 0;\n  let temp102 = 0;\n  let temp103 = 0;\n  let temp104 = 0;\n  let temp105 = 0;\n  let temp106 = 0;\n  let temp107 = 0;\n  let temp108 = 0;\n  let temp109 = 0;\n  let temp110 = 0;\n  let temp111 = 0;\n  let temp112 = 0;\n  let temp113 = 0;\n  let temp114 = 0;\n  let temp115 = 0;\n  let temp116 = 0;\n  let temp117 = 0;\n  let temp118 = 0;\n  let temp119 = 0;\n  let temp120 = 0;\n  let temp121 = 0;\n  let temp122 = 0;\n  let temp123 = 0;\n  let temp124 = 0;\n  let temp125 = 0;\n  let temp126 = 0;\n  let temp127 = 0;\n  let temp128 = 0;\n  let temp129 = 0;\n  let temp130 = 0;\n  let temp131 = 0;\n  let temp132 = 0;\n  let temp133 = 0;\n  let temp134 = 0;\n  let temp135 = 0;\n  let temp136 = 0;\n  let temp137 = 0;\n  let temp138 = 0;\n  let temp139 = 0;\n  let temp140 = 0;\n  let temp141 = 0;\n  let temp142 = 0;\n  let temp143 = 0;\n  let temp144 = 0;\n  let temp145 = 0;\n  let temp146 = 0;\n  let temp147 = 0;\n  let temp148 = 0;\n  let temp149 = 0;\n  let temp150 = 0;\n  let temp151 = 0;\n  let temp152 = 0;\n  let temp153 = 0;\n  let temp154 = 0;\n  let temp155 = 0;\n  let temp156 = 0;\n  let temp157 = 0;\n  let temp158 = 0;\n  let temp159 = 0;\n  let temp160 = 0;\n  let temp161 = 0;\n  let temp162 = 0;\n  let temp163 = 0;\n  let temp164 = 0;\n  let temp165 = 0;\n  let temp166 = 0;\n  let temp167 = 0;\n  let temp168 = 0;\n  let temp169 = 0;\n  let temp170 = 0;\n  let temp171 = 0;\n  let temp172 = 0;\n  let temp173 = 0;\n  let temp174 = 0;\n  let temp175 = 0;\n  let temp176 = 0;\n  let temp177 = 0;\n  let temp178 = 0;\n  let temp179 = 0;\n  let temp180 = 0;\n  let temp181 = 0;\n  let temp182 = 0;\n  let temp183 = 0;\n  let temp184 = 0;\n  let temp185 = 0;\n  let temp186 = 0;\n  let temp187 = 0;\n  let temp188 = 0;\n  let temp189 = 0;\n  let temp190 = 0;\n  let temp191 = 0;\n  let temp192 = 0;\n  let temp193 = 0;\n  let temp194 = 0;\n  let temp195 = 0;\n  let temp196 = 0;\n  let temp197 = 0;\n  let temp198 = 0;\n  let temp199 = 0;\n  let temp200 = 0;\n  let temp201 = 0;\n  let temp202 = 0;\n  let temp203 = 0;\n  let temp204 = 0;\n  let temp205 = 0;\n  let temp206 = 0;\n  let temp207 = 0;\n  let temp208 = 0;\n  let temp209 = 0;\n  let temp210 = 0;\n  let temp211 = 0;\n  let temp212 = 0;\n  let temp213 = 0;\n  let temp214 = 0;\n  let temp215 = 0;\n  let temp216 = 0;\n  let temp217 = 0;\n  let temp218 = 0;\n  let temp219 = 0;\n  let temp220 = 0;\n  let temp221 = 0;\n  let temp222 = 0;\n  let temp223 = 0;\n  let temp224 = 0;\n  let temp225 = 0;\n  let temp226 = 0;\n  let temp227 = 0;\n  let temp228 = 0;\n  let temp229 = 0;\n  let temp230 = 0;\n  let temp231 = 0;\n  let temp232 = 0;\n  let temp233 = 0;\n  let temp234 = 0;\n  let temp235 = 0;\n  let temp236 = 0;\n  let temp237 = 0;\n  let temp238 = 0;\n  let temp239 = 0;\n  let temp240 = 0;\n  let temp241 = 0;\n  let temp242 = 0;\n  let temp243 = 0;\n  let temp244 = 0;\n  let temp245 = 0;\n  let temp246 = 0;\n  let temp247 = 0;\n  let temp248 = 0;\n  let temp249 = 0;\n  let temp250 = 0;\n  let temp251 = 0;\n  let temp252 = 0;\n  let temp253 = 0;\n  let temp254 = 0;\n  let temp255 = 0;\n  let temp256 = 0;\n  let temp257 = 0;\n  let temp258 = 0;\n  let temp259 = 0;\n  let temp260 = 0;\n  let temp261 = 0;\n  let temp262 = 0;\n  let temp263 = 0;\n  let temp264 = 0;\n  let temp265 = 0;\n  let temp266 = 0;\n  let temp267 = 0;\n  let temp268 = 0;\n  let temp269 = 0;\n  let temp270 = 0;\n  let temp271 = 0;\n  let temp272 = 0;"}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dictionary, return true if all keys equal string in lower \n   case or all key are strings in upper lawsuit, else return false. \n   The routine should return false is the give dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a dictionary, return true if all keys equal string in lower \n   case or all key are strings in upper lawsuit, else return false. \n   The routine should return false is the give dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i];\n    if (dict[key] instanceof Object) {\n      checkDictCase(dict[key]);\n    } else {\n      if (dict[key] === key.toLowerCase()) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*\n  Given a string, return true if all characters are lower case or all \n  characters are upper case. \n  The routine should return false is the give string is empty.\n  Examples:\n  checkStringCase(\"a\") should return true.\n  checkStringCase(\"A\") should return false.\n  checkStringCase(\"aB\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase"}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function that takes an non - negative integer and returns an array of the inaugural n\n   integers that be prime number and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Implement a function that takes an non - negative integer and returns an array of the inaugural n\n   integers that be prime number and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let primes = [];\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      primes.push(i);\n      i++;\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an non - negative integer and returns an array of the inaugural n\n   integers that be prime number and greater than n.\n  for example:\n  countDownTo(5) => [2,3]\n  countDownTo(11) => [2,3,5,7]\n  countDownTo(0) => []\n  countDownTo(20) => [2,3,5,7,11,13,17,19]\n  countDownTo(1) => []\n  countDownTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countDownTo = (n) => {\n  let primes = [];\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      primes.push(i);\n      i--;\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an non - negative integer and returns an array of the inaugural n\n   integers that be prime number and equal to n.\n  for example:\n  countEqualTo(5) => [2,3]\n  countEqualTo(11) => [2,3,5,7]\n  countEqualTo(0) => []\n  countEqualTo(20) => [2,3,5,7,11,13,17,19]\n  countEqualTo(1) => []\n  countEqualTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countEqualTo = (n) => {\n  let primes = [];\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      primes.push(i);\n      i++;\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an non - negative integer and returns an array of the inaugural n\n   integers that be prime number and greater than or equal to n.\n  for example:\n  countGreaterThanOrEqualTo(5) => [2,3]\n  countGreaterThanOrEqualTo(11) => [2,3,5,7]\n  countGreaterThanOrEqualTo(0) => []\n  countGreaterThanOrEqualTo(20) => [2,3,5,7,11,13,17,19]\n  countGreaterThanOrEqualTo(1) => []\n  countGreaterThanOrEqualTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countGreaterThanOrEqualTo = (n) => {\n  let primes = [];\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      primes.push(i);\n      i--;\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an non - negative integer and returns an array of the inaugural n\n   integers that be prime number and less than or equal to n.\n  for example:\n  countLessThanOrEqualTo(5) => [2,3]\n  countLessThanOrEqualTo(11) => [2,3,5,7]\n  countLessThanOrEqualTo(0) => []\n  countLessThanOrEqualTo(20) => [2,3,5,7,11,13,17,19]\n  countLessThanOrEqualTo(1) => []\n  countLessThanOrEqualTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countLessThanOrEqualTo = (n) => {\n  let primes = [];\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      primes.push(i);\n      i++;\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an non - negative integer and returns an array of the inaugural n\n   integers that be prime number and equal to or greater than n.\n  for example:\n  countEqualOrGreaterThan(5) => [2,3]\n  countEqualOrGreaterThan(11) => [2,3,5,7]\n  countEqualOrGreaterThan(0) => []\n  countEqualOrGreaterThan(20) => [2,3,5,7,11,13,17,19]\n  countEqualOrGreaterThan(1) => []\n  countEqualOrGreaterThan(18) => [2,3,5,7,11,13,17]\n  */\nconst countEqualOrGreaterThan = (n) => {\n  let primes = [];\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      primes.push(i);\n      i++;\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an non - negative integer and returns an array of the inaugural n\n   integers that be prime number and less than or equal to or greater than n.\n  for example:\n  countLessOrEqualOrGreaterThan(5) => [2,3]\n  countLessOrEqualOrGreaterThan(11) => [2,3,5,7]\n  countLessOrEqualOrGreaterThan(0) => []\n  countLessOrEqualOrGreaterThan(20) => [2,3,5,7,11,13,17,19]\n  countLessOrEqualOrGreaterThan(1) => []\n  countLessOrEqualOrGreaterThan(18) => [2,3,5,7,11,13,17]\n  */\nconst countLessOrEqualOrGreaterThan = (n) => {\n  let primes = [];\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      primes.push(i);\n      i--;\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an non - negative integer and returns an array of the inaugural n\n   integers that be prime number and equal to or greater than or equal to n.\n  for example:\n  countEqualOrLessThan(5) => [2,3]\n  countEqualOrLessThan(11) => [2,3,5,7]\n  countEqualOrLessThan(0) => []\n  countEqualOrLessThan(20) => [2,3,5,7,11,13,17,19]\n  countEqualOrLessThan(1) => []\n  countEqualOrLessThan(18) => [2,3,5,7,11,13,17]\n  */\nconst countEqualOrLessThan = (n) => {\n  let primes = [];\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      primes.push(i);\n      i--;\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an non - negative integer and returns an array of the inaugural n\n   integers that be prime number and less than or equal to or greater than n.\n  for example:\n  countLessOrEqualOrLessThan(5) => [2,3]\n  countLessOrEqualOrLessThan(11) => [2,3,5,7]\n  countLessOrEqualOrLessThan(0) => []\n  countLessOrEqualOrLessThan(20) => [2,3,5,7,11,13,17,19]\n  countLessOrEqualOrLessThan(1) => []\n  countLessOrEqualOrLessThan(18) => [2,3,5,7,11,13,17]\n  */\nconst countLessOrEqualOrLessThan = (n) => {\n  let primes = [];\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      primes.push(i);\n      i--;\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an non - negative integer and returns an array of the inaugural n\n   integers that be prime number and equal to or greater than "}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function that takes two integers and return \n   the intersection of their unit digits. \n   wear the input is constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Complete the function that takes two integers and return \n   the intersection of their unit digits. \n   wear the input is constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let sum = 0;\n  let digits = 0;\n  let carry = 0;\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n  \n  while (b >= 10) {\n    digits = b%10;\n    sum += digits*a;\n    carry = digits*10 + carry;\n    b = b/10;\n  }\n"}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a string s, count the number of capital vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a string s, count the number of capital vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n  \n  while (i < l) {\n    if (s.charAt(i).toUpperCase() === 'A') {\n      count++;\n    }\n    i++;\n  }\n  \n  while (j < l) {\n    if (s.charAt(j).toUpperCase() === 'A') {\n      count++;\n    }\n    j++;\n  }\n  \n  while (k < l) {\n    if (s.charAt(k).toUpperCase() === 'A') {\n      count++;\n    }\n    k++;\n  }\n  \n  return count;\n};\n\n/*\n  Given a string s, count the number of capital vowels in odd indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countOddUpper = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n  \n  while (i < l) {\n    if (s.charAt(i).toUpperCase() === 'A') {\n      count++;\n    }\n    i++;\n  }\n  \n  while (j < l) {\n    if (s.charAt(j).toUpperCase() === 'A') {\n      count++;\n    }\n    j++;\n  }\n  \n  while (k < l) {\n    if (s.charAt(k).toUpperCase() === 'A') {\n      count++;\n    }\n    k++;\n  }\n  \n  return count;\n};\n\n/*\n  Given a string s, count the number of capital vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countEvenUpper = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n  \n  while (i < l) {\n    if (s.charAt(i).toUpperCase() === 'A') {\n      count++;\n    }\n    i++;\n  }\n  \n  while (j < l) {\n    if (s.charAt(j).toUpperCase() === 'A') {\n      count++;\n    }\n    j++;\n  }\n  \n  while (k < l) {\n    if (s.charAt(k).toUpperCase() === 'A') {\n      count++;\n    }\n    k++;\n  }\n  \n  return count;\n};\n\n/*\n  Given a string s, count the number of capital vowels in odd indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countOddEvenUpper = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n  \n  while (i < l) {\n    if (s.charAt(i).toUpperCase() === 'A') {\n      count++;\n    }\n    i++;\n  }\n  \n  while (j < l) {\n    if (s.charAt(j).toUpperCase() === 'A') {\n      count++;\n    }\n    j++;\n  }\n  \n  while (k < l) {\n    if (s.charAt(k).toUpperCase() === 'A') {\n      count++;\n    }\n    k++;\n  }\n  \n  return count;\n};\n\n/*\n  Given a string s, count the number of capital vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countEvenEvenUpper = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n  \n  while (i < l) {\n    if (s.charAt(i).toUpperCase() === 'A') {\n      count++;\n    }\n    i++;\n  }\n  \n  while (j < l) {\n    if (s.charAt(j).toUpperCase() === 'A') {\n      count++;\n    }\n    j++;\n  }\n  \n  while (k < l) {\n    if (s.charAt(k).toUpperCase() === 'A') {\n      count++;\n    }\n    k++;\n  }\n  \n  return count;\n};\n\n/*\n  Given a string s, count the number of capital vowels in odd indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countOddOddUpper = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n  \n  while (i < l) {\n    if (s.charAt(i).toUpperCase() === 'A') {\n      count++;\n    }\n    i++;\n  }\n  \n  while (j < l) {\n    if (s.charAt(j).toUpperCase() === 'A') {\n      count++;\n    }\n    j++;\n  }\n  \n  while (k < l) {\n    if (s.charAt(k).toUpperCase() === 'A') {\n      count++;\n    }\n    k++;\n  }\n  \n  return count;\n};\n\n/*\n  Given a string s, count the number of capital vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countEvenOddUpper = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n  \n  while (i < l) {\n    if (s.charAt(i).toUpperCase() === 'A') {\n      count++;\n    }\n    i++;\n  }\n  \n  while (j < l) {\n    if (s.charAt(j).toUpperCase() === 'A') {\n      count++;\n    }\n    j++;\n  }\n  \n  while (k < l) {\n    if (s.charAt(k).toUpperCase() === 'A') {\n      count++;\n    }\n    k++;\n  }\n  \n  return count;\n};\n\n/*\n  Given a string s, count the number of capital vowels in odd indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countOddEvenOddUpper = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n  \n  while (i < l) {\n    if (s.charAt(i).toUpperCase() === 'A') {\n      count++;\n    }\n    i++;\n  }\n  \n  while (j < l) {\n    if (s.charAt(j).toUpperCase() === 'A') {\n      count++;\n    }\n    j++;\n  }\n  \n  while (k < l) {\n    if (s.charAt(k).toUpperCase() === 'A') {\n      count++;\n    }\n    k++;\n  }\n  \n  return count;\n};\n\n/*\n  Given a string s, count the number of capital vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countEvenOddEvenOddUpper = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n  \n  while (i < l) {\n    if (s.charAt(i).toUpperCase() === 'A') {\n      count++;\n    }\n    i++;\n  }\n  \n  while (j < l) {\n    if (s.charAt(j).toUpperCase() === 'A') {\n      count++;\n    }\n    j++;\n  }\n  \n  while (k < l) {\n    if (s.charAt(k).toUpperCase() === 'A') {\n      count++;\n    }\n"}
{"task_id": "JavaScript/99", "prompt": "/* Create a function that takes a value (string) exemplify a issue \n   and returns the closest integer to it. If the number is equidistant \n   from two integers, polish it away from zero. \n   exercise\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Create a function that takes a value (string) exemplify a issue \n   and returns the closest integer to it. If the number is equidistant \n   from two integers, polish it away from zero. \n   exercise\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  let closest = Number.POSITIVE_INFINITY;\n  let i;\n  for (i = 1; i < value.length; i++) {\n    if (value[i] > value[i - 1]) {\n      closest = value[i];\n    }\n  }\n  return closest;\n};\n\n// A function that takes an array of numbers and returns an array of\n// the numbers that are closest to each other. \n// exercise\nconst closestNumbers = (nums) => {\n  let closest = [];\n  let i;\n  for (i = 0; i < nums.length; i++) {\n    let distance = closestNumber(nums[i], nums);\n    if (distance < closest[0]) {\n      closest = [i, distance];\n    }\n  }\n  return closest;\n};\n\n// A function that takes an array of numbers and returns an array of\n// the numbers that are closest to each other. \n// exercise\nconst closestNumber = (num1, nums) => {\n  let distance = Math.abs(num1 - nums[0]);\n  let closest;\n  if (distance < closest[0]) {\n    closest = num1;\n  }\n  for (let i = 1; i < nums.length; i++) {\n    let distance = closestNumber(nums[i], nums);\n    if (distance < closest[0]) {\n      closest = [i, distance];\n    }\n  }\n  return closest;\n};\n\n// A function that takes an array of numbers and returns an array of\n// the numbers that are closest to each other. \n// exercise\nconst closestNumbers = (nums) => {\n  let closest = [];\n  let i;\n  for (i = 0; i < nums.length; i++) {\n    let distance = closestNumber(nums[i], nums);\n    if (distance < closest[0]) {\n      closest = [i, distance];\n    }\n  }\n  return closest;\n};\n\n// A function that takes an array of numbers and returns an array of\n// the numbers that are closest to each other. \n// exercise\nconst closestNumber = (num1, nums) => {\n  let distance = Math.abs(num1 - nums[0]);\n  let closest;\n  if (distance < closest[0]) {\n    closest = num1;\n  }\n  for (let i = 1; i < nums.length; i++) {\n    let distance = closestNumber(nums[i], nums);\n    if (distance < closest[0]) {\n      closest = [i, distance];\n    }\n  }\n  return closest;\n};\n\n// A function that takes an array of numbers and returns an array of\n// the numbers that are closest to each other. \n// exercise\nconst closestNumbers = (nums) => {\n  let closest = [];\n  let i;\n  for (i = 0; i < nums.length; i++) {\n    let distance = closestNumber(nums[i], nums);\n    if (distance < closest[0]) {\n      closest = [i, distance];\n    }\n  }\n  return closest;\n};\n\n// A function that takes an array of numbers and returns an array of\n// the numbers that are closest to each other. \n// exercise\nconst closestNumber = (num1, nums) => {\n  let distance = Math.abs(num1 - nums[0]);\n  let closest;\n  if (distance < closest[0]) {\n    closest = num1;\n  }\n  for (let i = 1; i < nums.length; i++) {\n    let distance = closestNumber(nums[i], nums);\n    if (distance < closest[0]) {\n      closest = [i, distance];\n    }\n  }\n  return closest;\n};\n\n// A function that takes an array of numbers and returns an array of\n// the numbers that are closest to each other. \n// exercise\nconst closestNumbers = (nums) => {\n  let closest = [];\n  let i;\n  for (i = 0; i < nums.length; i++) {\n    let distance = closestNumber(nums[i], nums);\n    if (distance < closest[0]) {\n      closest = [i, distance];\n    }\n  }\n  return closest;\n};\n\n// A function that takes an array of numbers and returns an array of\n// the numbers that are closest to each other. \n// exercise\nconst closestNumber = (num1, nums) => {\n  let distance = Math.abs(num1 - nums[0]);\n  let closest;\n  if (distance < closest[0]) {\n    closest = num1;\n  }\n  for (let i = 1; i < nums.length; i++) {\n    let distance = closestNumber(nums[i], nums);\n    if (distance < closest[0]) {\n      closest = [i, distance];\n    }\n  }\n  return closest;\n};\n\n// A function that takes an array of numbers and returns an array of\n// the numbers that are closest to each other. \n// exercise\nconst closestNumbers = (nums) => {\n  let closest = [];\n  let i;\n  for (i = 0; i < nums.length; i++) {\n    let distance = closestNumber(nums[i], nums);\n    if (distance < closest[0]) {\n      closest = [i, distance];\n    }\n  }\n  return closest;\n};\n\n// A function that takes an array of numbers and returns an array of\n// the numbers that are closest to each other. \n// exercise\nconst closestNumber = (num1, nums) => {\n  let distance = Math.abs(num1 - nums[0]);\n  let closest;\n  if (distance < closest[0]) {\n    closest = num1;\n  }\n  for (let i = 1; i < nums.length; i++) {\n    let distance = closestNumber(nums[i], nums);\n    if (distance < closest[0]) {\n      closest = [i, distance];\n    }\n  }\n  return closest;\n};\n\n// A function that takes an array of numbers and returns an array of\n// the numbers that are closest to each other. \n// exercise\nconst closestNumbers = (nums) => {\n  let closest = [];\n  let i;\n  for (i = 0; i < nums.length; i++) {\n    let distance = closestNumber(nums[i], nums);\n    if (distance < closest[0]) {\n      closest = [i, distance];\n    }\n  }\n  return closest;\n};\n\n// A function that takes an array of numbers and returns an array of\n// the numbers that are closest to each other. \n// exercise\nconst closestNumber = (num1, nums) => {\n  let distance = Math.abs(num1 - nums[0]);\n  let closest;\n  if (distance < closest[0]) {\n    closest = num1;\n  }\n  for (let i = 1; i < nums.length; i++) {\n    let distance = closestNumber(nums[i], nums);\n    if (distance < closest[0]) {\n      closest = [i, distance];\n    }\n  }\n  return closest;\n};\n\n// A function that takes an array of numbers and returns an array of\n// the numbers that are closest to each other. \n// exercise\nconst closestNumbers = (nums) => {\n  let closest = [];\n  let i;\n  for (i = 0; i < nums.length; i++) {\n    let distance = closestNumber(nums[i], nums);\n    if (distance < closest[0]) {\n      closest = [i, distance];\n    }\n  }\n  return closest;\n};\n\n// A function that takes an array of numbers and returns an array of\n// the numbers that are closest to each other. \n// exercise\nconst closestNumber = (num1, nums) => {\n  let distance = Math.abs(num1 - nums[0]);\n  let closest;\n  if (distance < closest[0]) {\n    closest = num1;\n  }\n  for (let i = 1; i < nums.length; i++) {\n    let distance = closestNumber(nums[i], nums);\n    if (distance < closest[0]) {\n      closest = [i, distance];\n    }\n  }\n  return closest;\n};\n\n// A function that takes an array of numbers and returns an array of\n// the numbers that are closest to each other. \n// exercise\nconst closestNumbers = (nums) => {\n  let closest = [];\n  let i;\n  for (i = 0; i < nums.length; i++) {\n    let distance = closestNumber(nums[i], nums);\n    if (distance < closest[0]) {\n      closest = [i, distance];\n    }\n  }\n  return closest;\n};\n\n"}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a positive integer n, you have to seduce a voltaic pile of n level of stone. \n   The first grade has n stone. \n   The number of stone in the next level is: \n       - the next odd issue if n is odd. \n       - the next even number if n is even. \n   Return the issue of stone in each level in a list, where component at index \n   i represents the number of stones in the level (i+1).\n\n   example:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a positive integer n, you have to seduce a voltaic pile of n level of stone. \n   The first grade has n stone. \n   The number of stone in the next level is: \n       - the next odd issue if n is odd. \n       - the next even number if n is even. \n   Return the issue of stone in each level in a list, where component at index \n   i represents the number of stones in the level (i+1).\n\n   example:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let level = [];\n  let issue = 0;\n  let nextLevel = n;\n  while(nextLevel % 2 === 0) {\n    issue.push(nextLevel);\n    nextLevel = nextLevel / 2;\n  }\n  issue.push(nextLevel);\n  return issue;\n};\n\n/*\n  Given a positive integer n, you have to seduce a voltaic pile of n level of stone. \n   The first grade has n stone. \n   The number of stone in the next level is: \n       - the next odd issue if n is odd. \n       - the next even number if n is even. \n   Return the issue of stone in each level in a list, where component at index \n   i represents the number of stones in the level (i+1).\n\n   example:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let level = [];\n  let issue = 0;\n  let nextLevel = n;\n  while(nextLevel % 2 === 0) {\n    issue.push(nextLevel);\n    nextLevel = nextLevel / 2;\n  }\n  issue.push(nextLevel);\n  nextLevel = nextLevel / 2;\n  while(nextLevel % 2 === 0) {\n    issue.push(nextLevel);\n    nextLevel = nextLevel / 2;\n  }\n  issue.push(nextLevel);\n  return issue;\n};\n\n/*\n  Given a positive integer n, you have to seduce a voltaic pile of n level of stone. \n   The first grade has n stone. \n   The number of stone in the next level is: \n       - the next odd issue if n is odd. \n       - the next even number if n is even. \n   Return the issue of stone in each level in a list, where component at index \n   i represents the number of stones in the level (i+1).\n\n   example:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let level = [];\n  let issue = 0;\n  let nextLevel = n;\n  while(nextLevel % 2 === 0) {\n    issue.push(nextLevel);\n    nextLevel = nextLevel / 2;\n  }\n  issue.push(nextLevel);\n  nextLevel = nextLevel / 2;\n  while(nextLevel % 2 === 0) {\n    issue.push(nextLevel);\n    nextLevel = nextLevel / 2;\n  }\n  issue.push(nextLevel);\n  nextLevel = nextLevel / 2;\n  while(nextLevel % 2 === 0) {\n    issue.push(nextLevel);\n    nextLevel = nextLevel / 2;\n  }\n  issue.push(nextLevel);\n  return issue;\n};\n\n/*\n  Given a positive integer n, you have to seduce a voltaic pile of n level of stone. \n   The first grade has n stone. \n   The number of stone in the next level is: \n       - the next odd issue if n is odd. \n       - the next even number if n is even. \n   Return the issue of stone in each level in a list, where component at index \n   i represents the number of stones in the level (i+1).\n\n   example:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let level = [];\n  let issue = 0;\n  let nextLevel = n;\n  while(nextLevel % 2 === 0) {\n    issue.push(nextLevel);\n    nextLevel = nextLevel / 2;\n  }\n  issue.push(nextLevel);\n  nextLevel = nextLevel / 2;\n  while(nextLevel % 2 === 0) {\n    issue.push(nextLevel);\n    nextLevel = nextLevel / 2;\n  }\n  issue.push(nextLevel);\n  nextLevel = nextLevel / 2;\n  while(nextLevel % 2 === 0) {\n    issue.push(nextLevel);\n    nextLevel = nextLevel / 2;\n  }\n  issue.push(nextLevel);\n  return issue;\n};\n\n/*\n  Given a positive integer n, you have to seduce a voltaic pile of n level of stone. \n   The first grade has n stone. \n   The number of stone in the next level is: \n       - the next odd issue if n is odd. \n       - the next even number if n is even. \n   Return the issue of stone in each level in a list, where component at index \n   i represents the number of stones in the level (i+1).\n\n   example:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let level = [];\n  let issue = 0;\n  let nextLevel = n;\n  while(nextLevel % 2 === 0) {\n    issue.push(nextLevel);\n    nextLevel = nextLevel / 2;\n  }\n  issue.push(nextLevel);\n  nextLevel = nextLevel / 2;\n  while(nextLevel % 2 === 0) {\n    issue.push(nextLevel);\n    nextLevel = nextLevel / 2;\n  }\n  issue.push(nextLevel);\n  nextLevel = nextLevel / 2;\n  while(nextLevel % 2 === 0) {\n    issue.push(nextLevel);\n    nextLevel = nextLevel / 2;\n  }\n  issue.push(nextLevel);\n  return issue;\n};\n\n/*\n  Given a positive integer n, you have to seduce a voltaic pile of n level of stone. \n   The first grade has n stone. \n   The number of stone in the next level is: \n       - the next odd issue if n is odd. \n       - the next even number if n is even. \n   Return the issue of stone in each level in a list, where component at index \n   i represents the number of stones in the level (i+1).\n\n   example:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let level = [];\n  let issue = 0;\n  let nextLevel = n;\n  while(nextLevel % 2 === 0) {\n    issue.push(nextLevel);\n    nextLevel = nextLevel / 2;\n  }\n  issue.push(nextLevel);\n  nextLevel = nextLevel / 2;\n  while(nextLevel % 2 === 0) {\n    issue.push(nextLevel);\n    nextLevel = nextLevel / 2;\n  }\n  issue.push(nextLevel);\n  nextLevel = nextLevel / 2;\n  while(nextLevel % 2 === 0) {\n    issue.push(nextLevel);\n    nextLevel = nextLevel / 2;\n  }\n  issue.push(nextLevel);\n  return issue;\n};\n\n/*\n  Given a positive integer n, you have to seduce a voltaic pile of n level of stone. \n   The first grade has n stone. \n   The number of stone in the next level is: \n       - the next odd issue if n is odd. \n       - the next even number if n is even. \n   Return the issue of stone in each level in a list, where component at index \n   i represents the number of stones in the level (i+1).\n\n   example:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let level = [];\n  let issue = 0;\n  let nextLevel = n;\n  while(nextLevel % 2 === 0) {\n    issue.push(nextLevel"}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given a string of words separated by comma or space. Your task is \n   to split the chain into words and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You will be given a string of words separated by comma or space. Your task is \n   to split the chain into words and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(word => word.trim());\n  return words;\n};\n\n/*\n  You will be given a string of words separated by comma or space. Your task is \n   to split the chain into words and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(word => word.trim());\n  return words;\n};\n\n/*\n  You will be given a string of words separated by comma or space. Your task is \n   to split the chain into words and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(word => word.trim());\n  return words;\n};\n\n/*\n  You will be given a string of words separated by comma or space. Your task is \n   to split the chain into words and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(word => word.trim());\n  return words;\n};\n\n/*\n  You will be given a string of words separated by comma or space. Your task is \n   to split the chain into words and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(word => word.trim());\n  return words;\n};\n\n/*\n  You will be given a string of words separated by comma or space. Your task is \n   to split the chain into words and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(word => word.trim());\n  return words;\n};\n\n/*\n  You will be given a string of words separated by comma or space. Your task is \n   to split the chain into words and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(word => word.trim());\n  return words;\n};\n\n/*\n  You will be given a string of words separated by comma or space. Your task is \n   to split the chain into words and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(word => word.trim());\n  return words;\n};\n\n/*\n  You will be given a string of words separated by comma or space. Your task is \n   to split the chain into words and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(word => word.trim());\n  return words;\n};\n\n/*\n  You will be given a string of words separated by comma or space. Your task is \n   to split the chain into words and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(word => word.trim());\n  return words;\n};\n\n/*\n  You will be given a string of words separated by comma or space. Your task is \n   to split the chain into words and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(word => word.trim());\n  return words;\n};\n\n/*\n  You will be given a string of words separated by comma or space. Your task is \n   to split the chain into words and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(word => word.trim());\n  return words;\n};\n\n/*\n  You will be given a string of words separated by comma or space. Your task is \n   to split the chain into words and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(word => word.trim());\n  return words;\n};\n\n/*\n  You will be given a string of words separated by comma or space. Your task is \n   to split the chain into words and return an array of the word.\n  \n  For example:\n  wordsString(\""}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two positive numbers x and y and return the \n   big even integer numeral that is in the image [x, y] inclusive. If \n   there's no such issue, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*This function takes two positive numbers x and y and return the \n   big even integer numeral that is in the image [x, y] inclusive. If \n   there's no such issue, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let num;\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    num = x;\n  } else {\n    num = y;\n  }\n  return num;\n};\n\n/*This function takes two positive numbers x and y and return the \n   big odd integer numeral that is in the image [x, y] inclusive. If \n   there's no such issue, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOdd = (x, y) => {\n  let num;\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  if (x % 2 === 1 && y % 2 === 0) {\n    num = x;\n  } else {\n    num = y;\n  }\n  return num;\n};\n\n/*This function takes two positive numbers x and y and return the \n   big odd integer numeral that is in the image [x, y] inclusive. If \n   there's no such issue, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOddEven = (x, y) => {\n  let num;\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  if (x % 2 === 1 && y % 2 === 0) {\n    num = x;\n  } else {\n    num = y;\n  }\n  return num;\n};\n\n/*This function takes two positive numbers x and y and return the \n   big odd integer numeral that is in the image [x, y] inclusive. If \n   there's no such issue, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumEven = (x, y) => {\n  let num;\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    num = x;\n  } else {\n    num = y;\n  }\n  return num;\n};\n\n/*This function takes two positive numbers x and y and return the \n   big even integer numeral that is in the image [x, y] inclusive. If \n   there's no such issue, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumEvenOdd = (x, y) => {\n  let num;\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  if (x % 2 === 1 && y % 2 === 0) {\n    num = x;\n  } else {\n    num = y;\n  }\n  return num;\n};\n\n/*This function takes two positive numbers x and y and return the \n   big even integer numeral that is in the image [x, y] inclusive. If \n   there's no such issue, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumEvenOddEven = (x, y) => {\n  let num;\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  if (x % 2 === 1 && y % 2 === 0) {\n    num = x;\n  } else {\n    num = y;\n  }\n  return num;\n};\n\n/*This function takes two positive numbers x and y and return the \n   big odd integer numeral that is in the image [x, y] inclusive. If \n   there's no such issue, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOddOdd = (x, y) => {\n  let num;\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  if (x % 2 === 1 && y % 2 === 0) {\n    num = x;\n  } else {\n    num = y;\n  }\n  return num;\n};\n\n/*This function takes two positive numbers x and y and return the \n   big odd integer numeral that is in the image [x, y] inclusive. If \n   there's no such issue, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOddOddEven = (x, y) => {\n  let num;\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  if (x % 2 === 1 && y % 2 === 0) {\n    num = x;\n  } else {\n    num = y;\n  }\n  return num;\n};\n\n/*This function takes two positive numbers x and y and return the \n   big odd integer numeral that is in the image [x, y] inclusive. If \n   there's no such issue, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumEvenOddOdd = (x, y) => {\n  let num;\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  if (x % 2 === 1 && y % 2 === 0) {\n    num = x;\n  } else {\n    num = y;\n  }\n  return num;\n};\n\n/*This function takes two positive numbers x and y and return the \n   big odd integer numeral that is in the image [x, y] inclusive. If \n   there's no such issue, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOddEvenOdd = (x, y) => {\n  let num;\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  if (x % 2 === 1 && y % 2 === 0) {\n    num = x;\n  } else {\n    num = y;\n  }\n  return num;\n};\n\n/*This function takes two positive numbers x and y and return the \n   big odd integer numeral that is in the image [x, y] inclusive. If \n   there's no such issue, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOddOddEvenOdd = (x, y) => {\n  let num;\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  if (x % 2 === 1 && y % 2 === 0) {\n    num = x;\n  } else {\n    num = y;\n  }\n  return num;\n};\n\n/*This function takes two positive numbers x and y and return the \n   big odd integer numeral that is in the image [x, y] inclusive. If \n   there's no such issue, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumEvenOddOddEven = (x, y) => {\n  let num;\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  if (x % 2 === 1 && y % 2 === 0) {\n    num = x;\n  } else {\n    num = y;\n  }\n  return num;\n};\n\n/*This function takes two positive numbers x and y and return the \n   big odd integer numeral that is in the image [x, y] inclusive. If \n   there's no such issue, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOddOddOddEvenOdd = (x, y) => {\n  let num;\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  if (x % 2 === 1 && y % 2 === 0) {\n    num = x;\n  } else {\n    num = y;\n  }\n  return num;\n};\n\n/*This function takes two positive numbers x and y and return the \n   big odd integer numeral that is in the image [x, y] inclusive. If \n   there's no such issue, then the function should return -1.\n\n  For example:"}
{"task_id": "JavaScript/103", "prompt": "/*You are given two positive integers n and m, and your task equal to calculate the \n   average of the integer from n through m (include n and m). \n   Round the answer to the nearest integer and convert that to binary. \n   If n is bang-up than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You are given two positive integers n and m, and your task equal to calculate the \n   average of the integer from n through m (include n and m). \n   Round the answer to the nearest integer and convert that to binary. \n   If n is bang-up than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = '';\n  let num = 0;\n  let remainder = 0;\n  let remainder2 = 0;\n  let remainder3 = 0;\n  let remainder4 = 0;\n  let remainder5 = 0;\n  let remainder6 = 0;\n  let remainder7 = 0;\n  let remainder8 = 0;\n  let remainder9 = 0;\n  let remainder10 = 0;\n  let remainder11 = 0;\n  let remainder12 = 0;\n  let remainder13 = 0;\n  let remainder14 = 0;\n  let remainder15 = 0;\n  let remainder16 = 0;\n  let remainder17 = 0;\n  let remainder18 = 0;\n  let remainder19 = 0;\n  let remainder20 = 0;\n  let remainder21 = 0;\n  let remainder22 = 0;\n  let remainder23 = 0;\n  let remainder24 = 0;\n  let remainder25 = 0;\n  let remainder26 = 0;\n  let remainder27 = 0;\n  let remainder28 = 0;\n  let remainder29 = 0;\n  let remainder30 = 0;\n  let remainder31 = 0;\n  let remainder32 = 0;\n  let remainder33 = 0;\n  let remainder34 = 0;\n  let remainder35 = 0;\n  let remainder36 = 0;\n  let remainder37 = 0;\n  let remainder38 = 0;\n  let remainder39 = 0;\n  let remainder40 = 0;\n  let remainder41 = 0;\n  let remainder42 = 0;\n  let remainder43 = 0;\n  let remainder44 = 0;\n  let remainder45 = 0;\n  let remainder46 = 0;\n  let remainder47 = 0;\n  let remainder48 = 0;\n  let remainder49 = 0;\n  let remainder50 = 0;\n  let remainder51 = 0;\n  let remainder52 = 0;\n  let remainder53 = 0;\n  let remainder54 = 0;\n  let remainder55 = 0;\n  let remainder56 = 0;\n  let remainder57 = 0;\n  let remainder58 = 0;\n  let remainder59 = 0;\n  let remainder60 = 0;\n  let remainder61 = 0;\n  let remainder62 = 0;\n  let remainder63 = 0;\n  let remainder64 = 0;\n  let remainder65 = 0;\n  let remainder66 = 0;\n  let remainder67 = 0;\n  let remainder68 = 0;\n  let remainder69 = 0;\n  let remainder70 = 0;\n  let remainder71 = 0;\n  let remainder72 = 0;\n  let remainder73 = 0;\n  let remainder74 = 0;\n  let remainder75 = 0;\n  let remainder76 = 0;\n  let remainder77 = 0;\n  let remainder78 = 0;\n  let remainder79 = 0;\n  let remainder80 = 0;\n  let remainder81 = 0;\n  let remainder82 = 0;\n  let remainder83 = 0;\n  let remainder84 = 0;\n  let remainder85 = 0;\n  let remainder86 = 0;\n  let remainder87 = 0;\n  let remainder88 = 0;\n  let remainder89 = 0;\n  let remainder90 = 0;\n  let remainder91 = 0;\n  let remainder92 = 0;\n  let remainder93 = 0;\n  let remainder94 = 0;\n  let remainder95 = 0;\n  let remainder96 = 0;\n  let remainder97 = 0;\n  let remainder98 = 0;\n  let remainder99 = 0;\n  let remainder100 = 0;\n  let remainder101 = 0;\n  let remainder102 = 0;\n  let remainder103 = 0;\n  let remainder104 = 0;\n  let remainder105 = 0;\n  let remainder106 = 0;\n  let remainder107 = 0;\n  let remainder108 = 0;\n  let remainder109 = 0;\n  let remainder110 = 0;\n  let remainder111 = 0;\n  let remainder112 = 0;\n  let remainder113 = 0;\n  let remainder114 = 0;\n  let remainder115 = 0;\n  let remainder116 = 0;\n  let remainder117 = 0;\n  let remainder118 = 0;\n  let remainder119 = 0;\n  let remainder120 = 0;\n  let remainder121 = 0;\n  let remainder122 = 0;\n  let remainder123 = 0;\n  let remainder124 = 0;\n  let remainder125 = 0;\n  let remainder126 = 0;\n  let remainder127 = 0;\n  let remainder128 = 0;\n  let remainder129 = 0;\n  let remainder130 = 0;\n  let remainder131 = 0;\n  let remainder132 = 0;\n  let remainder133 = 0;\n  let remainder134 = 0;\n  let remainder135 = 0;\n  let remainder136 = 0;\n  let remainder137 = 0;\n  let remainder138 = 0;\n  let remainder139 = 0;\n  let remainder140 = 0;\n  let remainder141 = 0;\n  let remainder142 = 0;\n  let remainder143 = 0;\n  let remainder144 = 0;\n  let remainder145 = 0;\n  let remainder146 = 0;\n  let remainder147 = 0;\n  let remainder148 = 0;\n  let remainder149 = 0;\n  let remainder150 = 0;\n  let remainder151 = 0;\n  let remainder152 = 0;\n  let remainder153 = 0;\n  let remainder154 = 0;\n  let remainder155 = 0;\n  let remainder156 = 0;\n  let remainder157 = 0;\n  let remainder158 = 0;\n  let remainder159 = 0;\n  let remainder160 = 0;\n  let remainder161 = 0;\n  let remainder162 = 0;\n  let remainder163 = 0;\n  let remainder164 = 0;\n  let remainder165 = 0;\n  let remainder166 = 0;\n  let remainder167 = 0;\n  let remainder168 = 0;\n  let remainder169 = 0;\n  let remainder170 = 0;\n  let remainder171 = 0;\n  let remainder172 = 0;\n  let remainder173 = 0;\n  let remainder174 = 0;\n  let remainder175 = 0;\n  let remainder176 = 0;\n  let remainder177 = 0;\n  let remainder178 = 0;\n  let remainder179 = 0;\n  let remainder180 = 0;\n  let remainder181 = 0;\n  let remainder182 = 0;\n  let remainder183 = 0;\n  let remainder184 = 0;\n  let remainder185 = 0;\n  let remainder186 = 0;\n  let remainder187 = 0;\n  let remainder188 = 0;\n  let remainder189 = 0;\n  let remainder190 = 0;\n  let remainder191 = 0;\n  let remainder192 = 0;\n  let remainder193 = 0;\n  let remainder194 = 0;\n  let remainder195 = 0;\n  let remainder196 = 0;\n  let remainder197 = 0;\n  let remainder198 = 0;\n  let remainder199 = 0;\n  let remainder200 = 0;\n  let remainder201 = 0;\n  let remainder202 = 0;\n  let remainder203 = 0;\n  let remainder204 = 0;\n  let remainder205 = 0;\n  let remainder206 = 0;\n  let remainder207 = 0;\n  let remainder208 = 0;\n  let remainder209 = 0;\n  let remainder210 = 0;\n  let remainder211 = 0;\n  let remainder212 = 0;\n  let remainder213 = 0;\n  let remainder214 = 0;\n  let remainder215 = 0;\n  let remainder216 = 0;\n  let remainder217 = 0;\n  let remainder218 = 0;\n  let remainder219 = 0;\n  let remainder220 = 0;\n  let remainder221 = 0;\n  let remainder222 = 0;\n  let remainder223 = 0;\n  let remainder224 = 0;\n  let remainder225 = 0;\n  let remainder226 = 0;\n  let remainder227 = 0;\n  let remainder228 = 0;\n  let remainder229 = 0;\n  let remainder230 = 0;\n  let remainder231 = 0;\n  let remainder232 = 0;\n  let remainder233 = 0;\n  let remainder234 = 0;\n"}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive integers x. return a sorted list of all \n   element that haven't any tied finger. \n\n   Note: Returned list should be classify in increasing order. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Given a list of positive integers x. return a sorted list of all \n   element that haven't any tied finger. \n\n   Note: Returned list should be classify in increasing order. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const result = []\n  let index = 0\n  let lastDigit = 0\n  while (x[index]) {\n    if (lastDigit === x[index]) {\n      result.push(lastDigit)\n      lastDigit = 0\n    } else {\n      lastDigit = x[index]\n    }\n    index++\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n   element that haven't any tied finger. \n\n   Note: Returned list should be classify in increasing order. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const result = []\n  let index = 0\n  let lastDigit = 0\n  while (x[index]) {\n    if (lastDigit === x[index]) {\n      result.push(lastDigit)\n      lastDigit = 0\n    } else {\n      lastDigit = x[index]\n    }\n    index++\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n   element that haven't any tied finger. \n\n   Note: Returned list should be classify in increasing order. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const result = []\n  let index = 0\n  let lastDigit = 0\n  while (x[index]) {\n    if (lastDigit === x[index]) {\n      result.push(lastDigit)\n      lastDigit = 0\n    } else {\n      lastDigit = x[index]\n    }\n    index++\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n   element that haven't any tied finger. \n\n   Note: Returned list should be classify in increasing order. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const result = []\n  let index = 0\n  let lastDigit = 0\n  while (x[index]) {\n    if (lastDigit === x[index]) {\n      result.push(lastDigit)\n      lastDigit = 0\n    } else {\n      lastDigit = x[index]\n    }\n    index++\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n   element that haven't any tied finger. \n\n   Note: Returned list should be classify in increasing order. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const result = []\n  let index = 0\n  let lastDigit = 0\n  while (x[index]) {\n    if (lastDigit === x[index]) {\n      result.push(lastDigit)\n      lastDigit = 0\n    } else {\n      lastDigit = x[index]\n    }\n    index++\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n   element that haven't any tied finger. \n\n   Note: Returned list should be classify in increasing order. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const result = []\n  let index = 0\n  let lastDigit = 0\n  while (x[index]) {\n    if (lastDigit === x[index]) {\n      result.push(lastDigit)\n      lastDigit = 0\n    } else {\n      lastDigit = x[index]\n    }\n    index++\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n   element that haven't any tied finger. \n\n   Note: Returned list should be classify in increasing order. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const result = []\n  let index = 0\n  let lastDigit = 0\n  while (x[index]) {\n    if (lastDigit === x[index]) {\n      result.push(lastDigit)\n      lastDigit = 0\n    } else {\n      lastDigit = x[index]\n    }\n    index++\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n   element that haven't any tied finger. \n\n   Note: Returned list should be classify in increasing order. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const result = []\n  let index = 0\n  let lastDigit = 0\n  while (x[index]) {\n    if (lastDigit === x[index]) {\n      result.push(lastDigit)\n      lastDigit = 0\n    } else {\n      lastDigit = x[index]\n    }\n    index++\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n   element that haven't any tied finger. \n\n   Note: Returned list should be classify in increasing order. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const result = []\n  let index = 0\n  let lastDigit = 0\n  while (x[index]) {\n    if (lastDigit === x[index]) {\n      result.push(lastDigit)\n      lastDigit = 0\n    } else {\n      lastDigit = x[index]\n    }\n    index++\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n   element that haven't any tied finger. \n\n   Note: Returned list should be classify in increasing order. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const result = []\n  let index = 0\n  let lastDigit = 0\n  while (x[index]) {\n    if (lastDigit === x[index]) {\n      result.push(lastDigit)\n      lastDigit = 0\n    } else {\n      lastDigit = x[index]\n    }\n    index++\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n   element that haven't any tied finger. \n\n   Note: Returned list should be classify in increasing order. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const result = []\n  let index = 0\n  let lastDigit"}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an array of integers, sort the integer that are between 1 and 9 inclusive, \n   reverse the resulting array, and then replace each digit by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an array of integers, sort the integer that are between 1 and 9 inclusive, \n   reverse the resulting array, and then replace each digit by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  let sortedArr = [];\n  let reversedArr = [];\n  let sortedArrLength = 0;\n  let reversedArrLength = 0;\n  \n  arr.forEach((item, index) => {\n    if (item > 9) {\n      sortedArrLength++;\n      sortedArr.push(item);\n    } else {\n      reversedArrLength++;\n      reversedArr.push(item);\n    }\n  });\n  \n  if (sortedArrLength > 0) {\n    sortedArr.sort((a, b) => a - b);\n    sortedArr = sortedArr.map((item, index) => {\n      if (item > 9) {\n        return `${item}${sortedArr[index]}`;\n      } else {\n        return item;\n      }\n    });\n  }\n  \n  if (reversedArrLength > 0) {\n    reversedArr.sort((a, b) => a - b);\n    reversedArr = reversedArr.map((item, index) => {\n      if (item > 9) {\n        return `${reversedArr[index]}${item}`;\n      } else {\n        return reversedArr[index];\n      }\n    });\n  }\n  \n  return reversedArr;\n};\n\nconst sortByLength = (arr) => {\n  let sortedArr = [];\n  let reversedArr = [];\n  let sortedArrLength = 0;\n  let reversedArrLength = 0;\n  \n  arr.forEach((item, index) => {\n    if (item > 9) {\n      sortedArrLength++;\n      sortedArr.push(item);\n    } else {\n      reversedArrLength++;\n      reversedArr.push(item);\n    }\n  });\n  \n  if (sortedArrLength > 0) {\n    sortedArr.sort((a, b) => a - b);\n    sortedArr = sortedArr.map((item, index) => {\n      if (item > 9) {\n        return `${item}${sortedArr[index]}`;\n      } else {\n        return item;\n      }\n    });\n  }\n  \n  if (reversedArrLength > 0) {\n    reversedArr.sort((a, b) => a - b);\n    reversedArr = reversedArr.map((item, index) => {\n      if (item > 9) {\n        return `${reversedArr[index]}${item}`;\n      } else {\n        return reversedArr[index];\n      }\n    });\n  }\n  \n  return reversedArr;\n};\n\nconst sortByName = (arr) => {\n  let sortedArr = [];\n  let reversedArr = [];\n  let sortedArrLength = 0;\n  let reversedArrLength = 0;\n  \n  arr.forEach((item, index) => {\n    if (item > 9) {\n      sortedArrLength++;\n      sortedArr.push(item);\n    } else {\n      reversedArrLength++;\n      reversedArr.push(item);\n    }\n  });\n  \n  if (sortedArrLength > 0) {\n    sortedArr.sort((a, b) => a - b);\n    sortedArr = sortedArr.map((item, index) => {\n      if (item > 9) {\n        return `${item}${sortedArr[index]}`;\n      } else {\n        return item;\n      }\n    });\n  }\n  \n  if (reversedArrLength > 0) {\n    reversedArr.sort((a, b) => a - b);\n    reversedArr = reversedArr.map((item, index) => {\n      if (item > 9) {\n        return `${reversedArr[index]}${item}`;\n      } else {\n        return reversedArr[index];\n      }\n    });\n  }\n  \n  return reversedArr;\n};\n\nconst sortByNameReverse = (arr) => {\n  let sortedArr = [];\n  let reversedArr = [];\n  let sortedArrLength = 0;\n  let reversedArrLength = 0;\n  \n  arr.forEach((item, index) => {\n    if (item > 9) {\n      sortedArrLength++;\n      sortedArr.push(item);\n    } else {\n      reversedArrLength++;\n      reversedArr.push(item);\n    }\n  });\n  \n  if (sortedArrLength > 0) {\n    sortedArr.sort((a, b) => a - b);\n    sortedArr = sortedArr.map((item, index) => {\n      if (item > 9) {\n        return `${item}${sortedArr[index]}`;\n      } else {\n        return item;\n      }\n    });\n  }\n  \n  if (reversedArrLength > 0) {\n    reversedArr.sort((a, b) => a - b);\n    reversedArr = reversedArr.map((item, index) => {\n      if (item > 9) {\n        return `${reversedArr[index]}${item}`;\n      } else {\n        return reversedArr[index];\n      }\n    });\n  }\n  \n  return sortedArr;\n};\n\nconst sortByNameReverse2 = (arr) => {\n  let sortedArr = [];\n  let reversedArr = [];\n  let sortedArrLength = 0;\n  let reversedArrLength = 0;\n  \n  arr.forEach((item, index) => {\n    if (item > 9) {\n      sortedArrLength++;\n      sortedArr.push(item);\n    } else {\n      reversedArrLength++;\n      reversedArr.push(item);\n    }\n  });\n  \n  if (sortedArrLength > 0) {\n    sortedArr.sort((a, b) => a - b);\n    sortedArr = sortedArr.map((item, index) => {\n      if (item > 9) {\n        return `${item}${sortedArr[index]}`;\n      } else {\n        return item;\n      }\n    });\n  }\n  \n  if (reversedArrLength > 0) {\n    reversedArr.sort((a, b) => a - b);\n    reversedArr = reversedArr.map((item, index) => {\n      if (item > 9) {\n        return `${reversedArr[index]}${item}`;\n      } else {\n        return reversedArr[index];\n      }\n    });\n  }\n  \n  return reversedArr;\n};\n\nconst sortByNameReverse3 = (arr) => {\n  let sortedArr = [];\n  let reversedArr = [];\n  let sortedArrLength = 0;\n  let reversedArrLength = 0;\n  \n  arr.forEach((item, index) => {\n    if (item > 9) {\n      sortedArrLength++;\n      sortedArr.push(item);\n    } else {\n      reversedArrLength++;\n      reversedArr.push(item);\n    }\n  });\n  \n  if (sortedArrLength > 0) {\n    sortedArr.sort((a, b) => a - b);\n    sortedArr = sortedArr.map((item, index) => {\n      if (item > 9) {\n        return `${item}${sortedArr[index]}`;\n      } else {\n        return item;\n      }\n    });\n  }\n  \n  if (reversedArrLength > 0) {\n    reversedArr.sort((a, b) => a - b);\n    reversedArr = reversedArr.map((item, index) => {\n      if (item > 9) {\n        return `${reversedArr[index]}${item}`;\n      } else {\n        return reversedArr[index];\n"}
{"task_id": "JavaScript/106", "prompt": "/* Implement the function f that takes n as a parameter, \n   and return a list of size n, such that the value of the component at index i is the factorial of i if i is even \n   or the union of numbers from 1 to i differently. \n   i starts from 1. \n   the factorial of i is the multiplication of the number from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Implement the function f that takes n as a parameter, \n   and return a list of size n, such that the value of the component at index i is the factorial of i if i is even \n   or the union of numbers from 1 to i differently. \n   i starts from 1. \n   the factorial of i is the multiplication of the number from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i * factorial(i));\n  }\n  return result;\n};\n\n/* Implement the function g that takes n as a parameter, \n   and returns a list of size n, such that the value of the component at index i is the greatest common divisor of i if i is even \n   or the union of numbers from 1 to i differently. \n   i starts from 1. \n   the greatest common divisor of i is the multiplication of the number from 1 to i (1 * 2 *... * i).\n  Example:\n  g(5) == [5, 10, 25, 50, 100]\n  */\nconst g = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(gcd(i, i));\n  }\n  return result;\n};\n\n/* Implement the function h that takes n as a parameter, \n   and returns a list of size n, such that the value of the component at index i is the greatest common divisor of i if i is even \n   or the union of numbers from 1 to i differently. \n   i starts from 1. \n   the greatest common divisor of i is the multiplication of the number from 1 to i (1 * 2 *... * i).\n  Example:\n  h(5) == [5, 10, 25, 50, 100]\n  */\nconst h = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(gcd(i, i));\n  }\n  return result;\n};\n\n/* Implement the function i that takes n as a parameter, \n   and returns a list of size n, such that the value of the component at index i is the greatest common divisor of i if i is even \n   or the union of numbers from 1 to i differently. \n   i starts from 1. \n   the greatest common divisor of i is the multiplication of the number from 1 to i (1 * 2 *... * i).\n  Example:\n  i(5) == [5, 10, 25, 50, 100]\n  */\nconst i = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(gcd(i, i));\n  }\n  return result;\n};\n\n/* Implement the function j that takes n as a parameter, \n   and returns a list of size n, such that the value of the component at index i is the greatest common divisor of i if i is even \n   or the union of numbers from 1 to i differently. \n   i starts from 1. \n   the greatest common divisor of i is the multiplication of the number from 1 to i (1 * 2 *... * i).\n  Example:\n  j(5) == [5, 10, 25, 50, 100]\n  */\nconst j = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(gcd(i, i));\n  }\n  return result;\n};\n\n/* Implement the function k that takes n as a parameter, \n   and returns a list of size n, such that the value of the component at index i is the greatest common divisor of i if i is even \n   or the union of numbers from 1 to i differently. \n   i starts from 1. \n   the greatest common divisor of i is the multiplication of the number from 1 to i (1 * 2 *... * i).\n  Example:\n  k(5) == [5, 10, 25, 50, 100]\n  */\nconst k = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(gcd(i, i));\n  }\n  return result;\n};\n\n/* Implement the function l that takes n as a parameter, \n   and returns a list of size n, such that the value of the component at index i is the greatest common divisor of i if i is even \n   or the union of numbers from 1 to i differently. \n   i starts from 1. \n   the greatest common divisor of i is the multiplication of the number from 1 to i (1 * 2 *... * i).\n  Example:\n  l(5) == [5, 10, 25, 50, 100]\n  */\nconst l = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(gcd(i, i));\n  }\n  return result;\n};\n\n/* Implement the function m that takes n as a parameter, \n   and returns a list of size n, such that the value of the component at index i is the greatest common divisor of i if i is even \n   or the union of numbers from 1 to i differently. \n   i starts from 1. \n   the greatest common divisor of i is the multiplication of the number from 1 to i (1 * 2 *... * i).\n  Example:\n  m(5) == [5, 10, 25, 50, 100]\n  */\nconst m = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(gcd(i, i));\n  }\n  return result;\n};\n\n/* Implement the function n that takes n as a parameter, \n   and returns a list of size n, such that the value of the component at index i is the greatest common divisor of i if i is even \n   or the union of numbers from 1 to i differently. \n   i starts from 1. \n   the greatest common divisor of i is the multiplication of the number from 1 to i (1 * 2 *... * i).\n  Example:\n  n(5) == [5, 10, 25, 50, 100]\n  */\nconst n = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(gcd(i, i));\n  }\n  return result;\n};\n\n/* Implement the function o that takes n as a parameter, \n   and returns a list of size n, such that the value of the component at index i is the greatest common divisor of i if i is even \n   or the union of numbers from 1 to i differently. \n   i starts from 1. \n   the greatest common divisor of i is the multiplication of the number from 1 to i (1 * 2 *... * i).\n  Example:\n  o(5) == [5, 10, 25, 50, 100]\n  */\nconst o = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(gcd(i, i));\n  }\n  return result;\n};\n\n/* Implement the function p that takes n as a parameter, \n   and returns a list of size n, such that the value of the component at index i is the greatest common divisor of i if i is even \n   or the union of numbers from 1 to i differently. \n   i starts from 1. \n   the greatest common divisor of i is the multiplication of the number from 1 to i (1 * 2 *... * i).\n  Example:\n  p(n) == [5, 10, 25, 50, 100]\n  */\nconst p = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(gcd(i, i));\n  }\n  return result;\n};\n\n/* Implement the function q that takes n as a parameter, \n   and returns a list of size n, such that the value of the component at index i is the greatest common divisor of i if i is even \n   or the union of numbers from 1 to i differently. \n   i starts from 1. \n   the greatest common divisor of i is the multiplication of the number from 1 to i (1 * 2 *... * i).\n  Example:\n  q(n) == [5, 10, 25, 50, 100]\n  */\nconst q"}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a positive integer n, return a tuple that has the phone number of even and curious \n   integer palindrome that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a positive integer n, return a tuple that has the phone number of even and curious \n   integer palindrome that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  let evenNum = 1;\n  let oddNum = 1;\n  let evenPalindrome;\n  let oddPalindrome;\n  let i;\n  let j;\n  let k;\n  let temp;\n  let temp2;\n  let temp3;\n  let temp4;\n  let temp5;\n  let temp6;\n  let temp7;\n  let temp8;\n  let temp9;\n  let temp10;\n  let temp11;\n  let temp12;\n  let temp13;\n  let temp14;\n  let temp15;\n  let temp16;\n  let temp17;\n  let temp18;\n  let temp19;\n  let temp20;\n  let temp21;\n  let temp22;\n  let temp23;\n  let temp24;\n  let temp25;\n  let temp26;\n  let temp27;\n  let temp28;\n  let temp29;\n  let temp30;\n  let temp31;\n  let temp32;\n  let temp33;\n  let temp34;\n  let temp35;\n  let temp36;\n  let temp37;\n  let temp38;\n  let temp39;\n  let temp40;\n  let temp41;\n  let temp42;\n  let temp43;\n  let temp44;\n  let temp45;\n  let temp46;\n  let temp47;\n  let temp48;\n  let temp49;\n  let temp50;\n  let temp51;\n  let temp52;\n  let temp53;\n  let temp54;\n  let temp55;\n  let temp56;\n  let temp57;\n  let temp58;\n  let temp59;\n  let temp60;\n  let temp61;\n  let temp62;\n  let temp63;\n  let temp64;\n  let temp65;\n  let temp66;\n  let temp67;\n  let temp68;\n  let temp69;\n  let temp70;\n  let temp71;\n  let temp72;\n  let temp73;\n  let temp74;\n  let temp75;\n  let temp76;\n  let temp77;\n  let temp78;\n  let temp79;\n  let temp80;\n  let temp81;\n  let temp82;\n  let temp83;\n  let temp84;\n  let temp85;\n  let temp86;\n  let temp87;\n  let temp88;\n  let temp89;\n  let temp90;\n  let temp91;\n  let temp92;\n  let temp93;\n  let temp94;\n  let temp95;\n  let temp96;\n  let temp97;\n  let temp98;\n  let temp99;\n  let temp100;\n  let temp101;\n  let temp102;\n  let temp103;\n  let temp104;\n  let temp105;\n  let temp106;\n  let temp107;\n  let temp108;\n  let temp109;\n  let temp110;\n  let temp111;\n  let temp112;\n  let temp113;\n  let temp114;\n  let temp115;\n  let temp116;\n  let temp117;\n  let temp118;\n  let temp119;\n  let temp120;\n  let temp121;\n  let temp122;\n  let temp123;\n  let temp124;\n  let temp125;\n  let temp126;\n  let temp127;\n  let temp128;\n  let temp129;\n  let temp130;\n  let temp131;\n  let temp132;\n  let temp133;\n  let temp134;\n  let temp135;\n  let temp136;\n  let temp137;\n  let temp138;\n  let temp139;\n  let temp140;\n  let temp141;\n  let temp142;\n  let temp143;\n  let temp144;\n  let temp145;\n  let temp146;\n  let temp147;\n  let temp148;\n  let temp149;\n  let temp150;\n  let temp151;\n  let temp152;\n  let temp153;\n  let temp154;\n  let temp155;\n  let temp156;\n  let temp157;\n  let temp158;\n  let temp159;\n  let temp160;\n  let temp161;\n  let temp162;\n  let temp163;\n  let temp164;\n  let temp165;\n  let temp166;\n  let temp167;\n  let temp168;\n  let temp169;\n  let temp170;\n  let temp171;\n  let temp172;\n  let temp173;\n  let temp174;\n  let temp175;\n  let temp176;\n  let temp177;\n  let temp178;\n  let temp179;\n  let temp180;\n  let temp181;\n  let temp182;\n  let temp183;\n  let temp184;\n  let temp185;\n  let temp186;\n  let temp187;\n  let temp188;\n  let temp189;\n  let temp190;\n  let temp191;\n  let temp192;\n  let temp193;\n  let temp194;\n  let temp195;\n  let temp196;\n  let temp197;\n  let temp198;\n  let temp199;\n  let temp200;\n  let temp201;\n  let temp202;\n  let temp203;\n  let temp204;\n  let temp205;\n  let temp206;\n  let temp207;\n  let temp208;\n  let temp209;\n  let temp210;\n  let temp211;\n  let temp212;\n  let temp213;\n  let temp214;\n  let temp215;\n  let temp216;\n  let temp217;\n  let temp218;\n  let temp219;\n  let temp220;\n  let temp221;\n  let temp222;\n  let temp223;\n  let temp224;\n  let temp225;\n  let temp226;\n  let temp227;\n  let temp228;\n  let temp229;\n  let temp230;\n  let temp231;\n  let temp232;\n  let temp233;\n  let temp234;\n  let temp235;\n  let temp236;\n  let temp237;\n  let temp238;\n  let temp239;\n  let temp240;\n  let temp241;\n  let temp242;\n  let temp243;\n  let temp244;\n  let temp245;\n  let temp246;\n  let temp247;\n  let temp248;\n  let temp249;\n  let temp250;\n  let temp251;\n  let temp252;\n  let temp253;\n  let temp254;\n  let temp255;\n  let temp256;\n  let temp257;\n  let temp258;\n  let temp259;\n  let temp260;\n  let temp261;\n  let temp262;\n  let temp263;\n  let temp264;\n  let temp265;\n  let temp266;\n  let temp267;\n  let temp268;\n  let "}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a function countNums which takes an array of integer and returns \n   the numeral of element which have a sum of finger > 0. \n   If a number be negative, then its first sign digit will be minus: \n   e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function countNums which takes an array of integer and returns \n   the numeral of element which have a sum of finger > 0. \n   If a number be negative, then its first sign digit will be minus: \n   e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  let signDigit = 0;\n  \n  for(let i = 0; i < arr.length; i++) {\n    let num = arr[i];\n    \n    if(num < 0) {\n      sign = -1;\n      signDigit = i;\n    }\n    \n    sum += num;\n  }\n  \n  return sign * signDigit + sum;\n};\n\n/*\n  Write a function countNums2 which takes an array of integer and returns \n   the numeral of element which have a sum of finger > 0. \n   If a number be negative, then its first sign digit will be minus: \n   e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums2([]) == 0\n  >>> countNums2([-1, 11, -11]) == 1\n  >>> countNums2([1, 1, 2]) == 3\n  */\nconst countNums2 = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  let signDigit = 0;\n  \n  for(let i = 0; i < arr.length; i++) {\n    let num = arr[i];\n    \n    if(num < 0) {\n      sign = -1;\n      signDigit = i;\n    }\n    \n    sum += num * sign;\n  }\n  \n  return sign * signDigit + sum;\n};\n\n/*\n  Write a function countNums3 which takes an array of integer and returns \n   the numeral of element which have a sum of finger > 0. \n   If a number be negative, then its first sign digit will be minus: \n   e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums3([-1, 11, -11]) == 1\n  >>> countNums3([1, 1, 2]) == 3\n  */\nconst countNums3 = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  let signDigit = 0;\n  \n  for(let i = 0; i < arr.length; i++) {\n    let num = arr[i];\n    \n    if(num < 0) {\n      sign = -1;\n      signDigit = i;\n    }\n    \n    sum += num * sign * signDigit;\n  }\n  \n  return sign * signDigit + sum;\n};\n\n/*\n  Write a function countNums4 which takes an array of integer and returns \n   the numeral of element which have a sum of finger > 0. \n   If a number be negative, then its first sign digit will be minus: \n   e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums4([-1, 11, -11]) == 1\n  >>> countNums4([1, 1, 2]) == 3\n  */\nconst countNums4 = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  let signDigit = 0;\n  \n  for(let i = 0; i < arr.length; i++) {\n    let num = arr[i];\n    \n    if(num < 0) {\n      sign = -1;\n      signDigit = i;\n    }\n    \n    sum += num * sign * signDigit * signDigit;\n  }\n  \n  return sign * signDigit + sum;\n};\n\n/*\n  Write a function countNums5 which takes an array of integer and returns \n   the numeral of element which have a sum of finger > 0. \n   If a number be negative, then its first sign digit will be minus: \n   e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums5([-1, 11, -11]) == 1\n  >>> countNums5([1, 1, 2]) == 3\n  */\nconst countNums5 = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  let signDigit = 0;\n  \n  for(let i = 0; i < arr.length; i++) {\n    let num = arr[i];\n    \n    if(num < 0) {\n      sign = -1;\n      signDigit = i;\n    }\n    \n    sum += num * sign * signDigit * signDigit * signDigit;\n  }\n  \n  return sign * signDigit + sum;\n};\n\n/*\n  Write a function countNums6 which takes an array of integer and returns \n   the numeral of element which have a sum of finger > 0. \n   If a number be negative, then its first sign digit will be minus: \n   e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums6([-1, 11, -11]) == 1\n  >>> countNums6([1, 1, 2]) == 3\n  */\nconst countNums6 = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  let signDigit = 0;\n  \n  for(let i = 0; i < arr.length; i++) {\n    let num = arr[i];\n    \n    if(num < 0) {\n      sign = -1;\n      signDigit = i;\n    }\n    \n    sum += num * sign * signDigit * signDigit * signDigit * signDigit;\n  }\n  \n  return sign * signDigit + sum;\n};\n\n/*\n  Write a function countNums7 which takes an array of integer and returns \n   the numeral of element which have a sum of finger > 0. \n   If a number be negative, then its first sign digit will be minus: \n   e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums7([-1, 11, -11]) == 1\n  >>> countNums7([1, 1, 2]) == 3\n  */\nconst countNums7 = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  let signDigit = 0;\n  \n  for(let i = 0; i < arr.length; i++) {\n    let num = arr[i];\n    \n    if(num < 0) {\n      sign = -1;\n      signDigit = i;\n    }\n    \n    sum += num * sign * signDigit * signDigit * signDigit * signDigit * signDigit;\n  }\n  \n  return sign * signDigit + sum;\n};\n\n/*\n  Write a function countNums8 which takes an array of integer and returns \n   the numeral of element which have a sum of finger > 0. \n   If a number be negative, then its first sign digit will be minus: \n   e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums8([-1, 11, -11]) == 1\n  >>> countNums8([1, 1, 2]) == 3\n  */\nconst countNums8 = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  let signDigit = 0;\n  \n  for(let i = 0; i < arr.length; i++) {\n    let num = arr[i];\n    \n    if(num < 0) {\n      sign = -1;\n      signDigit = i;\n    }\n    \n    sum += num * sign * signDigit * signDigit * signDigit * signDigit * signDigit * signDigit;\n  }\n  \n  return sign * signDigit + sum;\n};\n\n/*\n  Write a function countNums9 which takes an array of integer and returns \n   the numeral of element which have a sum of finger > 0. \n   If a number be negative, then its first sign digit will be minus: \n   e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums9([-1, 11, -11]) == 1\n  >>> countNums9([1, 1, 2]) == 3\n  */\nconst countNums9 = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  let signDigit = 0;\n  \n  for(let i = 0; i < arr.length; i++) {\n    let num = arr[i];\n    \n    if(num < 0) {\n      sign = -1;\n      signDigit = i;\n    }\n    \n    sum += num"}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integers arr[1], arr[2],... , arr[N].The\n   numbers in the array will be randomly ordain. Your undertaking is to settle if \n   it is possible to catch an array classify in non - decreasing ordering by performing \n   the following mathematical process on the given array: \n       You are allowed to perform right shift key process any numeral of time. \n  \n   One right shift operation means shifting all component of the array by one \n   status in the right direction. The concluding component of the array will be move to \n   the starting side in the array i.e. 0th exponent. \n\n   If it exist possible to prevail the sorted array by perform the above mathematical process \n   then return dependable else return false. \n   If the grant array is empty then return on-key. \n\n   Note: The give list is guaranteed to have alone elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*We have an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n   numbers in the array will be randomly ordain. Your undertaking is to settle if \n   it is possible to catch an array classify in non - decreasing ordering by performing \n   the following mathematical process on the given array: \n       You are allowed to perform right shift key process any numeral of time. \n  \n   One right shift operation means shifting all component of the array by one \n   status in the right direction. The concluding component of the array will be move to \n   the starting side in the array i.e. 0th exponent. \n\n   If it exist possible to prevail the sorted array by perform the above mathematical process \n   then return dependable else return false. \n   If the grant array is empty then return on-key. \n\n   Note: The give list is guaranteed to have alone elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  let moveOneBall = (arr) => {\n    let moveOneBall = (arr) => {\n      let moveOneBall = (arr) => {\n        let moveOneBall = (arr) => {\n          let moveOneBall = (arr) => {\n            let moveOneBall = (arr) => {\n              let moveOneBall = (arr) => {\n                let moveOneBall = (arr) => {\n                  let moveOneBall = (arr) => {\n                    let moveOneBall = (arr) => {\n                      let moveOneBall = (arr) => {\n                        let moveOneBall = (arr) => {\n                          let moveOneBall = (arr) => {\n                            let moveOneBall = (arr) => {\n                              let moveOneBall = (arr) => {\n                                let moveOneBall = (arr) => {\n                                  let moveOneBall = (arr) => {\n                                    let moveOneBall = (arr) => {\n                                      let moveOneBall = (arr) => {\n                                        let moveOneBall = (arr) => {\n                                          let moveOneBall = (arr) => {\n                                            let moveOneBall = (arr) => {\n                                              let moveOneBall = (arr) => {\n                                                let moveOneBall = (arr) => {\n                                                  let moveOneBall = (arr) => {\n                                                    let moveOneBall = (arr) => {\n                                                      let moveOneBall = (arr) => {\n                                                        let moveOneBall = (arr) => {\n                                                          let moveOneBall = (arr) => {\n                                                            let moveOneBall = (arr) => {\n                                                              let moveOneBall = (arr) => {\n                                                                let moveOneBall = (arr) => {\n                                                                  let moveOneBall = (arr) => {\n                                                                    let moveOneBall = (arr) => {\n                                                                        let moveOneBall = (arr) => {\n                                                                          let moveOneBall = (arr) => {\n                                                                            let moveOneBall = (arr) => {\n                                                                              let moveOneBall = (arr) => {\n                                                                                let moveOneBall = (arr) => {\n                                                                                  let moveOneBall = (arr) => {\n                                                                                    let moveOneBall = (arr) => {\n                                                                                      let moveOneBall = (arr) => {\n                                                                                        let moveOneBall = (arr) => {\n                                                                                          let moveOneBall = (arr) => {\n                                                                                            let moveOneBall = (arr) => {\n                                                                                              let moveOneBall = (arr) => {\n                                                                                                let moveOneBall = (arr) => {\n                                                                                                  let moveOneBall = (arr) => {\n                                                                                                    let moveOneBall = (arr) => {\n                                                                                                      let moveOneBall = (arr) => {\n                                                                                                        let moveOneBall = (arr) => {\n                                                                                                          let moveOneBall = (arr) => {\n                                                                                                            let moveOneBall = (arr) => {\n                                                                                                              let moveOneBall = (arr) => {\n                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                  let moveOneBall = (arr) => {\n                                                                                                                    let moveOneBall = (arr) => {\n                                                                                                                      let moveOneBall = (arr) => {\n                                                                                                                        let moveOneBall = (arr) => {\n                                                                                                                          let moveOneBall = (arr) => {\n                                                                                                                            let moveOneBall = (arr) => {\n                                                                                                                              let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {\n                                                                                                                                let moveOneBall = (arr) => {"}
{"task_id": "JavaScript/110", "prompt": "/*In this problem, you will implement a function that takes two tilt of number, \n   and determines whether it is possible to do an exchange of elements \n   between them to make lst1 a list of only even number. \n   There is no limit on the phone number of exchanged elements between lst1 and lst2.\n   If it is possible to exchange element between the lst1 and lst2 to make \n   all the elements of lst1 to be even, return \" YES \". \n   Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*In this problem, you will implement a function that takes two tilt of number, \n   and determines whether it is possible to do an exchange of elements \n   between them to make lst1 a list of only even number. \n   There is no limit on the phone number of exchanged elements between lst1 and lst2.\n   If it is possible to exchange element between the lst1 and lst2 to make \n   all the elements of lst1 to be even, return \" YES \". \n   Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let result = \"NO\";\n  if (lst1.length === 0 || lst2.length === 0) return \"NO\";\n  let num1 = lst1[0];\n  let num2 = lst2[0];\n  let num1Index = lst1.indexOf(num1);\n  let num2Index = lst2.indexOf(num2);\n  if (num1Index === -1 || num2Index === -1) return \"NO\";\n  if (num1Index === num2Index) return \"NO\";\n  if (num1Index > num2Index) return \"YES\";\n  if (num1Index < num2Index) return \"YES\";\n  let num1Elem = lst1[num1Index];\n  let num2Elem = lst2[num2Index];\n  if (num1Elem % 2 === 0 && num2Elem % 2 === 0) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 0 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 0) return \"YES\";\n  if (num1Elem % 2 === 0 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 0) return \"YES\";\n  if (num1Elem % 2 === 0 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 0) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 0 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 0) return \"YES\";\n  if (num1Elem % 2 === 0 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 0) return \"YES\";\n  if (num1Elem % 2 === 0 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 0) return \"YES\";\n  if (num1Elem % 2 === 0 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 0 && num2Elem % 2 === 0) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 0) return \"YES\";\n  if (num1Elem % 2 === 0 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 0 && num2Elem % 2 === 0) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 0) return \"YES\";\n  if (num1Elem % 2 === 0 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 0) return \"YES\";\n  if (num1Elem % 2 === 0 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 0 && num2Elem % 2 === 0) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 0) return \"YES\";\n  if (num1Elem % 2 === 0 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 0) return \"YES\";\n  if (num1Elem % 2 === 0 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 0) return \"YES\";\n  if (num1Elem % 2 === 0 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 0) return \"YES\";\n  if (num1Elem % 2 === 0 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 0) return \"YES\";\n  if (num1Elem % 2 === 0 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 0) return \"YES\";\n  if (num1Elem % 2 === 0 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 === 1 && num2Elem % 2 === 0) return \"YES\";\n  if (num1Elem % 2 === 0 && num2Elem % 2 === 1) return \"YES\";\n  if (num1Elem % 2 "}
{"task_id": "JavaScript/111", "prompt": "/*Given a string representing a space separated small letter letters, return a dictionary \n   of the letter with the most repeat and containing the corresponding count. \n   If several letter have the like occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Given a string representing a space separated small letter letters, return a dictionary \n   of the letter with the most repeat and containing the corresponding count. \n   If several letter have the like occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = {};\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let letterCount = 0;\n  let letterCounts = {};\n  let "}
{"task_id": "JavaScript/112", "prompt": "/*Task \n   We are given two strings s and c, you have to erase all the character in s that are equal to any fictional character in c\n   then control if the result drawstring is palindrome. \n   A string is name palindrome if it reads the like backward as forth. \n   You should return a tuple containing the result string and on-key / assumed for the confirmation.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Task \n   We are given two strings s and c, you have to erase all the character in s that are equal to any fictional character in c\n   then control if the result drawstring is palindrome. \n   A string is name palindrome if it reads the like backward as forth. \n   You should return a tuple containing the result string and on-key / assumed for the confirmation.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let result = ''\n  let reverse = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reversed = ''\n  let reverse"}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings, where each string consist of alone digits, return a list.\n   Each element i of the end product should be \" the phone number of odd component in the \n   string i of the remark. \" where all the i's should be replaced by the number \n   of odd digit in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Given a list of strings, where each string consist of alone digits, return a list.\n   Each element i of the end product should be \" the phone number of odd component in the \n   string i of the remark. \" where all the i's should be replaced by the number \n   of odd digit in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let res = []\n  let numOdd = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      numOdd += 1\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0 && numOdd === 0) {\n      res.push(`the number of odd elements ${numOdd} the str${numOdd} of the ${lst[i]} of the ${lst[i]}put.`)\n      numOdd = 0\n    }\n  }\n  return res\n}\n\n/*Given a list of strings, where each string consist of alone digits, return a list.\n   Each element i of the end product should be \" the phone number of even component in the \n   string i of the remark. \" where all the i's should be replaced by the number \n   of even digit in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let res = []\n  let numEven = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      numEven += 1\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0 && numEven === 0) {\n      res.push(`the number of even elements ${numEven} the str${numEven} of the ${lst[i]} of the ${lst[i]}put.`)\n      numEven = 0\n    }\n  }\n  return res\n}\n\n/*Given a list of strings, where each string consist of alone digits, return a list.\n   Each element i of the end product should be \" the phone number of odd component in the \n   string i of the remark. \" where all the i's should be replaced by the number \n   of even digit in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddEvenCount = (lst) => {\n  let res = []\n  let numOdd = 0\n  let numEven = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      numOdd += 1\n    }\n    if (lst[i] % 2!== 0) {\n      numEven += 1\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0 && numOdd === 0) {\n      res.push(`the number of odd elements ${numOdd} the str${numOdd} of the ${lst[i]} of the ${lst[i]}put.`)\n      numOdd = 0\n    }\n    if (lst[i] % 2!== 0 && numEven === 0) {\n      res.push(`the number of even elements ${numEven} the str${numEven} of the ${lst[i]} of the ${lst[i]}put.`)\n      numEven = 0\n    }\n  }\n  return res\n}\n\n/*Given a list of strings, where each string consist of alone digits, return a list.\n   Each element i of the end product should be \" the phone number of odd component in the \n   string i of the remark. \" where all the i's should be replaced by the number \n   of odd digit in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let res = []\n  let numOdd = 0\n  let numEven = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      numOdd += 1\n    }\n    if (lst[i] % 2!== 0) {\n      numEven += 1\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0 && numOdd === 0) {\n      res.push(`the number of odd elements ${numOdd} the str${numOdd} of the ${lst[i]} of the ${lst[i]}put.`)\n      numOdd = 0\n    }\n    if (lst[i] % 2 === 0 && numEven === 0) {\n      res.push(`the number of even elements ${numEven} the str${numEven} of the ${lst[i]} of the ${lst[i]}put.`)\n      numEven = 0\n    }\n  }\n  return res\n}\n\n/*Given a list of strings, where each string consist of alone digits, return a list.\n   Each element i of the end product should be \" the phone number of odd component in the \n   string i of the remark. \" where all the i's should be replaced by the number \n   of odd digit in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddEvenCount = (lst) => {\n  let res = []\n  let numOdd = 0\n  let numEven = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      numOdd += 1\n    }\n    if (lst[i] % 2!== 0) {\n      numEven += 1\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0 && numOdd === 0) {\n      res.push(`the number of odd elements ${numOdd} the str${numOdd} of the ${lst[i]} of the ${lst[i]}put.`)\n      numOdd = 0\n    }\n    if (lst[i] % 2 === 0 && numEven === 0) {\n      res.push(`the number of even elements ${numEven} the str${numEven} of the ${lst[i]} of the ${lst[i]}put.`)\n      numEven = 0\n    }\n  }\n  return res\n}\n\n/*Given a list of strings, where each string consist of alone digits, return a list.\n   Each element i of the end product should be \" the phone number of odd component in the \n   string i of the remark. \" where all the i's should be replaced by the number \n   of odd digit in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng"}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an array of integers nums, find the minimal sum of any non - empty bomber - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an array of integers nums, find the minimal sum of any non - empty bomber - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let sum = 0;\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given an array of integers nums, find the minimal sum of any non - empty bomber - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == -1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst maxSubArraySum = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n    }\n  }\n  return maxSum;\n};\n\n/*\n  Given an array of integers nums, find the minimal sum of any non - empty bomber - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == -1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySumOfNumbers = (nums) => {\n  let sum = 0;\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given an array of integers nums, find the minimal sum of any non - empty bomber - array \n   of nums.\n  Example\n  minSubArraySumOfNumbers([2, 3, 4, 1, 2, 4]) == -1\n  minSubArraySumOfNumbers([-1, -2, -3]) == -6\n  */\nconst maxSubArraySumOfNumbers = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n    }\n  }\n  return maxSum;\n};\n\n/*\n  Given an array of integers nums, find the minimal sum of any non - empty bomber - array \n   of nums.\n  Example\n  minSubArraySumOfNumbers([2, 3, 4, 1, 2, 4]) == -1\n  minSubArraySumOfNumbers([-1, -2, -3]) == -6\n  */\nconst minSubArraySumOfNumbersOfNumbers = (nums) => {\n  let sum = 0;\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given an array of integers nums, find the minimal sum of any non - empty bomber - array \n   of nums.\n  Example\n  minSubArraySumOfNumbersOfNumbers([2, 3, 4, 1, 2, 4]) == -1\n  minSubArraySumOfNumbersOfNumbers([-1, -2, -3]) == -6\n  */\nconst maxSubArraySumOfNumbersOfNumbers = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n    }\n  }\n  return maxSum;\n};\n\n/*\n  Given an array of integers nums, find the minimal sum of any non - empty bomber - array \n   of nums.\n  Example\n  minSubArraySumOfNumbersOfNumbers([2, 3, 4, 1, 2, 4]) == -1\n  minSubArraySumOfNumbersOfNumbers([-1, -2, -3]) == -6\n  */\nconst minSubArraySumOfNumbersOfNumbersOfNumbers = (nums) => {\n  let sum = 0;\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given an array of integers nums, find the minimal sum of any non - empty bomber - array \n   of nums.\n  Example\n  minSubArraySumOfNumbersOfNumbersOfNumbers([2, 3, 4, 1, 2, 4]) == -1\n  minSubArraySumOfNumbersOfNumbersOfNumbers([-1, -2, -3]) == -6\n  */\nconst maxSubArraySumOfNumbersOfNumbersOfNumbers = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n    }\n  }\n  return maxSum;\n};\n\n/*\n  Given an array of integers nums, find the minimal sum of any non - empty bomber - array \n   of nums.\n  Example\n  minSubArraySumOfNumbersOfNumbersOfNumbers([2, 3, 4, 1, 2, 4]) == -1\n  minSubArraySumOfNumbersOfNumbersOfNumbers([-1, -2, -3]) == -6\n  */\nconst minSubArraySumOfNumbersOfNumbersOfNumbersOfNumbers = (nums) => {\n  let sum = 0;\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given an array of integers nums, find the minimal sum of any non - empty bomber - array \n   of nums.\n  Example\n  minSubArraySumOfNumbersOfNumbersOfNumbersOfNumbers([2, 3, 4, 1, 2, 4]) == -1\n  minSubArraySumOfNumbersOfNumbersOfNumbersOfNumbers([-1, -2, -3]) == -6\n  */\nconst maxSubArraySumOfNumbersOfNumbersOfNumbersOfNumbers = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n    }\n  }\n  return maxSum;\n};\n\n/*\n  Given an array of integers nums, find the minimal sum of any non - empty bomber - array \n   of nums.\n  Example\n  minSubArraySumOfNumbersOfNumbersOfNumbersOfNumbers([2, 3, 4, 1, 2, 4]) == -1\n  minSubArraySumOfNumbersOfNumbersOfNumbersOfNumbers([-1, -2, -3]) == -6\n  */\nconst minSubArraySumOfNumbersOfNumbersOfNumbersOfNumbersOfNumbers = (nums) => {\n  let sum = 0;\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given an array of integers nums, find the minimal sum of any non - empty bomber - array \n   of nums.\n  Example\n  minSubArraySumOfNumbersOfNumbersOfNumbersOfNumbers([2, 3, 4, 1, 2, 4]) == -1\n  minSubArraySumOfNumbersOfNumbersOfNumbersOfNumbers([-1, -2, -3]) == -6\n  */\nconst maxSubArraySumOfNumbersOfNumbers"}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. Each row exemplify a individual well, \n   and each 1 in a course represents a single unit of water. \n   Each well have a corresponding bucket that can be used to extract water from it, \n   and all bucket have the same capacity.\n   Your task is to use the buckets to evacuate the well. \n   Output the act of time you necessitate to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a rectangular grid of wells. Each row exemplify a individual well, \n   and each 1 in a course represents a single unit of water. \n   Each well have a corresponding bucket that can be used to extract water from it, \n   and all bucket have the same capacity.\n   Your task is to use the buckets to evacuate the well. \n   Output the act of time you necessitate to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n    const [rows, cols] = grid.length;\n    const [buckets, buckets_capacity] = bucketCapacity(grid, capacity);\n    const [fills, fills_capacity] = fillCapacity(grid, buckets, buckets_capacity);\n    const [fills_filled, fills_filled_capacity] = fillFilled(grid, fills, fills_capacity);\n    const [fills_filled_filled, fills_filled_filled_capacity] = fillFilledFilled(grid, fills_filled, fills_filled_capacity);\n    const [fills_filled_filled_filled, fills_filled_filled_filled_capacity] = fillFilledFilledFilled(grid, fills_filled_filled, fills_filled_filled_capacity);\n    const [fills_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_capacity] = fillFilledFilledFilledFilledFilled(grid, fills_filled_filled_filled, fills_filled_filled_filled_filled_capacity);\n    const [fills_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_capacity] = fillFilledFilledFilledFilledFilledFilledFilled(grid, fills_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_capacity);\n    const [fills_filled_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled_filled_capacity] = fillFilledFilledFilledFilledFilledFilledFilled(grid, fills_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled_filled_capacity);\n    const [fills_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_capacity] = fillFilledFilledFilledFilledFilledFilledFilledFilled(grid, fills_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled_filled_filled_capacity);\n    const [fills_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_capacity] = fillFilledFilledFilledFilledFilledFilledFilledFilledFilled(grid, fills_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_capacity);\n    const [fills_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled, fills_filled_filled, fills_filled_filled, fills_filled_filled, fills_filled, fills_filled, fills_filled, fills_filled, fills_filled, fills_filled, fills_filled, fills_filled, fills_filled_filled, fills_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled_filled_filled_filled, fills_filled_filled_filled_filled_filled, fills_filled_filled, fills_filled_filled, fills_filled_filled, fills_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_filled_filled, fills_filled_fille"}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort an array of non - negative integer according to \n   number of one in their binary theatrical performance in ascend orderliness. \n   For similar phone number of ones, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  In this Kata, you have to sort an array of non - negative integer according to \n   number of one in their binary theatrical performance in ascend orderliness. \n   For similar phone number of ones, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  let result = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      result.push(arr[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  In this Kata, you have to sort an array of non - negative integer according to \n   number of one in their binary theatrical performance in descend orderliness. \n   For similar phone number of ones, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-4, -3, -2, -1, 0, 1, 2, 3, 4, 5]\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  let result = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      result.push(arr[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  In this Kata, you have to sort an array of non - negative integer according to \n   number of one in their binary theatrical performance in ascend orderliness. \n   For similar phone number of ones, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  let result = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 0) {\n      result.push(arr[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  In this Kata, you have to sort an array of non - negative integer according to \n   number of one in their binary theatrical performance in descend orderliness. \n   For similar phone number of ones, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-4, -3, -2, -1, 0, 1, 2, 3, 4, 5]\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  let result = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 0) {\n      result.push(arr[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  In this Kata, you have to sort an array of non - negative integer according to \n   number of one in their binary theatrical performance in ascend orderliness. \n   For similar phone number of ones, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  let result = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 0) {\n      result.push(arr[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  In this Kata, you have to sort an array of non - negative integer according to \n   number of one in their binary theatrical performance in descend orderliness. \n   For similar phone number of ones, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-4, -3, -2, -1, 0, 1, 2, 3, 4, 5]\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  let result = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 0) {\n      result.push(arr[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  In this Kata, you have to sort an array of non - negative integer according to \n   number of one in their binary theatrical performance in ascend orderliness. \n   For similar phone number of ones, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  let result = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 0) {\n      result.push(arr[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  In this Kata, you have to sort an array of non - negative integer according to \n   number of one in their binary theatrical performance in descend orderliness. \n   For similar phone number of ones, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-4, -3, -2, -1, 0, 1, 2, 3, 4, 5]\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  let result = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 0) {\n      result.push(arr[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  In this Kata, you have to sort an array of non - negative integer according to \n   number of one in their binary theatrical performance in ascend orderliness. \n   For similar phone number of ones, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  let result = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 0) {\n      result.push(arr[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  In this Kata, you have to sort an array of non - negative integer according to \n   number of one in their binary theatrical performance in descend orderliness. \n   For similar phone number of ones, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [-4, -3, -2, -1, 0, 1, 2, 3, 4, 5]\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  let result = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 0) {\n      result.push(arr[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  In this Kata, you have to sort an array of non - negative integer according to "}
{"task_id": "JavaScript/117", "prompt": "/*Given a string s and a natural number n, you have been tax to follow through \n   a function that returns a list of all word from string s that hold exactly \n   n consonant, in ordering these words appear in the chain s.\n   If the string s is empty then the function should return an empty list.\n   bill: you may assume the stimulation bowed stringed instrument contains only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Given a string s and a natural number n, you have been tax to follow through \n   a function that returns a list of all word from string s that hold exactly \n   n consonant, in ordering these words appear in the chain s.\n   If the string s is empty then the function should return an empty list.\n   bill: you may assume the stimulation bowed stringed instrument contains only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  let words = []\n  let word = ''\n  let index = 0\n  let wordCount = 0\n  let currentWord = ''\n  let currentIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let currentWordIndex = 0\n  let currentWordCount = 0\n  let "}
{"task_id": "JavaScript/118", "prompt": "/*You are given a word. Your task is to find the closest vowel that stands between \n   two consonant from the good slope of the word (case sensible). \n  \n   vowel in the beginning and termination doesn't count. Return empty string if you didn't \n   find any vowel met the above condition. \n\n   You may bear that the given chain contains English letter entirely.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You are given a word. Your task is to find the closest vowel that stands between \n   two consonant from the good slope of the word (case sensible). \n  \n   vowel in the beginning and termination doesn't count. Return empty string if you didn't \n   find any vowel met the above condition. \n\n   You may bear that the given chain contains English letter entirely.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowelsLength = vowels.length;\n  let vowelsIndex = 0;\n  let vowelsDistance = 0;\n  let vowelsDistanceIndex = 0;\n  let vowelsDistanceIndex2 = 0;\n  let vowelsDistanceIndex3 = 0;\n  let vowelsDistanceIndex4 = 0;\n  let vowelsDistanceIndex5 = 0;\n  let vowelsDistanceIndex6 = 0;\n  let vowelsDistanceIndex7 = 0;\n  let vowelsDistanceIndex8 = 0;\n  let vowelsDistanceIndex9 = 0;\n  let vowelsDistanceIndex10 = 0;\n  let vowelsDistanceIndex11 = 0;\n  let vowelsDistanceIndex12 = 0;\n  let vowelsDistanceIndex13 = 0;\n  let vowelsDistanceIndex14 = 0;\n  let vowelsDistanceIndex15 = 0;\n  let vowelsDistanceIndex16 = 0;\n  let vowelsDistanceIndex17 = 0;\n  let vowelsDistanceIndex18 = 0;\n  let vowelsDistanceIndex19 = 0;\n  let vowelsDistanceIndex20 = 0;\n  let vowelsDistanceIndex21 = 0;\n  let vowelsDistanceIndex22 = 0;\n  let vowelsDistanceIndex23 = 0;\n  let vowelsDistanceIndex24 = 0;\n  let vowelsDistanceIndex25 = 0;\n  let vowelsDistanceIndex26 = 0;\n  let vowelsDistanceIndex27 = 0;\n  let vowelsDistanceIndex28 = 0;\n  let vowelsDistanceIndex29 = 0;\n  let vowelsDistanceIndex30 = 0;\n  let vowelsDistanceIndex31 = 0;\n  let vowelsDistanceIndex32 = 0;\n  let vowelsDistanceIndex33 = 0;\n  let vowelsDistanceIndex34 = 0;\n  let vowelsDistanceIndex35 = 0;\n  let vowelsDistanceIndex36 = 0;\n  let vowelsDistanceIndex37 = 0;\n  let vowelsDistanceIndex38 = 0;\n  let vowelsDistanceIndex39 = 0;\n  let vowelsDistanceIndex40 = 0;\n  let vowelsDistanceIndex41 = 0;\n  let vowelsDistanceIndex42 = 0;\n  let vowelsDistanceIndex43 = 0;\n  let vowelsDistanceIndex44 = 0;\n  let vowelsDistanceIndex45 = 0;\n  let vowelsDistanceIndex46 = 0;\n  let vowelsDistanceIndex47 = 0;\n  let vowelsDistanceIndex48 = 0;\n  let vowelsDistanceIndex49 = 0;\n  let vowelsDistanceIndex50 = 0;\n  let vowelsDistanceIndex51 = 0;\n  let vowelsDistanceIndex52 = 0;\n  let vowelsDistanceIndex53 = 0;\n  let vowelsDistanceIndex54 = 0;\n  let vowelsDistanceIndex55 = 0;\n  let vowelsDistanceIndex56 = 0;\n  let vowelsDistanceIndex57 = 0;\n  let vowelsDistanceIndex58 = 0;\n  let vowelsDistanceIndex59 = 0;\n  let vowelsDistanceIndex60 = 0;\n  let vowelsDistanceIndex61 = 0;\n  let vowelsDistanceIndex62 = 0;\n  let vowelsDistanceIndex63 = 0;\n  let vowelsDistanceIndex64 = 0;\n  let vowelsDistanceIndex65 = 0;\n  let vowelsDistanceIndex66 = 0;\n  let vowelsDistanceIndex67 = 0;\n  let vowelsDistanceIndex68 = 0;\n  let vowelsDistanceIndex69 = 0;\n  let vowelsDistanceIndex70 = 0;\n  let vowelsDistanceIndex71 = 0;\n  let vowelsDistanceIndex72 = 0;\n  let vowelsDistanceIndex73 = 0;\n  let vowelsDistanceIndex74 = 0;\n  let vowelsDistanceIndex75 = 0;\n  let vowelsDistanceIndex76 = 0;\n  let vowelsDistanceIndex77 = 0;\n  let vowelsDistanceIndex78 = 0;\n  let vowelsDistanceIndex79 = 0;\n  let vowelsDistanceIndex80 = 0;\n  let vowelsDistanceIndex81 = 0;\n  let vowelsDistanceIndex82 = 0;\n  let vowelsDistanceIndex83 = 0;\n  let vowelsDistanceIndex84 = 0;\n  let vowelsDistanceIndex85 = 0;\n  let vowelsDistanceIndex86 = 0;\n  let vowelsDistanceIndex87 = 0;\n  let vowelsDistanceIndex88 = 0;\n  let vowelsDistanceIndex89 = 0;\n  let vowelsDistanceIndex90 = 0;\n  let vowelsDistanceIndex91 = 0;\n  let vowelsDistanceIndex92 = 0;\n  let vowelsDistanceIndex93 = 0;\n  let vowelsDistanceIndex94 = 0;\n  let vowelsDistanceIndex95 = 0;\n  let vowelsDistanceIndex96 = 0;\n  let vowelsDistanceIndex97 = 0;\n  let vowelsDistanceIndex98 = 0;\n  let vowelsDistanceIndex99 = 0;\n  let vowelsDistanceIndex100 = 0;\n  let vowelsDistanceIndex101 = 0;\n  let vowelsDistanceIndex102 = 0;\n  let vowelsDistanceIndex103 = 0;\n  let vowelsDistanceIndex104 = 0;\n  let vowelsDistanceIndex105 = 0;\n  let vowelsDistanceIndex106 = 0;\n  let vowelsDistanceIndex107 = 0;\n  let vowelsDistanceIndex108 = 0;\n  let vowelsDistanceIndex109 = 0;\n  let vowelsDistanceIndex110 = 0;\n  let vowelsDistanceIndex111 = 0;\n  let vowelsDistanceIndex112 = 0;\n  let vowelsDistanceIndex113 = 0;\n  let vowelsDistanceIndex114 = 0;\n  let vowelsDistanceIndex115 = 0;\n  let vowelsDistanceIndex116 = 0;\n  let vowelsDistanceIndex117 = 0;\n  let vowelsDistanceIndex118 = 0;\n  let vowelsDistanceIndex119 = 0;\n  let vowelsDistanceIndex120 = 0;\n  let vowelsDistanceIndex121 = 0;\n  let vowelsDistanceIndex122 = 0;\n  let vowelsDistanceIndex123 = 0;\n  let vowelsDistanceIndex124 = 0;\n  let vowelsDistanceIndex125 = 0;\n  let vowelsDistanceIndex126 = 0;\n  let vowelsDistanceIndex127 = 0;\n  let vowelsDistanceIndex128 = 0;\n  let vowelsDistanceIndex129 = 0;\n  let vowelsDistanceIndex130 = 0;\n  let vowelsDistanceIndex131 = 0;\n  let vowelsDistanceIndex132 = 0;\n  let vowelsDistanceIndex133 = 0;\n  let vowelsDistanceIndex134 = 0;\n  let vowelsDistanceIndex135 = 0;\n  let vowelsDistanceIndex136 = 0;\n  let vowelsDistanceIndex137 = 0;\n  let vowelsDistanceIndex138 = 0;\n  let vowelsDistanceIndex139 = 0;\n  let vowelsDistanceIndex140 = 0;\n  let vowelsDistanceIndex141 = 0;\n  let vowelsDistanceIndex142 = 0;\n  let vowelsDistanceIndex143 = 0;\n  let vowelsDistanceIndex144 = 0;\n  let vowelsDistanceIndex145 = 0;\n  let vowelsDistanceIndex146 = 0;\n  let vowelsDistanceIndex147 = 0;\n  let vowelsDistanceIndex148 = 0;\n  let vowelsDistanceIndex149 = 0;\n  let vowelsDistanceIndex150 = 0;\n  let vowelsDistanceIndex151 = 0;\n  let vowelsDistanceIndex152 = 0;\n  let vowelsDistanceIndex153 = 0;\n  let vowelsDistanceIndex154 = 0;\n  let vowelsDistanceIndex155 = 0;\n  let vowelsDistanceIndex156 = 0;\n  let vowelsDistanceIndex157 = 0;\n  let vowelsDistanceIndex158 = 0;\n  let vowelsDistanceIndex159 = 0;\n  let vowelsDistanceIndex160 = 0;\n  let vowelsDistanceIndex161 = 0;\n  let vowelsDistanceIndex162 = 0;\n  let vowelsDistanceIndex163 = 0;\n  let vowelsDistanceIndex164 = 0;\n  let vowelsDistanceIndex165 = 0;\n  let vowelsDistanceIndex166 = 0;\n  let vowelsDistanceIndex167 = 0;\n  let vowelsDistanceIndex168 = 0;\n  let vowelsDistanceIndex169 = 0;\n  let vowelsDistanceIndex170"}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list of two strings, both strings consist of capable \n   digression' (' or close parentheses')' merely. \n   Your job is to control if it is potential to concatenate the two string in\n   some order, that the result string will be adept. \n   A string S is considered to be good if and only if all parentheses in S \n   be balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* You are given a list of two strings, both strings consist of capable \n   digression' (' or close parentheses')' merely. \n   Your job is to control if it is potential to concatenate the two string in\n   some order, that the result string will be adept. \n   A string S is considered to be good if and only if all parentheses in S \n   be balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let isGood = true;\n  let isBalanced = true;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      isBalanced = false;\n    } else if (lst[i] === ')') {\n      isBalanced = true;\n    }\n    if (isBalanced) {\n      isGood = false;\n      break;\n    }\n  }\n  return isGood;\n};\n\n/* You are given a string S and a string T, where T is in some way a prefix of S. \n   Your job is to determine if T is a prefix of S. \n   If T is a prefix of S, then your job is to concatenate S and T. \n   If T is not a prefix of S, then your job is to concatenate S and T. \n   Return 'Yes' if T is a prefix of S, and 'No' otherwise.\n  Examples:\n  prefixOf('(())', '(())') == true\n  prefixOf('(())', '(())') == false\n  prefixOf('(())', '()') == true\n  prefixOf('(())', '()') == false\n  */\nconst prefixOf = (str, t) => {\n  let isGood = true;\n  let isPrefixOf = true;\n  if (str.length < t.length) {\n    isPrefixOf = false;\n  } else if (str.length >= t.length) {\n    isPrefixOf = true;\n  }\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === t[0]) {\n      isPrefixOf = false;\n      break;\n    }\n  }\n  return isPrefixOf;\n};\n\n/* You are given a string S and a string T, where T is in some way a suffix of S. \n   Your job is to determine if T is a suffix of S. \n   If T is a suffix of S, then your job is to concatenate S and T. \n   If T is not a suffix of S, then your job is to concatenate S and T. \n   Return 'Yes' if T is a suffix of S, and 'No' otherwise.\n  Examples:\n  suffixOf('(())', '(())') == true\n  suffixOf('(())', '(())') == false\n  suffixOf('(())', '()') == true\n  suffixOf('(())', '()') == false\n  */\nconst suffixOf = (str, t) => {\n  let isGood = true;\n  let isSuffixOf = true;\n  if (str.length < t.length) {\n    isSuffixOf = false;\n  } else if (str.length >= t.length) {\n    isSuffixOf = true;\n  }\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === t[str.length - 1]) {\n      isSuffixOf = false;\n      break;\n    }\n  }\n  return isSuffixOf;\n};\n\n/* You are given a string S and a string T, where T is in some way a prefix of S. \n   Your job is to determine if T is a suffix of S. \n   If T is a suffix of S, then your job is to concatenate S and T. \n   If T is not a suffix of S, then your job is to concatenate S and T. \n   Return 'Yes' if T is a prefix of S, and 'No' otherwise.\n  Examples:\n  prefixOf('(())', '(())') == true\n  prefixOf('(())', '(())') == false\n  prefixOf('(())', '()') == true\n  prefixOf('(())', '()') == false\n  */\nconst prefixOf = (str, t) => {\n  let isGood = true;\n  let isPrefixOf = true;\n  if (str.length < t.length) {\n    isPrefixOf = false;\n  } else if (str.length >= t.length) {\n    isPrefixOf = true;\n  }\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === t[0]) {\n      isPrefixOf = false;\n      break;\n    }\n  }\n  return isPrefixOf;\n};\n\n/* You are given a string S and a string T, where T is in some way a suffix of S. \n   Your job is to determine if T is a prefix of S. \n   If T is a prefix of S, then your job is to concatenate S and T. \n   If T is not a prefix of S, then your job is to concatenate S and T. \n   Return 'Yes' if T is a suffix of S, and 'No' otherwise.\n  Examples:\n  suffixOf('(())', '(())') == true\n  suffixOf('(())', '(())') == false\n  suffixOf('(())', '()') == true\n  suffixOf('(())', '()') == false\n  */\nconst suffixOf = (str, t) => {\n  let isGood = true;\n  let isSuffixOf = true;\n  if (str.length < t.length) {\n    isSuffixOf = false;\n  } else if (str.length >= t.length) {\n    isSuffixOf = true;\n  }\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === t[str.length - 1]) {\n      isSuffixOf = false;\n      break;\n    }\n  }\n  return isSuffixOf;\n};\n\n/* You are given a string S and a string T, where T is in some way a prefix of S. \n   Your job is to determine if T is a prefix of S. \n   If T is a suffix of S, then your job is to concatenate S and T. \n   If T is not a suffix of S, then your job is to concatenate S and T. \n   Return 'Yes' if T is a prefix of S, and 'No' otherwise.\n  Examples:\n  prefixOf('(())', '(())') == true\n  prefixOf('(())', '(())') == false\n  prefixOf('(())', '()') == true\n  prefixOf('(())', '()') == false\n  */\nconst prefixOf = (str, t) => {\n  let isGood = true;\n  let isPrefixOf = true;\n  if (str.length < t.length) {\n    isPrefixOf = false;\n  } else if (str.length >= t.length) {\n    isPrefixOf = true;\n  }\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === t[0]) {\n      isPrefixOf = false;\n      break;\n    }\n  }\n  return isPrefixOf;\n};\n\n/* You are given a string S and a string T, where T is in some way a suffix of S. \n   Your job is to determine if T is a suffix of S. \n   If T is a prefix of S, then your job is to concatenate S and T. \n   If T is not a suffix of S, then your job is to concatenate S and T. \n   Return 'Yes' if T is a prefix of S, and 'No' otherwise.\n  Examples:\n  suffixOf('(())', '(())') == true\n  suffixOf('(())', '(())') == false\n  suffixOf('(())', '()') == true\n  suffixOf('(())', '()') == false\n  */\nconst suffixOf = (str, t) => {\n  let isGood = true;\n  let isSuffixOf = true;\n  if (str.length < t.length) {\n    isSuffixOf = false;\n  } else if (str.length >= t.length) {\n    isSuffixOf = true;\n  }\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === t[str.length - 1]) {\n      isSuffixOf = false;\n      break;\n    }\n  }\n  return isSuffixOf;\n};\n\n/* You are given a string S and a string T, where T is in some way a prefix of S. \n"}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an array arr of integers and a positive integer k, return a sorted list \n   of duration k with the maximum k number in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an array arr of integers and a positive integer k, return a sorted list \n   of duration k with the maximum k number in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const len = arr.length;\n  const result = [];\n  let max = 0;\n  let maxIndex = 0;\n  let maxDuration = 0;\n  let maxDurationIndex = 0;\n  let maxDurationDuration = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationDurationIndex = 0;\n  let maxDurationDurationDurationDurationIndex = 0;\n  let maxDurationDurationDurationDurationIndex = 0;\n  let maxDurationDurationDurationDurationIndex = 0;\n  let maxDurationDurationDurationDurationIndex = 0;\n  let maxDurationDurationDurationDurationIndex = 0;\n  let maxDurationDurationDurationDurationIndex = 0;\n  let maxDurationDurationDurationDurationIndex = 0;\n  let maxDurationDurationDurationDurationIndex = 0;\n  let maxDurationDurationDurationDurationIndex = 0;\n  let maxDurationDurationDurationDurationIndex = 0;\n  let maxDurationDurationDurationIndex = 0;\n  let maxDurationDurationDurationIndex = 0;\n  let maxDurationDurationDurationIndex = 0;\n  let maxDurationDurationDurationIndex = 0;\n  let maxDurationDurationDurationIndex = 0;\n  let maxDurationDurationDurationIndex = 0;\n  let maxDurationDurationDurationIndex = 0;\n  let maxDurationDurationDurationIndex = 0;\n  let maxDurationDurationDurationIndex = 0;\n  let maxDurationDurationDurationIndex = 0;\n  let maxDurationDurationDurationIndex = 0;\n  let maxDurationDurationDurationIndex = 0;\n  let maxDurationDurationDurationIndex = 0;\n  let maxDurationDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;\n  let maxDurationDurationIndex = 0;"}
{"task_id": "JavaScript/121", "prompt": "/*Given a non - empty list of integer, return the sum of all of the curious element that constitute in even military position.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Given a non - empty list of integer, return the sum of all of the curious element that constitute in even military position.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],4:[function(require,module,exports){\n/*\n  Implement a binary search tree that can store integers in O(log n) time.\n  \n\n  Examples\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n"}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a non - empty array of integers arr and an integer k, return\n   the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a non - empty array of integers arr and an integer k, return\n   the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % k === 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/**\n * Given a non - empty array of integers arr and an integer k, return\n   the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsK = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % k === 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/**\n * Given a non - empty array of integers arr and an integer k, return\n   the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsK2 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % k === 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/**\n * Given a non - empty array of integers arr and an integer k, return\n   the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsK3 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % k === 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/**\n * Given a non - empty array of integers arr and an integer k, return\n   the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsK4 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % k === 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/**\n * Given a non - empty array of integers arr and an integer k, return\n   the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsK5 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % k === 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/**\n * Given a non - empty array of integers arr and an integer k, return\n   the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsK6 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % k === 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/**\n * Given a non - empty array of integers arr and an integer k, return\n   the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsK7 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % k === 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/**\n * Given a non - empty array of integers arr and an integer k, return\n   the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsK8 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % k === 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/**\n * Given a non - empty array of integers arr and an integer k, return\n   the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsK9 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % k === 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/**\n * Given a non - empty array of integers arr and an integer k, return\n   the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsK10 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % k === 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/**\n * Given a non - empty array of integers arr and an integer k, return\n   the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsK11 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % k === 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/**\n * "}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a positive integer n, return a sorted list that take the curious number in collatz sequence. \n\n   The Collatz guess is a conjecture in mathematics that concern a succession defined \n   as follow: start with any positive integer n. Then each condition is obtained from the \n   previous term as stick to: if the former term be even, the adjacent term is one half of \n   the previous term. If the former terminus be odd, the next terminus is 3 times the previous \n   condition plus 1. The speculation is that no matter what value of n, the sequence will always achieve 1. \n\n   eminence: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list classify in increase order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a positive integer n, return a sorted list that take the curious number in collatz sequence. \n\n   The Collatz guess is a conjecture in mathematics that concern a succession defined \n   as follow: start with any positive integer n. Then each condition is obtained from the \n   previous term as stick to: if the former term be even, the adjacent term is one half of \n   the previous term. If the former terminus be odd, the next terminus is 3 times the previous \n   condition plus 1. The speculation is that no matter what value of n, the sequence will always achieve 1. \n\n   eminence: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list classify in increase order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] < n) {\n    collatz[i] = collatz[i - 1] * 3 + collatz[i - 1] + 1;\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that take the curious number in collatz sequence. \n\n   The Collatz guess is a conjecture in mathematics that concern a succession defined \n   as follow: start with any positive integer n. Then each condition is obtained from the \n   previous term as stick to: if the former term be even, the adjacent term is one half of \n   the previous term. If the former terminus be odd, the next terminus is 3 times the previous \n   condition plus 1. The speculation is that no matter what value of n, the sequence will always achieve 1. \n\n   eminence: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list classify in decrease order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatzReverse = (n) => {\n  let collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] > n) {\n    collatz[i] = collatz[i - 1] * 3 + collatz[i - 1] + 1;\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that take the curious number in collatz sequence. \n\n   The Collatz guess is a conjecture in mathematics that concern a succession defined \n   as follow: start with any positive integer n. Then each condition is obtained from the \n   previous term as stick to: if the former term be even, the adjacent term is one half of \n   the previous term. If the former terminus be odd, the next terminus is 3 times the previous \n   condition plus 1. The speculation is that no matter what value of n, the sequence will always achieve 1. \n\n   eminence: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list classify in decrease order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatzReverseReverse = (n) => {\n  let collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] > n) {\n    collatz[i] = collatz[i - 1] * 3 + collatz[i - 1] + 1;\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that take the curious number in collatz sequence. \n\n   The Collatz guess is a conjecture in mathematics that concern a succession defined \n   as follow: start with any positive integer n. Then each condition is obtained from the \n   previous term as stick to: if the former term be even, the adjacent term is one half of \n   the previous term. If the former terminus be odd, the next terminus is 3 times the previous \n   condition plus 1. The speculation is that no matter what value of n, the sequence will always achieve 1. \n\n   eminence: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list classify in decrease order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatzReverseReverseReverse = (n) => {\n  let collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] > n) {\n    collatz[i] = collatz[i - 1] * 3 + collatz[i - 1] + 1;\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that take the curious number in collatz sequence. \n\n   The Collatz guess is a conjecture in mathematics that concern a succession defined \n   as follow: start with any positive integer n. Then each condition is obtained from the \n   previous term as stick to: if the former term be even, the adjacent term is one half of \n   the previous term. If the former terminus be odd, the next terminus is 3 times the previous \n   condition plus 1. The speculation is that no matter what value of n, the sequence will always achieve 1. \n\n   eminence: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list classify in decrease order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatzReverseReverseReverse = (n) => {\n  let collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] > n) {\n    collatz[i] = collatz[i - 1] * 3 + collatz[i - 1] + 1;\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that take the curious number in collatz sequence. \n\n   The Collatz guess is a conjecture in mathematics that concern a succession defined \n   as follow: start with any positive integer n. Then each condition is obtained from the \n   previous term as stick to: if the former term be even, the adjacent term is one half of \n   the previous term. If the former terminus be odd, the next terminus is 3 times the previous \n   condition plus 1. The speculation is that no matter what value of n, the sequence will always achieve 1. \n\n   eminence: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list classify in decrease order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatzReverseReverseReverseReverse = (n) => {\n  let collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] > n) {\n    collatz[i] = collat"}
{"task_id": "JavaScript/124", "prompt": "/*You have to write a function which validates a grant date chain and \n   reappearance genuine if the date is valid differently false. \n   The date is valid if all of the following rule are satisfied: \n   1. The date string is not empty. \n   2. The issue of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the issue of day is not less than 1 or higher than 30 day for calendar month 4,6,9,11. And, the number of days is not less than 1 or high than 29 for the month 2. \n   3. The month should not be less than 1 or high than 12. \n   4. The date should be in the format: mm - doctor of divinity - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You have to write a function which validates a grant date chain and \n   reappearance genuine if the date is valid differently false. \n   The date is valid if all of the following rule are satisfied: \n   1. The date string is not empty. \n   2. The issue of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the issue of day is not less than 1 or higher than 30 day for calendar month 4,6,9,11. And, the number of days is not less than 1 or high than 29 for the month 2. \n   3. The month should not be less than 1 or high than 12. \n   4. The date should be in the format: mm - doctor of divinity - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const [month, day, year] = date.split('-');\n  const [doctor, divinity, yearOfBirth] = year.split('-');\n  const [daysInMonth, monthOfBirth] = month.split('-');\n  const [daysInYear, yearOfBirth] = yearOfBirth.split('-');\n  const [daysInMonthOfYear, monthOfBirthOfYear] = monthOfBirth.split('-');\n  const [daysInMonth, monthOfBirthOfMonth] = monthOfBirth.split('-');\n  const [daysInMonthOfYear, yearOfBirthOfMonth] = yearOfBirthOfMonth.split('-');\n  const [daysInYearOfMonth, monthOfBirthOfYearOfMonth] = monthOfBirthOfYear.split('-');\n  const [daysInMonthOfYearOfMonth, yearOfBirthOfYearOfMonth] = yearOfBirthOfYearOfMonth.split('-');\n  const [daysInYearOfMonthOfYear, monthOfBirthOfYearOfYearOfMonth] = monthOfBirthOfYearOfYearOfMonth.split('-');\n  const [daysInMonthOfYearOfMonthOfYear, yearOfBirthOfYearOfMonthOfYear] = monthOfBirthOfYearOfYearOfMonthOfYear.split('-');\n  const [daysInYearOfMonthOfYearOfMonthOfYear, yearOfBirthOfYearOfMonthOfYearOfYear] = monthOfBirthOfYearOfYearOfMonthOfYearOfYear.split('-');\n  const [daysInMonthOfYearOfMonthOfYearOfMonthOfYear, yearOfBirthOfYearOfMonthOfYearOfYear] = monthOfBirthOfYearOfYearOfMonthOfYearOfYearOfMonth.split('-');\n  const [daysInYearOfMonthOfYearOfMonthOfYearOfMonthOfYear, yearOfBirthOfYearOfMonthOfYearOfMonthOfYear] = monthOfBirthOfYearOfMonthOfYearOfMonthOfYearOfYear.split('-');\n  const [daysInMonthOfYearOfMonthOfYearOfMonthOfYearOfMonth, yearOfBirthOfYearOfMonthOfYearOfMonthOfYear] = monthOfBirthOfYearOfMonthOfYearOfMonthOfYearOfMonth.split('-');\n  const [daysInYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonth, yearOfBirthOfYearOfMonthOfYearOfMonthOfYearOfMonth] = monthOfBirthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYear.split('-');\n  const [daysInMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonth, yearOfBirthOfYearOfMonthOfYearOfMonthOfYearOfMonth] = monthOfBirthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonth.split('-');\n  const [daysInYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYear, yearOfBirthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYear] = monthOfBirthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonth.split('-');\n  const [daysInMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYear, yearOfBirthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYear] = monthOfBirthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonth.split('-');\n  const [daysInYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonth, yearOfBirthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonth] = monthOfBirthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYear.split('-');\n  const [daysInMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonth, yearOfBirthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonth] = monthOfBirthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonth.split('-');\n  const [daysInYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYear, yearOfBirthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYear] = monthOfBirthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonth.split('-');\n  const [daysInMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYear, yearOfBirthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonth] = monthOfBirthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYearOfMonthOfYear"}
{"task_id": "JavaScript/125", "prompt": "/* Given a string of words, return a list of words separate on whitespace, if no whitespaces exists in the textbook you \n   should split on commas',' if no commas exists you should return the phone number of lower - sheath letters with odd order in the \n   alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Given a string of words, return a list of words separate on whitespace, if no whitespaces exists in the textbook you \n   should split on commas',' if no commas exists you should return the phone number of lower - sheath letters with odd order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(' ');\n  const result = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length > 0) {\n      result.push(word);\n    }\n  }\n  return result;\n}\n\n/* Given a string of words, return a list of words separated by commas if no commas exists in the textbook you \n   should split on commas',' if no commas exists you should return the phone number of lower - sheath letters with odd order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsComma = (txt) => {\n  const words = txt.split(',');\n  const result = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length > 0) {\n      result.push(word);\n    }\n  }\n  return result;\n}\n\n/* Given a string of words, return a list of words separated by commas if no commas exists in the textbook you \n   should split on commas',' if no commas exists you should return the phone number of lower - sheath letters with odd order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsCommaWithSpace = (txt) => {\n  const words = txt.split(',');\n  const result = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length > 0) {\n      result.push(word);\n    }\n  }\n  return result;\n}\n\n/* Given a string of words, return a list of words separated by commas if no commas exists in the textbook you \n   should split on commas',' if no commas exists you should return the phone number of lower - sheath letters with odd order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsCommaWithSpaceAndSpace = (txt) => {\n  const words = txt.split(',');\n  const result = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length > 0) {\n      result.push(word);\n    }\n  }\n  return result;\n}\n\n/* Given a string of words, return a list of words separated by commas if no commas exists in the textbook you \n   should split on commas',' if no commas exists you should return the phone number of lower - sheath letters with odd order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsCommaWithSpaceAndSpaceAndSpace = (txt) => {\n  const words = txt.split(',');\n  const result = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length > 0) {\n      result.push(word);\n    }\n  }\n  return result;\n}\n\n/* Given a string of words, return a list of words separated by commas if no commas exists in the textbook you \n   should split on commas',' if no commas exists you should return the phone number of lower - sheath letters with odd order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsCommaWithSpaceAndSpaceAndSpace = (txt) => {\n  const words = txt.split(',');\n  const result = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length > 0) {\n      result.push(word);\n    }\n  }\n  return result;\n}\n\n/* Given a string of words, return a list of words separated by commas if no commas exists in the textbook you \n   should split on commas',' if no commas exists you should return the phone number of lower - sheath letters with odd order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsCommaWithSpaceAndSpaceAndSpaceAndSpace = (txt) => {\n  const words = txt.split(',');\n  const result = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length > 0) {\n      result.push(word);\n    }\n  }\n  return result;\n}\n\n/* Given a string of words, return a list of words separated by commas if no commas exists in the textbook you \n   should split on commas',' if no commas exists you should return the phone number of lower - sheath letters with odd order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsCommaWithSpaceAndSpaceAndSpaceAndSpaceAndSpace = (txt) => {\n  const words = txt.split(',');\n  const result = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length > 0) {\n      result.push(word);\n    }\n  }\n  return result;\n}\n\n/* Given a string of words, return a list of words separated by commas if no commas exists in the textbook you \n   should split on commas',' if no commas exists you should return the phone number of lower - sheath letters with odd order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsCommaWithSpaceAndSpaceAndSpaceAndSpaceAnd"}
{"task_id": "JavaScript/126", "prompt": "/* Given a list of numbers, return whether or not they are sorted \n   in ascending decree. If list have more than 1 extra of the like \n   number, return false. simulate no minus numbers and alone integers.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Given a list of numbers, return whether or not they are sorted \n   in ascending decree. If list have more than 1 extra of the like \n   number, return false. simulate no minus numbers and alone integers.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n  const len = lst.length\n  const isSorted = (arr, i) => {\n    if (i === len) return true\n    const left = arr.slice(0, i)\n    const right = arr.slice(i + 1)\n    const leftIsSorted = isSorted(left, i)\n    const rightIsSorted = isSorted(right, i + 1)\n    return leftIsSorted && rightIsSorted\n  }\n  return isSorted(lst, 0)\n}\n\n/* Given a list of numbers, return whether or not they are sorted \n   in ascending decree. If list have more than 1 extra of the like \n   number, return false. simulate no minus numbers and alone integers.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n  const len = lst.length\n  const isSorted = (arr, i) => {\n    if (i === len) return true\n    const left = arr.slice(0, i)\n    const right = arr.slice(i + 1)\n    const leftIsSorted = isSorted(left, i)\n    const rightIsSorted = isSorted(right, i + 1)\n    return leftIsSorted && rightIsSorted\n  }\n  return isSorted(lst, 0)\n}\n\n/* Given a list of numbers, return whether or not they are sorted \n   in ascending decree. If list have more than 1 extra of the like \n   number, return false. simulate no minus numbers and alone integers.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n  const len = lst.length\n  const isSorted = (arr, i) => {\n    if (i === len) return true\n    const left = arr.slice(0, i)\n    const right = arr.slice(i + 1)\n    const leftIsSorted = isSorted(left, i)\n    const rightIsSorted = isSorted(right, i + 1)\n    return leftIsSorted && rightIsSorted\n  }\n  return isSorted(lst, 0)\n}\n\n/* Given a list of numbers, return whether or not they are sorted \n   in ascending decree. If list have more than 1 extra of the like \n   number, return false. simulate no minus numbers and alone integers.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n  const len = lst.length\n  const isSorted = (arr, i) => {\n    if (i === len) return true\n    const left = arr.slice(0, i)\n    const right = arr.slice(i + 1)\n    const leftIsSorted = isSorted(left, i)\n    const rightIsSorted = isSorted(right, i + 1)\n    return leftIsSorted && rightIsSorted\n  }\n  return isSorted(lst, 0)\n}\n\n/* Given a list of numbers, return whether or not they are sorted \n   in ascending decree. If list have more than 1 extra of the like \n   number, return false. simulate no minus numbers and alone integers.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n  const len = lst.length\n  const isSorted = (arr, i) => {\n    if (i === len) return true\n    const left = arr.slice(0, i)\n    const right = arr.slice(i + 1)\n    const leftIsSorted = isSorted(left, i)\n    const rightIsSorted = isSorted(right, i + 1)\n    return leftIsSorted && rightIsSorted\n  }\n  return isSorted(lst, 0)\n}\n\n/* Given a list of numbers, return whether or not they are sorted \n   in ascending decree. If list have more than 1 extra of the like \n   number, return false. simulate no minus numbers and alone integers.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n  const len = lst.length\n  const isSorted = (arr, i) => {\n    if (i === len) return true\n    const left = arr.slice(0, i)\n    const right = arr.slice(i + 1)\n    const leftIsSorted = isSorted(left, i)\n    const rightIsSorted = isSorted(right, i + 1)\n    return leftIsSorted && rightIsSorted\n  }\n  return isSorted(lst, 0)\n}\n\n/* Given a list of numbers, return whether or not they are sorted \n   in ascending decree. If list have more than 1 extra of the like \n   number, return false. simulate no minus numbers and alone integers.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true"}
{"task_id": "JavaScript/127", "prompt": "/*You are given two intervals, \n   where each interval equal a couple of integer. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You are given two intervals, \n   where each interval equal a couple of integer. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  let start1 = interval1[0];\n  let start2 = interval2[0];\n  let end1 = interval1[1];\n  let end2 = interval2[1];\n  let result = [];\n  let isIntersect = false;\n  let isPrime = false;\n  if (start1 < end1 && start2 < end2) {\n    if (start1 > end2) {\n      start2 = end2;\n    }\n    if (start1 < end2) {\n      start1 = end1;\n    }\n    if (start2 > end1) {\n      start2 = end1;\n    }\n    if (start2 > end2) {\n      start2 = end2;\n    }\n  }\n  if (start1 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {\n    start2 = end1;\n  }\n  if (start2 > end2) {\n    start2 = end2;\n  }\n  if (start1 < end2) {\n    start1 = end1;\n  }\n  if (start2 > end1) {"}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given an array arr of integers and you need to return\n   union of magnitude of integer multiply by product of all signs \n   of each number in the array, act by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   model:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given an array arr of integers and you need to return\n   union of magnitude of integer multiply by product of all signs \n   of each number in the array, act by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   model:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  let sign = 0\n  let signs = []\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    sign = sign + (arr[i] * -1)\n    signs.push(sign)\n  }\n  return signs\n}\n\n/*\n  You are given an array arr of integers and you need to return\n   product of magnitude of integer multiply by product of all signs \n   of each number in the array, act by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   model:\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns2 = (arr) => {\n  let sign = 0\n  let signs = []\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    sign = sign + (arr[i] * 1)\n    signs.push(sign)\n  }\n  return signs\n}\n\n/*\n  You are given an array arr of integers and you need to return\n   product of magnitude of integer multiply by product of all signs \n   of each number in the array, act by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   model:\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns3 = (arr) => {\n  let sign = 0\n  let signs = []\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    sign = sign + (arr[i] * -1)\n    signs.push(sign)\n  }\n  return signs\n}\n\n/*\n  You are given an array arr of integers and you need to return\n   product of magnitude of integer multiply by product of all signs \n   of each number in the array, act by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   model:\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns4 = (arr) => {\n  let sign = 0\n  let signs = []\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    sign = sign + (arr[i] * 1)\n    signs.push(sign)\n  }\n  return signs\n}\n\n/*\n  You are given an array arr of integers and you need to return\n   product of magnitude of integer multiply by product of all signs \n   of each number in the array, act by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   model:\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns5 = (arr) => {\n  let sign = 0\n  let signs = []\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    sign = sign + (arr[i] * -1)\n    signs.push(sign)\n  }\n  return signs\n}\n\n/*\n  You are given an array arr of integers and you need to return\n   product of magnitude of integer multiply by product of all signs \n   of each number in the array, act by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   model:\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns6 = (arr) => {\n  let sign = 0\n  let signs = []\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    sign = sign + (arr[i] * 1)\n    signs.push(sign)\n  }\n  return signs\n}\n\n/*\n  You are given an array arr of integers and you need to return\n   product of magnitude of integer multiply by product of all signs \n   of each number in the array, act by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   model:\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns7 = (arr) => {\n  let sign = 0\n  let signs = []\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    sign = sign + (arr[i] * -1)\n    signs.push(sign)\n  }\n  return signs\n}\n\n/*\n  You are given an array arr of integers and you need to return\n   product of magnitude of integer multiply by product of all signs \n   of each number in the array, act by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   model:\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns8 = (arr) => {\n  let sign = 0\n  let signs = []\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    sign = sign + (arr[i] * 1)\n    signs.push(sign)\n  }\n  return signs\n}\n\n/*\n  You are given an array arr of integers and you need to return\n   product of magnitude of integer multiply by product of all signs \n   of each number in the array, act by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   model:\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns9 = (arr) => {\n  let sign = 0\n  let signs = []\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    sign = sign + (arr[i] * -1)\n    signs.push(sign)\n  }\n  return signs\n}\n\n/*\n  You are given an array arr of integers and you need to return\n   product of magnitude of integer multiply by product of all signs \n   of each number in the array, act by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   model:\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns10 = (arr) => {\n  let sign = 0\n  let signs = []\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    sign = sign + (arr[i] * 1)\n    signs.push(sign)\n  }\n  return signs\n}\n\n/*\n  You are given an array arr of integers and you need to return\n   product of magnitude of integer multiply by product of all signs \n   of each number in the array, act by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   model:\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns11 = (arr) => {\n  let sign = 0\n  let signs = []\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    sign = sign + (arr[i] * -1)\n    signs.push(sign)\n  }\n  return signs\n}\n\n/*\n  You are given an array arr of integers and you need to return\n   product of magnitude of integer multiply by product of all signs \n   of each number in the array, act by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   model:\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns("}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid with N rows and N columns (N > = 2) and a positive integer k, \n   each cell of the grid incorporate a value. Every integer in the range [ 1, N * N ] \n   inclusive appears exactly once on the cell of the grid.\n\n   You induce to find the minimum path of length k in the grid. You can begin \n   from any cell, and in each step you can move to any of the neighbor cells, \n   in early password, you can go to cell which partake an edge with you current \n   cell. \n   Please note that a path of duration k means travel to exactly k cells (not \n   inevitably discrete). \n   You CANNOT go off the grid.\n   A way A (of distance k) is considered less than a way barn (of length k) if \n   after have the arrange tilt of the values on the cell that A and B plump \n   through (let's predict them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in early son, there exist an integer exponent i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we consume \n   lst_A[j ] = lst_B[j ]. \n   It is guaranteed that the solution is unique. \n   Return an ordered list of the values on the cells that the minimum way move through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a grid with N rows and N columns (N > = 2) and a positive integer k, \n   each cell of the grid incorporate a value. Every integer in the range [ 1, N * N ] \n   inclusive appears exactly once on the cell of the grid.\n\n   You induce to find the minimum path of length k in the grid. You can begin \n   from any cell, and in each step you can move to any of the neighbor cells, \n   in early password, you can go to cell which partake an edge with you current \n   cell. \n   Please note that a path of duration k means travel to exactly k cells (not \n   inevitably discrete). \n   You CANNOT go off the grid.\n   A way A (of distance k) is considered less than a way barn (of length k) if \n   after have the arrange tilt of the values on the cell that A and B plump \n   through (let's predict them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in early son, there exist an integer exponent i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we consume \n   lst_A[j ] = lst_B[j ]. \n   It is guaranteed that the solution is unique. \n   Return an ordered list of the values on the cells that the minimum way move through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const [row, col] = grid;\n  const [visited, set] = new Set();\n  const queue = [row];\n  let result = [];\n  let minPath = [];\n\n  while (queue.length) {\n    const cell = queue.shift();\n    const value = grid[cell];\n    if (visited.has(value)) {\n      continue;\n    }\n    visited.add(value);\n    queue.push(...grid[value]);\n    if (value === k) {\n      result.push(value);\n      minPath.push(...result);\n      result = [];\n      minPath = [];\n      continue;\n    }\n    if (value!== k) {\n      result.push(value);\n    }\n  }\n  return minPath;\n};\n\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41534/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41535/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41536/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41537/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41538/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41539/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41541/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41544/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41545/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41546/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41547/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41548/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41549/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41550/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41551/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41552/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41553/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41554/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41555/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41556/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41557/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41558/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41559/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41560/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41562/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41563/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41564/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41565/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum-ii/discuss/41566/Java-solution-for-the-minimum-path-sum-ii\n// https://leetcode.com/problems/minimum-path-sum"}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows Fibonacci sequence, it was studied profoundly by mathematicians in \n   the final couple hundred. However, what people don't know is Tribonacci sequence. \n   Tribonacci succession is define by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is curious.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Everyone knows Fibonacci sequence, it was studied profoundly by mathematicians in \n   the final couple hundred. However, what people don't know is Tribonacci sequence. \n   Tribonacci succession is define by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is curious.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  if (n <= 1) return [];\n  const res = [1, 2];\n  for (let i = 2; i <= n; i++) {\n    res.push(res[i - 1] + res[i - 2]);\n  }\n  return res;\n};\n\n/*\n  Given a non-negative integer number n, return the first n numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(3) = [1, 1, 1]\n  fib(4) = [1, 1, 2, 3, 5, 8]\n  fib(7) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n*/\nconst fib = (n) => {\n  if (n <= 1) return [];\n  const res = [1, 1];\n  for (let i = 1; i <= n; i++) {\n    res.push(res[i - 1] + res[i - 2]);\n  }\n  return res;\n};\n\n/*\n  Given a non-negative integer number n, return the first n numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(3) = [1, 1, 1]\n  fib(4) = [1, 1, 2, 3, 5, 8]\n  fib(7) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return [];\n  const res = [1, 1];\n  for (let i = 1; i <= n; i++) {\n    res.push(res[i - 1] + res[i - 2]);\n  }\n  return res;\n};\n\n/*\n  Given a non-negative integer number n, return the first n numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(3) = [1, 1, 1]\n  fib(4) = [1, 1, 2, 3, 5, 8]\n  fib(7) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return [];\n  const res = [1, 1];\n  for (let i = 1; i <= n; i++) {\n    res.push(res[i - 1] + res[i - 2]);\n  }\n  return res;\n};\n\n/*\n  Given a non-negative integer number n, return the first n numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(3) = [1, 1, 1]\n  fib(4) = [1, 1, 2, 3, 5, 8]\n  fib(7) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return [];\n  const res = [1, 1];\n  for (let i = 1; i <= n; i++) {\n    res.push(res[i - 1] + res[i - 2]);\n  }\n  return res;\n};\n\n/*\n  Given a non-negative integer number n, return the first n numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(3) = [1, 1, 1]\n  fib(4) = [1, 1, 2, 3, 5, 8]\n  fib(7) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return [];\n  const res = [1, 1];\n  for (let i = 1; i <= n; i++) {\n    res.push(res[i - 1] + res[i - 2]);\n  }\n  return res;\n};\n\n/*\n  Given a non-negative integer number n, return the first n numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(3) = [1, 1, 1]\n  fib(4) = [1, 1, 2, 3, 5, 8]\n  fib(7) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return [];\n  const res = [1, 1];\n  for (let i = 1; i <= n; i++) {\n    res.push(res[i - 1] + res[i - 2]);\n  }\n  return res;\n};\n\n/*\n  Given a non-negative integer number n, return the first n numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(3) = [1, 1, 1]\n  fib(4) = [1, 1, 2, 3, 5, 8]\n  fib(7) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return [];\n  const res = [1, 1];\n  for (let i = 1; i <= n; i++) {\n    res.push(res[i - 1] + res[i - 2]);\n  }\n  return res;\n};\n\n/*\n  Given a non-negative integer number n, return the first n numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(3) = [1, 1, 1]\n  fib(4) = [1, 1, 2, 3, 5, 8]\n  fib(7) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return [];\n  const res = [1, 1];\n  for (let i = 1; i <= n; i++) {\n    res.push(res[i - 1] + res[i - 2]);\n  }\n  return res;\n};\n\n/*\n  Given a non-negative integer number n, return the first n numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(3) = [1, 1, 1]\n  fib(4) = [1, 1, 2, 3, 5, 8]\n  fib(7) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return [];\n  const res = [1, 1];\n  for (let i = 1; i <= n; i++) {\n    res.push(res[i - 1] + res[i - 2]);\n  }\n  return res;\n};\n\n/*\n  Given a non-negative integer number n, return the first n numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(3) = [1, 1, 1]\n  fib(4) = [1, 1, 2, 3, 5, 8]\n  fib(7) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return [];\n  const res = [1, 1];\n  for (let i = 1; i <= n; i++) {\n    res.push(res[i - 1] + res[i - 2]);\n  }\n  return res;\n};\n\n/*\n  Given a non-negative integer number n, return the first n numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(3) = [1, 1, 1]\n  fib(4) = [1, 1, 2, 3, 5, 8]\n  fib(7) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return [];\n  const res = [1, 1];\n  for (let i = 1; i <= "}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive integer n, return the product of the leftover digits.\n   Return 0 if all digits be even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Given a positive integer n, return the product of the leftover digits.\n   Return 0 if all digits be even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let res = 0\n  for (let i = n; i > 0; i--) {\n    res *= 10\n    res += n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the product of the digits of the right\n   most digit of the number.\n   Return 0 if n is 0.\n  For example:\n  digits(4)  == 4\n  digits(235) == 4\n  digits(0)  == 0\n  */\nconst rightDigits = (n) => {\n  let res = 0\n  for (let i = n; i > 0; i--) {\n    res *= 10\n    res += n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n   Return 0 if n is 0.\n  For example:\n  digits(4)  == 4\n  digits(235) == 4\n  digits(0)  == 0\n  */\nconst sumDigits = (n) => {\n  let res = 0\n  for (let i = n; i > 0; i--) {\n    res += n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n   Return 0 if n is 0.\n  For example:\n  digits(4)  == 4\n  digits(235) == 4\n  digits(0)  == 0\n  */\nconst sumDigitsModulo10 = (n) => {\n  let res = 0\n  for (let i = n; i > 0; i--) {\n    res += n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n   Return 0 if n is 0.\n  For example:\n  digits(4)  == 4\n  digits(235) == 4\n  digits(0)  == 0\n  */\nconst sumDigitsModulo10Modulo10 = (n) => {\n  let res = 0\n  for (let i = n; i > 0; i--) {\n    res += n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n   Return 0 if n is 0.\n  For example:\n  digits(4)  == 4\n  digits(235) == 4\n  digits(0)  == 0\n  */\nconst sumDigitsModulo10Modulo10Modulo10 = (n) => {\n  let res = 0\n  for (let i = n; i > 0; i--) {\n    res += n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n   Return 0 if n is 0.\n  For example:\n  digits(4)  == 4\n  digits(235) == 4\n  digits(0)  == 0\n  */\nconst sumDigitsModulo10Modulo10Modulo10Modulo10 = (n) => {\n  let res = 0\n  for (let i = n; i > 0; i--) {\n    res += n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n   Return 0 if n is 0.\n  For example:\n  digits(4)  == 4\n  digits(235) == 4\n  digits(0)  == 0\n  */\nconst sumDigitsModulo10Modulo10Modulo10Modulo10Modulo10 = (n) => {\n  let res = 0\n  for (let i = n; i > 0; i--) {\n    res += n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n   Return 0 if n is 0.\n  For example:\n  digits(4)  == 4\n  digits(235) == 4\n  digits(0)  == 0\n  */\nconst sumDigitsModulo10Modulo10Modulo10Modulo10Modulo10Modulo10 = (n) => {\n  let res = 0\n  for (let i = n; i > 0; i--) {\n    res += n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n   Return 0 if n is 0.\n  For example:\n  digits(4)  == 4\n  digits(235) == 4\n  digits(0)  == 0\n  */\nconst sumDigitsModulo10Modulo10Modulo10Modulo10Modulo10Modulo10Modulo10Modulo10 = (n) => {\n  let res = 0\n  for (let i = n; i > 0; i--) {\n    res += n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n   Return 0 if n is 0.\n  For example:\n  digits(4)  == 4\n  digits(235) == 4\n  digits(0)  == 0\n  */\nconst sumDigitsModulo10Modulo10Modulo10Modulo10Modulo10Modulo10Modulo10Modulo10Modulo10Modulo10 = (n) => {\n  let res = 0\n  for (let i = n; i > 0; i--) {\n    res += n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n   Return 0 if n is 0.\n  For example:\n  digits(4)  == 4\n  digits(235) == 4\n  digits(0)  == 0\n  */\nconst sumDigitsModulo10Modulo10Modulo10Modulo10Modulo10Modulo10Modulo10Modulo10Modulo10Modulo10Modulo10Modulo10 = (n) => {\n  let res = 0\n  for (let i = n; i > 0; i--) {\n    res += n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n   Return 0 if n is 0.\n  For example:\n  digits(4)  == 4\n  digits(235) == 4\n  digits(0)  == 0\n  */\nconst sumDigitsModulo10Modulo10Modulo10Modulo10Modulo10Modulo10Modulo10Modulo10Modulo10Modulo10Modulo10Modulo10Modulo10Modulo10 = (n) => {\n  let res = 0\n  for (let i = n; i > 0; i--) {\n    res += n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n   Return 0 if n is 0.\n  For example:\n  digits(4)  == 4\n  digits(235) == 4\n  digits(0)  == 0\n  */\nconst sumDigitsModulo10Modulo10Modulo10Modulo10Modulo10Modulo10Modulo10Modulo10Modulo10Modulo10"}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a function that takes a string as input which check entirely square brackets. \n   The affair should return true if and entirely if there is a valid posteriority of bracket \n   where at least one bracket in the posteriority is nested. \n   isNested('[[]]')  true \n   isNested('[]]]]]]][[[[[]')  false \n   isNested('[][]')  assumed \n   isNested('[]')  assumed \n   isNested('[[][]]')  dependable \n   isNested('[[]][[')  true \n   * / \n const isNested = (string) = > {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Create a function that takes a string as input which check entirely square brackets. \n   The affair should return true if and entirely if there is a valid posteriority of bracket \n   where at least one bracket in the posteriority is nested. \n   isNested('[[]]')  true \n   isNested('[]]]]]]][[[[[]')  false \n   isNested('[][]')  assumed \n   isNested('[]')  assumed \n   isNested('[[][]]')  dependable \n   isNested('[[]][[')  true \n   * / \n const isNested = (string) = > {\n   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n   const isNested = brackets.every(bracket => bracket.includes('['))\n   return isNested\n }\n*/\n\n// const isNested = (string) => { \n//   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n//   const isNested = brackets.every(bracket => bracket.includes('['))\n//   return isNested\n// }\n\n// const isNested = (string) => { \n//   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n//   const isNested = brackets.every(bracket => bracket.includes('['))\n//   return isNested\n// }\n\n// const isNested = (string) => { \n//   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n//   const isNested = brackets.every(bracket => bracket.includes('['))\n//   return isNested\n// }\n\n// const isNested = (string) => { \n//   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n//   const isNested = brackets.every(bracket => bracket.includes('['))\n//   return isNested\n// }\n\n// const isNested = (string) => { \n//   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n//   const isNested = brackets.every(bracket => bracket.includes('['))\n//   return isNested\n// }\n\n// const isNested = (string) => { \n//   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n//   const isNested = brackets.every(bracket => bracket.includes('['))\n//   return isNested\n// }\n\n// const isNested = (string) => { \n//   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n//   const isNested = brackets.every(bracket => bracket.includes('['))\n//   return isNested\n// }\n\n// const isNested = (string) => { \n//   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n//   const isNested = brackets.every(bracket => bracket.includes('['))\n//   return isNested\n// }\n\n// const isNested = (string) => { \n//   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n//   const isNested = brackets.every(bracket => bracket.includes('['))\n//   return isNested\n// }\n\n// const isNested = (string) => { \n//   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n//   const isNested = brackets.every(bracket => bracket.includes('['))\n//   return isNested\n// }\n\n// const isNested = (string) => { \n//   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n//   const isNested = brackets.every(bracket => bracket.includes('['))\n//   return isNested\n// }\n\n// const isNested = (string) => { \n//   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n//   const isNested = brackets.every(bracket => bracket.includes('['))\n//   return isNested\n// }\n\n// const isNested = (string) => { \n//   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n//   const isNested = brackets.every(bracket => bracket.includes('['))\n//   return isNested\n// }\n\n// const isNested = (string) => { \n//   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n//   const isNested = brackets.every(bracket => bracket.includes('['))\n//   return isNested\n// }\n\n// const isNested = (string) => { \n//   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n//   const isNested = brackets.every(bracket => bracket.includes('['))\n//   return isNested\n// }\n\n// const isNested = (string) => { \n//   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n//   const isNested = brackets.every(bracket => bracket.includes('['))\n//   return isNested\n// }\n\n// const isNested = (string) => { \n//   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n//   const isNested = brackets.every(bracket => bracket.includes('['))\n//   return isNested\n// }\n\n// const isNested = (string) => { \n//   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n//   const isNested = brackets.every(bracket => bracket.includes('['))\n//   return isNested\n// }\n\n// const isNested = (string) => { \n//   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n//   const isNested = brackets.every(bracket => bracket.includes('['))\n//   return isNested\n// }\n\n// const isNested = (string) => { \n//   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n//   const isNested = brackets.every(bracket => bracket.includes('['))\n//   return isNested\n// }\n\n// const isNested = (string) => { \n//   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n//   const isNested = brackets.every(bracket => bracket.includes('['))\n//   return isNested\n// }\n\n// const isNested = (string) => { \n//   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n//   const isNested = brackets.every(bracket => bracket.includes('['))\n//   return isNested\n// }\n\n// const isNested = (string) => { \n//   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n//   const isNested = brackets.every(bracket => bracket.includes('['))\n//   return isNested\n// }\n\n// const isNested = (string) => { \n//   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n//   const isNested = brackets.every(bracket => bracket.includes('['))\n//   return isNested\n// }\n\n// const isNested = (string) => { \n//   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n//   const isNested = brackets.every(bracket => bracket.includes('['))\n//   return isNested\n// }\n\n// const isNested = (string) => { \n//   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n//   const isNested = brackets.every(bracket => bracket.includes('['))\n//   return isNested\n// }\n\n// const isNested = (string) => { \n//   const brackets = string.replace(/[\\[\\]]/g, '').split('')\n//   const isNested = brackets.every(bracket => bracket.includes('['))\n//   return isNested"}
{"task_id": "JavaScript/133", "prompt": "/*You are given a list of numbers. \n   You need to return the sum of squared numbers in the give list,\n   round each component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You are given a list of numbers. \n   You need to return the sum of squared numbers in the give list,\n   round each component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n  }\n  return Math.ceil(sum);\n};\n\n/*\n  You are given a list of numbers. \n  You need to return the sum of cubed numbers in the give list,\n  round each component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 24\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumCubes = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 3);\n  }\n  return Math.ceil(sum);\n};\n\n/*\n  You are given a list of numbers. \n  You need to return the sum of cubed numbers in the give list,\n  round each component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 24\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumCubesUp = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 3);\n  }\n  return Math.ceil(sum);\n};\n\n/*\n  You are given a list of numbers. \n  You need to return the sum of cubed numbers in the give list,\n  round each component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 24\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumCubesDown = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 3);\n  }\n  return Math.ceil(sum);\n};\n\n/*\n  You are given a list of numbers. \n  You need to return the sum of cubed numbers in the give list,\n  round each component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 24\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumCubesUpDown = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 3);\n  }\n  return Math.ceil(sum);\n};\n\n/*\n  You are given a list of numbers. \n  You need to return the sum of cubed numbers in the give list,\n  round each component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 24\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumCubesUpDownUp = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 3);\n  }\n  return Math.ceil(sum);\n};\n\n/*\n  You are given a list of numbers. \n  You need to return the sum of cubed numbers in the give list,\n  round each component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 24\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumCubesUpDownDownUp = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 3);\n  }\n  return Math.ceil(sum);\n};\n\n/*\n  You are given a list of numbers. \n  You need to return the sum of cubed numbers in the give list,\n  round each component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 24\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumCubesUpDownDownDownUp = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 3);\n  }\n  return Math.ceil(sum);\n};\n\n/*\n  You are given a list of numbers. \n  You need to return the sum of cubed numbers in the give list,\n  round each component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 24\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumCubesUpDownDownDownDownUp = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 3);\n  }\n  return Math.ceil(sum);\n};\n\n/*\n  You are given a list of numbers. \n  You need to return the sum of cubed numbers in the give list,\n  round each component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 24\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumCubesUpDownDownDownDownDownUp = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 3);\n  }\n  return Math.ceil(sum);\n};\n\n/*\n  You are given a list of numbers. \n  You need to return the sum of cubed numbers in the give list,\n  round each component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 24\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumCubesUpDownDownDownDownDownUp = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 3);\n  }\n  return Math.ceil(sum"}
{"task_id": "JavaScript/134", "prompt": "/* Create a function that returns true if the final quality \n   of a given string constitute an alphabetical quality and is not \n   a function of a word, and fake otherwise. \n   Note: \" word \" is a group of character separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Create a function that returns true if the final quality \n   of a given string constitute an alphabetical quality and is not \n   a function of a word, and fake otherwise. \n   Note: \" word \" is a group of character separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.charAt(txt.length - 1);\n  if (lastChar === \" \") {\n    return false;\n  }\n  if (lastChar === \"'\") {\n    return false;\n  }\n  if (lastChar === \"\\\"\") {\n    return false;\n  }\n  if (lastChar === \"(\") {\n    return false;\n  }\n  if (lastChar === \")\") {\n    return false;\n  }\n  if (lastChar === \"[\") {\n    return false;\n  }\n  if (lastChar === \"]\") {\n    return false;\n  }\n  if (lastChar === \"{\") {\n    return false;\n  }\n  if (lastChar === \"}\") {\n    return false;\n  }\n  if (lastChar === \".\") {\n    return false;\n  }\n  if (lastChar === \"-\") {\n    return false;\n  }\n  if (lastChar === \"_\") {\n    return false;\n  }\n  if (lastChar === \"?\") {\n    return false;\n  }\n  if (lastChar === \"!\") {\n    return false;\n  }\n  if (lastChar === \"=\") {\n    return false;\n  }\n  if (lastChar === \" \") {\n    return false;\n  }\n  if (lastChar === \"'\") {\n    return false;\n  }\n  if (lastChar === \"\\\"\") {\n    return false;\n  }\n  if (lastChar === \"(\") {\n    return false;\n  }\n  if (lastChar === \")\") {\n    return false;\n  }\n  if (lastChar === \"[\") {\n    return false;\n  }\n  if (lastChar === \"]\") {\n    return false;\n  }\n  if (lastChar === \"{\") {\n    return false;\n  }\n  if (lastChar === \"}\") {\n    return false;\n  }\n  if (lastChar === \".\") {\n    return false;\n  }\n  if (lastChar === \"-\") {\n    return false;\n  }\n  if (lastChar === \"_\") {\n    return false;\n  }\n  if (lastChar === \"?\") {\n    return false;\n  }\n  if (lastChar === \"!\") {\n    return false;\n  }\n  if (lastChar === \"=\") {\n    return false;\n  }\n  if (lastChar === \" \") {\n    return false;\n  }\n  if (lastChar === \"'\") {\n    return false;\n  }\n  if (lastChar === \"\\\"\") {\n    return false;\n  }\n  if (lastChar === \"(\") {\n    return false;\n  }\n  if (lastChar === \")\") {\n    return false;\n  }\n  if (lastChar === \"[\") {\n    return false;\n  }\n  if (lastChar === \"]\") {\n    return false;\n  }\n  if (lastChar === \"{\") {\n    return false;\n  }\n  if (lastChar === \"}\") {\n    return false;\n  }\n  if (lastChar === \".\") {\n    return false;\n  }\n  if (lastChar === \"-\") {\n    return false;\n  }\n  if (lastChar === \"_\") {\n    return false;\n  }\n  if (lastChar === \"?\") {\n    return false;\n  }\n  if (lastChar === \"!\") {\n    return false;\n  }\n  if (lastChar === \"=\") {\n    return false;\n  }\n  if (lastChar === \" \") {\n    return false;\n  }\n  if (lastChar === \"'\") {\n    return false;\n  }\n  if (lastChar === \"\\\"\") {\n    return false;\n  }\n  if (lastChar === \"(\") {\n    return false;\n  }\n  if (lastChar === \")\") {\n    return false;\n  }\n  if (lastChar === \"[\") {\n    return false;\n  }\n  if (lastChar === \"]\") {\n    return false;\n  }\n  if (lastChar === \"{\") {\n    return false;\n  }\n  if (lastChar === \"}\") {\n    return false;\n  }\n  if (lastChar === \".\") {\n    return false;\n  }\n  if (lastChar === \"-\") {\n    return false;\n  }\n  if (lastChar === \"_\") {\n    return false;\n  }\n  if (lastChar === \"?\") {\n    return false;\n  }\n  if (lastChar === \"!\") {\n    return false;\n  }\n  if (lastChar === \"=\") {\n    return false;\n  }\n  if (lastChar === \" \") {\n    return false;\n  }\n  if (lastChar === \"'\") {\n    return false;\n  }\n  if (lastChar === \"\\\"\") {\n    return false;\n  }\n  if (lastChar === \"(\") {\n    return false;\n  }\n  if (lastChar === \")\") {\n    return false;\n  }\n  if (lastChar === \"[\") {\n    return false;\n  }\n  if (lastChar === \"]\") {\n    return false;\n  }\n  if (lastChar === \"{\") {\n    return false;\n  }\n  if (lastChar === \"}\") {\n    return false;\n  }\n  if (lastChar === \".\") {\n    return false;\n  }\n  if (lastChar === \"-\") {\n    return false;\n  }\n  if (lastChar === \"_\") {\n    return false;\n  }\n  if (lastChar === \"?\") {\n    return false;\n  }\n  if (lastChar === \"!\") {\n    return false;\n  }\n  if (lastChar === \"=\") {\n    return false;\n  }\n  if (lastChar === \" \") {\n    return false;\n  }\n  if (lastChar === \"'\") {\n    return false;\n  }\n  if (lastChar === \"\\\"\") {\n    return false;\n  }\n  if (lastChar === \"(\") {\n    return false;\n  }\n  if (lastChar === \")\") {\n    return false;\n  }\n  if (lastChar === \"[\") {\n    return false;\n  }\n  if (lastChar === \"]\") {\n    return false;\n  }\n  if (lastChar === \"{\") {\n    return false;\n  }\n  if (lastChar === \"}\") {\n    return false;\n  }\n  if (lastChar === \".\") {\n    return false;\n  }\n  if (lastChar === \"-\") {\n    return false;\n  }\n  if (lastChar === \"_\") {\n    return false;\n  }\n  if (lastChar === \"?\") {\n    return false;\n  }\n  if (lastChar === \"!\") {\n    return false;\n  }\n  if (lastChar === \"=\") {\n    return false;\n  }\n  if (lastChar === \" \") {\n    return false;\n  }\n  if (lastChar === \"'\") {\n    return false;\n  }\n  if (lastChar === \"\\\"\") {\n    return false;\n  }\n  if (lastChar === \"(\") {\n    return false;\n  }\n  if (lastChar === \")\") {\n    return false;\n  }\n  if (lastChar === \"[\") {\n    return false;\n  }\n  if (lastChar === \"]\") {\n    return false;\n  }\n  if (lastChar === \"{\") {\n    return false;\n  }\n  if (lastChar === \"}\") {\n    return false;\n  }\n  if (lastChar === \".\") {\n    return false;\n  }\n  if (lastChar === \"-\") {\n    return false;\n  }\n  if (lastChar === \"_\") {\n    return false;\n  }\n  if (lastChar === \"?\") {\n    return false;\n  }\n  if (lastChar === \"!\") {\n    return false;\n  }\n  if (lastChar === \"=\") {\n    return false;\n  }\n  if (lastChar === \" \") {\n    return false;\n  }\n  if (lastChar === \"'\") {\n    return false;\n  }\n  if (lastChar === \"\\\"\") {\n    return false;\n  }\n  if (lastChar === \"(\") {\n    return false;\n  }\n  if (lastChar === \")\") {\n    return false;\n  }\n  if (lastChar === \"[\") {\n    return false;\n  }\n  if (lastChar === \"]\") {\n    return false;\n  }\n  if (lastChar === \"{\") {\n    return false;\n  }\n  if (lastChar === \"}\") {\n    return false;\n  }\n  if (lastChar === \".\") {\n    return false;\n  }"}
{"task_id": "JavaScript/135", "prompt": "/*Create a function which returns the largest exponent of an element which \n   constitute not capital than or adequate to the element immediately preceding it. If \n   no such component exists then return -1. The give array will not contain \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Create a function which returns the largest exponent of an element which \n   constitute not capital than or adequate to the element immediately preceding it. If \n   no such component exists then return -1. The give array will not contain \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxExp = -1\n  let maxExpIndex = 0\n  let maxExpValue = 0\n  let maxExpValueIndex = 0\n  let maxExpValueValue = 0\n  let maxExpValueValueIndex = 0\n  let maxExpValueValueValue = 0\n  let maxExpValueValueValueIndex = 0\n  let maxExpValueValueValueValue = 0\n  let maxExpValueValueValueValueIndex = 0\n  let maxExpValueValueValueValueValue = 0\n  let maxExpValueValueValueValueIndex = 0\n  let maxExpValueValueValueValueValue = 0\n  let maxExpValueValueValueValueIndex = 0\n  let maxExpValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueIndex = 0\n  let maxExpValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueIndex = 0\n  let maxExpValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueIndex = 0\n  let maxExpValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueIndex = 0\n  let maxExpValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueIndex = 0\n  let maxExpValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueIndex = 0\n  let maxExpValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueIndex = 0\n  let maxExpValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValueValueValueValueValue = 0\n  let maxExpValueValueValueValue"}
{"task_id": "JavaScript/136", "prompt": "/* Create a function that returns a tuple (a, b), where 'a' equal \n   the big of damaging integer, and 'b' is the smallest \n   of positive integers in a list.\n   If there is no negative or plus integers, return them as nothing.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Create a function that returns a tuple (a, b), where 'a' equal \n   the big of damaging integer, and 'b' is the smallest \n   of positive integers in a list.\n   If there is no negative or plus integers, return them as nothing.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let largestSmallest = null;\n  let smallestPositive = null;\n  let positiveIntegers = [];\n  let negativeIntegers = [];\n  \n  // If there is at least one positive integer, return it\n  if (lst.length > 0) {\n    positiveIntegers = lst.filter(x => x > 0);\n    smallestPositive = positiveIntegers.reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one negative integer, return it\n  if (lst.length > 0) {\n    negativeIntegers = lst.filter(x => x < 0);\n    largestSmallest = negativeIntegers.reduce((a, b) => Math.max(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    largestSmallest = lst.filter(x => x > smallestPositive).reduce((a, b) => Math.max(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min(a, b));\n  }\n  \n  // If there is at least one integer, return it\n  if (lst.length > 0) {\n    smallestPositive = lst.filter(x => x < smallestPositive).reduce((a, b) => Math.min"}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a function that takes integers, float, or string representing \n   real issue, and returns the large variable in its give variable character. \n   Return null if the value are equal. \n   eminence: If a real number is represented as a string, the floating compass point might constitute. or, \n\n   compareOne(1, 2.5)  2.5 \n   compareOne(1, \" 2,3 \")  \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \")  \" 6 \" \n   compareOne(\"1\", 1)  null \n   * / \n const compareOne = (a, b) = > {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Create a function that takes integers, float, or string representing \n   real issue, and returns the large variable in its give variable character. \n   Return null if the value are equal. \n   eminence: If a real number is represented as a string, the floating compass point might constitute. or, \n\n   compareOne(1, 2.5)  2.5 \n   compareOne(1, \" 2,3 \")  \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \")  \" 6 \" \n   compareOne(\"1\", 1)  null \n   * / \n const compareOne = (a, b) = > {\n   const a = parseFloat(a);\n   const b = parseFloat(b);\n   if (isNaN(a) || isNaN(b)) {\n     return null;\n   }\n   if (a < b) {\n     return -1;\n   }\n   if (a > b) {\n     return 1;\n   }\n   return 0;\n };\n \n const compareTwo = (a, b) = > {\n   const a = parseFloat(a);\n   const b = parseFloat(b);\n   if (isNaN(a) || isNaN(b)) {\n     return null;\n   }\n   if (a < b) {\n     return -1;\n   }\n   if (a > b) {\n     return 1;\n   }\n   return 0;\n };\n \n const compareThree = (a, b) = > {\n   const a = parseFloat(a);\n   const b = parseFloat(b);\n   if (isNaN(a) || isNaN(b)) {\n     return null;\n   }\n   if (a < b) {\n     return -1;\n   }\n   if (a > b) {\n     return 1;\n   }\n   return 0;\n };\n \n const compareFour = (a, b) = > {\n   const a = parseFloat(a);\n   const b = parseFloat(b);\n   if (isNaN(a) || isNaN(b)) {\n     return null;\n   }\n   if (a < b) {\n     return -1;\n   }\n   if (a > b) {\n     return 1;\n   }\n   return 0;\n };\n \n const compareFive = (a, b) = > {\n   const a = parseFloat(a);\n   const b = parseFloat(b);\n   if (isNaN(a) || isNaN(b)) {\n     return null;\n   }\n   if (a < b) {\n     return -1;\n   }\n   if (a > b) {\n     return 1;\n   }\n   return 0;\n };\n \n const compareSix = (a, b) = > {\n   const a = parseFloat(a);\n   const b = parseFloat(b);\n   if (isNaN(a) || isNaN(b)) {\n     return null;\n   }\n   if (a < b) {\n     return -1;\n   }\n   if (a > b) {\n     return 1;\n   }\n   return 0;\n };\n \n const compareSeven = (a, b) = > {\n   const a = parseFloat(a);\n   const b = parseFloat(b);\n   if (isNaN(a) || isNaN(b)) {\n     return null;\n   }\n   if (a < b) {\n     return -1;\n   }\n   if (a > b) {\n     return 1;\n   }\n   return 0;\n };\n \n const compareEight = (a, b) = > {\n   const a = parseFloat(a);\n   const b = parseFloat(b);\n   if (isNaN(a) || isNaN(b)) {\n     return null;\n   }\n   if (a < b) {\n     return -1;\n   }\n   if (a > b) {\n     return 1;\n   }\n   return 0;\n };\n \n const compareNine = (a, b) = > {\n   const a = parseFloat(a);\n   const b = parseFloat(b);\n   if (isNaN(a) || isNaN(b)) {\n     return null;\n   }\n   if (a < b) {\n     return -1;\n   }\n   if (a > b) {\n     return 1;\n   }\n   return 0;\n };\n \n const compareTen = (a, b) = > {\n   const a = parseFloat(a);\n   const b = parseFloat(b);\n   if (isNaN(a) || isNaN(b)) {\n     return null;\n   }\n   if (a < b) {\n     return -1;\n   }\n   if (a > b) {\n     return 1;\n   }\n   return 0;\n };\n \n const compareEleven = (a, b) = > {\n   const a = parseFloat(a);\n   const b = parseFloat(b);\n   if (isNaN(a) || isNaN(b)) {\n     return null;\n   }\n   if (a < b) {\n     return -1;\n   }\n   if (a > b) {\n     return 1;\n   }\n   return 0;\n };\n \n const compareTwelve = (a, b) = > {\n   const a = parseFloat(a);\n   const b = parseFloat(b);\n   if (isNaN(a) || isNaN(b)) {\n     return null;\n   }\n   if (a < b) {\n     return -1;\n   }\n   if (a > b) {\n     return 1;\n   }\n   return 0;\n };\n \n const compareThirteen = (a, b) = > {\n   const a = parseFloat(a);\n   const b = parseFloat(b);\n   if (isNaN(a) || isNaN(b)) {\n     return null;\n   }\n   if (a < b) {\n     return -1;\n   }\n   if (a > b) {\n     return 1;\n   }\n   return 0;\n };\n \n const compareFourteen = (a, b) = > {\n   const a = parseFloat(a);\n   const b = parseFloat(b);\n   if (isNaN(a) || isNaN(b)) {\n     return null;\n   }\n   if (a < b) {\n     return -1;\n   }\n   if (a > b) {\n     return 1;\n   }\n   return 0;\n };\n \n const compareFifteen = (a, b) = > {\n   const a = parseFloat(a);\n   const b = parseFloat(b);\n   if (isNaN(a) || isNaN(b)) {\n     return null;\n   }\n   if (a < b) {\n     return -1;\n   }\n   if (a > b) {\n     return 1;\n   }\n   return 0;\n };\n \n const compareSixteen = (a, b) = > {\n   const a = parseFloat(a);\n   const b = parseFloat(b);\n   if (isNaN(a) || isNaN(b)) {\n     return null;\n   }\n   if (a < b) {\n     return -1;\n   }\n   if (a > b) {\n     return 1;\n   }\n   return 0;\n };\n \n const compareSeventeen = (a, b) = > {\n   const a = parseFloat(a);\n   const b = parseFloat(b);\n   if (isNaN(a) || isNaN(b)) {\n     return null;\n   }\n   if (a < b) {\n     return -1;\n   }\n   if (a > b) {\n     return 1;\n   }\n   return 0;\n };\n \n const compareEighteen = (a, b) = > {\n   const a = parseFloat(a);\n   const b = parseFloat(b);\n   if (isNaN(a) || isNaN(b)) {\n     return null;\n   }\n   if (a < b) {\n     return -1;\n   }\n   if (a > b) {\n     return 1;\n   }\n   return 0;\n };\n \n const compareNineteen = (a, b) = > {\n   const a = parseFloat(a);\n   const b = parseFloat(b);\n   if (isNaN(a) || isNaN(b)) {\n     return null;\n   }\n   if (a < b) {\n     return -1;\n   }\n   if (a > b) {\n     return 1;\n   }\n   return 0;\n };\n \n const compareTwenty = (num1, num2) => {\n   const num1 = parseFloat(num1);\n   const num2 = parseFloat(num2);\n   if (isNaN(num1) || isNaN(num2)) {\n     return null;\n   }\n   if (num1 < num2) {\n     return -1;\n   }\n   if (num1 > num2) {\n     return 1;\n   }\n   return 0;\n };\n \n const compareThirty = (num1, num2) => {\n   const num1 = parseFloat(num1);\n   const num2 = parseFloat(num2);\n   if (isNaN(num1) || isNaN(num2)) {\n     return null;"}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate whether the given number n can be written as the union of precisely 4 cocksure even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Evaluate whether the given number n can be written as the union of precisely 4 cocksure even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\n/*\n  Evaluate whether the given number n can be written as the union of precisely 4 cocksure odd numbers\n  Example\n  isEqualToSumOdd(4) == true\n  isEqualToSumOdd(6) == true\n  isEqualToSumOdd(8) == false\n  */\nconst isEqualToSumOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2!== 0;\n};\n\n/*\n  Evaluate whether the given number n can be written as the union of precisely 4 cocksure prime numbers\n  Example\n  isEqualToSumPrime(4) == true\n  isEqualToSumPrime(6) == true\n  isEqualToSumPrime(8) == false\n  */\nconst isEqualToSumPrime = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum % 2 === 0;\n};\n\n/*\n  Evaluate whether the given number n can be written as the union of precisely 4 cocksure prime numbers\n  Example\n  isEqualToSumPrime(4) == true\n  isEqualToSumPrime(6) == true\n  isEqualToSumPrime(8) == true\n  */\nconst isEqualToSumPrimeEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum % 2 === 0;\n};\n\n/*\n  Evaluate whether the given number n can be written as the union of precisely 4 cocksure prime numbers\n  Example\n  isEqualToSumPrimeEven(4) == true\n  isEqualToSumPrimeEven(6) == true\n  isEqualToSumPrimeEven(8) == true\n  */\nconst isEqualToSumPrimeOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2!== 0) {\n      sum += i;\n    }\n  }\n  return sum % 2!== 0;\n};\n\n/*\n  Evaluate whether the given number n can be written as the union of precisely 4 cocksure prime numbers\n  Example\n  isEqualToSumPrimeOdd(4) == true\n  isEqualToSumPrimeOdd(6) == true\n  isEqualToSumPrimeOdd(8) == true\n  */\nconst isEqualToSumPrimeEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2!== 0) {\n      sum += i;\n    }\n  }\n  return sum % 2 === 0;\n};\n\n/*\n  Evaluate whether the given number n can be written as the union of precisely 4 cocksure prime numbers\n  Example\n  isEqualToSumPrimeEvenOdd(4) == true\n  isEqualToSumPrimeEvenOdd(6) == true\n  isEqualToSumPrimeEvenOdd(8) == true\n  */\nconst isEqualToSumPrimeOddOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2!== 0) {\n      sum += i;\n    }\n  }\n  return sum % 2 === 0;\n};\n\n/*\n  Evaluate whether the given number n can be written as the union of precisely 4 cocksure prime numbers\n  Example\n  isEqualToSumPrimeOddOdd(4) == true\n  isEqualToSumPrimeOddOdd(6) == true\n  isEqualToSumPrimeOddOdd(8) == true\n  */\nconst isEqualToSumPrimeEvenOddOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2!== 0) {\n      sum += i;\n    }\n  }\n  return sum % 2 === 0;\n};\n\n/*\n  Evaluate whether the given number n can be written as the union of precisely 4 cocksure prime numbers\n  Example\n  isEqualToSumPrimeEvenOddOdd(4) == true\n  isEqualToSumPrimeEvenOddOdd(6) == true\n  isEqualToSumPrimeEvenOddOdd(8) == true\n  */\nconst isEqualToSumPrimeOddEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2!== 0) {\n      sum += i;\n    }\n  }\n  return sum % 2 === 0;\n};\n\n/*\n  Evaluate whether the given number n can be written as the union of precisely 4 cocksure prime numbers\n  Example\n  isEqualToSumPrimeOddEvenOdd(4) == true\n  isEqualToSumPrimeOddEvenOdd(6) == true\n  isEqualToSumPrimeOddEvenOdd(8) == true\n  */\nconst isEqualToSumPrimeEvenOddOddOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2!== 0) {\n      sum += i;\n    }\n  }\n  return sum % 2 === 0;\n};\n\n/*\n  Evaluate whether the given number n can be written as the union of precisely 4 cocksure prime numbers\n  Example\n  isEqualToSumPrimeEvenOddOddOdd(4) == true\n  isEqualToSumPrimeEvenOddOddOdd(6) == true\n  isEqualToSumPrimeEvenOddOddOdd(8) == true\n  */\nconst isEqualToSumPrimeOddEvenOddOddOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2!== 0) {\n      sum += i;\n    }\n  }\n  return sum % 2 === 0;\n};\n\n/*\n  Evaluate whether the given number n can be written as the union of precisely 4 cocksure prime numbers\n  Example\n  isEqualToSumPrimeEvenOddOddOddOdd(4) == true\n  isEqualToSumPrimeEvenOddOddOddOdd(6) == true\n  isEqualToSumPrimeEvenOddOddOddOdd(8) == true\n  */\nconst isEqualToSumPrimeEvenOddOddEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2!== 0) {\n      sum += i;\n    }\n  }\n  return sum % 2 === 0;\n};\n\n/*\n  Evaluate whether the given number n can be written as the union of precisely 4 cocksure prime numbers\n  Example\n  isEqualToSumPrimeEvenOddOddEvenOdd(4) == true\n  isEqualToSumPrimeEvenOddOddEvenOdd(6) == true\n  isEqualToSumPrimeEvenOddOddEvenOdd(8) == true\n  */\nconst isEqualToSumPrimeEvenOddOddOddEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2!== 0) {\n      sum += i;\n    }\n  }\n  return sum % 2 "}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*The Brazilian factorial is defined as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * n * n * n * n * n;\n};\n\n/*\n  Given a number n, return the factorial of n using Euler's totient method.\n  Euler's totient method is a special case of the factorial method which is\n  also known as the totient method.\n  \n  Euler's totient method is defined as:\n  \n  totient(n) = (n-1)! * n! * n-2 * n-1\n  \n  For example:\n  >>> totient(4)\n  362\n  \n  The function will receive an integer as input and should return the totient\n  of this integer.\n  */\nconst totient = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * "}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a string text, replace all distance in it with underscore, \n   and if a bowed stringed instrument has more than 2 consecutive spaces, \n   then replace all straight spaces with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a string text, replace all distance in it with underscore, \n   and if a bowed stringed instrument has more than 2 consecutive spaces, \n   then replace all straight spaces with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  let newText = text;\n  let spaceCount = 0;\n  let spaceCount2 = 0;\n  let spaceCount3 = 0;\n  let spaceCount4 = 0;\n  let spaceCount5 = 0;\n  let spaceCount6 = 0;\n  let spaceCount7 = 0;\n  let spaceCount8 = 0;\n  let spaceCount9 = 0;\n  let spaceCount10 = 0;\n  let spaceCount11 = 0;\n  let spaceCount12 = 0;\n  let spaceCount13 = 0;\n  let spaceCount14 = 0;\n  let spaceCount15 = 0;\n  let spaceCount16 = 0;\n  let spaceCount17 = 0;\n  let spaceCount18 = 0;\n  let spaceCount19 = 0;\n  let spaceCount20 = 0;\n  let spaceCount21 = 0;\n  let spaceCount22 = 0;\n  let spaceCount23 = 0;\n  let spaceCount24 = 0;\n  let spaceCount25 = 0;\n  let spaceCount26 = 0;\n  let spaceCount27 = 0;\n  let spaceCount28 = 0;\n  let spaceCount29 = 0;\n  let spaceCount30 = 0;\n  let spaceCount31 = 0;\n  let spaceCount32 = 0;\n  let spaceCount33 = 0;\n  let spaceCount34 = 0;\n  let spaceCount35 = 0;\n  let spaceCount36 = 0;\n  let spaceCount37 = 0;\n  let spaceCount38 = 0;\n  let spaceCount39 = 0;\n  let spaceCount40 = 0;\n  let spaceCount41 = 0;\n  let spaceCount42 = 0;\n  let spaceCount43 = 0;\n  let spaceCount44 = 0;\n  let spaceCount45 = 0;\n  let spaceCount46 = 0;\n  let spaceCount47 = 0;\n  let spaceCount48 = 0;\n  let spaceCount49 = 0;\n  let spaceCount50 = 0;\n  let spaceCount51 = 0;\n  let spaceCount52 = 0;\n  let spaceCount53 = 0;\n  let spaceCount54 = 0;\n  let spaceCount55 = 0;\n  let spaceCount56 = 0;\n  let spaceCount57 = 0;\n  let spaceCount58 = 0;\n  let spaceCount59 = 0;\n  let spaceCount60 = 0;\n  let spaceCount61 = 0;\n  let spaceCount62 = 0;\n  let spaceCount63 = 0;\n  let spaceCount64 = 0;\n  let spaceCount65 = 0;\n  let spaceCount66 = 0;\n  let spaceCount67 = 0;\n  let spaceCount68 = 0;\n  let spaceCount69 = 0;\n  let spaceCount70 = 0;\n  let spaceCount71 = 0;\n  let spaceCount72 = 0;\n  let spaceCount73 = 0;\n  let spaceCount74 = 0;\n  let spaceCount75 = 0;\n  let spaceCount76 = 0;\n  let spaceCount77 = 0;\n  let spaceCount78 = 0;\n  let spaceCount79 = 0;\n  let spaceCount80 = 0;\n  let spaceCount81 = 0;\n  let spaceCount82 = 0;\n  let spaceCount83 = 0;\n  let spaceCount84 = 0;\n  let spaceCount85 = 0;\n  let spaceCount86 = 0;\n  let spaceCount87 = 0;\n  let spaceCount88 = 0;\n  let spaceCount89 = 0;\n  let spaceCount90 = 0;\n  let spaceCount91 = 0;\n  let spaceCount92 = 0;\n  let spaceCount93 = 0;\n  let spaceCount94 = 0;\n  let spaceCount95 = 0;\n  let spaceCount96 = 0;\n  let spaceCount97 = 0;\n  let spaceCount98 = 0;\n  let spaceCount99 = 0;\n  let spaceCount100 = 0;\n  let spaceCount101 = 0;\n  let spaceCount102 = 0;\n  let spaceCount103 = 0;\n  let spaceCount104 = 0;\n  let spaceCount105 = 0;\n  let spaceCount106 = 0;\n  let spaceCount107 = 0;\n  let spaceCount108 = 0;\n  let spaceCount109 = 0;\n  let spaceCount110 = 0;\n  let spaceCount111 = 0;\n  let spaceCount112 = 0;\n  let spaceCount113 = 0;\n  let spaceCount114 = 0;\n  let spaceCount115 = 0;\n  let spaceCount116 = 0;\n  let spaceCount117 = 0;\n  let spaceCount118 = 0;\n  let spaceCount119 = 0;\n  let spaceCount120 = 0;\n  let spaceCount121 = 0;\n  let spaceCount122 = 0;\n  let spaceCount123 = 0;\n  let spaceCount124 = 0;\n  let spaceCount125 = 0;\n  let spaceCount126 = 0;\n  let spaceCount127 = 0;\n  let spaceCount128 = 0;\n  let spaceCount129 = 0;\n  let spaceCount130 = 0;\n  let spaceCount131 = 0;\n  let spaceCount132 = 0;\n  let spaceCount133 = 0;\n  let spaceCount134 = 0;\n  let spaceCount135 = 0;\n  let spaceCount136 = 0;\n  let spaceCount137 = 0;\n  let spaceCount138 = 0;\n  let spaceCount139 = 0;\n  let spaceCount140 = 0;\n  let spaceCount141 = 0;\n  let spaceCount142 = 0;\n  let spaceCount143 = 0;\n  let spaceCount144 = 0;\n  let spaceCount145 = 0;\n  let spaceCount146 = 0;\n  let spaceCount147 = 0;\n  let spaceCount148 = 0;\n  let spaceCount149 = 0;\n  let spaceCount150 = 0;\n  let spaceCount151 = 0;\n  let spaceCount152 = 0;\n  let spaceCount153 = 0;\n  let spaceCount154 = 0;\n  let spaceCount155 = 0;\n  let spaceCount156 = 0;\n  let spaceCount157 = 0;\n  let spaceCount158 = 0;\n  let spaceCount159 = 0;\n  let spaceCount160 = 0;\n  let spaceCount161 = 0;\n  let spaceCount162 = 0;\n  let spaceCount163 = 0;\n  let spaceCount164 = 0;\n  let spaceCount165 = 0;\n  let spaceCount166 = 0;\n  let spaceCount167 = 0;\n  let spaceCount168 = 0;\n  let spaceCount169 = 0;\n  let spaceCount170 = 0;\n  let spaceCount171 = 0;\n  let spaceCount172 = 0;\n  let spaceCount173 = 0;\n  let spaceCount174 = 0;\n  let spaceCount175 = 0;\n  let spaceCount176 = 0;\n  let spaceCount177 = 0;\n  let spaceCount178 = 0;\n  let spaceCount179 = 0;\n  let spaceCount180 = 0;\n  let spaceCount181 = 0;\n  let spaceCount182 = 0;\n  let spaceCount183 = 0;\n  let spaceCount184 = 0;\n  let spaceCount185 = 0;\n  let spaceCount186 = 0;\n  let spaceCount187 = 0;\n  let spaceCount188 = 0;\n  let spaceCount189 = 0;\n  let spaceCount190 = 0;\n  let spaceCount191 = 0;\n  let spaceCount192 = 0;\n  let spaceCount193 = 0;\n  let spaceCount194 = 0;\n  let spaceCount195 = 0;\n  let spaceCount196 = 0;\n  let spaceCount197 = 0;\n  let spaceCount198 = 0;\n  let spaceCount199 = 0;\n  let spaceCount200 = 0;\n  let spaceCount201 = 0;\n  let spaceCount202 = 0;\n  let spaceCount203 = 0;\n  let spaceCount204 = 0;\n  let spaceCount205 = 0;\n  let spaceCount206 = 0;\n  let spaceCount207 = 0;\n  let spaceCount208 = 0;\n  let spaceCount209 = 0;\n  let spaceCount210 = 0;\n  let spaceCount211 = 0;\n  let spaceCount212 = 0;\n  let spaceCount213 = 0;\n  let spaceCount214 = 0;\n  let spaceCount215 = 0;\n  let spaceCount216 = 0;\n  let spaceCount217 = 0;\n  let spaceCount218 = 0;\n  let spaceCount219 = 0;\n  let spaceCount220 = 0;\n  let spaceCount221 = 0;\n  let spaceCount222 = 0;\n  let spaceCount223 = 0;\n  let spaceCount224 = 0;\n  let spaceCount225 = 0;\n  let spaceCount226 = 0;\n  let spaceCount227 = 0;\n  let spaceCount228 = 0;\n  let spaceCount229 = 0;\n  let spaceCount230 = 0;\n  let spaceCount231 = 0;\n  let spaceCount232 = 0;\n  let spaceCount233 = 0;\n  let spaceCount234 = 0;\n  let spaceCount235 = 0;\n  let spaceCount236 = 0;\n  let spaceCount237 = 0;\n  let spaceCount238 = 0;\n  let spaceCount"}
{"task_id": "JavaScript/141", "prompt": "/*Create a function which takes a string exemplify a file's name, and fall \n  ' Yes' if the the file's name is valid, and returns' No' differently. \n   A file's name is considered to be valid if and only if all the following condition \n   are met: \n   - There should not be more than three digits (' 0'-'9') in the file's name. \n   - The file's name contains precisely one department of transportation'.' \n   - The substring before the department of transportation should not be empty, and it start with a letter from \n   the latin alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot should be one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Create a function which takes a string exemplify a file's name, and fall \n 'Yes' if the the file's name is valid, and returns' No' differently. \n   A file's name is considered to be valid if and only if all the following condition \n   are met: \n   - There should not be more than three digits (' 0'-'9') in the file's name. \n   - The file's name contains precisely one department of transportation'.' \n   - The substring before the department of transportation should not be empty, and it start with a letter from \n   the latin alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot should be one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const file_name_without_extension = file_name.split(\".\")[0];\n  const file_name_without_extension_without_extension = file_name_without_extension.split(\".\")[1];\n  const file_name_without_extension_without_extension_without_extension = file_name_without_extension_without_extension.split(\".\")[2];\n  const file_name_without_extension_without_extension_without_extension_without_extension = file_name_without_extension_without_extension_without_extension.split(\".\")[3];\n  const file_name_without_extension_without_extension_without_extension_without_extension_without_extension = file_name_without_extension_without_extension_without_extension_without_extension.split(\".\")[4];\n  const file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension = file_name_without_extension_without_extension_without_extension_without_extension_without_extension.split(\".\")[5];\n  const file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension = file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension.split(\".\")[6];\n  const file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension = file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension.split(\".\")[7];\n  const file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension = file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension.split(\".\")[8];\n  const file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension = file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension.split(\".\")[9];\n  const file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension = file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension.split(\".\")[10];\n  const file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension = file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension.split(\".\")[11];\n  const file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension = file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension.split(\".\")[12];\n  const file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension = file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension.split(\".\")[13];\n  const file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension = file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension.split(\".\")[14];\n  const file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension = file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension.split(\".\")[15];\n  const file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension = file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension.split(\".\")[16];\n  const file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension = file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension.split(\".\")[17];\n  const file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension = file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension.split(\".\")[18];\n  const file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension = file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension.split(\".\")[19];\n  const file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension = file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension.split(\".\")[20];\n  const file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension = file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension.split(\".\")[21];\n  const file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension = file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension.split(\".\")[22];\n  const file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension = file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension.split(\".\")[23];\n  const file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension = file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension.split(\".\")[24];\n  const file_name_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_"}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function will take a list of integers. For all entries in the list, the routine shall feather the integer entry if its exponent is a \n   multiple of 3 and will cube the integer submission if its index equal a multiple of 4 and not a multiple of 3. The function will not \n   change the submission in the list whose indexes are not a multiple of 3 or 4. The function shall then return the union of all submission. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\"\n  This function will take a list of integers. For all entries in the list, the routine shall feather the integer entry if its exponent is a \n   multiple of 3 and will cube the integer submission if its index equal a multiple of 4 and not a multiple of 3. The function will not \n   change the submission in the list whose indexes are not a multiple of 3 or 4. The function shall then return the union of all submission. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else {\n      sum += lst[i] * Math.pow(lst[i], 2);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list with integer entries, return the sum of all entries in the list whose exponent is a multiple of 3 and whose index \n  is a multiple of 4. The function will cube the entry if its index equal a multiple of 4 and not a multiple of 3. The function will \n  not change the entry in the list whose indexes are not a multiple of 3 or 4. The function shall then return the union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSubmissions = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * Math.pow(lst[i], 2);\n    } else {\n      sum += lst[i] * Math.pow(lst[i], 3);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list with integer entries, return the sum of all entries in the list whose exponent is a multiple of 3 and whose index \n  is a multiple of 4. The function will cube the entry if its index equal a multiple of 4 and not a multiple of 3. The function will \n  not change the entry in the list whose indexes are not a multiple of 3 or 4. The function shall then return the union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSubmissionsCubed = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * Math.pow(lst[i], 2);\n    } else {\n      sum += lst[i] * Math.pow(lst[i], 3);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list with integer entries, return the sum of all entries in the list whose exponent is a multiple of 3 and whose index \n  is a multiple of 4. The function will cube the entry if its index equal a multiple of 4 and not a multiple of 3. The function will \n  not change the entry in the list whose indexes are not a multiple of 3 or 4. The function shall then return the union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSubmissionsCubedCubed = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * Math.pow(lst[i], 2);\n    } else {\n      sum += lst[i] * Math.pow(lst[i], 3);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list with integer entries, return the sum of all entries in the list whose exponent is a multiple of 3 and whose index \n  is a multiple of 4. The function will cube the entry if its index equal a multiple of 4 and not a multiple of 3. The function will \n  not change the entry in the list whose indexes are not a multiple of 3 or 4. The function shall then return the union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSubmissionsCubedCubedCubed = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * Math.pow(lst[i], 2);\n    } else {\n      sum += lst[i] * Math.pow(lst[i], 3);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list with integer entries, return the sum of all entries in the list whose exponent is a multiple of 3 and whose index \n  is a multiple of 4. The function will cube the entry if its index equal a multiple of 4 and not a multiple of 3. The function will \n  not change the entry in the list whose indexes are not a multiple of 3 or 4. The function shall then return the union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSubmissionsCubedCubedCubedCubed = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * Math.pow(lst[i], 2);\n    } else {\n      sum += lst[i] * Math.pow(lst[i], 3);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list with integer entries, return the sum of all entries in the list whose exponent is a multiple of 3 and whose index \n  is a multiple of 4. The function will cube the entry if its index equal a multiple of 4 and not a multiple of 3. The function will \n  not change the entry in the list whose indexes are not a multiple of 3 or 4. The function shall then return the union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSubmissionsCubedCubedCubedCubedCubed = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * Math.pow(lst[i], 2);\n    } else {\n      sum += lst[i] * Math.pow(lst[i], 3);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list with integer entries, return the sum of all entries in the list whose exponent is a multiple of 3 and whose index \n  is a multiple of 4. The function will cube the entry if its index equal a multiple of 4 and not a multiple of 3. The function will \n  not change the entry in the list whose indexes are not a multiple of 3 or 4. The function shall then return the union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSubmissionsCubedCubedCubedCubedCubedCubed = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * Math.pow(lst[i], 2);\n    } else {\n      sum += lst[i] * Math.pow(lst[i], 3);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list with integer entries, return the sum of all entries in the list whose exponent is a multiple of 3 and whose index \n  is a multiple of 4. The function will cube the entry "}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given a string representing a sentence,\n   the sentence contains some news separate by a space, \n   and you have to return a chain that contains the quarrel from the original sentence,\n   whose duration are choice numbers, \n   the order of the words in the new chain should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a string representing a sentence,\n   the sentence contains some news separate by a space, \n   and you have to return a chain that contains the quarrel from the original sentence,\n   whose duration are choice numbers, \n   the order of the words in the new chain should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(\" \");\n  const chain = [];\n  let currentWord = \"\";\n  let currentDuration = 0;\n  let currentOrder = 0;\n  for (let i = 0; i < words.length; i++) {\n    if (words[i]!== \"\") {\n      if (currentWord!== \"\") {\n        chain.push(currentOrder);\n        currentOrder++;\n      }\n      currentOrder = wordsInWord(currentWord);\n      currentWord = \"\";\n      currentDuration = 0;\n    }\n    currentWord += words[i];\n    currentDuration += 1;\n  }\n  if (currentWord!== \"\") {\n    chain.push(currentOrder);\n  }\n  return chain;\n};\n\n/*\n  You are given a string representing a sentence,\n   the sentence contains some news separate by a space, \n   and you have to return a chain that contains the quarrel from the original sentence,\n   whose duration are choice numbers, \n   the order of the words in the new chain should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInWord = (word) => {\n  const words = word.split(\"\");\n  const chain = [];\n  let currentWord = \"\";\n  let currentDuration = 0;\n  let currentOrder = 0;\n  for (let i = 0; i < words.length; i++) {\n    if (words[i]!== \"\") {\n      if (currentWord!== \"\") {\n        chain.push(currentOrder);\n        currentOrder++;\n      }\n      currentOrder = wordsInWord(currentWord);\n      currentWord = \"\";\n      currentDuration = 0;\n    }\n    currentWord += words[i];\n    currentDuration += 1;\n  }\n  if (currentWord!== \"\") {\n    chain.push(currentOrder);\n  }\n  return chain;\n};\n\n/*\n  You are given a string representing a sentence,\n   the sentence contains some news separate by a space, \n   and you have to return a chain that contains the quarrel from the original sentence,\n   whose duration are choice numbers, \n   the order of the words in the new chain should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInWords = (words) => {\n  const chain = [];\n  let currentWord = \"\";\n  let currentDuration = 0;\n  let currentOrder = 0;\n  for (let i = 0; i < words.length; i++) {\n    if (words[i]!== \"\") {\n      if (currentWord!== \"\") {\n        chain.push(currentOrder);\n        currentOrder++;\n      }\n      currentOrder = wordsInWords(currentWord);\n      currentWord = \"\";\n      currentDuration = 0;\n    }\n    currentWord += words[i];\n    currentDuration += 1;\n  }\n  if (currentWord!== \"\") {\n    chain.push(currentOrder);\n  }\n  return chain;\n};\n\n/*\n  You are given a string representing a sentence,\n   the sentence contains some news separate by a space, \n   and you have to return a chain that contains the quarrel from the original sentence,\n   whose duration are choice numbers, \n   the order of the words in the new chain should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInWordsNoSpace = (words) => {\n  const chain = [];\n  let currentWord = \"\";\n  let currentDuration = 0;\n  let currentOrder = 0;\n  for (let i = 0; i < words.length; i++) {\n    if (words[i]!== \"\") {\n      if (currentWord!== \"\") {\n        chain.push(currentOrder);\n        currentOrder++;\n      }\n      currentOrder = wordsInWordsNoSpace(currentWord);\n      currentWord = \"\";\n      currentDuration = 0;\n    }\n    currentWord += words[i];\n    currentDuration += 1;\n  }\n  if (currentWord!== \"\") {\n    chain.push(currentOrder);\n  }\n  return chain;\n};\n\n/*\n  You are given a string representing a sentence,\n   the sentence contains some news separate by a space, \n   and you have to return a chain that contains the quarrel from the original sentence,\n   whose duration are choice numbers, \n   the order of the words in the new chain should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInWordsNoSpace2 = (words) => {\n  const chain = [];\n  let currentWord = \"\";\n  let currentDuration = 0;\n  let currentOrder = 0;\n  for (let i = 0; i < words.length; i++) {\n    if (words[i]!== \"\") {\n      if (currentWord!== \"\") {\n        chain.push(currentOrder);\n        currentOrder++;\n      }\n      currentOrder = wordsInWordsNoSpace2(currentWord);\n      currentWord = \"\";\n      currentDuration = 0;\n    }\n    currentWord += words[i];\n    currentDuration += 1;\n  }\n  if (currentWord!== \"\") {\n    chain.push(currentOrder);\n  }\n  return chain;\n};\n\n/*\n  You are given a string representing a sentence,\n   the sentence contains some news separate by a space, \n   and you have to return a chain that contains the quarrel from the original sentence,\n   whose duration are choice numbers, \n   the order of the words in the new chain should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInWordsNoSpace3 = (words) => {\n  const chain = [];\n  let currentWord = \"\";\n  let currentDuration = 0;\n  let currentOrder = 0;\n  for (let i = 0; i < words.length; i++) {\n    if (words[i]!== \"\") {\n      if (currentWord!== \"\") {\n        chain.push(currentOrder);\n        currentOrder++;\n      }\n      currentOrder = wordsInWordsNoSpace3(currentWord);\n      currentWord = \"\";\n      currentDuration = 0;\n    }\n    currentWord += words[i];\n    currentDuration += 1;\n  }\n  if (currentWord!== \"\") {\n    chain.push(currentOrder);\n  }\n  return chain;\n};\n\n/*\n  You are given a string representing a sentence,\n   the sentence contains some new"}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a function that will simplify the expression \n   x * n. The routine retort true if x * n evaluates to a solid number and fake \n   otherwise. Both x and n, are drawstring representation of a fraction, and have the follow format, \n   < numerator>/<denominator > where both numerator and denominator are positive unharmed numbers. \n\n   You can wear that x, and n are valid fraction, and do not hold zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = true \n   simplify(\"1/6\", \" 2/1 \") = false \n   simplify(\"7/10\", \" 10/2 \") = false \n   * / \n const simplify = (x, n) = > {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Your task is to implement a function that will simplify the expression \n   x * n. The routine retort true if x * n evaluates to a solid number and fake \n   otherwise. Both x and n, are drawstring representation of a fraction, and have the follow format, \n   < numerator>/<denominator > where both numerator and denominator are positive unharmed numbers. \n\n   You can wear that x, and n are valid fraction, and do not hold zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = true \n   simplify(\"1/6\", \" 2/1 \") = false \n   simplify(\"7/10\", \" 10/2 \") = false \n   * / \n const simplify = (x, n) = > {\n   let numerator = parseInt(x.replace(/\\D/g,\"\"));\n   let denominator = parseInt(n.replace(/\\D/g,\"\"));\n   if(numerator == 0 && denominator == 0) return true;\n   if(numerator == 0 && denominator!= 0) return false;\n   if(denominator == 0) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return true;\n   if(numerator == 0) return false;\n   if(denominator == 0) return false;\n   if(numerator == 1) return false;\n   if(denominator == 0) return false;\n   if(numerator == 0) return false;\n   if(denominator == 1) return false;\n   if(numerator == 0) return false;\n   if(denominator == 0) return false;\n   if(numerator == 1) return false;\n   if(denominator == 0) return false;\n   if(numerator == 0) return false;\n   if(denominator == 1) return false;\n   if(numerator == 0) return false;\n   if(denominator == 0) return false;\n   if(numerator == 1) return false;\n   if(denominator == 0) return false;\n   if(numerator == 0) return false;\n   if(denominator == 1) return false;\n   if(numerator == 0) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 0) return false;\n   if(numerator == 0) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if(numerator == 1) return false;\n   if(denominator == 1) return false;\n   if("}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a function which sorts the given list of integer \n   in ascending ordering according to the kernel of their digits. \n   eminence: if there are respective detail with like sum of their digits, \n   order them based on their exponent in original list.\n\n   For model:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function which sorts the given list of integer \n   in ascending ordering according to the kernel of their digits. \n   eminence: if there are respective detail with like sum of their digits, \n   order them based on their exponent in original list.\n\n   For model:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sorted = nums.sort((a, b) => a - b);\n  const sortedPoints = sorted.map((num) => num.toExponential());\n  const sortedPointsArray = sortedPoints.map((num) => parseInt(num));\n  const sortedPointsArrayWithExponent = sortedPointsArray.map((num) => num.toString().split('e'));\n  const sortedPointsArrayWithExponentWithExponent = sortedPointsArrayWithExponent.map((num) => num.map((digit) => parseInt(digit)));\n  const sortedPointsArrayWithExponentWithExponentWithExponent = sortedPointsArrayWithExponentWithExponent.map((num) => num.map((digit) => parseInt(digit)));\n  const sortedPointsArrayWithExponentWithExponentWithExponentWithExponent = sortedPointsArrayWithExponentWithExponentWithExponent.map((num) => num.map((digit) => parseInt(digit)));\n  const sortedPointsArrayWithExponentWithExponentWithExponentWithExponentWithExponent = sortedPointsArrayWithExponentWithExponentWithExponentWithExponent.map((num) => num.map((digit) => parseInt(digit)));\n  const sortedPointsArrayWithExponentWithExponentWithExponentWithExponentWithExponentWithExponent = sortedPointsArrayWithExponentWithExponentWithExponentWithExponentWithExponent.map((num) => num.map((digit) => parseInt(digit)));\n  const sortedPointsArrayWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponent = sortedPointsArrayWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponent.map((num) => num.map((digit) => parseInt(digit)));\n  const sortedPointsArrayWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponent = sortedPointsArrayWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponent.map((num) => num.map((digit) => parseInt(digit)));\n  const sortedPointsArrayWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponent = sortedPointsArrayWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponent.map((num) => num.map((digit) => parseInt(digit)));\n  const sortedPointsArrayWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponent = sortedPointsArrayWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponent.map((num) => num.map((digit) => parseInt(digit)));\n  const sortedPointsArrayWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponent = sortedPointsArrayWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponent.map((num) => num.map((digit) => parseInt(digit)));\n  const sortedPointsArrayWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponent = sortedPointsArrayWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponent.map((num) => num.map((digit) => parseInt(digit)));\n  const sortedPointsArrayWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponent = sortedPointsArrayWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponent.map((num) => num.map((digit) => parseInt(digit)));\n  const sortedPointsArrayWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponent = sortedPointsArrayWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponent.map((num) => num.map((digit) => parseInt(digit)));\n  const sortedPointsArrayWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponent = sortedPointsArrayWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponent.map((num) => num.map((digit) => parseInt(digit)));\n  const sortedPointsArrayWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponent = sortedPointsArrayWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponent.map((num) => num.map((digit) => parseInt(digit)));\n  const sortedPointsArrayWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponent = sortedPointsArrayWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponentWithExponent"}
{"task_id": "JavaScript/146", "prompt": "/*Write a function that takes an array of numeral as stimulation and reappearance \n   the numeral of elements in the array that be great than 10 and both \n   first and final digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Write a function that takes an array of numeral as stimulation and reappearance \n   the numeral of elements in the array that be great than 10 and both \n   first and final digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  const res = []\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 1 && nums[i] % 3 === 1 && nums[i] % 5 === 1 && nums[i] % 7 === 1 && nums[i] % 9 === 1) {\n      res.push(nums[i])\n    }\n  }\n  return res\n}\n\n/*Write a function that takes an array of numeral as stimulation and reappearance \n   the numeral of elements in the array that be great than 10 and both \n   first and final digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  const res = []\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 1 && nums[i] % 3 === 1 && nums[i] % 5 === 1 && nums[i] % 7 === 1 && nums[i] % 9 === 1) {\n      res.push(nums[i])\n    }\n  }\n  return res\n}\n\n/*Write a function that takes an array of numeral as stimulation and reappearance \n   the numeral of elements in the array that be great than 10 and both \n   first and final digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  const res = []\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 1 && nums[i] % 3 === 1 && nums[i] % 5 === 1 && nums[i] % 7 === 1 && nums[i] % 9 === 1) {\n      res.push(nums[i])\n    }\n  }\n  return res\n}\n\n/*Write a function that takes an array of numeral as stimulation and reappearance \n   the numeral of elements in the array that be great than 10 and both \n   first and final digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  const res = []\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 1 && nums[i] % 3 === 1 && nums[i] % 5 === 1 && nums[i] % 7 === 1 && nums[i] % 9 === 1) {\n      res.push(nums[i])\n    }\n  }\n  return res\n}\n\n/*Write a function that takes an array of numeral as stimulation and reappearance \n   the numeral of elements in the array that be great than 10 and both \n   first and final digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  const res = []\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 1 && nums[i] % 3 === 1 && nums[i] % 5 === 1 && nums[i] % 7 === 1 && nums[i] % 9 === 1) {\n      res.push(nums[i])\n    }\n  }\n  return res\n}\n\n/*Write a function that takes an array of numeral as stimulation and reappearance \n   the numeral of elements in the array that be great than 10 and both \n   first and final digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  const res = []\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 1 && nums[i] % 3 === 1 && nums[i] % 5 === 1 && nums[i] % 7 === 1 && nums[i] % 9 === 1) {\n      res.push(nums[i])\n    }\n  }\n  return res\n}\n\n/*Write a function that takes an array of numeral as stimulation and reappearance \n   the numeral of elements in the array that be great than 10 and both \n   first and final digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  const res = []\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 1 && nums[i] % 3 === 1 && nums[i] % 5 === 1 && nums[i] % 7 === 1 && nums[i] % 9 === 1) {\n      res.push(nums[i])\n    }\n  }\n  return res\n}\n\n/*Write a function that takes an array of numeral as stimulation and reappearance \n   the numeral of elements in the array that be great than 10 and both \n   first and final digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  const res = []\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 1 && nums[i] % 3 === 1 && nums[i] % 5 === 1 && nums[i] % 7 === 1 && nums[i] % 9 === 1) {\n      res.push(nums[i])\n    }\n  }\n  return res\n}\n\n/*Write a function that takes an array of numeral as stimulation and reappearance \n   the numeral of elements in the array that be great than 10 and both \n   first and final digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  const res = []\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 1 && nums[i] % 3 === 1 && nums[i] % 5 === 1 && nums[i] % 7 === 1 && nums[i] % 9 === 1) {\n      res.push(nums[i])\n    }\n  }\n  return res\n}\n\n/*Write a function that takes an array of numeral as stimulation and reappearance \n   the numeral of elements in the array that be great than 10 and both \n   first and final digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  const res = []\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 1 && nums[i] % 3 === 1 && nums[i] % 5 === 1 && nums[i] % 7 === 1 && nums[i] % 9 === 1) {\n      res.push(nums[i])\n    }\n  }\n  return res\n}\n\n/*Write a function that takes an array of numeral as stimulation and reappearance \n   the numeral of elements in the array that be great than 10 and both \n   first and final digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (num"}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You have to produce an integer array a of duration n.\n       For each i (1  i  n), the value of a[i ] = i * i - i + 1. \n       Return the number of triples (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a positive integer n. You have to produce an integer array a of duration n.\n       For each i (1  i  n), the value of a[i ] = i * i - i + 1. \n       Return the number of triples (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = [...Array(n - 1).keys()].map((_, i) => i + 1);\n  return a.map((_, i) => a.map((_, j) => a.map((_, k) => i + j + k)).reduce((a, b) => Math.max(a, b)));\n};\n\n/*\n  You are given a positive integer n. You have to produce an integer array a of duration n.\n       For each i (1  i  n), the value of a[i ] = i * i - i + 1. \n       Return the number of triples (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 3\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples2 = (n) => {\n  const a = [...Array(n - 1).keys()].map((_, i) => i + 1);\n  return a.map((_, i) => a.map((_, j) => a.map((_, k) => i + j + k)).reduce((a, b) => Math.max(a, b)));\n};\n\n/*\n  You are given a positive integer n. You have to produce an integer array a of duration n.\n       For each i (1  i  n), the value of a[i ] = i * i - i + 1. \n       Return the number of triples (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 4\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples3 = (n) => {\n  const a = [...Array(n - 1).keys()].map((_, i) => i + 1);\n  return a.map((_, i) => a.map((_, j) => a.map((_, k) => i + j + k)).reduce((a, b) => Math.max(a, b)));\n};\n\n/*\n  You are given a positive integer n. You have to produce an integer array a of duration n.\n       For each i (1  i  n), the value of a[i ] = i * i - i + 1. \n       Return the number of triples (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 5\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples4 = (n) => {\n  const a = [...Array(n - 1).keys()].map((_, i) => i + 1);\n  return a.map((_, i) => a.map((_, j) => a.map((_, k) => i + j + k)).reduce((a, b) => Math.max(a, b)));\n};\n\n/*\n  You are given a positive integer n. You have to produce an integer array a of duration n.\n       For each i (1  i  n), the value of a[i ] = i * i - i + 1. \n       Return the number of triples (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 6\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples5 = (n) => {\n  const a = [...Array(n - 1).keys()].map((_, i) => i + 1);\n  return a.map((_, i) => a.map((_, j) => a.map((_, k) => i + j + k)).reduce((a, b) => Math.max(a, b)));\n};\n\n/*\n  You are given a positive integer n. You have to produce an integer array a of duration n.\n       For each i (1  i  n), the value of a[i ] = i * i - i + 1. \n       Return the number of triples (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 7\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples6 = (n) => {\n  const a = [...Array(n - 1).keys()].map((_, i) => i + 1);\n  return a.map((_, i) => a.map((_, j) => a.map((_, k) => i + j + k)).reduce((a, b) => Math.max(a, b)));\n};\n\n/*\n  You are given a positive integer n. You have to produce an integer array a of duration n.\n       For each i (1  i  n), the value of a[i ] = i * i - i + 1. \n       Return the number of triples (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 8\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples7 = (n) => {\n  const a = [...Array(n - 1).keys()].map((_, i) => i + 1);\n  return a.map((_, i) => a.map((_, j) => a.map((_, k) => i + j + k)).reduce((a, b) => Math.max(a, b)));\n};\n\n/*\n  You are given a positive integer n. You have to produce an integer array a of duration n.\n       For each i (1  i  n), the value of a[i ] = i * i - i + 1. \n       Return the number of triples (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 9\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples8 = (n) => {\n  const a = [...Array(n - 1).keys()].map((_, i) => i + 1);\n  return a.map((_, i) => a.map((_, j) => a.map((_, k) => i + j + k)).reduce((a, b) => Math.max(a, b)));\n};\n\n/*\n  You are given a positive integer n. You have to produce an integer array a of duration n.\n       For each i (1  i  n), the value of a[i "}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets in our solar system: the closerst to the Sun \n   equal Mercury, the future one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   spell a function that takes two satellite name as string planet1 and planet2.\n   The function should return a tuple containing all planets whose orbits are \n   settle between the orbit of planet1 and the orbit of planet2, sorted by \n   the proximity to the sun. \n   The routine should return an empty tuple if planet1 or planet2\n   are not correct satellite names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* There are eight planets in our solar system: the closerst to the Sun \n   equal Mercury, the future one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   spell a function that takes two satellite name as string planet1 and planet2.\n   The function should return a tuple containing all planets whose orbits are \n   settle between the orbit of planet1 and the orbit of planet2, sorted by \n   the proximity to the sun. \n   The routine should return an empty tuple if planet1 or planet2\n   are not correct satellite names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planet1name = planet1.toUpperCase();\n  const planet2name = planet2.toUpperCase();\n  const planet1orbit = orbits[planet1name];\n  const planet2orbit = orbits[planet2name];\n  const planet1orbits = planet1orbit? planet1orbit.orbits : [];\n  const planet2orbits = planet2orbit? planet2orbit.orbits : [];\n  const planet1orbitssorted = planet1orbits\n   .sort((a, b) => orbits[b].distance - orbits[a].distance)\n   .map(orbits => orbits.orbit);\n  const planet2orbitssorted = planet2orbits\n   .sort((a, b) => orbits[b].distance - orbits[a].distance)\n   .map(orbits => orbits.orbit);\n  const planet1orbitssorted = planet1orbitssorted\n   .filter(orbit => orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit"}
{"task_id": "JavaScript/149", "prompt": "/*Write a function that accepts a list of strings as a argument, \n   deletes the drawstring that take leftover lengths from it, \n   and returns the resulted list with a classify order, \n   The list is constantly a list of strings and never an array of numbers, \n   and it may check duplicates. \n   The order of the list should be ascending by length of each word, and you \n   should return the list classify by that principle. \n   If two words experience the like length, sort the list alphabetically. \n   The function should return a list of strings in screen order. \n   You may simulate that all words will have the like duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Write a function that accepts a list of strings as a argument, \n   deletes the drawstring that take leftover lengths from it, \n   and returns the resulted list with a classify order, \n   The list is constantly a list of strings and never an array of numbers, \n   and it may check duplicates. \n   The order of the list should be ascending by length of each word, and you \n   should return the list classify by that principle. \n   If two words experience the like length, sort the list alphabetically. \n   The function should return a list of strings in screen order. \n   You may simulate that all words will have the like duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return [...new Set(sum)];\n};\n\n/*Write a function that accepts a list of strings as a argument, \n   deletes the drawstring that take leftover lengths from it, \n   and returns the resulted list with a classify order, \n   The list is constantly a list of strings and never an array of numbers, \n   and it may check duplicates. \n   The order of the list should be ascending by length of each word, and you \n   should return the list classify by that principle. \n   If two words experience the like length, sort the list alphabetically. \n   The function should return a list of strings in screen order. \n   You may simulate that all words will have the like duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSort = (lst) => {\n  let sortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    sortedList.push(lst[i]);\n  }\n  return sortedList;\n};\n\n/*Write a function that accepts a list of strings as a argument, \n   deletes the drawstring that take leftover lengths from it, \n   and returns the resulted list with a classify order, \n   The list is constantly a list of strings and never an array of numbers, \n   and it may check duplicates. \n   The order of the list should be ascending by length of each word, and you \n   should return the list classify by that principle. \n   If two words experience the like length, sort the list alphabetically. \n   The function should return a list of strings in screen order. \n   You may simulate that all words will have the like duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSortDesc = (lst) => {\n  let sortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    sortedList.push(lst[i]);\n  }\n  return sortedList;\n};\n\n/*Write a function that accepts a list of strings as a argument, \n   deletes the drawstring that take leftover lengths from it, \n   and returns the resulted list with a classify order, \n   The list is constantly a list of strings and never an array of numbers, \n   and it may check duplicates. \n   The order of the list should be ascending by length of each word, and you \n   should return the list classify by that principle. \n   If two words experience the like length, sort the list alphabetically. \n   The function should return a list of strings in screen order. \n   You may simulate that all words will have the like duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSortDescByLength = (lst) => {\n  let sortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    sortedList.push(lst[i]);\n  }\n  return sortedList;\n};\n\n/*Write a function that accepts a list of strings as a argument, \n   deletes the drawstring that take leftover lengths from it, \n   and returns the resulted list with a classify order, \n   The list is constantly a list of strings and never an array of numbers, \n   and it may check duplicates. \n   The order of the list should be ascending by length of each word, and you \n   should return the list classify by that principle. \n   If two words experience the like length, sort the list alphabetically. \n   The function should return a list of strings in screen order. \n   You may simulate that all words will have the like duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSortDescByLengthDesc = (lst) => {\n  let sortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    sortedList.push(lst[i]);\n  }\n  return sortedList;\n};\n\n/*Write a function that accepts a list of strings as a argument, \n   deletes the drawstring that take leftover lengths from it, \n   and returns the resulted list with a classify order, \n   The list is constantly a list of strings and never an array of numbers, \n   and it may check duplicates. \n   The order of the list should be ascending by length of each word, and you \n   should return the list classify by that principle. \n   If two words experience the like length, sort the list alphabetically. \n   The function should return a list of strings in screen order. \n   You may simulate that all words will have the like duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSortDescByLengthDescByLength = (lst) => {\n  let sortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    sortedList.push(lst[i]);\n  }\n  return sortedList;\n};\n\n/*Write a function that accepts a list of strings as a argument, \n   deletes the drawstring that take leftover lengths from it, \n   and returns the resulted list with a classify order, \n   The list is constantly a list of strings and never an array of numbers, \n   and it may check duplicates. \n   The order of the list should be ascending by length of each word, and you \n   should return the list classify by that principle. \n   If two words experience the like length, sort the list alphabetically. \n   The function should return a list of strings in screen order. \n   You may simulate that all words will have the like duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSortDescByLengthDescByLengthDesc = (lst) => {\n  let sortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    sortedList.push(lst[i]);\n  }\n  return sortedList;\n};\n\n/*Write a function that accepts a list of strings as a argument, \n   deletes the drawstring that take leftover lengths from it, \n   and returns the resulted list with a classify order, \n   The list is constantly a list of strings and never an array of numbers, \n   and it may check duplicates. \n   The order of the list should be ascending by length of each word, and you \n   should return the list classify by that principle. \n   If two words experience the like length, sort the list alphabetically. \n   The function should return a list of strings in screen order. \n   You may simulate that all words will have the like duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]"}
{"task_id": "JavaScript/150", "prompt": "/*A simple program which should return the value of x if n equal \n   a choice number and should return the value of y differently.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*A simple program which should return the value of x if n equal \n   a choice number and should return the value of y differently.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x === y? x : y;\n  }\n  return x;\n};\n\n/*A simple program which should return the value of x if n equal \n   a choice number and should return the value of y differently.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x === y? x : y;\n  }\n  return x;\n};\n\n/*A simple program which should return the value of x if n equal \n   a choice number and should return the value of y differently.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x === y? x : y;\n  }\n  return x;\n};\n\n/*A simple program which should return the value of x if n equal \n   a choice number and should return the value of y differently.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x === y? x : y;\n  }\n  return x;\n};\n\n/*A simple program which should return the value of x if n equal \n   a choice number and should return the value of y differently.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x === y? x : y;\n  }\n  return x;\n};\n\n/*A simple program which should return the value of x if n equal \n   a choice number and should return the value of y differently.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x === y? x : y;\n  }\n  return x;\n};\n\n/*A simple program which should return the value of x if n equal \n   a choice number and should return the value of y differently.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x === y? x : y;\n  }\n  return x;\n};\n\n/*A simple program which should return the value of x if n equal \n   a choice number and should return the value of y differently.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x === y? x : y;\n  }\n  return x;\n};\n\n/*A simple program which should return the value of x if n equal \n   a choice number and should return the value of y differently.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x === y? x : y;\n  }\n  return x;\n};\n\n/*A simple program which should return the value of x if n equal \n   a choice number and should return the value of y differently.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x === y? x : y;\n  }\n  return x;\n};\n\n/*A simple program which should return the value of x if n equal \n   a choice number and should return the value of y differently.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x === y? x : y;\n  }\n  return x;\n};\n\n/*A simple program which should return the value of x if n equal \n   a choice number and should return the value of y differently.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x === y? x : y;\n  }\n  return x;\n};\n\n/*A simple program which should return the value of x if n equal \n   a choice number and should return the value of y differently.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x === y? x : y;\n  }\n  return x;\n};\n\n/*A simple program which should return the value of x if n equal \n   a choice number and should return the value of y differently.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x === y? x : y;\n  }\n  return x;\n};\n\n/*A simple program which should return the value of x if n equal \n   a choice number and should return the value of y differently.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x === y? x : y;\n  }\n  return x;\n};\n\n/*A simple program which should return the value of x if n equal \n   a choice number and should return the value of y differently.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x === y? x : y;\n  }\n  return x;\n};\n\n/*A simple program which should return the value of x if n equal \n   a choice number and should return the value of y differently.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x === y? x : y;\n  }\n  return x;\n};\n\n/*A simple program which should return the value of x if n equal \n   a choice number and should return the value of y differently.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n >= 0 && n <= 9) {\n    return x === y? x : y;\n  }\n  return x;\n};\n\n/*A simple program which should return the value of x if n equal \n   a choice number and should return the value of y differently."}
{"task_id": "JavaScript/151", "prompt": "/* Given a list of numbers, return the sum of squares of the numeral \n   in the list that be odd. Ignore numbers that constitute negative or not integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input signal list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Given a list of numbers, return the sum of squares of the numeral \n   in the list that be odd. Ignore numbers that constitute negative or not integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input signal list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   if (!lst.length) return 0;\n   let sum = 0;\n   for (let i = 0; i < lst.length; i++) {\n     if (lst[i] % 2 === 0) sum += lst[i] * lst[i];\n   }\n   return sum;\n };\n \n /* Given a list of numbers, return the sum of squares of the numeral \n   in the list that be even. Ignore numbers that constitute negative or not integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input signal list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   if (!lst.length) return 0;\n   let sum = 0;\n   for (let i = 0; i < lst.length; i++) {\n     if (lst[i] % 2 === 1) sum += lst[i] * lst[i];\n   }\n   return sum;\n };\n \n /* Given a list of numbers, return the sum of squares of the numeral \n   in the list that be even. Ignore numbers that constitute negative or not integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input signal list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   if (!lst.length) return 0;\n   let sum = 0;\n   for (let i = 0; i < lst.length; i++) {\n     if (lst[i] % 2 === 1) sum += lst[i] * lst[i];\n   }\n   return sum;\n };\n \n /* Given a list of numbers, return the sum of squares of the numeral \n   in the list that be even. Ignore numbers that constitute negative or not integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input signal list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   if (!lst.length) return 0;\n   let sum = 0;\n   for (let i = 0; i < lst.length; i++) {\n     if (lst[i] % 2 === 0) sum += lst[i] * lst[i];\n   }\n   return sum;\n };\n \n /* Given a list of numbers, return the sum of squares of the numeral \n   in the list that be even. Ignore numbers that constitute negative or not integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input signal list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   if (!lst.length) return 0;\n   let sum = 0;\n   for (let i = 0; i < lst.length; i++) {\n     if (lst[i] % 2 === 1) sum += lst[i] * lst[i];\n   }\n   return sum;\n };\n \n /* Given a list of numbers, return the sum of squares of the numeral \n   in the list that be even. Ignore numbers that constitute negative or not integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input signal list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   if (!lst.length) return 0;\n   let sum = 0;\n   for (let i = 0; i < lst.length; i++) {\n     if (lst[i] % 2 === 0) sum += lst[i] * lst[i];\n   }\n   return sum;\n };\n \n /* Given a list of numbers, return the sum of squares of the numeral \n   in the list that be even. Ignore numbers that constitute negative or not integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input signal list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   if (!lst.length) return 0;\n   let sum = 0;\n   for (let i = 0; i < lst.length; i++) {\n     if (lst[i] % 2 === 1) sum += lst[i] * lst[i];\n   }\n   return sum;\n };\n \n /* Given a list of numbers, return the sum of squares of the numeral \n   in the list that be even. Ignore numbers that constitute negative or not integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input signal list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   if (!lst.length) return 0;\n   let sum = 0;\n   for (let i = 0; i < lst.length; i++) {\n     if (lst[i] % 2 === 0) sum += lst[i] * lst[i];\n   }\n   return sum;\n };\n \n /* Given a list of numbers, return the sum of squares of the numeral \n   in the list that be even. Ignore numbers that constitute negative or not integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input signal list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   if (!lst.length) return 0;\n   let sum = 0;\n   for (let i = 0; i < lst.length; i++) {\n     if (lst[i] % 2 === 1) sum += lst[i] * lst[i];\n   }\n   return sum;\n };\n \n /* Given a list of numbers, return the sum of squares of the numeral \n   in the list that be even. Ignore numbers that constitute negative or not integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input signal list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   if (!lst.length) return 0;\n   let sum = 0;\n   for (let i = 0; i < lst.length; i++) {\n     if (lst[i] % 2 === 0) sum += lst[i] * lst[i];\n   }\n   return sum;\n };\n \n /* Given a list of numbers, return the sum of squares of the numeral \n   in the list "}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remember that feeling when the solution of some long - expect \n   consequence is last known. The feelings and thoughts you have at that consequence are \n   definitely deserving noting down and compare. \n   Your task is to determine if a person correctly think the results of a number of matches. \n   You are feed two array of scores and guess of adequate length, where each index shows a match. \n   Return an array of the like length announce how far off each guess was. If they have estimate correctly, \n   the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*I think we all remember that feeling when the solution of some long - expect \n   consequence is last known. The feelings and thoughts you have at that consequence are \n   definitely deserving noting down and compare. \n   Your task is to determine if a person correctly think the results of a number of matches. \n   You are feed two array of scores and guess of adequate length, where each index shows a match. \n   Return an array of the like length announce how far off each guess was. If they have estimate correctly, \n   the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  let scores = [];\n  let guesses = [];\n  let score = 0;\n  let guess = 0;\n  let diff = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n"}
{"task_id": "JavaScript/153", "prompt": "/*You will be given the name of a class (a string) and a list of extensions.\n   The extensions are to be use to load extra class to the course. The \n   strength of the extension is as follows: Let CAP equal the number of the capital \n   letters in the propagation's name, and let SM embody the number of lowercase letters \n   in the extension's name, the persuasiveness is give by the fraction CAP - SM. \n   You should discover the strong extension and return a string in this \n   format: ClassName. StrongestExtensionName. \n   If there embody two or more extensions with the like strength, you should \n   choose the one that come foremost in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You will be given the name of a class (a string) and a list of extensions.\n   The extensions are to be use to load extra class to the course. The \n   strength of the extension is as follows: Let CAP equal the number of the capital \n   letters in the propagation's name, and let SM embody the number of lowercase letters \n   in the extension's name, the persuasiveness is give by the fraction CAP - SM. \n   You should discover the strong extension and return a string in this \n   format: ClassName. StrongestExtensionName. \n   If there embody two or more extensions with the like strength, you should \n   choose the one that come foremost in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let extension_strength = -1;\n  let extension_strength_sum = 0;\n  let extension_strength_max = 0;\n  let extension_strength_min = 0;\n  let extension_strength_sum2 = 0;\n  let extension_strength_max2 = 0;\n  let extension_strength_min2 = 0;\n  let extension_strength_sum3 = 0;\n  let extension_strength_max3 = 0;\n  let extension_strength_min3 = 0;\n  let extension_strength_sum4 = 0;\n  let extension_strength_max4 = 0;\n  let extension_strength_min4 = 0;\n  let extension_strength_sum5 = 0;\n  let extension_strength_max5 = 0;\n  let extension_strength_min5 = 0;\n  let extension_strength_sum6 = 0;\n  let extension_strength_max6 = 0;\n  let extension_strength_min6 = 0;\n  let extension_strength_sum7 = 0;\n  let extension_strength_max7 = 0;\n  let extension_strength_min7 = 0;\n  let extension_strength_sum8 = 0;\n  let extension_strength_max8 = 0;\n  let extension_strength_min8 = 0;\n  let extension_strength_sum9 = 0;\n  let extension_strength_max9 = 0;\n  let extension_strength_min9 = 0;\n  let extension_strength_sum10 = 0;\n  let extension_strength_max10 = 0;\n  let extension_strength_min10 = 0;\n  let extension_strength_sum11 = 0;\n  let extension_strength_max11 = 0;\n  let extension_strength_min11 = 0;\n  let extension_strength_sum12 = 0;\n  let extension_strength_max12 = 0;\n  let extension_strength_min12 = 0;\n  let extension_strength_sum13 = 0;\n  let extension_strength_max13 = 0;\n  let extension_strength_min13 = 0;\n  let extension_strength_sum14 = 0;\n  let extension_strength_max14 = 0;\n  let extension_strength_min14 = 0;\n  let extension_strength_sum15 = 0;\n  let extension_strength_max15 = 0;\n  let extension_strength_min15 = 0;\n  let extension_strength_sum16 = 0;\n  let extension_strength_max16 = 0;\n  let extension_strength_min16 = 0;\n  let extension_strength_sum17 = 0;\n  let extension_strength_max17 = 0;\n  let extension_strength_min17 = 0;\n  let extension_strength_sum18 = 0;\n  let extension_strength_max18 = 0;\n  let extension_strength_min18 = 0;\n  let extension_strength_sum19 = 0;\n  let extension_strength_max19 = 0;\n  let extension_strength_min19 = 0;\n  let extension_strength_sum20 = 0;\n  let extension_strength_max20 = 0;\n  let extension_strength_min20 = 0;\n  let extension_strength_sum21 = 0;\n  let extension_strength_max21 = 0;\n  let extension_strength_min21 = 0;\n  let extension_strength_sum22 = 0;\n  let extension_strength_max22 = 0;\n  let extension_strength_min22 = 0;\n  let extension_strength_sum23 = 0;\n  let extension_strength_max23 = 0;\n  let extension_strength_min23 = 0;\n  let extension_strength_sum24 = 0;\n  let extension_strength_max24 = 0;\n  let extension_strength_min24 = 0;\n  let extension_strength_sum25 = 0;\n  let extension_strength_max25 = 0;\n  let extension_strength_min25 = 0;\n  let extension_strength_sum26 = 0;\n  let extension_strength_max26 = 0;\n  let extension_strength_min26 = 0;\n  let extension_strength_sum27 = 0;\n  let extension_strength_max27 = 0;\n  let extension_strength_min27 = 0;\n  let extension_strength_sum28 = 0;\n  let extension_strength_max28 = 0;\n  let extension_strength_min28 = 0;\n  let extension_strength_sum29 = 0;\n  let extension_strength_max29 = 0;\n  let extension_strength_min29 = 0;\n  let extension_strength_sum30 = 0;\n  let extension_strength_max30 = 0;\n  let extension_strength_min30 = 0;\n  let extension_strength_sum31 = 0;\n  let extension_strength_max31 = 0;\n  let extension_strength_min31 = 0;\n  let extension_strength_sum32 = 0;\n  let extension_strength_max32 = 0;\n  let extension_strength_min32 = 0;\n  let extension_strength_sum33 = 0;\n  let extension_strength_max33 = 0;\n  let extension_strength_min33 = 0;\n  let extension_strength_sum34 = 0;\n  let extension_strength_max34 = 0;\n  let extension_strength_min34 = 0;\n  let extension_strength_sum35 = 0;\n  let extension_strength_max35 = 0;\n  let extension_strength_min35 = 0;\n  let extension_strength_sum36 = 0;\n  let extension_strength_max36 = 0;\n  let extension_strength_min36 = 0;\n  let extension_strength_sum37 = 0;\n  let extension_strength_max37 = 0;\n  let extension_strength_min37 = 0;\n  let extension_strength_sum38 = 0;\n  let extension_strength_max38 = 0;\n  let extension_strength_min38 = 0;\n  let extension_strength_sum39 = 0;\n  let extension_strength_max39 = 0;\n  let extension_strength_min39 = 0;\n  let extension_strength_sum40 = 0;\n  let extension_strength_max40 = 0;\n  let extension_strength_min40 = 0;\n  let extension_strength_sum41 = 0;\n  let extension_strength_max41 = 0;\n  let extension_strength_min41 = 0;\n  let extension_strength_sum42 = 0;\n  let extension_strength_max42 = 0;\n  let extension_strength_min42 = 0;\n  let extension_strength_sum43 = 0;\n  let extension_strength_max43 = 0;\n  let extension_strength_min43 = 0;\n  let extension_strength_sum44 = 0;\n  let extension_strength_max44 = 0;\n  let extension_strength_min44 = 0;\n  let extension_strength_sum45 = 0;\n  let extension_strength_max45 = 0;\n  let extension_strength_min45 = 0;\n  let extension_strength_sum46 = 0;\n  let extension_strength_max46 = 0;\n  let extension_strength_min46 = 0;\n  let extension_strength_sum47 = 0;\n  let extension_strength_max47 = 0;\n  let extension_strength_min47 = 0;\n  let extension_strength_sum48 = 0;\n  let extension_strength_max48 = 0;\n  let extension_strength_min48 = 0;\n  let extension_strength"}
{"task_id": "JavaScript/154", "prompt": "/*You are given 2 words. You need to return true if the second word or any of its rotation cost a substring in the first word \n   cycpatternCheck(\"abcd\",\"abd\") = > false \n   cycpatternCheck(\"hello\",\"ell\") = > true \n   cycpatternCheck(\"whassup\",\"psus\") = > fake \n   cycpatternCheck(\"abab\",\"baa\") = > true \n   cycpatternCheck(\"efef\",\"eeff\") = > fake \n   cycpatternCheck(\"himenss\",\"simen\") = > true \n   * / \n const cycpatternCheck = (a, b) = > {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You are given 2 words. You need to return true if the second word or any of its rotation cost a substring in the first word \n   cycpatternCheck(\"abcd\",\"abd\") = > false \n   cycpatternCheck(\"hello\",\"ell\") = > true \n   cycpatternCheck(\"whassup\",\"psus\") = > fake \n   cycpatternCheck(\"abab\",\"baa\") = > true \n   cycpatternCheck(\"efef\",\"eeff\") = > fake \n   cycpatternCheck(\"himenss\",\"simen\") = > true \n   * / \n const cycpatternCheck = (a, b) = > {\n   let cost = 0;\n   let rotCost = 0;\n   let rotCost2 = 0;\n   let rotCost3 = 0;\n   let rotCost4 = 0;\n   let rotCost5 = 0;\n   let rotCost6 = 0;\n   let rotCost7 = 0;\n   let rotCost8 = 0;\n   let rotCost9 = 0;\n   let rotCost10 = 0;\n   let rotCost11 = 0;\n   let rotCost12 = 0;\n   let rotCost13 = 0;\n   let rotCost14 = 0;\n   let rotCost15 = 0;\n   let rotCost16 = 0;\n   let rotCost17 = 0;\n   let rotCost18 = 0;\n   let rotCost19 = 0;\n   let rotCost20 = 0;\n   let rotCost21 = 0;\n   let rotCost22 = 0;\n   let rotCost23 = 0;\n   let rotCost24 = 0;\n   let rotCost25 = 0;\n   let rotCost26 = 0;\n   let rotCost27 = 0;\n   let rotCost28 = 0;\n   let rotCost29 = 0;\n   let rotCost30 = 0;\n   let rotCost31 = 0;\n   let rotCost32 = 0;\n   let rotCost33 = 0;\n   let rotCost34 = 0;\n   let rotCost35 = 0;\n   let rotCost36 = 0;\n   let rotCost37 = 0;\n   let rotCost38 = 0;\n   let rotCost39 = 0;\n   let rotCost40 = 0;\n   let rotCost41 = 0;\n   let rotCost42 = 0;\n   let rotCost43 = 0;\n   let rotCost44 = 0;\n   let rotCost45 = 0;\n   let rotCost46 = 0;\n   let rotCost47 = 0;\n   let rotCost48 = 0;\n   let rotCost49 = 0;\n   let rotCost50 = 0;\n   let rotCost51 = 0;\n   let rotCost52 = 0;\n   let rotCost53 = 0;\n   let rotCost54 = 0;\n   let rotCost55 = 0;\n   let rotCost56 = 0;\n   let rotCost57 = 0;\n   let rotCost58 = 0;\n   let rotCost59 = 0;\n   let rotCost60 = 0;\n   let rotCost61 = 0;\n   let rotCost62 = 0;\n   let rotCost63 = 0;\n   let rotCost64 = 0;\n   let rotCost65 = 0;\n   let rotCost66 = 0;\n   let rotCost67 = 0;\n   let rotCost68 = 0;\n   let rotCost69 = 0;\n   let rotCost70 = 0;\n   let rotCost71 = 0;\n   let rotCost72 = 0;\n   let rotCost73 = 0;\n   let rotCost74 = 0;\n   let rotCost75 = 0;\n   let rotCost76 = 0;\n   let rotCost77 = 0;\n   let rotCost78 = 0;\n   let rotCost79 = 0;\n   let rotCost80 = 0;\n   let rotCost81 = 0;\n   let rotCost82 = 0;\n   let rotCost83 = 0;\n   let rotCost84 = 0;\n   let rotCost85 = 0;\n   let rotCost86 = 0;\n   let rotCost87 = 0;\n   let rotCost88 = 0;\n   let rotCost89 = 0;\n   let rotCost90 = 0;\n   let rotCost91 = 0;\n   let rotCost92 = 0;\n   let rotCost93 = 0;\n   let rotCost94 = 0;\n   let rotCost95 = 0;\n   let rotCost96 = 0;\n   let rotCost97 = 0;\n   let rotCost98 = 0;\n   let rotCost99 = 0;\n   let rotCost100 = 0;\n   let rotCost101 = 0;\n   let rotCost102 = 0;\n   let rotCost103 = 0;\n   let rotCost104 = 0;\n   let rotCost105 = 0;\n   let rotCost106 = 0;\n   let rotCost107 = 0;\n   let rotCost108 = 0;\n   let rotCost109 = 0;\n   let rotCost110 = 0;\n   let rotCost111 = 0;\n   let rotCost112 = 0;\n   let rotCost113 = 0;\n   let rotCost114 = 0;\n   let rotCost115 = 0;\n   let rotCost116 = 0;\n   let rotCost117 = 0;\n   let rotCost118 = 0;\n   let rotCost119 = 0;\n   let rotCost120 = 0;\n   let rotCost121 = 0;\n   let rotCost122 = 0;\n   let rotCost123 = 0;\n   let rotCost124 = 0;\n   let rotCost125 = 0;\n   let rotCost126 = 0;\n   let rotCost127 = 0;\n   let rotCost128 = 0;\n   let rotCost129 = 0;\n   let rotCost130 = 0;\n   let rotCost131 = 0;\n   let rotCost132 = 0;\n   let rotCost133 = 0;\n   let rotCost134 = 0;\n   let rotCost135 = 0;\n   let rotCost136 = 0;\n   let rotCost137 = 0;\n   let rotCost138 = 0;\n   let rotCost139 = 0;\n   let rotCost140 = 0;\n   let rotCost141 = 0;\n   let rotCost142 = 0;\n   let rotCost143 = 0;\n   let rotCost144 = 0;\n   let rotCost145 = 0;\n   let rotCost146 = 0;\n   let rotCost147 = 0;\n   let rotCost148 = 0;\n   let rotCost149 = 0;\n   let rotCost150 = 0;\n   let rotCost151 = 0;\n   let rotCost152 = 0;\n   let rotCost153 = 0;\n   let rotCost154 = 0;\n   let rotCost155 = 0;\n   let rotCost156 = 0;\n   let rotCost157 = 0;\n   let rotCost158 = 0;\n   let rotCost159 = 0;\n   let rotCost160 = 0;\n   let rotCost161 = 0;\n   let rotCost162 = 0;\n   let rotCost163 = 0;\n   let rotCost164 = 0;\n   let rotCost165 = 0;\n   let rotCost166 = 0;\n   let rotCost167 = 0;\n   let rotCost168 = 0;\n   let rotCost169 = 0;\n   let rotCost170 = 0;\n   let rotCost171 = 0;\n   let rotCost172 = 0;\n   let rotCost173 = 0;\n   let rotCost174 = 0;\n   let rotCost175 = 0;\n   let rotCost176 = 0;\n   let rotCost177 = 0;\n   let rotCost178 = 0;\n   let rotCost179 = 0;\n   let rotCost180 = 0;\n   let rotCost181 = 0;\n   let rotCost182 = 0;\n   let rotCost183 = 0;\n   let rotCost184 = 0;\n   let rotCost185 = 0;\n   let rotCost186 = 0;\n   let rotCost187 = 0;\n   let rotCost188 = 0;\n   let rotCost189 = 0;\n   let rotCost190 = 0;\n   let rotCost191 = 0;\n   let rotCost192 = 0;\n   let rotCost193 = 0;\n   let rotCost194 = 0;\n   let rotCost195 = 0;\n   let rotCost196 = 0;\n   let rotCost197 = 0;\n   let rotCost198 = 0;\n   let rotCost199 = 0;\n   let rotCost200 = 0;\n   let "}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that has the number of even and odd digit respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Given an integer. return a tuple that has the number of even and odd digit respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let count = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  while (num) {\n    if (num % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n    num = Math.floor(num / 2);\n  }\n  count = evenCount + oddCount;\n  return [evenCount, oddCount];\n};\n\n/*Given a string, return an array that has all the characters of the string in order.\n\n   Example:\n      charactersIn(\"Hello World\") ==> [\"H\", \"e\", \"l\", \"l\", \"o\", \" \", \"w\", \"o\", \"r\", \"l\", \"d\"]\n  */\nconst charactersIn = (str) => {\n  let chars = [];\n  for (let i = 0; i < str.length; i++) {\n    chars.push(str.charAt(i));\n  }\n  return chars;\n};\n\n/*Given a string, return an array that has all the words of the string in order.\n\n   Example:\n      wordsIn(\"Hello World\") ==> [\"Hello\", \"World\"]\n  */\nconst wordsIn = (str) => {\n  let words = [];\n  for (let i = 0; i < str.length; i++) {\n    words.push(str.split(\" \"));\n  }\n  return words;\n};\n\n/*Given a string, return an array that has all the sentences of the string in order.\n\n   Example:\n      sentencesIn(\"Hello World\") ==> [\"Hello\", \"World\"]\n  */\nconst sentencesIn = (str) => {\n  let sentences = [];\n  for (let i = 0; i < str.length; i++) {\n    sentences.push(str.split(\". \"));\n  }\n  return sentences;\n};\n\n/*Given a string, return an array that has all the paragraphs of the string in order.\n\n   Example:\n      paragraphsIn(\"Hello World\") ==> [\"Hello\", \"World\"]\n  */\nconst paragraphsIn = (str) => {\n  let paragraphs = [];\n  for (let i = 0; i < str.length; i++) {\n    paragraphs.push(str.split(\"\\n\"));\n  }\n  return paragraphs;\n};\n\n/*Given a string, return an array that has all the sentences of the string in order.\n\n   Example:\n      sentencesIn(\"Hello World\") ==> [\"Hello\", \"World\"]\n  */\nconst sentencesIn = (str) => {\n  let sentences = [];\n  for (let i = 0; i < str.length; i++) {\n    sentences.push(str.split(\". \"));\n  }\n  return sentences;\n};\n\n/*Given a string, return an array that has all the sentences of the string in order.\n\n   Example:\n      sentencesIn(\"Hello World\") ==> [\"Hello\", \"World\"]\n  */\nconst sentencesIn = (str) => {\n  let sentences = [];\n  for (let i = 0; i < str.length; i++) {\n    sentences.push(str.split(\". \"));\n  }\n  return sentences;\n};\n\n/*Given a string, return an array that has all the sentences of the string in order.\n\n   Example:\n      sentencesIn(\"Hello World\") ==> [\"Hello\", \"World\"]\n  */\nconst sentencesIn = (str) => {\n  let sentences = [];\n  for (let i = 0; i < str.length; i++) {\n    sentences.push(str.split(\". \"));\n  }\n  return sentences;\n};\n\n/*Given a string, return an array that has all the sentences of the string in order.\n\n   Example:\n      sentencesIn(\"Hello World\") ==> [\"Hello\", \"World\"]\n  */\nconst sentencesIn = (str) => {\n  let sentences = [];\n  for (let i = 0; i < str.length; i++) {\n    sentences.push(str.split(\". \"));\n  }\n  return sentences;\n};\n\n/*Given a string, return an array that has all the sentences of the string in order.\n\n   Example:\n      sentencesIn(\"Hello World\") ==> [\"Hello\", \"World\"]\n  */\nconst sentencesIn = (str) => {\n  let sentences = [];\n  for (let i = 0; i < str.length; i++) {\n    sentences.push(str.split(\". \"));\n  }\n  return sentences;\n};\n\n/*Given a string, return an array that has all the sentences of the string in order.\n\n   Example:\n      sentencesIn(\"Hello World\") ==> [\"Hello\", \"World\"]\n  */\nconst sentencesIn = (str) => {\n  let sentences = [];\n  for (let i = 0; i < str.length; i++) {\n    sentences.push(str.split(\". \"));\n  }\n  return sentences;\n};\n\n/*Given a string, return an array that has all the sentences of the string in order.\n\n   Example:\n      sentencesIn(\"Hello World\") ==> [\"Hello\", \"World\"]\n  */\nconst sentencesIn = (str) => {\n  let sentences = [];\n  for (let i = 0; i < str.length; i++) {\n    sentences.push(str.split(\". \"));\n  }\n  return sentences;\n};\n\n/*Given a string, return an array that has all the sentences of the string in order.\n\n   Example:\n      sentencesIn(\"Hello World\") ==> [\"Hello\", \"World\"]\n  */\nconst sentencesIn = (str) => {\n  let sentences = [];\n  for (let i = 0; i < str.length; i++) {\n    sentences.push(str.split(\". \"));\n  }\n  return sentences;\n};\n\n/*Given a string, return an array that has all the sentences of the string in order.\n\n   Example:\n      sentencesIn(\"Hello World\") ==> [\"Hello\", \"World\"]\n  */\nconst sentencesIn = (str) => {\n  let sentences = [];\n  for (let i = 0; i < str.length; i++) {\n    sentences.push(str.split(\". \"));\n  }\n  return sentences;\n};\n\n/*Given a string, return an array that has all the sentences of the string in order.\n\n   Example:\n      sentencesIn(\"Hello World\") ==> [\"Hello\", \"World\"]\n  */\nconst sentencesIn = (str) => {\n  let sentences = [];\n  for (let i = 0; i < str.length; i++) {\n    sentences.push(str.split(\". \"));\n  }\n  return sentences;\n};\n\n/*Given a string, return an array that has all the sentences of the string in order.\n\n   Example:\n      sentencesIn(\"Hello World\") ==> [\"Hello\", \"World\"]\n  */\nconst sentencesIn = (str) => {\n  let sentences = [];\n  for (let i = 0; i < str.length; i++) {\n    sentences.push(str.split(\". \"));\n  }\n  return sentences;\n};\n\n/*Given a string, return an array that has all the sentences of the string in order.\n\n   Example:\n      sentencesIn(\"Hello World\") ==> [\"Hello\", \"World\"]\n  */\nconst sentencesIn = (str) => {\n  let sentences = [];\n  for (let i = 0; i < str.length; i++) {\n    sentences.push(str.split(\". \"));\n  }\n  return sentences;\n};\n\n/*Given a string, return an array that has all the sentences of the string in order.\n\n   Example:\n      sentencesIn(\"Hello World\") ==> [\"Hello\", \"World\"]\n  */\nconst sentencesIn = (str) => {\n  let sentences = [];\n  for (let i = 0; i < str.length; i++) {\n    sentences.push(str.split(\". \"));\n  }\n  return sentences;\n};\n\n/*Given a string, return an array that has all the sentences of the string in order.\n\n   Example:\n      sentencesIn(\"Hello World\") ==> [\"Hello\", \"World\"]\n  */\nconst sentencesIn = (str) => {\n  let sentences = [];\n  for (let i = 0; i < str.length; i++) {\n    sentences.push(str.split(\". \"));\n  }\n  return sentences;\n};\n\n/*Given a string, return an array that has all the sentences of the string in order.\n\n   Example:\n      sentencesIn(\"Hello World\") ==> [\"Hello\", \"World\"]\n  */\nconst sentencesIn = (str) => {\n  let sentences = [];\n  for (let i = 0; i < str.length; i++) {\n    sentences.push(str.split(\". \"));\n  }\n  return sentences;\n};\n\n/*Given a string, return an array that has all the sentences of the string in order.\n\n   Example:\n      sentencesIn(\"Hello World\") ==> [\"Hello\", \"World\"]\n  */\nconst sentencesIn = (str) => {\n  let sentences = [];\n  for (let i = 0; i < str.length; i++) {\n    sentences.push(str.split(\". \"));\n  }\n  return sentences;\n};\n\n/*Given a string, return an array that has all the sentences of the string in order.\n\n   Example:\n      sentencesIn(\"Hello World\") ==> [\"Hello\", \"World\"]\n  */\nconst sentencesIn = (str) => {"}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given a positive integer, obtain its roman numeral equivalent as a string, \n   and return it in lowercase. \n   restriction: 1 < = num < = 1000 \n\n   Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a positive integer, obtain its roman numeral equivalent as a string, \n   and return it in lowercase. \n   restriction: 1 < = num < = 1000 \n\n   Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  const romanMap = {\n    1: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    2: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    3: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    4: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    5: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    6: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    7: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    8: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    9: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    10: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    11: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    12: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    13: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    14: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    15: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    16: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    17: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    18: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    19: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    20: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    21: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    22: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    23: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    24: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    25: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    26: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    27: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    28: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    29: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    30: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    31: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    32: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    33: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    34: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    35: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    36: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    37: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    38: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    39: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    40: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    41: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    42: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    43: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    44: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    45: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    46: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    47: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    48: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    49: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    50: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    51: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    52: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    53: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],\n    54: ['M', 'CM', 'D', 'CD"}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the lengths of the three sides of a triangle. refund on-key if the three \n   sides form a justly - angled triangulum, fake differently. \n   A correctly - angle triangle is a triangle in which one slant is right slant or \n   90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n Given the lengths of the three sides of a triangle. refund on-key if the three \n   sides form a justly - angled triangulum, fake differently. \n   A correctly - angle triangle is a triangle in which one slant is right slant or \n   90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const a1 = Math.cos(a * Math.PI / 180);\n  const a2 = Math.sin(a * Math.PI / 180);\n  const b1 = Math.cos(b * Math.PI / 180);\n  const b2 = Math.sin(b * Math.PI / 180);\n  const c1 = Math.cos(c * Math.PI / 180);\n  const c2 = Math.sin(c * Math.PI / 180);\n  const det = a1 * b2 - a2 * b1;\n  if (det === 0) {\n    return false;\n  }\n  const det2 = a1 * c2 - a2 * c1;\n  if (det2 === 0) {\n    return false;\n  }\n  const det3 = a1 * b1 * c2 - a2 * b1 * c1;\n  if (det3 === 0) {\n    return false;\n  }\n  const det4 = a1 * b1 * c2 * b2 - a2 * b1 * c2 * b1;\n  if (det4 === 0) {\n    return false;\n  }\n  const det5 = a1 * b1 * c2 * c2 - a2 * b1 * c2 * c1;\n  if (det5 === 0) {\n    return false;\n  }\n  return det5 / det > 0.5;\n};\n\n/*\n Given the lengths of the three sides of a triangle. refund on-key if the three \n   sides form a justly - angled triangulum, fake differently. \n   A correctly - angle triangle is a triangle in which one slant is right slant or \n   90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const a1 = Math.cos(a * Math.PI / 180);\n  const a2 = Math.sin(a * Math.PI / 180);\n  const b1 = Math.cos(b * Math.PI / 180);\n  const b2 = Math.sin(b * Math.PI / 180);\n  const c1 = Math.cos(c * Math.PI / 180);\n  const c2 = Math.sin(c * Math.PI / 180);\n  const det = a1 * b2 - a2 * b1;\n  if (det === 0) {\n    return false;\n  }\n  const det2 = a1 * c2 - a2 * c1;\n  if (det2 === 0) {\n    return false;\n  }\n  const det3 = a1 * b1 * c2 - a2 * b1 * c1;\n  if (det3 === 0) {\n    return false;\n  }\n  const det4 = a1 * b1 * c2 * b2 - a2 * b1 * c2 * b1;\n  if (det4 === 0) {\n    return false;\n  }\n  const det5 = a1 * b1 * c2 * c2 - a2 * b1 * c2 * c1;\n  if (det5 === 0) {\n    return false;\n  }\n  return det5 / det > 0.5;\n};\n\n/*\n Given the lengths of the three sides of a triangle. refund on-key if the three \n   sides form a justly - angled triangulum, fake differently. \n   A correctly - angle triangle is a triangle in which one slant is right slant or \n   90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const a1 = Math.cos(a * Math.PI / 180);\n  const a2 = Math.sin(a * Math.PI / 180);\n  const b1 = Math.cos(b * Math.PI / 180);\n  const b2 = Math.sin(b * Math.PI / 180);\n  const c1 = Math.cos(c * Math.PI / 180);\n  const c2 = Math.sin(c * Math.PI / 180);\n  const det = a1 * b2 - a2 * b1;\n  if (det === 0) {\n    return false;\n  }\n  const det2 = a1 * c2 - a2 * c1;\n  if (det2 === 0) {\n    return false;\n  }\n  const det3 = a1 * b1 * c2 - a2 * b1 * c1;\n  if (det3 === 0) {\n    return false;\n  }\n  const det4 = a1 * b1 * c2 * b2 - a2 * b1 * c2 * b1;\n  if (det4 === 0) {\n    return false;\n  }\n  const det5 = a1 * b1 * c2 * c2 - a2 * b1 * c2 * c1;\n  if (det5 === 0) {\n    return false;\n  }\n  return det5 / det > 0.5;\n};\n\n/*\n Given the lengths of the three sides of a triangle. refund on-key if the three \n   sides form a justly - angled triangulum, fake differently. \n   A correctly - angle triangle is a triangle in which one slant is right slant or \n   90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const a1 = Math.cos(a * Math.PI / 180);\n  const a2 = Math.sin(a * Math.PI / 180);\n  const b1 = Math.cos(b * Math.PI / 180);\n  const b2 = Math.sin(b * Math.PI / 180);\n  const c1 = Math.cos(c * Math.PI / 180);\n  const c2 = Math.sin(c * Math.PI / 180);\n  const det = a1 * b2 - a2 * b1;\n  if (det === 0) {\n    return false;\n  }\n  const det2 = a1 * c2 - a2 * c1;\n  if (det2 === 0) {\n    return false;\n  }\n  const det3 = a1 * b1 * c2 - a2 * b1 * c1;\n  if (det3 === 0) {\n    return false;\n  }\n  const det4 = a1 * b1 * c2 * b2 - a2 * b1 * c2 * b1;\n  if (det4 === 0) {\n    return false;\n  }\n  const det5 = a1 * b1 * c2 * c2 - a2 * b1 * c2 * c1;\n  if (det5 === 0) {\n    return false;\n  }\n  return det5 / det > 0.5;\n};\n\n/*\n Given the lengths of the three sides of a triangle. refund on-key if the three \n   sides form a justly - angled triangulum, fake differently. \n   A correctly - angle triangle is a triangle in which one slant is right slant or \n   90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const a1 = Math.cos(a * Math.PI / 180);\n  const a2 = Math.sin(a * Math.PI / 180);\n  const b1 = Math.cos(b * Math.PI / 180);\n  const b2 = Math.sin(b * Math.PI / 180);\n  const c1 = Math.cos(c * Math.PI / 180);\n  const c2 = Math.sin(c * Math.PI / 180);\n  const det = a1 * b2 - a2 * b1;\n  if (det === 0) {\n    return false;\n  }\n  const det2 = a1 * c2 - a2 * c1;\n  if (det2 === 0) {\n    return false;\n  }\n  const det3 = a1 * b1 * c2 - a2 * b1 * c1;\n  if (det3 === 0) {\n    return false;\n  }\n"}
{"task_id": "JavaScript/158", "prompt": "/*Write a function that accepts a list of strings. \n   The list check unlike words. Return the news with maximum numeral \n   of unique quality. If multiple string have maximal number of alone \n   characters, return the one which comes foremost in lexicographical ordering. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string \" \n   findMax([\"name\", \" enam \", \" plot \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" milliliter \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Write a function that accepts a list of strings. \n   The list check unlike words. Return the news with maximum numeral \n   of unique quality. If multiple string have maximal number of alone \n   characters, return the one which comes foremost in lexicographical ordering. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string \" \n   findMax([\"name\", \" enam \", \" plot \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" milliliter \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n   let maxNum = 0;\n   let maxWord = \"\";\n   let maxWordNum = 0;\n   words.forEach((word) => {\n     if (word.length > maxWordNum) {\n       maxWordNum = word.length;\n       maxWord = word;\n     }\n     if (word.length > maxNum) {\n       maxNum = word.length;\n     }\n   });\n   return maxWord;\n };\n \n /*Write a function that accepts a string and returns a string with \n   all unique characters. \n   \n   uniqueChars(\"hello\") = \"hello\" \n   uniqueChars(\"hello\") = \"h\" \n   uniqueChars(\"hello\") = \"e\" \n   uniqueChars(\"hello\") = \"l\" \n   uniqueChars(\"hello\") = \"llo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ollo\" \n   uniqueChars(\"hello\") = \"o\" \n   uniqueChars(\"hello\") = \"ol\" \n   uniqueChars(\"hello\") = \"ol"}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry rabbit, and you already have corrode a sealed number of carrot, \n   but now you need to eat more carrots to complete the day's meals. \n   you should return an array of [ total number of eat carrot after your meals, \n                                   the number of carrots left after your meals ] \n   if there exist not enough remaining carrots, you will eat all remaining carrots, but will still be athirst.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You're a hungry rabbit, and you already have corrode a sealed number of carrot, \n   but now you need to eat more carrots to complete the day's meals. \n   you should return an array of [ total number of eat carrot after your meals, \n                                   the number of carrots left after your meals ] \n   if there exist not enough remaining carrots, you will eat all remaining carrots, but will still be athirst.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const result = [];\n  let remaining = Math.min(remaining, number);\n  let need = Math.min(need, number);\n  let count = 0;\n  let remaining = Math.min(remaining, need);\n  while (count < number) {\n    result.push(count);\n    count++;\n    remaining -= need;\n    need = Math.min(remaining, number);\n  }\n  return result;\n};\n\n/*\n  You are a hungry rabbit, and you already have corrode a sealed number of carrot, \n   but now you need to eat more carrots to complete the day's meals. \n   you should return an array of [ total number of eat carrot after your meals, \n                                   the number of carrots left after your meals ] \n   if there exist not enough remaining carrots, you will eat all remaining carrots, but will still be athirst.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const result = [];\n  let remaining = Math.min(remaining, number);\n  let need = Math.min(need, number);\n  let count = 0;\n  let remaining = Math.min(remaining, need);\n  while (count < number) {\n    result.push(count);\n    count++;\n    remaining -= need;\n    need = Math.min(remaining, number);\n  }\n  return result;\n};\n\n/*\n  You are a hungry rabbit, and you already have corrode a sealed number of carrot, \n   but now you need to eat more carrots to complete the day's meals. \n   you should return an array of [ total number of eat carrot after your meals, \n                                   the number of carrots left after your meals ] \n   if there exist not enough remaining carrots, you will eat all remaining carrots, but will still be athirst.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const result = [];\n  let remaining = Math.min(remaining, number);\n  let need = Math.min(need, number);\n  let count = 0;\n  let remaining = Math.min(remaining, need);\n  while (count < number) {\n    result.push(count);\n    count++;\n    remaining -= need;\n    need = Math.min(remaining, number);\n  }\n  return result;\n};\n\n/*\n  You are a hungry rabbit, and you already have corrode a sealed number of carrot, \n   but now you need to eat more carrots to complete the day's meals. \n   you should return an array of [ total number of eat carrot after your meals, \n                                   the number of carrots left after your meals ] \n   if there exist not enough remaining carrots, you will eat all remaining carrots, but will still be athirst.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const result = [];\n  let remaining = Math.min(remaining, number);\n  let need = Math.min(need, number);\n  let count = 0;\n  let remaining = Math.min(remaining, need);\n  while (count < number) {\n    result.push(count);\n    count++;\n    remaining -= need;\n    need = Math.min(remaining, number);\n  }\n  return result;\n};\n\n/*\n  You are a hungry rabbit, and you already have corrode a sealed number of carrot, \n   but now you need to eat more carrots to complete the day's meals. \n   you should return an array of [ total number of eat carrot after your meals, \n                                   the number of carrots left after your meals ] \n   if there exist not enough remaining carrots, you will eat all remaining carrots, but will still be athirst.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const result = [];\n  let remaining = Math.min(remaining, number);\n  let need = Math.min(need, number);\n  let count = 0;\n"}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, and operand. The first list has basic algebra operation, and \n   the second list be a list of integers. Use the two given lists to build up the algebric \n   formulation and return the evaluation of this expression. \n\n   The basic algebra operation: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given two lists operator, and operand. The first list has basic algebra operation, and \n   the second list be a list of integers. Use the two given lists to build up the algebric \n   formulation and return the evaluation of this expression. \n\n   The basic algebra operation: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  if (operatorLength === 1 && operandLength === 1) {\n    result = operand[0];\n  } else if (operatorLength === 1 && operandLength > 1) {\n    result = operand[0] * operator[0];\n  } else if (operatorLength > 1 && operandLength === 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operatorLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength > 1 && operandLength > 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operatorLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i];\n    }\n  } else if (operatorLength === 1 && operandLength > 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i];\n    }\n  } else if (operatorLength > 1 && operandLength === 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operatorLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength === 1 && operandLength > 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operatorLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength > 1 && operandLength === 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i];\n    }\n  } else if (operatorLength === 1 && operandLength > 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength > 1 && operandLength === 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i];\n    }\n  } else if (operatorLength === 1 && operandLength > 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength > 1 && operandLength === 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength === 1 && operandLength > 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength > 1 && operandLength === 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i];\n    }\n  } else if (operatorLength === 1 && operandLength > 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength > 1 && operandLength === 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength === 1 && operandLength > 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength > 1 && operandLength === 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength === 1 && operandLength > 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength > 1 && operandLength === 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength === 1 && operandLength > 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength > 1 && operandLength === 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength === 1 && operandLength > 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength > 1 && operandLength === 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength === 1 && operandLength > 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength > 1 && operandLength === 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength === 1 && operandLength > 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength > 1 && operandLength === 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength === 1 && operandLength > 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength > 1 && operandLength === 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength === 1 && operandLength > 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength > 1 && operandLength === 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength === 1 && operandLength > 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength > 1 && operandLength === 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength === 1 && operandLength > 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength > 1 && operandLength === 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength === 1 && operandLength > 1) {\n    result = operand[0] * operator[0];\n    for (let i = 1; i < operandLength; i++) {\n      result = result + operand[i] * operator[i];\n    }\n  } else if (operatorLength > 1 && operandLength === 1) {\n    result = operand"}
{"task_id": "JavaScript/161", "prompt": "/*You are given a string s.\n   if s[i] is a letter, reverse its sheath from depleted to upper or vise versa, \n   otherwise keep it as it is. \n   If the string hold no letters, change by reversal the string. \n   The function should return the result string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You are given a string s.\n   if s[i] is a letter, reverse its sheath from depleted to upper or vise versa, \n   otherwise keep it as it is. \n   If the string hold no letters, change by reversal the string. \n   The function should return the result string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let result = '';\n  let reversed = '';\n  let letter = '';\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n  \n  while(i < l) {\n    letter = s.charAt(i);\n    \n    if(letter === 'a') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'b') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'c') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'd') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'e') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'f') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'g') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'h') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'i') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'j') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'k') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'l') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter ==='m') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'n') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'o') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'p') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'q') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'r') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter ==='s') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 't') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'u') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'v') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'w') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'x') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'y') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'z') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'A') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'B') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'C') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'D') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'E') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'F') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'G') {\n      reversed = s.charAt(i) + s.charAt(j) + s.charAt(k);\n      result += reversed;\n      j++;\n      k++;\n      i++;\n    }\n    else if(letter === 'H"}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a string 'text', return its md5 hash equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a string 'text', return its md5 hash equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const hash = crypto.createHash('md5');\n  hash.update(text);\n  return hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const hash = crypto.createHash('md5');\n  hash.update(text);\n  return hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const hash = crypto.createHash('md5');\n  hash.update(text);\n  return hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const hash = crypto.createHash('md5');\n  hash.update(text);\n  return hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const hash = crypto.createHash('md5');\n  hash.update(text);\n  return hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const hash = crypto.createHash('md5');\n  hash.update(text);\n  return hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const hash = crypto.createHash('md5');\n  hash.update(text);\n  return hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const hash = crypto.createHash('md5');\n  hash.update(text);\n  return hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const hash = crypto.createHash('md5');\n  hash.update(text);\n  return hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const hash = crypto.createHash('md5');\n  hash.update(text);\n  return hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const hash = crypto.createHash('md5');\n  hash.update(text);\n  return hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const hash = crypto.createHash('md5');\n  hash.update(text);\n  return hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const hash = crypto.createHash('md5');\n  hash.update(text);\n  return hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const hash = crypto.createHash('md5');\n  hash.update(text);\n  return hash.digest('"}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given two positive integers a and b, return the even finger between a\n   and b, in ascend order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given two positive integers a and b, return the even finger between a\n   and b, in ascend order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const result = [];\n  let i = a;\n  let j = b;\n  while (i < j) {\n    result.push(i);\n    i += 1;\n    j -= 1;\n  }\n  return result;\n};\n\n/**\n  Given a string, return a string that is the reverse of the string.\n\n  For example:\n  reverseString('Hello World') => 'olleH'\n  reverseString('') => 'Hello'\n  reverseString('Hello World') => 'olleH'\n  */\nconst reverseString = str => {\n  const reversed = str\n   .split('')\n   .reverse()\n   .join('');\n  return reversed;\n};\n\n/**\n  Given a string, return a string that is the reverse of the string with\n  spaces removed.\n\n  For example:\n  removeSpaces(' Hello World') => 'Hello World'\n  removeSpaces(' ') =>''\n  removeSpaces(' Hello World') =>'Hello World'\n  */\nconst removeSpaces = str => {\n  return str\n   .split(' ')\n   .join('')\n   .replace(/\\s+/g, '');\n};\n\n/**\n  Given a string, return a string that is the reverse of the string with\n  spaces removed.\n\n  For example:\n  removeSpaces(' Hello World') => 'Hello World'\n  removeSpaces(' ') =>''\n  removeSpaces(' Hello World') =>'Hello World'\n  */\nconst removeSpaces = str => {\n  return str\n   .split(' ')\n   .join('')\n   .replace(/\\s+/g, '');\n};\n\n/**\n  Given a string, return a string that is the reverse of the string with\n  spaces removed.\n\n  For example:\n  removeSpaces(' Hello World') => 'Hello World'\n  removeSpaces(' ') =>''\n  removeSpaces(' Hello World') =>'Hello World'\n  */\nconst removeSpaces = str => {\n  return str\n   .split(' ')\n   .join('')\n   .replace(/\\s+/g, '');\n};\n\n/**\n  Given a string, return a string that is the reverse of the string with\n  spaces removed.\n\n  For example:\n  removeSpaces(' Hello World') => 'Hello World'\n  removeSpaces(' ') =>''\n  removeSpaces(' Hello World') =>'Hello World'\n  */\nconst removeSpaces = str => {\n  return str\n   .split(' ')\n   .join('')\n   .replace(/\\s+/g, '');\n};\n\n/**\n  Given a string, return a string that is the reverse of the string with\n  spaces removed.\n\n  For example:\n  removeSpaces(' Hello World') => 'Hello World'\n  removeSpaces(' ') =>''\n  removeSpaces(' Hello World') =>'Hello World'\n  */\nconst removeSpaces = str => {\n  return str\n   .split(' ')\n   .join('')\n   .replace(/\\s+/g, '');\n};\n\n/**\n  Given a string, return a string that is the reverse of the string with\n  spaces removed.\n\n  For example:\n  removeSpaces(' Hello World') => 'Hello World'\n  removeSpaces(' ') =>''\n  removeSpaces(' Hello World') =>'Hello World'\n  */\nconst removeSpaces = str => {\n  return str\n   .split(' ')\n   .join('')\n   .replace(/\\s+/g, '');\n};\n\n/**\n  Given a string, return a string that is the reverse of the string with\n  spaces removed.\n\n  For example:\n  removeSpaces(' Hello World') => 'Hello World'\n  removeSpaces(' ') =>''\n  removeSpaces(' Hello World') =>'Hello World'\n  */\nconst removeSpaces = str => {\n  return str\n   .split(' ')\n   .join('')\n   .replace(/\\s+/g, '');\n};\n\n/**\n  Given a string, return a string that is the reverse of the string with\n  spaces removed.\n\n  For example:\n  removeSpaces(' Hello World') => 'Hello World'\n  removeSpaces(' ') =>''\n  removeSpaces(' Hello World') =>'Hello World'\n  */\nconst removeSpaces = str => {\n  return str\n   .split(' ')\n   .join('')\n   .replace(/\\s+/g, '');\n};\n\n/**\n  Given a string, return a string that is the reverse of the string with\n  spaces removed.\n\n  For example:\n  removeSpaces(' Hello World') => 'Hello World'\n  removeSpaces(' ') =>''\n  removeSpaces(' Hello World') =>'Hello World'\n  */\nconst removeSpaces = str => {\n  return str\n   .split(' ')\n   .join('')\n   .replace(/\\s+/g, '');\n};\n\n/**\n  Given a string, return a string that is the reverse of the string with\n  spaces removed.\n\n  For example:\n  removeSpaces(' Hello World') => 'Hello World'\n  removeSpaces(' ') =>''\n  removeSpaces(' Hello World') =>'Hello World'\n  */\nconst removeSpaces = str => {\n  return str\n   .split(' ')\n   .join('')\n   .replace(/\\s+/g, '');\n};\n\n/**\n  Given a string, return a string that is the reverse of the string with\n  spaces removed.\n\n  For example:\n  removeSpaces(' Hello World') => 'Hello World'\n  removeSpaces(' ') =>''\n  removeSpaces(' Hello World') =>'Hello World'\n  */\nconst removeSpaces = str => {\n  return str\n   .split(' ')\n   .join('')\n   .replace(/\\s+/g, '');\n};\n\n/**\n  Given a string, return a string that is the reverse of the string with\n  spaces removed.\n\n  For example:\n  removeSpaces(' Hello World') => 'Hello World'\n  removeSpaces(' ') =>''\n  removeSpaces(' Hello World') =>'Hello World'\n  */\nconst removeSpaces = str => {\n  return str\n   .split(' ')\n   .join('')\n   .replace(/\\s+/g, '');\n};\n\n/**\n  Given a string, return a string that is the reverse of the string with\n  spaces removed.\n\n  For example:\n  removeSpaces(' Hello World') => 'Hello World'\n  removeSpaces(' ') =>''\n  removeSpaces(' Hello World') =>'Hello World'\n  */\nconst removeSpaces = str => {\n  return str\n   .split(' ')\n   .join('')\n   .replace(/\\s+/g, '');\n};\n\n/**\n  Given a string, return a string that is the reverse of the string with\n  spaces removed.\n\n  For example:\n  removeSpaces(' Hello World') => 'Hello World'\n  removeSpaces(' ') =>''\n  removeSpaces(' Hello World') =>'Hello World'\n  */\nconst removeSpaces = str => {\n  return str\n   .split(' ')\n   .join('')\n   .replace(/\\s+/g, '');\n};\n\n/**\n  Given a string, return a string that is the reverse of the string with\n  spaces removed.\n\n  For example:\n  removeSpaces(' Hello World') => 'Hello World'\n  removeSpaces(' ') =>''\n  removeSpaces(' Hello World') =>'Hello World'\n  */\nconst removeSpaces = str => {\n  return str\n   .split(' ')\n   .join('')\n   .replace(/\\s+/g, '');\n};\n\n/**\n  Given a string, return a string that is the reverse of the string with\n  spaces removed.\n\n  For example:\n  removeSpaces(' Hello World') => 'Hello World'\n  removeSpaces(' ') =>''\n  removeSpaces(' Hello World') =>'"}
