{"task_id": "JavaScript/0", "prompt": "/* Check match if in given contribute list of numbers, are any two numbers closer near to each other than \n   given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Check match if in given contribute list of numbers, are any two numbers closer near to each other than \n   given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const n = numbers.length;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let i;\n  let j;\n  let k;\n  let "}
{"task_id": "JavaScript/1", "prompt": "/* Input stimulation to this function routine is a string containing contain multiple groups of nested cuddle parentheses parenthesis. Your goal is to \n   separate those group into separate freestanding strings string and return the list of those. \n   Separate groups are balanced (each open brace is properly by rights closed shut) and not nested within each other \n   Ignore dismiss any spaces in the input string bowed stringed instrument.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Input stimulation to this function routine is a string containing contain multiple groups of nested cuddle parentheses parenthesis. Your goal is to \n   separate those group into separate freestanding strings string and return the list of those. \n   Separate groups are balanced (each open brace is properly by rights closed shut) and not nested within each other \n   Ignore dismiss any spaces in the input string bowed stringed instrument.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  let paren_groups = [];\n  let paren_group_string = '';\n  let paren_group_open = false;\n  let paren_group_closed = false;\n  let paren_group_strings = [];\n  let paren_group_strings_string = [];\n  let paren_group_strings_open = [];\n  let paren_group_strings_closed = [];\n  let paren_group_strings_strings = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let paren_group_strings_strings_string = [];\n  let "}
{"task_id": "JavaScript/2", "prompt": "/* Given impart a positive convinced floating float point number, it can be decomposed into \n   and integer part share (largest big integer smaller belittled than given sacrifice number) and decimals \n   (leftover part contribution always smaller than 1). \n\n   Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Given impart a positive convinced floating float point number, it can be decomposed into \n   and integer part share (largest big integer smaller belittled than given sacrifice number) and decimals \n   (leftover part contribution always smaller than 1). \n\n   Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const [integer, fraction] = number.toString().split('.');\n  return fraction.length < 2? integer : integer.slice(0, integer.length - fraction.length) + fraction;\n};\n\n/* Given impart a positive convinced floating float point number, it can be decomposed into \n   and integer part share (largest big integer smaller belittled than given sacrifice number) and decimals \n   (leftover part contribution always smaller than 1). \n\n   Return the integer part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateIntegerNumber = (number) => {\n  const [integer, fraction] = number.toString().split('.');\n  return fraction.length < 2? integer : integer.slice(0, integer.length - fraction.length) + fraction;\n};\n\n/* Given impart a positive convinced floating float point number, it can be decomposed into \n   and integer part share (largest big integer smaller belittled than given sacrifice number) and decimals \n   (leftover part contribution always smaller than 1). \n\n   Return the fractional part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateFractionNumber = (number) => {\n  const [integer, fraction] = number.toString().split('.');\n  return fraction.length < 2? integer : integer.slice(0, integer.length - fraction.length) + fraction;\n};\n\n/* Given impart a positive convinced floating float point number, it can be decomposed into \n   and integer part share (largest big integer smaller belittled than given sacrifice number) and decimals \n   (leftover part contribution always smaller than 1). \n\n   Return the integer part and fractional part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateIntegerFractionNumber = (number) => {\n  const [integer, fraction] = number.toString().split('.');\n  return fraction.length < 2? integer : integer.slice(0, integer.length - fraction.length) + fraction;\n};\n\n/* Given impart a positive convinced floating float point number, it can be decomposed into \n   and integer part share (largest big integer smaller belittled than given sacrifice number) and decimals \n   (leftover part contribution always smaller than 1). \n\n   Return the integer part and fractional part of the number.\n  >>> truncateFractionNumber(3.5)\n  3\n  */\nconst truncateFractionFractionNumber = (number) => {\n  const [integer, fraction] = number.toString().split('.');\n  return fraction.length < 2? integer : integer.slice(0, integer.length - fraction.length) + fraction;\n};\n\n/* Given impart a positive convinced floating float point number, it can be decomposed into \n   and integer part share (largest big integer smaller belittled than given sacrifice number) and decimals \n   (leftover part contribution always smaller than 1). \n\n   Return the integer part and fractional part of the number.\n  >>> truncateFractionFractionNumber(3.5)\n  3\n  */\nconst truncateFractionFractionFractionNumber = (number) => {\n  const [integer, fraction] = number.toString().split('.');\n  return fraction.length < 2? integer : integer.slice(0, integer.length - fraction.length) + fraction;\n};\n\n/* Given impart a positive convinced floating float point number, it can be decomposed into \n   and integer part share (largest big integer smaller belittled than given sacrifice number) and decimals \n   (leftover part contribution always smaller than 1). \n\n   Return the integer part and fractional part of the number.\n  >>> truncateFractionFractionFractionNumber(3.5)\n  3\n  */\nconst truncateFractionFractionFractionFractionNumber = (number) => {\n  const [integer, fraction] = number.toString().split('.');\n  return fraction.length < 2? integer : integer.slice(0, integer.length - fraction.length) + fraction;\n};\n\n/* Given impart a positive convinced floating float point number, it can be decomposed into \n   and integer part share (largest big integer smaller belittled than given sacrifice number) and decimals \n   (leftover part contribution always smaller than 1). \n\n   Return the integer part and fractional part of the number.\n  >>> truncateFractionFractionFractionFractionFractionNumber(3.5)\n  3\n  */\nconst truncateFractionFractionFractionFractionFractionNumber = (number) => {\n  const [integer, fraction] = number.toString().split('.');\n  return fraction.length < 2? integer : integer.slice(0, integer.length - fraction.length) + fraction;\n};\n\n/* Given impart a positive convinced floating float point number, it can be decomposed into \n   and integer part share (largest big integer smaller belittled than given sacrifice number) and decimals \n   (leftover part contribution always smaller than 1). \n\n   Return the integer part and fractional part of the number.\n  >>> truncateFractionFractionFractionFractionFractionFractionFractionNumber(3.5)\n  3\n  */\nconst truncateFractionFractionFractionFractionFractionFractionNumber = (number) => {\n  const [integer, fraction] = number.toString().split('.');\n  return fraction.length < 2? integer : integer.slice(0, integer.length - fraction.length) + fraction;\n};\n\n/* Given impart a positive convinced floating float point number, it can be decomposed into \n   and integer part share (largest big integer smaller belittled than given sacrifice number) and decimals \n   (leftover part contribution always smaller than 1). \n\n   Return the integer part and fractional part of the number.\n  >>> truncateFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFraction"}
{"task_id": "JavaScript/3", "prompt": "/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance <= 0;\n};\n\n/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, 10])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, 10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance <= 0;\n};\n\n/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, 10])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, 10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance <= 0;\n};\n\n/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, 10])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, 10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance <= 0;\n};\n\n/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, 10])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, 10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance <= 0;\n};\n\n/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, 10])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, 10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance <= 0;\n};\n\n/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, 10])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, 10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance <= 0;\n};\n\n/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, 10])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, 10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance <= 0;\n};\n\n/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, 10])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, 10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance <= 0;\n};\n\n/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, 10])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, 10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance <= 0;\n};\n\n/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero(["}
{"task_id": "JavaScript/4", "prompt": "/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (mean in this case font ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (mean in this case font ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map((number) => Math.abs(number - mean));\n  return Math.median(deviations);\n};\n\n/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (mean in this case font ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map((number) => Math.abs(number - mean));\n  return Math.median(deviations);\n};\n\n/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (mean in this case font ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map((number) => Math.abs(number - mean));\n  return Math.median(deviations);\n};\n\n/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (mean in this case font ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map((number) => Math.abs(number - mean));\n  return Math.median(deviations);\n};\n\n/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (mean in this case font ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map((number) => Math.abs(number - mean));\n  return Math.median(deviations);\n};\n\n/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (mean in this case font ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map((number) => Math.abs(number - mean));\n  return Math.median(deviations);\n};\n\n/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (mean in this case font ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map((number) => Math.abs(number - mean));\n  return Math.median(deviations);\n};\n\n/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (mean in this case font ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map((number) => Math.abs(number - mean));\n  return Math.median(deviations);\n};\n\n/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (mean in this case font ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map((number) => Math.abs(number - mean));\n  return Math.median(deviations);\n};\n\n/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (mean in this case font ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map((number) => Math.abs(number - mean));\n  return Math.median(deviations);\n};\n\n/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (mean in this case font ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map((number) => Math.abs(number - mean));\n  return Math.median(deviations);\n};\n\n/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (mean in this case font ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map((number) => Math.abs(number - mean));\n  return Math.median(deviations);\n};\n\n/* For a given impart list of input stimulation numbers, "}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number numeral 'delimeter' between every two consecutive back-to-back elements of input remark list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Insert a number numeral 'delimeter' between every two consecutive back-to-back elements of input remark list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < numbers.length) {\n    if (j === numbers.length - 1) {\n      result.push(numbers[i])\n      i++\n      j = 0\n    } else {\n      result.push(numbers[i])\n      i++\n      j++\n    }\n  }\n  result.push(numbers[i])\n  return result\n}\n\n/* Remove all occurrences of substring `from` in `string` from string `to`\n  >>> remove('hello', 'he')\n  'he'\n  >>> remove('hello', 'he', 2)\n  'he'\n  >>> remove('hello', 'he', 0, 2)\n  'he'\n  >>> remove('hello', 'he', 0, 3)\n  'hello'\n  >>> remove('hello', 'he', 0, 4)\n  'hello'\n  >>> remove('hello', 'he', 0, 5)\n  'hello'\n  >>> remove('hello', 'he', 0, 6)\n  'hello'\n  >>> remove('hello', 'he', 0, 7)\n  'hello'\n  >>> remove('hello', 'he', 0, 8)\n  'hello'\n  >>> remove('hello', 'he', 0, 9)\n  'hello'\n  >>> remove('hello', 'he', 0, 10)\n  'hello'\n  >>> remove('hello', 'he', 0, 11)\n  'hello'\n  >>> remove('hello', 'he', 0, 12)\n  'hello'\n  >>> remove('hello', 'he', 0, 13)\n  'hello'\n  >>> remove('hello', 'he', 0, 14)\n  'hello'\n  >>> remove('hello', 'he', 0, 15)\n  'hello'\n  >>> remove('hello', 'he', 0, 16)\n  'hello'\n  >>> remove('hello', 'he', 0, 17)\n  'hello'\n  >>> remove('hello', 'he', 0, 18)\n  'hello'\n  >>> remove('hello', 'he', 0, 19)\n  'hello'\n  >>> remove('hello', 'he', 0, 20)\n  'hello'\n  >>> remove('hello', 'he', 0, 21)\n  'hello'\n  >>> remove('hello', 'he', 0, 22)\n  'hello'\n  >>> remove('hello', 'he', 0, 23)\n  'hello'\n  >>> remove('hello', 'he', 0, 24)\n  'hello'\n  >>> remove('hello', 'he', 0, 25)\n  'hello'\n  >>> remove('hello', 'he', 0, 26)\n  'hello'\n  >>> remove('hello', 'he', 0, 27)\n  'hello'\n  >>> remove('hello', 'he', 0, 28)\n  'hello'\n  >>> remove('hello', 'he', 0, 29)\n  'hello'\n  >>> remove('hello', 'he', 0, 30)\n  'hello'\n  >>> remove('hello', 'he', 0, 31)\n  'hello'\n  >>> remove('hello', 'he', 0, 32)\n  'hello'\n  >>> remove('hello', 'he', 0, 33)\n  'hello'\n  >>> remove('hello', 'he', 0, 34)\n  'hello'\n  >>> remove('hello', 'he', 0, 35)\n  'hello'\n  >>> remove('hello', 'he', 0, 36)\n  'hello'\n  >>> remove('hello', 'he', 0, 37)\n  'hello'\n  >>> remove('hello', 'he', 0, 38)\n  'hello'\n  >>> remove('hello', 'he', 0, 39)\n  'hello'\n  >>> remove('hello', 'he', 0, 40)\n  'hello'\n  >>> remove('hello', 'he', 0, 41)\n  'hello'\n  >>> remove('hello', 'he', 0, 42)\n  'hello'\n  >>> remove('hello', 'he', 0, 43)\n  'hello'\n  >>> remove('hello', 'he', 0, 44)\n  'hello'\n  >>> remove('hello', 'he', 0, 45)\n  'hello'\n  >>> remove('hello', 'he', 0, 46)\n  'hello'\n  >>> remove('hello', 'he', 0, 47)\n  'hello'\n  >>> remove('hello', 'he', 0, 48)\n  'hello'\n  >>> remove('hello', 'he', 0, 49)\n  'hello'\n  >>> remove('hello', 'he', 0, 50)\n  'hello'\n  >>> remove('hello', 'he', 0, 51)\n  'hello'\n  >>> remove('hello', 'he', 0, 52)\n  'hello'\n  >>> remove('hello', 'he', 0, 53)\n  'hello'\n  >>> remove('hello', 'he', 0, 54)\n  'hello'\n  >>> remove('hello', 'he', 0, 55)\n  'hello'\n  >>> remove('hello', 'he', 0, 56)\n  'hello'\n  >>> remove('hello', 'he', 0, 57)\n  'hello'\n  >>> remove('hello', 'he', 0, 58)\n  'hello'\n  >>> remove('hello', 'he', 0, 59)\n  'hello'\n  >>> remove('hello', 'he', 0, 60)\n  'hello'\n  >>> remove('hello', 'he', 0, 61)\n  'hello'\n  >>> remove('hello', 'he', 0, 62)\n  'hello'\n  >>> remove('hello', 'he', 0, 63)\n  'hello'\n  >>> remove('hello', 'he', 0, 64)\n  'hello'\n  >>> remove('hello', 'he', 0, 65)\n  'hello'\n  >>> remove('hello', 'he', 0, 66)\n  'hello'\n  >>> remove('hello', 'he', 0, 67)\n  'hello'\n  >>> remove('hello', 'he', 0, 68)\n  'hello'\n  >>> remove('hello', 'he', 0, 69)\n  'hello'\n  >>> remove('hello', 'he', 0, 70)\n  'hello'\n  >>> remove('hello', 'he', 0, 71)\n  'hello'\n  >>> remove('hello', 'he', 0, 72)\n  'hello'\n  >>> remove('hello', 'he', 0, 73)\n  'hello'\n  >>> remove('hello', 'he', 0, 74)\n  'hello'\n  >>> remove('hello', 'he', 0, 75)\n  'hello'\n  >>> remove('hello', 'he', 0, 76)\n  'hello'\n  >>> remove('hello', 'he', 0, 77)\n  'hello'\n  >>> remove('hello', 'he', 0, 78)\n  'hello'\n  >>> remove('hello', 'he', 0, 79)\n  'hello'\n  >>> remove('hello', 'he', 0, 80)\n  'hello'\n  >>> remove('hello', 'he', 0, 81)\n  'hello'\n  >>> remove('hello', 'he', 0, 82)\n  'hello'\n  >>> remove('hello', 'he', 0, 83)\n  'hello'\n  >>> remove('hello', 'he', 0, 84)\n  'hello'\n  >>> remove('hello', 'he', 0, 85)\n  'hello'\n  >>> remove('hello', 'he', 0, 86)\n  'hello'\n  >>> remove('hello', 'he', 0, 87)\n  'hello'\n  >>> remove('hello', 'he', 0, 88)"}
{"task_id": "JavaScript/6", "prompt": "/* Input stimulation to this function routine is a string represented act multiple groups for nested parentheses digression separated break by spaces quad. \n   For each of the group, output the deepest deep level horizontal surface of nesting of parentheses. \n   E.g. (() ()) has maximum two levels of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Input stimulation to this function routine is a string represented act multiple groups for nested parentheses digression separated break by spaces quad. \n   For each of the group, output the deepest deep level horizontal surface of nesting of parentheses. \n   E.g. (() ()) has maximum two levels of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_array = paren_string.split(/\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\(|\\)|\\"}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1)\n}\n\n/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'ab')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstringIgnoreCase = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1 && str.indexOf(substring.toLowerCase()) > -1)\n}\n\n/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'ab', true)\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstringIgnoreCaseIgnoreCase = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1 && str.indexOf(substring.toLowerCase()) > -1 && str.indexOf(substring.toUpperCase()) > -1)\n}\n\n/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'ab', true)\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstringIgnoreCaseIgnoreCaseIgnoreCase = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1 && str.indexOf(substring.toLowerCase()) > -1 && str.indexOf(substring.toUpperCase()) > -1 && str.indexOf(substring.toUpperCase()) > -1)\n}\n\n/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'ab', true)\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstringIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1 && str.indexOf(substring.toLowerCase()) > -1 && str.indexOf(substring.toUpperCase()) > -1 && str.indexOf(substring.toUpperCase()) > -1 && str.indexOf(substring.toUpperCase()) > -1)\n}\n\n/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'ab', true)\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstringIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1 && str.indexOf(substring.toLowerCase()) > -1 && str.indexOf(substring.toUpperCase()) > -1 && str.indexOf(substring.toUpperCase()) > -1 && str.indexOf(substring.toUpperCase()) > -1)\n}\n\n/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'ab', true)\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstringIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1 && str.indexOf(substring.toLowerCase()) > -1 && str.indexOf(substring.toUpperCase()) > -1 && str.indexOf(substring.toUpperCase()) > -1 && str.indexOf(substring.toUpperCase()) > -1)\n}\n\n/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'ab', true)\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstringIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnore"}
{"task_id": "JavaScript/8", "prompt": "/* For a given impart list of integers integer, return a tuple consisting of a sum union and a product of all the integers integer in a list.\n   Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* For a given impart list of integers integer, return a tuple consisting of a sum union and a product of all the integers integer in a list.\n   Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/* Given a list [1,2,3,4,5,6,7,8,9,10], return a list of integers [1,2,3,4,5,6,7,8,9,10] with each element in the list multiplied by a factor of 10.\n  >>> multiplyByTen([1,2,3,4,5,6,7,8,9,10])\n  [10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,10000000000,100000000000,1000000000000]\n  */\nconst multiplyByTen = (numbers) => {\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(numbers[i] * 10);\n  }\n  return result;\n};\n\n/* Given a list [1,2,3,4,5,6,7,8,9,10], return a list of integers [1,2,3,4,5,6,7,8,9,10] with each element in the list multiplied by a factor of 100.\n  >>> multiplyByTen([1,2,3,4,5,6,7,8,9,10])\n  [100,1000,10000,100000,1000000,10000000,100000000,1000000000,10000000000,100000000000,1000000000000]\n  */\nconst multiplyByTen = (numbers) => {\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(numbers[i] * 100);\n  }\n  return result;\n};\n\n/* Given a list [1,2,3,4,5,6,7,8,9,10], return a list of integers [1,2,3,4,5,6,7,8,9,10] with each element in the list multiplied by a factor of 1000.\n  >>> multiplyByTen([1,2,3,4,5,6,7,8,9,10])\n  [1000,10000,100000,1000000,10000000,100000000,1000000000,10000000000,100000000000,1000000000000]\n  */\nconst multiplyByTen = (numbers) => {\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(numbers[i] * 1000);\n  }\n  return result;\n};\n\n/* Given a list [1,2,3,4,5,6,7,8,9,10], return a list of integers [1,2,3,4,5,6,7,8,9,10] with each element in the list multiplied by a factor of 10000.\n  >>> multiplyByTen([1,2,3,4,5,6,7,8,9,10])\n  [10000,100000,1000000,10000000,100000000,1000000000,10000000000,100000000000,1000000000000]\n  */\nconst multiplyByTen = (numbers) => {\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(numbers[i] * 10000);\n  }\n  return result;\n};\n\n/* Given a list [1,2,3,4,5,6,7,8,9,10], return a list of integers [1,2,3,4,5,6,7,8,9,10] with each element in the list multiplied by a factor of 100000.\n  >>> multiplyByTen([1,2,3,4,5,6,7,8,9,10])\n  [100000,1000000,10000000,100000000,1000000000,10000000000,100000000000,1000000000000]\n  */\nconst multiplyByTen = (numbers) => {\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(numbers[i] * 100000);\n  }\n  return result;\n};\n\n/* Given a list [1,2,3,4,5,6,7,8,9,10], return a list of integers [1,2,3,4,5,6,7,8,9,10] with each element in the list multiplied by a factor of 1000000.\n  >>> multiplyByTen([1,2,3,4,5,6,7,8,9,10])\n  [1000000,10000000,100000000,1000000000,10000000000,100000000000,1000000000000]\n  */\nconst multiplyByTen = (numbers) => {\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(numbers[i] * 1000000);\n  }\n  return result;\n};\n\n/* Given a list [1,2,3,4,5,6,7,8,9,10], return a list of integers [1,2,3,4,5,6,7,8,9,10] with each element in the list multiplied by a factor of 100000000.\n  >>> multiplyByTen([1,2,3,4,5,6,7,8,9,10])\n  [100000000,1000000000,10000000000,100000000000,1000000000000]\n  */\nconst multiplyByTen = (numbers) => {\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(numbers[i] * 100000000);\n  }\n  return result;\n};\n\n/* Given a list [1,2,3,4,5,6,7,8,9,10], return a list of integers [1,2,3,4,5,6,7,8,9,10] with each element in the list multiplied by a factor of 1000000000.\n  >>> multiplyByTen([1,2,3,4,5,6,7,8,9,10])\n  [1000000000,10000000000,100000000000,1000000000000]\n  */\nconst multiplyByTen = (numbers) => {\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(numbers[i] * 1000000000);\n  }\n  return result;\n};\n\n/* Given a list [1,2,3,4,5,6,7,8,9,10], return a list of integers [1,2,3,4,5,6,7,8,9,10] with each element in the list multiplied by a factor of 10000000000.\n  >>> multiplyByTen([1,2,3,4,5,6,7,8,9,10])\n  [10000000000,100000000000,1000000000000,10000000000000]\n  */\nconst multiplyByTen = (numbers) => {\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(numbers[i] * 10000000000);\n  }\n  return result;\n};\n\n/* Given a list [1,2,3,4,5,6,7,8,9,10], return a list of integers [1,2,3,4,5,6,7,8,9,10] with each element in the list multiplied by a factor of 100000000000.\n  >>> multiplyByTen([1,2,3,4,5,6,7,8,9,10])\n  [100000000000,1000000000000,10000000000000]\n  */\nconst multiplyByTen = (numbers) => {\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(numbers[i] * 100000000000);\n  }\n  return result;\n};\n\n/* Given a list [1,2,3,4,5,6,7,8,9,10], return a list of integers [1,2,3,4,5,6,7,8,9,10] with each element in the list multiplied by a factor of 1000000000000.\n  >>> multiplyByTen([1,2,3,4,5,6,7,8,9,10])\n  [1000000000000,10000000000000,100000000000000]\n  */\nconst multiplyByTen = (numbers) => {\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(numbers[i] * 1000000000000);\n  }\n  return result;\n};\n\n/* Given a list [1,2,3,4,5,6,7,8,9,10], return a list of integers [1,2,3,4,5,6,7,8,9,10] with each element in the list multiplied by a factor of 10000000000000.\n  >>> multiplyByTen([1,2,3,4,5,6,7,8,9,10])\n  [10000000000000,100000000000000,10000000000000000]\n  */\nconst multiplyByTen = (numbers) => {\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(numbers[i] * 10000000000000);\n  }\n  return result;\n};\n\n/* Given a list [1,2,3,4,5,6,7,8,9,10], return a list of integers [1,2,3,4,5,6,7,8,9,10] with each element in the list multiplied by a factor of 100000000000000.\n  >>> multiplyByTen([1,2,3,4,5,6,7,8,9,"}
{"task_id": "JavaScript/9", "prompt": "/* From a given impart list of integers integer, generate a list of rolling wheel maximum element chemical element found detect until given moment \n   in the sequence succession.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* From a given impart list of integers integer, generate a list of rolling wheel maximum element chemical element found detect until given moment \n   in the sequence succession.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  let max = 0;\n  let maxIndex = 0;\n  let maxValue = 0;\n  let currentValue = 0;\n  let currentIndex = 0;\n  let currentMax = 0;\n  let currentMaxIndex = 0;\n  let currentMaxValue = 0;\n  let currentMaxIndex2 = 0;\n  let currentMaxValue2 = 0;\n  let currentMaxIndex3 = 0;\n  let currentMaxValue3 = 0;\n  let currentMaxIndex4 = 0;\n  let currentMaxValue4 = 0;\n  let currentMaxIndex5 = 0;\n  let currentMaxValue5 = 0;\n  let currentMaxIndex6 = 0;\n  let currentMaxValue6 = 0;\n  let currentMaxIndex7 = 0;\n  let currentMaxValue7 = 0;\n  let currentMaxIndex8 = 0;\n  let currentMaxValue8 = 0;\n  let currentMaxIndex9 = 0;\n  let currentMaxValue9 = 0;\n  let currentMaxIndex10 = 0;\n  let currentMaxValue10 = 0;\n  let currentMaxIndex11 = 0;\n  let currentMaxValue11 = 0;\n  let currentMaxIndex12 = 0;\n  let currentMaxValue12 = 0;\n  let currentMaxIndex13 = 0;\n  let currentMaxValue13 = 0;\n  let currentMaxIndex14 = 0;\n  let currentMaxValue14 = 0;\n  let currentMaxIndex15 = 0;\n  let currentMaxValue15 = 0;\n  let currentMaxIndex16 = 0;\n  let currentMaxValue16 = 0;\n  let currentMaxIndex17 = 0;\n  let currentMaxValue17 = 0;\n  let currentMaxIndex18 = 0;\n  let currentMaxValue18 = 0;\n  let currentMaxIndex19 = 0;\n  let currentMaxValue19 = 0;\n  let currentMaxIndex20 = 0;\n  let currentMaxValue20 = 0;\n  let currentMaxIndex21 = 0;\n  let currentMaxValue21 = 0;\n  let currentMaxIndex22 = 0;\n  let currentMaxValue22 = 0;\n  let currentMaxIndex23 = 0;\n  let currentMaxValue23 = 0;\n  let currentMaxIndex24 = 0;\n  let currentMaxValue24 = 0;\n  let currentMaxIndex25 = 0;\n  let currentMaxValue25 = 0;\n  let currentMaxIndex26 = 0;\n  let currentMaxValue26 = 0;\n  let currentMaxIndex27 = 0;\n  let currentMaxValue27 = 0;\n  let currentMaxIndex28 = 0;\n  let currentMaxValue28 = 0;\n  let currentMaxIndex29 = 0;\n  let currentMaxValue29 = 0;\n  let currentMaxIndex30 = 0;\n  let currentMaxValue30 = 0;\n  let currentMaxIndex31 = 0;\n  let currentMaxValue31 = 0;\n  let currentMaxIndex32 = 0;\n  let currentMaxValue32 = 0;\n  let currentMaxIndex33 = 0;\n  let currentMaxValue33 = 0;\n  let currentMaxIndex34 = 0;\n  let currentMaxValue34 = 0;\n  let currentMaxIndex35 = 0;\n  let currentMaxValue35 = 0;\n  let currentMaxIndex36 = 0;\n  let currentMaxValue36 = 0;\n  let currentMaxIndex37 = 0;\n  let currentMaxValue37 = 0;\n  let currentMaxIndex38 = 0;\n  let currentMaxValue38 = 0;\n  let currentMaxIndex39 = 0;\n  let currentMaxValue39 = 0;\n  let currentMaxIndex40 = 0;\n  let currentMaxValue40 = 0;\n  let currentMaxIndex41 = 0;\n  let currentMaxValue41 = 0;\n  let currentMaxIndex42 = 0;\n  let currentMaxValue42 = 0;\n  let currentMaxIndex43 = 0;\n  let currentMaxValue43 = 0;\n  let currentMaxIndex44 = 0;\n  let currentMaxValue44 = 0;\n  let currentMaxIndex45 = 0;\n  let currentMaxValue45 = 0;\n  let currentMaxIndex46 = 0;\n  let currentMaxValue46 = 0;\n  let currentMaxIndex47 = 0;\n  let currentMaxValue47 = 0;\n  let currentMaxIndex48 = 0;\n  let currentMaxValue48 = 0;\n  let currentMaxIndex49 = 0;\n  let currentMaxValue49 = 0;\n  let currentMaxIndex50 = 0;\n  let currentMaxValue50 = 0;\n  let currentMaxIndex51 = 0;\n  let currentMaxValue51 = 0;\n  let currentMaxIndex52 = 0;\n  let currentMaxValue52 = 0;\n  let currentMaxIndex53 = 0;\n  let currentMaxValue53 = 0;\n  let currentMaxIndex54 = 0;\n  let currentMaxValue54 = 0;\n  let currentMaxIndex55 = 0;\n  let currentMaxValue55 = 0;\n  let currentMaxIndex56 = 0;\n  let currentMaxValue56 = 0;\n  let currentMaxIndex57 = 0;\n  let currentMaxValue57 = 0;\n  let currentMaxIndex58 = 0;\n  let currentMaxValue58 = 0;\n  let currentMaxIndex59 = 0;\n  let currentMaxValue59 = 0;\n  let currentMaxIndex60 = 0;\n  let currentMaxValue60 = 0;\n  let currentMaxIndex61 = 0;\n  let currentMaxValue61 = 0;\n  let currentMaxIndex62 = 0;\n  let currentMaxValue62 = 0;\n  let currentMaxIndex63 = 0;\n  let currentMaxValue63 = 0;\n  let currentMaxIndex64 = 0;\n  let currentMaxValue64 = 0;\n  let currentMaxIndex65 = 0;\n  let currentMaxValue65 = 0;\n  let currentMaxIndex66 = 0;\n  let currentMaxValue66 = 0;\n  let currentMaxIndex67 = 0;\n  let currentMaxValue67 = 0;\n  let currentMaxIndex68 = 0;\n  let currentMaxValue68 = 0;\n  let currentMaxIndex69 = 0;\n  let currentMaxValue69 = 0;\n  let currentMaxIndex70 = 0;\n  let currentMaxValue70 = 0;\n  let currentMaxIndex71 = 0;\n  let currentMaxValue71 = 0;\n  let currentMaxIndex72 = 0;\n  let currentMaxValue72 = 0;\n  let currentMaxIndex73 = 0;\n  let currentMaxValue73 = 0;\n  let currentMaxIndex74 = 0;\n  let currentMaxValue74 = 0;\n  let currentMaxIndex75 = 0;\n  let currentMaxValue75 = 0;\n  let currentMaxIndex76 = 0;\n  let currentMaxValue76 = 0;\n  let currentMaxIndex77 = 0;\n  let currentMaxValue77 = 0;\n  let currentMaxIndex78 = 0;\n  let currentMaxValue78 = 0;\n  let currentMaxIndex79 = 0;\n  let currentMaxValue79 = 0;\n  let currentMaxIndex80 = 0;\n  let currentMaxValue80 = 0;\n  let currentMaxIndex81 = 0;\n  let currentMaxValue81 = 0;\n  let currentMaxIndex82 = 0;\n  let currentMaxValue82 = 0;\n  let currentMaxIndex83 = 0;\n  let currentMaxValue83 = 0;\n  let currentMaxIndex84 = 0;\n  let currentMaxValue84 = 0;\n  let currentMaxIndex85 = 0;\n  let currentMaxValue85 = 0;\n  let currentMaxIndex86 = 0;\n  let currentMaxValue86 = 0;\n  let currentMaxIndex87 = 0;\n  let currentMaxValue87 = 0;\n  let currentMaxIndex88 = 0;\n  let currentMaxValue88 = 0;\n  let currentMaxIndex89 = 0;\n  let currentMaxValue89 = 0;\n  let currentMaxIndex90 = 0;\n  let currentMaxValue90 = 0;\n  let currentMaxIndex91 = 0;\n  let currentMaxValue91 = 0;\n  let currentMaxIndex92 = 0;\n  let currentMaxValue92 = 0;\n  let currentMaxIndex93 = 0;\n  let currentMaxValue93 = 0;\n  let currentMaxIndex94 = 0;\n  let currentMaxValue94 = 0;\n  let currentMaxIndex95 = 0;\n  let currentMaxValue95 = 0;\n  let currentMaxIndex96 = 0;\n  let currentMaxValue96 = 0;\n  let currentMaxIndex97 = 0;\n  let currentMaxValue97 = 0;\n  let currentMaxIndex98 = 0;\n  let currentMaxValue98 = 0;\n  let currentMaxIndex99 = 0;\n  let currentMaxValue99 = 0;\n  let currentMaxIndex100 = 0;\n  let currentMaxValue100 = 0;\n  let currentMaxIndex101 = 0;\n  let currentMaxValue101 = 0;\n  let currentMaxIndex102 = 0;\n  let currentMaxValue102 = 0;\n  let currentMaxIndex103 = 0;\n  let currentMaxValue103 = 0;\n  let currentMaxIndex104 = 0;\n  let currentMaxValue104 = 0;\n"}
{"task_id": "JavaScript/10", "prompt": "/* Test quiz if gniven strig is a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find line up the shortest palindrome that begins get down with a supplied string.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied provide string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Test quiz if gniven strig is a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find line up the shortest palindrome that begins get down with a supplied string.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied provide string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let longestPalindrome = '';\n  let longestPalindromeLength = 0;\n  let longestPalindromePrefix = '';\n  let longestPalindromeSuffix = '';\n  let longestPalindromeSuffixLength = 0;\n  let longestPalindromeSuffixPrefix = '';\n  let longestPalindromeSuffixSuffix = '';\n  let longestPalindromeSuffixSuffixLength = 0;\n  let longestPalindromeSuffixSuffixPrefix = '';\n  let longestPalindromeSuffixSuffixSuffix = '';\n  let longestPalindromeSuffixSuffixSuffixLength = 0;\n  let longestPalindromeSuffixSuffixSuffixPrefix = '';\n  let longestPalindromeSuffixSuffixSuffixSuffix = '';\n  let longestPalindromeSuffixSuffixSuffixSuffixLength = 0;\n  let longestPalindromeSuffixSuffixSuffixSuffixPrefix = '';\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffix = '';\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixLength = 0;\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixPrefix = '';\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffix = '';\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixLength = 0;\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixPrefix = '';\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffix = '';\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixLength = 0;\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixPrefix = '';\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffix = '';\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0;\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixPrefix = '';\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = '';\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0;\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixPrefix = '';\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = '';\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0;\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixPrefix = '';\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = '';\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0;\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixPrefix = '';\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = '';\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0;\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixPrefix = '';\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = '';\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0;\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixPrefix = '';\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = '';\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix"}
{"task_id": "JavaScript/11", "prompt": "/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary XOR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary XOR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = 0;\n  \n  for (let i = 0; i < a.length; i++) {\n    result += a[i]^b[i];\n  }\n  \n  return result;\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary AND on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = 0;\n  \n  for (let i = 0; i < a.length; i++) {\n    result += a[i]&b[i];\n  }\n  \n  return result;\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary OR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = 0;\n  \n  for (let i = 0; i < a.length; i++) {\n    result += a[i]|b[i];\n  }\n  \n  return result;\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary XOR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = 0;\n  \n  for (let i = 0; i < a.length; i++) {\n    result += a[i]^b[i];\n  }\n  \n  return result;\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary AND on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = 0;\n  \n  for (let i = 0; i < a.length; i++) {\n    result += a[i]&b[i];\n  }\n  \n  return result;\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary OR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = 0;\n  \n  for (let i = 0; i < a.length; i++) {\n    result += a[i]|b[i];\n  }\n  \n  return result;\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary XOR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = 0;\n  \n  for (let i = 0; i < a.length; i++) {\n    result += a[i]^b[i];\n  }\n  \n  return result;\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary AND on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = 0;\n  \n  for (let i = 0; i < a.length; i++) {\n    result += a[i]&b[i];\n  }\n  \n  return result;\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary OR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = 0;\n  \n  for (let i = 0; i < a.length; i++) {\n    result += a[i]|b[i];\n  }\n  \n  return result;\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary XOR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = 0;\n  \n  for (let i = 0; i < a.length; i++) {\n    result += a[i]^b[i];\n  }\n  \n  return result;\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary AND on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = 0;\n  \n  for (let i = 0; i < a.length; i++) {\n    result += a[i]&b[i];\n  }\n  \n  return result;\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary OR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = 0;\n  \n  for (let i = 0; i < a.length; i++) {\n    result += a[i]|b[i];\n  }\n  \n  return result;\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary XOR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = 0;\n  \n  for (let i = 0; i < a.length; i++) {\n    result += a[i]^b[i];\n  }\n  \n  return result;\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary AND on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = 0;\n  \n  for (let i = 0; i < a.length; i++) {\n    result += a[i]&b[i];\n  }\n  \n  return result;\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary OR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = 0;\n  \n  for (let i = 0; i < a.length; i++) {\n    result += a[i]|b[i];\n  }\n  \n  return result;\n};\n\n/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. "}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Return reelect the first beginning one in case of multiple \n   strings of the same length duration. Return null in case font the input stimulation list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Out of list of strings, return the longest one. Return reelect the first beginning one in case of multiple \n   strings of the same length duration. Return null in case font the input stimulation list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n  let longestLength = 0\n  let longestString = ''\n  for (let i = 0; i < strings.length; i++) {\n    const string = strings[i]\n    if (string.length > longestLength) {\n      longestLength = string.length\n      longestString = string\n    }\n  }\n  return longestString\n}\n\n/* Given a list with strings and a duration, return a list of strings containing all strings of the same length \n   starting from the longest one. Return null if the input list is empty.\n  >>> longest(['a', 'b', 'c'])\n  ['b', 'c']\n  >>> longest(['a', 'bb', 'ccc'])\n  ['bb', 'ccc']\n  */\nconst longestString = (strings, duration) => {\n  if (strings.length === 0) {\n    return null\n  }\n  let longestLength = 0\n  let longestString = ''\n  for (let i = 0; i < strings.length; i++) {\n    const string = strings[i]\n    if (string.length > longestLength) {\n      longestLength = string.length\n      longestString = string\n    }\n  }\n  const result = []\n  for (let i = 0; i < longestLength; i++) {\n    result.push(longestString.substring(0, i))\n  }\n  return result\n}\n\n/* Given a list with strings and a duration, return a list of strings containing all strings of the same length \n   starting from the longest one. Return null if the input list is empty.\n  >>> longestString([\n  'a', 'b', 'c'],\n  2)\n  ['b', 'c']\n  >>> longestString([\n  'a', 'bb', 'ccc'],\n  2)\n  ['bb', 'ccc']\n  */\nconst longestStringWithDuration = (strings, duration) => {\n  if (strings.length === 0) {\n    return null\n  }\n  let longestLength = 0\n  let longestString = ''\n  for (let i = 0; i < strings.length; i++) {\n    const string = strings[i]\n    if (string.length > longestLength) {\n      longestLength = string.length\n      longestString = string\n    }\n  }\n  const result = []\n  for (let i = 0; i < longestLength; i++) {\n    result.push(longestString.substring(0, i))\n  }\n  return result\n}\n\n/* Given a list with strings and a duration, return a list of strings containing all strings of the same length \n   starting from the longest one. Return null if the input list is empty.\n  >>> longestStringWithDuration([\n  'a', 'b', 'c'],\n  2)\n  ['b', 'c']\n  >>> longestStringWithDuration([\n  'a', 'bb', 'ccc'],\n  2)\n  ['bb', 'ccc']\n  */\nconst longestStringWithDurationWithDuration = (strings, duration) => {\n  if (strings.length === 0) {\n    return null\n  }\n  let longestLength = 0\n  let longestString = ''\n  for (let i = 0; i < strings.length; i++) {\n    const string = strings[i]\n    if (string.length > longestLength) {\n      longestLength = string.length\n      longestString = string\n    }\n  }\n  const result = []\n  for (let i = 0; i < longestLength; i++) {\n    result.push(longestString.substring(0, i))\n  }\n  return result\n}\n\n/* Given a list with strings and a duration, return a list of strings containing all strings of the same length \n   starting from the longest one. Return null if the input list is empty.\n  >>> longestStringWithDurationWithDuration([\n  'a', 'b', 'c'],\n  2)\n  ['b', 'c']\n  >>> longestStringWithDurationWithDuration([\n  'a', 'bb', 'ccc'],\n  2)\n  ['bb', 'ccc']\n  */\nconst longestStringWithDurationWithDurationWithDuration = (strings, duration) => {\n  if (strings.length === 0) {\n    return null\n  }\n  let longestLength = 0\n  let longestString = ''\n  for (let i = 0; i < strings.length; i++) {\n    const string = strings[i]\n    if (string.length > longestLength) {\n      longestLength = string.length\n      longestString = string\n    }\n  }\n  const result = []\n  for (let i = 0; i < longestLength; i++) {\n    result.push(longestString.substring(0, i))\n  }\n  return result\n}\n\n/* Given a list with strings and a duration, return a list of strings containing all strings of the same length \n   starting from the longest one. Return null if the input list is empty.\n  >>> longestStringWithDurationWithDurationWithDuration([\n  'a', 'b', 'c'],\n  2)\n  ['b', 'c']\n  >>> longestStringWithDurationWithDurationWithDuration([\n  'a', 'bb', 'ccc'],\n  2)\n  ['bb', 'ccc']\n  */\nconst longestStringWithDurationWithDurationWithDurationWithDuration = (strings, duration) => {\n  if (strings.length === 0) {\n    return null\n  }\n  let longestLength = 0\n  let longestString = ''\n  for (let i = 0; i < strings.length; i++) {\n    const string = strings[i]\n    if (string.length > longestLength) {\n      longestLength = string.length\n      longestString = string\n    }\n  }\n  const result = []\n  for (let i = 0; i < longestLength; i++) {\n    result.push(longestString.substring(0, i))\n  }\n  return result\n}\n\n/* Given a list with strings and a duration, return a list of strings containing all strings of the same length \n   starting from the longest one. Return null if the input list is empty.\n  >>> longestStringWithDurationWithDurationWithDurationWithDuration([\n  'a', 'b', 'c'],\n  2)\n  ['b', 'c']\n  >>> longestStringWithDurationWithDurationWithDurationWithDuration([\n  'a', 'bb', 'ccc'],\n  2)\n  ['bb', 'ccc']\n  */\nconst longestStringWithDurationWithDurationWithDurationWithDurationWithDuration = (strings, duration) => {\n  if (strings.length === 0) {\n    return null\n  }\n  let longestLength = 0\n  let longestString = ''\n  for (let i = 0; i < strings.length; i++) {\n    const string = strings[i]\n    if (string.length > longestLength) {\n      longestLength = string.length\n      longestString = string\n    }\n  }\n  const result = []\n  for (let i = 0; i < longestLength; i++) {\n    result.push(longestString.substring(0, i))\n  }\n  return result\n}\n\n/* Given a list with strings and a duration, return a list of strings containing all strings of the same length \n   starting from the longest one. Return null if the input list is empty.\n  >>> longestStringWithDurationWithDurationWithDurationWithDurationWithDuration([\n  'a', 'b', 'c'],\n  2)\n  ['b', 'c']\n  >>> longestStringWithDurationWithDurationWithDurationWithDurationWithDurationWithDuration([\n  'a', 'bb', 'ccc'],\n  2)\n  ['bb', 'ccc']\n  */\nconst longestStringWithDurationWithDurationWithDurationWithDurationWithDurationWithDuration = (strings, duration) => {\n  if (strings.length === 0) {\n    return null\n  }\n  let longestLength = 0\n  let longestString = ''\n  for (let i = 0; i < strings.length; i++) {\n    const string = strings[i]\n    if (string.length > longestLength) {\n      longestLength = string.length\n      longestString = string\n    }\n  }\n  const result = []\n  for (let i = 0; i < longestLength; i++) {\n    result.push(longestString.substring(0, i))\n  }\n  return result\n}\n\n/* Given a list with strings and a duration, return a list of strings containing all strings of the same length \n   starting from the longest one. Return null if the input list is empty.\n  >>> longestStringWithDurationWithDurationWithDurationWithDurationWithDurationWithDuration([\n  'a', 'b', 'c'],\n  2)\n  ['b', 'c']\n  >>> longestStringWithDurationWithDurationWithDurationWithDurationWithDurationWithDurationWithDuration([\n  'a', 'bb', 'ccc'],\n  2)\n  ['bb', 'ccc']\n  */\nconst longestStringWithDurationWithDurationWithDurationWithDurationWithDurationWithDurationWithDuration = (strings, duration) => {\n  if (strings.length === 0) {\n    return "}
{"task_id": "JavaScript/13", "prompt": "/* Return restitution a greatest big common divisor of two integers integer a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Return restitution a greatest big common divisor of two integers integer a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (a % b === 0) {\n    return a\n  }\n  return b\n}\n\n/**\n * Check if a number is prime\n * @param {number} n\n * @returns {boolean}\n */\nconst isPrime = function (n) {\n  if (n <= 2) {\n    return false\n  }\n  for (let i = 2; i < Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Check if a number is divisible by another\n * @param {number} n\n * @param {number} d\n * @returns {boolean}\n */\nconst isDivisibleBy = (n, d) => {\n  if (n <= d) {\n    return false\n  }\n  for (let i = d; i < n; i++) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Check if a number is divisible by another\n * @param {number} n\n * @param {number} d\n * @returns {boolean}\n */\nconst isDivisibleByTwo = (n, d) => {\n  if (n <= d) {\n    return false\n  }\n  for (let i = d; i < n; i++) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Check if a number is divisible by another\n * @param {number} n\n * @param {number} d\n * @returns {boolean}\n */\nconst isDivisibleByThree = (n, d) => {\n  if (n <= d) {\n    return false\n  }\n  for (let i = d; i < n; i++) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Check if a number is divisible by another\n * @param {number} n\n * @param {number} d\n * @returns {boolean}\n */\nconst isDivisibleByFour = (n, d) => {\n  if (n <= d) {\n    return false\n  }\n  for (let i = d; i < n; i++) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Check if a number is divisible by another\n * @param {number} n\n * @param {number} d\n * @returns {boolean}\n */\nconst isDivisibleByFive = (n, d) => {\n  if (n <= d) {\n    return false\n  }\n  for (let i = d; i < n; i++) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Check if a number is divisible by another\n * @param {number} n\n * @param {number} d\n * @returns {boolean}\n */\nconst isDivisibleBySix = (n, d) => {\n  if (n <= d) {\n    return false\n  }\n  for (let i = d; i < n; i++) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Check if a number is divisible by another\n * @param {number} n\n * @param {number} d\n * @returns {boolean}\n */\nconst isDivisibleBySeven = (n, d) => {\n  if (n <= d) {\n    return false\n  }\n  for (let i = d; i < n; i++) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Check if a number is divisible by another\n * @param {number} n\n * @param {number} d\n * @returns {boolean}\n */\nconst isDivisibleByEight = (n, d) => {\n  if (n <= d) {\n    return false\n  }\n  for (let i = d; i < n; i++) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Check if a number is divisible by another\n * @param {number} n\n * @param {number} d\n * @returns {boolean}\n */\nconst isDivisibleByNine = (n, d) => {\n  if (n <= d) {\n    return false\n  }\n  for (let i = d; i < n; i++) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Check if a number is divisible by another\n * @param {number} n\n * @param {number} d\n * @returns {boolean}\n */\nconst isDivisibleByTen = (n, d) => {\n  if (n <= d) {\n    return false\n  }\n  for (let i = d; i < n; i++) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Check if a number is divisible by another\n * @param {number} n\n * @param {number} d\n * @returns {boolean}\n */\nconst isDivisibleByEleven = (n, d) => {\n  if (n <= d) {\n    return false\n  }\n  for (let i = d; i < n; i++) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Check if a number is divisible by another\n * @param {number} n\n * @param {number} d\n * @returns {boolean}\n */\nconst isDivisibleByTwelve = (n, d) => {\n  if (n <= d) {\n    return false\n  }\n  for (let i = d; i < n; i++) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Check if a number is divisible by another\n * @param {number} n\n * @param {number} d\n * @returns {boolean}\n */\nconst isDivisibleByThirteen = (n, d) => {\n  if (n <= d) {\n    return false\n  }\n  for (let i = d; i < n; i++) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Check if a number is divisible by another\n * @param {number} n\n * @param {number} d\n * @returns {boolean}\n */\nconst isDivisibleByFourteen = (n, d) => {\n  if (n <= d) {\n    return false\n  }\n  for (let i = d; i < n; i++) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Check if a number is divisible by another\n * @param {number} n\n * @param {number} d\n * @returns {boolean}\n */\nconst isDivisibleByFifteen = (n, d) => {\n  if (n <= d) {\n    return false\n  }\n  for (let i = d; i < n; i++) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Check if a number is divisible by another\n * @param {number} n\n * @param {number} d\n * @returns {boolean}\n */\nconst isDivisibleBySixteen = (n, d) => {\n  if (n <= d) {\n    return false\n  }\n  for (let i = d; i < n; i++) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Check if a number is divisible by another\n * @param {number} n\n * @param {number} d\n * @returns {boolean}\n */\nconst isDivisibleBySeventeen = (n, d) => {\n  if (n <= d) {\n    return false\n  }\n  for (let i = d; i < n; i++) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Check if a number is divisible by another\n * @param {number} n\n * @param {number} d\n * @returns {boolean}\n */\nconst isDivisibleByEighteen = (n, d) => {\n  if (n <= d) {\n    return false\n  }\n  for (let i = d; i < n; i++) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Check if a number is divisible by another\n * @param {number} n\n * @param {number} d\n * @returns {boolean}\n */\nconst isDivisibleByNineteen = (n, d) => {\n  if (n <= d) {\n    return false\n  }\n  for (let i = d; i < n; i++) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Check if a number is divisible by another\n * @param {number} n\n * @param {number} d\n * @returns {boolean}\n */\nconst is"}
{"task_id": "JavaScript/14", "prompt": "/* Return restitution list of all prefixes prefix from shortest to longest of the input remark string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Return restitution list of all prefixes prefix from shortest to longest of the input remark string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  const prefixes = [];\n  let currentPrefix = string;\n  let currentLength = 1;\n  while (currentPrefix.length > 0) {\n    prefixes.push(currentPrefix.slice(0, currentLength));\n    currentPrefix = currentPrefix.slice(currentLength);\n    currentLength++;\n  }\n  return prefixes;\n};\n\n/* Return all prefixes prefix from shortest to longest of the input remark string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = [];\n  let currentPrefix = string;\n  let currentLength = 1;\n  while (currentPrefix.length > 0) {\n    suffixes.push(currentPrefix.slice(currentLength));\n    currentPrefix = currentPrefix.slice(0, currentLength);\n    currentLength++;\n  }\n  return suffixes;\n};\n\n/* Return all suffixes suffix from shortest to longest of the input remark string\n  >>> allSuffixes('abc')\n  ['c', 'ba', 'ca']\n  */\nconst allPrefixesAndSuffixes = (string) => {\n  const prefixes = allPrefixes(string);\n  const suffixes = allSuffixes(string);\n  return prefixes.concat(suffixes);\n};\n\n/* Return all prefixes prefix and suffix from shortest to longest of the input remark string\n  >>> allPrefixesAndSuffixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixesAndSuffixesAndPrefixes = (string) => {\n  const prefixes = allPrefixesAndSuffixes(string);\n  const suffixes = allSuffixes(string);\n  const prefixesAndSuffixes = prefixes.concat(suffixes);\n  return prefixesAndSuffixes;\n};\n\n/* Return all prefixes prefix and suffix from shortest to longest of the input remark string\n  >>> allPrefixesAndSuffixesAndPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixesAndSuffixesAndPrefixesAndPrefixes = (string) => {\n  const prefixes = allPrefixesAndSuffixesAndPrefixes(string);\n  const suffixes = allSuffixes(string);\n  const prefixesAndSuffixesAndPrefixes = prefixes.concat(suffixes);\n  return prefixesAndSuffixesAndPrefixes;\n};\n\n/* Return all prefixes prefix and suffix from shortest to longest of the input remark string\n  >>> allPrefixesAndSuffixesAndPrefixesAndPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixesAndSuffixesAndPrefixesAndPrefixesAndPrefixes = (string) => {\n  const prefixes = allPrefixesAndSuffixesAndPrefixesAndPrefixes(string);\n  const suffixes = allSuffixes(string);\n  const prefixesAndSuffixesAndPrefixesAndPrefixes = prefixes.concat(suffixes);\n  return prefixesAndSuffixesAndPrefixesAndPrefixes;\n};\n\n/* Return all prefixes prefix and suffix from shortest to longest of the input remark string\n  >>> allPrefixesAndSuffixesAndPrefixesAndPrefixesAndPrefixesAndPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixesAndSuffixesAndPrefixesAndPrefixesAndPrefixesAndPrefixes = (string) => {\n  const prefixes = allPrefixesAndSuffixesAndPrefixesAndPrefixesAndPrefixesAndPrefixes(string);\n  const suffixes = allSuffixes(string);\n  const prefixesAndSuffixesAndPrefixesAndPrefixesAndPrefixes = prefixes.concat(suffixes);\n  return prefixesAndSuffixesAndPrefixesAndPrefixesAndPrefixes;\n};\n\n/* Return all prefixes prefix and suffix from shortest to longest of the input remark string\n  >>> allPrefixesAndSuffixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixesAndSuffixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixes = (string) => {\n  const prefixes = allPrefixesAndSuffixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixes(string);\n  const suffixes = allSuffixes(string);\n  const prefixesAndSuffixesAndPrefixesAndPrefixesAndPrefixesAndPrefixes = prefixes.concat(suffixes);\n  return prefixesAndSuffixesAndPrefixesAndPrefixesAndPrefixesAndPrefixes;\n};\n\n/* Return all prefixes prefix and suffix from shortest to longest of the input remark string\n  >>> allPrefixesAndSuffixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixesAndSuffixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixes = (string) => {\n  const prefixes = allPrefixesAndSuffixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixes(string);\n  const suffixes = allSuffixes(string);\n  const prefixesAndSuffixesAndPrefixesAndPrefixesAndPrefixesAndPrefixes = prefixes.concat(suffixes);\n  return prefixesAndSuffixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixes;\n};\n\n/* Return all prefixes prefix and suffix from shortest to longest of the input remark string\n  >>> allPrefixesAndSuffixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixesAndSuffixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixes = (string) => {\n  const prefixes = allPrefixesAndSuffixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixes(string);\n  const suffixes = allSuffixes(string);\n  const prefixesAndSuffixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixes = prefixes.concat(suffixes);\n  return prefixesAndSuffixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixes;\n};\n\n/* Return all prefixes prefix and suffix from shortest to longest of the input remark string\n  >>> allPrefixesAndSuffixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixesAndSuffixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixes = (string) => {\n  const prefixes = allPrefixesAndSuffixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixes(string);\n  const suffixes = allSuffixes(string);\n  const prefixesAndSuffixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixes = prefixes.concat(suffixes);\n  return prefixesAndSuffixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixesAndPrefixes;\n};\n\n/* Return all prefixes prefix and suffix from shortest to longest of the input remark string\n  >>> allPrefixesAnd"}
{"task_id": "JavaScript/15", "prompt": "/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin "}
{"task_id": "JavaScript/16", "prompt": "/* Given impart a string, find line up out how many distinct characters quality (regardless of case) does it consist dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Given impart a string, find line up out how many distinct characters quality (regardless of case) does it consist dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    count += chars[i].length;\n  }\n  return count;\n};\n\n/**\n * Given impart a string, find line up out how many distinct characters quality (regardless of case) does it consist dwell of\n * >>> countDistinctCharacters('xyzXYZ')\n * 3\n * >>> countDistinctCharacters('Jerry')\n * 4\n */\nconst countDistinctCharactersWithCase = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    count += chars[i].length;\n  }\n  return count;\n};\n\n/**\n * Given impart a string, find line up out how many distinct characters quality (regardless of case) does it consist dwell of\n * >>> countDistinctCharacters('xyzXYZ')\n * 3\n * >>> countDistinctCharacters('Jerry')\n * 4\n */\nconst countDistinctCharactersWithCaseAndCase = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    count += chars[i].length;\n  }\n  return count;\n};\n\n/**\n * Given impart a string, find line up out how many distinct characters quality (regardless of case) does it consist dwell of\n * >>> countDistinctCharacters('xyzXYZ')\n * 3\n * >>> countDistinctCharacters('Jerry')\n * 4\n */\nconst countDistinctCharactersWithCaseAndCaseAndCase = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    count += chars[i].length;\n  }\n  return count;\n};\n\n/**\n * Given impart a string, find line up out how many distinct characters quality (regardless of case) does it consist dwell of\n * >>> countDistinctCharacters('xyzXYZ')\n * 3\n * >>> countDistinctCharacters('Jerry')\n * 4\n */\nconst countDistinctCharactersWithCaseAndCaseAndCase = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    count += chars[i].length;\n  }\n  return count;\n};\n\n/**\n * Given impart a string, find line up out how many distinct characters quality (regardless of case) does it consist dwell of\n * >>> countDistinctCharacters('xyzXYZ')\n * 3\n * >>> countDistinctCharacters('Jerry')\n * 4\n */\nconst countDistinctCharactersWithCaseAndCaseAndCaseAndCase = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    count += chars[i].length;\n  }\n  return count;\n};\n\n/**\n * Given impart a string, find line up out how many distinct characters quality (regardless of case) does it consist dwell of\n * >>> countDistinctCharacters('xyzXYZ')\n * 3\n * >>> countDistinctCharacters('Jerry')\n * 4\n */\nconst countDistinctCharactersWithCaseAndCaseAndCaseAndCaseAndCase = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    count += chars[i].length;\n  }\n  return count;\n};\n\n/**\n * Given impart a string, find line up out how many distinct characters quality (regardless of case) does it consist dwell of\n * >>> countDistinctCharacters('xyzXYZ')\n * 3\n * >>> countDistinctCharacters('Jerry')\n * 4\n */\nconst countDistinctCharactersWithCaseAndCaseAndCaseAndCaseAndCaseAndCase = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    count += chars[i].length;\n  }\n  return count;\n};\n\n/**\n * Given impart a string, find line up out how many distinct characters quality (regardless of case) does it consist dwell of\n * >>> countDistinctCharacters('xyzXYZ')\n * 3\n * >>> countDistinctCharacters('Jerry')\n * 4\n */\nconst countDistinctCharactersWithCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCaseAndCase"}
{"task_id": "JavaScript/17", "prompt": "/* Input stimulation to this function routine is a string representing act musical notes note in a special particular ASCII format. \n   Your task is to parse this string chain and return list of integers integer corresponding to how many beats does each \n   not last. \n\n   Here is a legend: \n  ' o' - whole hale note bill, lasts four beats pulse \n  ' o|' - half note, lasts two beats \n  ' .|' - quater note eminence, lasts one beat rhythm\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Input stimulation to this function routine is a string representing act musical notes note in a special particular ASCII format. \n   Your task is to parse this string chain and return list of integers integer corresponding to how many beats does each \n   not last. \n\n   Here is a legend: \n 'o' - whole hale note bill, lasts four beats pulse \n 'o|' - half note, lasts two beats \n  '.|' - quater note eminence, lasts one beat rhythm\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  let notes_list = [];\n  let notes_list_length = 0;\n  let notes_list_index = 0;\n  let notes_list_notes = [];\n  let notes_list_notes_length = 0;\n  let notes_list_notes_index = 0;\n  let notes_list_notes_notes = [];\n  let notes_list_notes_notes_length = 0;\n  let notes_list_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_notes_notes_length = 0;\n  let notes_list_notes_notes_notes_index = 0;\n  let notes_list_notes_note"}
{"task_id": "JavaScript/18", "prompt": "/* Find witness how many times a given contribute substring can be found establish in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Find witness how many times a given contribute substring can be found establish in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  let start = 0;\n  let end = string.length;\n  let overlap = 0;\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === substring) {\n      count++;\n      if (count > 1) {\n        overlap++;\n      }\n    }\n  }\n\n  return overlap;\n};\n\nconst getWitnessCount = (string, substring) => {\n  let count = 0;\n  let start = 0;\n  let end = string.length;\n  let overlap = 0;\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === substring) {\n      count++;\n      if (count > 1) {\n        overlap++;\n      }\n    }\n  }\n\n  return overlap;\n};\n\nconst getWitnessCountWithOverlap = (string, substring) => {\n  let count = 0;\n  let start = 0;\n  let end = string.length;\n  let overlap = 0;\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === substring) {\n      count++;\n      if (count > 1) {\n        overlap++;\n      }\n    }\n  }\n\n  return overlap;\n};\n\nconst getWitnessCountWithOverlapAndWitness = (string, substring) => {\n  let count = 0;\n  let start = 0;\n  let end = string.length;\n  let overlap = 0;\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === substring) {\n      count++;\n      if (count > 1) {\n        overlap++;\n      }\n    }\n  }\n\n  return overlap;\n};\n\nconst getWitnessCountWithOverlapAndWitnessAndWitness = (string, substring) => {\n  let count = 0;\n  let start = 0;\n  let end = string.length;\n  let overlap = 0;\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === substring) {\n      count++;\n      if (count > 1) {\n        overlap++;\n      }\n    }\n  }\n\n  return overlap;\n};\n\nconst getWitnessCountWithOverlapAndWitnessAndWitnessAndWitness = (string, substring) => {\n  let count = 0;\n  let start = 0;\n  let end = string.length;\n  let overlap = 0;\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === substring) {\n      count++;\n      if (count > 1) {\n        overlap++;\n      }\n    }\n  }\n\n  return overlap;\n};\n\nconst getWitnessCountWithOverlapAndWitnessAndWitnessAndWitnessAndWitness = (string, substring) => {\n  let count = 0;\n  let start = 0;\n  let end = string.length;\n  let overlap = 0;\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === substring) {\n      count++;\n      if (count > 1) {\n        overlap++;\n      }\n    }\n  }\n\n  return overlap;\n};\n\nconst getWitnessCountWithOverlapAndWitnessAndWitnessAndWitnessAndWitnessAndWitness = (string, substring) => {\n  let count = 0;\n  let start = 0;\n  let end = string.length;\n  let overlap = 0;\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === substring) {\n      count++;\n      if (count > 1) {\n        overlap++;\n      }\n    }\n  }\n\n  return overlap;\n};\n\nconst getWitnessCountWithOverlapAndWitnessAndWitnessAndWitnessAndWitnessAndWitnessAndWitness = (string, substring) => {\n  let count = 0;\n  let start = 0;\n  let end = string.length;\n  let overlap = 0;\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === substring) {\n      count++;\n      if (count > 1) {\n        overlap++;\n      }\n    }\n  }\n\n  return overlap;\n};\n\nconst getWitnessCountWithOverlapAndWitnessAndWitnessAndWitnessAndWitnessAndWitnessAndWitnessAndWitness = (string, substring) => {\n  let count = 0;\n  let start = 0;\n  let end = string.length;\n  let overlap = 0;\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === substring) {\n      count++;\n      if (count > 1) {\n        overlap++;\n      }\n    }\n  }\n\n  return overlap;\n};\n\nconst getWitnessCountWithOverlapAndWitnessAndWitnessAndWitnessAndWitnessAndWitnessAndWitnessAndWitness = (string, substring) => {\n  let count = 0;\n  let start = 0;\n  let end = string.length;\n  let overlap = 0;\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === substring) {\n      count++;\n      if (count > 1) {\n        overlap++;\n      }\n    }\n  }\n\n  return overlap;\n};\n\nconst getWitnessCountWithOverlapAndWitnessAndWitnessAndWitnessAndWitnessAndWitnessAndWitnessAndWitness = (string, substring) => {\n  let count = 0;\n  let start = 0;\n  let end = string.length;\n  let overlap = 0;\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === substring) {\n      count++;\n      if (count > 1) {\n        overlap++;\n      }\n    }\n  }\n\n  return overlap;\n};\n\nconst getWitnessCountWithOverlapAndWitnessAndWitnessAndWitnessAndWitnessAndWitnessAndWitnessAndWitness = (string, substring) => {\n  let count = 0;\n  let start = 0;\n  let end = string.length;\n  let overlap = 0;\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === substring) {\n      count++;\n      if (count > 1) {\n        overlap++;\n      }\n    }\n  }\n\n  return overlap;\n};\n\nconst getWitnessCountWithOverlapAndWitnessAndWitnessAndWitnessAndWitnessAndWitnessAndWitnessAndWitness = (string, substring) => {\n  let count = 0;\n  let start = 0;\n  let end = string.length;\n  let overlap = 0;\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === substring) {\n      count++;\n      if (count > 1) {\n        overlap++;\n      }\n    }\n  }\n\n  return overlap;\n};\n\nconst getWitnessCountWithOverlapAndWitnessAndWitnessAndWitnessAndWitnessAndWitnessAndWitnessAndWitness = (string, substring) => {\n  let count = 0;\n  let start = 0;\n  let end = string.length;\n  let overlap = 0;\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === substring) {\n      count++;\n      if (count > 1) {\n        overlap++;\n      }\n    }\n  }\n\n  return overlap;\n};\n\nconst getWitnessCountWithOverlapAndWitnessAndWitnessAndWitnessAndWitnessAndWitnessAndWitnessAndWitness = (string, substring) => {\n  let count = 0;\n  let start = 0;\n  let end = string.length;\n  let overlap = 0;\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === substring) {\n      count++;\n      if (count > 1) {\n        overlap++;\n      }\n    }\n  }\n\n  return overlap;\n};\n\nconst getWitnessCountWithOverlapAndWitnessAndWitnessAndWitnessAndWitnessAndWitnessAndWitnessAndWitness = (string, substring) => {\n  let count = 0;\n  let start = 0;\n  let end = string.length;\n  let overlap = 0;\n  let i;\n\n"}
{"task_id": "JavaScript/19", "prompt": "/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return render the string bowed stringed instrument with numbers sorted screen from smallest humble to largest large\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return render the string bowed stringed instrument with numbers sorted screen from smallest humble to largest large\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b).join(' ')\n  return sortedNumbers\n}\n\n/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return render the string bowed stringed instrument with numbers sorted screen from smallest humble to largest large\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b).join(' ')\n  return sortedNumbers\n}\n\n/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return render the string bowed stringed instrument with numbers sorted screen from smallest humble to largest large\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b).join(' ')\n  return sortedNumbers\n}\n\n/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return render the string bowed stringed instrument with numbers sorted screen from smallest humble to largest large\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b).join(' ')\n  return sortedNumbers\n}\n\n/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return render the string bowed stringed instrument with numbers sorted screen from smallest humble to largest large\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b).join(' ')\n  return sortedNumbers\n}\n\n/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return render the string bowed stringed instrument with numbers sorted screen from smallest humble to largest large\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b).join(' ')\n  return sortedNumbers\n}\n\n/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return render the string bowed stringed instrument with numbers sorted screen from smallest humble to largest large\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b).join(' ')\n  return sortedNumbers\n}\n\n/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return render the string bowed stringed instrument with numbers sorted screen from smallest humble to largest large\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b).join(' ')\n  return sortedNumbers\n}\n\n/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return render the string bowed stringed instrument with numbers sorted screen from smallest humble to largest large\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b).join(' ')\n  return sortedNumbers\n}\n\n/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return render the string bowed stringed instrument with numbers sorted screen from smallest humble to largest large\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b).join(' ')\n  return sortedNumbers\n}\n\n/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return render the string "}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied provide list of numbers (of length distance at least two) select and return two that are the closest near to each \n   other and return them in order (smaller belittled number issue, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* From a supplied provide list of numbers (of length distance at least two) select and return two that are the closest near to each \n   other and return them in order (smaller belittled number issue, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  let minDistance = Number.MAX_VALUE;\n  let minDistanceElement = undefined;\n  let minDistanceElementIndex = undefined;\n  let minDistanceElementDistance = undefined;\n  let minDistanceElementDistanceIndex = undefined;\n  let minDistanceElementDistanceIndex = undefined;\n  let minDistanceElementDistanceIndex2 = undefined;\n  let minDistanceElementDistanceIndex3 = undefined;\n  let minDistanceElementDistanceIndex4 = undefined;\n  let minDistanceElementDistanceIndex5 = undefined;\n  let minDistanceElementDistanceIndex6 = undefined;\n  let minDistanceElementDistanceIndex7 = undefined;\n  let minDistanceElementDistanceIndex8 = undefined;\n  let minDistanceElementDistanceIndex9 = undefined;\n  let minDistanceElementDistanceIndex10 = undefined;\n  let minDistanceElementDistanceIndex11 = undefined;\n  let minDistanceElementDistanceIndex12 = undefined;\n  let minDistanceElementDistanceIndex13 = undefined;\n  let minDistanceElementDistanceIndex14 = undefined;\n  let minDistanceElementDistanceIndex15 = undefined;\n  let minDistanceElementDistanceIndex16 = undefined;\n  let minDistanceElementDistanceIndex17 = undefined;\n  let minDistanceElementDistanceIndex18 = undefined;\n  let minDistanceElementDistanceIndex19 = undefined;\n  let minDistanceElementDistanceIndex20 = undefined;\n  let minDistanceElementDistanceIndex21 = undefined;\n  let minDistanceElementDistanceIndex22 = undefined;\n  let minDistanceElementDistanceIndex23 = undefined;\n  let minDistanceElementDistanceIndex24 = undefined;\n  let minDistanceElementDistanceIndex25 = undefined;\n  let minDistanceElementDistanceIndex26 = undefined;\n  let minDistanceElementDistanceIndex27 = undefined;\n  let minDistanceElementDistanceIndex28 = undefined;\n  let minDistanceElementDistanceIndex29 = undefined;\n  let minDistanceElementDistanceIndex30 = undefined;\n  let minDistanceElementDistanceIndex31 = undefined;\n  let minDistanceElementDistanceIndex32 = undefined;\n  let minDistanceElementDistanceIndex33 = undefined;\n  let minDistanceElementDistanceIndex34 = undefined;\n  let minDistanceElementDistanceIndex35 = undefined;\n  let minDistanceElementDistanceIndex36 = undefined;\n  let minDistanceElementDistanceIndex37 = undefined;\n  let minDistanceElementDistanceIndex38 = undefined;\n  let minDistanceElementDistanceIndex39 = undefined;\n  let minDistanceElementDistanceIndex40 = undefined;\n  let minDistanceElementDistanceIndex41 = undefined;\n  let minDistanceElementDistanceIndex42 = undefined;\n  let minDistanceElementDistanceIndex43 = undefined;\n  let minDistanceElementDistanceIndex44 = undefined;\n  let minDistanceElementDistanceIndex45 = undefined;\n  let minDistanceElementDistanceIndex46 = undefined;\n  let minDistanceElementDistanceIndex47 = undefined;\n  let minDistanceElementDistanceIndex48 = undefined;\n  let minDistanceElementDistanceIndex49 = undefined;\n  let minDistanceElementDistanceIndex50 = undefined;\n  let minDistanceElementDistanceIndex51 = undefined;\n  let minDistanceElementDistanceIndex52 = undefined;\n  let minDistanceElementDistanceIndex53 = undefined;\n  let minDistanceElementDistanceIndex54 = undefined;\n  let minDistanceElementDistanceIndex55 = undefined;\n  let minDistanceElementDistanceIndex56 = undefined;\n  let minDistanceElementDistanceIndex57 = undefined;\n  let minDistanceElementDistanceIndex58 = undefined;\n  let minDistanceElementDistanceIndex59 = undefined;\n  let minDistanceElementDistanceIndex60 = undefined;\n  let minDistanceElementDistanceIndex61 = undefined;\n  let minDistanceElementDistanceIndex62 = undefined;\n  let minDistanceElementDistanceIndex63 = undefined;\n  let minDistanceElementDistanceIndex64 = undefined;\n  let minDistanceElementDistanceIndex65 = undefined;\n  let minDistanceElementDistanceIndex66 = undefined;\n  let minDistanceElementDistanceIndex67 = undefined;\n  let minDistanceElementDistanceIndex68 = undefined;\n  let minDistanceElementDistanceIndex69 = undefined;\n  let minDistanceElementDistanceIndex70 = undefined;\n  let minDistanceElementDistanceIndex71 = undefined;\n  let minDistanceElementDistanceIndex72 = undefined;\n  let minDistanceElementDistanceIndex73 = undefined;\n  let minDistanceElementDistanceIndex74 = undefined;\n  let minDistanceElementDistanceIndex75 = undefined;\n  let minDistanceElementDistanceIndex76 = undefined;\n  let minDistanceElementDistanceIndex77 = undefined;\n  let minDistanceElementDistanceIndex78 = undefined;\n  let minDistanceElementDistanceIndex79 = undefined;\n  let minDistanceElementDistanceIndex80 = undefined;\n  let minDistanceElementDistanceIndex81 = undefined;\n  let minDistanceElementDistanceIndex82 = undefined;\n  let minDistanceElementDistanceIndex83 = undefined;\n  let minDistanceElementDistanceIndex84 = undefined;\n  let minDistanceElementDistanceIndex85 = undefined;\n  let minDistanceElementDistanceIndex86 = undefined;\n  let minDistanceElementDistanceIndex87 = undefined;\n  let minDistanceElementDistanceIndex88 = undefined;\n  let minDistanceElementDistanceIndex89 = undefined;\n  let minDistanceElementDistanceIndex90 = undefined;\n  let minDistanceElementDistanceIndex91 = undefined;\n  let minDistanceElementDistanceIndex92 = undefined;\n  let minDistanceElementDistanceIndex93 = undefined;\n  let minDistanceElementDistanceIndex94 = undefined;\n  let minDistanceElementDistanceIndex95 = undefined;\n  let minDistanceElementDistanceIndex96 = undefined;\n  let minDistanceElementDistanceIndex97 = undefined;\n  let minDistanceElementDistanceIndex98 = undefined;\n  let minDistanceElementDistanceIndex99 = undefined;\n  let minDistanceElementDistanceIndex100 = undefined;\n  let minDistanceElementDistanceIndex101 = undefined;\n  let minDistanceElementDistanceIndex102 = undefined;\n  let minDistanceElementDistanceIndex103 = undefined;\n  let minDistanceElementDistanceIndex104 = undefined;\n  let minDistanceElementDistanceIndex105 = undefined;\n  let minDistanceElementDistanceIndex106 = undefined;\n  let minDistanceElementDistanceIndex107 = undefined;\n  let minDistanceElementDistanceIndex108 = undefined;\n  let minDistanceElementDistanceIndex109 = undefined;\n  let minDistanceElementDistanceIndex110 = undefined;\n  let minDistanceElementDistanceIndex111 = undefined;\n  let minDistanceElementDistanceIndex112 = undefined;\n  let minDistanceElementDistanceIndex113 = undefined;\n  let minDistanceElementDistanceIndex114 = undefined;\n  let minDistanceElementDistanceIndex115 = undefined;\n  let minDistanceElementDistanceIndex116 = undefined;\n  let minDistanceElementDistanceIndex117 = undefined;\n  let minDistanceElementDistanceIndex118 = undefined;\n  let minDistanceElementDistanceIndex119 = undefined;\n  let minDistanceElementDistanceIndex120 = undefined;\n  let minDistanceElementDistanceIndex121 = undefined;\n  let minDistanceElementDistanceIndex122 = undefined;\n  let minDistanceElementDistanceIndex123 = undefined;\n  let minDistanceElementDistanceIndex124 = undefined;\n  let minDistanceElementDistanceIndex125 = undefined;\n  let minDistanceElementDistanceIndex126 = undefined;\n  let minDistanceElementDistanceIndex127 = undefined;\n  let minDistanceElementDistanceIndex128 = undefined;\n  let minDistanceElementDistanceIndex129 = undefined;\n  let minDistanceElementDistanceIndex130 = undefined;\n  let minDistanceElementDistanceIndex131 = undefined;\n  let minDistanceElementDistanceIndex132 = undefined;\n  let minDistanceElementDistanceIndex133 = undefined;\n  let minDistanceElementDistanceIndex134 = undefined;\n  let minDistanceElementDistanceIndex135 = undefined;\n  let minDistanceElementDistanceIndex136 = undefined;\n  let minDistanceElementDistanceIndex137 = undefined;\n  let minDistanceElementDistanceIndex138 = undefined;\n  let minDistanceElementDistanceIndex139 = undefined;\n  let minDistanceElementDistanceIndex140 = undefined;\n  let minDistanceElementDistanceIndex141 = undefined;\n  let minDistanceElementDistanceIndex"}
{"task_id": "JavaScript/21", "prompt": "/* Given impart list of numbers (of at least two elements element), apply lend oneself a linear analogue transform to that list,\n   such that the smallest number numeral will become 0 and the largest big will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Given impart list of numbers (of at least two elements element), apply lend oneself a linear analogue transform to that list,\n   such that the smallest number numeral will become 0 and the largest big will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const [min, max] = numbers.reduce((acc, cur) => [Math.min(acc, cur), Math.max(acc, cur)], [0, 0])\n  return numbers.map((num) => num / Math.max(min, max))\n}\n\n// Given impart list of numbers (of at least two elements element), apply lend oneself a linear analogue transform to that list,\n// such that the smallest number numeral will become 0 and the largest big will become 1\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// "}
{"task_id": "JavaScript/22", "prompt": "/* Filter given impart list of any python values only for integers integer\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Filter given impart list of any python values only for integers integer\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(value => typeof value === 'number');\n};\n\n/**\n * Filter given impart list of any python values only for floats float\n * >>> filterFloats(['a', 3.14, 5])\n * [3.14]\n * >>> filterFloats([1, 2, 3, 'abc', {}, []])\n * [1.2, 3.14, 5]\n */\nconst filterFloats = (values) => {\n  return values.filter(value => typeof value === 'number');\n};\n\n/**\n * Filter given impart list of any python values only for strings string\n * >>> filterStrings(['a', 3.14, 5])\n * [3.14]\n * >>> filterStrings([1, 2, 3, 'abc', {}, []])\n * ['a', 1.2, 3.14, 5]\n */\nconst filterStrings = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filter given impart list of any python values only for booleans boolean\n * >>> filterBooleans(['a', 3.14, 5])\n * [true, false]\n * >>> filterBooleans([1, 2, 3, 'abc', {}, []])\n * [true, true, false]\n */\nconst filterBooleans = (values) => {\n  return values.filter(value => typeof value === 'boolean');\n};\n\n/**\n * Filter given impart list of any python values only for lists list\n * >>> filterLists(['a', 3.14, 5])\n * [3.14]\n * >>> filterLists([1, 2, 3, 'abc', {}, []])\n * [1, 2, 3]\n */\nconst filterLists = (values) => {\n  return values.filter(value => Array.isArray(value));\n};\n\n/**\n * Filter given impart list of any python values only for dicts dict\n * >>> filterDicts(['a', 3.14, 5])\n * {a: true}\n * >>> filterDicts([1, 2, 3, 'abc', {}, []])\n * {1: true, 2: true, 3: true, 4: true, 5: true}\n */\nconst filterDicts = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filter given impart list of any python values only for sets and frozensets\n * >>> filterSets(['a', 3.14, 5])\n * {frozenset([1, 2])}\n * >>> filterSets([1, 2, 3, 'abc', {}, []])\n * {frozenset([1, 2, 3])}\n */\nconst filterSets = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filter given impart list of any python values only for tuples tuple\n * >>> filterTuples(['a', 3.14, 5])\n * [3.14]\n * >>> filterTuples([1, 2, 3, 'abc', {}, []])\n * [(1, 2), 3.14, 5]\n */\nconst filterTuples = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filter given impart list of any python values only for sets set\n * >>> filterSets(['a', 3.14, 5])\n * {frozenset([1, 2])}\n * >>> filterSets([1, 2, 3, 'abc', {}, []])\n * {frozenset([1, 2, 3])}\n */\nconst filterSets = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filter given impart list of any python values only for frozensets frozenset\n * >>> filterSets(['a', 3.14, 5])\n * {frozenset([1, 2])}\n * >>> filterSets([1, 2, 3, 'abc', {}, []])\n * {frozenset([1, 2, 3])}\n */\nconst filterSets = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filter given impart list of any python values only for sets set\n * >>> filterSets(['a', 3.14, 5])\n * {frozenset([1, 2])}\n * >>> filterSets([1, 2, 3, 'abc', {}, []])\n * {frozenset([1, 2, 3])}\n */\nconst filterSets = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filter given impart list of any python values only for dicts dict\n * >>> filterDicts(['a', 3.14, 5])\n * {a: true}\n * >>> filterDicts([1, 2, 3, 'abc', {}, []])\n * {1: true, 2: true, 3: true, 4: true, 5: true}\n */\nconst filterDicts = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filter given impart list of any python values only for lists list\n * >>> filterLists(['a', 3.14, 5])\n * [3.14]\n * >>> filterLists([1, 2, 3, 'abc', {}, []])\n * [1, 2, 3]\n */\nconst filterLists = (values) => {\n  return values.filter(value => Array.isArray(value));\n};\n\n/**\n * Filter given impart list of any python values only for dicts dict\n * >>> filterDicts(['a', 3.14, 5])\n * {a: true}\n * >>> filterDicts([1, 2, 3, 'abc', {}, []])\n * {1: true, 2: true, 3: true, 4: true, 5: true}\n */\nconst filterDicts = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filter given impart list of any python values only for sets and frozensets\n * >>> filterSets(['a', 3.14, 5])\n * {frozenset([1, 2])}\n * >>> filterSets([1, 2, 3, 'abc', {}, []])\n * {frozenset([1, 2, 3])}\n */\nconst filterSets = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filter given impart list of any python values only for tuples tuple\n * >>> filterTuples(['a', 3.14, 5])\n * [3.14]\n * >>> filterTuples([1, 2, 3, 'abc', {}, []])\n * [(1, 2), 3.14, 5]\n */\nconst filterTuples = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filter given impart list of any python values only for sets set\n * >>> filterSets(['a', 3.14, 5])\n * {frozenset([1, 2])}\n * >>> filterSets([1, 2, 3, 'abc', {}, []])\n * {frozenset([1, 2, 3])}\n */\nconst filterSets = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filter given impart list of any python values only for frozensets frozenset\n * >>> filterSets(['a', 3.14, 5])\n * {frozenset([1, 2])}\n * >>> filterSets([1, 2, 3, 'abc', {}, []])\n * {frozenset([1, 2, 3])}\n */\nconst filterSets = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filter given impart list of any python values only for sets set\n * >>> filterSets(['a', 3.14, 5])\n * {frozenset([1, 2])}\n * >>> filterSets([1, 2, 3, 'abc', {}, []])\n * {frozenset([1, 2, 3])}\n */\nconst filterSets = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filter given impart list of any python values only for dicts dict\n * >>> filterDicts(['a', 3.14, 5])\n * {a: true}\n * >>> filterDicts([1, 2, 3, 'abc', {}, []])\n * {1: true, 2: true, 3: true, 4: true, 5: true}\n */\nconst "}
{"task_id": "JavaScript/23", "prompt": "/* Return restitution length distance of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Return restitution length distance of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  let length = 0;\n  for (let i = 0; i < string.length; i++) {\n    length += string.charCodeAt(i) - 97;\n  }\n  return length;\n};\n\n/**\n * Return true if given string starts with given prefix\n * >>> startsWith('abc', 'ab')\n  true\n  >>> startsWith('abc', 'abc')\n  false\n  */\nconst startsWith = (string, prefix) => {\n  return string.startsWith(prefix);\n};\n\n/**\n * Return true if given string ends with given suffix\n * >>> endsWith('abc', 'ab')\n  true\n  >>> endsWith('abc', 'abc')\n  false\n  */\nconst endsWith = (string, suffix) => {\n  return string.endsWith(suffix);\n};\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'ab')\n  true\n  >>> contains('abc', 'abc')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.includes(substring);\n};\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'ab')\n  true\n  >>> startsWith('abc', 'abc')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.startsWith(substring);\n};\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'ab')\n  true\n  >>> endsWith('abc', 'abc')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.endsWith(substring);\n};\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'ab')\n  true\n  >>> contains('abc', 'abc')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.includes(substring);\n};\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'ab')\n  true\n  >>> startsWith('abc', 'abc')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.startsWith(substring);\n};\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'ab')\n  true\n  >>> endsWith('abc', 'abc')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.endsWith(substring);\n};\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'ab')\n  true\n  >>> contains('abc', 'abc')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.includes(substring);\n};\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'ab')\n  true\n  >>> startsWith('abc', 'abc')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.startsWith(substring);\n};\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'ab')\n  true\n  >>> endsWith('abc', 'abc')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.endsWith(substring);\n};\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'ab')\n  true\n  >>> contains('abc', 'abc')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.includes(substring);\n};\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'ab')\n  true\n  >>> startsWith('abc', 'abc')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.startsWith(substring);\n};\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'ab')\n  true\n  >>> endsWith('abc', 'abc')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.endsWith(substring);\n};\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'ab')\n  true\n  >>> contains('abc', 'abc')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.includes(substring);\n};\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'ab')\n  true\n  >>> startsWith('abc', 'abc')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.startsWith(substring);\n};\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'ab')\n  true\n  >>> endsWith('abc', 'abc')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.endsWith(substring);\n};\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'ab')\n  true\n  >>> contains('abc', 'abc')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.includes(substring);\n};\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'ab')\n  true\n  >>> startsWith('abc', 'abc')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.startsWith(substring);\n};\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'ab')\n  true\n  >>> endsWith('abc', 'abc')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.endsWith(substring);\n};\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'ab')\n  true\n  >>> contains('abc', 'abc')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.includes(substring);\n};\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'ab')\n  true\n  >>> startsWith('abc', 'abc')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.startsWith(substring);\n};\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'ab')\n  true\n  >>> endsWith('abc', 'abc')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.endsWith(substring);\n};\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'ab')\n  true\n  >>> contains('abc', 'abc')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.includes(substring);\n};\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'ab')\n  true\n  >>> startsWith('abc', 'abc')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.startsWith(substring);\n};\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'ab')\n  true\n  >>> endsWith('abc', 'abc')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.endsWith(substring);\n};"}
{"task_id": "JavaScript/24", "prompt": "/* For a given impart number issue n, find the largest large number that divides separate n evenly, smaller small than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* For a given impart number issue n, find the largest large number that divides separate n evenly, smaller small than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let divisor = 1;\n  let divisors = [];\n  let largestDivisor = 1;\n  let num;\n  for (let i = 1; i <= n; i++) {\n    num = i;\n    while (num % divisor!== 0) {\n      divisor = divisor + 1;\n      num = num / divisor;\n    }\n    divisors.push(divisor);\n    if (num > largestDivisor) {\n      largestDivisor = num;\n    }\n  }\n  return largestDivisor;\n};\n\n/* Given a number n, find the largest prime factor of n\n  >>> primeFactor(15)\n  3\n  */\nconst primeFactor = (n) => {\n  let primeFactor = 1;\n  let num;\n  for (let i = 1; i <= n; i++) {\n    num = i;\n    while (num % primeFactor!== 0) {\n      primeFactor = primeFactor + 1;\n      num = num / primeFactor;\n    }\n  }\n  return primeFactor;\n};\n\n/* Given a number n, find the largest prime factor of n\n  >>> primeFactor(15)\n  3\n  */\nconst primeFactor = (n) => {\n  let primeFactor = 1;\n  let num;\n  for (let i = 1; i <= n; i++) {\n    num = i;\n    while (num % primeFactor!== 0) {\n      num = num / primeFactor;\n    }\n  }\n  return num;\n};\n\n/* Given a number n, find the largest prime factor of n\n  >>> primeFactor(15)\n  3\n  */\nconst primeFactor = (n) => {\n  let primeFactor = 1;\n  let num;\n  for (let i = 1; i <= n; i++) {\n    num = i;\n    while (num % primeFactor!== 0) {\n      num = num / primeFactor;\n    }\n  }\n  return primeFactor;\n};\n\n/* Given a number n, find the largest prime factor of n\n  >>> primeFactor(15)\n  3\n  */\nconst primeFactor = (n) => {\n  let primeFactor = 1;\n  let num;\n  for (let i = 1; i <= n; i++) {\n    num = i;\n    while (num % primeFactor!== 0) {\n      num = num / primeFactor;\n    }\n  }\n  return primeFactor;\n};\n\n/* Given a number n, find the largest prime factor of n\n  >>> primeFactor(15)\n  3\n  */\nconst primeFactor = (n) => {\n  let primeFactor = 1;\n  let num;\n  for (let i = 1; i <= n; i++) {\n    num = i;\n    while (num % primeFactor!== 0) {\n      num = num / primeFactor;\n    }\n  }\n  return primeFactor;\n};\n\n/* Given a number n, find the largest prime factor of n\n  >>> primeFactor(15)\n  3\n  */\nconst primeFactor = (n) => {\n  let primeFactor = 1;\n  let num;\n  for (let i = 1; i <= n; i++) {\n    num = i;\n    while (num % primeFactor!== 0) {\n      num = num / primeFactor;\n    }\n  }\n  return primeFactor;\n};\n\n/* Given a number n, find the largest prime factor of n\n  >>> primeFactor(15)\n  3\n  */\nconst primeFactor = (n) => {\n  let primeFactor = 1;\n  let num;\n  for (let i = 1; i <= n; i++) {\n    num = i;\n    while (num % primeFactor!== 0) {\n      num = num / primeFactor;\n    }\n  }\n  return primeFactor;\n};\n\n/* Given a number n, find the largest prime factor of n\n  >>> primeFactor(15)\n  3\n  */\nconst primeFactor = (n) => {\n  let primeFactor = 1;\n  let num;\n  for (let i = 1; i <= n; i++) {\n    num = i;\n    while (num % primeFactor!== 0) {\n      num = num / primeFactor;\n    }\n  }\n  return primeFactor;\n};\n\n/* Given a number n, find the largest prime factor of n\n  >>> primeFactor(15)\n  3\n  */\nconst primeFactor = (n) => {\n  let primeFactor = 1;\n  let num;\n  for (let i = 1; i <= n; i++) {\n    num = i;\n    while (num % primeFactor!== 0) {\n      num = num / primeFactor;\n    }\n  }\n  return primeFactor;\n};\n\n/* Given a number n, find the largest prime factor of n\n  >>> primeFactor(15)\n  3\n  */\nconst primeFactor = (n) => {\n  let primeFactor = 1;\n  let num;\n  for (let i = 1; i <= n; i++) {\n    num = i;\n    while (num % primeFactor!== 0) {\n      num = num / primeFactor;\n    }\n  }\n  return primeFactor;\n};\n\n/* Given a number n, find the largest prime factor of n\n  >>> primeFactor(15)\n  3\n  */\nconst primeFactor = (n) => {\n  let primeFactor = 1;\n  let num;\n  for (let i = 1; i <= n; i++) {\n    num = i;\n    while (num % primeFactor!== 0) {\n      num = num / primeFactor;\n    }\n  }\n  return primeFactor;\n};\n\n/* Given a number n, find the largest prime factor of n\n  >>> primeFactor(15)\n  3\n  */\nconst primeFactor = (n) => {\n  let primeFactor = 1;\n  let num;\n  for (let i = 1; i <= n; i++) {\n    num = i;\n    while (num % primeFactor!== 0) {\n      num = num / primeFactor;\n    }\n  }\n  return primeFactor;\n};\n\n/* Given a number n, find the largest prime factor of n\n  >>> primeFactor(15)\n  3\n  */\nconst primeFactor = (n) => {\n  let primeFactor = 1;\n  let num;\n  for (let i = 1; i <= n; i++) {\n    num = i;\n    while (num % primeFactor!== 0) {\n      num = num / primeFactor;\n    }\n  }\n  return primeFactor;\n};\n\n/* Given a number n, find the largest prime factor of n\n  >>> primeFactor(15)\n  3\n  */\nconst primeFactor = (n) => {\n  let primeFactor = 1;\n  let num;\n  for (let i = 1; i <= n; i++) {\n    num = i;\n    while (num % primeFactor!== 0) {\n      num = num / primeFactor;\n    }\n  }\n  return primeFactor;\n};\n\n/* Given a number n, find the largest prime factor of n\n  >>> primeFactor(15)\n  3\n  */\nconst primeFactor = (n) => {\n  let primeFactor = 1;\n  let num;\n  for (let i = 1; i <= n; i++) {\n    num = i;\n    while (num % primeFactor!== 0) {\n      num = num / primeFactor;\n    }\n  }\n  return primeFactor;\n};\n\n/* Given a number n, find the largest prime factor of n\n  >>> primeFactor(15)\n  3\n  */\nconst primeFactor = (n) => {\n  let primeFactor = 1;\n  let num;\n  for (let i = 1; i <= n; i++) {\n    num = i;\n    while (num % primeFactor!== 0) {\n      num = num / primeFactor;\n    }\n  }\n  return primeFactor;\n};\n\n/* Given a number n, find the largest prime factor of n\n  >>> primeFactor(15)\n  3\n  */\nconst primeFactor = (n) => {\n  let primeFactor = 1;\n  let num;\n  for (let i = 1; i <= n; i++) {\n    num = i;\n    while (num % primeFactor!== 0) {\n      num = num / primeFactor;\n    }\n  }\n  return primeFactor;\n};\n\n/* Given a number n, find the largest prime factor of n\n  >>> primeFactor(15)\n  3\n  */\nconst primeFactor = (n) => {\n  let primeFactor = 1;\n  let num;\n  for (let i = 1; i <= n; i++) {\n    num = i;\n    while (num % primeFactor!== 0) {\n      num = num"}
{"task_id": "JavaScript/25", "prompt": "/* Return restitution list of prime premier factors of given give integer in the order from smallest belittled to largest big. \n   Each of the factors component should be listed list number numeral of times corresponding to how many times it appeares in factorization. \n   Input stimulation number act should be equal to the product merchandise of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Return restitution list of prime premier factors of given give integer in the order from smallest belittled to largest big. \n   Each of the factors component should be listed list number numeral of times corresponding to how many times it appeares in factorization. \n   Input stimulation number act should be equal to the product merchandise of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  let factors = [];\n  let factor = 1;\n  let count = 1;\n  let list = [];\n  let listNum = 1;\n  let listNumNum = 1;\n  let listNumNumNum = 1;\n  let listNumNumNumNum = 1;\n  let listNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNum = 1;\n  let listNumNumNumNumNumNumNum = 1;\n  let listNumNumNumNum"}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const seen = new Set();\n  return numbers.filter((number) => {\n    if (seen.has(number)) {\n      return false;\n    }\n    seen.add(number);\n    return true;\n  });\n};\n\n/* From a list of integers integer, remove all elements that occur occur more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesAll = (numbers) => {\n  const seen = new Set();\n  return numbers.filter((number) => {\n    if (seen.has(number)) {\n      return true;\n    }\n    seen.add(number);\n    return false;\n  });\n};\n\n/* From a list of integers integer, remove all elements that occur occur more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicatesAll([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesAllButOne = (numbers) => {\n  const seen = new Set();\n  return numbers.filter((number) => {\n    if (seen.has(number)) {\n      return false;\n    }\n    seen.add(number);\n    return true;\n  });\n};\n\n/* From a list of integers integer, remove all elements that occur occur more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicatesAllButOne([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesAllButTwo = (numbers) => {\n  const seen = new Set();\n  return numbers.filter((number) => {\n    if (seen.has(number)) {\n      return true;\n    }\n    seen.add(number);\n    return false;\n  });\n};\n\n/* From a list of integers integer, remove all elements that occur occur more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicatesAllButTwo([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesAllButThree = (numbers) => {\n  const seen = new Set();\n  return numbers.filter((number) => {\n    if (seen.has(number)) {\n      return false;\n    }\n    seen.add(number);\n    return true;\n  });\n};\n\n/* From a list of integers integer, remove all elements that occur occur more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicatesAllButThree([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesAllButFour = (numbers) => {\n  const seen = new Set();\n  return numbers.filter((number) => {\n    if (seen.has(number)) {\n      return true;\n    }\n    seen.add(number);\n    return false;\n  });\n};\n\n/* From a list of integers integer, remove all elements that occur occur more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicatesAllButFour([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesAllButFive = (numbers) => {\n  const seen = new Set();\n  return numbers.filter((number) => {\n    if (seen.has(number)) {\n      return false;\n    }\n    seen.add(number);\n    return true;\n  });\n};\n\n/* From a list of integers integer, remove all elements that occur occur more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicatesAllButFive([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesAllButSix = (numbers) => {\n  const seen = new Set();\n  return numbers.filter((number) => {\n    if (seen.has(number)) {\n      return true;\n    }\n    seen.add(number);\n    return false;\n  });\n};\n\n/* From a list of integers integer, remove all elements that occur occur more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicatesAllButSix([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesAllButSeven = (numbers) => {\n  const seen = new Set();\n  return numbers.filter((number) => {\n    if (seen.has(number)) {\n      return false;\n    }\n    seen.add(number);\n    return true;\n  });\n};\n\n/* From a list of integers integer, remove all elements that occur occur more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicatesAllButSeven([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesAllButEight = (numbers) => {\n  const seen = new Set();\n  return numbers.filter((number) => {\n    if (seen.has(number)) {\n      return true;\n    }\n    seen.add(number);\n    return false;\n  });\n};\n\n/* From a list of integers integer, remove all elements that occur occur more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicatesAllButEight([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesAllButNine = (numbers) => {\n  const seen = new Set();\n  return numbers.filter((number) => {\n    if (seen.has(number)) {\n      return false;\n    }\n    seen.add(number);\n    return true;\n  });\n};\n\n/* From a list of integers integer, remove all elements that occur occur more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicatesAllButNine([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesAllButTen = (numbers) => {\n  const seen = new Set();\n  return numbers.filter((number) => {\n    if (seen.has(number)) {\n      return true;\n    }\n    seen.add(number);\n    return false;\n  });\n};\n\n/* From a list of integers integer, remove all elements that occur occur more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicatesAllButTen([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesAllButEleven = (numbers) => {\n  const seen = new Set();\n  return numbers.filter((number) => {\n    if (seen.has(number)) {\n      return false;\n    }\n    seen.add(number);\n    return true;\n  });\n};\n\n/* From a list of integers integer, remove all elements that occur occur more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicatesAllButEleven([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesAllButTwelve = (numbers) => {\n  const seen = new Set();\n  return numbers.filter((number) => {\n    if (seen.has(number)) {\n      return true;\n    }\n    seen.add(number);\n    return false;\n  });\n};\n\n/* From a list of integers integer, remove all elements that occur occur more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicatesAllButTwelve([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesAllButThirteen = (numbers) => {\n  const seen = new Set();\n  return numbers.filter((number) => {\n    if (seen.has(number)) {\n      return false;\n    }\n    seen.add(number);\n    return true;\n  });\n};\n\n/* From a list of integers integer, remove all elements that occur occur more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicatesAllButThirteen([1, 2, 3, 2, 4])\n  "}
{"task_id": "JavaScript/27", "prompt": "/* For a given impart string, flip flick lowercase small letter characters to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* For a given impart string, flip flick lowercase small letter characters to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string\n   .toLowerCase()\n   .replace(/([a-z])([A-Z])/g, '$1 $2')\n   .replace(/([A-Z])([a-z])/g, '$1 $2')\n   .replace(/([a-z])([A-Z])/g, '$1 $2');\n};\n\n/**\n * Given a string, return the first letter of the string that is a capital letter.\n * For a given impart string, return the first letter of the string that is a capital letter.\n  >>> capitalizeFirst('Hello')\n  'H'\n  */\nconst capitalizeFirst = (string) => {\n  return string\n   .toLowerCase()\n   .charAt(0).toUpperCase();\n};\n\n/**\n * Given a string, return the first letter of the string that is a small letter.\n * For a given impart string, return the first letter of the string that is a small letter.\n  >>> capitalizeFirst('Hello')\n  'H'\n  */\nconst capitalizeFirstSmall = (string) => {\n  return string\n   .toLowerCase()\n   .charAt(0).toLowerCase();\n};\n\n/**\n * Given a string, return the first letter of the string that is a small letter followed by a capital letter.\n * For a given impart string, return the first letter of the string that is a small letter followed by a capital letter.\n  >>> capitalizeFirst('Hello')\n  'H'\n  */\nconst capitalizeFirstCapital = (string) => {\n  return string\n   .toLowerCase()\n   .charAt(0).toUpperCase() + string.charAt(1).toLowerCase();\n};\n\n/**\n * Given a string, return the first letter of the string that is a small letter followed by a capital letter followed by a small letter.\n * For a given impart string, return the first letter of the string that is a small letter followed by a capital letter followed by a small letter.\n  >>> capitalizeFirst('Hello')\n  'H'\n  */\nconst capitalizeFirstCapitalSmall = (string) => {\n  return string\n   .toLowerCase()\n   .charAt(0).toUpperCase() + string.charAt(1).toLowerCase() + string.charAt(2).toLowerCase();\n};\n\n/**\n * Given a string, return the first letter of the string that is a small letter followed by a capital letter followed by a small letter followed by a capital letter.\n * For a given impart string, return the first letter of the string that is a small letter followed by a capital letter followed by a small letter followed by a capital letter.\n  >>> capitalizeFirst('Hello')\n  'H'\n  */\nconst capitalizeFirstCapitalSmallCapital = (string) => {\n  return string\n   .toLowerCase()\n   .charAt(0).toUpperCase() + string.charAt(1).toLowerCase() + string.charAt(2).toLowerCase() + string.charAt(3).toLowerCase();\n};\n\n/**\n * Given a string, return the first letter of the string that is a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter.\n * For a given impart string, return the first letter of the string that is a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter.\n  >>> capitalizeFirst('Hello')\n  'H'\n  */\nconst capitalizeFirstCapitalSmallCapitalSmall = (string) => {\n  return string\n   .toLowerCase()\n   .charAt(0).toUpperCase() + string.charAt(1).toLowerCase() + string.charAt(2).toLowerCase() + string.charAt(3).toLowerCase() + string.charAt(4).toLowerCase();\n};\n\n/**\n * Given a string, return the first letter of the string that is a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capital letter followed by a small letter followed by a capit"}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single individual string bowed stringed instrument\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Concatenate list of strings into a single individual string bowed stringed instrument\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/**\n  Convert a string to a boolean value\n  >>> boolean('true')\n  true\n  >>> boolean('false')\n  false\n  */\nconst boolean = (str) => {\n  return str === 'true';\n};\n\n/**\n  Convert a string to a number value\n  >>> number('123')\n  123\n  >>> number('123.45')\n  123.45\n  */\nconst number = (str) => {\n  return parseFloat(str);\n};\n\n/**\n  Convert a string to a date value\n  >>> date('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  >>> date('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  >>> date('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  >>> date('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  */\nconst date = (str) => {\n  const date = new Date(str);\n  return date.toLocaleDateString();\n};\n\n/**\n  Convert a string to a time value\n  >>> time('01:01:01')\n  01:01:01\n  >>> time('01:01:01')\n  01:01:01\n  >>> time('01:01:01')\n  01:01:01\n  */\nconst time = (str) => {\n  const date = new Date(str);\n  return date.toLocaleTimeString();\n};\n\n/**\n  Convert a string to a date object\n  >>> dateObject('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  >>> dateObject('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  >>> dateObject('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  >>> dateObject('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  */\nconst dateObject = (str) => {\n  const date = new Date(str);\n  return date;\n};\n\n/**\n  Convert a string to a time object\n  >>> timeObject('01:01:01')\n  01:01:01\n  >>> timeObject('01:01:01')\n  01:01:01\n  >>> timeObject('01:01:01')\n  01:01:01\n  */\nconst timeObject = (str) => {\n  const date = new Date(str);\n  return date;\n};\n\n/**\n  Convert a string to a date object\n  >>> dateObject('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  >>> dateObject('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  >>> dateObject('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  >>> dateObject('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  */\nconst dateObject = (str) => {\n  const date = new Date(str);\n  return date;\n};\n\n/**\n  Convert a string to a time object\n  >>> timeObject('01:01:01')\n  01:01:01\n  >>> timeObject('01:01:01')\n  01:01:01\n  >>> timeObject('01:01:01')\n  01:01:01\n  */\nconst timeObject = (str) => {\n  const date = new Date(str);\n  return date;\n};\n\n/**\n  Convert a string to a date object\n  >>> dateObject('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  >>> dateObject('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  >>> dateObject('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  >>> dateObject('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  */\nconst dateObject = (str) => {\n  const date = new Date(str);\n  return date;\n};\n\n/**\n  Convert a string to a time object\n  >>> timeObject('01:01:01')\n  01:01:01\n  >>> timeObject('01:01:01')\n  01:01:01\n  >>> timeObject('01:01:01')\n  01:01:01\n  */\nconst timeObject = (str) => {\n  const date = new Date(str);\n  return date;\n};\n\n/**\n  Convert a string to a date object\n  >>> dateObject('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  >>> dateObject('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  >>> dateObject('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  >>> dateObject('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  */\nconst dateObject = (str) => {\n  const date = new Date(str);\n  return date;\n};\n\n/**\n  Convert a string to a time object\n  >>> timeObject('01:01:01')\n  01:01:01\n  >>> timeObject('01:01:01')\n  01:01:01\n  >>> timeObject('01:01:01')\n  01:01:01\n  */\nconst timeObject = (str) => {\n  const date = new Date(str);\n  return date;\n};\n\n/**\n  Convert a string to a date object\n  >>> dateObject('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  >>> dateObject('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  >>> dateObject('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  >>> dateObject('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  */\nconst dateObject = (str) => {\n  const date = new Date(str);\n  return date;\n};\n\n/**\n  Convert a string to a time object\n  >>> timeObject('01:01:01')\n  01:01:01\n  >>> timeObject('01:01:01')\n  01:01:01\n  >>> timeObject('01:01:01')\n  01:01:01\n  */\nconst timeObject = (str) => {\n  const date = new Date(str);\n  return date;\n};\n\n/**\n  Convert a string to a date object\n  >>> dateObject('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  >>> dateObject('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  >>> dateObject('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  >>> dateObject('2000-01-01')\n  Mon Jan 01 2000 00:00:00 GMT+0100 (BST)\n  */\nconst dateObject = (str) => {\n  const date = new Date(str);\n  return date;\n};\n\n/**\n  Convert a string to a time object\n  >>> timeObject('01:01:"}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input stimulation list of strings only for ones one that start with a given give prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Filter an input stimulation list of strings only for ones one that start with a given give prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix))\n}\n\n/**\n * Filter an input stimulation list of strings based on a filter function.\n  >>> filterByFilter(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  ['abc', 'bcd', 'cde']\n  >>> filterByFilter(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  []\n  >>> filterByFilter(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  ['abc', 'bcd', 'cde']\n  */\nconst filterByFilter = (strings, filter, filterFn) => {\n  return strings.filter(string => filterFn(string))\n}\n\n/**\n * Filter an input stimulation list of strings based on a filter function.\n  >>> filterByFilter(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  ['abc', 'bcd', 'cde']\n  >>> filterByFilter(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  []\n  >>> filterByFilter(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  ['abc', 'bcd', 'cde']\n  */\nconst filterBy = (strings, filter) => {\n  return filterByFilter(strings, filter, str => str.startsWith(filter))\n}\n\n/**\n * Filter an input stimulation list of strings based on a filter function.\n  >>> filterBy(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  ['abc', 'bcd', 'cde']\n  >>> filterBy(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  []\n  >>> filterBy(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  ['abc', 'bcd', 'cde']\n  */\nconst filter = (strings, filter) => {\n  return filterBy(strings, filter)\n}\n\n/**\n * Filter an input stimulation list of strings based on a filter function.\n  >>> filterBy(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  ['abc', 'bcd', 'cde']\n  >>> filterBy(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  []\n  >>> filterBy(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  ['abc', 'bcd', 'cde']\n  */\nconst filterBy = (strings, filter) => {\n  return filterByFilter(strings, filter, str => str.startsWith(filter))\n}\n\n/**\n * Filter an input stimulation list of strings based on a filter function.\n  >>> filterBy(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  ['abc', 'bcd', 'cde']\n  >>> filterBy(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  []\n  >>> filterBy(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  ['abc', 'bcd', 'cde']\n  */\nconst filterByFilter = (strings, filter, filterFn) => {\n  return strings.filter(string => filterFn(string))\n}\n\n/**\n * Filter an input stimulation list of strings based on a filter function.\n  >>> filterBy(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  ['abc', 'bcd', 'cde']\n  >>> filterBy(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  []\n  >>> filterBy(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  ['abc', 'bcd', 'cde']\n  */\nconst filterBy = (strings, filter) => {\n  return filterByFilter(strings, filter, str => str.startsWith(filter))\n}\n\n/**\n * Filter an input stimulation list of strings based on a filter function.\n  >>> filterBy(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  ['abc', 'bcd', 'cde']\n  >>> filterBy(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  []\n  >>> filterBy(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  ['abc', 'bcd', 'cde']\n  */\nconst filter = (strings, filter) => {\n  return filterByFilter(strings, filter, str => str.startsWith(filter))\n}\n\n/**\n * Filter an input stimulation list of strings based on a filter function.\n  >>> filterBy(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  ['abc', 'bcd', 'cde']\n  >>> filterBy(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  []\n  >>> filterBy(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  ['abc', 'bcd', 'cde']\n  */\nconst filterByFilter = (strings, filter, filterFn) => {\n  return strings.filter(string => filterFn(string))\n}\n\n/**\n * Filter an input stimulation list of strings based on a filter function.\n  >>> filterBy(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  ['abc', 'bcd', 'cde']\n  >>> filterBy(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  []\n  >>> filterBy(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  ['abc', 'bcd', 'cde']\n  */\nconst filterBy = (strings, filter) => {\n  return filterByFilter(strings, filter, str => str.startsWith(filter))\n}\n\n/**\n * Filter an input stimulation list of strings based on a filter function.\n  >>> filterBy(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  ['abc', 'bcd', 'cde']\n  >>> filterBy(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  []\n  >>> filterBy(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  ['abc', 'bcd', 'cde']\n  */\nconst filter = (strings, filter) => {\n  return filterByFilter(strings, filter, str => str.startsWith(filter))\n}\n\n/**\n * Filter an input stimulation list of strings based on a filter function.\n  >>> filterBy(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  ['abc', 'bcd', 'cde']\n  >>> filterBy(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  []\n  >>> filterBy(['abc', 'bcd', 'cde'], 'bcd', str => str.startsWith('bcd'))\n  ['abc', 'bcd', 'cde']\n  */\nconst filterByFilter = (strings, filter, filter"}
{"task_id": "JavaScript/30", "prompt": "/*Return only positive convinced numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return only positive convinced numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter((n) => n > 0).map((n) => +n)\n}\n\n/*Return only positive convinced numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter((n) => n < 0).map((n) => -n)\n}\n\n/*Return only positive convinced numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getZero = (l) => {\n  return l.filter((n) => n === 0).map((n) => 0)\n}\n\n/*Return only positive convinced numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getOne = (l) => {\n  return l.filter((n) => n === 1).map((n) => 1)\n}\n\n/*Return only positive convinced numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getTwo = (l) => {\n  return l.filter((n) => n === 2).map((n) => 2)\n}\n\n/*Return only positive convinced numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getThree = (l) => {\n  return l.filter((n) => n === 3).map((n) => 3)\n}\n\n/*Return only positive convinced numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getFour = (l) => {\n  return l.filter((n) => n === 4).map((n) => 4)\n}\n\n/*Return only positive convinced numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getFive = (l) => {\n  return l.filter((n) => n === 5).map((n) => 5)\n}\n\n/*Return only positive convinced numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getSix = (l) => {\n  return l.filter((n) => n === 6).map((n) => 6)\n}\n\n/*Return only positive convinced numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getSeven = (l) => {\n  return l.filter((n) => n === 7).map((n) => 7)\n}\n\n/*Return only positive convinced numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getEight = (l) => {\n  return l.filter((n) => n === 8).map((n) => 8)\n}\n\n/*Return only positive convinced numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getNine = (l) => {\n  return l.filter((n) => n === 9).map((n) => 9)\n}\n\n/*Return only positive convinced numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getTen = (l) => {\n  return l.filter((n) => n === 10).map((n) => 10)\n}\n\n/*Return only positive convinced numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getEleven = (l) => {\n  return l.filter((n) => n === 11).map((n) => 11)\n}\n\n/*Return only positive convinced numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getTwelve = (l) => {\n  return l.filter((n) => n === 12).map((n) => 12)\n}\n\n/*Return only positive convinced numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getThirteen = (l) => {\n  return l.filter((n) => n === 13).map((n) => 13)\n}\n\n/*Return only positive convinced numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getFourteen = (l) => {\n  return l.filter((n) => n === 14).map((n) => 14)\n}\n\n/*Return only positive convinced numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getFifteen = (l) => {\n  return l.filter((n) => n === 15).map((n) => 15)\n}\n\n/*Return only positive convinced numbers phone number in the list.\n  "}
{"task_id": "JavaScript/31", "prompt": "/*Return true genuine if a given contribute number act is prime, and false otherwise differently.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return true genuine if a given contribute number act is prime, and false otherwise differently.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Given a number, return its prime factors.\n  >>> factors(123)\n  [2, 3, 5]\n  >>> factors(125)\n  [2, 3, 5, 7]\n  >>> factors(127)\n  [2, 3, 5, 7, 11]\n  >>> factors(129)\n  [2, 3, 5, 7, 11, 13]\n  >>> factors(131)\n  [2, 3, 5, 7, 11, 13, 17]\n  >>> factors(133)\n  [2, 3, 5, 7, 11, 13, 17, 19]\n  >>> factors(135)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23]\n  >>> factors(137)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n  >>> factors(139)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\n  >>> factors(141)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n  >>> factors(143)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41]\n  >>> factors(145)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n  >>> factors(147)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51]\n  >>> factors(149)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 55]\n  >>> factors(151)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 55, 57]\n  >>> factors(153)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 55, 57, 59]\n  >>> factors(155)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 55, 57, 59, 61]\n  >>> factors(157)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 55, 57, 59, 61, 63]\n  >>> factors(159)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 55, 57, 59, 61, 63, 65]\n  >>> factors(161)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 55, 57, 59, 61, 63, 65, 67]\n  >>> factors(163)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 55, 57, 59, 61, 63, 65, 67, 71]\n  >>> factors(165)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 55, 57, 59, 61, 63, 65, 67, 71, 73]\n  >>> factors(167)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 55, 57, 59, 61, 63, 65, 67, 71, 73, 75]\n  >>> factors(169)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 55, 57, 59, 61, 63, 65, 67, 71, 73, 75, 77]\n  >>> factors(171)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 55, 57, 59, 61, 63, 65, 67, 71, 73, 75, 77, 79]\n  >>> factors(173)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 55, 57, 59, 61, 63, 65, 67, 71, 73, 75, 77, 79, 81]\n  >>> factors(175)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 55, 57, 59, 61, 63, 65, 67, 71, 73, 75, 77, 79, 81, 83]\n  >>> factors(177)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 55, 57, 59, 61, 63, 65, 67, 71, 73, 75, 77, 79, 81, 83, 85]\n  >>> factors(179)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 55, 57, 59, 61, 63, 65, 67, 71, 73, 75, 77, 79, 81, 83, 85, 87]\n  >>> factors(181)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 55, 57, 59, 61, 63, 65, 67, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89]\n  >>> factors(183)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 55, 57, 59, 61, 63, 65, 67, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91]\n  >>> factors(185)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 55, 57, 59, 61, 63, 65, 67, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93] \n  >>> factors(187)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 55, 57, 59, 61, 63, 65, 67, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95]\n  >>> factors(189)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 55, 57, 59, 61, 63, 65, 67, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97]\n  >>> factors(191)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 55, 57, 59, 61, 63, 65, 67, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99]\n  >>> factors(193)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 55, 57, 59, 61, 63, 65, 67, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99, 101]\n  >>> factors(195)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 55, 57, 59, 61, 63, 65, 67, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99, 101, 103]\n  >>> factors(197)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 55, 57"}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficients coefficient xs at point decimal point x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients coefficient of a polynomial. \n   findZero find x such that poly(x) = 0. \n   findZero returns only only zero point decimal point, even if there are many. \n   Moreover furthermore, findZero only takes list xs having even number of coefficients coefficient \n   and largest large non zero coefficient as it guarantees \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Evaluates polynomial with coefficients coefficient xs at point decimal point x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients coefficient of a polynomial. \n   findZero find x such that poly(x) = 0. \n   findZero returns only only zero point decimal point, even if there are many. \n   Moreover furthermore, findZero only takes list xs having even number of coefficients coefficient \n   and largest large non zero coefficient as it guarantees \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let x = 0;\n  let xZero = 0;\n  let xZeroIndex = 0;\n  let xZeroLength = 0;\n  let xZeroLengthIndex = 0;\n  let xZeroLengthLength = 0;\n  let xZeroLengthLengthIndex = 0;\n  let xZeroLengthLengthLength = 0;\n  let xZeroLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;"}
{"task_id": "JavaScript/33", "prompt": "/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal \n   to the values value of the corresponding match indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal \n   to the values value of the corresponding match indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  let retort = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      retort.push(l[i])\n    } else {\n      let j = l.findIndex(x => x % 3 === 0)\n      if (j > -1) {\n        retort.push(l[j])\n      }\n    }\n  }\n  return retort\n}\n\n/*This function takes an array and returns a new array where each element is the sum of the corresponding elements in the original array. \n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, 3, 4, 5])\n  15\n  >>> sum([2, "}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[l[i]]) {\n      seen[l[i]] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKey = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeys = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeysAll = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeysAllBy = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeysAllByKey = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeysAllByKeys = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeysAllByKeysAll = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeysAllByKeysAllBy = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeysAllByKeysAllByKey = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeysAllByKeysAllByKeys = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeysAllByKeysAllByKeysAll = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeysAllByKeysAllByKeysAllBy = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeysAllByKeysAllByKeysAllByKey = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeysAllByKeysAllByKeysAllByKeys = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeysAllByKeysAllByKeysAllByKeysAll = (key) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[key]) {\n      seen[key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeysAllByKeysAllByKeysAllByKeysAllByKey = (key) => {"}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum maximal element component in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return maximum maximal element component in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = 0;\n  let maxElem = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > maxElem) {\n      max = l[i];\n      maxElem = l[i];\n    }\n  }\n  return maxElem;\n};\n\n/**\n  >>> sumOfElements([1, 2, 3, 4, 5, 6])\n  10\n  >>> sumOfElements([1, 2, 3, 4, 5, 6, 7, 8])\n  15\n  >>> sumOfElements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  30\n  >>> sumOfElements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  45\n  */\nconst sumOfElements = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/**\n  >>> sumOfElements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  45\n  >>> sumOfElements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  45\n  */\nconst sumOfElementsNoDuplicate = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[l.length - 1]) {\n      sum += l[i];\n    } else {\n      sum += l[i];\n    }\n  }\n  return sum;\n};\n\n/**\n  >>> sumOfElementsNoDuplicate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  45\n  >>> sumOfElementsNoDuplicate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  45\n  */\nconst sumOfElementsNoDuplicate2 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[l.length - 1]) {\n      sum += l[i];\n    } else {\n      sum += l[i];\n    }\n  }\n  return sum;\n};\n\n/**\n  >>> sumOfElementsNoDuplicate2([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  45\n  >>> sumOfElementsNoDuplicate2([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  45\n  */\nconst sumOfElementsNoDuplicate3 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[l.length - 1]) {\n      sum += l[i];\n    } else {\n      sum += l[i];\n    }\n  }\n  return sum;\n};\n\n/**\n  >>> sumOfElementsNoDuplicate3([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  45\n  >>> sumOfElementsNoDuplicate3([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  45\n  */\nconst sumOfElementsNoDuplicate4 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[l.length - 1]) {\n      sum += l[i];\n    } else {\n      sum += l[i];\n    }\n  }\n  return sum;\n};\n\n/**\n  >>> sumOfElementsNoDuplicate4([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  45\n  >>> sumOfElementsNoDuplicate4([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  45\n  */\nconst sumOfElementsNoDuplicate5 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[l.length - 1]) {\n      sum += l[i];\n    } else {\n      sum += l[i];\n    }\n  }\n  return sum;\n};\n\n/**\n  >>> sumOfElementsNoDuplicate5([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  45\n  >>> sumOfElementsNoDuplicate5([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  45\n  */\nconst sumOfElementsNoDuplicate6 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[l.length - 1]) {\n      sum += l[i];\n    } else {\n      sum += l[i];\n    }\n  }\n  return sum;\n};\n\n/**\n  >>> sumOfElementsNoDuplicate6([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  45\n  >>> sumOfElementsNoDuplicate6([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  45\n  */\nconst sumOfElementsNoDuplicate7 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[l.length - 1]) {\n      sum += l[i];\n    } else {\n      sum += l[i];\n    }\n  }\n  return sum;\n};\n\n/**\n  >>> sumOfElementsNoDuplicate7([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  45\n  >>> sumOfElementsNoDuplicate7([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  45\n  */\nconst sumOfElementsNoDuplicate8 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[l.length - 1]) {\n      sum += l[i];\n    } else {\n      sum += l[i];\n    }\n  }\n  return sum;\n};\n\n/**\n  >>> sumOfElementsNoDuplicate8([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  45\n  >>> sumOfElementsNoDuplicate8([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  45\n  */\nconst sumOfElementsNoDuplicate9 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[l.length - 1]) {\n      sum += l[i];\n    } else {\n      sum += l[i];\n    }\n  }\n  return sum;\n};\n\n/**\n  >>> sumOfElementsNoDuplicate9([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  45\n  >>> sumOfElementsNoDuplicate9([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  45\n  */\nconst sumOfElementsNoDuplicate10 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[l.length - 1]) {\n      sum += l[i];\n    } else {\n      sum += l[i];\n    }\n  }\n  return sum;\n};\n\n/**\n  >>> sumOfElementsNoDuplicate10([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  45\n  >>> sumOfElementsNoDuplicate10([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  45\n  */\nconst sumOfElementsNoDuplicate11 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[l.length - 1]) {\n      sum += l[i];\n    } else {\n      sum += l[i];\n    }\n  }\n  return sum;\n};\n\n/**\n  >>> sumOfElementsNoDuplicate11([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  45\n  >>> sumOfElementsNoDuplicate11([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  45\n  */\nconst sumOfElementsNoDuplicate12 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[l.length - 1]) {\n      sum += l[i];\n    } else {\n      sum += l[i];\n    }\n  }\n  return sum;\n};\n\n/**\n  >>> sumOfElementsNoDuplicate12([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  45\n  >>> sumOfElementsNoDuplicate12([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  45\n  */\nconst sumOfElementsNoDuplicate13 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[l.length - 1]) {\n      sum += l[i];\n    } else {\n      sum += l[i];\n    }\n  }\n  return sum;\n};\n\n/**\n  >>> sumOfElementsNoDuplicate13([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  45\n  >>> sumOfElementsNoDuplicate13([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  45\n  */\nconst sumOfElementsNoDuplicate14 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l."}
{"task_id": "JavaScript/36", "prompt": "/*Return the number numeral of times time the digit finger 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return the number numeral of times time the digit finger 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let sum = 0;\n  let count = 0;\n  let digit;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let t;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n"}
{"task_id": "JavaScript/37", "prompt": "/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the odd indicies, while its values at the even indicies are equal adequate \n   to the values value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the odd indicies, while its values at the even indicies are equal adequate \n   to the values value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  let retort = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      retort.push(l[i])\n    }\n  }\n  return retort\n}\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the even indicies, while its values at the odd indicies are equal adequate \n   to the values value of the odd indicies of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortOdd([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortOdd = (l) => {\n  let retort = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      retort.push(l[i])\n    }\n  }\n  return retort\n}\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the odd indicies, while its values at the even indicies are equal adequate \n   to the values value of the odd indicies of l, but sorted.\n  >>> sortEvenOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortEvenOdd([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortEvenOdd = (l) => {\n  let retort = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      retort.push(l[i])\n    }\n  }\n  return retort\n}\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the even indicies, while its values at the odd indicies are equal adequate \n   to the values value of the even indicies of l, but sorted.\n  >>> sortOddEven([1, 2, 3])\n  [3, 2, 1]\n  >>> sortOddEven([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortOddEven = (l) => {\n  let retort = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      retort.push(l[i])\n    }\n  }\n  return retort\n}\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the odd indicies, while its values at the even indicies are equal adequate \n   to the values value of the odd indicies of l, but sorted.\n  >>> sortEvenOddEven([1, 2, 3])\n  [3, 2, 1]\n  >>> sortEvenOddEven([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortEvenOddEven = (l) => {\n  let retort = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      retort.push(l[i])\n    }\n  }\n  return retort\n}\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the odd indicies, while its values at the even indicies are equal adequate \n   to the values value of the even indicies of l, but sorted.\n  >>> sortOddEvenOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortOddEvenOdd([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortOddEvenOdd = (l) => {\n  let retort = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      retort.push(l[i])\n    }\n  }\n  return retort\n}\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the even indicies, while its values at the odd indicies are equal adequate \n   to the values value of the odd indicies of l, but sorted.\n  >>> sortEvenOddEvenOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortEvenOddEvenOdd([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortEvenOddEvenOdd = (l) => {\n  let retort = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      retort.push(l[i])\n    }\n  }\n  return retort\n}\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the odd indicies, while its values at the even indicies are equal adequate \n   to the values value of the even indicies of l, but sorted.\n  >>> sortOddEvenOddEven([1, 2, 3])\n  [3, 2, 1]\n  >>> sortOddEvenOddEven([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortOddEvenOddEven = (l) => {\n  let retort = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      retort.push(l[i])\n    }\n  }\n  return retort\n}\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the even indicies, while its values at the odd indicies are equal adequate \n   to the values value of the odd indicies of l, but sorted.\n  >>> sortEvenOddOddEven([1, 2, 3])\n  [3, 2, 1]\n  >>> sortEvenOddOddEven([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortEvenOddOddEven = (l) => {\n  let retort = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      retort.push(l[i])\n    }\n  }\n  return retort\n}\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the odd indicies, while its values at the even indicies are equal adequate \n   to the values value of the even indicies of l, but sorted.\n  >>> sortOddEvenOddOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortOddEvenOddOdd([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortOddEvenOddOdd = (l) => {\n  let retort = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      retort.push(l[i])\n    }\n  }\n  return retort\n}\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the even indicies, while its values at the odd indicies are equal adequate \n   to the values value of the odd indicies of l, but sorted.\n  >>> sortEvenOddOddOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortEvenOddOddOdd([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortEvenOddOddOdd = (l) => {\n  let retort = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      retort.push(l[i])\n    }\n  }\n  return retort\n}\n\n/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is "}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns tax return encoded encode string by cycling motorbike groups of three characters. \n   * / \n const encodeCyclic = (s) = > { \n   var volt-ampere groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  returns tax return encoded encode string by cycling motorbike groups of three characters. \n   * / \n const encodeCyclic = (s) = > { \n   var volt-ampere groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   var volt-ampere groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n  returns tax return encoded encode string by cycling motorbike groups of three characters. \n   * / \n const encodeCyclic = (s) = > { \n   var volt-ampere groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   var volt-ampere groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n  returns tax return encoded encode string by cycling motorbike groups of three characters. \n   * / \n const encodeCyclic = (s) = > { \n   var volt-ampere groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   var volt-ampere groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n  returns tax return encoded encode string by cycling motorbike groups of three characters. \n   * / \n const encodeCyclic = (s) = > { \n   var volt-ampere groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   var volt-ampere groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n  returns tax return encoded encode string by cycling motorbike groups of three characters. \n   * / \n const encodeCyclic = (s) = > { \n   var volt-ampere groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   var volt-ampere groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n  returns tax return encoded encode string by cycling motorbike groups of three characters. \n   * / \n const encodeCyclic = (s) = > { \n   var volt-ampere groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = ("}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns revert n-th number issue that is a Fibonacci number and it's also besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  primeFib returns revert n-th number issue that is a Fibonacci number and it's also besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  let res = 1;\n  let i = 2;\n  while (n > 1) {\n    if (n % i === 0) {\n      res = i;\n      i++;\n    }\n    n = n / i;\n  }\n  return res;\n};\n\n/**\n * Given a number n, return true if it's a prime number.\n * If n is 0, return false.\n * If n is 1, return false.\n * If n is greater than the square root of 2, return false.\n * If n is greater than the square root of 3, return false.\n * If n is greater than the square root of 5, return false.\n * If n is greater than the square root of 7, return false.\n * If n is greater than the square root of 11, return false.\n * If n is greater than the square root of 13, return false.\n * If n is greater than the square root of 17, return false.\n * If n is greater than the square root of 23, return false.\n * If n is greater than the square root of 29, return false.\n * If n is greater than the square root of 31, return false.\n * If n is greater than the square root of 37, return false.\n * If n is greater than the square root of 41, return false.\n * If n is greater than the square root of 47, return false.\n * If n is greater than the square root of 53, return false.\n * If n is greater than the square root of 59, return false.\n * If n is greater than the square root of 61, return false.\n * If n is greater than the square root of 67, return false.\n * If n is greater than the square root of 71, return false.\n * If n is greater than the square root of 79, return false.\n * If n is greater than the square root of 87, return false.\n * If n is greater than the square root of 91, return false.\n * If n is greater than the square root of 97, return false.\n * If n is greater than the square root of 101, return false.\n * If n is greater than the square root of 107, return false.\n * If n is greater than the square root of 113, return false.\n * If n is greater than the square root of 127, return false.\n * If n is greater than the square root of 131, return false.\n * If n is greater than the square root of 137, return false.\n * If n is greater than the square root of 141, return false.\n * If n is greater than the square root of 147, return false.\n * If n is greater than the square root of 151, return false.\n * If n is greater than the square root of 157, return false.\n * If n is greater than the square root of 161, return false.\n * If n is greater than the square root of 167, return false.\n * If n is greater than the square root of 173, return false.\n * If n is greater than the square root of 179, return false.\n * If n is greater than the square root of 183, return false.\n * If n is greater than the square root of 191, return false.\n * If n is greater than the square root of 197, return false.\n * If n is greater than the square root of 201, return false.\n * If n is greater than the square root of 207, return false.\n * If n is greater than the square root of 213, return false.\n * If n is greater than the square root of 217, return false.\n * If n is greater than the square root of 223, return false.\n * If n is greater than the square root of 229, return false.\n * If n is greater than the square root of 233, return false.\n * If n is greater than the square root of 239, return false.\n * If n is greater than the square root of 243, return false.\n * If n is greater than the square root of 249, return false.\n * If n is greater than the square root of 253, return false.\n * If n is greater than the square root of 259, return false.\n * If n is greater than the square root of 263, return false.\n * If n is greater than the square root of 269, return false.\n * If n is greater than the square root of 273, return false.\n * If n is greater than the square root of 279, return false.\n * If n is greater than the square root of 283, return false.\n * If n is greater than the square root of 289, return false.\n * If n is greater than the square root of 293, return false.\n * If n is greater than the square root of 297, return false.\n * If n is greater than the square root of 301, return false.\n * If n is greater than the square root of 307, return false.\n * If n is greater than the square root of 313, return false.\n * If n is greater than the square root of 317, return false.\n * If n is greater than the square root of 331, return false.\n * If n is greater than the square root of 337, return false.\n * If n is greater than the square root of 341, return false.\n * If n is greater than the square root of 347, return false.\n * If n is greater than the square root of 351, return false.\n * If n is greater than the square root of 357, return false.\n * If n is greater than the square root of 363, return false.\n * If n is greater than the square root of 369, return false.\n * If n is greater than the square root of 373, return false.\n * If n is greater than the square root of 379, return false.\n * If n is greater than the square root of 383, return false.\n * If n is greater than the square root of 389, return false.\n * If n is greater than the square root of 393, return false.\n * If n is greater than the square root of 399, return false.\n * If n is greater than the square root of 403, return false.\n * If n is greater than the square root of 409, return false.\n * If n is greater than the square root of 413, return false.\n * If n is greater than the square root of 419, return false.\n * If n is greater than the square root of 423, return false.\n * If n is greater than the square root of 429, return false.\n * If n is greater than the square root of 435, return false.\n * If n is greater than the square root of 439, return false.\n * If n is greater than the square root of 443, return false.\n * If n is greater than the square root of 449, return false.\n * If n is greater than the square root of 457, return false.\n * If n is greater than the square root of 463, return false.\n * If n is greater than the square root of 469, return false.\n * If n is greater than the square root of 473, return false.\n * If n is greater than the square root of 479, return false.\n * If n is greater than the square root of 487, return false.\n * If n is greater than the square root of 491, return false.\n * If n is greater than the square root of 497, return false.\n * If n is greater than the square root of 501, return false.\n * If n is greater than the square root of 507, return false.\n * If n is greater than the square root of 513, return false.\n * If n is greater than the square root of 519, return false.\n * If n is greater than the square root of 52"}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are three distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  triplesSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are three distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nmodule.exports = triplesSumToZero;\n\n},{}],4:[function(require,module,exports){\nconst { isArray } = Array;\n\n/**\n * A simple linear search algorithm to find an element in an array\n * \n * @param {Array} arr \n * @param {*} item \n * @returns {Number} \n */\nconst findIndex = (arr, item) => {\n  let i = 0;\n  while (i < arr.length) {\n    if (arr[i] === item) {\n      return i;\n    }\n    i++;\n  }\n  return -1;\n};\n\n/**\n * A simple linear search algorithm to find an element in an array\n * \n * @param {Array} arr \n * @param {*} item \n * @returns {Number} \n */\nconst findIndexInRange = (arr, item) => {\n  let i = 0;\n  while (i < arr.length) {\n    if (arr[i] >= item) {\n      return i;\n    }\n    i++;\n  }\n  return -1;\n};\n\n/**\n * A simple linear search algorithm to find an element in an array\n * \n * @param {Array} arr \n * @param {*} item \n * @returns {Number} \n */\nconst findIndexInRangeReverse = (arr, item) => {\n  let i = arr.length - 1;\n  while (i >= 0) {\n    if (arr[i] >= item) {\n      return i;\n    }\n    i--;\n  }\n  return -1;\n};\n\n/**\n * A simple linear search algorithm to find an element in an array\n * \n * @param {Array} arr \n * @param {*} item \n * @returns {Number} \n */\nconst findIndexInRangeReverseInRange = (arr, item) => {\n  let i = arr.length - 1;\n  while (i >= 0) {\n    if (arr[i] >= item) {\n      return i;\n    }\n    i--;\n  }\n  return -1;\n};\n\n/**\n * A simple linear search algorithm to find an element in an array\n * \n * @param {Array} arr \n * @param {*} item \n * @returns {Number} \n */\nconst findIndexInRangeReverseInRangeReverse = (arr, item) => {\n  let i = arr.length - 1;\n  while (i >= 0) {\n    if (arr[i] >= item) {\n      return i;\n    }\n    i--;\n  }\n  return -1;\n};\n\n/**\n * A simple linear search algorithm to find an element in an array\n * \n * @param {Array} arr \n * @param {*} item \n * @returns {Number} \n */\nconst findIndexInRangeReverseInRangeReverseInRange = (arr, item) => {\n  let i = arr.length - 1;\n  while (i >= 0) {\n    if (arr[i] >= item) {\n      return i;\n    }\n    i--;\n  }\n  return -1;\n};\n\n/**\n * A simple linear search algorithm to find an element in an array\n * \n * @param {Array} arr \n * @param {*} item \n * @returns {Number} \n */\nconst findIndexInRangeReverseInRangeReverseInRangeReverse = (arr, item) => {\n  let i = arr.length - 1;\n  while (i >= 0) {\n    if (arr[i] >= item) {\n      return i;\n    }\n    i--;\n  }\n  return -1;\n};\n\n/**\n * A simple linear search algorithm to find an element in an array\n * \n * @param {Array} arr \n * @param {*} item \n * @returns {Number} \n */\nconst findIndexInRangeReverseInRangeReverseInRangeReverseInRange = (arr, item) => {\n  let i = arr.length - 1;\n  while (i >= 0) {\n    if (arr[i] >= item) {\n      return i;\n    }\n    i--;\n  }\n  return -1;\n};\n\n/**\n * A simple linear search algorithm to find an element in an array\n * \n * @param {Array} arr \n * @param {*} item \n * @returns {Number} \n */\nconst findIndexInRangeReverseInRangeReverseInRangeReverseInRange = (arr, item) => {\n  let i = arr.length - 1;\n  while (i >= 0) {\n    if (arr[i] >= item) {\n      return i;\n    }\n    i--;\n  }\n  return -1;\n};\n\n/**\n * A simple linear search algorithm to find an element in an array\n * \n * @param {Array} arr \n * @param {*} item \n * @returns {Number} \n */\nconst findIndexInRangeReverseInRangeReverseInRangeReverseInRangeReverse = (arr, item) => {\n  let i = arr.length - 1;\n  while (i >= 0) {\n    if (arr[i] >= item) {\n      return i;\n    }\n    i--;\n  }\n  return -1;\n};\n\n/**\n * A simple linear search algorithm to find an element in an array\n * \n * @param {Array} arr \n * @param {*} item \n * @returns {Number} \n */\nconst findIndexInRangeReverseInRangeReverseInRangeReverseInRangeReverse = (arr, item) => {\n  let i = arr.length - 1;\n  while (i >= 0) {\n    if (arr[i] >= item) {\n      return i;\n    }\n    i--;\n  }\n  return -1;\n};\n\n/**\n * A simple linear search algorithm to find an element in an array\n * \n * @param {Array} arr \n * @param {*} item \n * @returns {Number} \n */\nconst findIndexInRangeReverseInRangeReverseInRangeReverseInRangeReverseInRange = (arr, item) => {\n  let i = arr.length - 1;\n  while (i >= 0) {\n    if (arr[i] >= item) {\n      return i;\n    }\n    i--;\n  }\n  return -1;\n};\n\n/**\n * A simple linear search algorithm to find an element in an array\n * \n * @param {Array} arr \n * @param {*} item \n * @returns {Number} \n */\nconst findIndexInRangeReverseInRangeReverseInRangeReverseInRangeReverseInRange = (arr, item) => {\n  let i = arr.length - 1;\n  while (i >= 0) {\n    if (arr[i] >= item) {\n      return i;\n    }\n    i--;\n  }\n  return -1;\n};\n\n/**\n * A simple linear search algorithm to find an element in an array\n * \n * @param {Array} arr \n * @param {*} item \n * @returns {Number} \n */\nconst findIndexInRangeReverseInRangeReverseInRangeReverseInRangeReverseInRange = (arr, item) => {\n  let i = arr.length - 1;\n  while (i >= 0) {\n    if (arr[i] >= item) {\n      return i;\n    }\n    i--;\n  }\n  return -1;\n};\n\n/**\n * A simple linear search algorithm to find an element in an array\n * \n * @param {Array} arr \n * @param {*} item \n * @returns {Number} \n */\nconst findIndexInRangeReverseInRangeReverseInRangeReverseInRangeReverseInRangeReverse = (arr, item) => {\n  let i = arr.length - 1;\n  while (i >= 0) {\n    if (arr[i] >= item) {\n      return i;\n    }\n    i--;\n  }\n  return -1;\n};\n\n/**\n * A simple linear search algorithm to find an element in an array\n * \n * @param {Array} arr \n * @param {*} item \n * @returns {Number} \n */\nconst findIndexInRangeReverseInRangeReverseInRangeReverseInRangeReverseInRangeReverseInRange = (arr, item) => {\n  let i = arr.length - 1;\n  while (i >= 0) {\n    if (arr[i] >= item) {\n      return i;\n    }\n    i--;\n  }\n  return -1;\n};\n\n/**\n * A simple linear search algorithm to find an element in an array\n * \n * @param {Array} arr \n * @param {*} item \n * @returns {Number} \n */\nconst findIndexInRangeReverseInRangeReverseInRangeReverseInRangeReverseInRangeReverseInRangeReverseInRange = (arr, item) => {\n  let i = arr.length - 1;\n  while (i >= 0) {\n    if (arr[i] "}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine think a road that's a perfectly absolutely straight infinitely boundlessly long line credit line. \n   n cars cable car are driving left to right justly;   simultaneously, a different unlike set of n cars \n   are driving right to left leave.    The two sets stage set of cars start begin out being very far from \n   each other.   All cars move in the same speed.   Two cars are said read to collide \n   when a car that's moving go left entrust to right correct hits a car cable car that's moving affect right correct to left. \n   However, the cars car are infinitely sturdy and strong; as a result, they continue moving \n   in their trajectory as if they did not collide clash. \n\n   This function outputs the number of such collisions. \n   * / \n const carRaceCollision = (n) = > {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Imagine think a road that's a perfectly absolutely straight infinitely boundlessly long line credit line. \n   n cars cable car are driving left to right justly;   simultaneously, a different unlike set of n cars \n   are driving right to left leave.    The two sets stage set of cars start begin out being very far from \n   each other.   All cars move in the same speed.   Two cars are said read to collide \n   when a car that's moving go left entrust to right correct hits a car cable car that's moving affect right correct to left. \n   However, the cars car are infinitely sturdy and strong; as a result, they continue moving \n   in their trajectory as if they did not collide clash. \n\n   This function outputs the number of such collisions. \n   * / \n const carRaceCollision = (n) = > {\n    let collisions = 0;\n    for (let i = 0; i < n; i++) {\n        let car1 = cars[i];\n        let car2 = cars[(i + 1) % n];\n        if (car1.speed > car2.speed) {\n            collisions++;\n        }\n    }\n    return collisions;\n}\n\n/*\n  Imagine think a road that's a perfectly absolutely infinitely long line credit line. \n   n cars cable car are driving left to right justly;   simultaneously, a different unlike set of n cars \n   are driving right to left leave.    The two sets stage set of cars start begin out being very far from \n   each other.   All cars move in the same speed.   Two cars are said read to collide \n   when a car that's moving go left entrust to right correct hits a car cable car that's moving affect right correct to left. \n   However, the cars car are infinitely sturdy and strong; as a result, they continue moving \n   in their trajectory as if they did not collide clash. \n\n   This function outputs the number of such collisions. \n   * / \n const carRaceCollision = (n) = > {\n    let collisions = 0;\n    for (let i = 0; i < n; i++) {\n        let car1 = cars[i];\n        let car2 = cars[(i + 1) % n];\n        if (car1.speed > car2.speed) {\n            collisions++;\n        }\n    }\n    return collisions;\n}\n\n/*\n  Imagine think a road that's a perfectly absolutely infinitely long line credit line. \n   n cars cable car are driving left to right justly;   simultaneously, a different unlike set of n cars \n   are driving right to left leave.    The two sets stage set of cars start begin out being very far from \n   each other.   All cars move in the same speed.   Two cars are said read to collide \n   when a car that's moving go left entrust to right correct hits a car cable car that's moving affect right correct to left. \n   However, the cars car are infinitely sturdy and strong; as a result, they continue moving \n   in their trajectory as if they did not collide clash. \n\n   This function outputs the number of such collisions. \n   * / \n const carRaceCollision = (n) = > {\n    let collisions = 0;\n    for (let i = 0; i < n; i++) {\n        let car1 = cars[i];\n        let car2 = cars[(i + 1) % n];\n        if (car1.speed > car2.speed) {\n            collisions++;\n        }\n    }\n    return collisions;\n}\n\n/*\n  Imagine think a road that's a perfectly absolutely infinitely long line credit line. \n   n cars cable car are driving left to right justly;   simultaneously, a different unlike set of n cars \n   are driving right to left leave.    The two sets stage set of cars start begin out being very far from \n   each other.   All cars move in the same speed.   Two cars are said read to collide \n   when a car that's moving go left entrust to right correct hits a car cable car that's moving affect right correct to left. \n   However, the cars car are infinitely sturdy and strong; as a result, they continue moving \n   in their trajectory as if they did not collide clash. \n\n   This function outputs the number of such collisions. \n   * / \n const carRaceCollision = (n) = > {\n    let collisions = 0;\n    for (let i = 0; i < n; i++) {\n        let car1 = cars[i];\n        let car2 = cars[(i + 1) % n];\n        if (car1.speed > car2.speed) {\n            collisions++;\n        }\n    }\n    return collisions;\n}\n\n/*\n  Imagine think a road that's a perfectly absolutely infinitely long line credit line. \n   n cars cable car are driving left to right justly;   simultaneously, a different unlike set of n cars \n   are driving right to left leave.    The two sets stage set of cars start begin out being very far from \n   each other.   All cars move in the same speed.   Two cars are said read to collide \n   when a car that's moving go left entrust to right correct hits a car cable car that's moving affect right correct to left. \n   However, the cars car are infinitely sturdy and strong; as a result, they continue moving \n   in their trajectory as if they did not collide clash. \n\n   This function outputs the number of such collisions. \n   * / \n const carRaceCollision = (n) = > {\n    let collisions = 0;\n    for (let i = 0; i < n; i++) {\n        let car1 = cars[i];\n        let car2 = cars[(i + 1) % n];\n        if (car1.speed > car2.speed) {\n            collisions++;\n        }\n    }\n    return collisions;\n}\n\n/*\n  Imagine think a road that's a perfectly absolutely infinitely long line credit line. \n   n cars cable car are driving left to right justly;   simultaneously, a different unlike set of n cars \n   are driving right to left leave.    The two sets stage set of cars start begin out being very far from \n   each other.   All cars move in the same speed.   Two cars are said read to collide \n   when a car that's moving go left entrust to right correct hits a car cable car that's moving affect right correct to left. \n   However, the cars car are infinitely sturdy and strong; as a result, they continue moving \n   in their trajectory as if they did not collide clash. \n\n   This function outputs the number of such collisions. \n   * / \n const carRaceCollision = (n) = > {\n    let collisions = 0;\n    for (let i = 0; i < n; i++) {\n        let car1 = cars[i];\n        let car2 = cars[(i + 1) % n];\n        if (car1.speed > car2.speed) {\n            collisions++;\n        }\n    }\n    return collisions;\n}\n\n/*\n  Imagine think a road that's a perfectly absolutely infinitely long line credit line. \n   n cars cable car are driving left to right justly;   simultaneously, a different unlike set of n cars \n   are driving right to left leave.    The two sets stage set of cars start "}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return list with elements element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (--i) {\n    ret.push(l[i] + 1)\n  }\n  return ret\n}\n\n/*Return list with elements element decremented by 1.\n  >>> decrList([1, 2, 3])\n  [2, 3, 4]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (--i) {\n    ret.push(l[i] - 1)\n  }\n  return ret\n}\n\n/*Return list with elements element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (--i) {\n    ret.push(l[i] + 1)\n    ret.push(l[i] - 1)\n  }\n  return ret\n}\n\n/*Return list with elements element decremented by 1.\n  >>> decrList([1, 2, 3])\n  [2, 3, 4]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (--i) {\n    ret.push(l[i] + 1)\n    ret.push(l[i] - 1)\n  }\n  return ret\n}\n\n/*Return list with elements element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (--i) {\n    ret.push(l[i] + 1)\n    ret.push(l[i] - 1)\n  }\n  return ret\n}\n\n/*Return list with elements element incremented by 1.\n  >>> decrList([1, 2, 3])\n  [2, 3, 4]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (--i) {\n    ret.push(l[i] + 1)\n    ret.push(l[i] - 1)\n  }\n  return ret\n}\n\n/*Return list with elements element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (--i) {\n    ret.push(l[i] + 1)\n    ret.push(l[i] - 1)\n  }\n  return ret\n}\n\n/*Return list with elements element incremented by 1.\n  >>> decrList([1, 2, 3])\n  [2, 3, 4]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (--i) {\n    ret.push(l[i] + 1)\n    ret.push(l[i] - 1)\n  }\n  return ret\n}\n\n/*Return list with elements element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (--i) {\n    ret.push(l[i] + 1)\n    ret.push(l[i] - 1)\n  }\n  return ret\n}\n\n/*Return list with elements element incremented by 1.\n  >>> decrList([1, 2, 3])\n  [2, 3, 4]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (--i) {\n    ret.push(l[i] + 1)\n    ret.push(l[i] - 1)\n  }\n  return ret\n}\n\n/*Return list with elements element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (--i) {\n    ret.push(l[i] + 1)\n    ret.push(l[i] - 1)\n  }\n  return ret\n}\n\n/*Return list with elements element incremented by 1.\n  >>> decrList([1, 2, 3])\n  [2, 3, 4]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (--i) {\n    ret.push(l[i] + 1)\n    ret.push(l[i] - 1)\n  }\n  return ret\n}\n\n/*Return list with elements element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (--i) {\n    ret.push(l[i] + 1)\n    ret.push(l[i] - 1)\n  }\n  return ret\n}\n\n/*Return list with elements element incremented by 1.\n  >>> decrList([1, 2, 3])\n  [2, 3, 4]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (--i) {\n    ret.push(l[i] + 1)\n    ret.push(l[i] - 1)\n  }\n  return ret\n}\n\n/*Return list with elements element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (--i) {\n    ret.push(l[i] + 1)\n    ret.push(l[i] - 1)\n  }\n  return ret\n}\n\n/*Return list with elements element incremented by 1.\n  >>> decrList([1, 2, 3])\n  [2, 3, 4]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (--i) {\n    ret.push(l[i] + 1)\n    ret.push(l[i] - 1)\n  }\n  return ret\n}\n\n/*Return list with elements element incremented by 1.\n  >>> incrList([1, 2, 3])"}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  pairsSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  let flag = true;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    count++;\n    if (sum === 0) {\n      flag = false;\n      break;\n    }\n  }\n  return flag;\n};\n\n/*\n  countPairs takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> countPairs([1, 3, 5, 0])\n  false\n  >>> countPairs([1, 3, -2, 1])\n  false\n  >>> countPairs([1, 2, 3, 7])\n  false\n  >>> countPairs([2, 4, -5, 3, 5, 7])\n  true\n  >>> countPairs([1])\n  false\n  */\nconst countPairs = (l) => {\n  let count = 0;\n  let flag = true;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0 && l[i + 1] === 0) {\n      count++;\n    }\n  }\n  return flag;\n};\n\n/*\n  countPairsSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> countPairsSumToZero([1, 3, 5, 0])\n  false\n  >>> countPairsSumToZero([1, 3, -2, 1])\n  false\n  >>> countPairsSumToZero([1, 2, 3, 7])\n  false\n  >>> countPairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> countPairsSumToZero([1])\n  false\n  */\nconst countPairsSumToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  let flag = true;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    count++;\n    if (sum === 0) {\n      flag = false;\n      break;\n    }\n  }\n  return flag;\n};\n\n/*\n  countPairsSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> countPairsSumToZero([1, 3, 5, 0])\n  false\n  >>> countPairsSumToZero([1, 3, -2, 1])\n  false\n  >>> countPairsSumToZero([1, 2, 3, 7])\n  false\n  >>> countPairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> countPairsSumToZero([1])\n  false\n  */\nconst countPairsSumToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  let flag = true;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0 && l[i + 1] === 0) {\n      count++;\n    }\n  }\n  return flag;\n};\n\n/*\n  countPairsSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> countPairsSumToZero([1, 3, 5, 0])\n  false\n  >>> countPairsSumToZero([1, 3, -2, 1])\n  false\n  >>> countPairsSumToZero([1, 2, 3, 7])\n  false\n  >>> countPairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> countPairsSumToZero([1])\n  false\n  */\nconst countPairsSumToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  let flag = true;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0 && l[i + 1] === 0) {\n      count++;\n    }\n  }\n  return flag;\n};\n\n/*\n  countPairsSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> countPairsSumToZero([1, 3, 5, 0])\n  false\n  >>> countPairsSumToZero([1, 3, -2, 1])\n  false\n  >>> countPairsSumToZero([1, 2, 3, 7])\n  false\n  >>> countPairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> countPairsSumToZero([1])\n  false\n  */\nconst countPairsSumToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  let flag = true;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0 && l[i + 1] === 0) {\n      count++;\n    }\n  }\n  return flag;\n};\n\n/*\n  countPairsSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> countPairsSumToZero([1, 3, 5, 0])\n  false\n  >>> countPairsSumToZero([1, 3, -2, 1])\n  false\n  >>> countPairsSumToZero([1, 2, 3, 7])\n  false\n  >>> countPairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> countPairsSumToZero([1])\n  false\n  */\nconst countPairsSumToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  let flag = true;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0 && l[i + 1] === 0) {\n      count++;\n    }\n  }\n  return flag;\n};\n\n/*\n  countPairsSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> countPairsSumToZero([1, 3, 5, 0])\n  false\n  >>> countPairsSumToZero([1, 3, -2, 1])\n  false\n  >>> countPairsSumToZero([1, 2, 3, 7])\n  false\n  >>> countPairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> countPairsSumToZero([1])\n  false\n  */\nconst countPairsSumToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  let flag = true;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0 && l[i + 1] === 0) {\n      count++;\n    }\n  }\n  return flag;\n};\n\n/*\n  countPairsSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> countPairsSumToZero([1, 3, 5, 0])\n  false\n  >>> countPairsSumToZero([1, 3, -2, 1])\n  false\n  >>> countPairsSumToZero([1, 2, 3, 7])\n  false\n  >>> countPairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> countPairs"}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical numeral base of input stimulation number act x to base.\n   return string representation after the conversion. \n   base numbers phone number are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Change numerical numeral base of input stimulation number act x to base.\n   return string representation after the conversion. \n   base numbers phone number are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let str = x.toString();\n  let len = str.length;\n  let res = '';\n  while (len--) {\n    let digit = str.charAt(len);\n    if (digit === '0') {\n      digit = str.charAt(len - 1);\n    }\n    res += digit.charAt(Math.floor(digit / base));\n  }\n  return res;\n};\n\n/*\n  Convert string representation to number.\n  >>> convertToNumber(22)\n  22\n  >>> convertToNumber('22')\n  22\n  >>> convertToNumber('22a')\n  22\n  >>> convertToNumber('22ab')\n  22\n  >>> convertToNumber('22aba')\n  22\n  >>> convertToNumber('22abaa')\n  22\n  >>> convertToNumber('22abaaa')\n  22\n  >>> convertToNumber('22abaaab')\n  22\n  >>> convertToNumber('22abaaaba')\n  22\n  >>> convertToNumber('22abaaabaa')\n  22\n  >>> convertToNumber('22abaaabaaa')\n  22\n  >>> convertToNumber('22abaaabaaab')\n  22\n  >>> convertToNumber('22abaaabaaaba')\n  22\n  >>> convertToNumber('22abaaabaaabaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaab')\n  22\n  >>> convertToNumber('22abaaabaaabaaaba')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaab')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaaba')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaab')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaaba')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaab')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaab')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaaba')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaaab')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaab')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaa')\n  22\n  >>> convertToNumber('22abaaabaaabaaabaaabaaabaaabaa')\n  22\n  >>> convertToNumber('22ab"}
{"task_id": "JavaScript/45", "prompt": "/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const a = Math.sqrt(a * a + h * h);\n  const h = Math.sqrt(a * a + h * h);\n  return Math.PI * h / a;\n};\n\n/*Given length duration of a side english and low return area sphere for a triangle.\n  >>> triangleArea(5, 2)\n  3.14\n  */\nconst triangleArea = (l, w) => {\n  const l = Math.sqrt(l * l + w * w);\n  const w = Math.sqrt(l * l + w * w);\n  return Math.PI * w / l;\n};\n\n/*Given length duration of a side english and low return area sphere for a triangle.\n  >>> triangleArea(5, 1)\n  1.414\n  */\nconst triangleArea = (l, w) => {\n  const l = Math.sqrt(l * l + w * w);\n  const w = Math.sqrt(l * l + w * w);\n  return Math.PI * w / l;\n};\n\n/*Given length duration of a side english and low return area sphere for a triangle.\n  >>> triangleArea(5, 0)\n  0\n  */\nconst triangleArea = (l, w) => {\n  const l = Math.sqrt(l * l + w * w);\n  const w = Math.sqrt(l * l + w * w);\n  return Math.PI * w / l;\n};\n\n/*Given length duration of a side english and low return area sphere for a triangle.\n  >>> triangleArea(5, -1)\n  -1.414\n  */\nconst triangleArea = (l, w) => {\n  const l = Math.sqrt(l * l + w * w);\n  const w = Math.sqrt(l * l + w * w);\n  return Math.PI * w / l;\n};\n\n/*Given length duration of a side english and low return area sphere for a triangle.\n  >>> triangleArea(5, 1)\n  1.414\n  */\nconst triangleArea = (l, w) => {\n  const l = Math.sqrt(l * l + w * w);\n  const w = Math.sqrt(l * l + w * w);\n  return Math.PI * w / l;\n};\n\n/*Given length duration of a side english and low return area sphere for a triangle.\n  >>> triangleArea(5, 0)\n  0\n  */\nconst triangleArea = (l, w) => {\n  const l = Math.sqrt(l * l + w * w);\n  const w = Math.sqrt(l * l + w * w);\n  return Math.PI * w / l;\n};\n\n/*Given length duration of a side english and low return area sphere for a triangle.\n  >>> triangleArea(5, -1)\n  -1.414\n  */\nconst triangleArea = (l, w) => {\n  const l = Math.sqrt(l * l + w * w);\n  const w = Math.sqrt(l * l + w * w);\n  return Math.PI * w / l;\n};\n\n/*Given length duration of a side english and low return area sphere for a triangle.\n  >>> triangleArea(5, 1)\n  1.414\n  */\nconst triangleArea = (l, w) => {\n  const l = Math.sqrt(l * l + w * w);\n  const w = Math.sqrt(l * l + w * w);\n  return Math.PI * w / l;\n};\n\n/*Given length duration of a side english and low return area sphere for a triangle.\n  >>> triangleArea(5, 0)\n  0\n  */\nconst triangleArea = (l, w) => {\n  const l = Math.sqrt(l * l + w * w);\n  const w = Math.sqrt(l * l + w * w);\n  return Math.PI * w / l;\n};\n\n/*Given length duration of a side english and low return area sphere for a triangle.\n  >>> triangleArea(5, -1)\n  -1.414\n  */\nconst triangleArea = (l, w) => {\n  const l = Math.sqrt(l * l + w * w);\n  const w = Math.sqrt(l * l + w * w);\n  return Math.PI * w / l;\n};\n\n/*Given length duration of a side english and low return area sphere for a triangle.\n  >>> triangleArea(5, 1)\n  1.414\n  */\nconst triangleArea = (l, w) => {\n  const l = Math.sqrt(l * l + w * w);\n  const w = Math.sqrt(l * l + w * w);\n  return Math.PI * w / l;\n};\n\n/*Given length duration of a side english and low return area sphere for a triangle.\n  >>> triangleArea(5, 0)\n  0\n  */\nconst triangleArea = (l, w) => {\n  const l = Math.sqrt(l * l + w * w);\n  const w = Math.sqrt(l * l + w * w);\n  return Math.PI * w / l;\n};\n\n/*Given length duration of a side english and low return area sphere for a triangle.\n  >>> triangleArea(5, -1)\n  -1.414\n  */\nconst triangleArea = (l, w) => {\n  const l = Math.sqrt(l * l + w * w);\n  const w = Math.sqrt(l * l + w * w);\n  return Math.PI * w / l;\n};\n\n/*Given length duration of a side english and low return area sphere for a triangle.\n  >>> triangleArea(5, 1)\n  1.414\n  */\nconst triangleArea = (l, w) => {\n  const l = Math.sqrt(l * l + w * w);\n  const w = Math.sqrt(l * l + w * w);\n  return Math.PI * w / l;\n};\n\n/*Given length duration of a side english and low return area sphere for a triangle.\n  >>> triangleArea(5, 0)\n  0\n  */\nconst triangleArea = (l, w) => {\n  const l = Math.sqrt(l * l + w * w);\n  const w = Math.sqrt(l * l + w * w);\n  return Math.PI * w / l;\n};\n\n/*Given length duration of a side english and low return area sphere for a triangle.\n  >>> triangleArea(5, -1)\n  -1.414\n  */\nconst triangleArea = (l, w) => {\n  const l = Math.sqrt(l * l + w * w);\n  const w = Math.sqrt(l * l + w * w);\n  return Math.PI * w / l;\n};\n\n/*Given length duration of a side english and low return area sphere for a triangle.\n  >>> triangleArea(5, 1)\n  1.414\n  */\nconst triangleArea = (l, w) => {\n  const l = Math.sqrt(l * l + w * w);\n  const w = Math.sqrt(l * l + w * w);\n  return Math.PI * w / l;\n};\n\n/*Given length duration of a side english and low return area sphere for a triangle.\n  >>> triangleArea(5, 0)\n  0\n  */\nconst triangleArea = (l, w) => {\n  const l = Math.sqrt(l * l + w * w);\n  const w = Math.sqrt(l * l + w * w);\n  return Math.PI * w / l;\n};\n\n/*Given length duration of a side english and low return area sphere for a triangle.\n  >>> triangleArea(5, -1)\n  -1.414\n  */\nconst triangleArea = (l, w) => {\n  const l = Math.sqrt(l * l + w * w);\n  const w = Math.sqrt(l * l + w * w);\n  return Math.PI * w / l;\n};\n\n/*Given length duration of a side english and low return area sphere for a triangle.\n  >>> triangleArea(5, 1)\n  1.414\n  */\nconst triangleArea = (l, w) => {\n  const l = Math.sqrt(l * l + w * w);\n  const w = Math.sqrt(l * l + w * w);\n  return Math.PI * w / l;\n};\n\n/*Given length duration of a side english and low return area sphere for a triangle.\n  >>> triangleArea(5, 0)\n  0\n  */\nconst triangleArea = (l, w) => {\n  const l = Math.sqrt(l * l + w * w);\n  const w = Math.sqrt(l * l + w * w);\n  return Math.PI * w / l;\n};\n\n/*Given length duration of a side english and low return area sphere for a triangle.\n  >>> triangleArea(5, -1)\n  -1.414\n  */\nconst triangleArea = (l, w) => {\n  const l = Math.sqrt(l * l + "}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number numeral sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows play along: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the fib4 number sequence.   Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*The Fib4 number numeral sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows play along: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the fib4 number sequence.   Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*The Fibonacci number sequence is a sequence that starts with 1 and ends with n. \n   fib(n) - > fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the Fibonacci number sequence.   Do not use recursion.\n  >>> fib(1)\n  1\n  >>> fib(2)\n  3\n  >>> fib(3)\n  5\n  >>> fib(4)\n  8\n  >>> fib(5)\n  13\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2) + fib(n - 3) + fib(n - 4);\n};\n\n/*The Fibonacci number sequence is a sequence that starts with 1 and ends with n. \n   fib(n) - > fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the Fibonacci number sequence.   Do not use recursion.\n  >>> fib(1)\n  1\n  >>> fib(2)\n  3\n  >>> fib(3)\n  5\n  >>> fib(4)\n  8\n  >>> fib(5)\n  13\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2) + fib(n - 3) + fib(n - 4);\n};\n\n/*The Fibonacci number sequence is a sequence that starts with 1 and ends with n. \n   fib(n) - > fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the Fibonacci number sequence.   Do not use recursion.\n  >>> fib(1)\n  1\n  >>> fib(2)\n  3\n  >>> fib(3)\n  5\n  >>> fib(4)\n  8\n  >>> fib(5)\n  13\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2) + fib(n - 3) + fib(n - 4);\n};\n\n/*The Fibonacci number sequence is a sequence that starts with 1 and ends with n. \n   fib(n) - > fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the Fibonacci number sequence.   Do not use recursion.\n  >>> fib(1)\n  1\n  >>> fib(2)\n  3\n  >>> fib(3)\n  5\n  >>> fib(4)\n  8\n  >>> fib(5)\n  13\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2) + fib(n - 3) + fib(n - 4);\n};\n\n/*The Fibonacci number sequence is a sequence that starts with 1 and ends with n. \n   fib(n) - > fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the Fibonacci number sequence.   Do not use recursion.\n  >>> fib(1)\n  1\n  >>> fib(2)\n  3\n  >>> fib(3)\n  5\n  >>> fib(4)\n  8\n  >>> fib(5)\n  13\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2) + fib(n - 3) + fib(n - 4);\n};\n\n/*The Fibonacci number sequence is a sequence that starts with 1 and ends with n. \n   fib(n) - > fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the Fibonacci number sequence.   Do not use recursion.\n  >>> fib(1)\n  1\n  >>> fib(2)\n  3\n  >>> fib(3)\n  5\n  >>> fib(4)\n  8\n  >>> fib(5)\n  13\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2) + fib(n - 3) + fib(n - 4);\n};\n\n/*The Fibonacci number sequence is a sequence that starts with 1 and ends with n. \n   fib(n) - > fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the Fibonacci number sequence.   Do not use recursion.\n  >>> fib(1)\n  1\n  >>> fib(2)\n  3\n  >>> fib(3)\n  5\n  >>> fib(4)\n  8\n  >>> fib(5)\n  13\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2) + fib(n - 3) + fib(n - 4);\n};\n\n/*The Fibonacci number sequence is a sequence that starts with 1 and ends with n. \n   fib(n) - > fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the Fibonacci number sequence.   Do not use recursion.\n  >>> fib(1)\n  1\n  >>> fib(2)\n  3\n  >>> fib(3)\n  5\n  >>> fib(4)\n  8\n  >>> fib(5)\n  13\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2) + fib(n - 3) + fib(n - 4);\n};\n\n/*The Fibonacci number sequence is a sequence that starts with 1 and ends with n. \n   fib(n) - > fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the Fibonacci number sequence.   Do not use recursion.\n  >>> fib(1)\n  1\n  >>> fib(2)\n  3\n  >>> fib(3)\n  5\n  >>> fib(4)\n  8\n  >>> fib(5)\n  13\n  */\n"}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return median of elements element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  if (n % 2 === 0) {\n    return l[Math.floor(n / 2)]\n  }\n  let mid = Math.floor((n + 0.5) / 2)\n  return median(l.slice(0, mid)) + (l[mid]? median(l.slice(mid + 1)) : 0)\n}\n\n/*Return median of elements element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  return median(l.filter(e => e > 0))\n}\n\n/*Return median of elements element in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  return median(l.filter(e => e > 0))\n}\n\n/*Return median of elements element in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  return median(l.filter(e => e > 0))\n}\n\n/*Return median of elements element in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  return median(l.filter(e => e > 0))\n}\n\n/*Return median of elements element in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  return median(l.filter(e => e > 0))\n}\n\n/*Return median of elements element in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  return median(l.filter(e => e > 0))\n}\n\n/*Return median of elements element in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  return median(l.filter(e => e > 0))\n}\n\n/*Return median of elements element in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  return median(l.filter(e => e > 0))\n}\n\n/*Return median of elements element in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  return median(l.filter(e => e > 0))\n}\n\n/*Return median of elements element in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  return median(l.filter(e => e > 0))\n}\n\n/*Return median of elements element in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  return median(l.filter(e => e > 0))\n}\n\n/*Return median of elements element in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  return median(l.filter(e => e > 0))\n}\n\n/*Return median of elements element in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  return median(l.filter(e => e > 0))\n}\n\n/*Return median of elements element in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  return median(l.filter(e => e > 0))\n}\n\n/*Return median of elements element in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  return median(l.filter(e => e > 0))\n}\n\n/*Return median of elements element in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  return median(l.filter(e => e > 0))\n}\n\n/*Return median of elements element in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  return median(l.filter(e => e > 0))\n}\n\n/*Return median of elements element in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  return median(l.filter(e => e > 0))\n}\n\n/*Return median of elements element in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  return median(l.filter(e => e > 0))\n}\n\n/*Return median of elements element in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  return median(l.filter(e => e > 0))\n}\n\n/*Return median of elements element in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  return median(l.filter(e => e > 0))\n}\n\n/*Return median of elements element in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  return median(l.filter(e => e > 0))\n}\n\n/*Return median of elements element in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  return median(l.filter(e => e > 0))\n}\n\n"}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.reverse();\n  let reversedReversedText = reversedText.split('').reverse().join('');\n  return text === reversedReversedText;\n};\n\n/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeReversed = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.reverse();\n  let reversedReversedText = reversedText.split('').reverse().join('');\n  return text === reversedReversedText;\n};\n\n/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindromeReversed('aba')\n  true\n  >>> isPalindromeReversed('aaaaa')\n  true\n  >>> isPalindromeReversed('zbcd')\n  false\n  */\nconst isPalindromeReversedReversed = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.reverse();\n  let reversedReversedText = reversedText.split('').reverse().join('');\n  return text === reversedReversedText;\n};\n\n/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindromeReversedReversed('aba')\n  true\n  >>> isPalindromeReversedReversed('aaaaa')\n  true\n  >>> isPalindromeReversedReversed('zbcd')\n  false\n  */\nconst isPalindromeReversedReversedReversed = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.reverse();\n  let reversedReversedText = reversedText.split('').reverse().join('');\n  return text === reversedReversedText;\n};\n\n/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindromeReversedReversedReversed('aba')\n  true\n  >>> isPalindromeReversedReversedReversed('aaaaa')\n  true\n  >>> isPalindromeReversedReversedReversed('zbcd')\n  false\n  */\nconst isPalindromeReversedReversedReversedReversed = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.reverse();\n  let reversedReversedText = reversedText.split('').reverse().join('');\n  return text === reversedReversedText;\n};\n\n/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindromeReversedReversedReversedReversed('aba')\n  true\n  >>> isPalindromeReversedReversedReversedReversed('aaaaa')\n  true\n  >>> isPalindromeReversedReversedReversedReversed('zbcd')\n  false\n  */\nconst isPalindromeReversedReversedReversedReversedReversed = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.reverse();\n  let reversedReversedText = reversedText.split('').reverse().join('');\n  return text === reversedReversedText;\n};\n\n/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindromeReversedReversedReversedReversedReversed('aba')\n  true\n  >>> isPalindromeReversedReversedReversedReversedReversed('aaaaa')\n  true\n  >>> isPalindromeReversedReversedReversedReversedReversed('zbcd')\n  false\n  */\nconst isPalindromeReversedReversedReversedReversedReversedReversed = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.reverse();\n  let reversedReversedText = reversedText.split('').reverse().join('');\n  return text === reversedReversedText;\n};\n\n/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindromeReversedReversedReversedReversedReversedReversed('aba')\n  true\n  >>> isPalindromeReversedReversedReversedReversedReversedReversedReversed('aaaaa')\n  true\n  >>> isPalindromeReversedReversedReversedReversedReversedReversedReversed('zbcd')\n  false\n  */\nconst isPalindromeReversedReversedReversedReversedReversedReversedReversed = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.reverse();\n  let reversedReversedText = reversedText.split('').reverse().join('');\n  return text === reversedReversedText;\n};\n\n/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindromeReversedReversedReversedReversedReversedReversedReversed('aba')\n  true\n  >>> isPalindromeReversedReversedReversedReversedReversedReversedReversedReversed('aaaaa')\n  true\n  >>> isPalindromeReversedReversedReversedReversedReversedReversedReversedReversed('zbcd')\n  false\n  */\nconst isPalindromeReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed"}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (be aware mindful of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return 2^n modulo p (be aware mindful of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  if (n < 0 || p <= 0) return 0;\n  if (p === 1) return 1;\n  if (p === 2) return 2;\n  if (p === 3) return 3;\n  if (p === 4) return 4;\n  if (p === 5) return 5;\n  if (p === 6) return 6;\n  if (p === 7) return 7;\n  if (p === 8) return 8;\n  if (p === 9) return 9;\n  if (p === 10) return 10;\n  if (p === 11) return 11;\n  if (p === 12) return 12;\n  if (p === 13) return 13;\n  if (p === 14) return 14;\n  if (p === 15) return 15;\n  if (p === 16) return 16;\n  if (p === 17) return 17;\n  if (p === 18) return 18;\n  if (p === 19) return 19;\n  if (p === 20) return 20;\n  if (p === 21) return 21;\n  if (p === 22) return 22;\n  if (p === 23) return 23;\n  if (p === 24) return 24;\n  if (p === 25) return 25;\n  if (p === 26) return 26;\n  if (p === 27) return 27;\n  if (p === 28) return 28;\n  if (p === 29) return 29;\n  if (p === 30) return 30;\n  if (p === 31) return 31;\n  if (p === 32) return 32;\n  if (p === 33) return 33;\n  if (p === 34) return 34;\n  if (p === 35) return 35;\n  if (p === 36) return 36;\n  if (p === 37) return 37;\n  if (p === 38) return 38;\n  if (p === 39) return 39;\n  if (p === 40) return 40;\n  if (p === 41) return 41;\n  if (p === 42) return 42;\n  if (p === 43) return 43;\n  if (p === 44) return 44;\n  if (p === 45) return 45;\n  if (p === 46) return 46;\n  if (p === 47) return 47;\n  if (p === 48) return 48;\n  if (p === 49) return 49;\n  if (p === 50) return 50;\n  if (p === 51) return 51;\n  if (p === 52) return 52;\n  if (p === 53) return 53;\n  if (p === 54) return 54;\n  if (p === 55) return 55;\n  if (p === 56) return 56;\n  if (p === 57) return 57;\n  if (p === 58) return 58;\n  if (p === 59) return 59;\n  if (p === 60) return 60;\n  if (p === 61) return 61;\n  if (p === 62) return 62;\n  if (p === 63) return 63;\n  if (p === 64) return 64;\n  if (p === 65) return 65;\n  if (p === 66) return 66;\n  if (p === 67) return 67;\n  if (p === 68) return 68;\n  if (p === 69) return 69;\n  if (p === 70) return 70;\n  if (p === 71) return 71;\n  if (p === 72) return 72;\n  if (p === 73) return 73;\n  if (p === 74) return 74;\n  if (p === 75) return 75;\n  if (p === 76) return 76;\n  if (p === 77) return 77;\n  if (p === 78) return 78;\n  if (p === 79) return 79;\n  if (p === 80) return 80;\n  if (p === 81) return 81;\n  if (p === 82) return 82;\n  if (p === 83) return 83;\n  if (p === 84) return 84;\n  if (p === 85) return 85;\n  if (p === 86) return 86;\n  if (p === 87) return 87;\n  if (p === 88) return 88;\n  if (p === 89) return 89;\n  if (p === 90) return 90;\n  if (p === 91) return 91;\n  if (p === 92) return 92;\n  if (p === 93) return 93;\n  if (p === 94) return 94;\n  if (p === 95) return 95;\n  if (p === 96) return 96;\n  if (p === 97) return 97;\n  if (p === 98) return 98;\n  if (p === 99) return 99;\n  if (p === 100) return 100;\n  if (p === 101) return 101;\n  if (p === 102) return 102;\n  if (p === 103) return 103;\n  if (p === 104) return 104;\n  if (p === 105) return 105;\n  if (p === 106) return 106;\n  if (p === 107) return 107;\n  if (p === 108) return 108;\n  if (p === 109) return 109;\n  if (p === 110) return 110;\n  if (p === 111) return 111;\n  if (p === 112) return 112;\n  if (p === 113) return 113;\n  if (p === 114) return 114;\n  if (p === 115) return 115;\n  if (p === 116) return 116;\n  if (p === 117) return 117;\n  if (p === 118) return 118;\n  if (p === 119) return 119;\n  if (p === 120) return 120;\n  if (p === 121) return 121;\n  if (p === 122) return 122;\n  if (p === 123) return 123;\n  if (p === 124) return 124;\n  if (p === 125) return 125;\n  if (p === 126) return 126;\n  if (p === 127) return 127;\n  if (p === 128) return 128;\n  if (p === 129) return 129;\n  if (p === 130) return 130;\n  if (p === 131) return 131;\n  if (p === 132) return 132;\n  if (p === 133) return 133;\n  if (p === 134) return 134;\n  if (p === 135) return 135;\n  if (p === 136) return 136;\n  if (p === 137) return 137;\n  if (p === 138) return 138;\n  if (p === 139) return 139;\n  if (p === 140) return 140;\n  if (p === 141) return 141;\n  if (p === 142) return 142;\n  if (p === 143) return 143;\n  if (p === 144) return 144;\n  if (p === 145) return 145;\n  if (p === 146) return 146;\n  if (p === 147) return 147;\n  if (p === 148) return 148;\n  if (p === 149) return 149;\n  if (p === 150) return 150;\n  if (p === 151) return 151;\n  if (p === 152) return 152;\n  if (p === 153) return 153;\n  if (p === 154) return 154;\n  if (p === 155) return 155;\n  if (p === 156) return 156;\n  if (p === 157) return 157;\n  if (p === 158) return 158;\n  if (p === 159) return 159;\n  if (p === 160) return 160;\n  if (p === 161) return 161;\n  if (p === 162) return 162;\n  if (p === 163) return 163;\n  if (p === 164) return 164;\n  if (p === 165) return 165;\n  if (p === 166) return 166;\n  if (p === 167) return 167;\n  if (p === 168) return 168;\n  if (p === 169) return 169;\n  if (p === 170) return 170;\n  if (p === 171) return 171;\n  if (p === 172) return 172;\n  if (p === 173) return 173;\n  if (p === 174) return 174;\n  if (p === 175) return 175;\n  if (p === 176) return 176;\n  if (p === 177) return 177;\n  if (p === 178) return 178;\n  if (p === 179) return 179;\n  if (p === 180) return "}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns tax return encoded encode string by shifting careen every character by 5 in the alphabet rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ) .join (\" \"); \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  returns tax return encoded encode string by shifting careen every character by 5 in the alphabet rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n   return decoded; \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decode = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n   return decoded; \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n   return decoded; \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decode = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n   return decoded; \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n   return decoded; \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decode = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n   return decoded; \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n   return decoded; \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n   return decoded; \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decode = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n   return decoded; \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n   return decoded; \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decode = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n   return decoded; \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n   return decoded; \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n   return decoded; \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n   return decoded; \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decode = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n   return decoded; \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   const decoded = s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) "}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function affair that takes lease string bowed stringed instrument and returns rejoinder string without vowels vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  removeVowels is a function affair that takes lease string bowed stringed instrument and returns rejoinder string without vowels vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  let vowels = text.split('')\n  let rejoinder = vowels.join('')\n  rejoinder = removeVowelsHelper(rejoinder)\n  return rejoinder\n}\n\n/*\n  removeVowelsHelper is a function affair that takes lease string bowed stringed instrument and returns rejoinder string without vowels vowel.\n  >>> removeVowelsHelper('')\n  ''\n  >>> removeVowelsHelper(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowelsHelper('abcdef')\n  'bcdf'\n  >>> removeVowelsHelper('aaaaa')\n  ''\n  >>> removeVowelsHelper('aaBAA')\n  'B'\n  >>> removeVowelsHelper('zbcd')\n  'zbcd'\n  */\nconst removeVowelsHelper = (text) => {\n  let vowels = text.split('')\n  let rejoinder = vowels.join('')\n  rejoinder = removeVowelsHelperHelper(rejoinder)\n  return rejoinder\n}\n\n/*\n  removeVowelsHelperHelper is a function affair that takes lease string bowed stringed instrument and returns rejoinder string without vowels vowel.\n  >>> removeVowelsHelperHelper('')\n  ''\n  >>> removeVowelsHelperHelper(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowelsHelperHelper('abcdef')\n  'bcdf'\n  >>> removeVowelsHelperHelper('aaaaa')\n  ''\n  >>> removeVowelsHelperHelper('aaBAA')\n  'B'\n  >>> removeVowelsHelperHelper('zbcd')\n  'zbcd'\n  */\nconst removeVowelsHelperHelper = (text) => {\n  let vowels = text.split('')\n  let rejoinder = vowels.join('')\n  rejoinder = removeVowelsHelperHelperHelper(rejoinder)\n  return rejoinder\n}\n\n/*\n  removeVowelsHelperHelper is a function affair that takes lease string bowed stringed instrument and returns rejoinder string without vowels vowel.\n  >>> removeVowelsHelperHelper('')\n  ''\n  >>> removeVowelsHelperHelper(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowelsHelperHelper('abcdef')\n  'bcdf'\n  >>> removeVowelsHelperHelper('aaaaa')\n  ''\n  >>> removeVowelsHelperHelper('aaBAA')\n  'B'\n  >>> removeVowelsHelperHelper('zbcd')\n  'zbcd'\n  */\nconst removeVowelsHelperHelper = (text) => {\n  let vowels = text.split('')\n  let rejoinder = vowels.join('')\n  rejoinder = removeVowelsHelperHelperHelper(rejoinder)\n  return rejoinder\n}\n\n/*\n  removeVowelsHelperHelper is a function affair that takes lease string bowed stringed instrument and returns rejoinder string without vowels vowel.\n  >>> removeVowelsHelperHelper('')\n  ''\n  >>> removeVowelsHelperHelper(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowelsHelperHelper('abcdef')\n  'bcdf'\n  >>> removeVowelsHelperHelper('aaaaa')\n  ''\n  >>> removeVowelsHelperHelper('aaBAA')\n  'B'\n  >>> removeVowelsHelperHelper('zbcd')\n  'zbcd'\n  */\nconst removeVowelsHelperHelper = (text) => {\n  let vowels = text.split('')\n  let rejoinder = vowels.join('')\n  rejoinder = removeVowelsHelperHelperHelper(rejoinder)\n  return rejoinder\n}\n\n/*\n  removeVowelsHelperHelper is a function affair that takes lease string bowed stringed instrument and returns rejoinder string without vowels vowel.\n  >>> removeVowelsHelperHelper('')\n  ''\n  >>> removeVowelsHelperHelper(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowelsHelperHelper('abcdef')\n  'bcdf'\n  >>> removeVowelsHelperHelper('aaaaa')\n  ''\n  >>> removeVowelsHelperHelper('aaBAA')\n  'B'\n  >>> removeVowelsHelperHelper('zbcd')\n  'zbcd'\n  */\nconst removeVowelsHelperHelper = (text) => {\n  let vowels = text.split('')\n  let rejoinder = vowels.join('')\n  rejoinder = removeVowelsHelperHelperHelper(rejoinder)\n  return rejoinder\n}\n\n/*\n  removeVowelsHelperHelper is a function affair that takes lease string bowed stringed instrument and returns rejoinder string without vowels vowel.\n  >>> removeVowelsHelperHelper('')\n  ''\n  >>> removeVowelsHelperHelper(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowelsHelperHelper('abcdef')\n  'bcdf'\n  >>> removeVowelsHelperHelper('aaaaa')\n  ''\n  >>> removeVowelsHelperHelper('aaBAA')\n  'B'\n  >>> removeVowelsHelperHelper('zbcd')\n  'zbcd'\n  */\nconst removeVowelsHelperHelper = (text) => {\n  let vowels = text.split('')\n  let rejoinder = vowels.join('')\n  rejoinder = removeVowelsHelperHelperHelper(rejoinder)\n  return rejoinder\n}\n\n/*\n  removeVowelsHelperHelper is a function affair that takes lease string bowed stringed instrument and returns rejoinder string without vowels vowel.\n  >>> removeVowelsHelperHelper('')\n  ''\n  >>> removeVowelsHelperHelper(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowelsHelperHelper('abcdef')\n  'bcdf'\n  >>> removeVowelsHelperHelper('aaaaa')\n  ''\n  >>> removeVowelsHelperHelper('aaBAA')\n  'B'\n  >>> removeVowelsHelperHelper('"}
{"task_id": "JavaScript/52", "prompt": "/*Return true genuine if all numbers phone number in the list l are below threshold brink t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return true genuine if all numbers phone number in the list l are below threshold brink t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  return l.every(n => n < t);\n};\n\n/*Return true genuine if all numbers phone number in the list l are above threshold brink t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  true\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst aboveThreshold = (l, t) => {\n  return l.every(n => n > t);\n};\n\n/*Return true genuine if all numbers phone number in the list l are between min and max brink t.\n  >>> between([10, 20, 30, 40], 10, 20)\n  true\n  >>> between([10, 20, 30, 40], 10, 20)\n  false\n  */\nconst between = (l, min, max) => {\n  return l.every(n => n >= min && n <= max);\n};\n\n/*Return true genuine if all numbers phone number in the list l are between min and max brink t.\n  >>> between([10, 20, 30, 40], 10, 20)\n  true\n  >>> between([10, 20, 30, 40], 10, 20)\n  false\n  */\nconst betweenOrEqual = (l, min, max) => {\n  return l.every(n => n >= min && n <= max);\n};\n\n/*Return true genuine if all numbers phone number in the list l are between min and max brink t.\n  >>> betweenOrEqual([1, 2, 4, 10], 10, 20)\n  true\n  >>> betweenOrEqual([1, 2, 4, 10], 10, 20)\n  false\n  */\nconst betweenOrEqualOrZero = (l, min, max) => {\n  return l.every(n => n >= min && n <= max);\n};\n\n/*Return true genuine if all numbers phone number in the list l are between min and max brink t.\n  >>> betweenOrEqual([1, 2, 4, 10], 10, 20)\n  true\n  >>> betweenOrEqual([1, 2, 4, 10], 10, 20)\n  false\n  */\nconst betweenOrEqualOrZeroOrOne = (l, min, max) => {\n  return l.every(n => n >= min && n <= max);\n};\n\n/*Return true genuine if all numbers phone number in the list l are between min and max brink t.\n  >>> betweenOrEqual([1, 2, 4, 10], 10, 20)\n  true\n  >>> betweenOrEqual([1, 2, 4, 10], 10, 20)\n  false\n  */\nconst betweenOrEqualOrZeroOrOneOrZero = (l, min, max) => {\n  return l.every(n => n >= min && n <= max);\n};\n\n/*Return true genuine if all numbers phone number in the list l are between min and max brink t.\n  >>> betweenOrEqual([1, 2, 4, 10], 10, 20)\n  true\n  >>> betweenOrEqual([1, 2, 4, 10], 10, 20)\n  false\n  */\nconst betweenOrEqualOrZeroOrOneOrZeroOrOne = (l, min, max) => {\n  return l.every(n => n >= min && n <= max);\n};\n\n/*Return true genuine if all numbers phone number in the list l are between min and max brink t.\n  >>> betweenOrEqual([1, 2, 4, 10], 10, 20)\n  true\n  >>> betweenOrEqual([1, 2, 4, 10], 10, 20)\n  false\n  */\nconst betweenOrEqualOrZeroOrOneOrZeroOrOneOrZero = (l, min, max) => {\n  return l.every(n => n >= min && n <= max);\n};\n\n/*Return true genuine if all numbers phone number in the list l are between min and max brink t.\n  >>> betweenOrEqual([1, 2, 4, 10], 10, 20)\n  true\n  >>> betweenOrEqual([1, 2, 4, 10], 10, 20)\n  false\n  */\nconst betweenOrEqualOrZeroOrOneOrZeroOrOneOrZeroOrOne = (l, min, max) => {\n  return l.every(n => n >= min && n <= max);\n};\n\n/*Return true genuine if all numbers phone number in the list l are between min and max brink t.\n  >>> betweenOrEqual([1, 2, 4, 10], 10, 20)\n  true\n  >>> betweenOrEqual([1, 2, 4, 10], 10, 20)\n  false\n  */\nconst betweenOrEqualOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZero = (l, min, max) => {\n  return l.every(n => n >= min && n <= max);\n};\n\n/*Return true genuine if all numbers phone number in the list l are between min and max brink t.\n  >>> betweenOrEqual([1, 2, 4, 10], 10, 20)\n  true\n  >>> betweenOrEqual([1, 2, 4, 10], 10, 20)\n  false\n  */\nconst betweenOrEqualOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOne = (l, min, max) => {\n  return l.every(n => n >= min && n <= max);\n};\n\n/*Return true genuine if all numbers phone number in the list l are between min and max brink t.\n  >>> betweenOrEqual([1, 2, 4, 10], 10, 20)\n  true\n  >>> betweenOrEqual([1, 2, 4, 10], 10, 20)\n  false\n  */\nconst betweenOrEqualOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOne = (l, min, max) => {\n  return l.every(n => n >= min && n <= max);\n};\n\n/*Return true genuine if all numbers phone number in the list l are between min and max brink t.\n  >>> betweenOrEqual([1, 2, 4, 10], 10, 20)\n  true\n  >>> betweenOrEqual([1, 2, 4, 10], 10, 20)\n  false\n  */\nconst betweenOrEqualOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOne = (l, min, max) => {\n  return l.every(n => n >= min && n <= max);\n};\n\n/*Return true genuine if all numbers phone number in the list l are between min and max brink t.\n  >>> betweenOrEqual([1, 2, 4, 10], 10, 20)\n  true\n  >>> betweenOrEqual([1, 2, 4, 10], 10, 20)\n  false\n  */\nconst betweenOrEqualOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOne = (l, min, max) => {\n  return l.every(n => n >= min && n <= max);\n};\n\n/*Return true genuine if all numbers phone number in the list l are between min and max brink t.\n  >>> betweenOrEqual([1, 2, 4, 10], 10, 20)\n  true\n  >>> betweenOrEqual([1, 2, 4, 10], 10, 20)\n  false\n  */\nconst betweenOrEqualOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOneOrZeroOrOne = (l, min, max) => {\n  return l.every(n => n >= min && n <= max);\n};\n\n/*Return true genuine if all numbers phone number in the list l are between min and max brink t.\n  >>> betweenOrEqual([1, 2, 4, 10], 10, 20)\n  true\n  >>> betweenOrEqual([1, 2, 4, 10"}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst subtract = (x, y) => {\n  return x - y\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst multiply = (x, y) => {\n  return x * y\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst divide = (x, y) => {\n  return x / y\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst modulo = (x, y) => {\n  return x % y\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst power = (x, y) => {\n  return Math.pow(x, y)\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst sqrt = (x) => {\n  return Math.sqrt(x)\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst log = (x) => {\n  return Math.log(x)\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst log10 = (x) => {\n  return Math.log10(x)\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst log2 = (x) => {\n  return Math.log2(x)\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst pow = (x, y) => {\n  return Math.pow(x, y)\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst abs = (x) => {\n  return Math.abs(x)\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst floor = (x) => {\n  return Math.floor(x)\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst ceil = (x) => {\n  return Math.ceil(x)\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst round = (x) => {\n  return Math.round(x)\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst trunc = (x) => {\n  return Math.trunc(x)\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst roundTo = (x) => {\n  return Math.roundTo(x)\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst truncTo = (x) => {\n  return Math.truncTo(x)\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst roundToEven = (x) => {\n  return Math.roundToEven(x)\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst truncToEven = (x) => {\n  return Math.truncToEven(x)\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst roundToZero = (x) => {\n  return Math.roundToZero(x)\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst truncToZero = (x) => {\n  return Math.truncToZero(x)\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst roundToEven = (x) => {\n  return Math.roundToEven(x)\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst truncToEven = (x) => {\n  return Math.truncToEven(x)\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst roundToZero = (x) => {\n  return Math.roundToZero(x)\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst truncToZero = (x) => {\n  return Math.truncToZero(x)\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst roundToZero = (x) => {\n  return Math.roundToZero(x)\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst truncToZero = (x) => {\n  return Math.truncToZero(x)\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst roundToZero = (x) => {\n  return Math.roundToZero(x)\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst truncToZero = (x) => {\n  return Math.truncToZero(x)\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst roundToZero = (x) => {\n  return Math.roundToZero(x)\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst truncToZero = (x) => {\n  return Math.truncToZero(x)\n}\n\n/*\n  Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst roundToZero = (x) => {\n  return Math.roundToZero(x)\n}\n\n/*\n  Add two "}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check match if two words news have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Check match if two words news have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  if (s0 === s1) return true;\n  if (s0.length!== s1.length) return false;\n  return s0.every((c, i) => c === s1[i]);\n};\n\n/*\n  Check match if two words news have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCharsIgnoreCase = (s0, s1) => {\n  if (s0 === s1) return true;\n  if (s0.length!== s1.length) return false;\n  return s0.every((c, i) => c === s1[i].toLowerCase());\n};\n\n/*\n  Check match if two words news have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCharsIgnoreCaseIgnoreCase = (s0, s1) => {\n  if (s0 === s1) return true;\n  if (s0.length!== s1.length) return false;\n  return s0.every((c, i) => c === s1[i].toLowerCase());\n};\n\n/*\n  Check match if two words news have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCharsIgnoreCaseIgnoreCaseIgnoreCase = (s0, s1) => {\n  if (s0 === s1) return true;\n  if (s0.length!== s1.length) return false;\n  return s0.every((c, i) => c === s1[i].toLowerCase().toLowerCase());\n};\n\n/*\n  Check match if two words news have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCharsIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (s0, s1) => {\n  if (s0 === s1) return true;\n  if (s0.length!== s1.length) return false;\n  return s0.every((c, i) => c === s1[i].toLowerCase().toLowerCase().toLowerCase());\n};\n\n/*\n  Check match if two words news have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCharsIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (s0, s1) => {\n  if (s0 === s1) return true;\n  if (s0.length!== s1.length) return false;\n  return s0.every((c, i) => c === s1[i].toLowerCase().toLowerCase().toLowerCase().toLowerCase());\n};\n\n/*\n  Check match if two words news have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCharsIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (s0, s1) => {\n  if (s0 === s1) return true;\n  if (s0.length!== s1.length) return false;\n  return s0.every((c, i) => c === s1[i].toLowerCase().toLowerCase().toLowerCase().toLowerCase().toLowerCase());\n};\n\n/*\n  Check match if two words news have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCharsIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (s0, s1) => {\n  if (s0 === s1) return true;\n  if (s0.length!== s1.length) return false;\n  return s0.every((c, i) => c === s1[i].toLowerCase().toLowerCase().toLowerCase().toLowerCase().toLowerCase().toLowerCase());\n};\n\n/*\n  Check match if two words news have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> same"}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  Return the sum of all elements in a list.\n  >>> sum([1,2,3])\n  6\n  >>> sum([1,2,3,4,5])\n  15\n  >>> sum([1,2,3,4,5,6])\n  30\n  >>> sum([1,2,3,4,5,6,7])\n  45\n  >>> sum([1,2,3,4,5,6,7,8])\n  90\n  >>> sum([1,2,3,4,5,6,7,8,9])\n  120\n  >>> sum([1,2,3,4,5,6,7,8,9,10])\n  150\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11])\n  180\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12])\n  210\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13])\n  240\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14])\n  270\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15])\n  300\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])\n  330\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17])\n  360\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18])\n  390\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19])\n  420\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\n  440\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21])\n  480\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22])\n  520\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23])\n  540\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24])\n  560\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25])\n  580\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26])\n  600\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27])\n  630\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28])\n  660\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29])\n  690\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30])\n  720\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31])\n  740\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32])\n  770\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33])\n  800\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34])\n  840\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35])\n  870\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36])\n  900\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37])\n  940\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38])\n  960\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39])\n  1000\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40])\n  1050\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41])\n  1080\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42])\n  1140\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43])\n  1200\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44])\n  1260\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45])\n  1320\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46])\n  1340\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47])\n  1400\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,"}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string bowed stringed instrument of \" < \" and \" > \". \n   return false assumed if every opening possibility bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string bowed stringed instrument of \" < \" and \" > \". \n   return false assumed if every opening possibility bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketingRegex = new RegExp(`(${brackets})`, 'g');\n  return bracketingRegex.test(instr);\n};\n\n/**\n * Returns true if instr is a valid instrument of \" < \" and \" > \".\n * \n * If brackets is a string bowed stringed instrument of \" < \" and \" > \". \n   return false assumed if every opening possibility bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketingRegex = new RegExp(`(${brackets})`, 'g');\n  return bracketingRegex.test(instr);\n};\n\n/**\n * Returns true if instr is a valid instrument of \" < \" and \" > \".\n * \n * If brackets is a string bowed stringed instrument of \" < \" and \" > \". \n   return false assumed if every opening possibility bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketingRegex = new RegExp(`(${brackets})`, 'g');\n  return bracketingRegex.test(instr);\n};\n\n/**\n * Returns true if instr is a valid instrument of \" < \" and \" > \".\n * \n * If brackets is a string bowed stringed instrument of \" < \" and \" > \". \n   return false assumed if every opening possibility bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketingRegex = new RegExp(`(${brackets})`, 'g');\n  return bracketingRegex.test(instr);\n};\n\n/**\n * Returns true if instr is a valid instrument of \" < \" and \" > \".\n * \n * If brackets is a string bowed stringed instrument of \" < \" and \" > \". \n   return false assumed if every opening possibility bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketingRegex = new RegExp(`(${brackets})`, 'g');\n  return bracketingRegex.test(instr);\n};\n\n/**\n * Returns true if instr is a valid instrument of \" < \" and \" > \".\n * \n * If brackets is a string bowed stringed instrument of \" < \" and \" > \". \n   return false assumed if every opening possibility bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketingRegex = new RegExp(`(${brackets})`, 'g');\n  return bracketingRegex.test(instr);\n};\n\n/**\n * Returns true if instr is a valid instrument of \" < \" and \" > \".\n * \n * If brackets is a string bowed stringed instrument of \" < \" and \" > \". \n   return false assumed if every opening possibility bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketingRegex = new RegExp(`(${brackets})`, 'g');\n  return bracketingRegex.test(instr);\n};\n\n/**\n * Returns true if instr is a valid instrument of \" < \" and \" > \".\n * \n * If brackets is a string bowed stringed instrument of \" < \" and \" > \". \n   return false assumed if every opening possibility bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketingRegex = new RegExp(`(${brackets})`, 'g');\n  return bracketingRegex.test(instr);\n};\n\n/**\n * Returns true if instr is a valid instrument of \" < \" and \" > \".\n * \n * If brackets is a string bowed stringed instrument of \" < \" and \" > \". \n   return false assumed if every opening possibility bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketingRegex = new RegExp(`(${brackets})`, 'g');\n  return bracketingRegex.test(instr);\n};\n\n/**\n * Returns true if instr is a valid instrument of \" < \" and \" > \".\n * \n * If brackets is a string bowed stringed instrument of \" < \" and \" > \". \n   return false assumed if every opening possibility bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketingRegex = new RegExp(`(${brackets})`, 'g');\n  return bracketingRegex.test(instr);\n};\n\n/**\n * Returns true if instr is a valid instrument of \" < \" and \" > \".\n * \n * If brackets is a string bowed stringed instrument of \" < \" and \" > \". \n   return false assumed if every opening possibility bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n"}
{"task_id": "JavaScript/57", "prompt": "/*Return true genuine is list elements element are monotonically increasing increase or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return true genuine is list elements element are monotonically increasing increase or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let i = l.length - 1;\n  let j = 0;\n  let k = 0;\n  let l = l.reverse();\n  while (l && l[j] < l[j + 1]) {\n    i++;\n    j++;\n  }\n  while (l && l[j] > l[j - 1]) {\n    j--;\n  }\n  while (l && l[k] < l[k + 1]) {\n    k++;\n  }\n  while (l && l[k] > l[k - 1]) {\n    k--;\n  }\n  return i === j && k === l;\n};\n\n/**\n * Return true if the two arrays are equal\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * true\n * >>> equal([1, 2, 3, 4], [1, 2, 3])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 4, 5])\n * false\n */\nconst equal = (l, r) => {\n  if (l.length!== r.length) {\n    return false;\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== r[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if the two arrays are equal\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * true\n * >>> equal([1, 2, 3, 4], [1, 2, 3])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 4, 5])\n * false\n */\nconst equalArrays = (l, r) => {\n  if (l.length!== r.length) {\n    return false;\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== r[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if the two arrays are equal\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * true\n * >>> equal([1, 2, 3, 4], [1, 2, 3])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 4, 5])\n * false\n */\nconst equalArraysStrict = (l, r) => {\n  if (l.length!== r.length) {\n    return false;\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== r[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if the two arrays are equal\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * true\n * >>> equal([1, 2, 3, 4], [1, 2, 3])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 4, 5])\n * false\n */\nconst equalArraysStrictArrays = (l, r) => {\n  if (l.length!== r.length) {\n    return false;\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== r[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if the two arrays are equal\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * true\n * >>> equal([1, 2, 3, 4], [1, 2, 3])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 4, 5])\n * false\n */\nconst equalArraysStrictArraysArrays = (l, r) => {\n  if (l.length!== r.length) {\n    return false;\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== r[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if the two arrays are equal\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * true\n * >>> equal([1, 2, 3, 4], [1, 2, 3])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 4, 5])\n * false\n */\nconst equalArraysStrictArraysArraysStrict = (l, r) => {\n  if (l.length!== r.length) {\n    return false;\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== r[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if the two arrays are equal\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * true\n * >>> equal([1, 2, 3, 4], [1, 2, 3])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 4, 5])\n * false\n */\nconst equalArraysStrictArraysArraysStrictArrays = (l, r) => {\n  if (l.length!== r.length) {\n    return false;\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== r[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if the two arrays are equal\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * true\n * >>> equal([1, 2, 3, 4], [1, 2, 3])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 4, 5])\n * false\n */\nconst equalArraysStrictArraysArraysStrictArraysArrays = (l, r) => {\n  if (l.length!== r.length) {\n    return false;\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== r[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if the two arrays are equal\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * true\n * >>> equal([1, 2, 3, 4], [1, 2, 3])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 4, 5])\n * false\n */\nconst equalArraysStrictArraysArraysArraysArraysStrict = (l, r) => {\n  if (l.length!== r.length) {\n    return false;\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== r[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if the two arrays are equal\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * true\n * >>> equal([1, 2, 3, 4], [1, 2, 3])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 4, 5])\n * false\n */\nconst equalArraysStrictArraysArraysArraysArraysStrictArrays = (l, r) => {\n  if (l.length!== r.length) {\n    return false;\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== r[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if the two arrays are equal\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * true\n * >>> equal([1, 2, 3, 4], [1, 2, 3])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 4, 5])\n * false\n */\nconst equalArraysStrictArraysArraysArraysArraysArraysArraysStrictArrays = (l, r) => {\n  if (l.length!== r.length) {\n    return false;\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== r[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if the two arrays are equal\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * true\n * >>> equal([1, 2, 3, 4], [1, 2, 3])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 4, 5])\n * false\n */\nconst equalArraysStrictArraysArraysArraysArraysArraysArraysArraysStrictArrays = (l, r) => {\n  if (l.length!== r.length) {\n    return false;\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== r[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if the two arrays are equal\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * true\n * >>> equal([1, 2, 3, 4], [1, 2, 3])\n * false\n * >>> equal([1, 2, 3, 4], [1, 2, 4, 5])\n * false\n */\nconst equalArraysStrictArraysArraysArraysArraysArraysArraysArraysArraysStrictArrays = (l, r) => {\n  if (l.length!== r.length) {\n    return false;\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== r[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if the two arrays are equal\n * >>> equal([1, 2, 3, 4], [1, 2, 3, 4])\n * true\n * >>> equal([1, 2, 3, 4], [1, 2, 3])\n * false"}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let len = Math.min(l1.length, l2.length)\n  while (i < len) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (j > 0) {\n        result.push(l1[i])\n        i++\n      }\n      j = 0\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique plural common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let len = Math.min(l1.length, l2.length)\n  while (i < len) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (j > 0) {\n        result.push(l1[i])\n        i++\n      }\n      j = 0\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let len = Math.min(l1.length, l2.length)\n  while (i < len) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (j > 0) {\n        result.push(l1[i])\n        i++\n      }\n      j = 0\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique plural common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let len = Math.min(l1.length, l2.length)\n  while (i < len) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (j > 0) {\n        result.push(l1[i])\n        i++\n      }\n      j = 0\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let len = Math.min(l1.length, l2.length)\n  while (i < len) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (j > 0) {\n        result.push(l1[i])\n        i++\n      }\n      j = 0\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique plural common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let len = Math.min(l1.length, l2.length)\n  while (i < len) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (j > 0) {\n        result.push(l1[i])\n        i++\n      }\n      j = 0\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let len = Math.min(l1.length, l2.length)\n  while (i < len) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (j > 0) {\n        result.push(l1[i])\n        i++\n      }\n      j = 0\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique plural common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let len = Math.min(l1.length, l2.length)\n  while (i < len) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (j > 0) {\n        result.push(l1[i])\n        i++\n      }\n      j = 0\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let len = Math.min(l1.length, l2.length)\n  while (i < len) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (j > 0) {\n        result.push(l1[i])\n        i++\n      }\n      j = 0\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique plural common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let len = Math.min(l1.length, l2.length)\n  while (i < len) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (j > 0) {\n        result.push(l1[i])\n        i++\n      }\n      j = 0\n    }\n  }\n  return result\n}\n\n/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, "}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime choice factor gene of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return the largest prime choice factor gene of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let primeFactor = 1;\n  let i = 2;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      primeFactor = primeFactor + 1;\n    } else {\n      i = i + 2;\n    }\n  }\n  return primeFactor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactorOf = (n) => {\n  let primeFactor = 1;\n  let i = 2;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      primeFactor = primeFactor + 1;\n    } else {\n      i = i + 2;\n    }\n  }\n  return primeFactor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let primeFactor = 1;\n  let i = 2;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      primeFactor = primeFactor + 1;\n    } else {\n      i = i + 2;\n    }\n  }\n  return primeFactor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let primeFactor = 1;\n  let i = 2;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      primeFactor = primeFactor + 1;\n    } else {\n      i = i + 2;\n    }\n  }\n  return primeFactor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let primeFactor = 1;\n  let i = 2;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      primeFactor = primeFactor + 1;\n    } else {\n      i = i + 2;\n    }\n  }\n  return primeFactor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let primeFactor = 1;\n  let i = 2;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      primeFactor = primeFactor + 1;\n    } else {\n      i = i + 2;\n    }\n  }\n  return primeFactor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let primeFactor = 1;\n  let i = 2;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      primeFactor = primeFactor + 1;\n    } else {\n      i = i + 2;\n    }\n  }\n  return primeFactor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let primeFactor = 1;\n  let i = 2;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      primeFactor = primeFactor + 1;\n    } else {\n      i = i + 2;\n    }\n  }\n  return primeFactor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let primeFactor = 1;\n  let i = 2;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      primeFactor = primeFactor + 1;\n    } else {\n      i = i + 2;\n    }\n  }\n  return primeFactor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let primeFactor = 1;\n  let i = 2;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      primeFactor = primeFactor + 1;\n    } else {\n      i = i + 2;\n    }\n  }\n  return primeFactor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let primeFactor = 1;\n  let i = 2;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      primeFactor = primeFactor + 1;\n    } else {\n      i = i + 2;\n    }\n  }\n  return primeFactor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let primeFactor = 1;\n  let i = 2;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      primeFactor = primeFactor + 1;\n    } else {\n      i = i + 2;\n    }\n  }\n  return primeFactor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let primeFactor = 1;\n  let i = 2;\n  while (primeFactor <= n) {\n    if (n % primeFactor === 0) {\n      primeFactor = primeFactor + 1;\n    } else {\n      i = i + 2;\n    }\n  }\n  return primeFactor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactorOf(13195)\n  29\n  >>> largestPrimeFactorOf(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = ("}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It works by iterating over all numbers from 1 to n and adding them up.\n * It returns 0 when n is 0.\n */\nconst sum = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It works by iterating over all numbers from 1 to n and adding them up.\n * It returns 0 when n is 0.\n */\nconst sum = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It works by iterating over all numbers from 1 to n and adding them up.\n * It returns 0 when n is 0.\n */\nconst sum = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It works by iterating over all numbers from 1 to n and adding them up.\n * It returns 0 when n is 0.\n */\nconst sum = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It works by iterating over all numbers from 1 to n and adding them up.\n * It returns 0 when n is 0.\n */\nconst sum = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It works by iterating over all numbers from 1 to n and adding them up.\n * It returns 0 when n is 0.\n */\nconst sum = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It works by iterating over all numbers from 1 to n and adding them up.\n * It returns 0 when n is 0.\n */\nconst sum = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It works by iterating over all numbers from 1 to n and adding them up.\n * It returns 0 when n is 0.\n */\nconst sum = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It works by iterating over all numbers from 1 to n and adding them up.\n * It returns 0 when n is 0.\n */\nconst sum = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It works by iterating over all numbers from 1 to n and adding them up.\n * It returns 0 when n is 0.\n */\nconst sum = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It works by iterating over all numbers from 1 to n and adding them up.\n * It returns 0 when n is 0.\n */\nconst sum = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It works by iterating over all numbers from 1 to n and adding them up.\n * It returns 0 when n is 0.\n */\nconst sum = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It works by iterating over all numbers from 1 to n and adding them up.\n * It returns 0 when n is 0.\n */\nconst sum = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It works by iterating over all numbers from 1 to n and adding them up.\n * It returns 0 when n is 0.\n */\nconst sum = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It works by iterating over all numbers from 1 to n and adding them up.\n * It returns 0 when n is 0.\n */\nconst sum = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It works by iterating over all numbers from 1 to n and adding them up.\n * It returns 0 when n is 0.\n */\nconst sum = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It works by iterating over all numbers from 1 to n and adding them up.\n * It returns 0 when n is 0.\n */\nconst sum = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It works by iterating over all numbers from 1 to n and adding them up.\n * It returns 0 when n is 0.\n */\nconst sum = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It works by iterating over all numbers from 1 to n and adding them up.\n * It returns 0 when n is 0.\n */\nconst sum = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It works by iterating over all numbers from 1 to n and adding them up.\n * It returns 0 when n is 0.\n */\nconst sum = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It works by iterating over all numbers from 1 to n and adding them "}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string bowed stringed instrument of \" (\" and \") \". \n   return true on-key if every opening bracket has a corresponding comparable closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string bowed stringed instrument of \" (\" and \") \". \n   return true on-key if every opening bracket has a corresponding comparable closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketings = brackets.split('')\n  const openingBrackets = bracketings.filter((bracket) => bracket.includes('('))\n  const closingBrackets = bracketings.filter((bracket) => bracket.includes(')'))\n  return openingBrackets.every(opening => closingBrackets.every(closing => opening === closing))\n}\n\n/* \n  Given a string of brackets, return true if the brackets are balanced. \n  \n  >>> balancedBrackets(\"(())\")\n  true\n  >>> balancedBrackets(\"(())())\")\n  false\n  >>> balancedBrackets(\"(())()())\")\n  false\n  >>> balancedBrackets(\"(()())()\")\n  false\n  >>> balancedBrackets(\"(()())()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())()()()()()()()()()()()()()()()()()()()()()()()\")\n  false\n  >>> balancedBrackets(\"(()())"}
{"task_id": "JavaScript/62", "prompt": "/* xs represent typify coefficients coefficient of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return derivative of this polynomial in the same form shape.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* xs represent typify coefficients coefficient of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return derivative of this polynomial in the same form shape.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  let sum = 0;\n  for (let i = 0; i < xs.length; i++) {\n    sum += xs[i] * xs[i];\n  }\n  return sum;\n};\n\n/* \n  Given a polynomial and coefficients, return its roots.\n  >>> roots([3, 1, 2, 4, 5])\n  [3, 1]\n  >>> roots([1, 2, 3])\n  [2, 3]\n  */\nconst roots = (xs) => {\n  let roots = [];\n  for (let i = 0; i < xs.length; i++) {\n    let x = xs[i];\n    let root = 1;\n    for (let j = i + 1; j < xs.length; j++) {\n      root *= xs[j];\n    }\n    roots.push(root);\n  }\n  return roots;\n};\n\n/* \n  Given a polynomial and coefficients, return its coefficients.\n  >>> coefficients([3, 1, 2, 4, 5])\n  [3, 1, 2, 4, 5]\n  >>> coefficients([1, 2, 3])\n  [3, 2, 1]\n  */\nconst coefficients = (xs) => {\n  let coefficients = [];\n  for (let i = 0; i < xs.length; i++) {\n    let x = xs[i];\n    let coefficient = 1;\n    for (let j = i + 1; j < xs.length; j++) {\n      coefficient *= xs[j];\n    }\n    coefficients.push(coefficient);\n  }\n  return coefficients;\n};\n\n/* \n  Given a polynomial and coefficients, return its degree.\n  >>> degree([3, 1, 2, 4, 5])\n  3\n  >>> degree([1, 2, 3])\n  2\n  */\nconst degree = (xs) => {\n  let degree = 0;\n  for (let i = 0; i < xs.length; i++) {\n    let x = xs[i];\n    degree += x;\n  }\n  return degree;\n};\n\n/* \n  Given a polynomial and coefficients, return its coefficients.\n  >>> coefficients([3, 1, 2, 4, 5])\n  [3, 1, 2, 4, 5]\n  >>> coefficients([1, 2, 3])\n  [3, 2, 1]\n  */\nconst coefficientsDegree = (xs) => {\n  let coefficients = [];\n  for (let i = 0; i < xs.length; i++) {\n    let x = xs[i];\n    let coefficient = 1;\n    for (let j = i + 1; j < xs.length; j++) {\n      coefficient *= xs[j];\n    }\n    coefficients.push(coefficient);\n  }\n  return coefficients;\n};\n\n/* \n  Given a polynomial and coefficients, return its coefficients.\n  >>> coefficients([3, 1, 2, 4, 5])\n  [3, 1, 2, 4, 5]\n  >>> coefficients([1, 2, 3])\n  [3, 2, 1]\n  */\nconst coefficientsDegreeDegree = (xs) => {\n  let coefficients = [];\n  for (let i = 0; i < xs.length; i++) {\n    let x = xs[i];\n    let coefficient = 1;\n    for (let j = i + 1; j < xs.length; j++) {\n      coefficient *= xs[j];\n    }\n    coefficients.push(coefficient);\n  }\n  return coefficients;\n};\n\n/* \n  Given a polynomial and coefficients, return its coefficients.\n  >>> coefficients([3, 1, 2, 4, 5])\n  [3, 1, 2, 4, 5]\n  >>> coefficients([1, 2, 3])\n  [3, 2, 1]\n  */\nconst coefficientsDegreeDegreeDegree = (xs) => {\n  let coefficients = [];\n  for (let i = 0; i < xs.length; i++) {\n    let x = xs[i];\n    let coefficient = 1;\n    for (let j = i + 1; j < xs.length; j++) {\n      coefficient *= xs[j];\n    }\n    coefficients.push(coefficient);\n  }\n  return coefficients;\n};\n\n/* \n  Given a polynomial and coefficients, return its coefficients.\n  >>> coefficients([3, 1, 2, 4, 5])\n  [3, 1, 2, 4, 5]\n  >>> coefficients([1, 2, 3])\n  [3, 2, 1]\n  */\nconst coefficientsDegreeDegreeDegreeDegreeDegree = (xs) => {\n  let coefficients = [];\n  for (let i = 0; i < xs.length; i++) {\n    let x = xs[i];\n    let coefficient = 1;\n    for (let j = i + 1; j < xs.length; j++) {\n      coefficient *= xs[j];\n    }\n    coefficients.push(coefficient);\n  }\n  return coefficients;\n};\n\n/* \n  Given a polynomial and coefficients, return its coefficients.\n  >>> coefficients([3, 1, 2, 4, 5])\n  [3, 1, 2, 4, 5]\n  >>> coefficients([1, 2, 3])\n  [3, 2, 1]\n  */\nconst coefficientsDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegreeDegree"}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number numeral sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows play along: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*The FibFib number numeral sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows play along: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Given a number n, return the Fibonacci number sequence that sums to n.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfibseq = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Given a number n, return the Fibonacci number sequence that sums to n.\n  >>> fibfibseq(1)\n  0\n  >>> fibfibseq(5)\n  4\n  >>> fibfibseq(8)\n  24\n  */\nconst fibfibseqseq = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfibseq(n-1) + fibfibseq(n-2) + fibfibseq(n-3);\n};\n\n/*\n  Given a number n, return the Fibonacci number sequence that sums to n.\n  >>> fibfibseqseqseq(1)\n  0\n  >>> fibfibseqseqseqseq(5)\n  4\n  >>> fibfibseqseqseqseqseq(8)\n  24\n  */\nconst fibfibseqseqseqseq = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfibseqseqseqseq(n-1) + fibfibseqseqseqseqseq(n-2) + fibfibseqseqseqseqseq(n-3);\n};\n\n/*\n  Given a number n, return the Fibonacci number sequence that sums to n.\n  >>> fibfibseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseqseq"}
{"task_id": "JavaScript/64", "prompt": "/*Write a function affair vowelsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of vowels in the string. \n   Vowels vowel in this case lawsuit are' a',' e',' i',' o',' u'. Here,' y' is also a \n   vowel, but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Write a function affair vowelsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of vowels in the string. \n   Vowels vowel in this case lawsuit are' a',' e',' i',' o',' u'. Here,' y' is also a \n   vowel, but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  \n  if(lastVowel === 'a' || lastVowel === 'e' || lastVowel === 'i' || lastVowel === 'o' || lastVowel === 'u') {\n    vowels++;\n  }\n  \n  if(lastVowel === 'y') {\n    vowels++;\n  }\n  \n  return vowels;\n};\n\n/*Write a function affair vowelsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of vowels in the string. \n   Vowels vowel in this case lawsuit are' a',' e',' i',' o',' u'. Here,' y' is also a \n   vowel, but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  \n  if(lastVowel === 'a' || lastVowel === 'e' || lastVowel === 'i' || lastVowel === 'o' || lastVowel === 'u') {\n    vowels++;\n  }\n  \n  if(lastVowel === 'y') {\n    vowels++;\n  }\n  \n  return vowels;\n};\n\n/*Write a function affair vowelsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of vowels in the string. \n   Vowels vowel in this case lawsuit are' a',' e',' i',' o',' u'. Here,' y' is also a \n   vowel, but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  \n  if(lastVowel === 'a' || lastVowel === 'e' || lastVowel === 'i' || lastVowel === 'o' || lastVowel === 'u') {\n    vowels++;\n  }\n  \n  if(lastVowel === 'y') {\n    vowels++;\n  }\n  \n  return vowels;\n};\n\n/*Write a function affair vowelsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of vowels in the string. \n   Vowels vowel in this case lawsuit are' a',' e',' i',' o',' u'. Here,' y' is also a \n   vowel, but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  \n  if(lastVowel === 'a' || lastVowel === 'e' || lastVowel === 'i' || lastVowel === 'o' || lastVowel === 'u') {\n    vowels++;\n  }\n  \n  if(lastVowel === 'y') {\n    vowels++;\n  }\n  \n  return vowels;\n};\n\n/*Write a function affair vowelsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of vowels in the string. \n   Vowels vowel in this case lawsuit are' a',' e',' i',' o',' u'. Here,' y' is also a \n   vowel, but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  \n  if(lastVowel === 'a' || lastVowel === 'e' || lastVowel === 'i' || lastVowel === 'o' || lastVowel === 'u') {\n    vowels++;\n  }\n  \n  if(lastVowel === 'y') {\n    vowels++;\n  }\n  \n  return vowels;\n};\n\n/*Write a function affair vowelsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of vowels in the string. \n   Vowels vowel in this case lawsuit are' a',' e',' i',' o',' u'. Here,' y' is also a \n   vowel, but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  \n  if(lastVowel === 'a' || lastVowel === 'e' || lastVowel === 'i' || lastVowel === 'o' || lastVowel === 'u') {\n    vowels++;\n  }\n  \n  if(lastVowel === 'y') {\n    vowels++;\n  }\n  \n  return vowels;\n};\n\n/*Write a function affair vowelsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of vowels in the string. \n   Vowels vowel in this case lawsuit are' a',' e',' i',' o',' u'. Here,' y' is also a \n   vowel, but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  \n  if(lastVowel === 'a' || lastVowel === 'e' || lastVowel === 'i' || lastVowel === 'o' || lastVowel === 'u') {\n    vowels++;\n  }\n  \n  if(lastVowel === 'y') {\n    vowels++;\n  }\n  \n  return vowels;\n};\n\n/*Write a function affair vowelsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns "}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits finger of the integer x, shift the digits digit right by shift\n   and return the result solution as a string. \n   If shift > number numeral of digits digit, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Circular shift the digits finger of the integer x, shift the digits digit right by shift\n   and return the result solution as a string. \n   If shift > number numeral of digits digit, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  let result = \"\";\n  let digit;\n  let digits = x.toString().split(\"\");\n  for (let i = 0; i < digits.length; i++) {\n    digit = digits[i];\n    result += digit.charAt(digit.length - shift);\n  }\n  return result;\n};\n\n/*\n  Return the number of digits in an integer x, shifted right by shift.\n  >>> digitsIn(123)\n  3\n  >>> digitsIn(1234)\n  4\n  >>> digitsIn(12345)\n  5\n  >>> digitsIn(123456)\n  6\n  >>> digitsIn(1234567)\n  7\n  >>> digitsIn(12345678)\n  8\n  >>> digitsIn(123456789)\n  9\n  >>> digitsIn(1234567890)\n  10\n  >>> digitsIn(1234567891)\n  11\n  >>> digitsIn(1234567892)\n  12\n  >>> digitsIn(1234567893)\n  13\n  >>> digitsIn(1234567894)\n  14\n  >>> digitsIn(1234567895)\n  15\n  >>> digitsIn(1234567896)\n  16\n  >>> digitsIn(1234567897)\n  17\n  >>> digitsIn(1234567898)\n  18\n  >>> digitsIn(12345678)\n  19\n  >>> digitsIn(1234567890)\n  20\n  >>> digitsIn(1234567891)\n  21\n  >>> digitsIn(1234567892)\n  22\n  >>> digitsIn(1234567893)\n  23\n  >>> digitsIn(1234567894)\n  24\n  >>> digitsIn(1234567895)\n  25\n  >>> digitsIn(1234567896)\n  26\n  >>> digitsIn(1234567897)\n  27\n  >>> digitsIn(1234567898)\n  28\n  >>> digitsIn(1234567890)\n  29\n  >>> digitsIn(1234567891)\n  30\n  >>> digitsIn(1234567892)\n  31\n  >>> digitsIn(1234567893)\n  32\n  >>> digitsIn(1234567894)\n  33\n  >>> digitsIn(1234567895)\n  34\n  >>> digitsIn(1234567896)\n  35\n  >>> digitsIn(1234567897)\n  36\n  >>> digitsIn(1234567898)\n  37\n  >>> digitsIn(1234567890)\n  38\n  >>> digitsIn(1234567891)\n  39\n  >>> digitsIn(1234567892)\n  40\n  >>> digitsIn(1234567893)\n  41\n  >>> digitsIn(1234567894)\n  42\n  >>> digitsIn(1234567895)\n  43\n  >>> digitsIn(1234567896)\n  44\n  >>> digitsIn(1234567897)\n  45\n  >>> digitsIn(1234567898)\n  46\n  >>> digitsIn(1234567890)\n  47\n  >>> digitsIn(1234567891)\n  48\n  >>> digitsIn(1234567892)\n  49\n  >>> digitsIn(1234567893)\n  50\n  >>> digitsIn(1234567894)\n  51\n  >>> digitsIn(1234567895)\n  52\n  >>> digitsIn(1234567896)\n  53\n  >>> digitsIn(1234567897)\n  54\n  >>> digitsIn(1234567898)\n  55\n  >>> digitsIn(1234567890)\n  56\n  >>> digitsIn(1234567891)\n  57\n  >>> digitsIn(1234567892)\n  58\n  >>> digitsIn(1234567893)\n  59\n  >>> digitsIn(1234567894)\n  60\n  >>> digitsIn(1234567895)\n  61\n  >>> digitsIn(1234567896)\n  62\n  >>> digitsIn(1234567897)\n  63\n  >>> digitsIn(1234567898)\n  64\n  >>> digitsIn(1234567890)\n  65\n  >>> digitsIn(1234567891)\n  66\n  >>> digitsIn(1234567892)\n  67\n  >>> digitsIn(1234567893)\n  68\n  >>> digitsIn(1234567894)\n  69\n  >>> digitsIn(1234567895)\n  70\n  >>> digitsIn(1234567896)\n  71\n  >>> digitsIn(1234567897)\n  72\n  >>> digitsIn(1234567898)\n  73\n  >>> digitsIn(1234567890)\n  74\n  >>> digitsIn(1234567891)\n  75\n  >>> digitsIn(1234567892)\n  76\n  >>> digitsIn(1234567893)\n  77\n  >>> digitsIn(1234567894)\n  78\n  >>> digitsIn(1234567895)\n  79\n  >>> digitsIn(1234567896)\n  80\n  >>> digitsIn(1234567897)\n  81\n  >>> digitsIn(1234567898)\n  82\n  >>> digitsIn(1234567890)\n  83\n  >>> digitsIn(1234567891)\n  84\n  >>> digitsIn(1234567892)\n  85\n  >>> digitsIn(1234567893)\n  86\n  >>> digitsIn(1234567894)\n  87\n  >>> digitsIn(1234567895)\n  88\n  >>> digitsIn(1234567896)\n  89\n  >>> digitsIn(1234567897)\n  90\n  >>> digitsIn(1234567898)\n  91\n  >>> digitsIn(1234567890)\n  92\n  >>> digitsIn(1234567891)\n  93\n  >>> digitsIn(1234567892)\n  94\n  >>> digitsIn(1234567893)\n  95\n  >>> digitsIn(1234567894)\n  96\n  >>> digitsIn(1234567895)\n  97\n  >>> digitsIn(1234567896)\n  98\n  >>> digitsIn(1234567897)\n  99\n  >>> digitsIn(1234567898)\n  100\n  >>> digitsIn(12345678)\n  101\n  >>> digitsIn(1234567890)\n  102\n  >>> digitsIn(1234567891)\n  103\n  >>> digitsIn(1234567892)\n  104\n  >>> digitsIn(1234567893)\n  105\n  >>> digitsIn(1234567894)\n  106\n  >>> digitsIn(1234567895)\n  107\n  >>> digitsIn(1234567896)\n  108\n  >>> digitsIn(1234567897)\n  109\n  >>> digitsIn(1234567898)\n  110\n  >>> digitsIn(12345678)\n  111\n  >>> digitsIn(1234567890)\n  112\n  >>> digitsIn(1234567891)\n  113\n  >>> digitsIn(1234567892)\n  114\n  >>> digitsIn(1234567893)\n  115\n  >>> digitsIn(1234567894)\n  116\n  >>> digitsIn(1234567895)\n  117\n  >>> digitsIn(1234567896)\n  118\n  >>> digitsIn(1234567897)\n  119\n  >>> digitsIn(1234567898)\n  120\n  >>> digitsIn(12345678)\n  121\n  >>> digitsIn(1234567890)\n  122\n  >>> digitsIn(1234567891)\n  123\n  >>> digitsIn(1234567892)\n  124\n  >>> digitsIn(1234567893)\n  125\n  >>> digitsIn(1234567894)\n  126\n  >>> digitsIn(1234567895)\n  127\n  >>> digitsIn(1234567896)\n  128\n"}
{"task_id": "JavaScript/66", "prompt": "/*Task necessitate \n   Write publish a function affair that takes a string as input stimulation and returns fall the sum of the upper characters only' \n   ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Task necessitate \n   Write publish a function affair that takes a string as input stimulation and returns fall the sum of the upper characters only' \n   ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  let digit;\n  for (let i = 0; i < s.length; i++) {\n    digit = s.charCodeAt(i);\n    sum += digit - 48;\n  }\n  return sum;\n};\n\n/*\n  Write a function digitSum2 that takes a string as input stimulation and returns fall the sum of the upper characters only' \n  ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum2(\"abAB\") => 131\n      digitSum2(\"abcCd\") => 67\n      digitSum2(\"helloE\") => 69\n      digitSum2(\"woArBld\") => 131\n      digitSum2(\"aAaaaXa\") => 153\n  */\nconst digitSum2 = (s) => {\n  let sum = 0;\n  let digit;\n  for (let i = 0; i < s.length; i++) {\n    digit = s.charCodeAt(i);\n    sum += digit - 48;\n  }\n  return sum;\n};\n\n/*\n  Write a function digitSum3 that takes a string as input stimulation and returns fall the sum of the upper characters only' \n  ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum3(\"abAB\") => 131\n      digitSum3(\"abcCd\") => 67\n      digitSum3(\"helloE\") => 69\n      digitSum3(\"woArBld\") => 131\n      digitSum3(\"aAaaaXa\") => 153\n  */\nconst digitSum3 = (s) => {\n  let sum = 0;\n  let digit;\n  for (let i = 0; i < s.length; i++) {\n    digit = s.charCodeAt(i);\n    sum += digit - 48;\n  }\n  return sum;\n};\n\n/*\n  Write a function digitSum4 that takes a string as input stimulation and returns fall the sum of the upper characters only' \n  ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum4(\"abAB\") => 131\n      digitSum4(\"abcCd\") => 67\n      digitSum4(\"helloE\") => 69\n      digitSum4(\"woArBld\") => 131\n      digitSum4(\"aAaaaXa\") => 153\n  */\nconst digitSum4 = (s) => {\n  let sum = 0;\n  let digit;\n  for (let i = 0; i < s.length; i++) {\n    digit = s.charCodeAt(i);\n    sum += digit - 48;\n  }\n  return sum;\n};\n\n/*\n  Write a function digitSum5 that takes a string as input stimulation and returns fall the sum of the upper characters only' \n  ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum5(\"abAB\") => 131\n      digitSum5(\"abcCd\") => 67\n      digitSum5(\"helloE\") => 69\n      digitSum5(\"woArBld\") => 131\n      digitSum5(\"aAaaaXa\") => 153\n  */\nconst digitSum5 = (s) => {\n  let sum = 0;\n  let digit;\n  for (let i = 0; i < s.length; i++) {\n    digit = s.charCodeAt(i);\n    sum += digit - 48;\n  }\n  return sum;\n};\n\n/*\n  Write a function digitSum6 that takes a string as input stimulation and returns fall the sum of the upper characters only' \n  ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum6(\"abAB\") => 131\n      digitSum6(\"abcCd\") => 67\n      digitSum6(\"helloE\") => 69\n      digitSum6(\"woArBld\") => 131\n      digitSum6(\"aAaaaXa\") => 153\n  */\nconst digitSum6 = (s) => {\n  let sum = 0;\n  let digit;\n  for (let i = 0; i < s.length; i++) {\n    digit = s.charCodeAt(i);\n    sum += digit - 48;\n  }\n  return sum;\n};\n\n/*\n  Write a function digitSum7 that takes a string as input stimulation and returns fall the sum of the upper characters only' \n  ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum7(\"abAB\") => 131\n      digitSum7(\"abcCd\") => 67\n      digitSum7(\"helloE\") => 69\n      digitSum7(\"woArBld\") => 131\n      digitSum7(\"aAaaaXa\") => 153\n  */\nconst digitSum7 = (s) => {\n  let sum = 0;\n  let digit;\n  for (let i = 0; i < s.length; i++) {\n    digit = s.charCodeAt(i);\n    sum += digit - 48;\n  }\n  return sum;\n};\n\n/*\n  Write a function digitSum8 that takes a string as input stimulation and returns fall the sum of the upper characters only' \n  ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum8(\"abAB\") => 131\n      digitSum8(\"abcCd\") => 67\n      digitSum8(\"helloE\") => 69\n      digitSum8(\"woArBld\") => 131\n      digitSum8(\"aAaaaXa\") => 153\n  */\nconst digitSum8 = (s) => {\n  let sum = 0;\n  let digit;\n  for (let i = 0; i < s.length; i++) {\n    digit = s.charCodeAt(i);\n    sum += digit - 48;\n  }\n  return sum;\n};\n\n/*\n  Write a function digitSum9 that takes a string as input stimulation and returns fall the sum of the upper characters only' \n  ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum9(\"abAB\") => 131\n      digitSum9(\"abcCd\") => 67\n      digitSum9(\"helloE\") => 69\n      digitSum9(\"woArBld\") => 131\n      digitSum9(\"aAaaaXa\") => 153\n  */\nconst digitSum9 = (s) => {\n  let sum = 0;\n  let digit;\n  for (let i = 0; i < s.length; i++) {\n    digit = s.charCodeAt(i);\n    sum += digit - 48;\n  }\n  return sum;\n};\n\n/*\n  Write a function digitSum10 that takes a string as input stimulation and returns fall the sum of the upper characters only' \n  ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum10(\"abAB\") => 131\n      digitSum10(\"abcCd\") => 67\n      digitSum10(\"helloE\") => 69\n      digitSum10(\"woArBld\") => 131\n      digitSum10(\"aAaaaXa\") => 153\n  */\nconst digitSum10 = (s) => {\n  let sum = 0;\n  let digit;\n  for (let i = 0; i < s.length; i++) {\n    digit = s.charCodeAt(i);\n    sum += digit - 48;\n  }\n  return sum;\n};\n\n/*\n  Write a function digitSum"}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task job, you will be given contribute a string bowed stringed instrument that represents act a number of apples apple and oranges orange \n   that are distributed in a basket of fruit this basket contains hold \n   apples apple, oranges, and mango fruits. Given the string that represents act the total entire number of \n   the oranges orange and apples and an integer that represent the total full number of the fruits fruit \n   in the basket return the number numeral of the mango fruits fruit in the basket. \n   for examble: \n   fruitDistribution(\"5 apples and 6 oranges orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apples apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples and 3 oranges \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples apple and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  In this task job, you will be given contribute a string bowed stringed instrument that represents act a number of apples apple and oranges orange \n   that are distributed in a basket of fruit this basket contains hold \n   apples apple, oranges, and mango fruits. Given the string that represents act the total entire number of \n   the oranges orange and apples and an integer that represent the total full number of the fruits fruit \n   in the basket return the number numeral of the mango fruits fruit in the basket. \n   for examble: \n   fruitDistribution(\"5 apples and 6 oranges orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apples apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples and 3 oranges \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples apple and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n let total = 0;\n let fruits = n.split(' ').map(Number);\n fruits.forEach((fruit) => {\n total += fruit;\n });\n return total;\n };\n */\nfunction fruitDistribution(str, n) {\n  let total = 0;\n  let fruits = n.split(' ').map(Number);\n  fruits.forEach((fruit) => {\n    total += fruit;\n  });\n  return total;\n}\n\n// Write a function that takes an array of strings and a number n and returns the number of distinct strings in the array that \n// are formed from the first n distinct strings. \n// \n// For example fruitDistribution([\"apples\", \"oranges\", \"mango\"], 3) returns 3 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 4) returns 2 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 5) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 6) returns 0 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 7) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 8) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 9) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 10) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 11) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 12) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 13) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 14) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 15) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 16) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 17) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 18) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 19) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 20) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 21) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 22) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 23) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 24) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 25) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 26) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 27) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 28) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 29) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 30) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 31) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 32) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 33) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 34) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 35) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 36) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 37) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 38) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 39) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 40) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 41) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 42) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 43) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 44) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 45) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 46) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 47) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 48) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 49) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 50) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 51) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 52) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 53) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 54) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 55) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 56) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 57) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 58) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 59) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 60) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 61) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 62) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 63) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 64) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 65) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 66) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 67) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 68) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 69) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 70) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 71) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 72) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 73) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 74) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 75) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 76) returns 1 \n// fruitDistribution([\"apples\", \"oranges\", \"mango\"], 77) returns 1 \n// "}
{"task_id": "JavaScript/68", "prompt": "/*\n  \" Given impart an array representing defend a branch of a tree that has non - negative minus integer nodes \n   your task job is to pluck one of the nodes lymph node and return it. \n   The plucked node should be the node with the smallest humble even tied value. \n   If multiple nodes with the same smallest even value are found return the node lymph node that has smallest minor index. \n\n   The plucked node lymph node should be returned in a list, [ smalest_value, its index ], \n   If there are no even tied values or the given collapse array is empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  \" Given impart an array representing defend a branch of a tree that has non - negative minus integer nodes \n   your task job is to pluck one of the nodes lymph node and return it. \n   The plucked node should be the node with the smallest humble even tied value. \n   If multiple nodes with the same smallest even value are found return the node lymph node that has smallest minor index. \n\n   The plucked node lymph node should be returned in a list, [ smalest_value, its index ], \n   If there are no even tied values or the given collapse array is empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const [nodes, min] = partition(arr);\n  return nodes.map((node) => node.value);\n};\n\n// https://leetcode.com/problems/minimum-spanning-tree-ii/solution/\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[]} nodes\n * @return {number[]}\n */\nconst partition = (nodes) => {\n  const min = 0;\n  const max = nodes.length - 1;\n  let left = 0;\n  let right = max;\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (nodes[mid] < min) {\n      min = nodes[mid];\n      left = mid;\n    }\n    if (nodes[mid] > max) {\n      right = mid;\n    }\n  }\n  return [nodes, min];\n};\n\n// https://leetcode.com/problems/minimum-spanning-tree-iii/solution/\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[]} nodes\n * @return {number[]}\n */\nconst partitionIII = (nodes) => {\n  const min = 0;\n  const max = nodes.length - 1;\n  let left = 0;\n  let right = max;\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (nodes[mid] < min) {\n      min = nodes[mid];\n      left = mid;\n    }\n    if (nodes[mid] > max) {\n      right = mid;\n    }\n  }\n  return [nodes, min];\n};\n\n// https://leetcode.com/problems/minimum-spanning-tree-iiii/solution/\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[]} nodes\n * @return {number[]}\n */\nconst partitionIIII = (nodes) => {\n  const min = 0;\n  const max = nodes.length - 1;\n  let left = 0;\n  let right = max;\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (nodes[mid] < min) {\n      min = nodes[mid];\n      left = mid;\n    }\n    if (nodes[mid] > max) {\n      right = mid;\n    }\n  }\n  return [nodes, min];\n};\n\n// https://leetcode.com/problems/minimum-spanning-tree-iiiii/solution/\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[]} nodes\n * @return {number[]}\n */\nconst partitionIIIII = (nodes) => {\n  const min = 0;\n  const max = nodes.length - 1;\n  let left = 0;\n  let right = max;\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (nodes[mid] < min) {\n      min = nodes[mid];\n      left = mid;\n    }\n    if (nodes[mid] > max) {\n      right = mid;\n    }\n  }\n  return [nodes, min];\n};\n\n// https://leetcode.com/problems/minimum-spanning-tree-iiiiii/solution/\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[]} nodes\n * @return {number[]}\n */\nconst partitionIIIIIII = (nodes) => {\n  const min = 0;\n  const max = nodes.length - 1;\n  let left = 0;\n  let right = max;\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (nodes[mid] < min) {\n      min = nodes[mid];\n      left = mid;\n    }\n    if (nodes[mid] > max) {\n      right = mid;\n    }\n  }\n  return [nodes, min];\n};\n\n// https://leetcode.com/problems/minimum-spanning-tree-iiiiiiii/solution/\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[]} nodes\n * @return {number[]}\n */\nconst partitionIIIIIIII = (nodes) => {\n  const min = 0;\n  const max = nodes.length - 1;\n  let left = 0;\n  let right = max;\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (nodes[mid] < min) {\n      min = nodes[mid];\n      left = mid;\n    }\n    if (nodes[mid] > max) {\n      right = mid;\n    }\n  }\n  return [nodes, min];\n};\n\n// https://leetcode.com/problems/minimum-spanning-tree-iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii"}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given impart a non - empty list of positive convinced integers integer. Return the greatest integer that is greater capital than \n   zero, and has a frequency greater big than or equal to the value of the integer itself. \n   The frequency of an integer is the number of times meter it appears look in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given impart a non - empty list of positive convinced integers integer. Return the greatest integer that is greater capital than \n   zero, and has a frequency greater big than or equal to the value of the integer itself. \n   The frequency of an integer is the number of times meter it appears look in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a list of positive integers integers. Return the number of positive integers \n   that appear more than once in the list.\n  Examples:\n      countPositive([4, 1, 2, 2, 3, 1])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      countPositive([4, 1, 2, 2, 3, 1, 2])\n      count"}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given impart list of integers integer, return list in strange order club. \n   Strange sorting classification, is when you start startle with the minimum value, \n   then maximum of the remaining persist integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart list of integers integer, return list in strange order club. \n   Strange sorting classification, is when you start startle with the minimum value, \n   then maximum of the remaining persist integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  let sortedLst = lst.sort((a, b) => a - b);\n  let sortedLst2 = lst.sort((a, b) => b - a);\n  let sortedLst3 = lst.sort((a, b) => a - b);\n  let sortedLst4 = lst.sort((a, b) => b - a);\n  let sortedLst5 = lst.sort((a, b) => a - b);\n  let sortedLst6 = lst.sort((a, b) => b - a);\n  let sortedLst7 = lst.sort((a, b) => a - b);\n  let sortedLst8 = lst.sort((a, b) => b - a);\n  let sortedLst9 = lst.sort((a, b) => a - b);\n  let sortedLst10 = lst.sort((a, b) => b - a);\n  let sortedLst11 = lst.sort((a, b) => a - b);\n  let sortedLst12 = lst.sort((a, b) => b - a);\n  let sortedLst13 = lst.sort((a, b) => a - b);\n  let sortedLst14 = lst.sort((a, b) => b - a);\n  let sortedLst15 = lst.sort((a, b) => a - b);\n  let sortedLst16 = lst.sort((a, b) => b - a);\n  let sortedLst17 = lst.sort((a, b) => a - b);\n  let sortedLst18 = lst.sort((a, b) => b - a);\n  let sortedLst19 = lst.sort((a, b) => a - b);\n  let sortedLst20 = lst.sort((a, b) => b - a);\n  let sortedLst21 = lst.sort((a, b) => a - b);\n  let sortedLst22 = lst.sort((a, b) => b - a);\n  let sortedLst23 = lst.sort((a, b) => a - b);\n  let sortedLst24 = lst.sort((a, b) => b - a);\n  let sortedLst25 = lst.sort((a, b) => a - b);\n  let sortedLst26 = lst.sort((a, b) => b - a);\n  let sortedLst27 = lst.sort((a, b) => a - b);\n  let sortedLst28 = lst.sort((a, b) => b - a);\n  let sortedLst29 = lst.sort((a, b) => a - b);\n  let sortedLst30 = lst.sort((a, b) => b - a);\n  let sortedLst31 = lst.sort((a, b) => a - b);\n  let sortedLst32 = lst.sort((a, b) => b - a);\n  let sortedLst33 = lst.sort((a, b) => a - b);\n  let sortedLst34 = lst.sort((a, b) => b - a);\n  let sortedLst35 = lst.sort((a, b) => a - b);\n  let sortedLst36 = lst.sort((a, b) => b - a);\n  let sortedLst37 = lst.sort((a, b) => a - b);\n  let sortedLst38 = lst.sort((a, b) => b - a);\n  let sortedLst39 = lst.sort((a, b) => a - b);\n  let sortedLst40 = lst.sort((a, b) => b - a);\n  let sortedLst41 = lst.sort((a, b) => a - b);\n  let sortedLst42 = lst.sort((a, b) => b - a);\n  let sortedLst43 = lst.sort((a, b) => a - b);\n  let sortedLst44 = lst.sort((a, b) => b - a);\n  let sortedLst45 = lst.sort((a, b) => a - b);\n  let sortedLst46 = lst.sort((a, b) => b - a);\n  let sortedLst47 = lst.sort((a, b) => a - b);\n  let sortedLst48 = lst.sort((a, b) => b - a);\n  let sortedLst49 = lst.sort((a, b) => a - b);\n  let sortedLst50 = lst.sort((a, b) => b - a);\n  let sortedLst51 = lst.sort((a, b) => a - b);\n  let sortedLst52 = lst.sort((a, b) => b - a);\n  let sortedLst53 = lst.sort((a, b) => a - b);\n  let sortedLst54 = lst.sort((a, b) => b - a);\n  let sortedLst55 = lst.sort((a, b) => a - b);\n  let sortedLst56 = lst.sort((a, b) => b - a);\n  let sortedLst57 = lst.sort((a, b) => a - b);\n  let sortedLst58 = lst.sort((a, b) => b - a);\n  let sortedLst59 = lst.sort((a, b) => a - b);\n  let sortedLst60 = lst.sort((a, b) => b - a);\n  let sortedLst61 = lst.sort((a, b) => a - b);\n  let sortedLst62 = lst.sort((a, b) => b - a);\n  let sortedLst63 = lst.sort((a, b) => a - b);\n  let sortedLst64 = lst.sort((a, b) => b - a);\n  let sortedLst65 = lst.sort((a, b) => a - b);\n  let sortedLst66 = lst.sort((a, b) => b - a);\n  let sortedLst67 = lst.sort((a, b) => a - b);\n  let sortedLst68 = lst.sort((a, b) => b - a);\n  let sortedLst69 = lst.sort((a, b) => a - b);\n  let sortedLst70 = lst.sort((a, b) => b - a);\n  let sortedLst71 = lst.sort((a, b) => a - b);\n  let sortedLst72 = lst.sort((a, b) => b - a);\n  let sortedLst73 = lst.sort((a, b) => a - b);\n  let sortedLst74 = lst.sort((a, b) => b - a);\n  let sortedLst75 = lst.sort((a, b) => a - b);\n  let sortedLst76 = lst.sort((a, b) => b - a);\n  let sortedLst77 = lst.sort((a, b) => a - b);\n  let sortedLst78 = lst.sort((a, b) => b - a);\n  let sortedLst79 = lst.sort((a, b) => a - b);\n  let sortedLst80 = lst.sort((a, b) => b - a);\n  let sortedLst81 = lst.sort((a, b) => a - b);\n  let sortedLst82 = lst.sort((a, b) => b - a);\n  let sortedLst83 = lst.sort((a, b) => a - b);\n  let sortedLst84 = lst.sort((a, b) => b - a);\n  let sortedLst85 = lst.sort((a, b) => a - b);\n  let sortedLst86 = lst.sort((a, b) => b - a);\n  let sortedLst87 = lst.sort((a, b) => a - b);\n  let sortedLst88 = lst.sort((a, b) => b - a);\n  let sortedLst89 = lst.sort((a, b) => a - b);\n  let sortedLst90 = lst.sort((a, b) => b - a);\n  let sortedLst91 = lst.sort((a, b) => a - b);\n  let sortedLst92 = lst.sort((a, b) => b - a);\n  let sortedLst93 = lst.sort((a, b) => a - b);\n  let sortedLst94 = "}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given impart the lengths distance of the three sides english of a triangle triangulum. Return the area of \n   the triangle triangulum rounded round off to 2 decimal points if the three sides form shape a valid triangle triangulum. \n   Otherwise return -1 \n   Three sides make a valid triangle when the sum union of any two sides side is greater \n   than the third side english.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart the lengths distance of the three sides english of a triangle triangulum. Return the area of \n   the triangle triangulum rounded round off to 2 decimal points if the three sides form shape a valid triangle triangulum. \n   Otherwise return -1 \n   Three sides make a valid triangle when the sum union of any two sides side is greater \n   than the third side english.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  const area = (a + b + c) / 2;\n  return Math.round(area * 100) / 100;\n};\n\n/*\n  Given impart the lengths distance of the three sides english of a quad quadrilateral \n  Return the area of the quad quadrilateral rounded round off to 2 decimal points if the three sides form shape a valid quad \n  Otherwise return -1 \n  Three sides make a valid quad when the sum union of any two sides side is greater \n  than the third side english.\n  Example:\n  quadArea(1, 2, 3) == 6.00\n  quadArea(1, 3, 2) == -1\n  */\nconst quadArea = (a, b, c) => {\n  const area = (a + b + c) / 2;\n  return Math.round(area * 100) / 100;\n};\n\n/*\n  Given impart the lengths distance of the three sides english of a quad pyramidal \n  Return the area of the quad pyramidal rounded round off to 2 decimal points if the three sides form shape a valid quad \n  Otherwise return -1 \n  Three sides make a valid quad when the sum union of any two sides side is greater \n  than the third side english.\n  Example:\n  quadArea(1, 2, 3) == 6.00\n  quadArea(1, 3, 2) == -1\n  */\nconst quadPyramidArea = (a, b, c) => {\n  const area = (a + b + c) / 2;\n  return Math.round(area * 100) / 100;\n};\n\n/*\n  Given impart the lengths distance of the three sides english of a quad tetrahedral \n  Return the area of the quad tetrahedral rounded round off to 2 decimal points if the three sides form shape a valid quad \n  Otherwise return -1 \n  Three sides make a valid quad when the sum union of any two sides side is greater \n  than the third side english.\n  Example:\n  quadArea(1, 2, 3) == 6.00\n  quadArea(1, 3, 2) == -1\n  */\nconst quadTetrahedralArea = (a, b, c) => {\n  const area = (a + b + c) / 2;\n  return Math.round(area * 100) / 100;\n};\n\n/*\n  Given impart the lengths distance of the three sides english of a quad hexagonal \n  Return the area of the quad hexagonal rounded round off to 2 decimal points if the three sides form shape a valid quad \n  Otherwise return -1 \n  Three sides make a valid quad when the sum union of any two sides side is greater \n  than the third side english.\n  Example:\n  quadArea(1, 2, 3) == 6.00\n  quadArea(1, 3, 2) == -1\n  */\nconst quadHexagonalArea = (a, b, c) => {\n  const area = (a + b + c) / 2;\n  return Math.round(area * 100) / 100;\n};\n\n/*\n  Given impart the lengths distance of the three sides english of a quad heptagonal \n  Return the area of the quad heptagonal rounded round off to 2 decimal points if the three sides form shape a valid quad \n  Otherwise return -1 \n  Three sides make a valid quad when the sum union of any two sides side is greater \n  than the third side english.\n  Example:\n  quadArea(1, 2, 3) == 6.00\n  quadArea(1, 3, 2) == -1\n  */\nconst quadHeptagonalArea = (a, b, c) => {\n  const area = (a + b + c) / 2;\n  return Math.round(area * 100) / 100;\n};\n\n/*\n  Given impart the lengths distance of the three sides english of a quad octagonal \n  Return the area of the quad octagonal rounded round off to 2 decimal points if the three sides form shape a valid quad \n  Otherwise return -1 \n  Three sides make a valid quad when the sum union of any two sides side is greater \n  than the third side english.\n  Example:\n  quadArea(1, 2, 3) == 6.00\n  quadArea(1, 3, 2) == -1\n  */\nconst quadOctagonalArea = (a, b, c) => {\n  const area = (a + b + c) / 2;\n  return Math.round(area * 100) / 100;\n};\n\n/*\n  Given impart the lengths distance of the three sides english of a quad nonoctagonal \n  Return the area of the quad nonoctagonal rounded round off to 2 decimal points if the three sides form shape a valid quad \n  Otherwise return -1 \n  Three sides make a valid quad when the sum union of any two sides side is greater \n  than the third side english.\n  Example:\n  quadArea(1, 2, 3) == 6.00\n  quadArea(1, 3, 2) == -1\n  */\nconst quadNonoctagonalArea = (a, b, c) => {\n  const area = (a + b + c) / 2;\n  return Math.round(area * 100) / 100;\n};\n\n/*\n  Given impart the lengths distance of the three sides english of a quad dodecahedral \n  Return the area of the quad dodecahedral rounded round off to 2 decimal points if the three sides form shape a valid quad \n  Otherwise return -1 \n  Three sides make a valid quad when the sum union of any two sides side is greater \n  than the third side english.\n  Example:\n  quadArea(1, 2, 3) == 6.00\n  quadArea(1, 3, 2) == -1\n  */\nconst quadDodecahedralArea = (a, b, c) => {\n  const area = (a + b + c) / 2;\n  return Math.round(area * 100) / 100;\n};\n\n/*\n  Given impart the lengths distance of the three sides english of a quad decagonal \n  Return the area of the quad decagonal rounded round off to 2 decimal points if the three sides form shape a valid quad \n  Otherwise return -1 \n  Three sides make a valid quad when the sum union of any two sides side is greater \n  than the third side english.\n  Example:\n  quadArea(1, 2, 3) == 6.00\n  quadArea(1, 3, 2) == -1\n  */\nconst quadDecagonalArea = (a, b, c) => {\n  const area = (a + b + c) / 2;\n  return Math.round(area * 100) / 100;\n};\n\n/*\n  Given impart the lengths distance of the three sides english of a quad trigonal \n  Return the area of the quad trigonal rounded round off to 2 decimal points if the three sides form shape a valid quad \n  Otherwise return -1 \n  Three sides make a valid quad when the sum union of any two sides side is greater \n  than the third side english.\n  Example:\n  quadArea(1, 2, 3) == 6.00\n  quadArea(1, 3, 2) == -1\n  */\nconst quadTrigonalArea = (a, b, c) => {\n  const area = (a + b + c) / 2;\n  return Math.round(a"}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write publish a function routine that returns true dependable if the object q will fly flee, and false assumed otherwise differently. \n   The object aim q will fly flee if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight system of weights w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Write publish a function routine that returns true dependable if the object q will fly flee, and false assumed otherwise differently. \n   The object aim q will fly flee if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight system of weights w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  let sum = 0;\n  let max = 0;\n  let maxWeight = 0;\n  let maxWeightWeight = 0;\n  let maxWeightWeightWeight = 0;\n  let maxWeightWeightWeightWeight = 0;\n  let maxWeightWeightWeightWeightWeight = 0;\n  let maxWeightWeightWeightWeightWeightWeight = 0;\n  let maxWeightWeightWeightWeightWeightWeightWeight = 0;\n  let maxWeightWeightWeightWeightWeightWeightWeightWeight = 0;\n  let maxWeightWeightWeightWeightWeightWeightWeightWeightWeight = 0;\n  let maxWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeight = 0;\n  let maxWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeight = 0;\n  let maxWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeight = 0;\n  let maxWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeight = 0;\n  let maxWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeight = 0;\n  let maxWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeightWeight"}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given impart an array arr of integers integer, find the minimum minimal number of elements element that \n   need necessitate to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards back and forwards. In one change, you can change one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart an array arr of integers integer, find the minimum minimal number of elements element that \n   need necessitate to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards back and forwards. In one change, you can change one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let change = 0;\n  let minChange = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < minChange) {\n      minChange = arr[i];\n      change = i;\n    }\n  }\n  return change;\n};\n\nmodule.exports = smallestChange;\n\n},{}],4:[function(require,module,exports){\n/*\n  Given impart an array arr of integers integer, find the minimum minimal number of elements element that \n   need necessitate to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards back and forwards. In one change, you can change one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let change = 0;\n  let minChange = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > minChange) {\n      minChange = arr[i];\n      change = i;\n    }\n  }\n  return change;\n};\n\nmodule.exports = smallestChange;\n\n},{}],5:[function(require,module,exports){\n/*\n  Given impart an array arr of integers integer, find the minimum minimal number of elements element that \n   need necessitate to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards back and forwards. In one change, you can change one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let change = 0;\n  let minChange = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < minChange) {\n      minChange = arr[i];\n      change = i;\n    }\n  }\n  return change;\n};\n\nmodule.exports = smallestChange;\n\n},{}],6:[function(require,module,exports){\n/*\n  Given impart an array arr of integers integer, find the minimum minimal number of elements element that \n   need necessitate to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards back and forwards. In one change, you can change one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let change = 0;\n  let minChange = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > minChange) {\n      minChange = arr[i];\n      change = i;\n    }\n  }\n  return change;\n};\n\nmodule.exports = smallestChange;\n\n},{}],7:[function(require,module,exports){\n/*\n  Given impart an array arr of integers integer, find the minimum minimal number of elements element that \n   need necessitate to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards back and forwards. In one change, you can change one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let change = 0;\n  let minChange = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < minChange) {\n      minChange = arr[i];\n      change = i;\n    }\n  }\n  return change;\n};\n\nmodule.exports = smallestChange;\n\n},{}],8:[function(require,module,exports){\n/*\n  Given impart an array arr of integers integer, find the minimum minimal number of elements element that \n   need necessitate to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards back and forwards. In one change, you can change one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let change = 0;\n  let minChange = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > minChange) {\n      minChange = arr[i];\n      change = i;\n    }\n  }\n  return change;\n};\n\nmodule.exports = smallestChange;\n\n},{}],9:[function(require,module,exports){\n/*\n  Given impart an array arr of integers integer, find the minimum minimal number of elements element that \n   need necessitate to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards back and forwards. In one change, you can change one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let change = 0;\n  let minChange = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < minChange) {\n      minChange = arr[i];\n      change = i;\n    }\n  }\n  return change;\n};\n\nmodule.exports = smallestChange;\n\n},{}],10:[function(require,module,exports){\n/*\n  Given impart an array arr of integers integer, find the minimum minimal number of elements element that \n   need necessitate to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards back and forwards. In one change, you can change one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let change = 0;\n  let minChange = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > minChange) {\n      minChange = arr[i];\n      change = i;\n    }\n  }\n  return change;\n};\n\nmodule.exports = smallestChange;\n\n},{}],11:[function(require,module,exports){\n/*\n  Given impart an array arr of integers integer, find the minimum minimal number of elements element that \n   need necessitate to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards back"}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write publish a function routine that accepts two lists list of strings and returns revert the list that has \n   total full number of chars in the all strings string of the list less than the other list.\n\n   if the two lists list have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Write publish a function routine that accepts two lists list of strings and returns revert the list that has \n   total full number of chars in the all strings string of the list less than the other list.\n\n   if the two lists list have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let total = 0;\n  let match;\n  lst1.forEach((item, index) => {\n    if (lst2.includes(item)) {\n      match = true;\n      total += 1;\n    }\n  });\n  return match? lst1 : lst2;\n};\n\n/**\n * Write a function that accepts two lists list of strings and returns true if all the strings in the list \n   are in the other list.\n\n  Examples\n  allIn([], []) ➞ false\n  allIn(['hi', 'admin'], ['hI', 'Hi']) ➞ true\n  allIn(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ true\n  allIn(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ true\n  allIn(['4'], ['1', '2', '3', '4', '5']) ➞ false\n  */\nconst allIn = (lst1, lst2) => {\n  let match = true;\n  lst1.forEach((item, index) => {\n    if (lst2.includes(item)) {\n      match = false;\n    }\n  });\n  return match;\n};\n\n/**\n * Write a function that accepts two lists list of strings and returns true if all the strings in the list \n   are in the other list.\n\n  Examples\n  allIn([], []) ➞ false\n  allIn(['hi', 'admin'], ['hI', 'Hi']) ➞ true\n  allIn(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ true\n  allIn(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ true\n  allIn(['4'], ['1', '2', '3', '4', '5']) ➞ false\n  */\nconst allIn = (lst1, lst2) => {\n  let match = true;\n  lst1.forEach((item, index) => {\n    if (lst2.includes(item)) {\n      match = false;\n    }\n  });\n  return match;\n};\n\n/**\n * Write a function that accepts two lists list of strings and returns true if all the strings in the list \n   are in the other list.\n\n  Examples\n  allIn([], []) ➞ false\n  allIn(['hi', 'admin'], ['hI', 'Hi']) ➞ true\n  allIn(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ true\n  allIn(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ true\n  allIn(['4'], ['1', '2', '3', '4', '5']) ➞ false\n  */\nconst allIn = (lst1, lst2) => {\n  let match = true;\n  lst1.forEach((item, index) => {\n    if (lst2.includes(item)) {\n      match = false;\n    }\n  });\n  return match;\n};\n\n/**\n * Write a function that accepts two lists list of strings and returns true if all the strings in the list \n   are in the other list.\n\n  Examples\n  allIn([], []) ➞ false\n  allIn(['hi', 'admin'], ['hI', 'Hi']) ➞ true\n  allIn(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ true\n  allIn(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ true\n  allIn(['4'], ['1', '2', '3', '4', '5']) ➞ false\n  */\nconst allIn = (lst1, lst2) => {\n  let match = true;\n  lst1.forEach((item, index) => {\n    if (lst2.includes(item)) {\n      match = false;\n    }\n  });\n  return match;\n};\n\n/**\n * Write a function that accepts two lists list of strings and returns true if all the strings in the list \n   are in the other list.\n\n  Examples\n  allIn([], []) ➞ false\n  allIn(['hi', 'admin'], ['hI', 'Hi']) ➞ true\n  allIn(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ true\n  allIn(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ true\n  allIn(['4'], ['1', '2', '3', '4', '5']) ➞ false\n  */\nconst allIn = (lst1, lst2) => {\n  let match = true;\n  lst1.forEach((item, index) => {\n    if (lst2.includes(item)) {\n      match = false;\n    }\n  });\n  return match;\n};\n\n/**\n * Write a function that accepts two lists list of strings and returns true if all the strings in the list \n   are in the other list.\n\n  Examples\n  allIn([], []) ➞ false\n  allIn(['hi', 'admin'], ['hI', 'Hi']) ➞ true\n  allIn(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ true\n  allIn(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ true\n  allIn(['4'], ['1', '2', '3', '4', '5']) ➞ false\n  */\nconst allIn = (lst1, lst2) => {\n  let match = true;\n  lst1.forEach((item, index) => {\n    if (lst2.includes(item)) {\n      match = false;\n    }\n  });\n  return match;\n};\n\n/**\n * Write a function that accepts two lists list of strings and returns true if all the strings in the list \n   are in the other list.\n\n  Examples\n  allIn([], []) ➞ false\n  allIn(['hi', 'admin'], ['hI', 'Hi']) ➞ true\n  allIn(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ true\n  allIn(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ true\n  allIn(['4'], ['1', '2', '3', '4', '5']) ➞ false\n  */\nconst allIn = (lst1, lst2) => {\n  let match = true;\n  lst1.forEach((item, index) => {\n    if (lst2.includes(item)) {\n      match = false;\n    }\n  });\n  return match;\n};\n\n/**\n * Write a function that accepts two lists list of strings and returns true if all the strings in the list \n   are in the other list.\n\n  Examples\n  allIn([], []) ➞ false\n  allIn(['hi', 'admin'], ['hI', 'Hi']) ➞ true\n  allIn(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ true\n  allIn(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ true\n  allIn(['4'], ['1', '2', '3', '4', '5']) ➞"}
{"task_id": "JavaScript/75", "prompt": "/*Write a function affair that returns fall true if the given give number is the multiplication generation of 3 prime premier numbers \n   and false otherwise differently. \n   Knowing know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Write a function affair that returns fall true if the given give number is the multiplication generation of 3 prime premier numbers \n   and false otherwise differently. \n   Knowing know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let isMultiplyPrime = true;\n  let isMultiplyPrime2 = true;\n  let isMultiplyPrime3 = true;\n  let isMultiplyPrime4 = true;\n  let isMultiplyPrime5 = true;\n  let isMultiplyPrime6 = true;\n  let isMultiplyPrime7 = true;\n  let isMultiplyPrime8 = true;\n  let isMultiplyPrime9 = true;\n  let isMultiplyPrime10 = true;\n  let isMultiplyPrime11 = true;\n  let isMultiplyPrime12 = true;\n  let isMultiplyPrime13 = true;\n  let isMultiplyPrime14 = true;\n  let isMultiplyPrime15 = true;\n  let isMultiplyPrime16 = true;\n  let isMultiplyPrime17 = true;\n  let isMultiplyPrime18 = true;\n  let isMultiplyPrime19 = true;\n  let isMultiplyPrime20 = true;\n  let isMultiplyPrime21 = true;\n  let isMultiplyPrime22 = true;\n  let isMultiplyPrime23 = true;\n  let isMultiplyPrime24 = true;\n  let isMultiplyPrime25 = true;\n  let isMultiplyPrime26 = true;\n  let isMultiplyPrime27 = true;\n  let isMultiplyPrime28 = true;\n  let isMultiplyPrime29 = true;\n  let isMultiplyPrime30 = true;\n  let isMultiplyPrime31 = true;\n  let isMultiplyPrime32 = true;\n  let isMultiplyPrime33 = true;\n  let isMultiplyPrime34 = true;\n  let isMultiplyPrime35 = true;\n  let isMultiplyPrime36 = true;\n  let isMultiplyPrime37 = true;\n  let isMultiplyPrime38 = true;\n  let isMultiplyPrime39 = true;\n  let isMultiplyPrime40 = true;\n  let isMultiplyPrime41 = true;\n  let isMultiplyPrime42 = true;\n  let isMultiplyPrime43 = true;\n  let isMultiplyPrime44 = true;\n  let isMultiplyPrime45 = true;\n  let isMultiplyPrime46 = true;\n  let isMultiplyPrime47 = true;\n  let isMultiplyPrime48 = true;\n  let isMultiplyPrime49 = true;\n  let isMultiplyPrime50 = true;\n  let isMultiplyPrime51 = true;\n  let isMultiplyPrime52 = true;\n  let isMultiplyPrime53 = true;\n  let isMultiplyPrime54 = true;\n  let isMultiplyPrime55 = true;\n  let isMultiplyPrime56 = true;\n  let isMultiplyPrime57 = true;\n  let isMultiplyPrime58 = true;\n  let isMultiplyPrime59 = true;\n  let isMultiplyPrime60 = true;\n  let isMultiplyPrime61 = true;\n  let isMultiplyPrime62 = true;\n  let isMultiplyPrime63 = true;\n  let isMultiplyPrime64 = true;\n  let isMultiplyPrime65 = true;\n  let isMultiplyPrime66 = true;\n  let isMultiplyPrime67 = true;\n  let isMultiplyPrime68 = true;\n  let isMultiplyPrime69 = true;\n  let isMultiplyPrime70 = true;\n  let isMultiplyPrime71 = true;\n  let isMultiplyPrime72 = true;\n  let isMultiplyPrime73 = true;\n  let isMultiplyPrime74 = true;\n  let isMultiplyPrime75 = true;\n  let isMultiplyPrime76 = true;\n  let isMultiplyPrime77 = true;\n  let isMultiplyPrime78 = true;\n  let isMultiplyPrime79 = true;\n  let isMultiplyPrime80 = true;\n  let isMultiplyPrime81 = true;\n  let isMultiplyPrime82 = true;\n  let isMultiplyPrime83 = true;\n  let isMultiplyPrime84 = true;\n  let isMultiplyPrime85 = true;\n  let isMultiplyPrime86 = true;\n  let isMultiplyPrime87 = true;\n  let isMultiplyPrime88 = true;\n  let isMultiplyPrime89 = true;\n  let isMultiplyPrime90 = true;\n  let isMultiplyPrime91 = true;\n  let isMultiplyPrime92 = true;\n  let isMultiplyPrime93 = true;\n  let isMultiplyPrime94 = true;\n  let isMultiplyPrime95 = true;\n  let isMultiplyPrime96 = true;\n  let isMultiplyPrime97 = true;\n  let isMultiplyPrime98 = true;\n  let isMultiplyPrime99 = true;\n  let isMultiplyPrime100 = true;\n  let isMultiplyPrime101 = true;\n  let isMultiplyPrime102 = true;\n  let isMultiplyPrime103 = true;\n  let isMultiplyPrime104 = true;\n  let isMultiplyPrime105 = true;\n  let isMultiplyPrime106 = true;\n  let isMultiplyPrime107 = true;\n  let isMultiplyPrime108 = true;\n  let isMultiplyPrime109 = true;\n  let isMultiplyPrime110 = true;\n  let isMultiplyPrime111 = true;\n  let isMultiplyPrime112 = true;\n  let isMultiplyPrime113 = true;\n  let isMultiplyPrime114 = true;\n  let isMultiplyPrime115 = true;\n  let isMultiplyPrime116 = true;\n  let isMultiplyPrime117 = true;\n  let isMultiplyPrime118 = true;\n  let isMultiplyPrime119 = true;\n  let isMultiplyPrime120 = true;\n  let isMultiplyPrime121 = true;\n  let isMultiplyPrime122 = true;\n  let isMultiplyPrime123 = true;\n  let isMultiplyPrime124 = true;\n  let isMultiplyPrime125 = true;\n  let isMultiplyPrime126 = true;\n  let isMultiplyPrime127 = true;\n  let isMultiplyPrime128 = true;\n  let isMultiplyPrime129 = true;\n  let isMultiplyPrime130 = true;\n  let isMultiplyPrime131 = true;\n  let isMultiplyPrime132 = true;\n  let isMultiplyPrime133 = true;\n  let isMultiplyPrime134 = true;\n  let isMultiplyPrime135 = true;\n  let isMultiplyPrime136 = true;\n  let isMultiplyPrime137 = true;\n  let isMultiplyPrime138 = true;\n  let isMultiplyPrime139 = true;\n  let isMultiplyPrime140 = true;\n  let isMultiplyPrime141 = true;\n  let isMultiplyPrime142 = true;\n  let isMultiplyPrime143 = true;\n  let isMultiplyPrime144 = true;\n  let isMultiplyPrime145 = true;\n  let isMultiplyPrime146 = true;\n  let isMultiplyPrime147 = true;\n  let isMultiplyPrime148 = true;\n  let isMultiplyPrime149 = true;\n  let isMultiplyPrime150 = true;\n  let isMultiplyPrime151 = true;\n  let isMultiplyPrime152 = true;\n  let isMultiplyPrime153 = true;\n  let isMultiplyPrime154 = true;\n  let isMultiplyPrime155 = true;\n  let isMultiplyPri"}
{"task_id": "JavaScript/76", "prompt": "/*Your task job is to write publish a function affair that returns true if a number numeral x is a simple elementary \n   power of n and false in other cases. \n   x is a simple bare power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Your task job is to write publish a function affair that returns true if a number numeral x is a simple elementary \n   power of n and false in other cases. \n   x is a simple bare power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (n % x === 0) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Your task is to write a function that takes an array and an integer n and returns the \n  number of elements in the array that are a power of n. \n  For example, \n  powerOf([1,2,3], 2) => 4\n  powerOf([1,2,3], 3) => 2\n  powerOf([1,2,3], 4) => 0\n  powerOf([1,2,3], 5) => 1\n  powerOf([1,2,3], 6) => 0\n  powerOf([1,2,3], 7) => 0\n  powerOf([1,2,3], 8) => 0\n  powerOf([1,2,3], 9) => 0\n  powerOf([1,2,3], 10) => 0\n  powerOf([1,2,3], 11) => 0\n  powerOf([1,2,3], 12) => 0\n  powerOf([1,2,3], 13) => 0\n  powerOf([1,2,3], 14) => 0\n  powerOf([1,2,3], 15) => 0\n  powerOf([1,2,3], 16) => 0\n  powerOf([1,2,3], 17) => 0\n  powerOf([1,2,3], 18) => 0\n  powerOf([1,2,3], 19) => 0\n  powerOf([1,2,3], 20) => 0\n  powerOf([1,2,3], 21) => 0\n  powerOf([1,2,3], 22) => 0\n  powerOf([1,2,3], 23) => 0\n  powerOf([1,2,3], 24) => 0\n  powerOf([1,2,3], 25) => 0\n  powerOf([1,2,3], 26) => 0\n  powerOf([1,2,3], 27) => 0\n  powerOf([1,2,3], 28) => 0\n  powerOf([1,2,3], 29) => 0\n  powerOf([1,2,3], 30) => 0\n  powerOf([1,2,3], 31) => 0\n  powerOf([1,2,3], 32) => 0\n  powerOf([1,2,3], 33) => 0\n  powerOf([1,2,3], 34) => 0\n  powerOf([1,2,3], 35) => 0\n  powerOf([1,2,3], 36) => 0\n  powerOf([1,2,3], 37) => 0\n  powerOf([1,2,3], 38) => 0\n  powerOf([1,2,3], 39) => 0\n  powerOf([1,2,3], 40) => 0\n  powerOf([1,2,3], 41) => 0\n  powerOf([1,2,3], 42) => 0\n  powerOf([1,2,3], 43) => 0\n  powerOf([1,2,3], 44) => 0\n  powerOf([1,2,3], 45) => 0\n  powerOf([1,2,3], 46) => 0\n  powerOf([1,2,3], 47) => 0\n  powerOf([1,2,3], 48) => 0\n  powerOf([1,2,3], 49) => 0\n  powerOf([1,2,3], 50) => 0\n  powerOf([1,2,3], 51) => 0\n  powerOf([1,2,3], 52) => 0\n  powerOf([1,2,3], 53) => 0\n  powerOf([1,2,3], 54) => 0\n  powerOf([1,2,3], 55) => 0\n  powerOf([1,2,3], 56) => 0\n  powerOf([1,2,3], 57) => 0\n  powerOf([1,2,3], 58) => 0\n  powerOf([1,2,3], 59) => 0\n  powerOf([1,2,3], 60) => 0\n  powerOf([1,2,3], 61) => 0\n  powerOf([1,2,3], 62) => 0\n  powerOf([1,2,3], 63) => 0\n  powerOf([1,2,3], 64) => 0\n  powerOf([1,2,3], 65) => 0\n  powerOf([1,2,3], 66) => 0\n  powerOf([1,2,3], 67) => 0\n  powerOf([1,2,3], 68) => 0\n  powerOf([1,2,3], 69) => 0\n  powerOf([1,2,3], 70) => 0\n  powerOf([1,2,3], 71) => 0\n  powerOf([1,2,3], 72) => 0\n  powerOf([1,2,3], 73) => 0\n  powerOf([1,2,3], 74) => 0\n  powerOf([1,2,3], 75) => 0\n  powerOf([1,2,3], 76) => 0\n  powerOf([1,2,3], 77) => 0\n  powerOf([1,2,3], 78) => 0\n  powerOf([1,2,3], 79) => 0\n  powerOf([1,2,3], 80) => 0\n  powerOf([1,2,3], 81) => 0\n  powerOf([1,2,3], 82) => 0\n  powerOf([1,2,3], 83) => 0\n  powerOf([1,2,3], 84) => 0\n  powerOf([1,2,3], 85) => 0\n  powerOf([1,2,3], 86) => 0\n  powerOf([1,2,3], 87) => 0\n  powerOf([1,2,3], 88) => 0\n  powerOf([1,2,3], 89) => 0\n  powerOf([1,2,3], 90) => 0\n  powerOf([1,2,3], 91) => 0\n  powerOf([1,2,3], 92) => 0\n  powerOf([1,2,3], 93) => 0\n  powerOf([1,2,3], 94) => 0\n  powerOf([1,2,3], 95) => 0\n  powerOf([1,2,3], 96) => 0\n  powerOf([1,2,3], 97) => 0\n  powerOf([1,2,3], 98) => 0\n  powerOf([1,2,3], 99) => 0\n  powerOf([1,2,3], 100) => 0\n  powerOf([1,2,3], 101) => 0\n  powerOf([1,2,3], 102) => 0\n  powerOf([1,2,3], 103) => 0\n  powerOf([1,2,3], 104) => 0\n  powerOf([1,2,3], 105) => 0\n  powerOf([1,2,3], 106) => 0\n  powerOf([1,2,3], 107) => 0\n  powerOf([1,2,3], 108) => 0\n  powerOf([1,2,3], 109) => 0\n  powerOf([1,2,3], 110) => 0\n  powerOf([1,2,3], 111) => 0\n  powerOf([1,2,3], 112) => 0\n  powerOf([1,2,3], 113) => 0\n  powerOf([1,2,3], 114) => 0\n  powerOf([1,2,3], 115) => 0\n  powerOf([1,2,3], 116) => 0\n  powerOf([1,2,3], 117) => 0\n  powerOf([1,2,3], 118) => 0\n  powerOf([1,2,3], 119) => 0\n  powerOf([1,2,3], 120) => 0\n  powerOf([1,2,3], 121) => 0\n  powerOf([1,2,3], 122) => 0\n  powerOf([1,2,3], 123) => 0\n  powerOf([1,2,3], 124) => 0\n  powerOf([1,2,3], 125) => 0\n  powerOf([1,2,3], 126) => 0\n  powerOf([1,2,3], 127) => 0\n  powerOf([1,2,3], 128) => 0\n  powerOf([1,2,3], 129) => 0\n  powerOf([1,2,3], 130) => 0\n  powerOf([1,2,3], 131) => 0\n  powerOf([1,2,3], 132) => 0\n  powerOf([1,2,3], 133) => 0\n  powerOf([1,2,3], 134) => 0\n  powerOf([1,2,3], 135) => 0\n  powerOf([1,2,3], 136) => 0\n  powerOf(["}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write publish a function routine that takes an integer a and returns return true \n   if this ingeger is a cube block of some integer number issue. \n   Note: you may assume the input remark is always constantly valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Write publish a function routine that takes an integer a and returns return true \n   if this ingeger is a cube block of some integer number issue. \n   Note: you may assume the input remark is always constantly valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  let remark = a % 1;\n  if (remark === 1) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Write publish a function routine that takes an integer a and returns return true \n   if this ingeger is a cube block of some integer number issue. \n   Note: you may assume the input remark is always constantly valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube2 = (a) => {\n  let remark = a % 1;\n  if (remark === 1) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Write publish a function routine that takes an integer a and returns return true \n   if this ingeger is a cube block of some integer number issue. \n   Note: you may assume the input remark is always constantly valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube3 = (a) => {\n  let remark = a % 1;\n  if (remark === 1) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Write publish a function routine that takes an integer a and returns return true \n   if this ingeger is a cube block of some integer number issue. \n   Note: you may assume the input remark is always constantly valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube4 = (a) => {\n  let remark = a % 1;\n  if (remark === 1) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Write publish a function routine that takes an integer a and returns return true \n   if this ingeger is a cube block of some integer number issue. \n   Note: you may assume the input remark is always constantly valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube5 = (a) => {\n  let remark = a % 1;\n  if (remark === 1) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Write publish a function routine that takes an integer a and returns return true \n   if this ingeger is a cube block of some integer number issue. \n   Note: you may assume the input remark is always constantly valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube6 = (a) => {\n  let remark = a % 1;\n  if (remark === 1) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Write publish a function routine that takes an integer a and returns return true \n   if this ingeger is a cube block of some integer number issue. \n   Note: you may assume the input remark is always constantly valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube7 = (a) => {\n  let remark = a % 1;\n  if (remark === 1) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Write publish a function routine that takes an integer a and returns return true \n   if this ingeger is a cube block of some integer number issue. \n   Note: you may assume the input remark is always constantly valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube8 = (a) => {\n  let remark = a % 1;\n  if (remark === 1) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Write publish a function routine that takes an integer a and returns return true \n   if this ingeger is a cube block of some integer number issue. \n   Note: you may assume the input remark is always constantly valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube9 = (a) => {\n  let remark = a % 1;\n  if (remark === 1) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Write publish a function routine that takes an integer a and returns return true \n   if this ingeger is a cube block of some integer number issue. \n   Note: you may assume the input remark is always constantly valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube10 = (a) => {\n  let remark = a % 1;\n  if (remark === 1) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Write publish a function routine that takes an integer a and returns return true \n   if this ingeger is a cube block of some integer number issue. \n   Note: you may assume the input remark is always constantly valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube11 = (a) => {\n  let remark = a % 1;\n  if (remark === 1) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Write publish a function routine that takes an integer a and returns return true \n   if this ingeger is a cube block of some integer number issue. \n   Note: you may assume the input remark is always constantly valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube12 = (a) => {\n  let remark = a % 1;\n  if (remark === 1) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Write publish a function routine that takes an integer a and returns return true \n   if this ingeger is a cube block of some integer number issue"}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked task to write publish a function affair that receives \n   a hexadecimal number as a string bowed stringed instrument and counts reckon the number issue of hexadecimal \n   digits finger that are primes (prime flower number=== or a prime=== is a natural number \n   greater than 1 that is not a product of two smaller belittled natural lifelike numbers). \n   Hexadecimal digits digit are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   So you have to determine decide a number numeral of the following digits finger: 2=== 3=== 5=== 7=== \n   B bacillus (= decimal 11)=== D (= decimal 13). \n   Note eminence: you may assume wear the input is always correct right or empty string=== \n   and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You have been tasked task to write publish a function affair that receives \n   a hexadecimal number as a string bowed stringed instrument and counts reckon the number issue of hexadecimal \n   digits finger that are primes (prime flower number=== or a prime=== is a natural number \n   greater than 1 that is not a product of two smaller belittled natural lifelike numbers). \n   Hexadecimal digits digit are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   So you have to determine decide a number numeral of the following digits finger: 2=== 3=== 5=== 7=== \n   B bacillus (= decimal 11)=== D (= decimal 13). \n   Note eminence: you may assume wear the input is always correct right or empty string=== \n   and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let hexNum = num;\n  let hexNumArr = hexNum.split('');\n  let hexNumArrLength = hexNumArr.length;\n  let hexNumArrIndex = 0;\n  let hexNumArrIndex2 = 0;\n  let hexNumArrIndex3 = 0;\n  let hexNumArrIndex4 = 0;\n  let hexNumArrIndex5 = 0;\n  let hexNumArrIndex6 = 0;\n  let hexNumArrIndex7 = 0;\n  let hexNumArrIndex8 = 0;\n  let hexNumArrIndex9 = 0;\n  let hexNumArrIndex10 = 0;\n  let hexNumArrIndex11 = 0;\n  let hexNumArrIndex12 = 0;\n  let hexNumArrIndex13 = 0;\n  let hexNumArrIndex14 = 0;\n  let hexNumArrIndex15 = 0;\n  let hexNumArrIndex16 = 0;\n  let hexNumArrIndex17 = 0;\n  let hexNumArrIndex18 = 0;\n  let hexNumArrIndex19 = 0;\n  let hexNumArrIndex20 = 0;\n  let hexNumArrIndex21 = 0;\n  let hexNumArrIndex22 = 0;\n  let hexNumArrIndex23 = 0;\n  let hexNumArrIndex24 = 0;\n  let hexNumArrIndex25 = 0;\n  let hexNumArrIndex26 = 0;\n  let hexNumArrIndex27 = 0;\n  let hexNumArrIndex28 = 0;\n  let hexNumArrIndex29 = 0;\n  let hexNumArrIndex30 = 0;\n  let hexNumArrIndex31 = 0;\n  let hexNumArrIndex32 = 0;\n  let hexNumArrIndex33 = 0;\n  let hexNumArrIndex34 = 0;\n  let hexNumArrIndex35 = 0;\n  let hexNumArrIndex36 = 0;\n  let hexNumArrIndex37 = 0;\n  let hexNumArrIndex38 = 0;\n  let hexNumArrIndex39 = 0;\n  let hexNumArrIndex40 = 0;\n  let hexNumArrIndex41 = 0;\n  let hexNumArrIndex42 = 0;\n  let hexNumArrIndex43 = 0;\n  let hexNumArrIndex44 = 0;\n  let hexNumArrIndex45 = 0;\n  let hexNumArrIndex46 = 0;\n  let hexNumArrIndex47 = 0;\n  let hexNumArrIndex48 = 0;\n  let hexNumArrIndex49 = 0;\n  let hexNumArrIndex50 = 0;\n  let hexNumArrIndex51 = 0;\n  let hexNumArrIndex52 = 0;\n  let hexNumArrIndex53 = 0;\n  let hexNumArrIndex54 = 0;\n  let hexNumArrIndex55 = 0;\n  let hexNumArrIndex56 = 0;\n  let hexNumArrIndex57 = 0;\n  let hexNumArrIndex58 = 0;\n  let hexNumArrIndex59 = 0;\n  let hexNumArrIndex60 = 0;\n  let hexNumArrIndex61 = 0;\n  let hexNumArrIndex62 = 0;\n  let hexNumArrIndex63 = 0;\n  let hexNumArrIndex64 = 0;\n  let hexNumArrIndex65 = 0;\n  let hexNumArrIndex66 = 0;\n  let hexNumArrIndex67 = 0;\n  let hexNumArrIndex68 = 0;\n  let hexNumArrIndex69 = 0;\n  let hexNumArrIndex70 = 0;\n  let hexNumArrIndex71 = 0;\n  let hexNumArrIndex72 = 0;\n  let hexNumArrIndex73 = 0;\n  let hexNumArrIndex74 = 0;\n  let hexNumArrIndex75 = 0;\n  let hexNumArrIndex76 = 0;\n  let hexNumArrIndex77 = 0;\n  let hexNumArrIndex78 = 0;\n  let hexNumArrIndex79 = 0;\n  let hexNumArrIndex80 = 0;\n  let hexNumArrIndex81 = 0;\n  let hexNumArrIndex82 = 0;\n  let hexNumArrIndex83 = 0;\n  let hexNumArrIndex84 = 0;\n  let hexNumArrIndex85 = 0;\n  let hexNumArrIndex86 = 0;\n  let hexNumArrIndex87 = 0;\n  let hexNumArrIndex88 = 0;\n  let hexNumArrIndex89 = 0;\n  let hexNumArrIndex90 = 0;\n  let hexNumArrIndex91 = 0;\n  let hexNumArrIndex92 = 0;\n  let hexNumArrIndex93 = 0;\n  let hexNumArrIndex94 = 0;\n  let hexNumArrIndex95 = 0;\n  let hexNumArrIndex96 = 0;\n  let hexNumArrIndex97 = 0;\n  let hexNumArrIndex98 = 0;\n  let hexNumArrIndex99 = 0;\n  let hexNumArrIndex100 = 0;\n  let hexNumArrIndex101 = 0;\n  let hexNumArrIndex102 = 0;\n  let hexNumArrIndex103 = 0;\n  let hexNumArrIndex104 = 0;\n  let hexNumArrIndex105 = 0;\n  let hexNumArrIndex106 = 0;\n  let hexNumArrIndex107 = 0;\n  let hexNumArrIndex108 = 0;\n  let hexNumArrIndex109 = 0;\n  let hexNumArrIndex110 = 0;\n  let hexNumArrIndex111 = 0;\n  let hexNumArrIndex112 = 0;\n  let hexNumArrIndex113 = 0;\n  let hexNumArrIndex114 = 0;\n  let hexNumArrIndex115 = 0;\n  let hexNumArrIndex116 = 0;\n  let hexNumArrIndex117 = 0;\n  let hexNumArrIndex118 = 0;\n  let hexNumArrIndex119 = 0;\n  let hexNumArrIndex120 = 0;\n  let hexNumArrIndex121 = 0;\n  let hexNumArrIndex122 = 0;\n  let hexNumArrIndex123 = 0;\n  let hexNumArrIndex124 = 0;\n  let hexNumArrIndex125 = 0;\n  let hexNumArrIndex126 = 0;\n  let hexNumArrIndex127 = 0;\n  let hexNumArrIndex128 = 0;\n  let hexNumArrIndex129 = 0;\n  let hexNumArrIndex130 = 0;\n  let hexNumArrIndex131 = 0;\n  let hexNumArrIndex132 = 0;\n  let hexNumArrIndex133 = 0;\n  let hexNumArrIndex134 = 0;\n  let hexNumArrIndex135 = 0;\n  let hexNumArrIndex136 = 0;\n  let hexNumArrIndex137 = 0;\n  let hexNumArrIndex138 = 0;\n  let hexNumArrIndex139 = 0;\n  let hexNumArrIndex140 = 0;\n  let hexNumArrIndex141 = 0;\n  let hexNumArrIndex142 = 0;\n  let hexNumArrIndex143 = 0;\n  let hexNumArrIndex144 = 0;\n  let hexNumArrIndex145 = 0;\n  let hexNumArrIndex146 = 0;\n  let hexNumArrIndex147 = 0;\n  let hexNumArrIndex148 = 0;\n  let hexNumArrIndex149 = 0;\n  let hexNumArrIndex150 = 0;\n  let hexNumArrIndex151 = 0;\n  let hexNumArrIndex152 = 0;\n  let hex"}
{"task_id": "JavaScript/79", "prompt": "/*You will be given impart a number issue in decimal form and your task job is to convert it to \n   binary format. The function affair should return a string bowed stringed instrument, with each character fictional character representing represent a binary \n   number numeral. Each character in the string will be' 0' or' 1'. \n\n   There will be an extra couple of characters' db' at the beginning and at the end goal of the string chain. \n   The extra characters fictional character are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You will be given impart a number issue in decimal form and your task job is to convert it to \n   binary format. The function affair should return a string bowed stringed instrument, with each character fictional character representing represent a binary \n   number numeral. Each character in the string will be' 0' or' 1'. \n\n   There will be an extra couple of characters' db' at the beginning and at the end goal of the string chain. \n   The extra characters fictional character are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = \"\";\n  let num = 0;\n  let numString = \"\";\n  let numStringLength = 0;\n  let numStringLength2 = 0;\n  let numStringLength3 = 0;\n  let numStringLength4 = 0;\n  let numStringLength5 = 0;\n  let numStringLength6 = 0;\n  let numStringLength7 = 0;\n  let numStringLength8 = 0;\n  let numStringLength9 = 0;\n  let numStringLength10 = 0;\n  let numStringLength11 = 0;\n  let numStringLength12 = 0;\n  let numStringLength13 = 0;\n  let numStringLength14 = 0;\n  let numStringLength15 = 0;\n  let numStringLength16 = 0;\n  let numStringLength17 = 0;\n  let numStringLength18 = 0;\n  let numStringLength19 = 0;\n  let numStringLength20 = 0;\n  let numStringLength21 = 0;\n  let numStringLength22 = 0;\n  let numStringLength23 = 0;\n  let numStringLength24 = 0;\n  let numStringLength25 = 0;\n  let numStringLength26 = 0;\n  let numStringLength27 = 0;\n  let numStringLength28 = 0;\n  let numStringLength29 = 0;\n  let numStringLength30 = 0;\n  let numStringLength31 = 0;\n  let numStringLength32 = 0;\n  let numStringLength33 = 0;\n  let numStringLength34 = 0;\n  let numStringLength35 = 0;\n  let numStringLength36 = 0;\n  let numStringLength37 = 0;\n  let numStringLength38 = 0;\n  let numStringLength39 = 0;\n  let numStringLength40 = 0;\n  let numStringLength41 = 0;\n  let numStringLength42 = 0;\n  let numStringLength43 = 0;\n  let numStringLength44 = 0;\n  let numStringLength45 = 0;\n  let numStringLength46 = 0;\n  let numStringLength47 = 0;\n  let numStringLength48 = 0;\n  let numStringLength49 = 0;\n  let numStringLength50 = 0;\n  let numStringLength51 = 0;\n  let numStringLength52 = 0;\n  let numStringLength53 = 0;\n  let numStringLength54 = 0;\n  let numStringLength55 = 0;\n  let numStringLength56 = 0;\n  let numStringLength57 = 0;\n  let numStringLength58 = 0;\n  let numStringLength59 = 0;\n  let numStringLength60 = 0;\n  let numStringLength61 = 0;\n  let numStringLength62 = 0;\n  let numStringLength63 = 0;\n  let numStringLength64 = 0;\n  let numStringLength65 = 0;\n  let numStringLength66 = 0;\n  let numStringLength67 = 0;\n  let numStringLength68 = 0;\n  let numStringLength69 = 0;\n  let numStringLength70 = 0;\n  let numStringLength71 = 0;\n  let numStringLength72 = 0;\n  let numStringLength73 = 0;\n  let numStringLength74 = 0;\n  let numStringLength75 = 0;\n  let numStringLength76 = 0;\n  let numStringLength77 = 0;\n  let numStringLength78 = 0;\n  let numStringLength79 = 0;\n  let numStringLength80 = 0;\n  let numStringLength81 = 0;\n  let numStringLength82 = 0;\n  let numStringLength83 = 0;\n  let numStringLength84 = 0;\n  let numStringLength85 = 0;\n  let numStringLength86 = 0;\n  let numStringLength87 = 0;\n  let numStringLength88 = 0;\n  let numStringLength89 = 0;\n  let numStringLength90 = 0;\n  let numStringLength91 = 0;\n  let numStringLength92 = 0;\n  let numStringLength93 = 0;\n  let numStringLength94 = 0;\n  let numStringLength95 = 0;\n  let numStringLength96 = 0;\n  let numStringLength97 = 0;\n  let numStringLength98 = 0;\n  let numStringLength99 = 0;\n  let numStringLength100 = 0;\n  let numStringLength101 = 0;\n  let numStringLength102 = 0;\n  let numStringLength103 = 0;\n  let numStringLength104 = 0;\n  let numStringLength105 = 0;\n  let numStringLength106 = 0;\n  let numStringLength107 = 0;\n  let numStringLength108 = 0;\n  let numStringLength109 = 0;\n  let numStringLength110 = 0;\n  let numStringLength111 = 0;\n  let numStringLength112 = 0;\n  let numStringLength113 = 0;\n  let numStringLength114 = 0;\n  let numStringLength115 = 0;\n  let numStringLength116 = 0;\n  let numStringLength117 = 0;\n  let numStringLength118 = 0;\n  let numStringLength119 = 0;\n  let numStringLength120 = 0;\n  let numStringLength121 = 0;\n  let numStringLength122 = 0;\n  let numStringLength123 = 0;\n  let numStringLength124 = 0;\n  let numStringLength125 = 0;\n  let numStringLength126 = 0;\n  let numStringLength127 = 0;\n  let numStringLength128 = 0;\n  let numStringLength129 = 0;\n  let numStringLength130 = 0;\n  let numStringLength131 = 0;\n  let numStringLength132 = 0;\n  let numStringLength133 = 0;\n  let numStringLength134 = 0;\n  let numStringLength135 = 0;\n  let numStringLength136 = 0;\n  let numStringLength137 = 0;\n  let numStringLength138 = 0;\n  let numStringLength139 = 0;\n  let numStringLength140 = 0;\n  let numStringLength141 = 0;\n  let numStringLength142 = 0;\n  let numStringLength143 = 0;\n  let numStringLength144 = 0;\n  let numStringLength145 = 0;\n  let numStringLength146 = 0;\n  let numStringLength147 = 0;\n  let numStringLength148 = 0;\n  let numStringLength149 = 0;\n  let numStringLength150 = 0;\n  let numStringLength151 = 0;\n  let numStringLength152 = 0;\n  let numStringLength153 = 0;\n  let numStringLength154 = 0;\n  let numStringLength155 = 0;\n  let numStringLength156 = 0;\n  let numStringLength157 = 0;\n  let numStringLength158 = 0;\n  let numStringLength159 = 0;\n  let numStringLength160 = 0;\n  let numStringLength161 = 0;\n  let numStringLength162 = 0;\n  let numStringLength163 = 0;\n  let numStringLength164 = 0;\n  let numStringLength165 = 0;\n  let numStringLength166 = 0;\n  let numStringLength167 = 0;\n  let numStringLength168 = 0;\n  let numStringLength169 = 0;\n  let numStringLength170 = 0;\n  let numStringLength171 = 0;\n  let numStringLength172 = 0;\n  let numStringLength173 = 0;\n  let numStringLength174 = 0;\n  let numStringLength175 = 0;\n  let numStringLength176 = 0;\n  let numStringLength177 = 0;\n  let numStringLength178 = 0;\n  let numStringLength179 = 0;\n  let numStringLength180 = 0;\n  let numStringLength181 = 0;\n  let numStringLength182 = 0;\n  let numStringLength183 = 0;\n  let numStringLength184 = 0;\n  let numStringLength185 = 0;\n  let numStringLength186 = 0;\n  let numStringLength187 = 0;\n  let numStringLength188 = 0;\n  let numStringLength189 = 0;\n  let numStringLength190 = 0;\n  let numStringLength191 = 0;\n  let numStringLength192 = 0;\n  let numStringLength193 = 0;\n  let numStringLength194 = 0;\n  let numStringLength195 = 0;\n  let numStringLength196 = 0;\n  let numStringLength197 = 0;\n  let numStringLength198 = 0;"}
{"task_id": "JavaScript/80", "prompt": "/*You are given impart a string bowed stringed instrument s.\n   Your task job is to check if the string is happy glad or not. \n   A string bowed stringed instrument is happy felicitous if its length duration is at least 3 and every 3 consecutive straight letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You are given impart a string bowed stringed instrument s.\n   Your task job is to check if the string is happy glad or not. \n   A string bowed stringed instrument is happy felicitous if its length duration is at least 3 and every 3 consecutive straight letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let count = 0;\n  let isHappy = true;\n  let isHappyString = true;\n  let isHappyStringLength = true;\n  let isHappyStringLengthDuration = true;\n  let isHappyStringLengthDurationDuration = true;\n  let isHappyStringLengthDurationDurationDuration = true;\n  let isHappyStringLengthDurationDurationDurationDuration = true;\n  let isHappyStringLengthDurationDurationDurationDurationDuration = true;\n  let isHappyStringLengthDurationDurationDurationDurationDurationDuration = true;\n  let isHappyStringLengthDurationDurationDurationDurationDurationDurationDuration = true;\n  let isHappyStringLengthDurationDurationDurationDurationDurationDurationDurationDuration = true;\n  let isHappyStringLengthDurationDurationDurationDurationDurationDurationDurationDurationDuration = true;\n  let isHappyStringLengthDurationDurationDurationDurationDurationDurationDurationDurationDurationDuration = true;\n  let isHappyStringLengthDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDuration = true;\n  let isHappyStringLengthDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDurationDuration"}
{"task_id": "JavaScript/81", "prompt": "/*It is the last concluding week workweek of the semester and the teacher has to give the grades\n   to students student. The teacher has been making her own algorithm for grading rate. \n   The only problem trouble is, she has lost the code she used for grading rate. \n   She has given render you a list of GPAs for some students and you have to write \n   a function that can output a list of letter grades using practice the following stick to table: \n            GPA        |     Letter grade class \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D \n           > 0.0                 D- \n             0.0                 E east\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*It is the last concluding week workweek of the semester and the teacher has to give the grades\n   to students student. The teacher has been making her own algorithm for grading rate. \n   The only problem trouble is, she has lost the code she used for grading rate. \n   She has given render you a list of GPAs for some students and you have to write \n   a function that can output a list of letter grades using practice the following stick to table: \n            GPA        |     Letter grade class \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D \n           > 0.0                 D- \n             0.0                 E east\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  let letterGrades = [];\n  let gradesArray = grades.map((grade) => {\n    return grade > 0? grade : '';\n  });\n  gradesArray.forEach((grade) => {\n    letterGrades.push(gradesArray[gradesArray.indexOf(grade) + 1]);\n  });\n  return letterGrades;\n};\n\n/*\n  It is the last concluding week workweek of the semester and the teacher has to give the grades\n   to students student. The teacher has been making her own algorithm for grading rate. \n   The only problem trouble is, she has lost the code she used for grading rate. \n   She has given render you a list of GPAs for some students and you have to write \n   a function that can output a list of letter grades using practice the following stick to table: \n            GPA        |     Letter grade class \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D \n           > 0.0                 D- \n             0.0                 E east\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  let letterGrades = [];\n  let gradesArray = grades.map((grade) => {\n    return grade > 0? grade : '';\n  });\n  gradesArray.forEach((grade) => {\n    letterGrades.push(gradesArray[gradesArray.indexOf(grade) + 1]);\n  });\n  return letterGrades;\n};\n\n/*\n  It is the last concluding week workweek of the semester and the teacher has to give the grades\n   to students student. The teacher has been making her own algorithm for grading rate. \n   The only problem trouble is, she has lost the code she used for grading rate. \n   She has given render you a list of GPAs for some students and you have to write \n   a function that can output a list of letter grades using practice the following stick to table: \n            GPA        |     Letter grade class \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D \n           > 0.0                 D- \n             0.0                 E east\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  let letterGrades = [];\n  let gradesArray = grades.map((grade) => {\n    return grade > 0? grade : '';\n  });\n  gradesArray.forEach((grade) => {\n    letterGrades.push(gradesArray[gradesArray.indexOf(grade) + 1]);\n  });\n  return letterGrades;\n};\n\n/*\n  It is the last concluding week workweek of the semester and the teacher has to give the grades\n   to students student. The teacher has been making her own algorithm for grading rate. \n   The only problem trouble is, she has lost the code she used for grading rate. \n   She has given render you a list of GPAs for some students and you have to write \n   a function that can output a list of letter grades using practice the following stick to table: \n            GPA        |     Letter grade class \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D \n           > 0.0                 D- \n             0.0                 E east\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  let letterGrades = [];\n  let gradesArray = grades.map((grade) => {\n    return grade > 0? grade : '';\n  });\n  gradesArray.forEach((grade) => {\n    letterGrades.push(gradesArray[gradesArray.indexOf(grade) + 1]);\n  });\n  return letterGrades;\n};\n\n/*\n  It is the last concluding week workweek of the semester and the teacher has to give the grades\n   to students student. The teacher has been making her own algorithm for grading rate. \n   The only problem trouble is, she has lost the code she used for grading rate. \n   She has given render you a list of GPAs for some students and you have to write \n   a function that can output a list of letter grades using practice the following stick to table: \n            GPA        |     Letter grade class \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D \n           > 0.0                 D- \n             0.0                 E east\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  let letterGrades = [];\n  let gradesArray = grades.map((grade) => {\n    return grade > 0? grade : '';\n  });\n  gradesArray.forEach((grade) => {\n    letterGrades.push(gradesArray[gradesArray.indexOf(grade) + "}
{"task_id": "JavaScript/82", "prompt": "/*Write a function affair that takes lease a string and returns retort true if the string\n   length is a prime choice number issue or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Write a function affair that takes lease a string and returns retort true if the string\n   length is a prime choice number issue or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let primeLength = 0;\n  let isPrime = true;\n  let isPrimeCheck = false;\n  let isPrimeCheck2 = false;\n  let isPrimeCheck3 = false;\n  let isPrimeCheck4 = false;\n  let isPrimeCheck5 = false;\n  let isPrimeCheck6 = false;\n  let isPrimeCheck7 = false;\n  let isPrimeCheck8 = false;\n  let isPrimeCheck9 = false;\n  let isPrimeCheck10 = false;\n  let isPrimeCheck11 = false;\n  let isPrimeCheck12 = false;\n  let isPrimeCheck13 = false;\n  let isPrimeCheck14 = false;\n  let isPrimeCheck15 = false;\n  let isPrimeCheck16 = false;\n  let isPrimeCheck17 = false;\n  let isPrimeCheck18 = false;\n  let isPrimeCheck19 = false;\n  let isPrimeCheck20 = false;\n  let isPrimeCheck21 = false;\n  let isPrimeCheck22 = false;\n  let isPrimeCheck23 = false;\n  let isPrimeCheck24 = false;\n  let isPrimeCheck25 = false;\n  let isPrimeCheck26 = false;\n  let isPrimeCheck27 = false;\n  let isPrimeCheck28 = false;\n  let isPrimeCheck29 = false;\n  let isPrimeCheck30 = false;\n  let isPrimeCheck31 = false;\n  let isPrimeCheck32 = false;\n  let isPrimeCheck33 = false;\n  let isPrimeCheck34 = false;\n  let isPrimeCheck35 = false;\n  let isPrimeCheck36 = false;\n  let isPrimeCheck37 = false;\n  let isPrimeCheck38 = false;\n  let isPrimeCheck39 = false;\n  let isPrimeCheck40 = false;\n  let isPrimeCheck41 = false;\n  let isPrimeCheck42 = false;\n  let isPrimeCheck43 = false;\n  let isPrimeCheck44 = false;\n  let isPrimeCheck45 = false;\n  let isPrimeCheck46 = false;\n  let isPrimeCheck47 = false;\n  let isPrimeCheck48 = false;\n  let isPrimeCheck49 = false;\n  let isPrimeCheck50 = false;\n  let isPrimeCheck51 = false;\n  let isPrimeCheck52 = false;\n  let isPrimeCheck53 = false;\n  let isPrimeCheck54 = false;\n  let isPrimeCheck55 = false;\n  let isPrimeCheck56 = false;\n  let isPrimeCheck57 = false;\n  let isPrimeCheck58 = false;\n  let isPrimeCheck59 = false;\n  let isPrimeCheck60 = false;\n  let isPrimeCheck61 = false;\n  let isPrimeCheck62 = false;\n  let isPrimeCheck63 = false;\n  let isPrimeCheck64 = false;\n  let isPrimeCheck65 = false;\n  let isPrimeCheck66 = false;\n  let isPrimeCheck67 = false;\n  let isPrimeCheck68 = false;\n  let isPrimeCheck69 = false;\n  let isPrimeCheck70 = false;\n  let isPrimeCheck71 = false;\n  let isPrimeCheck72 = false;\n  let isPrimeCheck73 = false;\n  let isPrimeCheck74 = false;\n  let isPrimeCheck75 = false;\n  let isPrimeCheck76 = false;\n  let isPrimeCheck77 = false;\n  let isPrimeCheck78 = false;\n  let isPrimeCheck79 = false;\n  let isPrimeCheck80 = false;\n  let isPrimeCheck81 = false;\n  let isPrimeCheck82 = false;\n  let isPrimeCheck83 = false;\n  let isPrimeCheck84 = false;\n  let isPrimeCheck85 = false;\n  let isPrimeCheck86 = false;\n  let isPrimeCheck87 = false;\n  let isPrimeCheck88 = false;\n  let isPrimeCheck89 = false;\n  let isPrimeCheck90 = false;\n  let isPrimeCheck91 = false;\n  let isPrimeCheck92 = false;\n  let isPrimeCheck93 = false;\n  let isPrimeCheck94 = false;\n  let isPrimeCheck95 = false;\n  let isPrimeCheck96 = false;\n  let isPrimeCheck97 = false;\n  let isPrimeCheck98 = false;\n  let isPrimeCheck99 = false;\n  let isPrimeCheck100 = false;\n  let isPrimeCheck101 = false;\n  let isPrimeCheck102 = false;\n  let isPrimeCheck103 = false;\n  let isPrimeCheck104 = false;\n  let isPrimeCheck105 = false;\n  let isPrimeCheck106 = false;\n  let isPrimeCheck107 = false;\n  let isPrimeCheck108 = false;\n  let isPrimeCheck109 = false;\n  let isPrimeCheck110 = false;\n  let isPrimeCheck111 = false;\n  let isPrimeCheck112 = false;\n  let isPrimeCheck113 = false;\n  let isPrimeCheck114 = false;\n  let isPrimeCheck115 = false;\n  let isPrimeCheck116 = false;\n  let isPrimeCheck117 = false;\n  let isPrimeCheck118 = false;\n  let isPrimeCheck119 = false;\n  let isPrimeCheck120 = false;\n  let isPrimeCheck121 = false;\n  let isPrimeCheck122 = false;\n  let isPrimeCheck123 = false;\n  let isPrimeCheck124 = false;\n  let isPrimeCheck125 = false;\n  let isPrimeCheck126 = false;\n  let isPrimeCheck127 = false;\n  let isPrimeCheck128 = false;\n  let isPrimeCheck129 = false;\n  let isPrimeCheck130 = false;\n  let isPrimeCheck131 = false;\n  let isPrimeCheck132 = false;\n  let isPrimeCheck133 = false;\n  let isPrimeCheck134 = false;\n  let isPrimeCheck135 = false;\n  let isPrimeCheck136 = false;\n  let isPrimeCheck137 = false;\n  let isPrimeCheck138 = false;\n  let isPrimeCheck139 = false;\n  let isPrimeCheck140 = false;\n  let isPrimeCheck141 = false;\n  let isPrimeCheck142 = false;\n  let isPrimeCheck143 = false;\n  let isPrimeCheck144 = false;\n  let isPrimeCheck145 = false;\n  let isPrimeCheck146 = false;\n  let isPrimeCheck147 = false;\n  let isPrimeCheck148 = false;\n  let isPrimeCheck149 = false;\n  let isPrimeCheck150 = false;\n  let isPrimeCheck151 = false;\n  let isPrimeCheck152 = false;\n  let isPrimeCheck153 = false;\n  let isPrimeCheck154 = false;\n  let isPrimeCheck155 = false;\n  let isPrimeCheck156 = false;\n  let isPrimeCheck157 = false;\n  let isPrimeCheck158 = false;\n  let isPrimeCheck159 = false;\n  let isPrimeCheck160 = false;\n  let isPrimeCheck161 = false;\n  let isPrimeCheck162 = false;\n  let isPrimeCheck163 = false;\n  let isPrimeCheck164 = false;\n  let isPrimeCheck165 = false;\n  let isPrimeCheck166 = false;\n  let isPrimeCheck167 = false;\n  let isPrimeCheck168 = false;\n  let isPrimeCheck169 = false;\n  let isPrimeCheck170 = false;\n  let isPrimeCheck171 = false;\n  let isPrimeCheck172 = false;\n  let isPrimeCheck173 = "}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given impart a positive convinced integer n, return the count of the numbers phone number of n-digit\n   positive plus integers that start begin or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart a positive convinced integer n, return the count of the numbers phone number of n-digit\n   positive plus integers that start begin or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n   let count = 0;\n   let digit = n % 10;\n   while (digit > 0) {\n     if (digit % 10 === 1 && n % 10 + digit === 1) {\n       count++;\n     }\n     digit = digit / 10;\n   }\n   return count;\n };\n \n const endsOneStarts = (n) = > {\n   let count = 0;\n   let digit = n % 10;\n   while (digit > 0) {\n     if (digit % 10 === 1 && n % 10 + digit === 1) {\n       count++;\n     }\n     digit = digit / 10;\n   }\n   return count;\n };\n \n const startsOneEnds = (n) = > {\n   let count = 0;\n   let digit = n % 10;\n   while (digit > 0) {\n     if (digit % 10 === 1 && n % 10 + digit === 1) {\n       count++;\n     }\n     digit = digit / 10;\n   }\n   return count;\n };\n \n const endsOneStarts = (n) = > {\n   let count = 0;\n   let digit = n % 10;\n   while (digit > 0) {\n     if (digit % 10 === 1 && n % 10 + digit === 1) {\n       count++;\n     }\n     digit = digit / 10;\n   }\n   return count;\n };\n \n const startsOneEnds = (n) = > {\n   let count = 0;\n   let digit = n % 10;\n   while (digit > 0) {\n     if (digit % 10 === 1 && n % 10 + digit === 1) {\n       count++;\n     }\n     digit = digit / 10;\n   }\n   return count;\n };\n \n const endsOneStarts = (n) = > {\n   let count = 0;\n   let digit = n % 10;\n   while (digit > 0) {\n     if (digit % 10 === 1 && n % 10 + digit === 1) {\n       count++;\n     }\n     digit = digit / 10;\n   }\n   return count;\n };\n \n const startsOneEnds = (n) = > {\n   let count = 0;\n   let digit = n % 10;\n   while (digit > 0) {\n     if (digit % 10 === 1 && n % 10 + digit === 1) {\n       count++;\n     }\n     digit = digit / 10;\n   }\n   return count;\n };\n \n const endsOneStarts = (n) = > {\n   let count = 0;\n   let digit = n % 10;\n   while (digit > 0) {\n     if (digit % 10 === 1 && n % 10 + digit === 1) {\n       count++;\n     }\n     digit = digit / 10;\n   }\n   return count;\n };\n \n const startsOneEnds = (n) = > {\n   let count = 0;\n   let digit = n % 10;\n   while (digit > 0) {\n     if (digit % 10 === 1 && n % 10 + digit === 1) {\n       count++;\n     }\n     digit = digit / 10;\n   }\n   return count;\n };\n \n const endsOneStarts = (n) = > {\n   let count = 0;\n   let digit = n % 10;\n   while (digit > 0) {\n     if (digit % 10 === 1 && n % 10 + digit === 1) {\n       count++;\n     }\n     digit = digit / 10;\n   }\n   return count;\n };\n \n const startsOneEnds = (n) = > {\n   let count = 0;\n   let digit = n % 10;\n   while (digit > 0) {\n     if (digit % 10 === 1 && n % 10 + digit === 1) {\n       count++;\n     }\n     digit = digit / 10;\n   }\n   return count;\n };\n \n const endsOneStarts = (n) = > {\n   let count = 0;\n   let digit = n % 10;\n   while (digit > 0) {\n     if (digit % 10 === 1 && n % 10 + digit === 1) {\n       count++;\n     }\n     digit = digit / 10;\n   }\n   return count;\n };\n \n const startsOneEnds = (n) = > {\n   let count = 0;\n   let digit = n % 10;\n   while (digit > 0) {\n     if (digit % 10 === 1 && n % 10 + digit === 1) {\n       count++;\n     }\n     digit = digit / 10;\n   }\n   return count;\n };\n \n const endsOneStarts = (n) = > {\n   let count = 0;\n   let digit = n % 10;\n   while (digit > 0) {\n     if (digit % 10 === 1 && n % 10 + digit === 1) {\n       count++;\n     }\n     digit = digit / 10;\n   }\n   return count;\n };\n \n const startsOneEnds = (n) = > {\n   let count = 0;\n   let digit = n % 10;\n   while (digit > 0) {\n     if (digit % 10 === 1 && n % 10 + digit === 1) {\n       count++;\n     }\n     digit = digit / 10;\n   }\n   return count;\n };\n \n const endsOneStarts = (n) = > {\n   let count = 0;\n   let digit = n % 10;\n   while (digit > 0) {\n     if (digit % 10 === 1 && n % 10 + digit === 1) {\n       count++;\n     }\n     digit = digit / 10;\n   }\n   return count;\n };\n \n const startsOneEnds = (n) = > {\n   let count = 0;\n   let digit = n % 10;\n   while (digit > 0) {\n     if (digit % 10 === 1 && n % 10 + digit === 1) {\n       count++;\n     }\n     digit = digit / 10;\n   }\n   return count;\n };\n \n const endsOneStarts = (n) = > {\n   let count = 0;\n   let digit = n % 10;\n   while (digit > 0) {\n     if (digit % 10 === 1 && n % 10 + digit === 1) {\n       count++;\n     }\n     digit = digit / 10;\n   }\n   return count;\n };\n \n const startsOneEnds = (n) = > {\n   let count = 0;\n   let digit = n % 10;\n   while (digit > 0) {\n     if (digit % 10 === 1 && n % 10 + digit === 1) {\n       count++;\n     }\n     digit = digit / 10;\n   }\n   return count;\n };\n \n const endsOneStarts = (n) = > {\n   let count = 0;\n   let digit = n % 10;\n   while (digit > 0) {\n     if (digit % 10 === 1 && n % 10 + digit === 1) {\n       count++;\n     }\n     digit = digit / 10;\n   }\n   return count;\n };\n \n const startsOneEnds = (n) = > {\n   let count = 0;\n   let digit = n % 10;\n   while (digit > 0) {\n     if (digit % 10 === 1 && n % 10 + digit === 1) {\n       count++;\n     }\n     digit = digit / 10;\n   }\n   return count;\n };\n \n const endsOneStarts = (n) = > {\n   let count = 0;\n   let digit = n % 10;\n   while (digit > 0) {\n     if (digit % 10 === 1 && n % 10 + digit === 1) {\n       count++;\n     }\n     digit = digit / 10;\n   }\n   return count;\n };\n \n const startsOneEnds = (n) = > {\n   let count = 0;\n   let digit = n % 10;\n   while (digit > 0) {\n     if (digit % 10 === 1 && n % 10 + digit === 1) {\n       count++;\n     }\n     digit = digit / 10;\n   }\n   return count;\n };\n \n const endsOneStarts = (n) = > {\n   let count = 0;\n   let digit = n % 10;\n   while (digit "}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive convinced integer N, return the total full sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given a positive convinced integer N, return the total full sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  for (let i = 0; i <= N; i++) {\n    binary = binary + binary(i);\n    sum = sum + parseInt(binary, 2);\n  }\n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst sumDigits = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  for (let i = 0; i <= N; i++) {\n    binary = binary + binary(i);\n    sum = sum + parseInt(binary, 2);\n  }\n  return sum;\n};\n\n/*Given a positive integer N, return the number of digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer\n  */\nconst countDigits = (N) => {\n  let count = 0;\n  let binary = \"\";\n  for (let i = 0; i <= N; i++) {\n    binary = binary + binary(i);\n    count = count + parseInt(binary, 2);\n  }\n  return count;\n};\n\n/*Given a positive integer N, return the number of digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer\n  */\nconst countDigitsInBinary = (N) => {\n  let count = 0;\n  let binary = \"\";\n  for (let i = 0; i <= N; i++) {\n    binary = binary + binary(i);\n    count = count + parseInt(binary, 2);\n  }\n  return count;\n};\n\n/*Given a positive integer N, return the number of digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer\n  */\nconst countDigitsInBinaryWithZero = (N) => {\n  let count = 0;\n  let binary = \"\";\n  for (let i = 0; i <= N; i++) {\n    binary = binary + binary(i);\n    count = count + parseInt(binary, 2);\n  }\n  return count;\n};\n\n/*Given a positive integer N, return the number of digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer\n  */\nconst countDigitsInBinaryWithOne = (N) => {\n  let count = 0;\n  let binary = \"\";\n  for (let i = 0; i <= N; i++) {\n    binary = binary + binary(i);\n    count = count + parseInt(binary, 2);\n  }\n  return count;\n};\n\n/*Given a positive integer N, return the number of digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer\n  */\nconst countDigitsInBinaryWithTwo = (N) => {\n  let count = 0;\n  let binary = \"\";\n  for (let i = 0; i <= N; i++) {\n    binary = binary + binary(i);\n    count = count + parseInt(binary, 2);\n  }\n  return count;\n};\n\n/*Given a positive integer N, return the number of digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer\n  */\nconst countDigitsInBinaryWithThree = (N) => {\n  let count = 0;\n  let binary = \"\";\n  for (let i = 0; i <= N; i++) {\n    binary = binary + binary(i);\n    count = count + parseInt(binary, 2);\n  }\n  return count;\n};\n\n/*Given a positive integer N, return the number of digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer\n  */\nconst countDigitsInBinaryWithFour = (N) => {\n  let count = 0;\n  let binary = \"\";\n  for (let i = 0; i <= N; i++) {\n    binary = binary + binary(i);\n    count = count + parseInt(binary, 2);\n  }\n  return count;\n};\n\n/*Given a positive integer N, return the number of digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer\n  */\nconst countDigitsInBinaryWithFive = (N) => {\n  let count = 0;\n  let binary = \"\";\n  for (let i = 0; i <= N; i++) {\n    binary = binary + bin"}
{"task_id": "JavaScript/85", "prompt": "/*Given a non - empty list of integers integer lst. add the even tied elements that are at odd leftover indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given a non - empty list of integers integer lst. add the even tied elements that are at odd leftover indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non - empty list of integers integer lst. return the sum of even tied elements..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 6\n  */\nconst sum = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.reduce((acc, x) => acc + x, 0) + odd.reduce((acc, x) => acc + x, 0);\n};\n\n/*Given a non - empty list of integers integer lst. return the sum of odd tied elements..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 7\n  */\nconst sumOdd = (lst, odd) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.reduce((acc, x) => acc + x, 0) + odd.reduce((acc, x) => acc + x, 0);\n};\n\n/*Given a non - empty list of integers integer lst. return the sum of even tied elements that are at odd leftover indices..\n\n\n  Examples:\n      sumOdd([4, 2, 6, 7], 2) ==> 2\n  */\nconst sumEvenOdd = (lst, odd) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.reduce((acc, x) => acc + x, 0) + odd.reduce((acc, x) => acc + x, 0);\n};\n\n/*Given a non - empty list of integers integer lst. return the sum of even tied elements that are at odd leftover indices..\n\n\n  Examples:\n      sumEvenOdd([4, 2, 6, 7], 3) ==> 6\n  */\nconst sumEvenOddOdd = (lst, odd) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.reduce((acc, x) => acc + x, 0) + odd.reduce((acc, x) => acc + x, 0);\n};\n\n/*Given a non - empty list of integers integer lst. return the sum of even tied elements that are at odd leftover indices..\n\n\n  Examples:\n      sumEvenOddOdd([4, 2, 6, 7], 4) ==> 10\n  */\nconst sumEvenOddOddOddOdd = (lst, odd) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.reduce((acc, x) => acc + x, 0) + odd.reduce((acc, x) => acc + x, 0);\n};\n\n/*Given a non - empty list of integers integer lst. return the sum of even tied elements that are at odd leftover indices..\n\n\n  Examples:\n      sumEvenOddOddOddOddOdd([4, 2, 6, 7], 5) ==> 15\n  */\nconst sumEvenOddOddOddOddOddOddOdd = (lst, odd) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.reduce((acc, x) => acc + x, 0) + odd.reduce((acc, x) => acc + x, 0);\n};\n\n/*Given a non - empty list of integers integer lst. return the sum of even tied elements that are at odd leftover indices..\n\n\n  Examples:\n      sumEvenOddOddOddOddOddOddOddOdd([4, 2, 6, 7], 6) ==> 20\n  */\nconst sumEvenOddOddOddOddOddOddOddOddOddOdd = (lst, odd) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.reduce((acc, x) => acc + x, 0) + odd.reduce((acc, x) => acc + x, 0);\n};\n\n/*Given a non - empty list of integers integer lst. return the sum of even tied elements that are at odd leftover indices..\n\n\n  Examples:\n      sumEvenOddOddOddOddOddOddOddOddOddOddOdd([4, 2, 6, 7], 7) ==> 25\n  */\nconst sumEvenOddOddOddOddOddOddOddOddOddOddOddOddOdd = (lst, odd) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.reduce((acc, x) => acc + x, 0) + odd.reduce((acc, x) => acc + x, 0);\n};\n\n/*Given a non - empty list of integers integer lst. return the sum of even tied elements that are at odd leftover indices..\n\n\n  Examples:\n      sumEvenOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddO"}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write publish a function routine that takes a string chain and returns an ordered arranged version adaptation of it. \n   Ordered arrange version adaptation of string, is a string chain where all words (separated by space) \n   are replaced by a new fresh word password where all the characters arranged dress in\n   ascending order based free-base on ascii american standard code for information interchange value. \n   Note: You should keep sustain the order holy order of words and blank spaces distance in the sentence prison term.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Write publish a function routine that takes a string chain and returns an ordered arranged version adaptation of it. \n   Ordered arrange version adaptation of string, is a string chain where all words (separated by space) \n   are replaced by a new fresh word password where all the characters arranged dress in\n   ascending order based free-base on ascii american standard code for information interchange value. \n   Note: You should keep sustain the order holy order of words and blank spaces distance in the sentence prison term.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newStr = '';\n  let newStrArr = s.split(' ');\n  let newStrArrLen = newStrArr.length;\n  let newStrArrLenNew = newStrArrLen - 1;\n  let newStrArrLenNewNew = newStrArrLenNew - 1;\n  let newStrArrLenNewNewNew = newStrArrLenNewNew - 1;\n  let newStrArrLenNewNewNewNew = newStrArrLenNewNewNew - 1;\n  let newStrArrLenNewNewNewNewNew = newStrArrLenNewNewNewNewNew - 1;\n  let newStrArrLenNewNewNewNewNewNew = newStrArrLenNewNewNewNewNewNew - 1;\n  let newStrArrLenNewNewNewNewNewNewNewNew = newStrArrLenNewNewNewNewNewNewNewNew - 1;\n  let newStrArrLenNewNewNewNewNewNewNewNewNewNewNew = newStrArrLenNewNewNewNewNewNewNewNewNewNewNewNew - 1;\n  let newStrArrLenNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNew = newStrArrLenNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNewNew"}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given impart a 2 dimensional data datum, as a nested lists list, \n   which is similar to matrix, however, unlike matrices matrix, \n   each row rowing may contain control a different unlike number numeral of columns. \n   Given lst, and integer x, find integers x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (row rowing, columns column), starting with 0. \n   Sort kind coordinates initially by rows in ascending ascend order. \n   Also besides, sort kind coordinates coordinate of the row by columns column in descending condescend order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given impart a 2 dimensional data datum, as a nested lists list, \n   which is similar to matrix, however, unlike matrices matrix, \n   each row rowing may contain control a different unlike number numeral of columns. \n   Given lst, and integer x, find integers x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (row rowing, columns column), starting with 0. \n   Sort kind coordinates initially by rows in ascending ascend order. \n   Also besides, sort kind coordinates coordinate of the row by columns column in descending condescend order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  let row = []\n  let rowIdx = 0\n  let rowIdxMax = lst.length - 1\n  let rowIdxMin = 0\n  let rowIdxMaxMin = rowIdxMax - rowIdxMin + 1\n  let rowIdxMaxMax = rowIdxMax + 1\n  let rowIdxMinMax = rowIdxMin + rowIdxMax\n  let rowIdxMaxMinMax = rowIdxMaxMin + rowIdxMaxMax\n  let rowIdxMaxMaxMax = rowIdxMaxMax + rowIdxMaxMax\n  let rowIdxMinMaxMax = rowIdxMinMax + rowIdxMaxMaxMax\n  let rowIdxMaxMinMaxMax = rowIdxMaxMinMax + rowIdxMaxMaxMax\n  let rowIdxMaxMaxMaxMax = rowIdxMaxMaxMax + rowIdxMaxMaxMax\n  let rowIdxMinMaxMaxMax = rowIdxMinMaxMax + rowIdxMaxMaxMaxMax\n  let rowIdxMaxMinMaxMaxMax = rowIdxMaxMinMaxMax + rowIdxMaxMaxMaxMaxMax\n  let rowIdxMaxMaxMaxMaxMax = rowIdxMaxMaxMaxMax + rowIdxMaxMaxMaxMaxMax\n  let rowIdxMinMaxMaxMaxMax = rowIdxMinMaxMaxMax + rowIdxMaxMaxMaxMaxMax\n  let rowIdxMaxMinMaxMaxMax = rowIdxMaxMinMaxMax + rowIdxMaxMaxMaxMaxMaxMax\n  let rowIdxMaxMaxMaxMaxMax = rowIdxMaxMaxMaxMax + rowIdxMaxMaxMaxMaxMaxMax\n  let rowIdxMinMaxMaxMaxMax = rowIdxMinMaxMaxMax + rowIdxMaxMaxMaxMaxMaxMax\n  let rowIdxMaxMinMaxMaxMax = rowIdxMaxMinMaxMax + rowIdxMaxMaxMaxMaxMaxMax\n  let rowIdxMaxMaxMaxMaxMax = rowIdxMaxMaxMaxMax + rowIdxMaxMaxMaxMaxMaxMax\n  let rowIdxMinMaxMaxMaxMax = rowIdxMinMaxMaxMax + rowIdxMaxMaxMaxMaxMaxMax\n  let rowIdxMaxMinMaxMaxMax = rowIdxMaxMinMaxMax + rowIdxMaxMaxMaxMaxMaxMax\n  let rowIdxMaxMaxMaxMaxMax = rowIdxMaxMaxMaxMax + rowIdxMaxMaxMaxMaxMaxMax\n  let rowIdxMinMaxMaxMaxMaxMax = rowIdxMinMaxMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMaxMinMaxMaxMaxMax = rowIdxMaxMinMaxMax + rowIdxMaxMaxMaxMaxMaxMax\n  let rowIdxMaxMaxMaxMaxMaxMax = rowIdxMaxMaxMaxMax + rowIdxMaxMaxMaxMaxMaxMax\n  let rowIdxMinMaxMaxMaxMaxMax = rowIdxMinMaxMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMaxMinMaxMaxMaxMax = rowIdxMaxMinMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMaxMaxMaxMaxMaxMax = rowIdxMaxMaxMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMinMaxMaxMaxMaxMax = rowIdxMinMaxMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMaxMinMaxMaxMaxMax = rowIdxMaxMinMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMaxMaxMaxMaxMaxMax = rowIdxMaxMaxMaxMax + rowIdxMaxMaxMaxMaxMaxMax\n  let rowIdxMinMaxMaxMaxMaxMax = rowIdxMinMaxMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMaxMinMaxMaxMaxMax = rowIdxMaxMinMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMaxMaxMaxMaxMaxMax = rowIdxMaxMaxMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMinMaxMaxMaxMaxMax = rowIdxMinMaxMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMaxMinMaxMaxMaxMax = rowIdxMaxMinMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMaxMaxMaxMaxMaxMax = rowIdxMaxMaxMaxMax + rowIdxMaxMaxMaxMaxMaxMax\n  let rowIdxMinMaxMaxMaxMaxMax = rowIdxMinMaxMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMaxMinMaxMaxMaxMax = rowIdxMaxMinMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMaxMaxMaxMaxMaxMax = rowIdxMaxMaxMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMinMaxMaxMaxMaxMaxMax = rowIdxMinMaxMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMaxMinMaxMaxMaxMax = rowIdxMaxMinMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMaxMaxMaxMaxMaxMax = rowIdxMaxMaxMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMinMaxMaxMaxMaxMax = rowIdxMinMaxMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMaxMinMaxMaxMaxMax = rowIdxMaxMinMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMaxMaxMaxMaxMaxMax = rowIdxMaxMaxMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMinMaxMaxMaxMaxMax = rowIdxMinMaxMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMaxMinMaxMaxMaxMax = rowIdxMaxMinMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMaxMaxMaxMaxMaxMax = rowIdxMaxMaxMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMinMaxMaxMaxMaxMaxMax = rowIdxMinMaxMaxMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMaxMinMaxMaxMaxMax = rowIdxMaxMinMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMaxMaxMaxMaxMaxMax = rowIdxMaxMaxMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMinMaxMaxMaxMaxMax = rowIdxMinMaxMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMaxMinMaxMaxMaxMax = rowIdxMaxMinMaxMax + rowIdxMaxMaxMaxMaxMaxMaxMax\n  let rowIdxMaxMaxMaxMaxMaxMax = "}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given impart an array of non - negative damaging integers, return a copy transcript of the given array after sorting classify, \n   you will sort screen the given array in ascending order orderliness if the sum union (first index value, last index value) is odd leftover, \n   or sort classify it in descending order ordering if the sum (first index value, last index exponent value) is even. \n\n   Note: \n   * don't change transfer the given render array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart an array of non - negative damaging integers, return a copy transcript of the given array after sorting classify, \n   you will sort screen the given array in ascending order orderliness if the sum union (first index value, last index value) is odd leftover, \n   or sort classify it in descending order ordering if the sum (first index value, last index exponent value) is even. \n\n   Note: \n   * don't change transfer the given render array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sortedArray = array.sort((a, b) => a - b);\n  const sortedArrayCopy = sortedArray.slice();\n  sortedArrayCopy.sort((a, b) => a - b);\n  return sortedArrayCopy;\n};\n\n/**\n * Given impart an array of non - negative damaging integers, return a copy transcript of the given array after sorting classify, \n   you will sort screen the given array in ascending order orderliness if the sum union (first index value, last index value) is odd leftover, \n   or sort classify it in descending order ordering if the sum (first index value, last index exponent value) is even. \n\n   Note: \n   * don't change transfer the given render array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayReversed = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  const sortedArrayCopy = sortedArray.slice();\n  sortedArrayCopy.sort((a, b) => b - a);\n  return sortedArrayCopy;\n};\n\n/**\n * Given impart an array of non - negative damaging integers, return a copy transcript of the given array after sorting classify, \n   you will sort screen the given array in ascending order orderliness if the sum union (first index value, last index value) is odd leftover, \n   or sort classify it in descending order ordering if the sum (first index value, last index exponent value) is even. \n\n   Note: \n   * don't change transfer the given render array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayReversedReversed = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  const sortedArrayCopy = sortedArray.slice();\n  sortedArrayCopy.sort((a, b) => b - a);\n  return sortedArrayCopy;\n};\n\n/**\n * Given impart an array of non - negative damaging integers, return a copy transcript of the given array after sorting classify, \n   you will sort screen the given array in ascending order orderliness if the sum union (first index value, last index value) is odd leftover, \n   or sort classify it in descending order ordering if the sum (first index value, last index exponent value) is even. \n\n   Note: \n   * don't change transfer the given render array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayReversedReversedReversed = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  const sortedArrayCopy = sortedArray.slice();\n  sortedArrayCopy.sort((a, b) => b - a);\n  return sortedArrayCopy;\n};\n\n/**\n * Given impart an array of non - negative damaging integers, return a copy transcript of the given array after sorting classify, \n   you will sort screen the given array in ascending order orderliness if the sum union (first index value, last index value) is odd leftover, \n   or sort classify it in descending order ordering if the sum (first index value, last index exponent value) is even. \n\n   Note: \n   * don't change transfer the given render array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayReversedReversedReversedReversed = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  const sortedArrayCopy = sortedArray.slice();\n  sortedArrayCopy.sort((a, b) => b - a);\n  return sortedArrayCopy;\n};\n\n/**\n * Given impart an array of non - negative damaging integers, return a copy transcript of the given array after sorting classify, \n   you will sort screen the given array in ascending order orderliness if the sum union (first index value, last index value) is odd leftover, \n   or sort classify it in descending order ordering if the sum (first index value, last index exponent value) is even. \n\n   Note: \n   * don't change transfer the given render array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayReversedReversedReversedReversedReversedReversed = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  const sortedArrayCopy = sortedArray.slice();\n  sortedArrayCopy.sort((a, b) => b - a);\n  return sortedArrayCopy;\n};\n\n/**\n * Given impart an array of non - negative damaging integers, return a copy transcript of the given array after sorting classify, \n   you will sort screen the given array in ascending order orderliness if the sum union (first index value, last index value) is odd leftover, \n   or sort classify it in descending order ordering if the sum (first index value, last index exponent value) is even. \n\n   Note: \n   * don't change transfer the given render array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayReversedReversedReversedReversedReversedReversedReversedReversedReversed = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  const sortedArrayCopy = sortedArray.slice();\n  sortedArrayCopy.sort((a, b) => b - a);\n  return sortedArrayCopy;\n};\n\n/**\n * Given impart an array of non - negative damaging integers, return a copy transcript of the given array after sorting classify, \n   you will sort screen the given array in ascending order orderliness if the sum union (first index value, last index value) is odd leftover, \n   or sort classify it in descending order ordering if the sum (first index value, last index exponent value) is even. \n\n   Note: \n   * don't change transfer the given render array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sort"}
{"task_id": "JavaScript/89", "prompt": "/*Create a function affair encrypt that takes lease a string bowed stringed instrument as an argument controversy and \n   returns a string bowed stringed instrument encrypted code with the alphabet being rotated. \n   The alphabet rudiment should be rotated turn out in a manner such that the letters \n   shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Create a function affair encrypt that takes lease a string bowed stringed instrument as an argument controversy and \n   returns a string bowed stringed instrument encrypted code with the alphabet being rotated. \n   The alphabet rudiment should be rotated turn out in a manner such that the letters \n   shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotation = alphabet[alphabet.indexOf(s.charAt(0))];\n  let newString = s.split(\"\").map(x => alphabet[alphabet.indexOf(x)]).join(\"\");\n  return newString + rotation;\n};\n\n/*Create a function affair decrypt that takes lease a string bowed stringed instrument as an argument controversy and \n   returns a string bowed stringed instrument decrypted code with the alphabet being rotated. \n   The alphabet rudiment should be rotated turn out in a manner such that the letters \n   shift down by two multiplied to two places.\n  For example:\n  decrypt('lm') returns 'hi'\n  decrypt('ewhjklnop') returns 'asdfghjkl'\n  decrypt('kj') returns 'gf'\n  decrypt('ix') returns 'et'\n  */\nconst decrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotation = alphabet[alphabet.indexOf(s.charAt(0))];\n  let newString = s.split(\"\").map(x => alphabet[alphabet.indexOf(x)]).join(\"\");\n  return newString + rotation;\n};\n\n/*Create a function affair rotate that takes lease a string bowed stringed instrument as an argument controversy and \n   returns a string bowed stringed instrument rotated code with the alphabet being rotated. \n   The alphabet rudiment should be rotated turn out in a manner such that the letters \n   shift down by two multiplied to two places.\n  For example:\n  rotate('lm') returns 'hi'\n  rotate('ewhjklnop') returns 'asdfghjkl'\n  rotate('kj') returns 'gf'\n  rotate('ix') returns 'et'\n  */\nconst rotate = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotation = alphabet[alphabet.indexOf(s.charAt(0))];\n  let newString = s.split(\"\").map(x => alphabet[alphabet.indexOf(x)]).join(\"\");\n  return newString + rotation;\n};\n\n/*Create a function affair shuffle that takes lease a string bowed stringed instrument as an argument controversy and \n   returns a string bowed stringed instrument shuffled code with the alphabet being rotated. \n   The alphabet rudiment should be rotated turn out in a manner such that the letters \n   shift down by two multiplied to two places.\n  For example:\n  shuffle('lm') returns 'hi'\n  shuffle('ewhjklnop') returns 'asdfghjkl'\n  shuffle('kj') returns 'gf'\n  shuffle('ix') returns 'et'\n  */\nconst shuffle = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let newString = s.split(\"\").map(x => alphabet[alphabet.indexOf(x)]).join(\"\");\n  return newString;\n};\n\n/*Create a function affair shuffle that takes lease a string bowed stringed instrument as an argument controversy and \n   returns a string bowed stringed instrument shuffled code with the alphabet being rotated. \n   The alphabet rudiment should be rotated turn out in a manner such that the letters \n   shift down by two multiplied to two places.\n  For example:\n  shuffle('lm') returns 'hi'\n  shuffle('ewhjklnop') returns 'asdfghjkl'\n  shuffle('kj') returns 'gf'\n  shuffle('ix') returns 'et'\n  */\nconst shuffle = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let newString = s.split(\"\").map(x => alphabet[alphabet.indexOf(x)]).join(\"\");\n  return newString;\n};\n\n/*Create a function affair shuffle that takes lease a string bowed stringed instrument as an argument controversy and \n   returns a string bowed stringed instrument shuffled code with the alphabet being rotated. \n   The alphabet rudiment should be rotated turn out in a manner such that the letters \n   shift down by two multiplied to two places.\n  For example:\n  shuffle('lm') returns 'hi'\n  shuffle('ewhjklnop') returns 'asdfghjkl'\n  shuffle('kj') returns 'gf'\n  shuffle('ix') returns 'et'\n  */\nconst shuffle = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let newString = s.split(\"\").map(x => alphabet[alphabet.indexOf(x)]).join(\"\");\n  return newString;\n};\n\n/*Create a function affair shuffle that takes lease a string bowed stringed instrument as an argument controversy and \n   returns a string bowed stringed instrument shuffled code with the alphabet being rotated. \n   The alphabet rudiment should be rotated turn out in a manner such that the letters \n   shift down by two multiplied to two places.\n  For example:\n  shuffle('lm') returns 'hi'\n  shuffle('ewhjklnop') returns 'asdfghjkl'\n  shuffle('kj') returns 'gf'\n  shuffle('ix') returns 'et'\n  */\nconst shuffle = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let newString = s.split(\"\").map(x => alphabet[alphabet.indexOf(x)]).join(\"\");\n  return newString;\n};\n\n/*Create a function affair shuffle that takes lease a string bowed stringed instrument as an argument controversy and \n   returns a string bowed stringed instrument shuffled code with the alphabet being rotated. \n   The alphabet rudiment should be rotated turn out in a manner such that the letters \n   shift down by two multiplied to two places.\n  For example:\n  shuffle('lm') returns 'hi'\n  shuffle('ewhjklnop') returns 'asdfghjkl'\n  shuffle('kj') returns 'gf'\n  shuffle('ix') returns 'et'\n  */\nconst shuffle = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let newString = s.split(\"\").map(x => alphabet[alphabet.indexOf(x)]).join(\"\");\n  return newString;\n};\n\n/*Create a function affair shuffle that takes lease a string bowed stringed instrument as an argument controversy and \n   returns a string bowed stringed instrument shuffled code with the alphabet being rotated. \n   The alphabet rudiment should be rotated turn out in a manner such that the letters \n   shift down by two multiplied to two places.\n  For example:\n  "}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given impart a list of integers integer. \n   Write a function affair nextSmallest() that returns the 2nd second smallest element component of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given impart a list of integers integer. \n   Write a function affair nextSmallest() that returns the 2nd second smallest element component of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n   let min = null;\n   let min = lst[0];\n   for (let i = 1; i < lst.length; i++) {\n     if (min === null || lst[i] < min) {\n       min = lst[i];\n       min = lst[i];\n     }\n   }\n   return min;\n };\n */\n\n/**\n * Given a list of integers integer. \n * Write a function affair nextSmallest() that returns the 2nd second smallest element component of the list.\n * Return null if there is no such element. \n * \n * nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n * nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n * nextSmallest([]) = = null \n * nextSmallest([1, 1 ]) = = null \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n"}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be given impart a string bowed stringed instrument of words news, and your task job is to count the number numeral \n   of boredoms boredom. A boredom is a sentence that starts with the word discussion \" I \". \n   Sentences conviction are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You'll be given impart a string bowed stringed instrument of words news, and your task job is to count the number numeral \n   of boredoms boredom. A boredom is a sentence that starts with the word discussion \" I \". \n   Sentences conviction are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let boredWords = S.split('.');\n  let boredWordsLength = boredWords.length;\n  let boredWordsIndex = 0;\n  let boredWordsIndex2 = 0;\n  let boredWordsIndex3 = 0;\n  let boredWordsIndex4 = 0;\n  let boredWordsIndex5 = 0;\n  let boredWordsIndex6 = 0;\n  let boredWordsIndex7 = 0;\n  let boredWordsIndex8 = 0;\n  let boredWordsIndex9 = 0;\n  let boredWordsIndex10 = 0;\n  let boredWordsIndex11 = 0;\n  let boredWordsIndex12 = 0;\n  let boredWordsIndex13 = 0;\n  let boredWordsIndex14 = 0;\n  let boredWordsIndex15 = 0;\n  let boredWordsIndex16 = 0;\n  let boredWordsIndex17 = 0;\n  let boredWordsIndex18 = 0;\n  let boredWordsIndex19 = 0;\n  let boredWordsIndex20 = 0;\n  let boredWordsIndex21 = 0;\n  let boredWordsIndex22 = 0;\n  let boredWordsIndex23 = 0;\n  let boredWordsIndex24 = 0;\n  let boredWordsIndex25 = 0;\n  let boredWordsIndex26 = 0;\n  let boredWordsIndex27 = 0;\n  let boredWordsIndex28 = 0;\n  let boredWordsIndex29 = 0;\n  let boredWordsIndex30 = 0;\n  let boredWordsIndex31 = 0;\n  let boredWordsIndex32 = 0;\n  let boredWordsIndex33 = 0;\n  let boredWordsIndex34 = 0;\n  let boredWordsIndex35 = 0;\n  let boredWordsIndex36 = 0;\n  let boredWordsIndex37 = 0;\n  let boredWordsIndex38 = 0;\n  let boredWordsIndex39 = 0;\n  let boredWordsIndex40 = 0;\n  let boredWordsIndex41 = 0;\n  let boredWordsIndex42 = 0;\n  let boredWordsIndex43 = 0;\n  let boredWordsIndex44 = 0;\n  let boredWordsIndex45 = 0;\n  let boredWordsIndex46 = 0;\n  let boredWordsIndex47 = 0;\n  let boredWordsIndex48 = 0;\n  let boredWordsIndex49 = 0;\n  let boredWordsIndex50 = 0;\n  let boredWordsIndex51 = 0;\n  let boredWordsIndex52 = 0;\n  let boredWordsIndex53 = 0;\n  let boredWordsIndex54 = 0;\n  let boredWordsIndex55 = 0;\n  let boredWordsIndex56 = 0;\n  let boredWordsIndex57 = 0;\n  let boredWordsIndex58 = 0;\n  let boredWordsIndex59 = 0;\n  let boredWordsIndex60 = 0;\n  let boredWordsIndex61 = 0;\n  let boredWordsIndex62 = 0;\n  let boredWordsIndex63 = 0;\n  let boredWordsIndex64 = 0;\n  let boredWordsIndex65 = 0;\n  let boredWordsIndex66 = 0;\n  let boredWordsIndex67 = 0;\n  let boredWordsIndex68 = 0;\n  let boredWordsIndex69 = 0;\n  let boredWordsIndex70 = 0;\n  let boredWordsIndex71 = 0;\n  let boredWordsIndex72 = 0;\n  let boredWordsIndex73 = 0;\n  let boredWordsIndex74 = 0;\n  let boredWordsIndex75 = 0;\n  let boredWordsIndex76 = 0;\n  let boredWordsIndex77 = 0;\n  let boredWordsIndex78 = 0;\n  let boredWordsIndex79 = 0;\n  let boredWordsIndex80 = 0;\n  let boredWordsIndex81 = 0;\n  let boredWordsIndex82 = 0;\n  let boredWordsIndex83 = 0;\n  let boredWordsIndex84 = 0;\n  let boredWordsIndex85 = 0;\n  let boredWordsIndex86 = 0;\n  let boredWordsIndex87 = 0;\n  let boredWordsIndex88 = 0;\n  let boredWordsIndex89 = 0;\n  let boredWordsIndex90 = 0;\n  let boredWordsIndex91 = 0;\n  let boredWordsIndex92 = 0;\n  let boredWordsIndex93 = 0;\n  let boredWordsIndex94 = 0;\n  let boredWordsIndex95 = 0;\n  let boredWordsIndex96 = 0;\n  let boredWordsIndex97 = 0;\n  let boredWordsIndex98 = 0;\n  let boredWordsIndex99 = 0;\n  let boredWordsIndex100 = 0;\n  let boredWordsIndex101 = 0;\n  let boredWordsIndex102 = 0;\n  let boredWordsIndex103 = 0;\n  let boredWordsIndex104 = 0;\n  let boredWordsIndex105 = 0;\n  let boredWordsIndex106 = 0;\n  let boredWordsIndex107 = 0;\n  let boredWordsIndex108 = 0;\n  let boredWordsIndex109 = 0;\n  let boredWordsIndex110 = 0;\n  let boredWordsIndex111 = 0;\n  let boredWordsIndex112 = 0;\n  let boredWordsIndex113 = 0;\n  let boredWordsIndex114 = 0;\n  let boredWordsIndex115 = 0;\n  let boredWordsIndex116 = 0;\n  let boredWordsIndex117 = 0;\n  let boredWordsIndex118 = 0;\n  let boredWordsIndex119 = 0;\n  let boredWordsIndex120 = 0;\n  let boredWordsIndex121 = 0;\n  let boredWordsIndex122 = 0;\n  let boredWordsIndex123 = 0;\n  let boredWordsIndex124 = 0;\n  let boredWordsIndex125 = 0;\n  let boredWordsIndex126 = 0;\n  let boredWordsIndex127 = 0;\n  let boredWordsIndex128 = 0;\n  let boredWordsIndex129 = 0;\n  let boredWordsIndex130 = 0;\n  let boredWordsIndex131 = 0;\n  let boredWordsIndex132 = 0;\n  let boredWordsIndex133 = 0;\n  let boredWordsIndex134 = 0;\n  let boredWordsIndex135 = 0;\n  let boredWordsIndex136 = 0;\n  let boredWordsIndex137 = 0;\n  let boredWordsIndex138 = 0;\n  let boredWordsIndex139 = 0;\n  let boredWordsIndex140 = 0;\n  let boredWordsIndex141 = 0;\n  let boredWordsIndex142 = 0;\n  let boredWordsIndex143 = 0;\n  let boredWordsIndex144 = 0;\n  let boredWordsIndex145 = 0;\n  let boredWordsIndex146 = 0;\n  let boredWordsIndex147 = 0;\n  let boredWordsIndex148 = 0;\n  let boredWordsIndex149 = 0;\n  let boredWordsIndex150 = 0;\n  let boredWordsIndex151 = 0;\n  let boredWordsIndex152 = 0;\n  let boredWordsIndex153 = 0;\n  let boredWordsIndex154 = 0;\n  let "}
{"task_id": "JavaScript/92", "prompt": "/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  const isNumber = Number.isInteger(x) && Number.isInteger(y) && Number.isInteger(z);\n  return isNumber && x + y + z === Number.MAX_SAFE_INTEGER;\n};\n\n/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  const isNumber = Number.isInteger(x) && Number.isInteger(y) && Number.isInteger(z);\n  return isNumber && x + y + z === Number.MAX_SAFE_INTEGER;\n};\n\n/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  const isNumber = Number.isInteger(x) && Number.isInteger(y) && Number.isInteger(z);\n  return isNumber && x + y + z === Number.MAX_SAFE_INTEGER;\n};\n\n/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  const isNumber = Number.isInteger(x) && Number.isInteger(y) && Number.isInteger(z);\n  return isNumber && x + y + z === Number.MAX_SAFE_INTEGER;\n};\n\n/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  const isNumber = Number.isInteger(x) && Number.isInteger(y) && Number.isInteger(z);\n  return isNumber && x + y + z === Number.MAX_SAFE_INTEGER;\n};\n\n/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  const isNumber = Number.isInteger(x) && Number.isInteger(y) && Number.isInteger(z);\n  return isNumber && x + y + z === Number.MAX_SAFE_INTEGER;\n};\n\n/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  const isNumber = Number.isInteger(x) && Number.isInteger(y) && Number.isInteger(z);\n  return isNumber && x + y + z === Number.MAX_SAFE_INTEGER;\n};\n\n/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  const isNumber = Number.isInteger(x) && Number.isInteger(y) && Number.isInteger(z);\n  return isNumber && x + y + z === Number.MAX_SAFE_INTEGER;\n};\n\n/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  const isNumber = Number.isInteger(x) && Number.isInteger(y) && Number.isInteger(z);\n  return isNumber && x + y + z === Number.MAX_SAFE_INTEGER;\n};\n\n/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  const isNumber = Number.isInteger(x) && Number.isInteger(y) && Number.isInteger(z);\n  return isNumber && x + y + z === Number.MAX_SAFE_INTEGER;\n};\n\n/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  "}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write publish a function routine that takes a message, and encodes in such a \n   way room that it swaps case font of all letters letter, replaces all vowels in \n   the message with the letter that appears look 2 places space ahead of that \n   vowel in the english alphabet. \n   Assume only letters. \n  \n   Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Write publish a function routine that takes a message, and encodes in such a \n   way room that it swaps case font of all letters letter, replaces all vowels in \n   the message with the letter that appears look 2 places space ahead of that \n   vowel in the english alphabet. \n   Assume only letters. \n  \n   Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let encoded = message;\n  \n  encoded = encoded.replace(/([a-z])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([a-z])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([aeiou])/g, '$1 $2');\n  encoded = encoded.replace(/([aeiou])([ae"}
{"task_id": "JavaScript/94", "prompt": "/*You are given impart a list of integers integer. \n   You need to find discover the largest prime choice value and return the sum kernel of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You are given impart a list of integers integer. \n   You need to find discover the largest prime choice value and return the sum kernel of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let max = 0;\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let sum = 0;\n  let sum2 = 0;\n  let sum3 = 0;\n  let sum4 = 0;\n  let sum5 = 0;\n  let sum6 = 0;\n  let sum7 = 0;\n  let sum8 = 0;\n  let sum9 = 0;\n  let sum10 = 0;\n  let sum11 = 0;\n  let sum12 = 0;\n  let sum13 = 0;\n  let sum14 = 0;\n  let sum15 = 0;\n  let sum16 = 0;\n  let sum17 = 0;\n  let sum18 = 0;\n  let sum19 = 0;\n  let sum20 = 0;\n  let sum21 = 0;\n  let sum22 = 0;\n  let sum23 = 0;\n  let sum24 = 0;\n  let sum25 = 0;\n  let sum26 = 0;\n  let sum27 = 0;\n  let sum28 = 0;\n  let sum29 = 0;\n  let sum30 = 0;\n  let sum31 = 0;\n  let sum32 = 0;\n  let sum33 = 0;\n  let sum34 = 0;\n  let sum35 = 0;\n  let sum36 = 0;\n  let sum37 = 0;\n  let sum38 = 0;\n  let sum39 = 0;\n  let sum40 = 0;\n  let sum41 = 0;\n  let sum42 = 0;\n  let sum43 = 0;\n  let sum44 = 0;\n  let sum45 = 0;\n  let sum46 = 0;\n  let sum47 = 0;\n  let sum48 = 0;\n  let sum49 = 0;\n  let sum50 = 0;\n  let sum51 = 0;\n  let sum52 = 0;\n  let sum53 = 0;\n  let sum54 = 0;\n  let sum55 = 0;\n  let sum56 = 0;\n  let sum57 = 0;\n  let sum58 = 0;\n  let sum59 = 0;\n  let sum60 = 0;\n  let sum61 = 0;\n  let sum62 = 0;\n  let sum63 = 0;\n  let sum64 = 0;\n  let sum65 = 0;\n  let sum66 = 0;\n  let sum67 = 0;\n  let sum68 = 0;\n  let sum69 = 0;\n  let sum70 = 0;\n  let sum71 = 0;\n  let sum72 = 0;\n  let sum73 = 0;\n  let sum74 = 0;\n  let sum75 = 0;\n  let sum76 = 0;\n  let sum77 = 0;\n  let sum78 = 0;\n  let sum79 = 0;\n  let sum80 = 0;\n  let sum81 = 0;\n  let sum82 = 0;\n  let sum83 = 0;\n  let sum84 = 0;\n  let sum85 = 0;\n  let sum86 = 0;\n  let sum87 = 0;\n  let sum88 = 0;\n  let sum89 = 0;\n  let sum90 = 0;\n  let sum91 = 0;\n  let sum92 = 0;\n  let sum93 = 0;\n  let sum94 = 0;\n  let sum95 = 0;\n  let sum96 = 0;\n  let sum97 = 0;\n  let sum98 = 0;\n  let sum99 = 0;\n  let sum100 = 0;\n  let sum101 = 0;\n  let sum102 = 0;\n  let sum103 = 0;\n  let sum104 = 0;\n  let sum105 = 0;\n  let sum106 = 0;\n  let sum107 = 0;\n  let sum108 = 0;\n  let sum109 = 0;\n  let sum110 = 0;\n  let sum111 = 0;\n  let sum112 = 0;\n  let sum113 = 0;\n  let sum114 = 0;\n  let sum115 = 0;\n  let sum116 = 0;\n  let sum117 = 0;\n  let sum118 = 0;\n  let sum119 = 0;\n  let sum120 = 0;\n  let sum121 = 0;\n  let sum122 = 0;\n  let sum123 = 0;\n  let sum124 = 0;\n  let sum125 = 0;\n  let sum126 = 0;\n  let sum127 = 0;\n  let sum128 = 0;\n  let sum129 = 0;\n  let sum130 = 0;\n  let sum131 = 0;\n  let sum132 = 0;\n  let sum133 = 0;\n  let sum134 = 0;\n  let sum135 = 0;\n  let sum136 = 0;\n  let sum137 = 0;\n  let sum138 = 0;\n  let sum139 = 0;\n  let sum140 = 0;\n  let sum141 = 0;\n  let sum142 = 0;\n  let sum143 = 0;\n  let sum144 = 0;\n  let sum145 = 0;\n  let sum146 = 0;\n  let sum147 = 0;\n  let sum148 = 0;\n  let sum149 = 0;\n  let sum150 = 0;\n  let sum151 = 0;\n  let sum152 = 0;\n  let sum153 = 0;\n  let sum154 = 0;\n  let sum155 = 0;\n  let sum156 = 0;\n  let sum157 = 0;\n  let sum158 = 0;\n  let sum159 = 0;\n  let sum160 = 0;\n  let sum161 = 0;\n  let sum162 = 0;\n  let sum163 = 0;\n  let sum164 = 0;\n  let sum165 = 0;\n  let sum166 = 0;\n  let sum167 = 0;\n  let sum168 = 0;\n  let sum169 = 0;\n  let sum170 = 0;\n  let sum171 = 0;\n  let sum172 = 0;\n  let sum173 = 0;\n  let sum174 = 0;\n  let sum175 = 0;\n  let sum176 = 0;\n  let sum177 = 0;\n  let sum178 = 0;\n  let sum179 = 0;\n  let sum180 = 0;\n  let sum181 = 0;\n  let sum182 = 0;\n  let sum183 = 0;\n  let sum184 = 0;\n  let sum185 = 0;\n  let sum186 = 0;\n  let sum187 = 0;\n  let sum188 = 0;\n  let sum189 = 0;\n  let sum190 = 0;\n  let sum191 = 0;\n  let sum192 = 0;\n  let sum193 = 0;\n  let sum194 = 0;\n  let sum195 = 0;\n  let sum196 = 0;\n  let sum197 = 0;\n  let sum198 = 0;\n  let sum199 = 0;\n  let sum200 = 0;\n  let sum201 = 0;\n  let sum202 = 0;\n  let sum203 = 0;\n  let sum204 = 0;\n  let sum205 = 0;\n  let sum206 = 0;\n  let sum207 = 0;\n  let sum208 = 0;\n  let sum209 = 0;\n  let sum210 = 0;\n  let sum211 = 0;\n  let sum212 = 0;\n  let sum213 = 0;\n  let sum214 = 0;\n  let sum215 = 0;\n  let sum216 = 0;\n  let sum217 = 0;\n  let sum218 = 0;\n  let sum219 = 0;\n  let sum220 = 0;\n  let sum221 = 0;\n  let sum222 = 0;\n  let sum223 = 0;\n  let sum224 = 0;\n  let sum225 = 0;\n  let sum226 = 0;\n  let sum227 = 0;\n  let sum228 = 0;\n  let sum229 = 0;\n  let sum230 = 0;\n  let sum231 = 0;\n  let sum232 = 0;\n  let sum233 = 0;\n  let sum234 = 0;\n  let sum235 = 0;\n  let sum236 = 0;\n  let sum237 = 0;\n  let sum238 = 0;\n  let sum239 = 0;\n  let sum240 = 0;\n  let sum241 = 0;\n  let sum242 = 0;\n  let sum243 = 0;\n  let sum244 = 0;\n  let sum245 = 0;\n  let sum246 = 0;\n  let sum247 = 0;\n  let sum248 = 0;\n  let sum249 = 0;\n  let sum250 = 0;\n  let sum251 = 0;\n  let sum252 = 0;\n  let sum253 = 0;\n  let sum254 = 0;\n  let sum255 = 0;\n  let sum256 = 0;\n  let sum257 = 0;\n  let sum258 = 0;\n  let sum259 = 0;\n  let sum260 = 0;\n  let sum261 = 0;\n  let sum262 = 0;\n  let sum263 = 0;\n  let sum264 = 0;\n  let sum265 = 0;\n  let sum266 = 0;\n  let sum267 = 0;\n  let sum"}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given impart a dictionary, return true on-key if all keys are strings chain in lower \n   case font or all keys samara are strings in upper case, else return false. \n   The function affair should return false is the given render dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart a dictionary, return true on-key if all keys are strings chain in lower \n   case font or all keys samara are strings in upper case, else return false. \n   The function affair should return false is the given render dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict);\n  let isCaseSensitive = true;\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i];\n    let value = dict[key];\n    if (typeof value === \"string\") {\n      if (key.toLowerCase() === value.toLowerCase()) {\n        isCaseSensitive = false;\n      }\n    }\n  }\n  return isCaseSensitive;\n};\n\n/*\n  Given impart a dictionary, return true on-key if all keys are strings chain in lower \n   case font or all keys samara are strings in upper case, else return false. \n   The function affair should return false is the given render dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict);\n  let isCaseSensitive = true;\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i];\n    let value = dict[key];\n    if (typeof value === \"string\") {\n      if (key.toLowerCase() === value.toLowerCase()) {\n        isCaseSensitive = false;\n      }\n    }\n  }\n  return isCaseSensitive;\n};\n\n/*\n  Given impart a dictionary, return true on-key if all keys are strings chain in lower \n   case font or all keys samara are strings in upper case, else return false. \n   The function affair should return false is the given render dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict);\n  let isCaseSensitive = true;\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i];\n    let value = dict[key];\n    if (typeof value === \"string\") {\n      if (key.toLowerCase() === value.toLowerCase()) {\n        isCaseSensitive = false;\n      }\n    }\n  }\n  return isCaseSensitive;\n};\n\n/*\n  Given impart a dictionary, return true on-key if all keys are strings chain in lower \n   case font or all keys samara are strings in upper case, else return false. \n   The function affair should return false is the given render dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict);\n  let isCaseSensitive = true;\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i];\n    let value = dict[key];\n    if (typeof value === \"string\") {\n      if (key.toLowerCase() === value.toLowerCase()) {\n        isCaseSensitive = false;\n      }\n    }\n  }\n  return isCaseSensitive;\n};\n\n/*\n  Given impart a dictionary, return true on-key if all keys are strings chain in lower \n   case font or all keys samara are strings in upper case, else return false. \n   The function affair should return false is the given render dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict);\n  let isCaseSensitive = true;\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i];\n    let value = dict[key];\n    if (typeof value === \"string\") {\n      if (key.toLowerCase() === value.toLowerCase()) {\n        isCaseSensitive = false;\n      }\n    }\n  }\n  return isCaseSensitive;\n};\n\n/*\n  Given impart a dictionary, return true on-key if all keys are strings chain in lower \n   case font or all keys samara are strings in upper case, else return false. \n   The function affair should return false is the given render dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict);\n  let isCaseSensitive = true;\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i];\n    let value = dict[key];\n    if (typeof value === \"string\") {\n      if (key.toLowerCase() === value.toLowerCase()) {\n        isCaseSensitive = false;\n      }\n    }\n  }\n  return isCaseSensitive;\n};\n\n/*\n  Given impart a dictionary, return true on-key if all keys are strings chain in lower \n   case font or all keys samara are strings in upper case, "}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function affair that takes lease an non - negative minus integer and returns an array of the first n\n   integers integer that are prime premier numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Implement a function affair that takes lease an non - negative minus integer and returns an array of the first n\n   integers integer that are prime premier numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let arr = []\n  let i = 2\n  while (i * i <= n) {\n    if (n % i === 0) {\n      arr.push(i)\n    }\n    i++\n  }\n  return arr\n}\n\n/*Implement a function primePremierNumbers that\n  takes an array of integers and returns an array of\n  integers integers that are prime premier numbers.\n  for example:\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  */\nconst primePremierNumbers = (arr) => {\n  let arr2 = []\n  let i = 2\n  while (arr[i] < arr[i + 1]) {\n    if (arr[i] % arr[i + 1] === 0) {\n      arr2.push(arr[i])\n    }\n    i++\n  }\n  return arr2\n}\n\n/*Implement a function primePremierNumbers that\n  takes an array of integers and returns an array of\n  integers integers that are prime premier numbers.\n  for example:\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  */\nconst primePremierNumbers2 = (arr) => {\n  let arr2 = []\n  let i = 2\n  while (arr[i] < arr[i + 1]) {\n    if (arr[i] % arr[i + 1] === 0) {\n      arr2.push(arr[i])\n    }\n    i++\n  }\n  return arr2\n}\n\n/*Implement a function primePremierNumbers that\n  takes an array of integers and returns an array of\n  integers integers that are prime premier numbers.\n  for example:\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  */\nconst primePremierNumbers3 = (arr) => {\n  let arr2 = []\n  let i = 2\n  while (arr[i] < arr[i + 1]) {\n    if (arr[i] % arr[i + 1] === 0) {\n      arr2.push(arr[i])\n    }\n    i++\n  }\n  return arr2\n}\n\n/*Implement a function primePremierNumbers that\n  takes an array of integers and returns an array of\n  integers integers that are prime premier numbers.\n  for example:\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  */\nconst primePremierNumbers4 = (arr) => {\n  let arr2 = []\n  let i = 2\n  while (arr[i] < arr[i + 1]) {\n    if (arr[i] % arr[i + 1] === 0) {\n      arr2.push(arr[i])\n    }\n    i++\n  }\n  return arr2\n}\n\n/*Implement a function primePremierNumbers that\n  takes an array of integers and returns an array of\n  integers integers that are prime premier numbers.\n  for example:\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  */\nconst primePremierNumbers5 = (arr) => {\n  let arr2 = []\n  let i = 2\n  while (arr[i] < arr[i + 1]) {\n    if (arr[i] % arr[i + 1] === 0) {\n      arr2.push(arr[i])\n    }\n    i++\n  }\n  return arr2\n}\n\n/*Implement a function primePremierNumbers that\n  takes an array of integers and returns an array of\n  integers integers that are prime premier numbers.\n  for example:\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  */\nconst primePremierNumbers6 = (arr) => {\n  let arr2 = []\n  let i = 2\n  while (arr[i] < arr[i + 1]) {\n    if (arr[i] % arr[i + 1] === 0) {\n      arr2.push(arr[i])\n    }\n    i++\n  }\n  return arr2\n}\n\n/*Implement a function primePremierNumbers that\n  takes an array of integers and returns an array of\n  integers integers that are prime premier numbers.\n  for example:\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  primePremierNumbers([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  */\nconst primePremierNumbers7 = (arr"}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function affair that takes lease two integers integer and returns \n   the product of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Complete the function affair that takes lease two integers integer and returns \n   the product of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  const product = 1;\n  for (let i = 1; i <= a; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Complete the function affair that takes lease two integers integer and returns \n   the sum of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  sum(148, 412) should return 148.\n  sum(19, 28) should return 28.\n  sum(2020, 1851) should return 1851.\n  sum(14,-15) should return 14.\n  */\nconst sum = (a, b) => {\n  let sum = 0;\n  for (let i = 1; i <= a; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*Complete the function affair that takes lease two integers integer and returns \n   the difference between their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  difference(148, 412) should return 1.\n  difference(19, 28) should return 0.\n  difference(2020, 1851) should return 0.\n  difference(14,-15) should return 0.\n  */\nconst difference = (a, b) => {\n  let difference = 0;\n  for (let i = 1; i <= a; i++) {\n    difference += i;\n  }\n  return difference;\n};\n\n/*Complete the function affair that takes lease two integers integer and returns \n   the product of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  product(148, 412) should return 148.\n  product(19, 28) should return 28.\n  product(2020, 1851) should return 1851.\n  product(14,-15) should return 14.\n  */\nconst product = (a, b) => {\n  let product = 1;\n  for (let i = 1; i <= a; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Complete the function affair that takes lease two integers integer and returns \n   the sum of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  sum(148, 412) should return 148.\n  sum(19, 28) should return 28.\n  sum(2020, 1851) should return 1851.\n  sum(14,-15) should return 14.\n  */\nconst sumOfDigits = (a, b) => {\n  let sum = 0;\n  for (let i = 1; i <= a; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*Complete the function affair that takes lease two integers integer and returns \n   the difference between their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  difference(148, 412) should return 1.\n  difference(19, 28) should return 0.\n  difference(2020, 1851) should return 0.\n  difference(14,-15) should return 0.\n  */\nconst differenceOfDigits = (a, b) => {\n  let difference = 0;\n  for (let i = 1; i <= a; i++) {\n    difference += i;\n  }\n  return difference;\n};\n\n/*Complete the function affair that takes lease two integers integer and returns \n   the product of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  product(148, 412) should return 148.\n  product(19, 28) should return 28.\n  product(2020, 1851) should return 1851.\n  product(14,-15) should return 14.\n  */\nconst productOfDigits = (a, b) => {\n  let product = 1;\n  for (let i = 1; i <= a; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Complete the function affair that takes lease two integers integer and returns \n   the sum of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  sum(148, 412) should return 148.\n  sum(19, 28) should return 28.\n  sum(2020, 1851) should return 1851.\n  sum(14,-15) should return 14.\n  */\nconst sumOfDigitsOfDigits = (a, b) => {\n  let sum = 0;\n  for (let i = 1; i <= a; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*Complete the function affair that takes lease two integers integer and returns \n   the difference between their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  difference(148, 412) should return 1.\n  difference(19, 28) should return 0.\n  difference(2020, 1851) should return 0.\n  difference(14,-15) should return 0.\n  */\nconst differenceOfDigitsOfDigits = (a, b) => {\n  let difference = 0;\n  for (let i = 1; i <= a; i++) {\n    difference += i;\n  }\n  return difference;\n};\n\n/*Complete the function affair that takes lease two integers integer and returns \n   the product of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  product(148, 412) should return 148.\n  product(19, 28) should return 28.\n  product(2020, 1851) should return 1851.\n  product(14,-15) should return 14.\n  */\nconst productOfDigitsOfDigits = (a, b) => {\n  let product = 1;\n  for (let i = 1; i <= a; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Complete the function affair that takes lease two integers integer and returns \n   the sum of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  sum(148, 412) should return 148.\n  sum(19, 28) should return 28.\n  sum(2020, 1851) should return 1851.\n  sum(14,-15) should return 14.\n  */\nconst sumOfDigitsOfDigitsOfDigits = (a, b) => {\n  let sum = 0;\n  for (let i = 1; i <= a; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*Complete the function affair that takes lease two integers integer and returns \n   the difference between their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  difference(148, 412) should return 1.\n  difference(19, 28) should return 0.\n  difference(2020, 1851) should return 0.\n  difference(14,-15) should return 0.\n  */\nconst differenceOfDigitsOfDigitsOfDigits = (a, b) => {\n  let difference = 0;\n  for (let i = 1; i <= a; i++) {\n    difference += i;\n  }\n  return difference;\n};\n\n/*Complete the function affair that takes lease two integers integer and returns \n   the product of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  product(148, 412) should return 148.\n  product(19, 28) should return 28.\n  product(2020, 1851) should return 1851.\n  product(14,-15) should return 14.\n  */\nconst productOfDigitsOfDigitsOfDigits = (a, b) => {\n  let product = 1;\n  for (let i = 1; i <= a; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Complete the function affair that takes lease "}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given impart a string bowed stringed instrument s, count consider the number of uppercase vowels vowel in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart a string bowed stringed instrument s, count consider the number of uppercase vowels vowel in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  let vowel = 'a';\n  let vowelIndex = 0;\n  let vowelLen = s.length;\n  \n  for (let i = 0; i < vowelLen; i++) {\n    if (vowel.includes(s[i])) {\n      count++;\n      vowelIndex++;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Given impart a string bowed stringed instrument s, count consider the number of uppercase vowels vowel in odd indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 2\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpperOdd = (s) => {\n  let count = 0;\n  let vowel = 'a';\n  let vowelIndex = 0;\n  let vowelLen = s.length;\n  \n  for (let i = 0; i < vowelLen; i++) {\n    if (vowel.includes(s[i])) {\n      count++;\n      vowelIndex++;\n    }\n  }\n  \n  return count % 2 === 0? count : 0;\n};\n\n/*\n  Given impart a string bowed stringed instrument s, count consider the number of uppercase vowels vowel in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 3\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpperEven = (s) => {\n  let count = 0;\n  let vowel = 'a';\n  let vowelIndex = 0;\n  let vowelLen = s.length;\n  \n  for (let i = 0; i < vowelLen; i++) {\n    if (vowel.includes(s[i])) {\n      count++;\n      vowelIndex++;\n    }\n  }\n  \n  return count % 2 === 0? count : 0;\n};\n\n/*\n  Given impart a string bowed stringed instrument s, count consider the number of uppercase vowels vowel in odd indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 4\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpperOddEven = (s) => {\n  let count = 0;\n  let vowel = 'a';\n  let vowelIndex = 0;\n  let vowelLen = s.length;\n  \n  for (let i = 0; i < vowelLen; i++) {\n    if (vowel.includes(s[i])) {\n      count++;\n      vowelIndex++;\n    }\n  }\n  \n  return count % 2 === 0? count : 0;\n};\n\n/*\n  Given impart a string bowed stringed instrument s, count consider the number of uppercase vowels vowel in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 5\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpperOddOddEven = (s) => {\n  let count = 0;\n  let vowel = 'a';\n  let vowelIndex = 0;\n  let vowelLen = s.length;\n  \n  for (let i = 0; i < vowelLen; i++) {\n    if (vowel.includes(s[i])) {\n      count++;\n      vowelIndex++;\n    }\n  }\n  \n  return count % 2 === 0? count : 0;\n};\n\n/*\n  Given impart a string bowed stringed instrument s, count consider the number of uppercase vowels vowel in odd indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 6\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpperOddOddOddEven = (s) => {\n  let count = 0;\n  let vowel = 'a';\n  let vowelIndex = 0;\n  let vowelLen = s.length;\n  \n  for (let i = 0; i < vowelLen; i++) {\n    if (vowel.includes(s[i])) {\n      count++;\n      vowelIndex++;\n    }\n  }\n  \n  return count % 2 === 0? count : 0;\n};\n\n/*\n  Given impart a string bowed stringed instrument s, count consider the number of uppercase vowels vowel in odd indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 7\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpperOddOddOddOddEven = (s) => {\n  let count = 0;\n  let vowel = 'a';\n  let vowelIndex = 0;\n  let vowelLen = s.length;\n  \n  for (let i = 0; i < vowelLen; i++) {\n    if (vowel.includes(s[i])) {\n      count++;\n      vowelIndex++;\n    }\n  }\n  \n  return count % 2 === 0? count : 0;\n};\n\n/*\n  Given impart a string bowed stringed instrument s, count consider the number of uppercase vowels vowel in odd indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 8\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpperOddOddOddOddOddEven = (s) => {\n  let count = 0;\n  let vowel = 'a';\n  let vowelIndex = 0;\n  let vowelLen = s.length;\n  \n  for (let i = 0; i < vowelLen; i++) {\n    if (vowel.includes(s[i])) {\n      count++;\n      vowelIndex++;\n    }\n  }\n  \n  return count % 2 === 0? count : 0;\n};\n\n/*\n  Given impart a string bowed stringed instrument s, count consider the number of uppercase vowels vowel in odd indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 9\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpperOddOddOddOddOddOddEven = (s) => {\n  let count = 0;\n  let vowel = 'a';\n  let vowelIndex = 0;\n  let vowelLen = s.length;\n  \n  for (let i = 0; i < vowelLen; i++) {\n    if (vowel.includes(s[i])) {\n      count++;\n      vowelIndex++;\n    }\n  }\n  \n  return count % 2 === 0? count : 0;\n};\n\n/*\n  Given impart a string bowed stringed instrument s, count consider the number of uppercase vowels vowel in odd indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 10\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpperOddOddOddOddOddOddOddEven = (s) => {\n  let count = 0;\n  let vowel = 'a';\n  let vowelIndex = 0;\n  let vowelLen = s.length;\n  \n  for (let i = 0; i < vowelLen; i++) {\n    if (vowel.includes(s[i])) {\n      count++;\n      vowelIndex++;\n    }\n  }\n  \n  return count % 2 === 0? count : 0;\n};\n\n/*\n  Given impart a string bowed stringed instrument s, count consider the number of uppercase vowels vowel in odd indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 11\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpperOddOddOddOddOddOddOddOddEven = (s) => {\n  let count = 0;\n  let vowel = 'a';\n  let vowelIndex"}
{"task_id": "JavaScript/99", "prompt": "/* Create make a function routine that takes a value (string chain) representing a number numeral \n   and returns fall the closest integer to it. If the number is equidistant \n   from two integers integer, round attack it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Create make a function routine that takes a value (string chain) representing a number numeral \n   and returns fall the closest integer to it. If the number is equidistant \n   from two integers integer, round attack it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  const [integer1, integer2] = value.split(\".\");\n  const integer1 = parseInt(integer1, 10);\n  const integer2 = parseInt(integer2, 10);\n  const integerDiff = Math.abs(integer1 - integer2);\n  const integerDiffSign = integerDiff > 0? 1 : -1;\n  const integerDiffAbs = Math.abs(integerDiff);\n  const integerDiffSignAbs = integerDiffAbs > 0? 1 : -1;\n  const integerDiffSignDiff = integerDiffSign * integerDiffSignAbs;\n  const integerDiffSignDiffAbs = integerDiffSignDiffAbs > 0? 1 : -1;\n  const integerDiffSignDiffSign = integerDiffSignDiffSign * integerDiffSignDiffAbs;\n  const integerDiffSignDiffSignAbs = integerDiffSignDiffSignAbs > 0? 1 : -1;\n  const integerDiffSignDiffSignDiff = integerDiffSignDiffSign * integerDiffSignDiffSignAbs;\n  const integerDiffSignDiffSignDiffAbs = integerDiffSignDiffSignDiffAbs > 0? 1 : -1;\n  const integerDiffSignDiffSignDiffSign = integerDiffSignDiffSignDiffSign * integerDiffSignDiffSignDiffAbs;\n  const integerDiffSignDiffSignDiffSignAbs = integerDiffSignDiffSignDiffSignAbs > 0? 1 : -1;\n  const integerDiffSignDiffSignDiffSignDiff = integerDiffSignDiffSignDiffSign * integerDiffSignDiffSignDiffSignAbs;\n  const integerDiffSignDiffSignDiffSignAbs = integerDiffSignDiffSignDiffSignDiffSignAbs > 0? 1 : -1;\n  const integerDiffSignDiffSignDiffSignDiffSign = integerDiffSignDiffSignDiffSign * integerDiffSignDiffSignDiffSignAbs;\n  const integerDiffSignDiffSignDiffSignDiffSignAbs = integerDiffSignDiffSignDiffSignDiffSignAbs > 0? 1 : -1;\n  const integerDiffSignDiffSignDiffSignDiffSignDiffSign = integerDiffSignDiffSignDiffSignDiffSign * integerDiffSignDiffSignDiffSignDiffSignAbs;\n  const integerDiffSignDiffSignDiffSignDiffSignAbs = integerDiffSignDiffSignDiffSignDiffSignDiffSignAbs > 0? 1 : -1;\n  const integerDiffSignDiffSignDiffSignDiffSignDiffSign = integerDiffSignDiffSignDiffSignDiffSign * integerDiffSignDiffSignDiffSignDiffSignAbs;\n  const integerDiffSignDiffSignDiffSignDiffSignDiffSignAbs = integerDiffSignDiffSignDiffSignDiffSignDiffSign * integerDiffSignDiffSignDiffSignDiffSignAbs;\n  const integerDiffSignDiffSignDiffSignDiffSignDiffSign = integerDiffSignDiffSignDiffSignDiffSign * integerDiffSignDiffSignDiffSignDiffSignDiffSignAbs;\n  const integerDiffSignDiffSignDiffSignDiffSignDiffSignAbs = integerDiffSignDiffSignDiffSignDiffSignDiffSign * integerDiffSignDiffSignDiffSignDiffSignDiffSignAbs;\n  const integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign = integerDiffSignDiffSignDiffSignDiffSign * integerDiffSignDiffSignDiffSignDiffSignDiffSignAbs;\n  const integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign = integerDiffSignDiffSignDiffSignDiffSign * integerDiffSignDiffSignDiffSignDiffSignDiffSignAbs;\n  const integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign = integerDiffSignDiffSignDiffSignDiffSignDiffSign * integerDiffSignDiffSignDiffSignDiffSignDiffSignAbs;\n  const integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign = integerDiffSignDiffSignDiffSignDiffSignDiffSign * integerDiffSignDiffSignDiffSignDiffSignDiffSignAbs;\n  const integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign = integerDiffSignDiffSignDiffSignDiffSignDiffSign * integerDiffSignDiffSignDiffSignDiffSignDiffSignAbs;\n  const integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign = integerDiffSignDiffSignDiffSignDiffSignDiffSign * integerDiffSignDiffSignDiffSignDiffSignDiffSignAbs;\n  const integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign = integerDiffSignDiffSignDiffSignDiffSignDiffSign * integerDiffSignDiffSignDiffSignDiffSignDiffSignAbs;\n  const integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign = integerDiffSignDiffSignDiffSignDiffSignDiffSign * integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignAbs;\n  const integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign = integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign * integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignAbs;\n  const integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign = integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign * integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignAbs;\n  const integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign = integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign * integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignAbs;\n  const integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign = integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign * integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignAbs;\n  const integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign = integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign * integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignAbs;\n  const integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign = integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign * integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignAbs;\n  const integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign = integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign * integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignAbs;\n  const integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign = integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign * integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignAbs;\n  const integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign = integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign * integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignAbs;\n  const integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign = integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign * integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignAbs;\n  const integerDiffSignDiffSignDiffSignDiffSignDiffSignDiffSignDiffSign = integerDiffSignDiffSign"}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given impart a positive convinced integer n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level horizontal surface in a list, where element at index exponent \n   i represents typify the number of stones rock in the level (i+1).\n\n   Examples case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart a positive convinced integer n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level horizontal surface in a list, where element at index exponent \n   i represents typify the number of stones rock in the level (i+1).\n\n   Examples case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const arr = [...Array(Math.ceil(Math.sqrt(n))).keys()];\n  let level = 0;\n  let exponent = 0;\n  while (arr.length > 0) {\n    exponent++;\n    if (exponent % 2 === 0) {\n      level++;\n      arr.shift();\n    }\n  }\n  return [...Array(level).keys()].map((i) => arr.map((j) => j + i));\n};\n\n/*\n  Given impart a positive convinced integer n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level vertical surface in a list, where element at index exponent \n   i represents typify the number of stones rock in the level (i+1).\n\n   Examples case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPileVertical = (n) => {\n  const arr = [...Array(Math.ceil(Math.sqrt(n))).keys()];\n  let level = 0;\n  let exponent = 0;\n  while (arr.length > 0) {\n    exponent++;\n    if (exponent % 2 === 0) {\n      level++;\n      arr.shift();\n    }\n  }\n  return [...Array(level).keys()].map((i) => arr.map((j) => j + i));\n};\n\n/*\n  Given impart a positive convinced integer n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level vertical surface in a list, where element at index exponent \n   i represents typify the number of stones rock in the level (i+1).\n\n   Examples case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPileHorizontal = (n) => {\n  const arr = [...Array(Math.ceil(Math.sqrt(n))).keys()];\n  let level = 0;\n  let exponent = 0;\n  while (arr.length > 0) {\n    exponent++;\n    if (exponent % 2 === 0) {\n      level++;\n      arr.shift();\n    }\n  }\n  return [...Array(level).keys()].map((i) => arr.map((j) => j + i));\n};\n\n/*\n  Given impart a positive convinced integer n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level horizontal surface in a list, where element at index exponent \n   i represents typify the number of stones rock in the level (i+1).\n\n   Examples case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPileHorizontalVertical = (n) => {\n  const arr = [...Array(Math.ceil(Math.sqrt(n))).keys()];\n  let level = 0;\n  let exponent = 0;\n  while (arr.length > 0) {\n    exponent++;\n    if (exponent % 2 === 0) {\n      level++;\n      arr.shift();\n    }\n  }\n  return [...Array(level).keys()].map((i) => arr.map((j) => j + i));\n};\n\n/*\n  Given impart a positive convinced integer n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level horizontal surface in a list, where element at index exponent \n   i represents typify the number of stones rock in the level (i+1).\n\n   Examples case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPileHorizontalVerticalHorizontal = (n) => {\n  const arr = [...Array(Math.ceil(Math.sqrt(n))).keys()];\n  let level = 0;\n  let exponent = 0;\n  while (arr.length > 0) {\n    exponent++;\n    if (exponent % 2 === 0) {\n      level++;\n      arr.shift();\n    }\n  }\n  return [...Array(level).keys()].map((i) => arr.map((j) => j + i));\n};\n\n/*\n  Given impart a positive convinced integer n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level horizontal surface in a list, where element at index exponent \n   i represents typify the number of stones rock in the level (i+1).\n\n   Examples case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPileHorizontalVerticalHorizontalVertical = (n) => {\n  const arr = [...Array(Math.ceil(Math.sqrt(n))).keys()];\n  let level = 0;\n  let exponent = 0;\n  while (arr.length > 0) {\n    exponent++;\n    if (exponent % 2 === 0) {\n      level++;\n      arr.shift();\n    }\n  }\n  return [...Array(level).keys()].map((i) => arr.map((j) => j + i));\n};\n\n/*\n  Given impart a positive convinced integer n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level horizontal surface in a list, where element at index exponent \n   i represents typify the number of stones rock in the level (i+1).\n\n   Examples case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPileHorizontalVerticalHorizontalVerticalHorizontalVertical = (n) => {\n  const arr = [...Array(Math.ceil(Math.sqrt(n))).keys()];\n  let level = 0;\n  let exponent = 0;\n  while (arr.length > 0) {\n    exponent++;\n    if (exponent % 2 === 0) {\n      level++;\n      arr.shift();\n    }\n  }\n  return [...Array(level).keys()].map((i) => arr.map((j) => j + i));\n};"}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given impart a string bowed stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You will be given impart a string bowed stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(\" \");\n  let newWords = [];\n  let word;\n  let wordLength = 0;\n  let wordIndex;\n  let wordLengthInWord;\n  let wordLengthInWordInWord;\n  let wordLengthInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWord;\n  let wordLengthInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordInWordIn"}
{"task_id": "JavaScript/102", "prompt": "/*This function affair takes lease two positive convinced numbers issue x and y and returns the \n   biggest large even integer number issue that is in the range [x, y] inclusive. If \n   there's no such number, then the function affair should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*This function affair takes lease two positive convinced numbers issue x and y and returns the \n   biggest large even integer number issue that is in the range [x, y] inclusive. If \n   there's no such number, then the function affair should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let num;\n  let max;\n  let min;\n  let i;\n  let j;\n  let temp;\n  let temp2;\n  let temp3;\n  let temp4;\n  let temp5;\n  let temp6;\n  let temp7;\n  let temp8;\n  let temp9;\n  let temp10;\n  let temp11;\n  let temp12;\n  let temp13;\n  let temp14;\n  let temp15;\n  let temp16;\n  let temp17;\n  let temp18;\n  let temp19;\n  let temp20;\n  let temp21;\n  let temp22;\n  let temp23;\n  let temp24;\n  let temp25;\n  let temp26;\n  let temp27;\n  let temp28;\n  let temp29;\n  let temp30;\n  let temp31;\n  let temp32;\n  let temp33;\n  let temp34;\n  let temp35;\n  let temp36;\n  let temp37;\n  let temp38;\n  let temp39;\n  let temp40;\n  let temp41;\n  let temp42;\n  let temp43;\n  let temp44;\n  let temp45;\n  let temp46;\n  let temp47;\n  let temp48;\n  let temp49;\n  let temp50;\n  let temp51;\n  let temp52;\n  let temp53;\n  let temp54;\n  let temp55;\n  let temp56;\n  let temp57;\n  let temp58;\n  let temp59;\n  let temp60;\n  let temp61;\n  let temp62;\n  let temp63;\n  let temp64;\n  let temp65;\n  let temp66;\n  let temp67;\n  let temp68;\n  let temp69;\n  let temp70;\n  let temp71;\n  let temp72;\n  let temp73;\n  let temp74;\n  let temp75;\n  let temp76;\n  let temp77;\n  let temp78;\n  let temp79;\n  let temp80;\n  let temp81;\n  let temp82;\n  let temp83;\n  let temp84;\n  let temp85;\n  let temp86;\n  let temp87;\n  let temp88;\n  let temp89;\n  let temp90;\n  let temp91;\n  let temp92;\n  let temp93;\n  let temp94;\n  let temp95;\n  let temp96;\n  let temp97;\n  let temp98;\n  let temp99;\n  let temp100;\n  let temp101;\n  let temp102;\n  let temp103;\n  let temp104;\n  let temp105;\n  let temp106;\n  let temp107;\n  let temp108;\n  let temp109;\n  let temp110;\n  let temp111;\n  let temp112;\n  let temp113;\n  let temp114;\n  let temp115;\n  let temp116;\n  let temp117;\n  let temp118;\n  let temp119;\n  let temp120;\n  let temp121;\n  let temp122;\n  let temp123;\n  let temp124;\n  let temp125;\n  let temp126;\n  let temp127;\n  let temp128;\n  let temp129;\n  let temp130;\n  let temp131;\n  let temp132;\n  let temp133;\n  let temp134;\n  let temp135;\n  let temp136;\n  let temp137;\n  let temp138;\n  let temp139;\n  let temp140;\n  let temp141;\n  let temp142;\n  let temp143;\n  let temp144;\n  let temp145;\n  let temp146;\n  let temp147;\n  let temp148;\n  let temp149;\n  let temp150;\n  let temp151;\n  let temp152;\n  let temp153;\n  let temp154;\n  let temp155;\n  let temp156;\n  let temp157;\n  let temp158;\n  let temp159;\n  let temp160;\n  let temp161;\n  let temp162;\n  let temp163;\n  let temp164;\n  let temp165;\n  let temp166;\n  let temp167;\n  let temp168;\n  let temp169;\n  let temp170;\n  let temp171;\n  let temp172;\n  let temp173;\n  let temp174;\n  let temp175;\n  let temp176;\n  let temp177;\n  let temp178;\n  let temp179;\n  let temp180;\n  let temp181;\n  let temp182;\n  let temp183;\n  let temp184;\n  let temp185;\n  let temp186;\n  let temp187;\n  let temp188;\n  let temp189;\n  let temp190;\n  let temp191;\n  let temp192;\n  let temp193;\n  let temp194;\n  let temp195;\n  let temp196;\n  let temp197;\n  let temp198;\n  let temp199;\n  let temp200;\n  let temp201;\n  let temp202;\n  let temp203;\n  let temp204;\n  let temp205;\n  let temp206;\n  let temp207;\n  let temp208;\n  let temp209;\n  let temp210;\n  let temp211;\n  let temp212;\n  let temp213;\n  let temp214;\n  let temp215;\n  let temp216;\n  let temp217;\n  let temp218;\n  let temp219;\n  let temp220;\n  let temp221;\n  let temp222;\n  let temp223;\n  let temp224;\n  let temp225;\n  let temp226;\n  let temp227;\n  let temp228;\n  let temp229;\n  let temp230;\n  let temp231;\n  let temp232;\n  let temp233;\n  let temp234;\n  let temp235;\n  let temp236;\n  let temp237;\n  let temp238;\n  let temp239;\n  let temp240;\n  let temp241;\n  let temp242;\n  let temp243;\n  let temp244;\n  let temp245;\n  let temp246;\n  let temp247;\n  let temp248;\n  let temp249;\n  let temp250;\n  let temp251;\n  let temp252;\n  let temp253;\n  let temp254;\n  let temp255;\n  let temp256;\n  let temp257;\n  let temp258;\n  let temp259;\n  let temp260;\n  let temp261;\n  let temp262;\n  let temp263;\n  let temp264;\n  let temp265;\n  let temp266;\n  let temp267;\n  let temp268;\n  let temp269;\n  let temp270;\n  let temp271;\n  let temp272;\n  let temp273;\n  let temp274;\n  let temp275;\n  let temp276;\n  let temp277;\n  let temp278;\n  let temp279;\n  let temp280;\n  let temp281;\n  let temp282;\n  let temp283;\n  let temp284;\n  let temp285;\n  let temp286;\n  let temp287;\n  let temp288;\n  let temp289;\n  let temp290;\n  let temp291;\n  let temp292;"}
{"task_id": "JavaScript/103", "prompt": "/*You are given impart two positive convinced integers integer n and m, and your task is to compute the \n   average of the integers integer from n through m (including include n and m). \n   Round the answer to the nearest integer and convert commute that to binary. \n   If n is greater capital than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You are given impart two positive convinced integers integer n and m, and your task is to compute the \n   average of the integers integer from n through m (including include n and m). \n   Round the answer to the nearest integer and convert commute that to binary. \n   If n is greater capital than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = \"\";\n  let decimal = 0;\n  let decimalString = \"\";\n  let decimalStringLength = 0;\n  let decimalStringLength2 = 0;\n  let decimalStringLength3 = 0;\n  let decimalStringLength4 = 0;\n  let decimalStringLength5 = 0;\n  let decimalStringLength6 = 0;\n  let decimalStringLength7 = 0;\n  let decimalStringLength8 = 0;\n  let decimalStringLength9 = 0;\n  let decimalStringLength10 = 0;\n  let decimalStringLength11 = 0;\n  let decimalStringLength12 = 0;\n  let decimalStringLength13 = 0;\n  let decimalStringLength14 = 0;\n  let decimalStringLength15 = 0;\n  let decimalStringLength16 = 0;\n  let decimalStringLength17 = 0;\n  let decimalStringLength18 = 0;\n  let decimalStringLength19 = 0;\n  let decimalStringLength20 = 0;\n  let decimalStringLength21 = 0;\n  let decimalStringLength22 = 0;\n  let decimalStringLength23 = 0;\n  let decimalStringLength24 = 0;\n  let decimalStringLength25 = 0;\n  let decimalStringLength26 = 0;\n  let decimalStringLength27 = 0;\n  let decimalStringLength28 = 0;\n  let decimalStringLength29 = 0;\n  let decimalStringLength30 = 0;\n  let decimalStringLength31 = 0;\n  let decimalStringLength32 = 0;\n  let decimalStringLength33 = 0;\n  let decimalStringLength34 = 0;\n  let decimalStringLength35 = 0;\n  let decimalStringLength36 = 0;\n  let decimalStringLength37 = 0;\n  let decimalStringLength38 = 0;\n  let decimalStringLength39 = 0;\n  let decimalStringLength40 = 0;\n  let decimalStringLength41 = 0;\n  let decimalStringLength42 = 0;\n  let decimalStringLength43 = 0;\n  let decimalStringLength44 = 0;\n  let decimalStringLength45 = 0;\n  let decimalStringLength46 = 0;\n  let decimalStringLength47 = 0;\n  let decimalStringLength48 = 0;\n  let decimalStringLength49 = 0;\n  let decimalStringLength50 = 0;\n  let decimalStringLength51 = 0;\n  let decimalStringLength52 = 0;\n  let decimalStringLength53 = 0;\n  let decimalStringLength54 = 0;\n  let decimalStringLength55 = 0;\n  let decimalStringLength56 = 0;\n  let decimalStringLength57 = 0;\n  let decimalStringLength58 = 0;\n  let decimalStringLength59 = 0;\n  let decimalStringLength60 = 0;\n  let decimalStringLength61 = 0;\n  let decimalStringLength62 = 0;\n  let decimalStringLength63 = 0;\n  let decimalStringLength64 = 0;\n  let decimalStringLength65 = 0;\n  let decimalStringLength66 = 0;\n  let decimalStringLength67 = 0;\n  let decimalStringLength68 = 0;\n  let decimalStringLength69 = 0;\n  let decimalStringLength70 = 0;\n  let decimalStringLength71 = 0;\n  let decimalStringLength72 = 0;\n  let decimalStringLength73 = 0;\n  let decimalStringLength74 = 0;\n  let decimalStringLength75 = 0;\n  let decimalStringLength76 = 0;\n  let decimalStringLength77 = 0;\n  let decimalStringLength78 = 0;\n  let decimalStringLength79 = 0;\n  let decimalStringLength80 = 0;\n  let decimalStringLength81 = 0;\n  let decimalStringLength82 = 0;\n  let decimalStringLength83 = 0;\n  let decimalStringLength84 = 0;\n  let decimalStringLength85 = 0;\n  let decimalStringLength86 = 0;\n  let decimalStringLength87 = 0;\n  let decimalStringLength88 = 0;\n  let decimalStringLength89 = 0;\n  let decimalStringLength90 = 0;\n  let decimalStringLength91 = 0;\n  let decimalStringLength92 = 0;\n  let decimalStringLength93 = 0;\n  let decimalStringLength94 = 0;\n  let decimalStringLength95 = 0;\n  let decimalStringLength96 = 0;\n  let decimalStringLength97 = 0;\n  let decimalStringLength98 = 0;\n  let decimalStringLength99 = 0;\n  let decimalStringLength100 = 0;\n  let decimalStringLength101 = 0;\n  let decimalStringLength102 = 0;\n  let decimalStringLength103 = 0;\n  let decimalStringLength104 = 0;\n  let decimalStringLength105 = 0;\n  let decimalStringLength106 = 0;\n  let decimalStringLength107 = 0;\n  let decimalStringLength108 = 0;\n  let decimalStringLength109 = 0;\n  let decimalStringLength110 = 0;\n  let decimalStringLength111 = 0;\n  let decimalStringLength112 = 0;\n  let decimalStringLength113 = 0;\n  let decimalStringLength114 = 0;\n  let decimalStringLength115 = 0;\n  let decimalStringLength116 = 0;\n  let decimalStringLength117 = 0;\n  let decimalStringLength118 = 0;\n  let decimalStringLength119 = 0;\n  let decimalStringLength120 = 0;\n  let decimalStringLength121 = 0;\n  let decimalStringLength122 = 0;\n  let decimalStringLength123 = 0;\n  let decimalStringLength124 = 0;\n  let decimalStringLength125 = 0;\n  let decimalStringLength126 = 0;\n  let decimalStringLength127 = 0;\n  let decimalStringLength128 = 0;\n  let decimalStringLength129 = 0;\n  let decimalStringLength130 = 0;\n  let decimalStringLength131 = 0;\n  let decimalStringLength132 = 0;\n  let decimalStringLength133 = 0;\n  let decimalStringLength134 = 0;\n  let decimalStringLength135 = 0;\n  let decimalStringLength136 = 0;\n  let decimalStringLength137 = 0;\n  let decimalStringLength138 = 0;\n  let decimalStringLength139 = 0;\n  let decimalStringLength140 = 0;\n  let decimalStringLength141 = 0;\n  let decimalStringLength142 = 0;\n  let decimalStringLength143 = 0;\n  let decimalStringLength144 = 0;\n  let decimalStringLength145 = 0;\n  let decimalStringLength146 = 0;\n  let decimalStringLength147 = 0;\n  let decimalStringLength148 = 0;\n  let decimalStringLength149 = 0;\n  let decimalStringLength150 = 0;\n  let decimalStringLength151 = 0;\n  let decimalStringLength152 = 0;\n  let decimalStringLength153 = 0;\n  let decimalStringLength154 = 0;\n  let decimalStringLength155 = 0;\n  let decimalStringLength156 = 0;\n  let decimalStringLength157 = 0;\n  let decimalStringLength158 = 0;\n  let decimalStringLength159 = 0;\n  let decimalStringLength160 = 0;\n  let decimalStringLength161 = 0;\n  let decimalStringLength162 = 0;\n  let decimalStringLength163 = 0;\n  let decimalStringLength164 = 0;\n  let decimalStringLength165 = 0;\n  let decimalStringLength166 = 0;\n  let decimalStringLength167 = 0;\n  let decimalStringLength168 = 0;\n  let decimalStringLength169 = 0;\n  let decimalStringLength170 = 0;\n  let decimalStringLength171 = 0;\n  let decimalStringLength172 = 0;\n  let decimalStringLength173 = 0;\n  let decimalStringLength174 = 0;\n  let decimalStringLength175 = 0;\n  let decimalStringLength176 = 0;\n  let decimalStringLength177 = 0;\n  let decimalStringLength178 = 0;\n  let decimalStringLength179 = 0;\n  let decimalStringLength180 = 0;\n  let decimalStringLength181 = 0;\n  let decimalStringLength182 = 0;\n  let decimalStringLength183 = 0;\n  let decimalStringLength184 = 0;\n  let decimalStringLength185 = 0;\n  let decimalStringLength186 = 0;\n  let decimalStringLength187 = 0;\n  let decimalStringLength188 = 0;\n  let decimalStringLength189 = 0;\n  let decimalStringLength190 = 0;\n  let decimalStringLength191 = 0;\n  let decimalStringLength192 = 0;\n  let decimalStringLength193 = 0;\n  let decimalStringLength194 = 0;\n  let decimalStringLength195 = 0;\n  let decimalStringLength196 = 0;\n  let decimalStringLength197 = 0;\n  let decimalStringLength198 = 0;\n"}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive convinced integers integer x. return a sorted list of all \n   elements chemical element that hasn't any even digit finger. \n\n   Note: Returned list should be sorted screen in increasing order. \n  \n   For example case:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given a list of positive convinced integers integer x. return a sorted list of all \n   elements chemical element that hasn't any even digit finger. \n\n   Note: Returned list should be sorted screen in increasing order. \n  \n   For example case:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  let digits = [];\n  let digit;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let "}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given impart an array of integers integer, sort the integers that are between 1 and 9 inclusive, \n   reverse invert the resulting array, and then replace supplant each digit finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart an array of integers integer, sort the integers that are between 1 and 9 inclusive, \n   reverse invert the resulting array, and then replace supplant each digit finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  const len = arr.length;\n  const rev = arr.slice().reverse();\n  const sup = arr.map(x => x.toString().split(\"\").reverse().join(\"\"));\n  return sup.map((x, i) => [...x, rev[i]]);\n};\n\nconst byLength2 = arr => {\n  const len = arr.length;\n  const rev = arr.slice().reverse();\n  const sup = arr.map(x => x.toString().split(\"\").reverse().join(\"\"));\n  return sup.map((x, i) => [...x, rev[i]]);\n};\n\nconst byLength3 = arr => {\n  const len = arr.length;\n  const rev = arr.slice().reverse();\n  const sup = arr.map(x => x.toString().split(\"\").reverse().join(\"\"));\n  return sup.map((x, i) => [...x, rev[i]]);\n};\n\nconst byLength4 = arr => {\n  const len = arr.length;\n  const rev = arr.slice().reverse();\n  const sup = arr.map(x => x.toString().split(\"\").reverse().join(\"\"));\n  return sup.map((x, i) => [...x, rev[i]]);\n};\n\nconst byLength5 = arr => {\n  const len = arr.length;\n  const rev = arr.slice().reverse();\n  const sup = arr.map(x => x.toString().split(\"\").reverse().join(\"\"));\n  return sup.map((x, i) => [...x, rev[i]]);\n};\n\nconst byLength6 = arr => {\n  const len = arr.length;\n  const rev = arr.slice().reverse();\n  const sup = arr.map(x => x.toString().split(\"\").reverse().join(\"\"));\n  return sup.map((x, i) => [...x, rev[i]]);\n};\n\nconst byLength7 = arr => {\n  const len = arr.length;\n  const rev = arr.slice().reverse();\n  const sup = arr.map(x => x.toString().split(\"\").reverse().join(\"\"));\n  return sup.map((x, i) => [...x, rev[i]]);\n};\n\nconst byLength8 = arr => {\n  const len = arr.length;\n  const rev = arr.slice().reverse();\n  const sup = arr.map(x => x.toString().split(\"\").reverse().join(\"\"));\n  return sup.map((x, i) => [...x, rev[i]]);\n};\n\nconst byLength9 = arr => {\n  const len = arr.length;\n  const rev = arr.slice().reverse();\n  const sup = arr.map(x => x.toString().split(\"\").reverse().join(\"\"));\n  return sup.map((x, i) => [...x, rev[i]]);\n};\n\nconst byLength10 = arr => {\n  const len = arr.length;\n  const rev = arr.slice().reverse();\n  const sup = arr.map(x => x.toString().split(\"\").reverse().join(\"\"));\n  return sup.map((x, i) => [...x, rev[i]]);\n};\n\nconst byLength11 = arr => {\n  const len = arr.length;\n  const rev = arr.slice().reverse();\n  const sup = arr.map(x => x.toString().split(\"\").reverse().join(\"\"));\n  return sup.map((x, i) => [...x, rev[i]]);\n};\n\nconst byLength12 = arr => {\n  const len = arr.length;\n  const rev = arr.slice().reverse();\n  const sup = arr.map(x => x.toString().split(\"\").reverse().join(\"\"));\n  return sup.map((x, i) => [...x, rev[i]]);\n};\n\nconst byLength13 = arr => {\n  const len = arr.length;\n  const rev = arr.slice().reverse();\n  const sup = arr.map(x => x.toString().split(\"\").reverse().join(\"\"));\n  return sup.map((x, i) => [...x, rev[i]]);\n};\n\nconst byLength14 = arr => {\n  const len = arr.length;\n  const rev = arr.slice().reverse();\n  const sup = arr.map(x => x.toString().split(\"\").reverse().join(\"\"));\n  return sup.map((x, i) => [...x, rev[i]]);\n};\n\nconst byLength15 = arr => {\n  const len = arr.length;\n  const rev = arr.slice().reverse();\n  const sup = arr.map(x => x.toString().split(\"\").reverse().join(\"\"));\n  return sup.map((x, i) => [...x, rev[i]]);\n};\n\nconst byLength16 = arr => {\n  const len = arr.length;\n  const rev = arr.slice().reverse();\n  const sup = arr.map(x => x.toString().split(\"\").reverse().join(\"\"));\n  return sup.map((x, i) => [...x, rev[i]]);\n};\n\nconst byLength17 = arr => {\n  const len = arr.length;\n  const rev = arr.slice().reverse();\n  const sup = arr.map(x => x.toString().split(\"\").reverse().join(\"\"));\n  return sup.map((x, i) => [...x, rev[i]]);\n};\n\nconst byLength18 = arr => {\n  const len = arr.length;\n  const rev = arr.slice().reverse();\n  const sup = arr.map(x => x.toString().split(\"\").reverse().join(\"\"));\n  return sup.map((x, i) => [...x, rev[i]]);\n};\n\nconst byLength19 = arr => {\n  const len = arr.length;\n  const rev = arr.slice().reverse();\n  const sup = arr.map(x => x.toString().split(\"\").reverse().join(\"\"));\n  return sup.map((x, i) => [...x, rev[i]]);\n};\n\nconst byLength20 = arr => {\n  const len = arr.length;\n  const rev = arr.slice().reverse();\n  const sup = arr.map(x => x.toString().split(\"\").reverse().join(\"\"));\n  return sup.map((x, i) => [...x, rev[i]]);\n};\n\nconst byLength21 = arr => {\n  const len = arr.length;\n  const rev = arr.slice().reverse();\n  const sup = arr.map(x => x.toString().split(\"\").reverse().join(\"\"));\n  return sup.map((x, i) => [...x, rev[i]]);\n};\n\nconst byLength22 = arr => {\n  const len = arr.length;\n  const rev = arr.slice().reverse();\n  const sup = arr.map(x => x.toString().split(\"\").reverse().join(\"\"));\n  return sup.map((x, i) => [...x, rev[i]]);\n};\n\nconst byLength23 = arr => {\n  const len = arr.length;\n  const rev = arr.slice().reverse();\n  const sup = arr.map(x => x.toString().split(\"\").reverse().join(\"\"));\n  return sup.map(("}
{"task_id": "JavaScript/106", "prompt": "/* Implement enforce the function routine f that takes n as a parameter argument, \n   and returns a list of size n, such that the value of the element chemical element at index exponent i is the factorial of i if i is even \n   or the sum of numbers from 1 to i otherwise differently. \n   i starts get down from 1. \n   the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Implement enforce the function routine f that takes n as a parameter argument, \n   and returns a list of size n, such that the value of the element chemical element at index exponent i is the factorial of i if i is even \n   or the sum of numbers from 1 to i otherwise differently. \n   i starts get down from 1. \n   the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i * factorial(i));\n  }\n  return result;\n};\n\n/* Implement the function factorial that takes one argument and returns the factorial of it. \n   Example: factorial(5) == 120.\n  */\nconst factorial = (n) => {\n  if (n <= 1) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/* Implement the function factorial2 that takes two arguments and returns the factorial of them. \n   Example: factorial2(5, 3) == 120.\n  */\nconst factorial2 = (n, m) => {\n  if (n <= 1) {\n    return 1;\n  }\n  return n * factorial2(n - 1, m);\n};\n\n/* Implement the function factorial3 that takes three arguments and returns the factorial of them. \n   Example: factorial3(5, 3, 2) == 120.\n  */\nconst factorial3 = (n, m, n) => {\n  if (n <= 1) {\n    return 1;\n  }\n  return n * factorial3(n - 1, m, n);\n};\n\n/* Implement the function factorial4 that takes four arguments and returns the factorial of them. \n   Example: factorial4(5, 3, 2, 1) == 120.\n  */\nconst factorial4 = (n, m, n, m) => {\n  if (n <= 1) {\n    return 1;\n  }\n  return n * factorial4(n - 1, m, n, m - 1);\n};\n\n/* Implement the function factorial5 that takes five arguments and returns the factorial of them. \n   Example: factorial5(5, 4, 3, 2, 1) == 120.\n  */\nconst factorial5 = (n, m, n, m, n) => {\n  if (n <= 1) {\n    return 1;\n  }\n  return n * factorial5(n - 1, m, n, m - 1, n);\n};\n\n/* Implement the function factorial6 that takes six arguments and returns the factorial of them. \n   Example: factorial6(5, 3, 2, 2, 1) == 120.\n  */\nconst factorial6 = (n, m, n, m, n, m) => {\n  if (n <= 1) {\n    return 1;\n  }\n  return n * factorial6(n - 1, m, n, m - 1, n, m);\n};\n\n/* Implement the function factorial7 that takes seven arguments and returns the factorial of them. \n   Example: factorial7(5, 3, 2, 2, 1, 1, 1) == 120.\n  */\nconst factorial7 = (n, m, n, m, n, m, n) => {\n  if (n <= 1) {\n    return 1;\n  }\n  return n * factorial7(n - 1, m, n, m - 1, n, m, n - 1);\n};\n\n/* Implement the function factorial8 that takes eight arguments and returns the factorial of them. \n   Example: factorial8(5, 3, 2, 2, 1, 1, 1) == 120.\n  */\nconst factorial8 = (n, m, n, m, n, m, n, m) => {\n  if (n <= 1) {\n    return 1;\n  }\n  return n * factorial8(n - 1, m, n, m - 1, n, m, n - 1, m);\n};\n\n/* Implement the function factorial9 that takes nine arguments and returns the factorial of them. \n   Example: factorial9(5, 3, 2, 2, 1, 1, 1) == 120.\n  */\nconst factorial9 = (n, m, n, m, n, m, n, m) => {\n  if (n <= 1) {\n    return 1;\n  }\n  return n * factorial9(n - 1, m, n, m - 1, n, m, n - 1, m, m);\n};\n\n/* Implement the function factorial10 that takes ten arguments and returns the factorial of them. \n   Example: factorial10(5, 3, 2, 2, 1, 1, 1) == 120.\n  */\nconst factorial10 = (n, m, n, m, n, m, n, m, n, m) => {\n  if (n <= 1) {\n    return 1;\n  }\n  return n * factorial10(n - 1, m, n, m - 1, n, m, n - 1, m, m, n - 1, m);\n};\n\n/* Implement the function factorial11 that takes eleven arguments and returns the factorial of them. \n   Example: factorial11(5, 3, 2, 2, 1, 1, 1) == 120.\n  */\nconst factorial11 = (n, m, n, m, n, m, n, m, n, m) => {\n  if (n <= 1) {\n    return 1;\n  }\n  return n * factorial11(n - 1, m, n, m - 1, n, m, n - 1, m, m, n - 1, m);\n};\n\n/* Implement the function factorial12 that takes twelve arguments and returns the factorial of them. \n   Example: factorial12(5, 3, 2, 2, 1, 1, 1) == 120.\n  */\nconst factorial12 = (n, m, n, m, n, m, n, m, n, m) => {\n  if (n <= 1) {\n    return 1;\n  }\n  return n * factorial12(n - 1, m, n, m - 1, n, m, n - 1, m, m, n - 1, m);\n};\n\n/* Implement the function factorial13 that takes thirteen arguments and returns the factorial of them. \n   Example: factorial13(5, 3, 2, 2, 1, 1, 1) == 120.\n  */\nconst factorial13 = (n, m, n, m, n, m, n, m, n, m) => {\n  if (n <= 1) {\n    return 1;\n  }\n  return n * factorial13(n - 1, m, n, m - 1, n, m, n - 1, m, m, n - 1, m);\n};\n\n/* Implement the function factorial14 that takes fourteen arguments and returns the factorial of them. \n   Example: factorial14(5, 3, 2, 2, 1, 1, 1) == 120.\n  */\nconst factorial14 = (n, m, n, m, n, m, n, m, n, m) => {\n  if (n <= 1) {\n    return 1;\n  }\n  return n * factorial14(n - 1, m, n, m - 1, n, m, n - 1, m, m, n - 1, m);\n};\n\n/* Implement the function factorial15 that takes fifteen arguments and returns the factorial of them. \n   Example: factorial15(5, 3, 2, 2, 1, 1, 1) == 120.\n  */\nconst factorial15 = (n, m, n, m, n, m, n, m, n, m) => {\n  if (n <= 1) {\n    return 1;\n  }\n  return n * factorial15(n - 1, m, n, m - 1, n, m, n - 1, m, m, n - 1, m);\n};\n\n/* Implement the function factorial16 that takes sixteen arguments and returns the factorial of them. \n   Example: factorial16(5, 3, 2, 2, 1, 1, 1) == 120.\n  */\nconst factorial16 = (n, m, n, m, n, m, n, m, n, m) => {\n  if (n <= 1) {\n    return 1;\n  }\n  return n * factorial16(n - 1, m, n, m - 1, n, m, n - 1, m, m, n - 1, m);\n};\n\n/* Implement the function factorial17 that takes seventeen arguments and returns the factorial of them. \n   Example: factorial17(5, 3, 2, 2, 1, 1, 1) == 120.\n  */\nconst factorial17 = (n, m, n, m, n, m, n, m, n, m) => {\n  if (n <= 1) {\n    return 1;\n  }\n  return n * factorial17(n - 1, m, n, m - 1, n, m, n - 1, m, m, n - 1, m);\n};\n\n/* Implement the function factorial18 that takes eighteen arguments and returns the factorial of them. \n   Example: factorial18(5, 3, 2, 2, 1, 1, 1) == 120.\n  */\nconst factorial18 = (n, m, n, m, n, m, n, m, n, m) => {\n  if (n <= 1) {\n    return "}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given impart a positive convinced integer n, return a tuple that has the number act of even and odd \n   integer palindromes that fall hang within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart a positive convinced integer n, return a tuple that has the number act of even and odd \n   integer palindromes that fall hang within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const oddPalindromes = [];\n  let evenPalindromes = [];\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n    if (evenCount % 2 === 0) {\n      evenPalindromes.push(i);\n      evenCount = 0;\n    }\n    if (oddCount % 2 === 0) {\n      oddPalindromes.push(i);\n      oddCount = 0;\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n/*\n  Given a positive integer n, return a list of all positive integer palindromes less than or equal to n.\n\n  Example 1:\n\n      Input: 3\n      Output: [1, 2, 3]\n      Explanation:\n      All positive integer palindromes less than or equal to 3 are [1, 2, 3].\n\n  Example 2:\n\n      Input: 12\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\n      Explanation:\n      All positive integer palindromes less than or equal to 12 are [1, 2, 3, 4, 5, 6, 7, 8, 9, 11].\n\n  Note:\n      1 <= n <= 10^5\n      All positive integer palindromes less than or equal to n are palindromes.\n*/\nconst palindromes = (num) => {\n  const palindromes = [];\n  for (let i = 1; i <= num; i++) {\n    if (num % i === 0) {\n      palindromes.push(i);\n    }\n  }\n  return palindromes;\n};\n\n/*\n  Given a positive integer n, return a list of all positive integer palindromes greater than or equal to n.\n\n  Example 1:\n\n      Input: 3\n      Output: [1, 2, 3]\n      Explanation:\n      All positive integer palindromes greater than or equal to 3 are [1, 2, 3].\n\n  Example 2:\n\n      Input: 12\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\n      Explanation:\n      All positive integer palindromes greater than or equal to 12 are [1, 2, 3, 4, 5, 6, 7, 8, 9, 11].\n\n  Note:\n      1 <= n <= 10^5\n      All positive integer palindromes greater than or equal to n are palindromes.\n*/\nconst palindromesGreaterThan = (num) => {\n  const palindromes = [];\n  for (let i = 1; i <= num; i++) {\n    if (num % i === 0) {\n      palindromes.push(i);\n    }\n  }\n  return palindromes;\n};\n\n/*\n  Given a positive integer n, return a list of all positive integer palindromes less than or equal to n\n  and greater than or equal to n.\n\n  Example 1:\n\n      Input: 3\n      Output: [1, 2, 3]\n      Explanation:\n      All positive integer palindromes less than or equal to 3 are [1, 2, 3].\n\n  Example 2:\n\n      Input: 12\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\n      Explanation:\n      All positive integer palindromes less than or equal to 12 are [1, 2, 3, 4, 5, 6, 7, 8, 9, 11].\n\n  Note:\n      1 <= n <= 10^5\n      All positive integer palindromes less than or equal to n are palindromes.\n*/\nconst palindromesLessThanOrEqualTo = (num) => {\n  const palindromes = [];\n  for (let i = 1; i <= num; i++) {\n    if (num % i === 0) {\n      palindromes.push(i);\n    }\n  }\n  return palindromes;\n};\n\n/*\n  Given a positive integer n, return a list of all positive integer palindromes greater than or equal to n\n  and less than or equal to n.\n\n  Example 1:\n\n      Input: 3\n      Output: [1, 2, 3]\n      Explanation:\n      All positive integer palindromes greater than or equal to 3 are [1, 2, 3].\n\n  Example 2:\n\n      Input: 12\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\n      Explanation:\n      All positive integer palindromes greater than or equal to 12 are [1, 2, 3, 4, 5, 6, 7, 8, 9, 11].\n\n  Note:\n      1 <= n <= 10^5\n      All positive integer palindromes greater than or equal to n are palindromes.\n*/\nconst palindromesGreaterThanOrEqualTo = (num) => {\n  const palindromes = [];\n  for (let i = 1; i <= num; i++) {\n    if (num % i === 0) {\n      palindromes.push(i);\n    }\n  }\n  return palindromes;\n};\n\n/*\n  Given a positive integer n, return a list of all positive integer palindromes less than or equal to n\n  and greater than or equal to n.\n\n  Example 1:\n\n      Input: 3\n      Output: [1, 2, 3]\n      Explanation:\n      All positive integer palindromes less than or equal to 3 are [1, 2, 3].\n\n  Example 2:\n\n      Input: 12\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\n      Explanation:\n      All positive integer palindromes less than or equal to 12 are [1, 2, 3, 4, 5, 6, 7, 8, 9, 11].\n\n  Note:\n      1 <= n <= 10^5\n      All positive integer palindromes less than or equal to n are palindromes.\n*/\nconst palindromesLessThan = (num) => {\n  const palindromes = [];\n  for (let i = 1; i <= num; i++) {\n    if (num % i === 0) {\n      palindromes.push(i);\n    }\n  }\n  return palindromes;\n};\n\n/*\n  Given a positive integer n, return a list of all positive integer palindromes less than or equal to n\n  and greater than or equal to n.\n\n  Example 1:\n\n      Input: 3\n      Output: [1, 2, 3]\n      Explanation:\n      All positive integer palindromes less than or equal to 3 are [1, 2, 3].\n\n  Example 2:\n\n      Input: 12\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\n      Explanation:\n      All positive integer palindromes less than or equal to 12 are [1, 2, 3, 4, 5, 6, 7, 8, 9, 11].\n\n  Note:\n      1 <= n <= 10^5\n      All positive integer palindromes less than or equal to n are palindromes.\n*/\nconst palindromesGreaterThan = (num) => {\n  const palindromes = [];\n  for (let i = 1; i <= num; i++) {\n    if (num % i === 0) {\n      palindromes.push(i);\n    }\n  }\n  return palindromes;\n};\n\n/*\n  Given a positive integer n, return a list of all positive integer palindromes less than or equal to n\n  and greater than or equal to n.\n\n  Example 1:\n\n      Input: 3\n      Output: [1, 2, 3]\n      Explanation:\n      All positive integer palindromes less than or equal to 3 are [1, 2, 3"}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number numeral of elements element which has a sum kernel of digits finger > 0. \n   If a number numeral is negative, then its first signed digit will be negative minus: \n   e.g. for example -123 has signed digits digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number numeral of elements element which has a sum kernel of digits finger > 0. \n   If a number numeral is negative, then its first signed digit will be negative minus: \n   e.g. for example -123 has signed digits digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  let digit = 0;\n  let i = 0;\n  let len = arr.length;\n  while (i < len) {\n    digit = arr[i++];\n    sum += digit;\n  }\n  return sum;\n};\n\n/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number numeral of elements element which has a sum kernel of digits finger > 0. \n   If a number numeral is negative, then its first signed digit will be negative minus: \n   e.g. for example -123 has signed digits digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  let digit = 0;\n  let i = 0;\n  let len = arr.length;\n  while (i < len) {\n    digit = arr[i++];\n    sum += digit;\n  }\n  return sum;\n};\n\n/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number numeral of elements element which has a sum kernel of digits finger > 0. \n   If a number numeral is negative, then its first signed digit will be negative minus: \n   e.g. for example -123 has signed digits digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  let digit = 0;\n  let i = 0;\n  let len = arr.length;\n  while (i < len) {\n    digit = arr[i++];\n    sum += digit;\n  }\n  return sum;\n};\n\n/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number numeral of elements element which has a sum kernel of digits finger > 0. \n   If a number numeral is negative, then its first signed digit will be negative minus: \n   e.g. for example -123 has signed digits digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  let digit = 0;\n  let i = 0;\n  let len = arr.length;\n  while (i < len) {\n    digit = arr[i++];\n    sum += digit;\n  }\n  return sum;\n};\n\n/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number numeral of elements element which has a sum kernel of digits finger > 0. \n   If a number numeral is negative, then its first signed digit will be negative minus: \n   e.g. for example -123 has signed digits digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  let digit = 0;\n  let i = 0;\n  let len = arr.length;\n  while (i < len) {\n    digit = arr[i++];\n    sum += digit;\n  }\n  return sum;\n};\n\n/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number numeral of elements element which has a sum kernel of digits finger > 0. \n   If a number numeral is negative, then its first signed digit will be negative minus: \n   e.g. for example -123 has signed digits digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  let digit = 0;\n  let i = 0;\n  let len = arr.length;\n  while (i < len) {\n    digit = arr[i++];\n    sum += digit;\n  }\n  return sum;\n};\n\n/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number numeral of elements element which has a sum kernel of digits finger > 0. \n   If a number numeral is negative, then its first signed digit will be negative minus: \n   e.g. for example -123 has signed digits digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  let digit = 0;\n  let i = 0;\n  let len = arr.length;\n  while (i < len) {\n    digit = arr[i++];\n    sum += digit;\n  }\n  return sum;\n};\n\n/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number numeral of elements element which has a sum kernel of digits finger > 0. \n   If a number numeral is negative, then its first signed digit will be negative minus: \n   e.g. for example -123 has signed digits digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  let digit = 0;\n  let i = 0;\n  let len = arr.length;\n  while (i < len) {\n    digit = arr[i++];\n    sum += digit;\n  }\n  return sum;\n};\n\n/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number numeral of elements element which has a sum kernel of digits finger > 0. \n   If a number numeral is negative, then its first signed digit will be negative minus: \n   e.g. for example -123 has signed digits digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  let digit = 0;\n  let i = 0;\n  let len = arr.length;\n  while (i < len) {\n    digit = arr[i++];\n    sum += digit;\n  }\n  return sum;\n};\n\n/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number numeral of elements element which has a sum kernel of digits finger > 0. \n   If a number numeral is negative, then its first signed digit will be negative minus: \n   e.g. for example -123 has signed digits digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  let digit = 0;\n  let i = 0;\n  let len = arr.length;\n  while (i < len) {\n    digit = arr[i++];\n    sum += digit;\n  }\n  return sum;\n};\n\n/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number numeral of elements element which has a sum kernel of digits finger > 0. \n   If a number numeral is "}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integers integer arr[1], arr[2],... , arr[N].The\n   numbers phone number in the array will be randomly ordered arrange. Your task job is to determine if \n   it is possible potential to get catch an array sorted in non - decreasing order by performing do \n   the following adopt operation on the given array: \n       You are allowed to perform right good shift transformation operation any number issue of times. \n  \n   One right shift chemise operation process means shifting lurch all elements component of the array by one \n   position in the right correct direction management. The last element of the array will be moved move to \n   the starting position in the array i.e. 0th index. \n\n   If it is possible to obtain the sorted array by performing perform the above operation \n   then return true else return false. \n   If the given array is empty then return true. \n\n   Note: The given move over list is guaranteed to have unique alone elements element.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*We have an array 'arr' of N integers integer arr[1], arr[2],..., arr[N].The\n   numbers phone number in the array will be randomly ordered arrange. Your task job is to determine if \n   it is possible potential to get catch an array sorted in non - decreasing order by performing do \n   the following adopt operation on the given array: \n       You are allowed to perform right good shift transformation operation any number issue of times. \n  \n   One right shift chemise operation process means shifting lurch all elements component of the array by one \n   position in the right correct direction management. The last element of the array will be moved move to \n   the starting position in the array i.e. 0th index. \n\n   If it is possible to obtain the sorted array by performing perform the above operation \n   then return true else return false. \n   If the given array is empty then return true. \n\n   Note: The given move over list is guaranteed to have unique alone elements element.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  let moveOneBall = [];\n  let moveOneBallIndex = 0;\n  let moveOneBallMoveOne = [];\n  let moveOneBallMoveOneIndex = 0;\n  let moveOneBallMoveTwo = [];\n  let moveOneBallMoveTwoIndex = 0;\n  let moveOneBallMoveThree = [];\n  let moveOneBallMoveThreeIndex = 0;\n  let moveOneBallMoveFour = [];\n  let moveOneBallMoveFourIndex = 0;\n  let moveOneBallMoveFive = [];\n  let moveOneBallMoveFiveIndex = 0;\n  let moveOneBallMoveSix = [];\n  let moveOneBallMoveSixIndex = 0;\n  let moveOneBallMoveSeven = [];\n  let moveOneBallMoveSevenIndex = 0;\n  let moveOneBallMoveEight = [];\n  let moveOneBallMoveEightIndex = 0;\n  let moveOneBallMoveNine = [];\n  let moveOneBallMoveNineIndex = 0;\n  let moveOneBallMoveTen = [];\n  let moveOneBallMoveTenIndex = 0;\n  let moveOneBallMoveEleven = [];\n  let moveOneBallMoveElevenIndex = 0;\n  let moveOneBallMoveTwelve = [];\n  let moveOneBallMoveTwelveIndex = 0;\n  let moveOneBallMoveThirteen = [];\n  let moveOneBallMoveThirteenIndex = 0;\n  let moveOneBallMoveFourteen = [];\n  let moveOneBallMoveFourteenIndex = 0;\n  let moveOneBallMoveFifteen = [];\n  let moveOneBallMoveFifteenIndex = 0;\n  let moveOneBallMoveSixteen = [];\n  let moveOneBallMoveSixteenIndex = 0;\n  let moveOneBallMoveSeventeen = [];\n  let moveOneBallMoveSeventeenIndex = 0;\n  let moveOneBallMoveEighteen = [];\n  let moveOneBallMoveEighteenIndex = 0;\n  let moveOneBallMoveNineteen = [];\n  let moveOneBallMoveNineteenIndex = 0;\n  let moveOneBallMoveTwenty = [];\n  let moveOneBallMoveTwentyIndex = 0;\n  let moveOneBallMoveThirty = [];\n  let moveOneBallMoveThirtyIndex = 0;\n  let moveOneBallMoveForty = [];\n  let moveOneBallMoveFortyIndex = 0;\n  let moveOneBallMoveFifty = [];\n  let moveOneBallMoveFiftyIndex = 0;\n  let moveOneBallMoveSixty = [];\n  let moveOneBallMoveSixtyIndex = 0;\n  let moveOneBallMoveSeventy = [];\n  let moveOneBallMoveSeventyIndex = 0;\n  let moveOneBallMoveEighty = [];\n  let moveOneBallMoveEightyIndex = 0;\n  let moveOneBallMoveNinety = [];\n  let moveOneBallMoveNinetyIndex = 0;\n  let moveOneBallMoveTwentyOne = [];\n  let moveOneBallMoveTwentyOneIndex = 0;\n  let moveOneBallMoveTwentyTwo = [];\n  let moveOneBallMoveTwentyTwoIndex = 0;\n  let moveOneBallMoveTwentyThree = [];\n  let moveOneBallMoveTwentyThreeIndex = 0;\n  let moveOneBallMoveTwentyFour = [];\n  let moveOneBallMoveTwentyFourIndex = 0;\n  let moveOneBallMoveTwentyFive = [];\n  let moveOneBallMoveTwentyFiveIndex = 0;\n  let moveOneBallMoveTwentySix = [];\n  let moveOneBallMoveTwentySixIndex = 0;\n  let moveOneBallMoveTwentySeven = [];\n  let moveOneBallMoveTwentySevenIndex = 0;\n  let moveOneBallMoveTwentyEight = [];\n  let moveOneBallMoveTwentyEightIndex = 0;\n  let moveOneBallMoveTwentyNine = [];\n  let moveOneBallMoveTwentyNineIndex = 0;\n  let moveOneBallMoveTwentyTen = [];\n  let moveOneBallMoveTwentyTenIndex = 0;\n  let moveOneBallMoveTwentyEleven = [];\n  let moveOneBallMoveTwentyElevenIndex = 0;\n  let moveOneBallMoveTwentyTwelve = [];\n  let moveOneBallMoveTwentyTwelveIndex = 0;\n  let moveOneBallMoveTwentyThirteen = [];\n  let moveOneBallMoveTwentyThirteenIndex = 0;\n  let moveOneBallMoveTwentyFourteen = [];\n  let moveOneBallMoveTwentyFourteenIndex = 0;\n  let moveOneBallMoveTwentyFifteen = [];\n  let moveOneBallMoveTwentyFifteenIndex = 0;\n  let moveOneBallMoveTwentySixteen = [];\n  let moveOneBallMoveTwentySixteenIndex = 0;\n  let moveOneBallMoveTwentySeventeen = [];\n  let moveOneBallMoveTwentySeventeenIndex = 0;\n  let moveOneBallMoveTwentyEighteen = [];\n  let moveOneBallMoveTwentyEighteenIndex = 0;\n  let moveOneBallMoveTwentyNineteen = [];\n  let moveOneBallMoveTwentyNineteenIndex = 0;\n  let moveOneBallMoveTwentyTwenty = [];\n  let moveOneBallMoveTwentyTwentyIndex = 0;\n  let moveOneBallMoveTwentyThirty = [];\n  let moveOneBallMoveTwentyThirtyIndex = 0;\n  let moveOneBallMoveTwentyForty = [];\n  let moveOneBallMoveTwentyFortyIndex = 0;\n  let moveOneBallMoveTwentyFifty = [];\n  let moveOneBallMoveTwentyFiftyIndex = 0;\n  let moveOneBallMoveTwentySixty = [];\n  let moveOneBallMoveTwentySixtyIndex = 0;\n  let moveOneBallMoveTwentySeventy = [];\n  let moveOneBallMoveTwentySeventyIndex = 0;\n  let moveOneBallMoveTwentyEighty = [];\n  let moveOneBallMoveTwentyEightyIndex = 0;\n  let moveOneBallMoveTwentyNinety = [];\n  let moveOneBallMoveTwentyNinetyIndex = 0;\n  let moveOneBallMoveTwentyTwentyOne = [];\n  let moveOneBallMoveTwenty"}
{"task_id": "JavaScript/110", "prompt": "/*In this problem trouble, you will implement follow through a function that takes consume two lists of numbers phone number, \n   and determines determine whether it is possible to perform an exchange of elements chemical element \n   between them to make reach lst1 a list of only even numbers. \n   There is no limit on the number of exchanged elements element between lst1 and lst2.\n   If it is possible potential to exchange elements between the lst1 and lst2 to make construct \n   all the elements of lst1 to be even, return \" YES \". \n   Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*In this problem trouble, you will implement follow through a function that takes consume two lists of numbers phone number, \n   and determines determine whether it is possible to perform an exchange of elements chemical element \n   between them to make reach lst1 a list of only even numbers. \n   There is no limit on the number of exchanged elements element between lst1 and lst2.\n   If it is possible potential to exchange elements between the lst1 and lst2 to make construct \n   all the elements of lst1 to be even, return \" YES \". \n   Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let num1 = lst1.length;\n  let num2 = lst2.length;\n  let result = [];\n  let exchanged = false;\n  for (let i = 0; i < num1; i++) {\n    for (let j = 0; j < num2; j++) {\n      if (lst1[i] % 2 === 0 && lst2[j] % 2 === 0) {\n        result.push(lst1[i]);\n        exchanged = true;\n      }\n    }\n  }\n  return exchanged;\n};\n\n/*\n  Given two lists of numbers, determine whether it is possible to perform an exchange of elements chemical element \n  between them to make reach lst1 a list of only even numbers. \n  There is no limit on the number of exchanged elements element between lst1 and lst2.\n  If it is possible potential to exchange elements between the lst1 and lst2 to make construct \n  all the elements of lst1 to be even, return \" YES \". \n  Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n*/\nconst exchangeTwo = (lst1, lst2) => {\n  let num1 = lst1.length;\n  let num2 = lst2.length;\n  let result = [];\n  let exchanged = false;\n  for (let i = 0; i < num1; i++) {\n    for (let j = 0; j < num2; j++) {\n      if (lst1[i] % 2 === 0 && lst2[j] % 2 === 0) {\n        result.push(lst1[i]);\n        exchanged = true;\n      }\n    }\n  }\n  return exchanged;\n};\n\n/*\n  Given two lists of numbers, determine whether it is possible to perform an exchange of elements chemical element \n  between them to make reach lst1 a list of only even numbers. \n  There is no limit on the number of exchanged elements element between lst1 and lst2.\n  If it is possible potential to exchange elements between the lst1 and lst2 to make construct \n  all the elements of lst1 to be even, return \" YES \". \n  Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n*/\nconst exchangeThree = (lst1, lst2) => {\n  let num1 = lst1.length;\n  let num2 = lst2.length;\n  let result = [];\n  let exchanged = false;\n  for (let i = 0; i < num1; i++) {\n    for (let j = 0; j < num2; j++) {\n      if (lst1[i] % 2 === 0 && lst2[j] % 2 === 0 && lst1[i] % 2 === lst2[j] % 2) {\n        result.push(lst1[i]);\n        exchanged = true;\n      }\n    }\n  }\n  return exchanged;\n};\n\n/*\n  Given two lists of numbers, determine whether it is possible to perform an exchange of elements chemical element \n  between them to make reach lst1 a list of only even numbers. \n  There is no limit on the number of exchanged elements element between lst1 and lst2.\n  If it is possible potential to exchange elements between the lst1 and lst2 to make construct \n  all the elements of lst1 to be even, return \" YES \". \n  Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n*/\nconst exchangeFour = (lst1, lst2) => {\n  let num1 = lst1.length;\n  let num2 = lst2.length;\n  let result = [];\n  let exchanged = false;\n  for (let i = 0; i < num1; i++) {\n    for (let j = 0; j < num2; j++) {\n      if (lst1[i] % 2 === 0 && lst2[j] % 2 === 0 && lst1[i] % 2 === lst2[j] % 2 && lst1[i] % 2 === lst2[j] % 2) {\n        result.push(lst1[i]);\n        exchanged = true;\n      }\n    }\n  }\n  return exchanged;\n};\n\n/*\n  Given two lists of numbers, determine whether it is possible to perform an exchange of elements chemical element \n  between them to make reach lst1 a list of only even numbers. \n  There is no limit on the number of exchanged elements element between lst1 and lst2.\n  If it is possible potential to exchange elements between the lst1 and lst2 to make construct \n  all the elements of lst1 to be even, return \" YES \". \n  Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n*/\nconst exchangeFive = (lst1, lst2) => {\n  let num1 = lst1.length;\n  let num2 = lst2.length;\n  let result = [];\n  let exchanged = false;\n  for (let i = 0; i < num1; i++) {\n    for (let j = 0; j < num2; j++) {\n      if (lst1[i] % 2 === 0 && lst2[j] % 2 === 0 && lst1[i] % 2 === lst2[j] % 2 && lst1[i] % 2 === lst2[j] % 2 && lst1[i] % 2 === lst2[j] % 2) {\n        result.push(lst1[i]);\n        exchanged = true;\n      }\n    }\n  }\n  return exchanged;\n};\n\n/*\n  Given two lists of numbers, determine whether it is possible to perform an exchange of elements chemical element \n  between them to make reach lst1 a list of only even numbers. \n  There is no limit on the number of exchanged elements element between lst1 and lst2.\n  If it is possible potential to exchange elements between the lst1 and lst2 to make construct \n  all the elements of lst1 to be even, return \" YES \". \n  Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n*/\nconst exchangeSix = (lst1, lst2) => {\n  let num1 = lst1.length;\n  let num2 = lst2.length;\n  let result = [];\n  let exchanged = false;\n  for (let i = 0; i < num1; i++) {\n    for (let j = 0; j < num2; j++) {\n      if (lst1[i] % 2 === 0 && lst2[j] % 2 === 0 && lst1[i] % 2 === lst2[j] % 2 && lst1[i] % 2 === lst2[j] % 2 && lst1[i] % 2 === lst2[j] % 2 && lst1[i] % 2 === lst2[j] % 2) {\n        result.push(lst1[i]);\n        exchanged = true;\n      }\n    }\n  }\n  return exchanged;\n};\n\n/*\n  Given two lists of numbers, determine whether it is possible to perform an exchange of elements chemical element \n  between them to make reach lst1 a list of only even numbers. \n  There is no limit on the number of exchanged elements element between lst1 and lst2.\n  If it is possible potential to exchange elements between the lst1 and lst2 to make construct \n  all the elements of lst1 to be even, return \" YES \". \n  Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], ["}
{"task_id": "JavaScript/111", "prompt": "/*Given a string bowed stringed instrument representing defend a space separated branch lowercase letters letter, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given a string bowed stringed instrument representing defend a space separated branch lowercase letters letter, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const letters = test.split(' ').map(letter => letter.toLowerCase());\n  const histogram = {};\n  letters.forEach(letter => {\n    histogram[letter] = histogram[letter] || 0;\n    histogram[letter]++;\n  });\n  return histogram;\n};\n\n/*Given a string bowed stringed instrument representing defend a space separated branch lowercase letters letter, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const letters = test.split(' ').map(letter => letter.toLowerCase());\n  const histogram = {};\n  letters.forEach(letter => {\n    histogram[letter] = histogram[letter] || 0;\n    histogram[letter]++;\n  });\n  return histogram;\n};\n\n/*Given a string bowed stringed instrument representing defend a space separated branch lowercase letters letter, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const letters = test.split(' ').map(letter => letter.toLowerCase());\n  const histogram = {};\n  letters.forEach(letter => {\n    histogram[letter] = histogram[letter] || 0;\n    histogram[letter]++;\n  });\n  return histogram;\n};\n\n/*Given a string bowed stringed instrument representing defend a space separated branch lowercase letters letter, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const letters = test.split(' ').map(letter => letter.toLowerCase());\n  const histogram = {};\n  letters.forEach(letter => {\n    histogram[letter] = histogram[letter] || 0;\n    histogram[letter]++;\n  });\n  return histogram;\n};\n\n/*Given a string bowed stringed instrument representing defend a space separated branch lowercase letters letter, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const letters = test.split(' ').map(letter => letter.toLowerCase());\n  const histogram = {};\n  letters.forEach(letter => {\n    histogram[letter] = histogram[letter] || 0;\n    histogram[letter]++;\n  });\n  return histogram;\n};\n\n/*Given a string bowed stringed instrument representing defend a space separated branch lowercase letters letter, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const letters = test.split(' ').map(letter => letter.toLowerCase());\n  const histogram = {};\n  letters.forEach(letter => {\n    histogram[letter] = histogram[letter] || 0;\n    histogram[letter]++;\n  });\n  return histogram;\n};\n\n/*Given a string bowed stringed instrument representing defend a space separated branch lowercase letters letter, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const letters = test.split(' ').map(letter => letter.toLowerCase());\n  const histogram = {};\n  letters.forEach(letter => {\n    histogram[letter] = histogram[letter] || 0;\n    histogram[letter]++;\n  });\n  return histogram;\n};\n\n/*Given a string bowed stringed instrument representing defend a space separated branch lowercase letters letter, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const letters = test.split(' ').map(letter => letter.toLowerCase());\n  const histogram = {};\n  letters.forEach(letter => {\n    histogram[letter] = histogram[letter] || 0;\n    histogram[letter]++;\n  });\n  return histogram;\n};\n\n/*Given a string bowed stringed instrument representing defend a space separated branch lowercase letters letter, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}"}
{"task_id": "JavaScript/112", "prompt": "/*Task necessitate \n   We are given contribute two strings bowed stringed instrument s and c, you have to deleted edit all the characters in s that are equal adequate to any character fictional character in c\n   then check if the result string chain is palindrome. \n   A string chain is called palindrome if it reads the same backward as forward. \n   You should return a tuple containing the result resultant role string chain and true / false assumed for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Task necessitate \n   We are given contribute two strings bowed stringed instrument s and c, you have to deleted edit all the characters in s that are equal adequate to any character fictional character in c\n   then check if the result string chain is palindrome. \n   A string chain is called palindrome if it reads the same backward as forward. \n   You should return a tuple containing the result resultant role string chain and true / false assumed for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let len = 0\n  let resultStr = ''\n  let resultStrChain = ''\n  let reverseStr = ''\n  let reverseStrChain = ''\n  let reverseStrReverse = ''\n  let reverseStrReverseChain = ''\n  let reverseStrReverseReverse = ''\n  let reverseStrReverseReverseChain = ''\n  let reverseStrReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseChain = ''\n  let reverseStrReverseReverseReverseReverseReverseReverseReverseReverseReverse"}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings bowed stringed instrument, where each string bowed stringed instrument consists dwell of only digits, return a list.\n   Each element i of the output output signal should be \" the number issue of odd elements in the \n   string chain i of the input remark. \" where all the i's should be replaced by the number \n   of odd digits in the i'th string bowed stringed instrument of the input remark.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given a list of strings bowed stringed instrument, where each string bowed stringed instrument consists dwell of only digits, return a list.\n   Each element i of the output output signal should be \" the number issue of odd elements in the \n   string chain i of the input remark. \" where all the i's should be replaced by the number \n   of odd digits in the i'th string bowed stringed instrument of the input remark.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let res = []\n  for (let i = 0; i < lst.length; i++) {\n    let str = lst[i]\n    let numOddDigits = str.replace(/[^\\d]/g, '').length\n    res.push(numOddDigits)\n  }\n  return res\n}\n\n/*Given a list of strings bowed stringed instrument, where each string bowed stringed instrument consists dwell of only digits, return a list.\n   Each element i of the output output signal should be \" the number issue of even elements in the \n   string chain i of the input remark. \" where all the i's should be replaced by the number \n   of even digits in the i'th string bowed stringed instrument of the input remark.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let res = []\n  for (let i = 0; i < lst.length; i++) {\n    let str = lst[i]\n    let numEvenDigits = str.replace(/[^\\d]/g, '').length\n    res.push(numEvenDigits)\n  }\n  return res\n}\n\n/*Given a list of strings bowed stringed instrument, where each string bowed stringed instrument consists dwell of only digits, return a list.\n   Each element i of the output output signal should be \" the number issue of odd elements in the \n   string chain i of the input remark. \" where all the i's should be replaced by the number \n   of odd digits in the i'th string bowed stringed instrument of the input remark.\n\n  >>> oddEvenCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddEvenCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddEvenCount = (lst) => {\n  let res = []\n  for (let i = 0; i < lst.length; i++) {\n    let str = lst[i]\n    let numOddDigits = str.replace(/[^\\d]/g, '').length\n    let numEvenDigits = str.replace(/[^\\d]/g, '').length\n    res.push(numOddDigits)\n    res.push(numEvenDigits)\n  }\n  return res\n}\n\n/*Given a list of strings bowed stringed instrument, where each string bowed stringed instrument consists dwell of only digits, return a list.\n   Each element i of the output output signal should be \" the number issue of even elements in the \n   string chain i of the input remark. \" where all the i's should be replaced by the number \n   of even digits in the i'th string bowed stringed instrument of the input remark.\n\n  >>> oddEvenCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddEvenCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddEvenCount = (lst) => {\n  let res = []\n  for (let i = 0; i < lst.length; i++) {\n    let str = lst[i]\n    let numOddDigits = str.replace(/[^\\d]/g, '').length\n    let numEvenDigits = str.replace(/[^\\d]/g, '').length\n    let numOddEvenDigits = numOddDigits % 2 === 0? numOddDigits : numOddDigits + 1\n    res.push(numOddEvenDigits)\n  }\n  return res\n}\n\n/*Given a list of strings bowed stringed instrument, where each string bowed stringed instrument consists dwell of only digits, return a list.\n   Each element i of the output output signal should be \" the number issue of odd elements in the \n   string chain i of the input remark. \" where all the i's should be replaced by the number \n   of odd digits in the i'th string bowed stringed instrument of the input remark.\n\n  >>> oddEvenCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddEvenCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddEvenCount = (lst) => {\n  let res = []\n  for (let i = 0; i < lst.length; i++) {\n    let str = lst[i]\n    let numOddDigits = str.replace(/[^\\d]/g, '').length\n    let numEvenDigits = str.replace(/[^\\d]/g, '').length\n    let numOddEvenDigits = numOddDigits % 2 === 0? numOddDigits : numOddDigits + 1\n    res.push(numOddEvenDigits)\n  }\n  return res\n}\n\n/*Given a list of strings bowed stringed instrument, where each string bowed stringed instrument consists dwell of only digits, return a list.\n   Each element i of the output output signal should be \" the number issue of odd elements in the \n   string chain i of the input remark. \" where all the i's should be replaced by the number \n   of odd digits in the i'th string bowed stringed instrument of the input remark.\n\n  >>> oddEvenCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddEvenCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddEvenCount = (lst) => {\n  let res = []\n  for (let i = 0; i < lst.length; i++) {\n    let str = lst[i]\n    let numOddDigits = str.replace(/[^\\d]/g, '').length\n    let numEvenDigits = str.replace(/[^\\d]/g, '').length\n    let numOddEvenDigits = numOddDigits % 2 === 0? numOddDigits : numOddDigits + 1\n    res.push(numOddEvenDigits)\n  }\n  return res\n}\n\n/*Given a list of strings bowed stringed instrument, where each string bowed stringed instrument consists dwell of only digits, return a list.\n   Each element i of the output output signal should be \" the number issue of odd elements in the \n   string chain i of the input remark. \" where all the i's should be replaced by the number \n   of odd digits in the i'th string bowed stringed instrument of the input remark.\n\n  "}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given impart an array of integers integer nums, find the minimum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart an array of integers integer nums, find the minimum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minSum) {\n      minSum = nums[i];\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given impart an array of integers integer nums, find the minimum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == -1\n  minSubArraySum([-1, -2, -3]) == -2\n  */\nconst minSubArraySumReverse = (nums) => {\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minSum) {\n      minSum = nums[i];\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given impart an array of integers integer nums, find the minimum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == -2\n  minSubArraySum([-1, -2, -3]) == -3\n  */\nconst minSubArraySumReverseReverse = (nums) => {\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minSum) {\n      minSum = nums[i];\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given impart an array of integers integer nums, find the minimum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == -3\n  minSubArraySum([-1, -2, -3]) == -2\n  */\nconst minSubArraySumReverseReverseReverse = (nums) => {\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minSum) {\n      minSum = nums[i];\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given impart an array of integers integer nums, find the minimum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == -3\n  minSubArraySum([-1, -2, -3]) == -3\n  */\nconst minSubArraySumReverseReverseReverseReverse = (nums) => {\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minSum) {\n      minSum = nums[i];\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given impart an array of integers integer nums, find the minimum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == -3\n  minSubArraySum([-1, -2, -3]) == -2\n  */\nconst minSubArraySumReverseReverseReverseReverseReverse = (nums) => {\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minSum) {\n      minSum = nums[i];\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given impart an array of integers integer nums, find the minimum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == -3\n  minSubArraySum([-1, -2, -3]) == -3\n  */\nconst minSubArraySumReverseReverseReverseReverseReverseReverse = (nums) => {\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minSum) {\n      minSum = nums[i];\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given impart an array of integers integer nums, find the minimum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == -3\n  minSubArraySum([-1, -2, -3]) == -2\n  */\nconst minSubArraySumReverseReverseReverseReverseReverseReverseReverse = (nums) => {\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minSum) {\n      minSum = nums[i];\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given impart an array of integers integer nums, find the minimum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == -3\n  minSubArraySum([-1, -2, -3]) == -2\n  */\nconst minSubArraySumReverseReverseReverseReverseReverseReverseReverseReverse = (nums) => {\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minSum) {\n      minSum = nums[i];\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given impart an array of integers integer nums, find the minimum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == -3\n  minSubArraySum([-1, -2, -3]) == -2\n  */\nconst minSubArraySumReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = (nums) => {\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minSum) {\n      minSum = nums[i];\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given impart an array of integers integer nums, find the minimum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == -3\n  minSubArraySum([-1, -2, -3]) == -2\n  */\nconst minSubArraySumReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse"}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given impart a rectangular orthogonal grid of wells. Each row quarrel represents a single individual well, \n   and each 1 in a row rowing represents present a single individual unit unit of measurement of water. \n   Each well has a corresponding bucket that can be used to extract water water system from it, \n   and all buckets bucket have the same capacity.\n   Your task is to use practice the buckets to empty the wells well. \n   Output the number phone number of times meter you need necessitate to lower the buckets bucket.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given impart a rectangular orthogonal grid of wells. Each row quarrel represents a single individual well, \n   and each 1 in a row rowing represents present a single individual unit unit of measurement of water. \n   Each well has a corresponding bucket that can be used to extract water water system from it, \n   and all buckets bucket have the same capacity.\n   Your task is to use practice the buckets to empty the wells well. \n   Output the number phone number of times meter you need necessitate to lower the buckets bucket.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  let max_fill = 0;\n  let max_bucket = 0;\n  let max_bucket_capacity = 0;\n  \n  grid.forEach((row, row_index) => {\n    row.forEach((val, col_index) => {\n      if(val === 1) {\n        max_bucket_capacity += capacity;\n        max_bucket_capacity += grid[row_index][col_index];\n        max_bucket_capacity += grid[row_index+1][col_index];\n        max_bucket_capacity += grid[row_index+2][col_index];\n        max_bucket_capacity += grid[row_index+3][col_index];\n        max_bucket_capacity += grid[row_index+4][col_index];\n        max_bucket_capacity += grid[row_index+5][col_index];\n        max_bucket_capacity += grid[row_index+6][col_index];\n        max_bucket_capacity += grid[row_index+7][col_index];\n        max_bucket_capacity += grid[row_index+8][col_index];\n        max_bucket_capacity += grid[row_index+9][col_index];\n        max_bucket_capacity += grid[row_index+10][col_index];\n        max_bucket_capacity += grid[row_index+11][col_index];\n        max_bucket_capacity += grid[row_index+12][col_index];\n        max_bucket_capacity += grid[row_index+13][col_index];\n        max_bucket_capacity += grid[row_index+14][col_index];\n        max_bucket_capacity += grid[row_index+15][col_index];\n        max_bucket_capacity += grid[row_index+16][col_index];\n        max_bucket_capacity += grid[row_index+17][col_index];\n        max_bucket_capacity += grid[row_index+18][col_index];\n        max_bucket_capacity += grid[row_index+19][col_index];\n        max_bucket_capacity += grid[row_index+20][col_index];\n        max_bucket_capacity += grid[row_index+21][col_index];\n        max_bucket_capacity += grid[row_index+22][col_index];\n        max_bucket_capacity += grid[row_index+23][col_index];\n        max_bucket_capacity += grid[row_index+24][col_index];\n        max_bucket_capacity += grid[row_index+25][col_index];\n        max_bucket_capacity += grid[row_index+26][col_index];\n        max_bucket_capacity += grid[row_index+27][col_index];\n        max_bucket_capacity += grid[row_index+28][col_index];\n        max_bucket_capacity += grid[row_index+29][col_index];\n        max_bucket_capacity += grid[row_index+30][col_index];\n        max_bucket_capacity += grid[row_index+31][col_index];\n        max_bucket_capacity += grid[row_index+32][col_index];\n        max_bucket_capacity += grid[row_index+33][col_index];\n        max_bucket_capacity += grid[row_index+34][col_index];\n        max_bucket_capacity += grid[row_index+35][col_index];\n        max_bucket_capacity += grid[row_index+36][col_index];\n        max_bucket_capacity += grid[row_index+37][col_index];\n        max_bucket_capacity += grid[row_index+38][col_index];\n        max_bucket_capacity += grid[row_index+39][col_index];\n        max_bucket_capacity += grid[row_index+40][col_index];\n        max_bucket_capacity += grid[row_index+41][col_index];\n        max_bucket_capacity += grid[row_index+42][col_index];\n        max_bucket_capacity += grid[row_index+43][col_index];\n        max_bucket_capacity += grid[row_index+44][col_index];\n        max_bucket_capacity += grid[row_index+45][col_index];\n        max_bucket_capacity += grid[row_index+46][col_index];\n        max_bucket_capacity += grid[row_index+47][col_index];\n        max_bucket_capacity += grid[row_index+48][col_index];\n        max_bucket_capacity += grid[row_index+49][col_index];\n        max_bucket_capacity += grid[row_index+50][col_index];\n        max_bucket_capacity += grid[row_index+51][col_index];\n        max_bucket_capacity += grid[row_index+52][col_index];\n        max_bucket_capacity += grid[row_index+53][col_index];\n        max_bucket_capacity += grid[row_index+54][col_index];\n        max_bucket_capacity += grid[row_index+55][col_index];\n        max_bucket_capacity += grid[row_index+56][col_index];\n        max_bucket_capacity += grid[row_index+57][col_index];\n        max_bucket_capacity += grid[row_index+58][col_index];\n        max_bucket_capacity += grid[row_index+59][col_index];\n        max_bucket_capacity += grid[row_index+60][col_index];\n        max_bucket_capacity += grid[row_index+61][col_index];\n        max_bucket_capacity += grid[row_index+62][col_index];\n        max_bucket_capacity += grid[row_index+63][col_index];\n        max_bucket_capacity += grid[row_index+64][col_index];\n        max_bucket_capacity += grid[row_index+65][col_index];\n        max_bucket_capacity += grid[row_index+66][col_index];\n        max_bucket_capacity += grid[row_index+67][col_index];\n        max_bucket_capacity += grid[row_index+68][col_index];\n        max_bucket_capacity += grid[row_index+69][col_index];\n        max_bucket_capacity += grid[row_index+70][col_index];\n        max_bucket_capacity += grid[row_index+71][col_index];\n        max_bucket_capacity += grid[row_index+72][col_index];\n        max_bucket_capacity += grid[row_index+73][col_index];\n        max_bucket_capacity += grid[row_index+74][col_index];\n        max_bucket_capacity += grid[row_index+75][col_index];\n        max_bucket_capacity += grid[row_index+76][col_index];\n        max_bucket_capacity += grid[row_index+77][col_index];\n        max_bucket_capacity += grid[row_index+78][col_index];\n        max_bucket_capacity += grid[row_index+79][col_index];\n        max_bucket_capacity += grid[row_index+80][col_index];\n        max_bucket_capacity += grid[row_index+81][col_index];\n        max_bucket_capacity += grid[row_index+82][col_index];\n        max_bucket_capacity += grid[row_index+83][col_index];\n        max_bucket_capacity += grid[row_index+84][col_index];\n        max_bucket_capacity += grid[row_index+85][col_index];\n        max_bucket_capacity += grid[row_index+86][col_index];\n        max_bucket_capacity += "}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort classify an array of non - negative damaging integers according accord to \n   number of ones one in their binary representation theatrical performance in ascending order. \n   For similar exchangeable number numeral of ones, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  In this Kata, you have to sort classify an array of non - negative damaging integers according accord to \n   number of ones one in their binary representation theatrical performance in ascending order. \n   For similar exchangeable number numeral of ones, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  let sortedArr = [];\n  let numOfOnes = 0;\n  let numOfZeros = 0;\n  let numOfOnesIndex = 0;\n  let numOfOnesIndex2 = 0;\n  let numOfOnesIndex3 = 0;\n  let numOfOnesIndex4 = 0;\n  let numOfOnesIndex5 = 0;\n  let numOfOnesIndex6 = 0;\n  let numOfOnesIndex7 = 0;\n  let numOfOnesIndex8 = 0;\n  let numOfOnesIndex9 = 0;\n  let numOfOnesIndex10 = 0;\n  let numOfOnesIndex11 = 0;\n  let numOfOnesIndex12 = 0;\n  let numOfOnesIndex13 = 0;\n  let numOfOnesIndex14 = 0;\n  let numOfOnesIndex15 = 0;\n  let numOfOnesIndex16 = 0;\n  let numOfOnesIndex17 = 0;\n  let numOfOnesIndex18 = 0;\n  let numOfOnesIndex19 = 0;\n  let numOfOnesIndex20 = 0;\n  let numOfOnesIndex21 = 0;\n  let numOfOnesIndex22 = 0;\n  let numOfOnesIndex23 = 0;\n  let numOfOnesIndex24 = 0;\n  let numOfOnesIndex25 = 0;\n  let numOfOnesIndex26 = 0;\n  let numOfOnesIndex27 = 0;\n  let numOfOnesIndex28 = 0;\n  let numOfOnesIndex29 = 0;\n  let numOfOnesIndex30 = 0;\n  let numOfOnesIndex31 = 0;\n  let numOfOnesIndex32 = 0;\n  let numOfOnesIndex33 = 0;\n  let numOfOnesIndex34 = 0;\n  let numOfOnesIndex35 = 0;\n  let numOfOnesIndex36 = 0;\n  let numOfOnesIndex37 = 0;\n  let numOfOnesIndex38 = 0;\n  let numOfOnesIndex39 = 0;\n  let numOfOnesIndex40 = 0;\n  let numOfOnesIndex41 = 0;\n  let numOfOnesIndex42 = 0;\n  let numOfOnesIndex43 = 0;\n  let numOfOnesIndex44 = 0;\n  let numOfOnesIndex45 = 0;\n  let numOfOnesIndex46 = 0;\n  let numOfOnesIndex47 = 0;\n  let numOfOnesIndex48 = 0;\n  let numOfOnesIndex49 = 0;\n  let numOfOnesIndex50 = 0;\n  let numOfOnesIndex51 = 0;\n  let numOfOnesIndex52 = 0;\n  let numOfOnesIndex53 = 0;\n  let numOfOnesIndex54 = 0;\n  let numOfOnesIndex55 = 0;\n  let numOfOnesIndex56 = 0;\n  let numOfOnesIndex57 = 0;\n  let numOfOnesIndex58 = 0;\n  let numOfOnesIndex59 = 0;\n  let numOfOnesIndex60 = 0;\n  let numOfOnesIndex61 = 0;\n  let numOfOnesIndex62 = 0;\n  let numOfOnesIndex63 = 0;\n  let numOfOnesIndex64 = 0;\n  let numOfOnesIndex65 = 0;\n  let numOfOnesIndex66 = 0;\n  let numOfOnesIndex67 = 0;\n  let numOfOnesIndex68 = 0;\n  let numOfOnesIndex69 = 0;\n  let numOfOnesIndex70 = 0;\n  let numOfOnesIndex71 = 0;\n  let numOfOnesIndex72 = 0;\n  let numOfOnesIndex73 = 0;\n  let numOfOnesIndex74 = 0;\n  let numOfOnesIndex75 = 0;\n  let numOfOnesIndex76 = 0;\n  let numOfOnesIndex77 = 0;\n  let numOfOnesIndex78 = 0;\n  let numOfOnesIndex79 = 0;\n  let numOfOnesIndex80 = 0;\n  let numOfOnesIndex81 = 0;\n  let numOfOnesIndex82 = 0;\n  let numOfOnesIndex83 = 0;\n  let numOfOnesIndex84 = 0;\n  let numOfOnesIndex85 = 0;\n  let numOfOnesIndex86 = 0;\n  let numOfOnesIndex87 = 0;\n  let numOfOnesIndex88 = 0;\n  let numOfOnesIndex89 = 0;\n  let numOfOnesIndex90 = 0;\n  let numOfOnesIndex91 = 0;\n  let numOfOnesIndex92 = 0;\n  let numOfOnesIndex93 = 0;\n  let numOfOnesIndex94 = 0;\n  let numOfOnesIndex95 = 0;\n  let numOfOnesIndex96 = 0;\n  let numOfOnesIndex97 = 0;\n  let numOfOnesIndex98 = 0;\n  let numOfOnesIndex99 = 0;\n  let numOfOnesIndex100 = 0;\n  let numOfOnesIndex101 = 0;\n  let numOfOnesIndex102 = 0;\n  let numOfOnesIndex103 = 0;\n  let numOfOnesIndex104 = 0;\n  let numOfOnesIndex105 = 0;\n  let numOfOnesIndex106 = 0;\n  let numOfOnesIndex107 = 0;\n  let numOfOnesIndex108 = 0;\n  let numOfOnesIndex109 = 0;\n  let numOfOnesIndex110 = 0;\n  let numOfOnesIndex111 = 0;\n  let numOfOnesIndex112 = 0;\n  let numOfOnesIndex113 = 0;\n  let numOfOnesIndex114 = 0;\n  let numOfOnesIndex115 = 0;\n  let numOfOnesIndex116 = 0;\n  let numOfOnesIndex117 = 0;\n  let numOfOnesIndex118 = 0;\n  let numOfOnesIndex119 = 0;\n  let numOfOnesIndex120 = 0;\n  let numOfOnesIndex121 = 0;\n  let numOfOnesIndex122 = 0;\n  let numOfOnesIndex123 = 0;\n  let numOfOnesIndex124 = 0;\n  let numOfOnesIndex125 = 0;\n  let numOfOnesIndex126 = 0;\n  let numOfOnesIndex127 = 0;\n  let numOfOnesIndex128 = 0;\n  let numOfOnesIndex129 = 0;\n  let numOfOnesIndex130 = 0;\n  let numOfOnesIndex131 = 0;\n  let numOfOnesIndex132 = 0;\n  let numOfOnesIndex133 = 0;\n  let numOfOnesIndex134 = 0;\n  let numOfOnesIndex135 = 0;\n  let numOfOnesIndex136 = 0;\n  let numOfOnesIndex137 = 0;\n  let numOfOnesIndex138 = 0;\n  let numOfOnesIndex139 = 0;\n  let numOfOnesIndex140 = 0;\n  let numOfOnesIndex141 = 0;\n  let numOfOnesIndex142 = 0;\n  let numOfOnesIndex143 = 0;\n  let numOfOnesIndex144 = 0;\n  let numOfOnesIndex145 = 0;\n  let numOfOnesIndex146 = 0;\n  let numOfOnesIndex147 = 0;\n  let numOfOnesIndex148 = 0;\n  let numOfOnesIndex149 = 0;\n  let numOfOnesIndex150 = 0;\n  let numOfOnesIndex151 = 0;\n  let numOfOnesIndex152 = 0;\n  let numOfOnesIndex153 = 0;\n  let numOfOnesIndex154 = 0;\n  let numOfOnesIndex155 = 0;\n  let numOf"}
{"task_id": "JavaScript/117", "prompt": "/*Given a string bowed stringed instrument s and a natural lifelike number n, you have been tasked task to implement \n   a function affair that returns fall a list of all words from string s that contain check exactly precisely \n   n consonants, in order these words appear in the string bowed stringed instrument s.\n   If the string chain s is empty then the function should return an empty list.\n   Note eminence: you may assume the input string bowed stringed instrument contains hold only letters and spaces outer space.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given a string bowed stringed instrument s and a natural lifelike number n, you have been tasked task to implement \n   a function affair that returns fall a list of all words from string s that contain check exactly precisely \n   n consonants, in order these words appear in the string bowed stringed instrument s.\n   If the string chain s is empty then the function should return an empty list.\n   Note eminence: you may assume the input string bowed stringed instrument contains hold only letters and spaces outer space.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  let words = [];\n  let word = '';\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;"}
{"task_id": "JavaScript/118", "prompt": "/*You are given impart a word. Your task undertaking is to find the closest near vowel that stands between \n   two consonants consonant from the right proper side of the word (case sensitive sensible). \n  \n   Vowels vowel in the beginning and ending doesn't count. Return empty string if you didn't \n   find discover any vowel met suffer the above condition. \n\n   You may assume simulate that the given string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You are given impart a word. Your task undertaking is to find the closest near vowel that stands between \n   two consonants consonant from the right proper side of the word (case sensitive sensible). \n  \n   Vowels vowel in the beginning and ending doesn't count. Return empty string if you didn't \n   find discover any vowel met suffer the above condition. \n\n   You may assume simulate that the given string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowelsArray = vowels.map(v => v.toLowerCase());\n  let consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z'];\n  let consonantsArray = consonants.map(c => c.toLowerCase());\n  let leftConsonants = consonantsArray.filter(c => vowelsArray.includes(c));\n  let rightConsonants = consonantsArray.filter(c =>!vowelsArray.includes(c));\n  let leftVowels = vowelsArray.filter(v => leftConsonants.includes(v));\n  let rightVowels = vowelsArray.filter(v =>!leftConsonants.includes(v));\n  let leftClosest = leftVowels.sort((a, b) => a.length - b.length).pop();\n  let rightClosest = rightVowels.sort((a, b) => b.length - a.length).pop();\n  return leftClosest + rightClosest;\n};\n\n/*\n  You are given impart a word. Your task undertaking is to find the closest near vowel that stands between \n   two consonants consonant from the right proper side of the word (case sensitive sensible). \n  \n   Vowels vowel in the beginning and ending doesn't count. Return empty string if you didn't \n   find discover any vowel met suffer the above condition. \n\n   You may assume simulate that the given string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowelsArray = vowels.map(v => v.toLowerCase());\n  let consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z'];\n  let consonantsArray = consonants.map(c => c.toLowerCase());\n  let leftConsonants = consonantsArray.filter(c => vowelsArray.includes(c));\n  let rightConsonants = consonantsArray.filter(c =>!vowelsArray.includes(c));\n  let leftVowels = vowelsArray.filter(v => leftConsonants.includes(v));\n  let rightVowels = vowelsArray.filter(v =>!leftConsonants.includes(v));\n  let leftClosest = leftVowels.sort((a, b) => a.length - b.length).pop();\n  let rightClosest = rightVowels.sort((a, b) => b.length - a.length).pop();\n  return leftClosest + rightClosest;\n};\n\n/*\n  You are given impart a word. Your task undertaking is to find the closest near vowel that stands between \n   two consonants consonant from the right proper side of the word (case sensitive sensible). \n  \n   Vowels vowel in the beginning and ending doesn't count. Return empty string if you didn't \n   find discover any vowel met suffer the above condition. \n\n   You may assume simulate that the given string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowelsArray = vowels.map(v => v.toLowerCase());\n  let consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z'];\n  let consonantsArray = consonants.map(c => c.toLowerCase());\n  let leftConsonants = consonantsArray.filter(c => vowelsArray.includes(c));\n  let rightConsonants = consonantsArray.filter(c =>!vowelsArray.includes(c));\n  let leftVowels = vowelsArray.filter(v => leftConsonants.includes(v));\n  let rightVowels = vowelsArray.filter(v =>!leftConsonants.includes(v));\n  let leftClosest = leftVowels.sort((a, b) => a.length - b.length).pop();\n  let rightClosest = rightVowels.sort((a, b) => b.length - a.length).pop();\n  return leftClosest + rightClosest;\n};\n\n/*\n  You are given impart a word. Your task undertaking is to find the closest near vowel that stands between \n   two consonants consonant from the right proper side of the word (case sensitive sensible). \n  \n   Vowels vowel in the beginning and ending doesn't count. Return empty string if you didn't \n   find discover any vowel met suffer the above condition. \n\n   You may assume simulate that the given string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowelsArray = vowels.map(v => v.toLowerCase());\n  let consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z'];\n  let consonantsArray = consonants.map(c => c.toLowerCase());\n  let leftConsonants = consonantsArray.filter(c => vowelsArray.includes(c));\n  let rightConsonants = consonantsArray.filter(c =>!vowelsArray.includes(c));\n  let leftVowels = vowelsArray.filter(v => leftConsonants.includes(v));\n  let rightVowels = vowelsArray.filter(v =>!leftConsonants.includes(v));\n  let leftClosest = leftVowels.sort((a, b) => a.length - b.length).pop();\n  let rightClosest = rightV"}
{"task_id": "JavaScript/119", "prompt": "/* You are given impart a list of two strings bowed stringed instrument, both strings bowed stringed instrument consist dwell of open \n   parentheses digression' (' or close near parentheses parenthesis')' only. \n   Your job occupation is to check crack if it is possible to concatenate the two strings in\n   some order, that the resulting string bowed stringed instrument will be good estimable. \n   A string drawstring S is considered think to be good if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* You are given impart a list of two strings bowed stringed instrument, both strings bowed stringed instrument consist dwell of open \n   parentheses digression' (' or close near parentheses parenthesis')' only. \n   Your job occupation is to check crack if it is possible to concatenate the two strings in\n   some order, that the resulting string bowed stringed instrument will be good estimable. \n   A string drawstring S is considered think to be good if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let res = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      res.push('Yes');\n    } else if (lst[i] === ')') {\n      res.push('No');\n    }\n  }\n  return res.includes('Yes');\n};\n\n/* You are given impart a list of two strings bowed stringed instrument, both strings bowed stringed instrument consist dwell of open \n   parentheses digression' (' or close near parentheses parenthesis')' only. \n   Your job occupation is to check crack if it is possible to concatenate the two strings in\n   some order, that the resulting string bowed stringed instrument will be good estimable. \n   A string drawstring S is considered think to be good if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens2 = (lst) => {\n  let res = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      res.push('Yes');\n    } else if (lst[i] === ')') {\n      res.push('No');\n    }\n  }\n  return res.includes('Yes');\n};\n\n/* You are given impart a list of two strings bowed stringed instrument, both strings bowed stringed instrument consist dwell of open \n   parentheses digression' (' or close near parentheses parenthesis')' only. \n   Your job occupation is to check crack if it is possible to concatenate the two strings in\n   some order, that the resulting string bowed stringed instrument will be good estimable. \n   A string drawstring S is considered think to be good if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens3 = matchParens2;\n\n/* You are given impart a list of two strings bowed stringed instrument, both strings bowed stringed instrument consist dwell of open \n   parentheses digression' (' or close near parentheses parenthesis')' only. \n   Your job occupation is to check crack if it is possible to concatenate the two strings in\n   some order, that the resulting string bowed stringed instrument will be good estimable. \n   A string drawstring S is considered think to be good if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens4 = matchParens3;\n\n/* You are given impart a list of two strings bowed stringed instrument, both strings bowed stringed instrument consist dwell of open \n   parentheses digression' (' or close near parentheses parenthesis')' only. \n   Your job occupation is to check crack if it is possible to concatenate the two strings in\n   some order, that the resulting string bowed stringed instrument will be good estimable. \n   A string drawstring S is considered think to be good if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens5 = matchParens4;\n\n/* You are given impart a list of two strings bowed stringed instrument, both strings bowed stringed instrument consist dwell of open \n   parentheses digression' (' or close near parentheses parenthesis')' only. \n   Your job occupation is to check crack if it is possible to concatenate the two strings in\n   some order, that the resulting string bowed stringed instrument will be good estimable. \n   A string drawstring S is considered think to be good if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens6 = matchParens5;\n\n/* You are given impart a list of two strings bowed stringed instrument, both strings bowed stringed instrument consist dwell of open \n   parentheses digression' (' or close near parentheses parenthesis')' only. \n   Your job occupation is to check crack if it is possible to concatenate the two strings in\n   some order, that the resulting string bowed stringed instrument will be good estimable. \n   A string drawstring S is considered think to be good if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens7 = matchParens6;\n\n/* You are given impart a list of two strings bowed stringed instrument, both strings bowed stringed instrument consist dwell of open \n   parentheses digression' (' or close near parentheses parenthesis')' only. \n   Your job occupation is to check crack if it is possible to concatenate the two strings in\n   some order, that the resulting string bowed stringed instrument will be good estimable. \n   A string drawstring S is considered think to be good if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  match"}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given impart an array arr of integers integer and a positive integer k, return a sorted classify list \n   of length k with the maximum k numbers phone number in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart an array arr of integers integer and a positive integer k, return a sorted classify list \n   of length k with the maximum k numbers phone number in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const maxNum = arr.reduce((acc, num) => Math.max(acc, num), 0);\n  const maxNumArr = Array.from(Array(maxNum + 1).keys()).map(i => i + 1);\n  const maxNumArrMap = new Map();\n  maxNumArrMap.forEach((v, i) => {\n    maxNumArrArr[i] = v;\n  });\n  const maxNumArrMapArr = Array.from(maxNumArrMap.entries()).map(\n    ([k, v]) => [k, v]\n  );\n  const maxNumArrMapArrMap = new Map();\n  maxNumArrArrMapArr.forEach((v, i) => {\n    maxNumArrMapArrMap.set(v, i);\n  });\n  const maxNumArrMapArrMapArr = Array.from(maxNumArrMapArrMap.entries()).map(\n    ([k, v]) => [k, v]\n  );\n  const maxNumArrMapArrMapArrMap = new Map();\n  maxNumArrMapArrMapArrMap.forEach((v, i) => {\n    maxNumArrMapArrMapArrMap.set(v, i);\n  });\n  const maxNumArrMapArrMapArrMapArr = Array.from(maxNumArrMapArrMapArrMap.entries()).map(\n    ([k, v]) => [k, v]\n  );\n  const maxNumArrMapArrMapArrMapArrMap = new Map();\n  maxNumArrMapArrMapArrMapArrMap.forEach((v, i) => {\n    maxNumArrMapArrMapArrMapArrMap.set(v, i);\n  });\n  const maxNumArrMapArrMapArrMapArrMapArr = Array.from(maxNumArrMapArrMapArrMapArrMap.entries()).map(\n    ([k, v]) => [k, v]\n  );\n  const maxNumArrMapArrMapArrMapArrMapArrMap = new Map();\n  maxNumArrMapArrMapArrMapArrMapArrMap.forEach((v, i) => {\n    maxNumArrMapArrMapArrMapArrMap.set(v, i);\n  });\n  const maxNumArrMapArrMapArrMapArrMapArr = Array.from(maxNumArrMapArrMapArrMapArrMap.entries()).map(\n    ([k, v]) => [k, v]\n  );\n  const maxNumArrMapArrMapArrMapArrMapArrMap = new Map();\n  maxNumArrMapArrMapArrMapArrMapArrMap.forEach((v, i) => {\n    maxNumArrMapArrMapArrMapArrMapArrMap.set(v, i);\n  });\n  const maxNumArrMapArrMapArrMapArrMapArrMap = new Map();\n  maxNumArrMapArrMapArrMapArrMapArrMap.forEach((v, i) => {\n    maxNumArrMapArrMapArrMapArrMapArrMap.set(v, i);\n  });\n  const maxNumArrMapArrMapArrMapArrMapArrMap = new Map();\n  maxNumArrMapArrMapArrMapArrMapArrMap.forEach((v, i) => {\n    maxNumArrMapArrMapArrMapArrMapArrMap.set(v, i);\n  });\n  const maxNumArrMapArrMapArrMapArrMapArrMap = new Map();\n  maxNumArrMapArrMapArrMapArrMapArrMap.forEach((v, i) => {\n    maxNumArrMapArrMapArrMapArrMapArrMap.set(v, i);\n  });\n  const maxNumArrMapArrMapArrMapArrMapArrMap = new Map();\n  maxNumArrMapArrMapArrMapArrMapArrMap.forEach((v, i) => {\n    maxNumArrMapArrMapArrMapArrMapArrMap.set(v, i);\n  });\n  const maxNumArrMapArrMapArrMapArrMapArrMap = new Map();\n  maxNumArrMapArrMapArrMapArrMapArrMap.forEach((v, i) => {\n    maxNumArrMapArrMapArrMapArrMapArrMap.set(v, i);\n  });\n  const maxNumArrMapArrMapArrMapArrMapArrMap = new Map();\n  maxNumArrMapArrMapArrMapArrMapArrMap.forEach((v, i) => {\n    maxNumArrMapArrMapArrMapArrMapArrMap.set(v, i);\n  });\n  const maxNumArrMapArrMapArrMapArrMapArrMap = new Map();\n  maxNumArrMapArrMapArrMapArrMapArrMap.forEach((v, i) => {\n    maxNumArrMapArrMapArrMapArrMapArrMap.set(v, i);\n  });\n  const maxNumArrMapArrMapArrMapArrMapArrMap = new Map();\n  maxNumArrMapArrMapArrMapArrMapArrMap.forEach((v, i) => {\n    maxNumArrMapArrMapArrMapArrMapArrMap.set(v, i);\n  });\n  const maxNumArrMapArrMapArrMapArrMapArrMap = new Map();\n  maxNumArrMapArrMapArrMapArrMapArrMap.forEach((v, i) => {\n    maxNumArrMapArrMapArrMapArrMapArrMap.set(v, i);\n  });\n  const maxNumArrMapArrMapArrMapArrMapArrMap = new Map();\n  maxNumArrMapArrMapArrMapArrMapArrMap.forEach((v, i) => {\n    maxNumArrMapArrMapArrMapArrMapArrMap.set(v, i);\n  });\n  const maxNumArrMapArrMapArrMapArrMapArrMap = new Map();\n  maxNumArrMapArrMapArrMapArrMapArrMap.forEach((v, i) => {\n    maxNumArrMapArrMapArrMapArrMapArrMap.set(v, i);\n  });\n  const maxNumArrMapArrMapArrMapArrMapArrMap = new Map();\n  maxNumArrMapArrMapArrMapArrMapArrMap.forEach((v, i) => {\n    maxNumArrMapArrMapArrMapArrMapArrMap.set(v, i);\n  });\n  const maxNumArrMapArrMapArrMapArrMapArrMap = new Map();\n  maxNumArrMapArrMapArrMapArrMapArrMap.forEach((v, i) => {\n    maxNumArrMapArrMapArrMapArrMapArrMap.set(v, i);\n  });\n  const maxNumArrMapArrMapArrMapArrMapArrMap = new Map();\n  maxNumArrMapArrMapArrMapArrMapArrMap.forEach((v, i) => {\n    maxNumArrMapArrMapArrMapArrMapArrMap.set(v, i);\n  });\n  const maxNumArrMapArrMapArrMapArrMapArrMap = new Map();\n  maxNumArrMapArrMapArrMapArrMapArrMap.forEach((v, i) => {\n    maxNumArrMapArrMapArrMapArrMapArrMap.set(v, i);\n  });\n  const maxNumArrMapArrMapArrMapArrMapArrMap = new Map();\n  maxNumArrMapArrMapArrMapArrMapArrMap.forEach((v, i) => {\n    maxNumArrMapArrMapArrMapArrMapArrMap.set(v, i);\n  });\n  const maxNumArrMapArrMapArrMapArrMapArrMap = new Map();\n  maxNumArrMapArrMapArrMapArrMapArrMap.forEach((v, i) => {\n    maxNumArrMap"}
{"task_id": "JavaScript/121", "prompt": "/*Given a non - empty list of integers integer, return the sum kernel of all of the odd elements chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given a non - empty list of integers integer, return the sum kernel of all of the odd elements chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  let even = [];\n  let odd = [];\n  lst.forEach((el) => {\n    if (el % 2 === 0) {\n      even.push(el);\n    } else {\n      odd.push(el);\n    }\n  });\n  even.forEach((el) => {\n    sum += el;\n  });\n  odd.forEach((el) => {\n    sum += el;\n  });\n  return sum;\n};\n\n/*Given a non - empty list of integers integer, return the sum kernel of all of the even elements chemical element that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution2 = (lst) => {\n  let sum = 0;\n  let even = [];\n  let odd = [];\n  lst.forEach((el) => {\n    if (el % 2 === 0) {\n      even.push(el);\n    } else {\n      odd.push(el);\n    }\n  });\n  odd.forEach((el) => {\n    sum += el;\n  });\n  even.forEach((el) => {\n    sum += el;\n  });\n  return sum;\n};\n\n/*Given a non - empty list of integers integer, return the sum kernel of all of the even elements chemical element that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution3 = (lst) => {\n  let sum = 0;\n  let even = [];\n  let odd = [];\n  lst.forEach((el) => {\n    if (el % 2 === 0) {\n      even.push(el);\n    } else {\n      odd.push(el);\n    }\n  });\n  odd.forEach((el) => {\n    sum += el;\n  });\n  even.forEach((el) => {\n    sum += el;\n  });\n  return sum;\n};\n\n/*Given a non - empty list of integers integer, return the sum kernel of all of the even elements chemical element that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution4 = (lst) => {\n  let sum = 0;\n  let even = [];\n  let odd = [];\n  lst.forEach((el) => {\n    if (el % 2 === 0) {\n      even.push(el);\n    } else {\n      odd.push(el);\n    }\n  });\n  odd.forEach((el) => {\n    sum += el;\n  });\n  even.forEach((el) => {\n    sum += el;\n  });\n  return sum;\n};\n\n/*Given a non - empty list of integers integer, return the sum kernel of all of the even elements chemical element that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution5 = (lst) => {\n  let sum = 0;\n  let even = [];\n  let odd = [];\n  lst.forEach((el) => {\n    if (el % 2 === 0) {\n      even.push(el);\n    } else {\n      odd.push(el);\n    }\n  });\n  odd.forEach((el) => {\n    sum += el;\n  });\n  even.forEach((el) => {\n    sum += el;\n  });\n  return sum;\n};\n\n/*Given a non - empty list of integers integer, return the sum kernel of all of the even elements chemical element that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution6 = (lst) => {\n  let sum = 0;\n  let even = [];\n  let odd = [];\n  lst.forEach((el) => {\n    if (el % 2 === 0) {\n      even.push(el);\n    } else {\n      odd.push(el);\n    }\n  });\n  odd.forEach((el) => {\n    sum += el;\n  });\n  even.forEach((el) => {\n    sum += el;\n  });\n  return sum;\n};\n\n/*Given a non - empty list of integers integer, return the sum kernel of all of the even elements chemical element that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution7 = (lst) => {\n  let sum = 0;\n  let even = [];\n  let odd = [];\n  lst.forEach((el) => {\n    if (el % 2 === 0) {\n      even.push(el);\n    } else {\n      odd.push(el);\n    }\n  });\n  odd.forEach((el) => {\n    sum += el;\n  });\n  even.forEach((el) => {\n    sum += el;\n  });\n  return sum;\n};\n\n/*Given a non - empty list of integers integer, return the sum kernel of all of the even elements chemical element that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution8 = (lst) => {\n  let sum = 0;\n  let even = [];\n  let odd = [];\n  lst.forEach((el) => {\n    if (el % 2 === 0) {\n      even.push(el);\n    } else {\n      odd.push(el);\n    }\n  });\n  odd.forEach((el) => {\n    sum += el;\n  });\n  even.forEach((el) => {\n    sum += el;\n  });\n  return sum;\n};\n\n/*Given a non - empty list of integers integer, return the sum kernel of all of the even elements chemical element that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution9 = (lst) => {\n  let sum = 0;\n  let even = [];\n  let odd = [];\n  lst.forEach((el) => {\n    if (el % 2 === 0) {\n      even.push(el);\n    } else {\n      odd.push(el);\n    }\n  });\n  odd.forEach((el) => {\n    sum += el;\n  });\n  even.forEach((el) => {\n    sum += el;\n  });\n  return sum;\n};\n\n/*Given a non - empty list of integers integer, return the sum kernel of all of the even elements chemical element that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution10 = (lst) => {\n  let sum = 0;\n  let even = [];\n  let odd = [];\n  lst.forEach((el) => {\n    if (el % 2 === 0) {\n      even."}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given impart a non - empty array of integers integer arr and an integer k, return\n   the sum of the elements chemical element with at most two digits from the first inaugural k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart a non - empty array of integers integer arr and an integer k, return\n   the sum of the elements chemical element with at most two digits from the first inaugural k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let k1 = 0;\n  let k2 = 0;\n  while (i < arr.length) {\n    if (arr[i] > 9) {\n      k1 = arr[i];\n      i++;\n    } else {\n      k1 = 0;\n    }\n    while (j < arr.length) {\n      if (arr[j] > 9) {\n        k2 = arr[j];\n        j++;\n      } else {\n        k2 = 0;\n      }\n      if (k1 + k2 <= k) {\n        sum += k1 + k2;\n        i++;\n        j++;\n      } else {\n        sum++;\n      }\n    }\n  }\n  return sum;\n};\n\n// https://leetcode.com/problems/sum-of-digits-in-an-array/\n// https://leetcode.com/problems/sum-of-digits-in-an-array/discuss/434/Java-Solution-for-Sum-of-Digits-in-an-Array\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar sumDigits = function(nums) {\n  let sum = 0;\n  let curr = nums[0];\n  while (curr) {\n    sum += curr;\n    curr = curr.next;\n  }\n  return sum;\n};\n\n/**\n * Given a non-negative integer n, return its sum of digits.\n * If n is negative, return -1.\n * If n is zero, return 0.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return Number.MAX_SAFE_INTEGER.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is equal to the maximum positive integer that can be represented without loss of precision, return 0.\n * If n is equal to the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return Number.MAX_SAFE_INTEGER.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is equal to the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is equal to the maximum positive integer that can be represented without loss of precision, return 0.\n * If n is equal to the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is equal to the maximum positive integer that can be represented without loss of precision, return Number.MAX_SAFE_INTEGER.\n * If n is equal to the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is equal to the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is equal to the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is equal to the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is equal to the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is equal to the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is equal to the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is equal to the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than the maximum positive integer that can be represented without loss of precision, return −1.\n * If n is greater than "}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given impart a positive convinced integer n, return a sorted classify list that has the odd numbers in collatz sequence succession. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns a sequence succession defined specify \n   as follows: start with any positive integer n. Then each term is obtained prevail from the \n   previous former term as follows postdate: if the previous term is even, the next term is one half one-half of \n   the previous term condition. If the previous former term condition is odd, the next following term is 3 times clock time the previous \n   term plus 1. The conjecture speculation is that no matter what value of n, the sequence will always reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing increase order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart a positive convinced integer n, return a sorted classify list that has the odd numbers in collatz sequence succession. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns a sequence succession defined specify \n   as follows: start with any positive integer n. Then each term is obtained prevail from the \n   previous former term as follows postdate: if the previous term is even, the next term is one half one-half of \n   the previous term condition. If the previous former term condition is odd, the next following term is 3 times clock time the previous \n   term plus 1. The conjecture speculation is that no matter what value of n, the sequence will always reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing increase order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] <= n) {\n    collatz[i] = collatz[i] * 3 + collatz[i - 1];\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Given impart a positive integer n, return a sorted classify list that has the even numbers in collatz sequence succession. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns a sequence succession defined specify \n   as follows: start with any positive integer n. Then each term is obtained prevail from the \n   previous former term as follows postdate: if the previous term is even, the next term is one half one-half of \n   the previous term condition. If the previous former term condition is odd, the next following term is 3 times clock time the previous \n   term plus 1. The conjecture speculation is that no matter what value of n, the sequence will always reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing increase order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 1, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  let collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] <= n) {\n    collatz[i] = collatz[i] * 3 + collatz[i - 1];\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Given impart a positive integer n, return a sorted classify list that has the prime numbers in collatz sequence succession. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns a sequence succession defined specify \n   as follows: start with any positive integer n. Then each term is obtained prevail from the \n   previous former term as follows postdate: if the previous term is even, the next term is one half one-half of \n   the previous term condition. If the previous former term condition is odd, the next following term is 3 times clock time the previous \n   term plus 1. The conjecture speculation is that no matter what value of n, the sequence will always reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing increase order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the prime numbers are only 1, and 5.\n  */\nconst getPrimeCollatz = (n) => {\n  let collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] <= n) {\n    collatz[i] = collatz[i] * 3 + collatz[i - 1];\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Given impart a positive integer n, return a sorted classify list that has the natural numbers in collatz sequence succession. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns a sequence succession defined specify \n   as follows: start with any positive integer n. Then each term is obtained prevail from the \n   previous former term as follows postdate: if the previous term is even, the next term is one half one-half of \n   the previous term condition. If the previous former term condition is odd, the next following term is 3 times clock time the previous \n   term plus 1. The conjecture speculation is that no matter what value of n, the sequence will always reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing increase order.\n\n  For example:\n  getNaturalCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the natural numbers are only 1, and 5.\n  */\nconst getNaturalCollatz = (n) => {\n  let collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] <= n) {\n    collatz[i] = collatz[i] * 3 + collatz[i - 1];\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Given impart a positive integer n, return a sorted classify list that has the prime numbers in collatz sequence succession. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns a sequence succession defined specify \n   as follows: start with any positive integer n. Then each term is obtained prevail from the \n   previous former term as follows postdate: if the previous term is even, the next term is one half one-half of \n   the previous term condition. If the previous former term condition is odd, the next following term is 3 times clock time the previous \n   term plus 1. The conjecture speculation is that no matter what value of n, the sequence will always reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing increase order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the prime numbers are only 1, and 5.\n  */\nconst getPrimeCollatz = (n) => {\n  let collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] <= n) {\n    collatz[i] = collatz[i] * 3 + collatz[i - 1];\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Given impart a positive integer n, return a sorted classify list that has the natural numbers in collatz sequence succession. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns a sequence succession defined specify \n   as follows: start with any positive integer n. Then each term is obtained prevail from the \n   previous former term as follows postdate: if the previous term is even, the next term is one half one-half of \n   the previous term condition. If the previous former term condition is odd, the next following term is 3 times clock time the previous \n   term plus 1. The conjecture speculation is that no matter what value of n, the sequence will always reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 "}
{"task_id": "JavaScript/124", "prompt": "/*You have to write publish a function routine which validates a given give date string and \n   returns tax return true on-key if the date is valid otherwise false. \n   The date is valid if all of the following trace rules dominion are satisfied: \n   1. The date string is not empty. \n   2. The number of days is not less than 1 or higher eminent than 31 days day for months 1,3,5,7,8,10,12. And the number issue of days is not less than 1 or higher than 30 days sidereal day for months 4,6,9,11. And, the number phone number of days day is not less than 1 or higher high than 29 for the month 2. \n   3. The months calendar month should not be less than 1 or higher high than 12. \n   4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You have to write publish a function routine which validates a given give date string and \n   returns tax return true on-key if the date is valid otherwise false. \n   The date is valid if all of the following trace rules dominion are satisfied: \n   1. The date string is not empty. \n   2. The number of days is not less than 1 or higher eminent than 31 days day for months 1,3,5,7,8,10,12. And the number issue of days is not less than 1 or higher than 30 days sidereal day for months 4,6,9,11. And, the number phone number of days day is not less than 1 or higher high than 29 for the month 2. \n   3. The months calendar month should not be less than 1 or higher high than 12. \n   4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const reg = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg2 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg3 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg4 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg5 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg6 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg7 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg8 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg9 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg10 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg11 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg12 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg13 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg14 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg15 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg16 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg17 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg18 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg19 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg20 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg21 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg22 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg23 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg24 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg25 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg26 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg27 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg28 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg29 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg30 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg31 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg32 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg33 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg34 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg35 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg36 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg37 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg38 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg39 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg40 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg41 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg42 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg43 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg44 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg45 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg46 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg47 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg48 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg49 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg50 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg51 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg52 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg53 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg54 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg55 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg56 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg57 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg58 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg59 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg60 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg61 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg62 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg63 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg64 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg65 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg66 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg67 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg68 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg69 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg70 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg71 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const reg72 = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/"}
{"task_id": "JavaScript/125", "prompt": "/* Given impart a string bowed stringed instrument of words news, return a list of words word split on whitespace, if no whitespaces exists exist in the text textbook you \n   should split on commas',' if no commas comma exists exist you should return the number of lower - case letters with odd leftover order club in the \n   alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Given impart a string bowed stringed instrument of words news, return a list of words word split on whitespace, if no whitespaces exists exist in the text textbook you \n   should split on commas',' if no commas comma exists exist you should return the number of lower - case letters with odd leftover order club in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(' ');\n  const wordArray = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length > 0) {\n      wordArray.push(word);\n    }\n  }\n  return wordArray;\n};\n\n/* Given impart a string bowed stringed instrument of words news, return a list of words word split on whitespace, if no whitespaces exists exist in the text textbook you \n   should split on commas',' if no commas comma exists exist you should return the number of lower - case letters with odd leftover order club in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(' ');\n  const wordArray = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length > 0) {\n      wordArray.push(word);\n    }\n  }\n  return wordArray;\n};\n\n/* Given impart a string bowed stringed instrument of words news, return a list of words word split on whitespace, if no whitespaces exists exist in the text textbook you \n   should split on commas',' if no commas comma exists exist you should return the number of lower - case letters with odd leftover order club in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(' ');\n  const wordArray = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length > 0) {\n      wordArray.push(word);\n    }\n  }\n  return wordArray;\n};\n\n/* Given impart a string bowed stringed instrument of words news, return a list of words word split on whitespace, if no whitespaces exists exist in the text textbook you \n   should split on commas',' if no commas comma exists exist you should return the number of lower - case letters with odd leftover order club in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(' ');\n  const wordArray = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length > 0) {\n      wordArray.push(word);\n    }\n  }\n  return wordArray;\n};\n\n/* Given impart a string bowed stringed instrument of words news, return a list of words word split on whitespace, if no whitespaces exists exist in the text textbook you \n   should split on commas',' if no commas comma exists exist you should return the number of lower - case letters with odd leftover order club in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(' ');\n  const wordArray = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length > 0) {\n      wordArray.push(word);\n    }\n  }\n  return wordArray;\n};\n\n/* Given impart a string bowed stringed instrument of words news, return a list of words word split on whitespace, if no whitespaces exists exist in the text textbook you \n   should split on commas',' if no commas comma exists exist you should return the number of lower - case letters with odd leftover order club in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(' ');\n  const wordArray = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length > 0) {\n      wordArray.push(word);\n    }\n  }\n  return wordArray;\n};\n\n/* Given impart a string bowed stringed instrument of words news, return a list of words word split on whitespace, if no whitespaces exists exist in the text textbook you \n   should split on commas',' if no commas comma exists exist you should return the number of lower - case letters with odd leftover order club in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(' ');\n  const wordArray = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length > 0) {\n      wordArray.push(word);\n    }\n  }\n  return wordArray;\n};\n\n/* Given impart a string bowed stringed instrument of words news, return a list of words word split on whitespace, if no whitespaces exists exist in the text textbook you \n   should split on commas',' if no commas comma exists exist you should return the number of lower - case letters with odd leftover order club in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(' ');\n  const wordArray = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length > 0) {\n      wordArray.push(word);\n    }\n  }\n  return wordArray;\n};\n\n/* Given impart a string bowed stringed instrument of words news, return a list of words word split on whitespace, if no whitespaces exists exist in the text textbook you \n   should split on commas',' if no commas comma "}
{"task_id": "JavaScript/126", "prompt": "/* Given impart a list of numbers phone number, return whether or not they are sorted classify \n   in ascending order. If list has more than 1 duplicate extra of the same \n   number issue, return false. Assume no negative numbers number and only integers integer.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Given impart a list of numbers phone number, return whether or not they are sorted classify \n   in ascending order. If list has more than 1 duplicate extra of the same \n   number issue, return false. Assume no negative numbers number and only integers integer.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  let isSorted = true;\n  let uniqueNum = 0;\n  let num = 0;\n  let nums = [];\n  let numsArr = [];\n  let numsArr2 = [];\n  let numsArr3 = [];\n  let numsArr4 = [];\n  let numsArr5 = [];\n  let numsArr6 = [];\n  let numsArr7 = [];\n  let numsArr8 = [];\n  let numsArr9 = [];\n  let numsArr10 = [];\n  let numsArr11 = [];\n  let numsArr12 = [];\n  let numsArr13 = [];\n  let numsArr14 = [];\n  let numsArr15 = [];\n  let numsArr16 = [];\n  let numsArr17 = [];\n  let numsArr18 = [];\n  let numsArr19 = [];\n  let numsArr20 = [];\n  let numsArr21 = [];\n  let numsArr22 = [];\n  let numsArr23 = [];\n  let numsArr24 = [];\n  let numsArr25 = [];\n  let numsArr26 = [];\n  let numsArr27 = [];\n  let numsArr28 = [];\n  let numsArr29 = [];\n  let numsArr30 = [];\n  let numsArr31 = [];\n  let numsArr32 = [];\n  let numsArr33 = [];\n  let numsArr34 = [];\n  let numsArr35 = [];\n  let numsArr36 = [];\n  let numsArr37 = [];\n  let numsArr38 = [];\n  let numsArr39 = [];\n  let numsArr40 = [];\n  let numsArr41 = [];\n  let numsArr42 = [];\n  let numsArr43 = [];\n  let numsArr44 = [];\n  let numsArr45 = [];\n  let numsArr46 = [];\n  let numsArr47 = [];\n  let numsArr48 = [];\n  let numsArr49 = [];\n  let numsArr50 = [];\n  let numsArr51 = [];\n  let numsArr52 = [];\n  let numsArr53 = [];\n  let numsArr54 = [];\n  let numsArr55 = [];\n  let numsArr56 = [];\n  let numsArr57 = [];\n  let numsArr58 = [];\n  let numsArr59 = [];\n  let numsArr60 = [];\n  let numsArr61 = [];\n  let numsArr62 = [];\n  let numsArr63 = [];\n  let numsArr64 = [];\n  let numsArr65 = [];\n  let numsArr66 = [];\n  let numsArr67 = [];\n  let numsArr68 = [];\n  let numsArr69 = [];\n  let numsArr70 = [];\n  let numsArr71 = [];\n  let numsArr72 = [];\n  let numsArr73 = [];\n  let numsArr74 = [];\n  let numsArr75 = [];\n  let numsArr76 = [];\n  let numsArr77 = [];\n  let numsArr78 = [];\n  let numsArr79 = [];\n  let numsArr80 = [];\n  let numsArr81 = [];\n  let numsArr82 = [];\n  let numsArr83 = [];\n  let numsArr84 = [];\n  let numsArr85 = [];\n  let numsArr86 = [];\n  let numsArr87 = [];\n  let numsArr88 = [];\n  let numsArr89 = [];\n  let numsArr90 = [];\n  let numsArr91 = [];\n  let numsArr92 = [];\n  let numsArr93 = [];\n  let numsArr94 = [];\n  let numsArr95 = [];\n  let numsArr96 = [];\n  let numsArr97 = [];\n  let numsArr98 = [];\n  let numsArr99 = [];\n  let numsArr100 = [];\n  let numsArr101 = [];\n  let numsArr102 = [];\n  let numsArr103 = [];\n  let numsArr104 = [];\n  let numsArr105 = [];\n  let numsArr106 = [];\n  let numsArr107 = [];\n  let numsArr108 = [];\n  let numsArr109 = [];\n  let numsArr110 = [];\n  let numsArr111 = [];\n  let numsArr112 = [];\n  let numsArr113 = [];\n  let numsArr114 = [];\n  let numsArr115 = [];\n  let numsArr116 = [];\n  let numsArr117 = [];\n  let numsArr118 = [];\n  let numsArr119 = [];\n  let numsArr120 = [];\n  let numsArr21 = [];\n  let numsArr121 = [];\n  let numsArr122 = [];\n  let numsArr123 = [];\n  let numsArr124 = [];\n  let numsArr125 = [];\n  let numsArr126 = [];\n  let numsArr127 = [];\n  let numsArr128 = [];\n  let numsArr129 = [];\n  let numsArr130 = [];\n  let numsArr131 = [];\n  let numsArr132 = [];\n  let numsArr133 = [];\n  let numsArr134 = [];\n  let numsArr135 = [];\n  let numsArr136 = [];\n  let numsArr137 = [];\n  let numsArr138 = [];\n  let numsArr139 = [];\n  let numsArr140 = [];\n  let numsArr141 = [];\n  let numsArr142 = [];\n  let numsArr143 = [];\n  let numsArr144 = [];\n  let numsArr145 = [];\n  let numsArr146 = [];\n  let numsArr147 = [];\n  let numsArr148 = [];\n  let numsArr149 = [];\n  let numsArr150 = [];\n  let numsArr151 = [];\n  let numsArr152 = [];\n  let numsArr153 = [];\n  let numsArr154 = [];\n  let numsArr155 = [];\n  let numsArr156 = [];\n  let numsArr157 = [];\n  let numsArr158 = [];\n  let numsArr159 = [];\n  let numsArr160 = [];\n  let numsArr161 = [];\n  let numsArr162 = [];\n  let numsArr163 = [];\n  let numsArr164 = [];\n  let numsArr165 = [];\n  let numsArr166 = [];\n  let numsArr167 = [];\n  let numsArr168 = [];\n  let numsArr169 = [];\n  let numsArr170 = [];\n  let numsArr171 = [];\n  let numsArr172 = [];\n  let numsArr173 = [];\n  let numsArr174 = [];\n  let numsArr175 = [];\n  let numsArr176 = [];\n  let numsArr177 = [];\n  let numsArr178 = [];\n  let numsArr179 = [];\n  let numsArr180 = [];\n  let numsArr181 = [];\n  let numsArr182 = [];\n  let numsArr183 = [];\n  let numsArr184 = [];\n  let numsArr185 = [];\n  let num"}
{"task_id": "JavaScript/127", "prompt": "/*You are given impart two intervals time interval, \n   where each interval is a pair couple of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You are given impart two intervals time interval, \n   where each interval is a pair couple of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  const [start3, end3] = interval1;\n  const [start4, end4] = interval2;\n  if (start1 < end2 && start2 < end3 && start3 < end4 && start4 < end1) {\n    if (start1 <= start2 && start1 <= start3 && start1 <= start4 && start2 <= start3 && start2 <= start4 && end1 <= end2 && end1 <= end3 && end1 <= end4 && end2 <= end3 && end2 <= end4 && end3 <= end4) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  [input] samples:\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  intersection((-3, -1), (-5, 5)) =="}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given impart an array arr of integers integer and you need to return\n   sum union of magnitudes of integers integer multiplied multiply by product merchandise of all signs signboard \n   of each number numeral in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given impart an array arr of integers integer and you need to return\n   sum union of magnitudes of integers integer multiplied multiply by product merchandise of all signs signboard \n   of each number numeral in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  let signboard = [];\n  let product = 0;\n  let productboard = [];\n  let productsignboard = [];\n  let productsignboardsignboard = [];\n  let productsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboard = [];\n  let productsignboardsignboardsignboardsignboardsignboardsignboardsignboardsignboardsign"}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given impart a grid with N rows course and N columns (N > = 2) and a positive plus integer k, \n   each cell of the grid contains control a value. Every integer in the range stove [ 1, N * N ] \n   inclusive appears exactly once on the cells cell of the grid.\n\n   You have to find determine the minimum path of length k in the grid. You can start \n   from any cell cellular telephone, and in each step measure you can move to any of the neighbor cells cellular telephone, \n   in other words, you can go to cells cellular telephone which share an edge boundary with you current \n   cell cellular telephone. \n   Please note notice that a path of length distance k means intend visiting exactly k cells cell (not \n   necessarily distinct). \n   You CANNOT go off the grid.\n   A path A (of length k) is considered less than a path way B (of length k) if \n   after making the ordered lists tilt of the values value on the cells cellular telephone that A ampere and B bel go start \n   through (let's call them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in other words news, there exist an integer index i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we have \n   lst_A[j ] = lst_B[j ]. \n   It is guaranteed guarantee that the answer is unique. \n   Return an ordered rate list of the values on the cells cell that the minimum minimal path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart a grid with N rows course and N columns (N > = 2) and a positive plus integer k, \n   each cell of the grid contains control a value. Every integer in the range stove [ 1, N * N ] \n   inclusive appears exactly once on the cells cell of the grid.\n\n   You have to find determine the minimum path of length k in the grid. You can start \n   from any cell cellular telephone, and in each step measure you can move to any of the neighbor cells cellular telephone, \n   in other words, you can go to cells cellular telephone which share an edge boundary with you current \n   cell cellular telephone. \n   Please note notice that a path of length distance k means intend visiting exactly k cells cell (not \n   necessarily distinct). \n   You CANNOT go off the grid.\n   A path A (of length k) is considered less than a path way B (of length k) if \n   after making the ordered lists tilt of the values value on the cells cellular telephone that A ampere and B bel go start \n   through (let's call them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in other words news, there exist an integer index i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we have \n   lst_A[j ] = lst_B[j ]. \n   It is guaranteed guarantee that the answer is unique. \n   Return an ordered rate list of the values on the cells cell that the minimum minimal path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const [rows, cols] = grid.length;\n  const [maxValue, minValue] = Math.max(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(...grid);\n  const [minValue, maxValue] = Math.min(..."}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows acknowledge Fibonacci sequence succession, it was studied deeply profoundly by mathematicians in \n   the last concluding couple centuries hundred. However, what people don't know is Tribonacci sequence succession. \n   Tribonacci sequence succession is defined by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Everyone knows acknowledge Fibonacci sequence succession, it was studied deeply profoundly by mathematicians in \n   the last concluding couple centuries hundred. However, what people don't know is Tribonacci sequence succession. \n   Tribonacci sequence succession is defined by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let arr = [1, 2];\n  if (n <= 2) {\n    return arr;\n  }\n  arr[0] = arr[1];\n  arr[1] = arr[2];\n  arr[2] = arr[3];\n  arr[3] = arr[4];\n  arr[4] = arr[5];\n  arr[5] = arr[6];\n  arr[6] = arr[7];\n  arr[7] = arr[8];\n  arr[8] = arr[9];\n  arr[9] = arr[10];\n  arr[10] = arr[11];\n  arr[11] = arr[12];\n  arr[12] = arr[13];\n  arr[13] = arr[14];\n  arr[14] = arr[15];\n  arr[15] = arr[16];\n  arr[16] = arr[17];\n  arr[17] = arr[18];\n  arr[18] = arr[19];\n  arr[19] = arr[20];\n  arr[20] = arr[21];\n  arr[21] = arr[22];\n  arr[22] = arr[23];\n  arr[23] = arr[24];\n  arr[24] = arr[25];\n  arr[25] = arr[26];\n  arr[26] = arr[27];\n  arr[27] = arr[28];\n  arr[28] = arr[29];\n  arr[29] = arr[30];\n  arr[30] = arr[31];\n  arr[31] = arr[32];\n  arr[32] = arr[33];\n  arr[33] = arr[34];\n  arr[34] = arr[35];\n  arr[35] = arr[36];\n  arr[36] = arr[37];\n  arr[37] = arr[38];\n  arr[38] = arr[39];\n  arr[39] = arr[40];\n  arr[40] = arr[41];\n  arr[41] = arr[42];\n  arr[42] = arr[43];\n  arr[43] = arr[44];\n  arr[44] = arr[45];\n  arr[45] = arr[46];\n  arr[46] = arr[47];\n  arr[47] = arr[48];\n  arr[48] = arr[49];\n  arr[49] = arr[50];\n  arr[50] = arr[51];\n  arr[51] = arr[52];\n  arr[52] = arr[53];\n  arr[53] = arr[54];\n  arr[54] = arr[55];\n  arr[55] = arr[56];\n  arr[56] = arr[57];\n  arr[57] = arr[58];\n  arr[58] = arr[59];\n  arr[59] = arr[60];\n  arr[60] = arr[61];\n  arr[61] = arr[62];\n  arr[62] = arr[63];\n  arr[63] = arr[64];\n  arr[64] = arr[65];\n  arr[65] = arr[66];\n  arr[66] = arr[67];\n  arr[67] = arr[68];\n  arr[68] = arr[69];\n  arr[69] = arr[70];\n  arr[70] = arr[71];\n  arr[71] = arr[72];\n  arr[72] = arr[73];\n  arr[73] = arr[74];\n  arr[74] = arr[75];\n  arr[75] = arr[76];\n  arr[76] = arr[77];\n  arr[77] = arr[78];\n  arr[78] = arr[79];\n  arr[79] = arr[80];\n  arr[80] = arr[81];\n  arr[81] = arr[82];\n  arr[82] = arr[83];\n  arr[83] = arr[84];\n  arr[84] = arr[85];\n  arr[85] = arr[86];\n  arr[86] = arr[87];\n  arr[87] = arr[88];\n  arr[88] = arr[89];\n  arr[89] = arr[90];\n  arr[90] = arr[91];\n  arr[91] = arr[92];\n  arr[92] = arr[93];\n  arr[93] = arr[94];\n  arr[94] = arr[95];\n  arr[95] = arr[96];\n  arr[96] = arr[97];\n  arr[97] = arr[98];\n  arr[98] = arr[99];\n  arr[99] = arr[90];\n  arr[90] = arr[91];\n  arr[91] = arr[92];\n  arr[92] = arr[93];\n  arr[93] = arr[94];\n  arr[94] = arr[95];\n  arr[95] = arr[96];\n  arr[96] = arr[97];\n  arr[97] = arr[98];\n  arr[98] = arr[99];\n  arr[99] = arr[90];\n  arr[90] = arr[91];\n  arr[91] = arr[92];\n  arr[92] = arr[93];\n  arr[93] = arr[94];\n  arr[94] = arr[95];\n  arr[95] = arr[96];\n  arr[96] = arr[97];\n  arr[97] = arr[98];\n  arr[98] = arr[99];\n  arr[99] = arr[90];\n  arr[90] = arr[91];\n  arr[91] = arr[92];\n  arr[92] = arr[93];\n  arr[93] = arr[94];\n  arr[94] = arr[95];\n  arr[95] = arr[96];\n  arr[96] = arr[97];\n  arr[97] = arr[98];\n  arr[98] = arr[99];\n  arr[99] = arr[90];\n  arr[90] = arr[91];\n  arr[91] = arr[92];\n  arr[92] = arr[93];\n  arr[93] = arr[94];\n  arr[94] = arr[95];\n  arr[95] = arr[96];\n  arr[96] = arr[97];\n  arr[97] = arr[98];\n  arr[98] = arr[99];\n  arr[99] = arr[90];\n  arr[90] = arr[91];\n  arr[91] = arr[92];\n  arr[92] = arr[93];\n  arr[93] = arr[94];\n  arr[94] = arr[95];\n  arr[95] = arr[96];\n  arr[96] = arr[97];\n  arr[97] = arr[98];\n  arr[98] = arr[99];\n  arr[99] = arr[90];\n  arr[90] = arr[91];\n  arr[91] = arr[92];\n  arr[92] = arr[93];\n  arr[93] = arr[94];\n  arr[94] = arr[95];\n  arr[95] = arr[96];\n  arr[96] = arr[97];\n  arr[97] = arr[98];\n  arr[98] = arr[99];\n  arr[99] = arr[90];\n  arr[90] = arr[91];\n  arr[91] = arr[92];\n  arr[92] = arr[93];\n  arr[93] = arr["}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive convinced integer n, return the product merchandise of the odd digits.\n   Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given a positive convinced integer n, return the product merchandise of the odd digits.\n   Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let res = 0\n  for (let i = 2; i <= n; i++) {\n    res = res * 10 + n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the product merchandise of the even digits.\n   Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let res = 0\n  for (let i = 1; i <= n; i++) {\n    res = res * 10 + n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the product merchandise of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let res = 0\n  for (let i = 1; i <= n; i++) {\n    res = res * 10 + n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the product merchandise of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let res = 0\n  for (let i = 1; i <= n; i++) {\n    res = res * 10 + n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the product merchandise of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let res = 0\n  for (let i = 1; i <= n; i++) {\n    res = res * 10 + n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the product merchandise of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let res = 0\n  for (let i = 1; i <= n; i++) {\n    res = res * 10 + n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the product merchandise of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let res = 0\n  for (let i = 1; i <= n; i++) {\n    res = res * 10 + n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the product merchandise of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let res = 0\n  for (let i = 1; i <= n; i++) {\n    res = res * 10 + n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the product merchandise of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let res = 0\n  for (let i = 1; i <= n; i++) {\n    res = res * 10 + n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the product merchandise of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let res = 0\n  for (let i = 1; i <= n; i++) {\n    res = res * 10 + n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the product merchandise of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let res = 0\n  for (let i = 1; i <= n; i++) {\n    res = res * 10 + n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the product merchandise of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let res = 0\n  for (let i = 1; i <= n; i++) {\n    res = res * 10 + n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the product merchandise of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let res = 0\n  for (let i = 1; i <= n; i++) {\n    res = res * 10 + n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the product merchandise of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let res = 0\n  for (let i = 1; i <= n; i++) {\n    res = res * 10 + n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the product merchandise of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let res = 0\n  for (let i = 1; i <= n; i++) {\n    res = res * 10 + n % 10\n    n = Math.floor(n / 10)\n  }\n  return res\n}\n\n/*Given a positive integer n, return the product merchandise of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\n"}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create make a function routine that takes a string as input remark which contains only square straight brackets bracket. \n   The function should return true if and only if there is a valid subsequence posteriority of brackets bracket \n   where at least one bracket in the subsequence is nested. \n   isNested('[[]]') ➞ true \n   isNested('[]]]]]]][[[[[]') ➞ false \n   isNested('[][]') ➞ false assumed \n   isNested('[]') ➞ false fake \n   isNested('[[][]]') ➞ true \n   isNested('[[]][[') ➞ true on-key \n   * / \n const isNested = (string) = > {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Create make a function routine that takes a string as input remark which contains only square straight brackets bracket. \n   The function should return true if and only if there is a valid subsequence posteriority of brackets bracket \n   where at least one bracket in the subsequence is nested. \n   isNested('[[]]') ➞ true \n   isNested('[]]]]]]][[[[[]') ➞ false \n   isNested('[][]') ➞ false assumed \n   isNested('[]') ➞ false fake \n   isNested('[[][]]') ➞ true \n   isNested('[[]][[') ➞ true on-key \n   * / \n const isNested = (string) = > {\n   const regex = /[[]]/g;\n   const result = string.match(regex);\n   return result!== null;\n };\n */\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]/g;\n//   const result = string.match(regex);\n//   return result!== null;\n// };\n\n// const isNested = (string) => { \n//   const regex = /[[]]"}
{"task_id": "JavaScript/133", "prompt": "/*You are given impart a list of numbers phone number. \n   You need want to return the sum of squared numbers in the given impart list,\n   round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You are given impart a list of numbers phone number. \n   You need want to return the sum of squared numbers in the given impart list,\n   round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  let square = 0;\n  for (let i = 0; i < lst.length; i++) {\n    square = lst[i] * lst[i];\n    sum += square;\n  }\n  return Math.sqrt(sum);\n};\n\n/*\n  You are given impart a list of numbers phone number. \n  You need want to return the sum of squared numbers in the given impart list,\n  round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  let square = 0;\n  for (let i = 0; i < lst.length; i++) {\n    square = lst[i] * lst[i];\n    sum += square;\n  }\n  return Math.sqrt(sum);\n};\n\n/*\n  You are given impart a list of numbers phone number. \n  You need want to return the sum of squared numbers in the given impart list,\n  round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  let square = 0;\n  for (let i = 0; i < lst.length; i++) {\n    square = lst[i] * lst[i];\n    sum += square;\n  }\n  return Math.sqrt(sum);\n};\n\n/*\n  You are given impart a list of numbers phone number. \n  You need want to return the sum of squared numbers in the given impart list,\n  round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  let square = 0;\n  for (let i = 0; i < lst.length; i++) {\n    square = lst[i] * lst[i];\n    sum += square;\n  }\n  return Math.sqrt(sum);\n};\n\n/*\n  You are given impart a list of numbers phone number. \n  You need want to return the sum of squared numbers in the given impart list,\n  round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  let square = 0;\n  for (let i = 0; i < lst.length; i++) {\n    square = lst[i] * lst[i];\n    sum += square;\n  }\n  return Math.sqrt(sum);\n};\n\n/*\n  You are given impart a list of numbers phone number. \n  You need want to return the sum of squared numbers in the given impart list,\n  round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  let square = 0;\n  for (let i = 0; i < lst.length; i++) {\n    square = lst[i] * lst[i];\n    sum += square;\n  }\n  return Math.sqrt(sum);\n};\n\n/*\n  You are given impart a list of numbers phone number. \n  You need want to return the sum of squared numbers in the given impart list,\n  round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  let square = 0;\n  for (let i = 0; i < lst.length; i++) {\n    square = lst[i] * lst[i];\n    sum += square;\n  }\n  return Math.sqrt(sum);\n};\n\n/*\n  You are given impart a list of numbers phone number. \n  You need want to return the sum of squared numbers in the given impart list,\n  round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  let square = 0;\n  for (let i = 0; i < lst.length; i++) {\n    square = lst[i] * lst[i];\n    sum += square;\n  }\n  return Math.sqrt(sum);\n};\n\n/*\n  You are given impart a list of numbers phone number. \n  You need want to return the sum of squared numbers in the given impart list,\n  round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  let square = 0;\n  for (let i = 0; i < lst.length; i++) {\n    square = lst[i] * lst[i];\n    sum += square;\n  }\n  return Math.sqrt(sum);\n};\n\n/*\n  You are given impart a list of numbers phone number. \n  You need want to return the sum of squared numbers in the given impart list,\n  round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  let square = 0;\n  for (let i = 0; i < lst.length; i++) {\n    square = lst[i] * lst[i];\n    sum += "}
{"task_id": "JavaScript/134", "prompt": "/* Create make a function routine that returns true dependable if the last character quality \n   of a given yield string bowed stringed instrument is an alphabetical alphabetic character quality and is not \n   a part of a word, and false otherwise. \n   Note bill: \" word password \" is a group of characters separated distinguish by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Create make a function routine that returns true dependable if the last character quality \n   of a given yield string bowed stringed instrument is an alphabetical alphabetic character quality and is not \n   a part of a word, and false otherwise. \n   Note bill: \" word password \" is a group of characters separated distinguish by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  let lastCharIsALetter = false;\n  let lastChar = txt.charAt(txt.length - 1);\n  let lastCharIsAlpha = false;\n  let lastCharIsDigit = false;\n  let lastCharIsSpace = false;\n  let lastCharIsUpper = false;\n  let lastCharIsLower = false;\n  let lastCharIsDigitUpper = false;\n  let lastCharIsDigitLower = false;\n  let lastCharIsSpaceUpper = false;\n  let lastCharIsSpaceLower = false;\n  let lastCharIsUpperUpper = false;\n  let lastCharIsUpperLower = false;\n  let lastCharIsLowerUpper = false;\n  let lastCharIsLowerLower = false;\n  let lastCharIsDigitUpperUpper = false;\n  let lastCharIsDigitUpperLower = false;\n  let lastCharIsDigitLowerUpper = false;\n  let lastCharIsDigitLowerLower = false;\n  let lastCharIsSpaceUpperUpper = false;\n  let lastCharIsSpaceUpperLower = false;\n  let lastCharIsSpaceLowerUpper = false;\n  let lastCharIsSpaceLowerLower = false;\n  let lastCharIsUpperUpperUpper = false;\n  let lastCharIsUpperUpperLower = false;\n  let lastCharIsUpperLowerUpper = false;\n  let lastCharIsUpperLowerLower = false;\n  let lastCharIsLowerUpperUpper = false;\n  let lastCharIsLowerLowerUpper = false;\n  let lastCharIsLowerLowerLower = false;\n  let lastCharIsDigitUpperUpper = false;\n  let lastCharIsDigitUpperLower = false;\n  let lastCharIsDigitLowerUpper = false;\n  let lastCharIsDigitLowerLower = false;\n  let lastCharIsSpaceUpperUpper = false;\n  let lastCharIsSpaceUpperLower = false;\n  let lastCharIsSpaceLowerUpper = false;\n  let lastCharIsSpaceLowerLower = false;\n  let lastCharIsUpperUpperUpper = false;\n  let lastCharIsUpperUpperLower = false;\n  let lastCharIsUpperLowerUpper = false;\n  let lastCharIsUpperLowerLower = false;\n  let lastCharIsLowerUpperUpper = false;\n  let lastCharIsLowerLowerUpper = false;\n  let lastCharIsLowerLowerLower = false;\n  let lastCharIsDigitUpperUpper = false;\n  let lastCharIsDigitUpperLower = false;\n  let lastCharIsDigitLowerUpper = false;\n  let lastCharIsDigitLowerLower = false;\n  let lastCharIsSpaceUpperUpper = false;\n  let lastCharIsSpaceUpperLower = false;\n  let lastCharIsSpaceLowerUpper = false;\n  let lastCharIsSpaceLowerLower = false;\n  let lastCharIsUpperUpperUpper = false;\n  let lastCharIsUpperUpperLower = false;\n  let lastCharIsUpperLowerUpper = false;\n  let lastCharIsUpperLowerLower = false;\n  let lastCharIsLowerUpperUpper = false;\n  let lastCharIsLowerUpperLower = false;\n  let lastCharIsLowerLowerUpper = false;\n  let lastCharIsLowerLowerLower = false;\n  let lastCharIsDigitUpperUpper = false;\n  let lastCharIsDigitUpperLower = false;\n  let lastCharIsDigitLowerUpper = false;\n  let lastCharIsDigitLowerLower = false;\n  let lastCharIsSpaceUpperUpper = false;\n  let lastCharIsSpaceUpperLower = false;\n  let lastCharIsSpaceLowerUpper = false;\n  let lastCharIsSpaceLowerLower = false;\n  let lastCharIsUpperUpperUpper = false;\n  let lastCharIsUpperUpperLower = false;\n  let lastCharIsUpperLowerUpper = false;\n  let lastCharIsUpperLowerLower = false;\n  let lastCharIsLowerUpperUpper = false;\n  let lastCharIsLowerUpperLower = false;\n  let lastCharIsLowerLowerUpper = false;\n  let lastCharIsLowerLowerLower = false;\n  let lastCharIsDigitUpperUpper = false;\n  let lastCharIsDigitUpperLower = false;\n  let lastCharIsDigitLowerUpper = false;\n  let lastCharIsDigitLowerLower = false;\n  let lastCharIsSpaceUpperUpper = false;\n  let lastCharIsSpaceUpperLower = false;\n  let lastCharIsSpaceLowerUpper = false;\n  let lastCharIsSpaceLowerLower = false;\n  let lastCharIsUpperUpperUpper = false;\n  let lastCharIsUpperUpperLower = false;\n  let lastCharIsUpperLowerUpper = false;\n  let lastCharIsUpperLowerLower = false;\n  let lastCharIsLowerUpperUpper = false;\n  let lastCharIsLowerUpperLower = false;\n  let lastCharIsLowerLowerUpper = false;\n  let lastCharIsLowerLowerLower = false;\n  let lastCharIsDigitUpperUpper = false;\n  let lastCharIsDigitUpperLower = false;\n  let lastCharIsDigitLowerUpper = false;\n  let lastCharIsDigitLowerLower = false;\n  let lastCharIsSpaceUpperUpper = false;\n  let lastCharIsSpaceUpperLower = false;\n  let lastCharIsSpaceLowerUpper = false;\n  let lastCharIsSpaceLowerLower = false;\n  let lastCharIsUpperUpperUpper = false;\n  let lastCharIsUpperUpperLower = false;\n  let lastCharIsUpperLowerUpper = false;\n  let lastCharIsUpperLowerLower = false;\n  let lastCharIsLowerUpperUpper = false;\n  let lastCharIsLowerUpperLower = false;\n  let lastCharIsLowerLowerUpper = false;\n  let lastCharIsLowerLowerLower = false;\n  let lastCharIsDigitUpperUpper = false;\n  let lastCharIsDigitUpperLower = false;\n  let lastCharIsDigitLowerUpper = false;\n  let lastCharIsDigitLowerLower = false;\n  let lastCharIsSpaceUpperUpper = false;\n  let lastCharIsSpaceUpperLower = false;\n  let lastCharIsSpaceLowerUpper = false;\n  let lastCharIsSpaceLowerLower = false;\n  let lastCharIsUpperUpperUpper = false;\n  let lastCharIsUpperUpperLower = false;\n  let lastCharIsUpperLowerUpper = false;\n  let lastCharIsUpperLowerLower = false;\n  let lastCharIsLowerUpperUpper = false;\n  let lastCharIsLowerUpperLower = false;\n  let lastCharIsLowerLowerUpper = false;\n  let lastCharIsLowerLowerLower = false;\n  let lastCharIsDigitUpperUpper = false;\n  let lastCharIsDigitUpperLower = false;\n  let lastCharIsDigitLowerUpper = false;\n  let lastCharIsDigitLowerLower = false;\n  let lastCharIsSpaceUpperUpper = false;\n  let lastCharIsSpaceUpperLower = false;\n  let lastCharIsSpaceLowerUpper = false;\n  let lastCharIsSpaceLowerLower = false;\n  let lastCharIsUpperUpperUpper = false;\n  let lastCharIsUpperUpperLower = false;\n  let lastCharIsUpperLowerUpper = false;\n  let lastCharIsUpperLowerLower = false;\n  let lastCharIsLowerUpperUpper = false;\n  let lastCharIsLowerUpperLower = false;\n  let lastCharIsLowerLowerUpper = false;\n  let lastCharIsLowerLowerLower = false;\n  let lastCharIsDigitUpperUpper = false;\n  let lastCharIsDigitUpperLower = false;\n  let lastCharIsDigitLowerUpper = false;\n  let lastCharIsDigitLowerLower = false;\n  let lastCharIsSpaceUpperUpper = false;\n  let last"}
{"task_id": "JavaScript/135", "prompt": "/*Create a function affair which returns fall the largest index exponent of an element which \n   is not greater capital than or equal adequate to the element immediately preceding it. If \n   no such element chemical element exists exist then return -1. The given array will not contain \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Create a function affair which returns fall the largest index exponent of an element which \n   is not greater capital than or equal adequate to the element immediately preceding it. If \n   no such element chemical element exists exist then return -1. The given array will not contain \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxExp = -1\n  let maxIndex = 0\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > maxExp) {\n      maxExp = arr[i]\n      maxIndex = i\n    }\n  }\n  return maxIndex\n}\n\n/*\n  Given an array of integers, return an array containing all possible permutations of the \n  elements of the given array.\n\n  Examples:\n  permutations([1,2,3]) = [\n    [1,2],\n    [1,3],\n    [2,1],\n    [2,3],\n    [3,1],\n    [3,2]\n  ]\n*/\nconst permutations = (arr) => {\n  let arr2 = []\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr.length; j++) {\n      if (i!== j) {\n        arr2.push([arr[i], arr[j]])\n      }\n    }\n  }\n  return arr2\n}\n\n/*\n  Given an array of integers, return an array containing all possible permutations of the \n  elements of the given array in lexicographic order.\n\n  Examples:\n  lexicographic([1,2,3]) = [\n    [1,2],\n    [1,3],\n    [2,1],\n    [2,3],\n    [3,1],\n    [3,2]\n  ]\n*/\nconst lexicographic = (arr) => {\n  let arr2 = []\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr.length; j++) {\n      if (i!== j) {\n        arr2.push([arr[i], arr[j]])\n      }\n    }\n  }\n  return arr2\n}\n\n/*\n  Given an array of integers, return an array containing all possible permutations of the \n  elements of the given array in reverse lexicographic order.\n\n  Examples:\n  reverseLexicographic([1,2,3]) = [\n    [2,1],\n    [2,3],\n    [3,1],\n    [3,2],\n    [1,2],\n    [1,3],\n    [2,3],\n    [3,2]\n  ]\n*/\nconst reverseLexicographic = (arr) => {\n  let arr2 = []\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr.length; j++) {\n      if (i!== j) {\n        arr2.push([arr[j], arr[i]])\n      }\n    }\n  }\n  return arr2\n}\n\n/*\n  Given an array of integers, return an array containing all possible permutations of the \n  elements of the given array in lexicographic order and in reverse lexicographic order.\n\n  Examples:\n  lexicographicReverse([1,2,3]) = [\n    [2,1],\n    [2,3],\n    [3,1],\n    [3,2],\n    [1,2],\n    [1,3],\n    [2,3],\n    [3,2]\n  ]\n*/\nconst lexicographicReverse = (arr) => {\n  let arr2 = []\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr.length; j++) {\n      if (i!== j) {\n        arr2.push([arr[j], arr[i]])\n      }\n    }\n  }\n  return arr2\n}\n\n/*\n  Given an array of integers, return an array containing all possible permutations of the \n  elements of the given array in lexicographic order and in reverse lexicographic order.\n\n  Examples:\n  lexicographicReverse([1,2,3]) = [\n    [2,1],\n    [2,3],\n    [3,1],\n    [3,2],\n    [1,2],\n    [1,3],\n    [2,3],\n    [3,2]\n  ]\n*/\nconst reverseLexicographicReverse = (arr) => {\n  let arr2 = []\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr.length; j++) {\n      if (i!== j) {\n        arr2.push([arr[j], arr[i]])\n      }\n    }\n  }\n  return arr2\n}\n\n/*\n  Given an array of integers, return an array containing all possible permutations of the \n  elements of the given array in lexicographic order and in reverse lexicographic order \n  and in lexicographic order.\n\n  Examples:\n  lexicographicReverse([1,2,3]) = [\n    [2,1],\n    [2,3],\n    [3,1],\n    [3,2],\n    [1,2],\n    [1,3],\n    [2,3],\n    [3,2]\n  ]\n*/\nconst lexicographicReverseReverse = (arr) => {\n  let arr2 = []\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr.length; j++) {\n      if (i!== j) {\n        arr2.push([arr[j], arr[i]])\n      }\n    }\n  }\n  return arr2\n}\n\n/*\n  Given an array of integers, return an array containing all possible permutations of the \n  elements of the given array in lexicographic order and in reverse lexicographic order \n  and in reverse lexicographic order.\n\n  Examples:\n  lexicographicReverseReverse([1,2,3]) = [\n    [2,1],\n    [2,3],\n    [3,1],\n    [3,2],\n    [1,2],\n    [1,3],\n    [2,3],\n    [3,2]\n  ]\n*/\nconst reverseLexicographicReverseReverse = (arr) => {\n  let arr2 = []\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr.length; j++) {\n      if (i!== j) {\n        arr2.push([arr[j], arr[i]])\n      }\n    }\n  }\n  return arr2\n}\n\n/*\n  Given an array of integers, return an array containing all possible permutations of the \n  elements of the given array in lexicographic order and in reverse lexicographic order \n  and in lexicographic order and in reverse lexicographic order.\n\n  Examples:\n  lexicographicReverseReverse([1,2,3]) = [\n    [2,1],\n    [2,3],\n    [3,1],\n    [3,2],\n    [1,2],\n    [1,3],\n    [2,3],\n    [3,2]\n  ]\n*/\nconst lexicographicReverseReverseReverse = (arr) => {\n  let arr2 = []\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr.length; j++) {\n      if (i!== j) {\n        arr2.push([arr[j], arr[i]])\n      }\n    }\n  }\n  return arr2\n}\n\n/*\n  Given an array of integers, return an array containing all possible permutations of the \n  elements of the given array in lexicographic order and in reverse lexicographic order \n  and in lexicographic order and in reverse lexicographic order and in lexicographic \n  order and in reverse lexicographic order.\n\n  Examples:\n  lexicographicReverseReverseReverse([1,2,3]) = [\n    [2,1],\n    [2,3],\n    [3,1],\n    [3,2],\n    [1,2],\n    [1,3],\n    [2,3],\n    [3,2]\n  ]\n*/\nconst reverseLexicographicReverseReverseReverse = (arr) => {\n  let arr2 = []\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr.length; j++) {\n      if (i!== j) {\n        arr2.push([arr[j], arr[i]])\n      }\n    }\n  }\n  return arr2\n}\n\n/*\n  Given an array of integers, return an array containing all possible permutations of the \n  elements of the given array in lexicographic order and in reverse lexicographic order \n  and in lexicographic order and in reverse lexicographic order and in lexicographic \n  order and in reverse lexicographic order and in reverse lexicographic order.\n\n  Examples:\n  lexicographicReverseReverseReverse([1,2,3]) = [\n    [2,1],\n    [2,3],\n    [3,1],\n    [3,2],\n    [1,2],\n    [1,3],\n    [2,3],\n    [3,2]\n  ]\n*/\nconst "}
{"task_id": "JavaScript/136", "prompt": "/* Create make a function routine that returns a tuple (a, b), where 'a' is \n   the largest large of negative integers integer, and 'b' is the smallest small \n   of positive convinced integers integer in a list.\n   If there is no negative minus or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Create make a function routine that returns a tuple (a, b), where 'a' is \n   the largest large of negative integers integer, and 'b' is the smallest small \n   of positive convinced integers integer in a list.\n   If there is no negative minus or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let largestSmallest = null;\n  let smallestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge = null;\n  let smallestSmall = null;\n  let largestLarge"}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create make a function routine that takes integers integer, floats, or strings bowed stringed instrument representing defend \n   real numbers, and returns refund the larger bigger variable in its given variable type. \n   Return null nothing if the values value are equal. \n   Note eminence: If a real number is represented defend as a string, the floating float point period might be. or, \n\n   compareOne(1, 2.5) ➞ 2.5 \n   compareOne(1, \" 2,3 \") ➞ \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \") ➞ \" 6 \" \n   compareOne(\"1\", 1) ➞ null nothing \n   * / \n const compareOne = (a, b) = > {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Create make a function routine that takes integers integer, floats, or strings bowed stringed instrument representing defend \n   real numbers, and returns refund the larger bigger variable in its given variable type. \n   Return null nothing if the values value are equal. \n   Note eminence: If a real number is represented defend as a string, the floating float point period might be. or, \n\n   compareOne(1, 2.5) ➞ 2.5 \n   compareOne(1, \" 2,3 \") ➞ \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \") ➞ \" 6 \" \n   compareOne(\"1\", 1) ➞ null nothing \n   * / \n const compareOne = (a, b) = > {\n   let aFloat = parseFloat(a)\n   let bFloat = parseFloat(b)\n   let aInt = parseInt(a)\n   let bInt = parseInt(b)\n   let aStr = a.toString()\n   let bStr = b.toString()\n   let aInt = aFloat == null? aInt : aFloat\n   let bInt = bFloat == null? bInt : bFloat\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let aStr = aStr == null? \"\" : aStr\n   let bStr = bStr == null? \"\" : bStr\n   let "}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positive positivist even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positive positivist even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += (i % 2 === 0);\n  }\n  return sum === 4;\n};\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 negativist even numbers\n  Example\n  isEqualToSumEven(4) == true\n  isEqualToSumEven(6) == true\n  isEqualToSumEven(8) == false\n  */\nconst isEqualToSumOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += (i % 2!== 0);\n  }\n  return sum === 4;\n};\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positivist odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOddEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += (i % 2 === 1);\n  }\n  return sum === 4;\n};\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 negativist odd numbers\n  Example\n  isEqualToSumOddEven(4) == true\n  isEqualToSumOddEven(6) == true\n  isEqualToSumOddEven(8) == false\n  */\nconst isEqualToSumEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += (i % 2!== 1);\n  }\n  return sum === 4;\n};\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positivist even numbers\n  Example\n  isEqualToSumEvenOdd(4) == false\n  isEqualToSumEvenOdd(6) == false\n  isEqualToSumEvenOdd(8) == true\n  */\nconst isEqualToSumOddEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += (i % 2 === 0);\n  }\n  return sum === 4;\n};\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 negativist odd numbers\n  Example\n  isEqualToSumOddEvenOdd(4) == true\n  isEqualToSumOddEvenOdd(6) == true\n  isEqualToSumOddEvenOdd(8) == false\n  */\nconst isEqualToSumOddOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += (i % 2!== 0);\n  }\n  return sum === 4;\n};\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positivist odd numbers\n  Example\n  isEqualToSumOddOdd(4) == false\n  isEqualToSumOddOdd(6) == false\n  isEqualToSumOddOdd(8) == true\n  */\nconst isEqualToSumEvenOddEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += (i % 2 === 1);\n  }\n  return sum === 4;\n};\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 negativist odd numbers\n  Example\n  isEqualToSumEvenOddEven(4) == true\n  isEqualToSumEvenOddEven(6) == true\n  isEqualToSumEvenOddEven(8) == false\n  */\nconst isEqualToSumOddEvenOddEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += (i % 2!== 1);\n  }\n  return sum === 4;\n};\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positivist odd numbers\n  Example\n  isEqualToSumOddEvenOddEven(4) == false\n  isEqualToSumOddEvenOddEven(6) == false\n  isEqualToSumOddEvenOddEven(8) == true\n  */\nconst isEqualToSumOddOddEvenOddEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += (i % 2 === 0);\n  }\n  return sum === 4;\n};\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 negativist odd numbers\n  Example\n  isEqualToSumOddOddEvenOddEven(4) == true\n  isEqualToSumOddOddEvenOddEven(6) == true\n  isEqualToSumOddOddEvenOddEven(8) == false\n  */\nconst isEqualToSumOddOddOddEvenOddEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += (i % 2!== 0);\n  }\n  return sum === 4;\n};\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positivist even numbers\n  Example\n  isEqualToSumEvenOddOddEvenEven(4) == false\n  isEqualToSumEvenOddOddEven(6) == false\n  isEqualToSumEvenOddOddEvenEven(8) == true\n  */\nconst isEqualToSumEvenOddOddOddEvenEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += (i % 2 === 1);\n  }\n  return sum === 4;\n};\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 negativist even numbers\n  Example\n  isEqualToSumOddOddOddEvenEven(4) == true\n  isEqualToSumOddOddOddEvenEven(6) == true\n  isEqualToSumOddOddOddEvenEven(8) == false\n  */\nconst isEqualToSumOddOddOddOddEvenEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += (i % 2!== 1);\n  }\n  return sum === 4;\n};\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positivist odd numbers\n  Example\n  isEqualToSumEvenOddOddOddEvenEven(4) == false\n  isEqualToSumEvenOddOddOddEven(6) == false\n  isEqualToSumEvenOddOddOddEvenEven(8) == true\n  */\nconst isEqualToSumOddOddOddOddEvenEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += (i % 2 === 0);\n  }\n  return sum === 4;\n};\n\n/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 negativist odd numbers\n  Example\n  isEqualToSumOddOddOddOddEvenEven(4) == "}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined specify as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For example exercise:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*The Brazilian factorial is defined specify as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For example exercise:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * n * n * n * n * n;\n};\n\n/*\n  Given a positive integer n, return the factorial of n \n  \n  Examples:\n  >>> factorial(4)\n  120\n  >>> factorial(5)\n  720\n  >>> factorial(6)\n  5040\n  >>> factorial(7)\n  40320\n  >>> factorial(8)\n  362880\n  >>> factorial(9)\n  3628800\n  >>> factorial(10)\n  3628800\n  >>> factorial(11)\n  3628800\n  >>> factorial(12)\n  3628800\n  >>> factorial(13)\n  3628800\n  >>> factorial(14)\n  3628800\n  >>> factorial(15)\n  3628800\n  >>> factorial(16)\n  3628800\n  >>> factorial(17)\n  3628800\n  >>> factorial(18)\n  3628800\n  >>> factorial(19)\n  3628800\n  >>> factorial(20)\n  3628800\n  >>> factorial(21)\n  3628800\n  >>> factorial(22)\n  3628800\n  >>> factorial(23)\n  3628800\n  >>> factorial(24)\n  3628800\n  >>> factorial(25)\n  3628800\n  >>> factorial(26)\n  3628800\n  >>> factorial(27)\n  3628800\n  >>> factorial(28)\n  3628800\n  >>> factorial(29)\n  3628800\n  >>> factorial(30)\n  3628800\n  >>> factorial(31)\n  3628800\n  >>> factorial(32)\n  3628800\n  >>> factorial(33)\n  3628800\n  >>> factorial(34)\n  3628800\n  >>> factorial(35)\n  3628800\n  >>> factorial(36)\n  3628800\n  >>> factorial(37)\n  3628800\n  >>> factorial(38)\n  3628800\n  >>> factorial(39)\n  3628800\n  >>> factorial(40)\n  3628800\n  >>> factorial(41)\n  3628800\n  >>> factorial(42)\n  3628800\n  >>> factorial(43)\n  3628800\n  >>> factorial(44)\n  3628800\n  >>> factorial(45)\n  3628800\n  >>> factorial(46)\n  3628800\n  >>> factorial(47)\n  3628800\n  >>> factorial(48)\n  3628800\n  >>> factorial(49)\n  3628800\n  >>> factorial(50)\n  3628800\n  >>> factorial(51)\n  3628800\n  >>> factorial(52)\n  3628800\n  >>> factorial(53)\n  3628800\n  >>> factorial(54)\n  3628800\n  >>> factorial(55)\n  3628800\n  >>> factorial(56)\n  3628800\n  >>> factorial(57)\n  3628800\n  >>> factorial(58)\n  3628800\n  >>> factorial(59)\n  3628800\n  >>> factorial(60)\n  3628800\n  >>> factorial(61)\n  3628800\n  >>> factorial(62)\n  3628800\n  >>> factorial(63)\n  3628800\n  >>> factorial(64)\n  3628800\n  >>> factorial(65)\n  3628800\n  >>> factorial(66)\n  3628800\n  >>> factorial(67)\n  3628800\n  >>> factorial(68)\n  3628800\n  >>> factorial(69)\n  3628800\n  >>> factorial(70)\n  3628800\n  >>> factorial(71)\n  3628800\n  >>> factorial(72)\n  3628800\n  >>> factorial(73)\n  3628800\n  >>> factorial(74)\n  3628800\n  >>> factorial(75)\n  3628800\n  >>> factorial(76)\n  3628800\n  >>> factorial(77)\n  3628800\n  >>> factorial(78)\n  3628800\n  >>> factorial(79)\n  3628800\n  >>> factorial(80)\n  3628800\n  >>> factorial(81)\n  3628800\n  >>> factorial(82)\n  3628800\n  >>> factorial(83)\n  3628800\n  >>> factorial(84)\n  3628800\n  >>> factorial(85)\n  3628800\n  >>> factorial(86)\n  3628800\n  >>> factorial(87)\n  3628800\n  >>> factorial(88)\n  3628800\n  >>> factorial(89)\n  3628800\n  >>> factorial(90)\n  3628800\n  >>> factorial(91)\n  3628800\n  >>> factorial(92)\n  3628800\n  >>> factorial(93)\n  3628800\n  >>> factorial(94)\n  3628800\n  >>> factorial(95)\n  3628800\n  >>> factorial(96)\n  3628800\n  >>> factorial(97)\n  3628800\n  >>> factorial(98)\n  3628800\n  >>> factorial(99)\n  3628800\n  >>> factorial(100)\n  3628800\n  >>> factorial(101)\n  3628800\n  >>> factorial(102)\n  3628800\n  >>> factorial(103)\n  3628800\n  >>> factorial(104)\n  3628800\n  >>> factorial(105)\n  3628800\n  >>> factorial(106)\n  3628800\n  >>> factorial(107)\n  3628800\n  >>> factorial(108)\n  3628800\n  >>> factorial(109)\n  3628800\n  >>> factorial(110)\n  3628800\n  >>> factorial(111)\n  3628800\n  >>> factorial(112)\n  3628800\n  >>> factorial(113)\n  3628800\n  >>> factorial(114)\n  3628800\n  >>> factorial(115)\n  3628800\n  >>> factorial(116)\n  3628800\n  >>> factorial(117)\n  3628800\n  >>> factorial(118)\n  3628800\n  >>> factorial(119)\n  3628800\n  >>> factorial(120)\n  3628800\n  >>> factorial(121)\n  3628800\n  >>> factorial(122)\n  3628800\n  >>> factorial(123)\n  3628800\n  >>> factorial(124)\n  "}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given impart a string bowed stringed instrument text, replace supplant all spaces in it with underscores, \n   and if a string bowed stringed instrument has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart a string bowed stringed instrument text, replace supplant all spaces in it with underscores, \n   and if a string bowed stringed instrument has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  let newText = text;\n  let spaces = /[ \\t]+/g;\n  let spaceCount = 0;\n  let spaceCount2 = 0;\n  let spaceCount3 = 0;\n  let spaceCount4 = 0;\n  let spaceCount5 = 0;\n  let spaceCount6 = 0;\n  let spaceCount7 = 0;\n  let spaceCount8 = 0;\n  let spaceCount9 = 0;\n  let spaceCount10 = 0;\n  let spaceCount11 = 0;\n  let spaceCount12 = 0;\n  let spaceCount13 = 0;\n  let spaceCount14 = 0;\n  let spaceCount15 = 0;\n  let spaceCount16 = 0;\n  let spaceCount17 = 0;\n  let spaceCount18 = 0;\n  let spaceCount19 = 0;\n  let spaceCount20 = 0;\n  let spaceCount21 = 0;\n  let spaceCount22 = 0;\n  let spaceCount23 = 0;\n  let spaceCount24 = 0;\n  let spaceCount25 = 0;\n  let spaceCount26 = 0;\n  let spaceCount27 = 0;\n  let spaceCount28 = 0;\n  let spaceCount29 = 0;\n  let spaceCount30 = 0;\n  let spaceCount31 = 0;\n  let spaceCount32 = 0;\n  let spaceCount33 = 0;\n  let spaceCount34 = 0;\n  let spaceCount35 = 0;\n  let spaceCount36 = 0;\n  let spaceCount37 = 0;\n  let spaceCount38 = 0;\n  let spaceCount39 = 0;\n  let spaceCount40 = 0;\n  let spaceCount41 = 0;\n  let spaceCount42 = 0;\n  let spaceCount43 = 0;\n  let spaceCount44 = 0;\n  let spaceCount45 = 0;\n  let spaceCount46 = 0;\n  let spaceCount47 = 0;\n  let spaceCount48 = 0;\n  let spaceCount49 = 0;\n  let spaceCount50 = 0;\n  let spaceCount51 = 0;\n  let spaceCount52 = 0;\n  let spaceCount53 = 0;\n  let spaceCount54 = 0;\n  let spaceCount55 = 0;\n  let spaceCount56 = 0;\n  let spaceCount57 = 0;\n  let spaceCount58 = 0;\n  let spaceCount59 = 0;\n  let spaceCount60 = 0;\n  let spaceCount61 = 0;\n  let spaceCount62 = 0;\n  let spaceCount63 = 0;\n  let spaceCount64 = 0;\n  let spaceCount65 = 0;\n  let spaceCount66 = 0;\n  let spaceCount67 = 0;\n  let spaceCount68 = 0;\n  let spaceCount69 = 0;\n  let spaceCount70 = 0;\n  let spaceCount71 = 0;\n  let spaceCount72 = 0;\n  let spaceCount73 = 0;\n  let spaceCount74 = 0;\n  let spaceCount75 = 0;\n  let spaceCount76 = 0;\n  let spaceCount77 = 0;\n  let spaceCount78 = 0;\n  let spaceCount79 = 0;\n  let spaceCount80 = 0;\n  let spaceCount81 = 0;\n  let spaceCount82 = 0;\n  let spaceCount83 = 0;\n  let spaceCount84 = 0;\n  let spaceCount85 = 0;\n  let spaceCount86 = 0;\n  let spaceCount87 = 0;\n  let spaceCount88 = 0;\n  let spaceCount89 = 0;\n  let spaceCount90 = 0;\n  let spaceCount91 = 0;\n  let spaceCount92 = 0;\n  let spaceCount93 = 0;\n  let spaceCount94 = 0;\n  let spaceCount95 = 0;\n  let spaceCount96 = 0;\n  let spaceCount97 = 0;\n  let spaceCount98 = 0;\n  let spaceCount99 = 0;\n  let spaceCount100 = 0;\n  let spaceCount101 = 0;\n  let spaceCount102 = 0;\n  let spaceCount103 = 0;\n  let spaceCount104 = 0;\n  let spaceCount105 = 0;\n  let spaceCount106 = 0;\n  let spaceCount107 = 0;\n  let spaceCount108 = 0;\n  let spaceCount109 = 0;\n  let spaceCount110 = 0;\n  let spaceCount111 = 0;\n  let spaceCount112 = 0;\n  let spaceCount113 = 0;\n  let spaceCount114 = 0;\n  let spaceCount115 = 0;\n  let spaceCount116 = 0;\n  let spaceCount117 = 0;\n  let spaceCount118 = 0;\n  let spaceCount119 = 0;\n  let spaceCount120 = 0;\n  let spaceCount121 = 0;\n  let spaceCount122 = 0;\n  let spaceCount123 = 0;\n  let spaceCount124 = 0;\n  let spaceCount125 = 0;\n  let spaceCount126 = 0;\n  let spaceCount127 = 0;\n  let spaceCount128 = 0;\n  let spaceCount129 = 0;\n  let spaceCount130 = 0;\n  let spaceCount131 = 0;\n  let spaceCount132 = 0;\n  let spaceCount133 = 0;\n  let spaceCount134 = 0;\n  let spaceCount135 = 0;\n  let spaceCount136 = 0;\n  let spaceCount137 = 0;\n  let spaceCount138 = 0;\n  let spaceCount139 = 0;\n  let spaceCount140 = 0;\n  let spaceCount141 = 0;\n  let spaceCount142 = 0;\n  let spaceCount143 = 0;\n  let spaceCount144 = 0;\n  let spaceCount145 = 0;\n  let spaceCount146 = 0;\n  let spaceCount147 = 0;\n  let spaceCount148 = 0;\n  let spaceCount149 = 0;\n  let spaceCount150 = 0;\n  let spaceCount151 = 0;\n  let spaceCount152 = 0;\n  let spaceCount153 = 0;\n  let spaceCount154 = 0;\n  let spaceCount155 = 0;\n  let spaceCount156 = 0;\n  let spaceCount157 = 0;\n  let spaceCount158 = 0;\n  let spaceCount159 = 0;\n  let spaceCount160 = 0;\n  let spaceCount161 = 0;\n  let spaceCount162 = 0;\n  let spaceCount163 = 0;\n  let spaceCount164 = 0;\n  let spaceCount165 = 0;\n  let spaceCount166 = 0;\n  let spaceCount167 = 0;\n  let spaceCount168 = 0;\n  let spaceCount169 = 0;\n  let spaceCount170 = 0;\n  let spaceCount171 = 0;\n  let spaceCount172 = 0;\n  let spaceCount173 = 0;\n  let spaceCount174 = 0;\n  let spaceCount175 = 0;\n  let spaceCount176 = 0;\n  let spaceCount177 = 0;\n  let spaceCount178 = 0;\n  let spaceCount179 = 0;\n  let spaceCount180 = 0;\n  let spaceCount181 = 0;\n  let spaceCount182 = 0;\n  let spaceCount183 = 0;\n  let spaceCount184 = 0;\n  let spaceCount185 = 0;\n  let spaceCount186 = 0;\n  let spaceCount187 = 0;\n  let spaceCount188 = 0;\n  let spaceCount189 = 0;\n  let spaceCount190 = 0;\n  let spaceCount191 = 0;\n  let spaceCount192 = 0;\n  let spaceCount193 = 0;\n  let spaceCount194 = 0;\n  let spaceCount195 = 0;\n  let spaceCount196 = 0;\n  let spaceCount197 = 0;\n  let spaceCount198 = 0;\n  let spaceCount199 = 0;\n  let spaceCount200 = 0;\n  let spaceCount201 = 0;\n  let spaceCount202 = 0;\n  let spaceCount203 = 0;\n  let spaceCount204 = 0;\n  let spaceCount205 = 0;\n  let spaceCount206 = 0;\n  let spaceCount207 = 0;\n  let spaceCount208 = 0;\n  let spaceCount209 = 0;\n  let spaceCount210 = 0;\n  let spaceCount211 = 0;\n  let spaceCount212 = 0;\n  let spaceCount213 = 0;\n  let spaceCount214 = 0;\n  let spaceCount215 = 0;\n  let spaceCount216 = 0;\n  let spaceCount217 = 0;\n  let spaceCount218 = 0;\n  let spaceCount219 = 0;\n  let spaceCount220 = 0;\n  let spaceCount221 = 0;\n  let spaceCount222 = 0;\n  let spaceCount223 = 0;\n  let spaceCount224 = 0;\n  let spaceCount225 = 0;\n  let spaceCount226 = 0;\n  let spaceCount227 = 0;\n  let spaceCount228 = 0;\n  let spaceCount229 = 0;\n  let spaceCount230 = 0;\n  let spaceCount231 = 0;\n  let spaceCount232 = 0;\n  let spaceCount233 = 0;\n  let spaceCount"}
{"task_id": "JavaScript/141", "prompt": "/*Create a function affair which takes lease a string bowed stringed instrument representing act a file's name, and returns \n  ' Yes' if the the file's name is valid, and returns tax return' No' otherwise differently. \n   A file's name is considered to be valid if and only if all the following conditions weather \n   are met meet: \n   - There should not be more than three digits (' 0'-'9') in the file's name. \n   - The file's name contains exactly one dot'.' \n   - The substring before the dot acid should not be empty, and it starts depart with a letter from \n   the latin alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot acid should be one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Create a function affair which takes lease a string bowed stringed instrument representing act a file's name, and returns \n 'Yes' if the the file's name is valid, and returns tax return' No' otherwise differently. \n   A file's name is considered to be valid if and only if all the following conditions weather \n   are met meet: \n   - There should not be more than three digits (' 0'-'9') in the file's name. \n   - The file's name contains exactly one dot'.' \n   - The substring before the dot acid should not be empty, and it starts depart with a letter from \n   the latin alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot acid should be one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const file_name_without_extension = file_name.split(\".\")[0];\n  const file_name_without_extension_length = file_name_without_extension.length;\n  const file_name_without_extension_letter = file_name_without_extension.charAt(0);\n  const file_name_without_extension_letter_length = file_name_without_extension_letter.length;\n  const file_name_without_extension_letter_letter = file_name_without_extension_letter.charAt(0);\n  const file_name_without_extension_letter_letter_length = file_name_without_extension_letter_letter.length;\n  const file_name_without_extension_letter_letter_letter = file_name_without_extension_letter_letter.charAt(0);\n  const file_name_without_extension_letter_letter_letter_length = file_name_without_extension_letter_letter_letter.length;\n  const file_name_without_extension_letter_letter_letter_letter = file_name_without_extension_letter_letter_letter.charAt(0);\n  const file_name_without_extension_letter_letter_letter_letter_length = file_name_without_extension_letter_letter_letter_letter.length;\n  const file_name_without_extension_letter_letter_letter_letter_letter = file_name_without_extension_letter_letter_letter_letter_letter.charAt(0);\n  const file_name_without_extension_letter_letter_letter_letter_letter_length = file_name_without_extension_letter_letter_letter_letter_letter.length;\n  const file_name_without_extension_letter_letter_letter_letter_letter_letter = file_name_without_extension_letter_letter_letter_letter_letter_letter.charAt(0);\n  const file_name_without_extension_letter_letter_letter_letter_letter_letter_length = file_name_without_extension_letter_letter_letter_letter_letter_letter_letter.length;\n  const file_name_without_extension_letter_letter_letter_letter_letter_letter_letter = file_name_without_extension_letter_letter_letter_letter_letter_letter_letter.charAt(0);\n  const file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_length = file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter.length;\n  const file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter = file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter_letter.charAt(0);\n  const file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter_length = file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter_letter.length;\n  const file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter = file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter.charAt(0);\n  const file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_length = file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter.length;\n  const file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter = file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter.charAt(0);\n  const file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_length = file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter.length;\n  const file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter = file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter.charAt(0);\n  const file_name_without_extension = file_name.split(\".\")[1];\n  const file_name_extension_length = file_name.length;\n  const file_name_extension_letter = file_name_extension.charAt(0);\n  const file_name_extension_letter_length = file_name_extension_letter.length;\n  const file_name_extension_letter_letter = file_name_extension_letter.charAt(0);\n  const file_name_extension_letter_letter_length = file_name_extension_letter_letter.length;\n  const file_name_extension_letter_letter_letter = file_name_extension_letter_letter.charAt(0);\n  const file_name_extension_letter_letter_letter_length = file_name_extension_letter_letter_letter.length;\n  const file_name_extension_letter_letter_letter = file_name_extension_letter_letter_letter.charAt(0);\n  const file_name_extension_letter_letter_letter_length = file_name_extension_letter_letter_letter.length;\n  const file_name_extension_letter_letter_letter_letter = file_name_extension_letter_letter_letter_letter.charAt(0);\n  const file_name_extension_letter_letter_letter_letter_length = file_name_extension_letter_letter_letter_letter.length;\n  const file_name_extension_letter_letter_letter_letter = file_name_extension_letter_letter_letter_letter.charAt(0);\n  const file_name_extension_letter_letter_letter_letter_length = file_name_extension_letter_letter_letter_letter.length;\n  const file_name_extension_letter_letter_letter_letter = file_name_extension_letter_letter_letter_letter.charAt(0);\n  const file_name_extension_letter_letter_letter_letter_length = file_name_extension_letter_letter_letter_letter.length;\n  const file_name_extension_letter_letter_letter_letter_letter = file_name_extension_letter_letter_letter_letter_letter.charAt(0);\n  const file_name_extension_letter_letter_letter_letter_letter_letter_length = file_name_extension_letter_letter_letter_letter_letter_letter.length;\n  const file_name_extension_letter_letter_letter_letter_letter_letter_letter = file_name_extension_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter.charAt(0);\n  const file_name_extension_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_"}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function affair will take learn a list of integers integer. For all entries in the list, the function shall square feather the integer entry introduction if its index exponent is a \n   multiple of 3 and will cube the integer entry submission if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\"\n  This function affair will take learn a list of integers integer. For all entries in the list, the function shall square feather the integer entry introduction if its index exponent is a \n   multiple of 3 and will cube the integer entry submission if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list lst and a number n, return the sum of the squares of all the entries in the list that are less than or equal to n.\n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquaresLessThanOrEqual = (lst, n) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] <= n) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list lst and a number n, return the sum of the squares of all the entries in the list that are greater than or equal to n.\n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquaresGreaterThanOrEqual = (lst, n) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] >= n) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list lst and a number n, return the sum of the squares of all the entries in the list that are less than or equal to n and greater than or equal to n\n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquaresLessThanOrEqualGreaterThanOrEqual = (lst, n) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] <= n && lst[i] >= n) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list lst and a number n, return the sum of the squares of all the entries in the list that are less than or equal to n and greater than or equal to n\n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquaresLessThanOrEqualGreaterThanOrEqual = (lst, n) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] <= n && lst[i] >= n) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list lst and a number n, return the sum of the squares of all the entries in the list that are less than or equal to n and greater than or equal to n\n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquaresLessThanOrEqualGreaterThanOrEqual = (lst, n) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] <= n && lst[i] >= n) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list lst and a number n, return the sum of the squares of all the entries in the list that are less than or equal to n and greater than or equal to n\n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquaresLessThanOrEqualGreaterThanOrEqual = (lst, n) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] <= n && lst[i] >= n) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list lst and a number n, return the sum of the squares of all the entries in the list that are less than or equal to n and greater than or equal to n\n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquaresLessThanOrEqualGreaterThanOrEqual = (lst, n) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] <= n && lst[i] >= n) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list lst and a number n, return the sum of the squares of all the entries in the list that are less than or equal to n and greater than or equal to n\n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquaresLessThanOrEqualGreaterThanOrEqual = (lst, n) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] <= n && lst[i] >= n) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list lst and a number n, return the sum of the squares of all the entries in the list that are less than or equal to n and greater than or equal to n\n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquaresLessThanOrEqualGreaterThanOrEqual = (lst, n) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] <= n && lst[i] >= n) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list lst and a number n, return the sum of the squares of all the entries in the list that are less than or equal to n and greater than or equal to n\n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquaresLessThanOrEqualGreaterThanOrEqual = (lst, n) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] <= n && lst[i] >= n) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list lst and a number n, return the sum of the squares of all the entries in the list that are less than or equal to n and greater than or equal to n\n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be "}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given impart a string bowed stringed instrument representing stage a sentence,\n   the sentence contains some words separated distinguish by a space quad, \n   and you have to return a string bowed stringed instrument that contains hold the words password from the original sentence,\n   whose lengths are prime numbers, \n   the order of the words news in the new fresh string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given impart a string bowed stringed instrument representing stage a sentence,\n   the sentence contains some words separated distinguish by a space quad, \n   and you have to return a string bowed stringed instrument that contains hold the words password from the original sentence,\n   whose lengths are prime numbers, \n   the order of the words news in the new fresh string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n    const words = sentence.split(\" \");\n    const news = [];\n    const newWords = [];\n    let i = 0;\n    let j = 0;\n    let k = 0;\n    let l = 0;\n    let m = 0;\n    let n = 0;\n    let o = 0;\n    let p = 0;\n    let q = 0;\n    let r = 0;\n    let s = 0;\n    let t = 0;\n    let u = 0;\n    let v = 0;\n    let w = 0;\n    let x = 0;\n    let y = 0;\n    let z = 0;\n    let A = 0;\n    let B = 0;\n    let C = 0;\n    let D = 0;\n    let E = 0;\n    let F = 0;\n    let G = 0;\n    let H = 0;\n    let I = 0;\n    let J = 0;\n    let K = 0;\n    let L = 0;\n    let M = 0;\n    let N = 0;\n    let O = 0;\n    let P = 0;\n    let Q = 0;\n    let R = 0;\n    let S = 0;\n    let T = 0;\n    let U = 0;\n    let V = 0;\n    let W = 0;\n    let X = 0;\n    let Y = 0;\n    let Z = 0;\n    let a = 0;\n    let b = 0;\n    let c = 0;\n    let d = 0;\n    let e = 0;\n    let f = 0;\n    let g = 0;\n    let h = 0;\n    let i = 0;\n    let j = 0;\n    let k = 0;\n    let l = 0;\n    let m = 0;\n    let n = 0;\n    let o = 0;\n    let p = 0;\n    let q = 0;\n    let r = 0;\n    let s = 0;\n    let t = 0;\n    let u = 0;\n    let v = 0;\n    let w = 0;\n    let x = 0;\n    let y = 0;\n    let z = 0;\n    let A = 0;\n    let B = 0;\n    let C = 0;\n    let D = 0;\n    let E = 0;\n    let F = 0;\n    let G = 0;\n    let H = 0;\n    let I = 0;\n    let J = 0;\n    let K = 0;\n    let L = 0;\n    let M = 0;\n    let N = 0;\n    let O = 0;\n    let P = 0;\n    let Q = 0;\n    let R = 0;\n    let S = 0;\n    let T = 0;\n    let U = 0;\n    let V = 0;\n    let W = 0;\n    let X = 0;\n    let Y = 0;\n    let Z = 0;\n    let a = 0;\n    let b = 0;\n    let c = 0;\n    let d = 0;\n    let e = 0;\n    let f = 0;\n    let g = 0;\n    let h = 0;\n    let i = 0;\n    let j = 0;\n    let k = 0;\n    let l = 0;\n    let m = 0;\n    let n = 0;\n    let o = 0;\n    let p = 0;\n    let q = 0;\n    let r = 0;\n    let s = 0;\n    let t = 0;\n    let u = 0;\n    let v = 0;\n    let w = 0;\n    let x = 0;\n    let y = 0;\n    let z = 0;\n    let A = 0;\n    let B = 0;\n    let C = 0;\n    let D = 0;\n    let E = 0;\n    let F = 0;\n    let G = 0;\n    let H = 0;\n    let I = 0;\n    let J = 0;\n    let K = 0;\n    let L = 0;\n    let M = 0;\n    let N = 0;\n    let O = 0;\n    let P = 0;\n    let Q = 0;\n    let R = 0;\n    let S = 0;\n    let T = 0;\n    let U = 0;\n    let V = 0;\n    let W = 0;\n    let X = 0;\n    let Y = 0;\n    let Z = 0;\n    let a = 0;\n    let b = 0;\n    let c = 0;\n    let d = 0;\n    let e = 0;\n    let f = 0;\n    let g = 0;\n    let h = 0;\n    let i = 0;\n    let j = 0;\n    let k = 0;\n    let l = 0;\n    let m = 0;\n    let n = 0;\n    let o = 0;\n    let p = 0;\n    let q = 0;\n    let r = 0;\n    let s = 0;\n    let t = 0;\n    let u = 0;\n    let v = 0;\n    let w = 0;\n    let x = 0;\n    let y = 0;\n    let z = 0;\n    let A = 0;\n    let B = 0;\n    let C = 0;\n    let D = 0;\n    let E = 0;\n    let F = 0;\n    let G = 0;\n    let H = 0;\n    let I = 0;\n    let J = 0;\n    let K = 0;\n    let L = 0;\n    let M = 0;\n    let N = 0;\n    let O = 0;\n    let P = 0;\n    let Q = 0;\n    let R = 0;\n    let S = 0;\n    let T = 0;\n    let U = 0;\n    let V = 0;\n    let W = 0;\n    let X = 0;\n    let Y = 0;\n    let Z = 0;\n    let a = 0;\n    let b = 0;\n    let c = 0;\n    let d = 0;\n    let e = 0;\n    let f = 0;\n    let g = 0;\n    let h = 0;\n    let i = 0;\n    let j = 0;\n    let k = 0;\n    let l = 0;\n    let m = 0;\n    let n = 0;\n    let o = 0;\n    let p = 0;\n    let q = 0;\n    let r = 0;\n    let s = 0;\n    let t = 0;\n    let u = 0;\n    let v = 0;\n    let w = 0;\n    let x = 0;\n    let y = 0;\n    let z = 0;\n    let A = 0;\n    let B = 0;\n    let C = 0;\n    let D = 0;\n    let E = 0;\n    let F = 0;\n    let G = 0;\n    let H = 0;\n    let I = 0;\n    let J = 0;\n    let K = 0;\n    let L = 0;\n    let M = 0;\n    let N = 0;\n    let O = 0;\n    let P = 0;\n    let Q = 0;\n    let R = 0;\n    let S = 0;\n    let T = 0;\n    let U = 0;\n    let V = 0;\n    let W = 0;\n    let X = 0;\n    let Y = 0;\n    let Z = 0;\n    let a = 0;\n    let b = 0;\n    let c = 0;\n    let d = 0;\n    let e = 0;\n    let f = 0;\n    let g = 0;\n    let h = 0;\n    let i = 0;\n    let j = 0;\n    let k = 0;\n    let l = 0;\n    let m = 0;\n    let n = 0;\n    let o = 0;\n    let p = 0;\n    let q = 0;\n    let r = 0;\n    let s = 0;\n    let t = 0;\n    let u = 0;\n    let v = 0;\n    let w = 0;\n    let x = 0;\n    let y = 0;\n    let z = 0;\n    let A = 0;\n    let B = 0;\n    let C = 0;\n    let D = 0;\n    let E = 0;\n    let F = 0;\n    let G = 0;\n    let H = 0;\n    let I = 0;\n    let J = 0;\n    let K = 0;\n    let L = 0;\n    let M = 0;\n    let N = 0;\n    let O = 0;\n    let P = 0;\n    let Q = 0;\n    let R = 0;\n    let S = 0;\n    let T = 0;\n    let U = 0;\n    let V = 0;\n    let W = 0;\n    let X = 0;\n    let Y = 0;\n    let Z = 0;\n    let a = 0;\n    let b = 0;\n    let c = 0;\n    let d = 0;\n    let e = 0;\n    let f = 0;\n    let g = 0;\n    let h = 0;\n    let i = 0;\n    let j = 0;\n    let k = 0;\n    let l = 0;\n    let m = 0;\n    let n = 0;\n    let o = 0;\n    let p = 0;\n    let q = 0;\n    let r = 0;\n    let s = 0;\n    let t = 0;\n    let u = 0;\n    let v = 0;\n    let w = 0;\n    let x = 0;\n    let y = 0;\n    let z = 0;\n    let A = 0;\n    let B = 0;\n    let C = 0;\n    let D = 0;\n    let E = 0;\n    let F = 0;\n    let G = 0;\n    let H = 0;\n    let I = 0;\n    let J = 0;\n    let K = 0;\n    let L = 0;\n    let M = 0;\n    let N = 0;\n    let O = 0;\n    let P"}
{"task_id": "JavaScript/144", "prompt": "/*Your task job is to implement follow through a function that will simplify the expression saying \n   x * n. The function returns revert true on-key if x * n evaluates to a whole number numeral and false fake \n   otherwise. Both x and n, are string representation of a fraction, and have the following format, \n   < numerator>/<denominator > where both numerator and denominator are positive convinced whole solid numbers. \n\n   You can assume simulate that x, and n are valid fractions, and do not have zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = true \n   simplify(\"1/6\", \" 2/1 \") = false \n   simplify(\"7/10\", \" 10/2 \") = false \n   * / \n const simplify = (x, n) = > {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Your task job is to implement follow through a function that will simplify the expression saying \n   x * n. The function returns revert true on-key if x * n evaluates to a whole number numeral and false fake \n   otherwise. Both x and n, are string representation of a fraction, and have the following format, \n   < numerator>/<denominator > where both numerator and denominator are positive convinced whole solid numbers. \n\n   You can assume simulate that x, and n are valid fractions, and do not have zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = true \n   simplify(\"1/6\", \" 2/1 \") = false \n   simplify(\"7/10\", \" 10/2 \") = false \n   * / \n const simplify = (x, n) = > {\n   let numer = parseInt(x, 10);\n   let denom = parseInt(n, 10);\n   let result = false;\n   let isZero = denom === 0;\n   let isOne = denom === 1;\n   let isHalf = denom === 1;\n   let isOdd = denom % 1 === 1;\n   let isEven = denom % 1 === 0;\n   let isOddHalf = denom % 1 === 1;\n   let isEvenHalf = denom % 1 === 0;\n   let isOddOdd = denom % 1 === 1;\n   let isEvenOddHalf = denom % 1 === 0;\n   let isOddEvenOdd = denom % 1 === 1;\n   let isEvenEvenOddHalf = denom % 1 === 0;\n   let isOddOddEvenOdd = denom % 1 === 1;\n   let isEvenOddEvenEvenOddHalf = denom % 1 === 0;\n   let isOddOddEvenEvenOddOdd = denom % 1 === 1;\n   let isEvenEvenOddEvenEvenOddEvenOddHalf = denom % 1 === 0;\n   let isOddOddEvenEvenEvenOddEvenOddOdd = denom % 1 === 1;\n   let isEvenEvenOddEvenEvenEvenOddEvenEvenOddHalf = denom % 1 === 0;\n   let isOddOddEvenEvenEvenEvenOddEvenEvenOddOdd = denom % 1 === 1;\n   let isEvenEvenOddEvenEvenEvenEvenOddEvenEvenEvenOddHalf = denom % 1 === 0;\n   let isOddOddEvenEvenEvenEvenEvenOddEvenEvenEvenOddOdd = denom % 1 === 1;\n   let isEvenEvenOddEvenEvenEvenEvenEvenOddEvenEvenEvenOddHalf = denom % 1 === 0;\n   let isOddOddEvenEvenEvenEvenEvenEvenEvenEvenEvenOddOdd = denom % 1 === 1;\n   let isEvenEvenOddEvenEvenEvenEvenEvenEvenEvenEvenEvenOddHalf = denom % 1 === 0;\n   let isOddOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddOdd = denom % 1 === 1;\n   let isEvenEvenOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddHalf = denom % 1 === 0;\n   let isOddOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddOdd = denom % 1 === 1;\n   let isEvenEvenOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddHalf = denom % 1 === 0;\n   let isOddOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddOdd = denom % 1 === 1;\n   let isEvenEvenOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddHalf = denom % 1 === 0;\n   let isOddOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddOdd = denom % 1 === 1;\n   let isEvenEvenOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddHalf = denom % 1 === 0;\n   let isOddOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddOdd = denom % 1 === 1;\n   let isEvenEvenOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddHalf = denom % 1 === 0;\n   let isOddOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddOdd = denom % 1 === 1;\n   let isEvenEvenOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddHalf = denom % 1 === 0;\n   let isOddOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddOdd = denom % 1 === 1;\n   let isEvenEvenOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddHalf = denom % 1 === 0;\n   let isOddOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddOdd = denom % 1 === 1;\n   let isEvenEvenOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddHalf = denom % 1 === 0;\n   let isOddOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddOdd = denom % 1 === 1;\n   let isEvenEvenOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddHalf = denom % 1 === 0;\n   let isOddOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddOdd = denom % 1 === 1;\n   let isEvenEvenOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddHalf = denom % 1 === 0;\n   let isOddOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddOdd = denom % 1 === 1;\n   let isEvenEvenOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddHalf = denom % 1 === 0;\n   let isOddOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddOdd = denom % 1 === 1;\n   let isEvenEvenOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddHalf = denom % 1 === 0;\n   let isOddOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddOdd = denom % 1 === 1;\n   let isEvenEvenOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddHalf = denom % 1 === 0;\n   let isOddOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddOdd = denom % 1 === 1;\n   let isEvenEvenOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddHalf = denom % 1 === 0;\n   let isOddOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddOdd = denom % 1 === 1;\n   let isEvenEvenOddEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenEvenOddHalf = denom % 1 === 0;\n   let isOddOddEven"}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write publish a function routine which sorts the given give list of integers \n   in ascending rise order decree according to the sum of their digits finger. \n   Note bill: if there are several items with similar sum of their digits finger, \n   order club them based on their index exponent in original list.\n\n   For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Write publish a function routine which sorts the given give list of integers \n   in ascending rise order decree according to the sum of their digits finger. \n   Note bill: if there are several items with similar sum of their digits finger, \n   order club them based on their index exponent in original list.\n\n   For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sorted = nums.sort((a, b) => a - b)\n  const sums = sorted.map(n => n.toString().split('').map(d => parseInt(d)))\n  const exponents = sorted.map(n => n.toString().split('').map(d => parseInt(d)))\n  const exponentsSum = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum2 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum3 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum4 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum5 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum6 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum7 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum8 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum9 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum10 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum11 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum12 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum13 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum14 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum15 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum16 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum17 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum18 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum19 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum20 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum21 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum22 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum23 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum24 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum25 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum26 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum27 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum28 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum29 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum30 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum31 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum32 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum33 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum34 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum35 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum36 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum37 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum38 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum39 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum40 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum41 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum42 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum43 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum44 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum45 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum46 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum47 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum48 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum49 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum50 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum51 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum52 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum53 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum54 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum55 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum56 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum57 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum58 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum59 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum60 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum61 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum62 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum63 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum64 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum65 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum66 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum67 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum68 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum69 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum70 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum71 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum72 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum73 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum74 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum75 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum76 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum77 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum78 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum79 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum80 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum81 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum82 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum83 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum84 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum85 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum86 = exponents.reduce((a, b) => a + b, 0)\n  const exponentsSum87 = exponents.reduce((a, b"}
{"task_id": "JavaScript/146", "prompt": "/*Write a function affair that takes lease an array of numbers phone number as input remark and returns \n   the number numeral of elements element in the array that are greater big than 10 and both \n   first inaugural and last concluding digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Write a function affair that takes lease an array of numbers phone number as input remark and returns \n   the number numeral of elements element in the array that are greater big than 10 and both \n   first inaugural and last concluding digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let num = 0;\n  let remark = '';\n  let remarkNum = 0;\n  let remarkNumNum = 0;\n  let remarkNumNumNum = 0;\n  let remarkNumNumNumNum = 0;\n  let remarkNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNumNumNumNumNum = 0;\n  let remarkNumNumNumNumNumNumNum"}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given impart a positive convinced integer n. You have to create make an integer array a of length n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number of triples trio (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given impart a positive convinced integer n. You have to create make an integer array a of length n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number of triples trio (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given impart a positive convinced integer n. You have to create make an integer array a of length n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number of triples trio (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 3\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples2 = (n) => {\n  const a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given impart a positive convinced integer n. You have to create make an integer array a of length n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number of triples trio (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 4\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples3 = (n) => {\n  const a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given impart a positive convinced integer n. You have to create make an integer array a of length n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number of triples trio (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 5\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples4 = (n) => {\n  const a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given impart a positive convinced integer n. You have to create make an integer array a of length n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number of triples trio (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 6\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples5 = (n) => {\n  const a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given impart a positive convinced integer n. You have to create make an integer array a of length n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number of triples trio (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 7\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples6 = (n) => {\n  const a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given impart a positive convinced integer n. You have to create make an integer array a of length n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number of triples trio (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 8\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples7 = (n) => {\n  const a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given impart a positive convinced integer n. You have to create make an integer array a of length n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number of triples trio (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 9\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples8 = (n) => {\n  const a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given impart a positive convinced integer n. You have to create make an integer array a of length n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number of triples trio (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a["}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets planet in our solar system arrangement: the closerst to the Sun \n   is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write spell a function that takes consider two planet satellite names as strings planet1 and planet2.\n   The function affair should return a tuple containing hold all planets whose orbits are \n   located between the orbit of planet1 and the orbit sphere of planet2, sorted classify by \n   the proximity to the sun. \n   The function routine should return an empty tuple if planet1 or planet2\n   are not correct planet names name calling.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* There are eight planets planet in our solar system arrangement: the closerst to the Sun \n   is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write spell a function that takes consider two planet satellite names as strings planet1 and planet2.\n   The function affair should return a tuple containing hold all planets whose orbits are \n   located between the orbit of planet1 and the orbit sphere of planet2, sorted classify by \n   the proximity to the sun. \n   The function routine should return an empty tuple if planet1 or planet2\n   are not correct planet names name calling.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planet1name = planet1.toLowerCase();\n  const planet2name = planet2.toLowerCase();\n  const planet1orbit = orbit(planet1name);\n  const planet2orbit = orbit(planet2name);\n  const planet1orbits = orbits(planet1name);\n  const planet2orbits = orbits(planet2name);\n  const planet1orbitssorted = orbitsSorted(planet1name);\n  const planet2orbitssorted = orbitsSorted(planet2name);\n  const planet1orbitssorted2 = orbitsSorted2(planet1name);\n  const planet2orbitssorted2 = orbitsSorted2(planet2name);\n  const planet1orbitssorted3 = orbitsSorted3(planet1name);\n  const planet2orbitssorted3 = orbitsSorted3(planet2name);\n  const planet1orbitssorted4 = orbitsSorted4(planet1name);\n  const planet2orbitssorted4 = orbitsSorted4(planet2name);\n  const planet1orbitssorted5 = orbitsSorted5(planet1name);\n  const planet2orbitssorted5 = orbitsSorted5(planet2name);\n  const planet1orbitssorted6 = orbitsSorted6(planet1name);\n  const planet2orbitssorted6 = orbitsSorted6(planet2name);\n  const planet1orbitssorted7 = orbitsSorted7(planet1name);\n  const planet2orbitssorted7 = orbitsSorted7(planet2name);\n  const planet1orbitssorted8 = orbitsSorted8(planet1name);\n  const planet2orbitssorted8 = orbitsSorted8(planet2name);\n  const planet1orbitssorted9 = orbitsSorted9(planet1name);\n  const planet2orbitssorted9 = orbitsSorted9(planet2name);\n  const planet1orbitssorted10 = orbitsSorted10(planet1name);\n  const planet2orbitssorted10 = orbitsSorted10(planet2name);\n  const planet1orbitssorted11 = orbitsSorted11(planet1name);\n  const planet2orbitssorted11 = orbitsSorted11(planet2name);\n  const planet1orbitssorted12 = orbitsSorted12(planet1name);\n  const planet2orbitssorted12 = orbitsSorted12(planet2name);\n  const planet1orbitssorted13 = orbitsSorted13(planet1name);\n  const planet2orbitssorted13 = orbitsSorted13(planet2name);\n  const planet1orbitssorted14 = orbitsSorted14(planet1name);\n  const planet2orbitssorted14 = orbitsSorted14(planet2name);\n  const planet1orbitssorted15 = orbitsSorted15(planet1name);\n  const planet2orbitssorted15 = orbitsSorted15(planet2name);\n  const planet1orbitssorted16 = orbitsSorted16(planet1name);\n  const planet2orbitssorted16 = orbitsSorted16(planet2name);\n  const planet1orbitssorted17 = orbitsSorted17(planet1name);\n  const planet2orbitssorted17 = orbitsSorted17(planet2name);\n  const planet1orbitssorted18 = orbitsSorted18(planet1name);\n  const planet2orbitssorted18 = orbitsSorted18(planet2name);\n  const planet1orbitssorted19 = orbitsSorted19(planet1name);\n  const planet2orbitssorted19 = orbitsSorted19(planet2name);\n  const planet1orbitssorted20 = orbitsSorted20(planet1name);\n  const planet2orbitssorted20 = orbitsSorted20(planet2name);\n  const planet1orbitssorted21 = orbitsSorted21(planet1name);\n  const planet2orbitssorted21 = orbitsSorted21(planet2name);\n  const planet1orbitssorted22 = orbitsSorted22(planet1name);\n  const planet2orbitssorted22 = orbitsSorted22(planet2name);\n  const planet1orbitssorted23 = orbitsSorted23(planet1name);\n  const planet2orbitssorted23 = orbitsSorted23(planet2name);\n  const planet1orbitssorted24 = orbitsSorted24(planet1name);\n  const planet2orbitssorted24 = orbitsSorted24(planet2name);\n  const planet1orbitssorted25 = orbitsSorted25(planet1name);\n  const planet2orbitssorted25 = orbitsSorted25(planet2name);\n  const planet1orbitssorted26 = orbitsSorted26(planet1name);\n  const planet2orbitssorted26 = orbitsSorted26(planet2name);\n  const planet1orbitssorted27 = orbitsSorted27(planet1name);\n  const planet2orbitssorted27 = orbitsSorted27(planet2name);\n  const planet1orbitssorted28 = orbitsSorted28(planet1name);\n  const planet2orbitssorted28 = orbitsSorted28(planet2name);\n  const planet1orbitssorted29 = orbitsSorted29(planet1name);\n  const planet2orbitssorted29 = orbitsSorted29(planet2name);\n  const planet1orbitssorted30 = orbitsSorted30(planet1name);\n  const planet2orbitssorted30 = orbitsSorted30(planet2name);\n  const planet1orbitssorted31 = orbitsSorted31(planet1name);\n  const planet2orbitssorted31 = orbitsSorted31(planet2name);\n  const planet1orbitssorted32 = orbitsSorted32(planet1name);\n  const planet2orbitssorted32 = orbitsSorted32(planet2name);\n  const planet1orbitssorted33 = orbitsSorted33(planet1name);\n  const planet2orbitssorted33 = orbitsSorted33(planet2name);\n  const planet1orbitssorted34 = orbits"}
{"task_id": "JavaScript/149", "prompt": "/*Write a function affair that accepts take a list of strings bowed stringed instrument as a parameter argument, \n   deletes the strings bowed stringed instrument that have odd curious lengths from it, \n   and returns the resulted leave list with a sorted classify order, \n   The list is always a list of strings and never an array of numbers, \n   and it may contain incorporate duplicates duplicate. \n   The order of the list should be ascending ascend by length of each word, and you \n   should return the list sorted screen by that rule. \n   If two words discussion have the same length duration, sort the list alphabetically. \n   The function routine should return a list of strings in sorted screen order decree. \n   You may assume that all words will have the same length duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Write a function affair that accepts take a list of strings bowed stringed instrument as a parameter argument, \n   deletes the strings bowed stringed instrument that have odd curious lengths from it, \n   and returns the resulted leave list with a sorted classify order, \n   The list is always a list of strings and never an array of numbers, \n   and it may contain incorporate duplicates duplicate. \n   The order of the list should be ascending ascend by length of each word, and you \n   should return the list sorted screen by that rule. \n   If two words discussion have the same length duration, sort the list alphabetically. \n   The function routine should return a list of strings in sorted screen order decree. \n   You may assume that all words will have the same length duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return [...new Set(sum)];\n};\n\n/*Write a function affair that accepts take a list of strings bowed stringed instrument as a parameter argument, \n   deletes the strings bowed stringed instrument that have odd curious lengths from it, \n   and returns the resulted leave list with a sorted classify order, \n   The list is always a list of strings and never an array of numbers, \n   and it may contain incorporate duplicates duplicate. \n   The order of the list should be ascending ascend by length of each word, and you \n   should return the list sorted screen by that rule. \n   If two words discussion have the same length duration, sort the list alphabetically. \n   The function routine should return a list of strings in sorted screen order decree. \n   You may assume that all words will have the same length duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListLength = (lst) => {\n  let length = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      length += 1;\n    }\n  }\n  return [...new Set(length)];\n};\n\n/*Write a function affair that accepts take a list of strings bowed stringed instrument as a parameter argument, \n   deletes the strings bowed stringed instrument that have odd curious lengths from it, \n   and returns the resulted leave list with a sorted classify order, \n   The list is always a list of strings and never an array of numbers, \n   and it may contain incorporate duplicates duplicate. \n   The order of the list should be ascending ascend by length of each word, and you \n   should return the list sorted screen by that rule. \n   If two words discussion have the same length duration, sort the list alphabetically. \n   The function routine should return a list of strings in sorted screen order decree. \n   You may assume that all words will have the same length duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListAlphabetically = (lst) => {\n  let alphabeticallySortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      alphabeticallySortedList.push(lst[i]);\n    }\n  }\n  return alphabeticallySortedList;\n};\n\n/*Write a function affair that accepts take a list of strings bowed stringed instrument as a parameter argument, \n   deletes the strings bowed stringed instrument that have odd curious lengths from it, \n   and returns the resulted leave list with a sorted classify order, \n   The list is always a list of strings and never an array of numbers, \n   and it may contain incorporate duplicates duplicate. \n   The order of the list should be ascending ascend by length of each word, and you \n   should return the list sorted screen by that rule. \n   If two words discussion have the same length duration, sort the list alphabetically. \n   The function routine should return a list of strings in sorted screen order decree. \n   You may assume that all words will have the same length duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListAlphabeticallySortedList = (lst) => {\n  let alphabeticallySortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      alphabeticallySortedList.push(lst[i]);\n    }\n  }\n  return alphabeticallySortedList.sort((a, b) => a.length - b.length);\n};\n\n/*Write a function affair that accepts take a list of strings bowed stringed instrument as a parameter argument, \n   deletes the strings bowed stringed instrument that have odd curious lengths from it, \n   and returns the resulted leave list with a sorted classify order, \n   The list is always a list of strings and never an array of numbers, \n   and it may contain incorporate duplicates duplicate. \n   The order of the list should be ascending ascend by length of each word, and you \n   should return the list sorted screen by that rule. \n   If two words discussion have the same length duration, sort the list alphabetically. \n   The function routine should return a list of strings in sorted screen order decree. \n   You may assume that all words will have the same length duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListAlphabeticallySortedListAlphabeticallySortedList = (lst) => {\n  let alphabeticallySortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      alphabeticallySortedList.push(lst[i]);\n    }\n  }\n  return alphabeticallySortedList.sort((a, b) => a.length - b.length);\n};\n\n/*Write a function affair that accepts take a list of strings bowed stringed instrument as a parameter argument, \n   deletes the strings bowed stringed instrument that have odd curious lengths from it, \n   and returns the resulted leave list with a sorted classify order, \n   The list is always a list of strings and never an array of numbers, \n   and it may contain incorporate duplicates duplicate. \n   The order of the list should be ascending ascend by length of each word, and you \n   should return the list sorted screen by that rule. \n   If two words discussion have the same length duration, sort the list alphabetically. \n   The function routine should return a list of strings in sorted screen order decree. \n   You may assume that all words will have the same length duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListAlphabeticallySortedListAlphabeticallySortedListAlphabeticallySortedList = (lst) => {\n  let alphabeticallySortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      alphabeticallySortedList.push(lst[i]);\n    }\n  }\n  return alphabeticallySortedList.sort((a, b) => a.length - b.length);\n};\n\n/*Write a function affair that accepts take a list of strings bowed stringed instrument as a parameter argument, \n   deletes the strings bowed stringed instrument that have odd curious lengths from it, \n   and returns the resulted leave list with a "}
{"task_id": "JavaScript/150", "prompt": "/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 1 || n > 100) {\n    throw new Error('n must be between 1 and 100');\n  }\n  if (x === 0 || y === 0) {\n    return y;\n  }\n  if (n % x === 0) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrY(n - x, n - y, y);\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrZ = (n, x, y) => {\n  if (n < 1 || n > 100) {\n    throw new Error('n must be between 1 and 100');\n  }\n  if (x === 0 || y === 0) {\n    return y;\n  }\n  if (n % x === 0) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrZ(n - x, n - y, y);\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrZ(7, 34, 12) == 34\n  for xOrZ(15, 8, 5) == 5\n  \n  */\nconst xOrW = (n, x, y) => {\n  if (n < 1 || n > 100) {\n    throw new Error('n must be between 1 and 100');\n  }\n  if (x === 0 || y === 0) {\n    return y;\n  }\n  if (n % x === 0) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrW(n - x, n - y, y);\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrW(7, 34, 12) == 34\n  for xOrW(15, 8, 5) == 5\n  \n  */\nconst xOrX = (n, x, y) => {\n  if (n < 1 || n > 100) {\n    throw new Error('n must be between 1 and 100');\n  }\n  if (x === 0 || y === 0) {\n    return y;\n  }\n  if (n % x === 0) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrX(n - x, n - y, y);\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrX(7, 34, 12) == 34\n  for xOrX(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 1 || n > 100) {\n    throw new Error('n must be between 1 and 100');\n  }\n  if (x === 0 || y === 0) {\n    return y;\n  }\n  if (n % x === 0) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrY(n - x, n - y, y);\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrZ = (n, x, y) => {\n  if (n < 1 || n > 100) {\n    throw new Error('n must be between 1 and 100');\n  }\n  if (x === 0 || y === 0) {\n    return y;\n  }\n  if (n % x === 0) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrZ(n - x, n - y, y);\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrZ(7, 34, 12) == 34\n  for xOrZ(15, 8, 5) == 5\n  \n  */\nconst xOrW = (n, x, y) => {\n  if (n < 1 || n > 100) {\n    throw new Error('n must be between 1 and 100');\n  }\n  if (x === 0 || y === 0) {\n    return y;\n  }\n  if (n % x === 0) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrW(n - x, n - y, y);\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrW(7, 34, 12) == 34\n  for xOrW(15, 8, 5) == 5\n  \n  */\nconst xOrX = (n, x, y) => {\n  if (n < 1 || n > 100) {\n    throw new Error('n must be between 1 and 100');\n  }\n  if (x === 0 || y === 0) {\n    return y;\n  }\n  if (n % x === 0) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrX(n - x, n - y, y);\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrX(7, 34, 12) == 34\n  for xOrX(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 1 || n > 100) {\n    throw new Error('n must be between 1 and 100');\n  }\n  if (x === 0 || y === 0) {\n    return y;\n  }\n  if (n % x === 0) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrY(n - x, n - y, y);\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrZ = (n, x, y) => {\n  if (n < 1 || n > 100) {\n    throw new Error('n must be between 1 and 100');\n  }\n  if (x === 0 || y === 0) {\n    return y;\n  }\n  if (n % x === 0) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrZ(n - x, n - y, y);\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrZ(7, 34, 12) == 34\n  for xOrZ(15, 8, 5) == 5\n  \n  */\nconst xOrW = (n, x, y) => {\n  if (n < 1 || n > 100) {\n    throw new Error('n must be between 1 and 100');\n  }\n  if (x === 0 || y === 0) {\n    return y;\n  }\n  if (n % x === 0) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrW(n - x, n - y, y);\n};\n\n/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrW(7, 34, 12) == 34\n  for xOrW(15, 8, 5) == 5\n  \n  */\nconst xOrX = (n, x, y) => {\n  if (n < 1 || n > 100) {\n    throw new Error('n must be between 1 and 100');\n  }\n  if (x === 0 || y === 0) {\n    return y;\n  }\n  if ("}
{"task_id": "JavaScript/151", "prompt": "/* Given impart a list of numbers phone number, return the sum union of squares of the numbers \n   in the list that are odd leftover. Ignore numbers numeral that are negative damaging or not integers integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input remark list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Given impart a list of numbers phone number, return the sum union of squares of the numbers \n   in the list that are odd leftover. Ignore numbers numeral that are negative damaging or not integers integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input remark list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   let sum = 0;\n   let count = 0;\n   let oddSum = 0;\n   let oddCount = 0;\n   let oddSum2 = 0;\n   let oddCount2 = 0;\n   let oddSum3 = 0;\n   let oddCount3 = 0;\n   let oddSum4 = 0;\n   let oddCount4 = 0;\n   let oddSum5 = 0;\n   let oddCount5 = 0;\n   let oddSum6 = 0;\n   let oddCount6 = 0;\n   let oddSum7 = 0;\n   let oddCount7 = 0;\n   let oddSum8 = 0;\n   let oddCount8 = 0;\n   let oddSum9 = 0;\n   let oddCount9 = 0;\n   let oddSum10 = 0;\n   let oddCount10 = 0;\n   let oddSum11 = 0;\n   let oddCount11 = 0;\n   let oddSum12 = 0;\n   let oddCount12 = 0;\n   let oddSum13 = 0;\n   let oddCount13 = 0;\n   let oddSum14 = 0;\n   let oddCount14 = 0;\n   let oddSum15 = 0;\n   let oddCount15 = 0;\n   let oddSum16 = 0;\n   let oddCount16 = 0;\n   let oddSum17 = 0;\n   let oddCount17 = 0;\n   let oddSum18 = 0;\n   let oddCount18 = 0;\n   let oddSum19 = 0;\n   let oddCount19 = 0;\n   let oddSum20 = 0;\n   let oddCount20 = 0;\n   let oddSum21 = 0;\n   let oddCount21 = 0;\n   let oddSum22 = 0;\n   let oddCount22 = 0;\n   let oddSum23 = 0;\n   let oddCount23 = 0;\n   let oddSum24 = 0;\n   let oddCount24 = 0;\n   let oddSum25 = 0;\n   let oddCount25 = 0;\n   let oddSum26 = 0;\n   let oddCount26 = 0;\n   let oddSum27 = 0;\n   let oddCount27 = 0;\n   let oddSum28 = 0;\n   let oddCount28 = 0;\n   let oddSum29 = 0;\n   let oddCount29 = 0;\n   let oddSum30 = 0;\n   let oddCount30 = 0;\n   let oddSum31 = 0;\n   let oddCount31 = 0;\n   let oddSum32 = 0;\n   let oddCount32 = 0;\n   let oddSum33 = 0;\n   let oddCount33 = 0;\n   let oddSum34 = 0;\n   let oddCount34 = 0;\n   let oddSum35 = 0;\n   let oddCount35 = 0;\n   let oddSum36 = 0;\n   let oddCount36 = 0;\n   let oddSum37 = 0;\n   let oddCount37 = 0;\n   let oddSum38 = 0;\n   let oddCount38 = 0;\n   let oddSum39 = 0;\n   let oddCount39 = 0;\n   let oddSum40 = 0;\n   let oddCount40 = 0;\n   let oddSum41 = 0;\n   let oddCount41 = 0;\n   let oddSum42 = 0;\n   let oddCount42 = 0;\n   let oddSum43 = 0;\n   let oddCount43 = 0;\n   let oddSum44 = 0;\n   let oddCount44 = 0;\n   let oddSum45 = 0;\n   let oddCount45 = 0;\n   let oddSum46 = 0;\n   let oddCount46 = 0;\n   let oddSum47 = 0;\n   let oddCount47 = 0;\n   let oddSum48 = 0;\n   let oddCount48 = 0;\n   let oddSum49 = 0;\n   let oddCount49 = 0;\n   let oddSum50 = 0;\n   let oddCount50 = 0;\n   let oddSum51 = 0;\n   let oddCount51 = 0;\n   let oddSum52 = 0;\n   let oddCount52 = 0;\n   let oddSum53 = 0;\n   let oddCount53 = 0;\n   let oddSum54 = 0;\n   let oddCount54 = 0;\n   let oddSum55 = 0;\n   let oddCount55 = 0;\n   let oddSum56 = 0;\n   let oddCount56 = 0;\n   let oddSum57 = 0;\n   let oddCount57 = 0;\n   let oddSum58 = 0;\n   let oddCount58 = 0;\n   let oddSum59 = 0;\n   let oddCount59 = 0;\n   let oddSum60 = 0;\n   let oddCount60 = 0;\n   let oddSum61 = 0;\n   let oddCount61 = 0;\n   let oddSum62 = 0;\n   let oddCount62 = 0;\n   let oddSum63 = 0;\n   let oddCount63 = 0;\n   let oddSum64 = 0;\n   let oddCount64 = 0;\n   let oddSum65 = 0;\n   let oddCount65 = 0;\n   let oddSum66 = 0;\n   let oddCount66 = 0;\n   let oddSum67 = 0;\n   let oddCount67 = 0;\n   let oddSum68 = 0;\n   let oddCount68 = 0;\n   let oddSum69 = 0;\n   let oddCount69 = 0;\n   let oddSum70 = 0;\n   let oddCount70 = 0;\n   let oddSum71 = 0;\n   let oddCount71 = 0;\n   let oddSum72 = 0;\n   let oddCount72 = 0;\n   let oddSum73 = 0;\n   let oddCount73 = 0;\n   let oddSum74 = 0;\n   let oddCount74 = 0;\n   let oddSum75 = 0;\n   let oddCount75 = 0;\n   let oddSum76 = 0;\n   let oddCount76 = 0;\n   let oddSum77 = 0;\n   let oddCount77 = 0;\n   let oddSum78 = 0;\n   let oddCount78 = 0;\n   let oddSum79 = 0;\n   let oddCount79 = 0;\n   let oddSum80 = 0;\n   let oddCount80 = 0;\n   let oddSum81 = 0;\n   let oddCount81 = 0;\n   let oddSum82 = 0;\n   let oddCount82 = 0;\n   let oddSum83 = 0;\n   let oddCount83 = 0;\n   let oddSum84 = 0;\n   let oddCount84 = 0;\n   let oddSum85 = 0;\n   let oddCount85 = 0;\n   let oddSum86 = 0;\n   let oddCount86 = 0;\n   let oddSum87 = 0;\n   let oddCount87 = 0;\n   let oddSum88 = 0;\n   let oddCount88 = 0;\n   let oddSum89 = 0;\n   let oddCount89 = 0;\n   let oddSum90 = 0;\n   let oddCount90 = 0;\n   let oddSum91 = 0;\n   let oddCount91 = 0;\n   let oddSum92 = 0;\n   let oddCount92 = 0;\n   let oddSum93 = 0;\n   let oddCount93 = 0;\n   let oddSum94 = 0;\n   let oddCount94 = 0;\n   let oddSum95 = 0;\n   let oddCount95 = 0;\n   let oddSum96 = 0;\n   let oddCount96 = 0;\n   let oddSum97 = 0;\n   let oddCount97 = 0;\n   let oddSum98 = 0;\n   let oddCount98 = 0;\n   let oddSum99 = 0;\n   let oddCount99 = 0;\n   let oddSum100 = 0;\n   let oddCount100 = 0;\n   let oddSum101 = 0;\n   let oddCount101 = 0;\n   let oddSum102"}
{"task_id": "JavaScript/152", "prompt": "/*I think remember we all remember commend that feeling when the result solution of some long - awaited \n   event consequence is finally ultimately known. The feelings and thoughts thinking you have at that moment here and now are \n   definitely worth noting down and comparing. \n   Your task job is to determine settle if a person correctly guessed the results resultant role of a number of matches. \n   You are given establish two arrays of scores and guesses guess of equal adequate length distance, where each index shows express a match catch. \n   Return an array of the same length denoting how far off each guess was. If they have guessed guess correctly, \n   the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*I think remember we all remember commend that feeling when the result solution of some long - awaited \n   event consequence is finally ultimately known. The feelings and thoughts thinking you have at that moment here and now are \n   definitely worth noting down and comparing. \n   Your task job is to determine settle if a person correctly guessed the results resultant role of a number of matches. \n   You are given establish two arrays of scores and guesses guess of equal adequate length distance, where each index shows express a match catch. \n   Return an array of the same length denoting how far off each guess was. If they have guessed guess correctly, \n   the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const gameScores = game.map((score) => score);\n  const guessScores = guess.map((score) => score);\n  const gameScoreDifferences = gameScores.map((score) => Math.abs(score - guessScores[0]));\n  const gameScoreDifferenceDifferences = gameScoreDifferences.map((difference) => Math.abs(difference));\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferences.map"}
{"task_id": "JavaScript/153", "prompt": "/*You will be given impart the name of a class course (a string) and a list of extensions.\n   The extensions are to be used practice to load additional classes course to the class course. The \n   strength of the extension is as follows trace: Let get CAP be the number issue of the uppercase \n   letters in the extension reference's name, and let permit SM be the number of lowercase small letter letters \n   in the extension's name, the strength lastingness is given by the fraction CAP - SM. \n   You should find the strongest firm extension annex and return a string drawstring in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same strength, you should \n   choose the one that comes occur first foremost in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You will be given impart the name of a class course (a string) and a list of extensions.\n   The extensions are to be used practice to load additional classes course to the class course. The \n   strength of the extension is as follows trace: Let get CAP be the number issue of the uppercase \n   letters in the extension reference's name, and let permit SM be the number of lowercase small letter letters \n   in the extension's name, the strength lastingness is given by the fraction CAP - SM. \n   You should find the strongest firm extension annex and return a string drawstring in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same strength, you should \n   choose the one that comes occur first foremost in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let extension_strength = -1;\n  let extension_strongest_name = null;\n  let extension_strongest_strength = null;\n  let extension_strongest_extension = null;\n  let extension_strongest_extension_strength = null;\n  let extension_strongest_extension_strength_strongest = null;\n  let extension_strongest_extension_strength_strongest_name = null;\n  let extension_strongest_extension_strength_strongest_strength = null;\n  let extension_strongest_extension_strength_strongest_extension = null;\n  let extension_strongest_extension_strength_strongest_extension_strength = null;\n  let extension_strongest_extension_strength_strongest_extension_strength_strongest = null;\n  let extension_strongest_extension_strength_strongest_extension_strength_strongest_name = null;\n  let extension_strongest_extension_strength_strongest_extension_strength_strongest_strength = null;\n  let extension_strongest_extension_strength_strongest_extension_strength_strongest_extension = null;\n  let extension_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength = null;\n  let extension_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest = null;\n  let extension_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_name = null;\n  let extension_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_strength = null;\n  let extension_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension = null;\n  let extension_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest = null;\n  let extension_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_name = null;\n  let extension_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_strength = null;\n  let extension_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension = null;\n  let extension_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest = null;\n  let extension_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_name = null;\n  let extension_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_strength = null;\n  let extension_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest = null;\n  let extension_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_name = null;\n  let extension_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_strength = null;\n  let extension_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest = null;\n  let extension_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_name = null;\n  let extension_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_strength = null;\n  let extension_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest = null;\n  let extension_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_name = null;\n  let extension_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_strength = null;\n  let extension_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_strongest_extension_strength_"}
{"task_id": "JavaScript/154", "prompt": "/*You are given impart 2 words news. You need want to return true if the second word or any of its rotations rotation is a substring in the first beginning word \n   cycpatternCheck(\"abcd\",\"abd\") = > false \n   cycpatternCheck(\"hello\",\"ell\") = > true genuine \n   cycpatternCheck(\"whassup\",\"psus\") = > false fake \n   cycpatternCheck(\"abab\",\"baa\") = > true \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > true \n   * / \n const cycpatternCheck = (a, b) = > {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You are given impart 2 words news. You need want to return true if the second word or any of its rotations rotation is a substring in the first beginning word \n   cycpatternCheck(\"abcd\",\"abd\") = > false \n   cycpatternCheck(\"hello\",\"ell\") = > true genuine \n   cycpatternCheck(\"whassup\",\"psus\") = > false fake \n   cycpatternCheck(\"abab\",\"baa\") = > true \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > true \n   * / \n const cycpatternCheck = (a, b) = > {\n   let firstWord = a.split('')\n   let secondWord = b.split('')\n   let firstWordRotation = firstWord.map(x => x.split('').map(y => y.split(''))).flat()\n   let secondWordRotation = secondWord.map(x => x.split('').map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let secondWordRotation = secondWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let secondWordRotation = secondWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let secondWordRotation = secondWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let secondWordRotation = secondWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let secondWordRotation = secondWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let secondWordRotation = secondWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let secondWordRotation = secondWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let secondWordRotation = secondWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let secondWordRotation = secondWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let secondWordRotation = secondWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let secondWordRotation = secondWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let secondWordRotation = secondWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let secondWordRotation = secondWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let secondWordRotation = secondWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let secondWordRotation = secondWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let secondWordRotation = secondWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let secondWordRotation = secondWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let secondWordRotation = secondWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let secondWordRotation = secondWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let secondWordRotation = secondWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let secondWordRotation = secondWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let secondWordRotation = secondWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let secondWordRotation = secondWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let secondWordRotation = secondWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let secondWordRotation = secondWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let secondWordRotation = secondWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let secondWordRotation = secondWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let firstWordRotation = firstWordRotation.map(x => x.map(y => y.split(''))).flat()\n   let second"}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that has the number numeral of even and odd curious digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given an integer. return a tuple that has the number numeral of even and odd curious digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  let curiousDigit = 0;\n  let curiousDigitCount = 0;\n  let curiousDigitCount2 = 0;\n  let curiousDigitCount3 = 0;\n  let curiousDigitCount4 = 0;\n  let curiousDigitCount5 = 0;\n  let curiousDigitCount6 = 0;\n  let curiousDigitCount7 = 0;\n  let curiousDigitCount8 = 0;\n  let curiousDigitCount9 = 0;\n  let curiousDigitCount10 = 0;\n  let curiousDigitCount11 = 0;\n  let curiousDigitCount12 = 0;\n  let curiousDigitCount13 = 0;\n  let curiousDigitCount14 = 0;\n  let curiousDigitCount15 = 0;\n  let curiousDigitCount16 = 0;\n  let curiousDigitCount17 = 0;\n  let curiousDigitCount18 = 0;\n  let curiousDigitCount19 = 0;\n  let curiousDigitCount20 = 0;\n  let curiousDigitCount21 = 0;\n  let curiousDigitCount22 = 0;\n  let curiousDigitCount23 = 0;\n  let curiousDigitCount24 = 0;\n  let curiousDigitCount25 = 0;\n  let curiousDigitCount26 = 0;\n  let curiousDigitCount27 = 0;\n  let curiousDigitCount28 = 0;\n  let curiousDigitCount29 = 0;\n  let curiousDigitCount30 = 0;\n  let curiousDigitCount31 = 0;\n  let curiousDigitCount32 = 0;\n  let curiousDigitCount33 = 0;\n  let curiousDigitCount34 = 0;\n  let curiousDigitCount35 = 0;\n  let curiousDigitCount36 = 0;\n  let curiousDigitCount37 = 0;\n  let curiousDigitCount38 = 0;\n  let curiousDigitCount39 = 0;\n  let curiousDigitCount40 = 0;\n  let curiousDigitCount41 = 0;\n  let curiousDigitCount42 = 0;\n  let curiousDigitCount43 = 0;\n  let curiousDigitCount44 = 0;\n  let curiousDigitCount45 = 0;\n  let curiousDigitCount46 = 0;\n  let curiousDigitCount47 = 0;\n  let curiousDigitCount48 = 0;\n  let curiousDigitCount49 = 0;\n  let curiousDigitCount50 = 0;\n  let curiousDigitCount51 = 0;\n  let curiousDigitCount52 = 0;\n  let curiousDigitCount53 = 0;\n  let curiousDigitCount54 = 0;\n  let curiousDigitCount55 = 0;\n  let curiousDigitCount56 = 0;\n  let curiousDigitCount57 = 0;\n  let curiousDigitCount58 = 0;\n  let curiousDigitCount59 = 0;\n  let curiousDigitCount60 = 0;\n  let curiousDigitCount61 = 0;\n  let curiousDigitCount62 = 0;\n  let curiousDigitCount63 = 0;\n  let curiousDigitCount64 = 0;\n  let curiousDigitCount65 = 0;\n  let curiousDigitCount66 = 0;\n  let curiousDigitCount67 = 0;\n  let curiousDigitCount68 = 0;\n  let curiousDigitCount69 = 0;\n  let curiousDigitCount70 = 0;\n  let curiousDigitCount71 = 0;\n  let curiousDigitCount72 = 0;\n  let curiousDigitCount73 = 0;\n  let curiousDigitCount74 = 0;\n  let curiousDigitCount75 = 0;\n  let curiousDigitCount76 = 0;\n  let curiousDigitCount77 = 0;\n  let curiousDigitCount78 = 0;\n  let curiousDigitCount79 = 0;\n  let curiousDigitCount80 = 0;\n  let curiousDigitCount81 = 0;\n  let curiousDigitCount82 = 0;\n  let curiousDigitCount83 = 0;\n  let curiousDigitCount84 = 0;\n  let curiousDigitCount85 = 0;\n  let curiousDigitCount86 = 0;\n  let curiousDigitCount87 = 0;\n  let curiousDigitCount88 = 0;\n  let curiousDigitCount89 = 0;\n  let curiousDigitCount90 = 0;\n  let curiousDigitCount91 = 0;\n  let curiousDigitCount92 = 0;\n  let curiousDigitCount93 = 0;\n  let curiousDigitCount94 = 0;\n  let curiousDigitCount95 = 0;\n  let curiousDigitCount96 = 0;\n  let curiousDigitCount97 = 0;\n  let curiousDigitCount98 = 0;\n  let curiousDigitCount99 = 0;\n  let curiousDigitCount100 = 0;\n  let curiousDigitCount101 = 0;\n  let curiousDigitCount102 = 0;\n  let curiousDigitCount103 = 0;\n  let curiousDigitCount104 = 0;\n  let curiousDigitCount105 = 0;\n  let curiousDigitCount106 = 0;\n  let curiousDigitCount107 = 0;\n  let curiousDigitCount108 = 0;\n  let curiousDigitCount109 = 0;\n  let curiousDigitCount110 = 0;\n  let curiousDigitCount111 = 0;\n  let curiousDigitCount112 = 0;\n  let curiousDigitCount113 = 0;\n  let curiousDigitCount114 = 0;\n  let curiousDigitCount115 = 0;\n  let curiousDigitCount116 = 0;\n  let curiousDigitCount117 = 0;\n  let curiousDigitCount118 = 0;\n  let curiousDigitCount119 = 0;\n  let curiousDigitCount120 = 0;\n  let curiousDigitCount121 = 0;\n  let curiousDigitCount122 = 0;\n  let curiousDigitCount123 = 0;\n  let curiousDigitCount124 = 0;\n  let curiousDigitCount125 = 0;\n  let curiousDigitCount126 = 0;\n  let curiousDigitCount127 = 0;\n  let curiousDigitCount128 = 0;\n  let curiousDigitCount129 = 0;\n  let curiousDigitCount130 = 0;\n  let curiousDigitCount131 = 0;\n  let curiousDigitCount132 = 0;\n  let curiousDigitCount133 = 0;\n  let curiousDigitCount134 = 0;\n  let curiousDigitCount135 = 0;\n  let curiousDigitCount136 = 0;\n  let curiousDigitCount137 = 0;\n  let curiousDigitCount138 = 0;\n  let curiousDigitCount139 = 0;\n  let curiousDigitCount140 = 0;\n  let curiousDigitCount141 = 0;\n  let curiousDigitCount142 = 0;\n  let curiousDigitCount143 = 0;\n  let curiousDigitCount144 = 0;\n  let curiousDigitCount145 = 0;\n  let curiousDigitCount146 = 0;\n  let curiousDigitCount147 = 0;\n  let curiousDigitCount148 = 0;\n  let curiousDigitCount149 = 0;\n  let curiousDigitCount150 = 0;\n  let curiousDigitCount151 = 0;\n  let curiousDigitCount152 = 0;\n  let curiousDigitCount153 = 0;\n  let curiousDigitCount154 = 0;\n  let curiousDigitCount155 = 0;\n  let curiousDigitCount156 = 0;\n  let curiousDigitCount157 = 0;\n  let curiousDigitCount158 = 0;\n  let curiousDigitCount159 = 0;\n  let curiousDigitCount160 = 0;\n  let curiousDigitCount161 = 0;\n  let curiousDigitCount162 = 0;\n  let curiousDigitCount163"}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given impart a positive convinced integer, obtain receive its roman numeral equivalent as a string, \n   and return it in lowercase. \n   Restrictions limitation: 1 < = num < = 1000 \n\n   Examples case:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart a positive convinced integer, obtain receive its roman numeral equivalent as a string, \n   and return it in lowercase. \n   Restrictions limitation: 1 < = num < = 1000 \n\n   Examples case:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  let roman = '';\n  let num = (number + '');\n  let numArr = num.split('');\n  let numLen = numArr.length;\n  let numMod = numLen % 3;\n  let numMod2 = numLen % 5;\n  let numMod3 = numLen % 7;\n  let numMod4 = numLen % 9;\n  let numMod5 = numLen % 11;\n  let numMod6 = numLen % 13;\n  let numMod7 = numLen % 15;\n  let numMod8 = numLen % 17;\n  let numMod9 = numLen % 19;\n  let numMod10 = numLen % 21;\n  let numMod11 = numLen % 23;\n  let numMod12 = numLen % 25;\n  let numMod13 = numLen % 27;\n  let numMod14 = numLen % 29;\n  let numMod15 = numLen % 31;\n  let numMod16 = numLen % 33;\n  let numMod17 = numLen % 35;\n  let numMod18 = numLen % 37;\n  let numMod19 = numLen % 39;\n  let numMod20 = numLen % 41;\n  let numMod21 = numLen % 43;\n  let numMod22 = numLen % 45;\n  let numMod23 = numLen % 47; \n  let numMod24 = numLen % 49;\n  let numMod25 = numLen % 51;\n  let numMod26 = numLen % 53;\n  let numMod27 = numLen % 55;\n  let numMod28 = numLen % 57;\n  let numMod29 = numLen % 59;\n  let numMod30 = numLen % 61;\n  let numMod31 = numLen % 63;\n  let numMod32 = numLen % 65;\n  let numMod33 = numLen % 67;\n  let numMod34 = numLen % 69;\n  let numMod35 = numLen % 71;\n  let numMod36 = numLen % 73;\n  let numMod37 = numLen % 75;\n  let numMod38 = numLen % 77;\n  let numMod39 = numLen % 79;\n  let numMod40 = numLen % 81;\n  let numMod41 = numLen % 83;\n  let numMod42 = numLen % 85;\n  let numMod43 = numLen % 87;\n  let numMod44 = numLen % 89;\n  let numMod45 = numLen % 91;\n  let numMod46 = numLen % 93;\n  let numMod47 = numLen % 95;\n  let numMod48 = numLen % 97;\n  let numMod49 = numLen % 99;\n  let numMod50 = numLen % 101;\n  let numMod51 = numLen % 103;\n  let numMod52 = numLen % 105;\n  let numMod53 = numLen % 107;\n  let numMod54 = numLen % 109;\n  let numMod55 = numLen % 111;\n  let numMod56 = numLen % 113;\n  let numMod57 = numLen % 115;\n  let numMod58 = numLen % 117;\n  let numMod59 = numLen % 119;\n  let numMod60 = numLen % 121;\n  let numMod61 = numLen % 123;\n  let numMod62 = numLen % 125;\n  let numMod63 = numLen % 127;\n  let numMod64 = numLen % 129;\n  let numMod65 = numLen % 131;\n  let numMod66 = numLen % 133;\n  let numMod67 = numLen % 135;\n  let numMod68 = numLen % 137;\n  let numMod69 = numLen % 139;\n  let numMod70 = numLen % 141;\n  let numMod71 = numLen % 143;\n  let numMod72 = numLen % 145;\n  let numMod73 = numLen % 147;\n  let numMod74 = numLen % 149;\n  let numMod75 = numLen % 151;\n  let numMod76 = numLen % 153;\n  let numMod77 = numLen % 155;\n  let numMod78 = numLen % 157;\n  let numMod79 = numLen % 159;\n  let numMod80 = numLen % 161;\n  let numMod81 = numLen % 163;\n  let numMod82 = numLen % 165;\n  let numMod83 = numLen % 167;\n  let numMod84 = numLen % 169;\n  let numMod85 = numLen % 171;\n  let numMod86 = numLen % 173;\n  let numMod87 = numLen % 175;\n  let numMod88 = numLen % 177;\n  let numMod89 = numLen % 179;\n  let numMod90 = numLen % 181;\n  let numMod91 = numLen % 183;\n  let numMod92 = numLen % 185;\n  let numMod93 = numLen % 187;\n  let numMod94 = numLen % 189;\n  let numMod95 = numLen % 191;\n  let numMod96 = numLen % 193;\n  let numMod97 = numLen % 195;\n  let numMod98 = numLen % 197;\n  let numMod99 = numLen % 199;\n  let numMod100 = numLen % 201;\n  let numMod101 = numLen % 203;\n  let numMod102 = numLen % 205;\n  let numMod103 = numLen % 207;\n  let numMod104 = numLen % 209;\n  let numMod105 = numLen % 211;\n  let numMod106 = numLen % 213;\n  let numMod107 = numLen % 215;\n  let numMod108 = numLen % 217;\n  let numMod109 = numLen % 219;\n  let numMod110 = numLen % 221;\n  let numMod111 = numLen % 223;\n  let numMod112 = numLen % 225;\n  let numMod113 = numLen % 227;\n  let numMod114 = numLen % 229;\n  let numMod115 = numLen % 231;\n  let numMod116 = numLen % 233;\n  let numMod117 = numLen % 235;\n  let numMod118 = numLen % 237;\n  let numMod119 = numLen % 239;\n  let numMod120 = numLen % 241;\n  let numMod121 = numLen % 243;\n  let numMod122 = numLen % 245;\n  let numMod123 = numLen % 247;\n  let numMod124 = numLen % 249;\n  let numMod125 = numLen % 251;\n  let numMod126 = numLen % 253;\n  let numMod127 = numLen % 255;\n  let numMod128 = numLen % 257;\n  let numMod129 = numLen % 259;\n  let numMod"}
{"task_id": "JavaScript/157", "prompt": "/*\n Given impart the lengths distance of the three sides english of a triangle triangulum. Return true genuine if the three \n   sides english form imprint a right justly - angled slant triangle, false otherwise. \n   A right - angled fish triangle triangulum is a triangle in which one angle slant is right angle or \n   90 degree academic degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n Given impart the lengths distance of the three sides english of a triangle triangulum. Return true genuine if the three \n   sides english form imprint a right justly - angled slant triangle, false otherwise. \n   A right - angled fish triangle triangulum is a triangle in which one angle slant is right angle or \n   90 degree academic degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n  const side1Angle = Math.atan2(b, a);\n  const side2Angle = Math.atan2(c, b);\n  const side3Angle = Math.atan2(c, a);\n  return side1Angle > side2Angle && side1Angle < side3Angle && side2Angle < side3Angle;\n};\n\n/*\n Given impart the lengths distance of the three sides english of a triangle triangulum. Return true genuine if the three \n   sides english form imprint a left justly - angled slant triangle, false otherwise. \n   A left - angled fish triangle triangulum is a triangle in which one angle slant is left angle or \n   -90 degree academic degree.\n  Example:\n  leftAngleTriangle(3, 4, 5) == true\n  leftAngleTriangle(1, 2, 3) == false\n  */\nconst leftAngleTriangle = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n  const side1Angle = Math.atan2(b, a);\n  const side2Angle = Math.atan2(c, b);\n  const side3Angle = Math.atan2(c, a);\n  return side1Angle < side2Angle && side1Angle > side3Angle && side2Angle > side3Angle;\n};\n\n/*\n Given impart the lengths distance of the three sides english of a triangle triangulum. Return true genuine if the three \n   sides english form imprint a right justly - angled slant triangle, false otherwise. \n   A right - angled fish triangle triangulum is a triangle in which one angle slant is right angle or \n   90 degree academic degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n  const side1Angle = Math.atan2(b, a);\n  const side2Angle = Math.atan2(c, b);\n  const side3Angle = Math.atan2(c, a);\n  return side1Angle > side2Angle && side1Angle < side3Angle && side2Angle < side3Angle;\n};\n\n/*\n Given impart the lengths distance of the three sides english of a triangle triangulum. Return true genuine if the three \n   sides english form imprint a left justly - angled slant triangle, false otherwise. \n   A left - angled fish triangle triangulum is a triangle in which one angle slant is left angle or \n   -90 degree academic degree.\n  Example:\n  leftAngleTriangle(3, 4, 5) == true\n  leftAngleTriangle(1, 2, 3) == false\n  */\nconst leftAngleTriangle = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n  const side1Angle = Math.atan2(b, a);\n  const side2Angle = Math.atan2(c, b);\n  const side3Angle = Math.atan2(c, a);\n  return side1Angle < side2Angle && side1Angle > side3Angle && side2Angle > side3Angle;\n};\n\n/*\n Given impart the lengths distance of the three sides english of a triangle triangulum. Return true genuine if the three \n   sides english form imprint a right justly - angled slant triangle, false otherwise. \n   A right - angled fish triangle triangulum is a triangle in which one angle slant is right angle or \n   90 degree academic degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n  const side1Angle = Math.atan2(b, a);\n  const side2Angle = Math.atan2(c, b);\n  const side3Angle = Math.atan2(c, a);\n  return side1Angle > side2Angle && side1Angle < side3Angle && side2Angle < side3Angle;\n};\n\n/*\n Given impart the lengths distance of the three sides english of a triangle triangulum. Return true genuine if the three \n   sides english form imprint a left justly - angled slant triangle, false otherwise. \n   A left - angled fish triangle triangulum is a triangle in which one angle slant is left angle or \n   -90 degree academic degree.\n  Example:\n  leftAngleTriangle(3, 4, 5) == true\n  leftAngleTriangle(1, 2, 3) == false\n  */\nconst leftAngleTriangle = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n  const side1Angle = Math.atan2(b, a);\n  const side2Angle = Math.atan2(c, b);\n  const side3Angle = Math.atan2(c, a);\n  return side1Angle < side2Angle && side1Angle > side3Angle && side2Angle > side3Angle;\n};\n\n/*\n Given impart the lengths distance of the three sides english of a triangle triangulum. Return true genuine if the three \n   sides english form imprint a right justly - angled slant triangle, false otherwise. \n   A right - angled fish triangle triangulum is a triangle in which one angle slant is right angle or \n   90 degree academic degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n  const side1Angle = Math.atan2(b, a);\n  const side2Angle = Math.atan2(c, b);\n  const side3Angle = Math.atan2(c, a);\n  return side1Angle > side"}
{"task_id": "JavaScript/158", "prompt": "/*Write a function affair that accepts take a list of strings bowed stringed instrument. \n   The list contains contain different words. Return the word son with maximum maximal number \n   of unique characters quality. If multiple strings string have maximum number of unique \n   characters, return the one which comes come first foremost in lexicographical order ordering. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string \" \n   findMax([\"name\", \" enam \", \" game \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Write a function affair that accepts take a list of strings bowed stringed instrument. \n   The list contains contain different words. Return the word son with maximum maximal number \n   of unique characters quality. If multiple strings string have maximum number of unique \n   characters, return the one which comes come first foremost in lexicographical order ordering. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string \" \n   findMax([\"name\", \" enam \", \" game \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n   let max = 0;\n   let maxChar = 0;\n   let maxCharQuality = 0;\n   let maxCharQualityOrder = [];\n   let maxCharQualityOrderIndex = 0;\n   let maxCharQualityOrderIndex2 = 0;\n   let maxCharQualityOrderIndex3 = 0;\n   let maxCharQualityOrderIndex4 = 0;\n   let maxCharQualityOrderIndex5 = 0;\n   let maxCharQualityOrderIndex6 = 0;\n   let maxCharQualityOrderIndex7 = 0;\n   let maxCharQualityOrderIndex8 = 0;\n   let maxCharQualityOrderIndex9 = 0;\n   let maxCharQualityOrderIndex10 = 0;\n   let maxCharQualityOrderIndex11 = 0;\n   let maxCharQualityOrderIndex12 = 0;\n   let maxCharQualityOrderIndex13 = 0;\n   let maxCharQualityOrderIndex14 = 0;\n   let maxCharQualityOrderIndex15 = 0;\n   let maxCharQualityOrderIndex16 = 0;\n   let maxCharQualityOrderIndex17 = 0;\n   let maxCharQualityOrderIndex18 = 0;\n   let maxCharQualityOrderIndex19 = 0;\n   let maxCharQualityOrderIndex20 = 0;\n   let maxCharQualityOrderIndex21 = 0;\n   let maxCharQualityOrderIndex22 = 0;\n   let maxCharQualityOrderIndex23 = 0;\n   let maxCharQualityOrderIndex24 = 0;\n   let maxCharQualityOrderIndex25 = 0;\n   let maxCharQualityOrderIndex26 = 0;\n   let maxCharQualityOrderIndex27 = 0;\n   let maxCharQualityOrderIndex28 = 0;\n   let maxCharQualityOrderIndex29 = 0;\n   let maxCharQualityOrderIndex30 = 0;\n   let maxCharQualityOrderIndex31 = 0;\n   let maxCharQualityOrderIndex32 = 0;\n   let maxCharQualityOrderIndex33 = 0;\n   let maxCharQualityOrderIndex34 = 0;\n   let maxCharQualityOrderIndex35 = 0;\n   let maxCharQualityOrderIndex36 = 0;\n   let maxCharQualityOrderIndex37 = 0;\n   let maxCharQualityOrderIndex38 = 0;\n   let maxCharQualityOrderIndex39 = 0;\n   let maxCharQualityOrderIndex40 = 0;\n   let maxCharQualityOrderIndex41 = 0;\n   let maxCharQualityOrderIndex42 = 0;\n   let maxCharQualityOrderIndex43 = 0;\n   let maxCharQualityOrderIndex44 = 0;\n   let maxCharQualityOrderIndex45 = 0;\n   let maxCharQualityOrderIndex46 = 0;\n   let maxCharQualityOrderIndex47 = 0;\n   let maxCharQualityOrderIndex48 = 0;\n   let maxCharQualityOrderIndex49 = 0;\n   let maxCharQualityOrderIndex50 = 0;\n   let maxCharQualityOrderIndex51 = 0;\n   let maxCharQualityOrderIndex52 = 0;\n   let maxCharQualityOrderIndex53 = 0;\n   let maxCharQualityOrderIndex54 = 0;\n   let maxCharQualityOrderIndex55 = 0;\n   let maxCharQualityOrderIndex56 = 0;\n   let maxCharQualityOrderIndex57 = 0;\n   let maxCharQualityOrderIndex58 = 0;\n   let maxCharQualityOrderIndex59 = 0;\n   let maxCharQualityOrderIndex60 = 0;\n   let maxCharQualityOrderIndex61 = 0;\n   let maxCharQualityOrderIndex62 = 0;\n   let maxCharQualityOrderIndex63 = 0;\n   let maxCharQualityOrderIndex64 = 0;\n   let maxCharQualityOrderIndex65 = 0;\n   let maxCharQualityOrderIndex66 = 0;\n   let maxCharQualityOrderIndex67 = 0;\n   let maxCharQualityOrderIndex68 = 0;\n   let maxCharQualityOrderIndex69 = 0;\n   let maxCharQualityOrderIndex70 = 0;\n   let maxCharQualityOrderIndex71 = 0;\n   let maxCharQualityOrderIndex72 = 0;\n   let maxCharQualityOrderIndex73 = 0;\n   let maxCharQualityOrderIndex74 = 0;\n   let maxCharQualityOrderIndex75 = 0;\n   let maxCharQualityOrderIndex76 = 0;\n   let maxCharQualityOrderIndex77 = 0;\n   let maxCharQualityOrderIndex78 = 0;\n   let maxCharQualityOrderIndex79 = 0;\n   let maxCharQualityOrderIndex80 = 0;\n   let maxCharQualityOrderIndex81 = 0;\n   let maxCharQualityOrderIndex82 = 0;\n   let maxCharQualityOrderIndex83 = 0;\n   let maxCharQualityOrderIndex84 = 0;\n   let maxCharQualityOrderIndex85 = 0;\n   let maxCharQualityOrderIndex86 = 0;\n   let maxCharQualityOrderIndex87 = 0;\n   let maxCharQualityOrderIndex88 = 0;\n   let maxCharQualityOrderIndex89 = 0;\n   let maxCharQualityOrderIndex90 = 0;\n   let maxCharQualityOrderIndex91 = 0;\n   let maxCharQualityOrderIndex92 = 0;\n   let maxCharQualityOrderIndex93 = 0;\n   let maxCharQualityOrderIndex94 = 0;\n   let maxCharQualityOrderIndex95 = 0;\n   let maxCharQualityOrderIndex96 = 0;\n   let maxCharQualityOrderIndex97 = 0;\n   let maxCharQualityOrderIndex98 = 0;\n   let maxCharQualityOrderIndex99 = 0;\n   let maxCharQualityOrderIndex100 = 0;\n   let maxCharQualityOrderIndex101 = 0;\n   let maxCharQualityOrderIndex102 = 0;\n   let maxCharQualityOrderIndex103 = 0;\n   let maxCharQualityOrderIndex104 = 0;\n   let maxCharQualityOrderIndex105 = 0;\n   let maxCharQualityOrderIndex106 = 0;\n   let maxCharQualityOrderIndex107 = 0;\n   let maxCharQualityOrderIndex108 = 0;\n   let maxCharQualityOrderIndex109 = 0;\n   let maxCharQualityOrderIndex110 = 0;\n   let maxCharQualityOrderIndex111 = 0;\n   let maxCharQualityOrderIndex112 = 0;\n   let maxCharQualityOrderIndex113 = 0;\n   let maxCharQualityOrderIndex114 = 0;\n   let maxCharQualityOrderIndex115 = 0;\n   let maxCharQualityOrderIndex116 = 0;\n   let maxCharQualityOrderIndex117 = 0;\n   let maxCharQualityOrderIndex118 = 0;\n   let maxCharQualityOrderIndex119 = 0;\n   let maxCharQualityOrderIndex120 = 0;\n   let maxCharQualityOrderIndex121 = 0;\n   let maxCharQualityOrderIndex122 = 0;\n   let maxCharQualityOrderIndex123 = 0;\n   let maxCharQualityOrderIndex124 = 0;\n   let maxCharQualityOrderIndex125 = 0;\n   let maxCharQualityOrderIndex126 = 0;\n   let maxCharQualityOrderIndex127 = 0;\n   let maxCharQualityOrderIndex128 = 0;\n   let maxCharQualityOrderIndex129 = 0;\n   let maxCharQualityOrderIndex130 = 0;\n   let maxCharQualityOrderIndex131 = 0;\n   let maxCharQualityOrderIndex132 = 0;\n   let maxCharQualityOrderIndex133 = 0;\n   let maxCharQualityOrderIndex134 = 0;\n   let maxCharQualityOrderIndex135 = 0;\n   let maxCharQualityOrderIndex136 = 0;\n   let maxCharQualityOrderIndex137"}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry athirst rabbit lapin, and you already have eaten a certain sealed number of carrots, \n   but now you need to eat more carrots carrot to complete dispatch the day's meals. \n   you should return an array of [ total number of eaten feed carrots carrot after your meals, \n                                   the number of carrots left after your meals ] \n   if there are not enough adequate remaining carrots carrot, you will eat all remaining carrots, but will still even be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You're a hungry athirst rabbit lapin, and you already have eaten a certain sealed number of carrots, \n   but now you need to eat more carrots carrot to complete dispatch the day's meals. \n   you should return an array of [ total number of eaten feed carrots carrot after your meals, \n                                   the number of carrots left after your meals ] \n   if there are not enough adequate remaining carrots carrot, you will eat all remaining carrots, but will still even be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const carrots = Math.floor(number * Math.pow(need, number))\n  const remaining = Math.min(remaining, carrots)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = Math.min(carrots, carrotAfter)\n  const carrotLeft = carrots - remaining\n  const carrotAfter = carrotLeft - number\n  const carrots = "}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given impart two lists tilt operator, and operand. The first list has basic algebra operations process, and \n   the second list is a list of integers. Use practice the two given yield lists tilt to build build up the algebric \n   expression formula and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart two lists tilt operator, and operand. The first list has basic algebra operations process, and \n   the second list is a list of integers. Use practice the two given yield lists tilt to build build up the algebric \n   expression formula and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  if (operatorLength < operandLength) {\n    operandLength = operatorLength;\n  }\n  for (let i = 0; i < operandLength; i++) {\n    result += operator[i % operatorLength](operand[i]);\n  }\n  return result;\n};\n\n/*\n  Given impart two lists tilt operator, and operand. The first list has basic algebra operations process, and \n   the second list is a list of integers. Use practice the two given yield lists tilt to build build up the algebric \n   expression formula and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  if (operatorLength < operandLength) {\n    operandLength = operatorLength;\n  }\n  for (let i = 0; i < operandLength; i++) {\n    result += operator[i % operatorLength](operand[i]);\n  }\n  return result;\n};\n\n/*\n  Given impart two lists tilt operator, and operand. The first list has basic algebra operations process, and \n   the second list is a list of integers. Use practice the two given yield lists tilt to build build up the algebric \n   expression formula and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  if (operatorLength < operandLength) {\n    operandLength = operatorLength;\n  }\n  for (let i = 0; i < operandLength; i++) {\n    result += operator[i % operatorLength](operand[i]);\n  }\n  return result;\n};\n\n/*\n  Given impart two lists tilt operator, and operand. The first list has basic algebra operations process, and \n   the second list is a list of integers. Use practice the two given yield lists tilt to build build up the algebric \n   expression formula and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  if (operatorLength < operandLength) {\n    operandLength = operatorLength;\n  }\n  for (let i = 0; i < operandLength; i++) {\n    result += operator[i % operatorLength](operand[i]);\n  }\n  return result;\n};\n\n/*\n  Given impart two lists tilt operator, and operand. The first list has basic algebra operations process, and \n   the second list is a list of integers. Use practice the two given yield lists tilt to build build up the algebric \n   expression formula and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  if (operatorLength < operandLength) {\n    operandLength = operatorLength;\n  }\n  for (let i = 0; i < operandLength; i++) {\n    result += operator[i % operatorLength](operand[i]);\n  }\n  return result;\n};\n\n/*\n  Given impart two lists tilt operator, and operand. The first list has basic algebra operations process, and \n   the second list is a list of integers. Use practice the two given yield lists tilt to build build up the algebric \n   expression formula and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  if (operatorLength < operandLength) {\n    operandLength = operatorLength;\n  }\n  for (let i = 0; i < operandLength; i++) {\n    result += operator[i % operatorLength](operand[i]);\n  }\n  return result;\n};\n\n/*\n  Given impart two lists tilt operator, and operand. The first list has basic algebra operations process, and \n   the second list is a list of integers. Use practice the two given yield lists tilt to build build up the algebric \n   expression formul"}
{"task_id": "JavaScript/161", "prompt": "/*You are given impart a string bowed stringed instrument s.\n   if s[i] is a letter, reverse overrule its case casing from lower to upper or vise versa, \n   otherwise differently keep observe it as it is. \n   If the string contains no letters letter, reverse change by reversal the string. \n   The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You are given impart a string bowed stringed instrument s.\n   if s[i] is a letter, reverse overrule its case casing from lower to upper or vise versa, \n   otherwise differently keep observe it as it is. \n   If the string contains no letters letter, reverse change by reversal the string. \n   The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let result = ''\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a"}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given impart a string bowed stringed instrument 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart a string bowed stringed instrument 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given impart a string bowed stringed instrument 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given impart a string bowed stringed instrument 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given impart a string bowed stringed instrument 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given impart a string bowed stringed instrument 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given impart a string bowed stringed instrument 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given impart a string bowed stringed instrument 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given impart a string bowed stringed instrument 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given impart a string bowed stringed instrument 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given impart a string bowed stringed instrument 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given impart a string bowed stringed instrument 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given impart a string bowed stringed instrument 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given impart a string bowed stringed instrument 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given impart a string bowed stringed instrument 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('"}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given impart two positive convinced integers integer a and b, return the even digits between a\n   and b, in ascending rise order decree.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Given impart two positive convinced integers integer a and b, return the even digits between a\n   and b, in ascending rise order decree.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const result = [];\n  let i = a;\n  let j = b;\n  while (i > 0) {\n    result.push(i);\n    i = Math.floor(i / 2);\n  }\n  while (j > 0) {\n    result.push(j);\n    j = Math.floor(j / 2);\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the number of digits of n.\n */\nconst getDigits = n => {\n  const digits = [];\n  let i = 1;\n  while (n > 0) {\n    digits.unshift(n % 10);\n    n = Math.floor(n / 10);\n    i++;\n  }\n  return digits.length;\n};\n\n/**\n * Given a positive integer n, return the number of digits of n that divide evenly.\n */\nconst getDivideEvenDigits = n => {\n  const digits = getDigits(n);\n  let count = 0;\n  for (let i = 0; i < digits.length; i++) {\n    if (n % digits[i] == 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a positive integer n, return the number of digits of n that divide evenly with remainder.\n */\nconst getDivideEvenWithRemainder = n => {\n  const digits = getDigits(n);\n  let count = 0;\n  for (let i = 0; i < digits.length; i++) {\n    if (n % digits[i] == 0) {\n      count++;\n    }\n  }\n  return count + getDivideEvenDigits(n / digits[i]);\n};\n\n/**\n * Given a positive integer n, return the number of digits of n that divide evenly with remainder that divide evenly.\n */\nconst getDivideEvenWithRemainderWithRemainder = n => {\n  const digits = getDigits(n);\n  let count = 0;\n  for (let i = 0; i < digits.length; i++) {\n    if (n % digits[i] == 0) {\n      count++;\n    }\n  }\n  return count + getDivideEvenWithRemainder(n / digits[i]);\n};\n\n/**\n * Given a positive integer n, return the number of digits of n that divide evenly with remainder that divide evenly with remainder.\n */\nconst getDivideEvenWithRemainderWithRemainderWithRemainder = n => {\n  const digits = getDigits(n);\n  let count = 0;\n  for (let i = 0; i < digits.length; i++) {\n    if (n % digits[i] == 0) {\n      count++;\n    }\n  }\n  return count + getDivideEvenWithRemainderWithRemainder(n / digits[i]);\n};\n\n/**\n * Given a positive integer n, return the number of digits of n that divide evenly with remainder that divide evenly with remainder.\n */\nconst getDivideEvenWithRemainderWithRemainderWithRemainderWithRemainder = n => {\n  const digits = getDigits(n);\n  let count = 0;\n  for (let i = 0; i < digits.length; i++) {\n    if (n % digits[i] == 0) {\n      count++;\n    }\n  }\n  return count + getDivideEvenWithRemainderWithRemainderWithRemainder(n / digits[i]);\n};\n\n/**\n * Given a positive integer n, return the number of digits of n that divide evenly with remainder that divide evenly with remainder.\n */\nconst getDivideEvenWithRemainderWithRemainderWithRemainderWithRemainderWithRemainder = n => {\n  const digits = getDigits(n);\n  let count = 0;\n  for (let i = 0; i < digits.length; i++) {\n    if (n % digits[i] == 0) {\n      count++;\n    }\n  }\n  return count + getDivideEvenWithRemainderWithRemainderWithRemainderWithRemainder(n / digits[i]);\n};\n\n/**\n * Given a positive integer n, return the number of digits of n that divide evenly with remainder that divide evenly with remainder.\n */\nconst getDivideEvenWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainder = n => {\n  const digits = getDigits(n);\n  let count = 0;\n  for (let i = 0; i < digits.length; i++) {\n    if (n % digits[i] == 0) {\n      count++;\n    }\n  }\n  return count + getDivideEvenWithRemainderWithRemainderWithRemainderWithRemainderWithRemainder(n / digits[i]);\n};\n\n/**\n * Given a positive integer n, return the number of digits of n that divide evenly with remainder that divide evenly with remainder.\n */\nconst getDivideEvenWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainder = n => {\n  const digits = getDigits(n);\n  let count = 0;\n  for (let i = 0; i < digits.length; i++) {\n    if (n % digits[i] == 0) {\n      count++;\n    }\n  }\n  return count + getDivideEvenWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainder(n / digits[i]);\n};\n\n/**\n * Given a positive integer n, return the number of digits of n that divide evenly with remainder that divide evenly with remainder.\n */\nconst getDivideEvenWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainder = n => {\n  const digits = getDigits(n);\n  let count = 0;\n  for (let i = 0; i < digits.length; i++) {\n    if (n % digits[i] == 0) {\n      count++;\n    }\n  }\n  return count + getDivideEvenWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainder(n / digits[i]);\n};\n\n/**\n * Given a positive integer n, return the number of digits of n that divide evenly with remainder that divide evenly with remainder.\n */\nconst getDivideEvenWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainder = n => {\n  const digits = getDigits(n);\n  let count = 0;\n  for (let i = 0; i < digits.length; i++) {\n    if (n % digits[i] == 0) {\n      count++;\n    }\n  }\n  return count + getDivideEvenWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainder(n / digits[i]);\n};\n\n/**\n * Given a positive integer n, return the number of digits of n that divide evenly with remainder that divide evenly with remainder.\n */\nconst getDivideEvenWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainder = n => {\n  const digits = getDigits(n);\n  let count = 0;\n  for (let i = 0; i < digits.length; i++) {\n    if (n % digits[i] == 0) {\n      count++;\n    }\n  }\n  return count + getDivideEvenWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainder(n / digits[i]);\n};\n\n/**\n * Given a positive integer n, return the number of digits of n that divide evenly with remainder that divide evenly with remainder.\n */\nconst getDivideEvenWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainder = n => {\n  const digits = getDigits(n);\n  let count = 0;\n  for (let i = 0; i < digits.length; i++) {\n    if (n % digits[i] == 0) {\n      count++;\n    }\n  }\n  return count + getDivideEvenWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainderWithRemainder(n / digits[i]);\n"}
