{"task_id": "JavaScript/0", "prompt": "/* Check if in given list of numbers, are any two numbers closer cheeseparing to each other than \n   given render threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Check if in given list of numbers, are any two numbers closer cheeseparing to each other than \n   given render threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const closeElements = numbers.map(number => {\n    const diff = number - threshold;\n    return diff < 0? diff : -diff;\n  });\n  return closeElements.every(element => Math.abs(element) < 1e-10);\n};\n\n/* Check if given list of numbers are close to each other in given render threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  true\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  false\n  */\nconst isCloseTo = (numbers, threshold) => {\n  const closeElements = numbers.map(number => {\n    const diff = number - threshold;\n    return diff < 0? diff : -diff;\n  });\n  return closeElements.every(element => Math.abs(element) < 1e-10);\n};\n\n/* Check if given list of numbers are close to each other in given render threshold.\n  >>> isCloseTo([1.0, 2.0, 3.0], 0.5)\n  true\n  >>> isCloseTo([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  false\n  */\nconst isCloseToElements = (numbers, threshold) => {\n  const closeElements = numbers.map(number => {\n    const diff = number - threshold;\n    return diff < 0? diff : -diff;\n  });\n  return closeElements.every(element => Math.abs(element) < 1e-10);\n};\n\n/* Check if given list of numbers are close to each other in given render threshold.\n  >>> isCloseToElements([1.0, 2.0, 3.0], 0.5)\n  true\n  >>> isCloseToElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  false\n  */\nconst isCloseToElementsElements = (numbers, threshold) => {\n  const closeElements = numbers.map(number => {\n    const diff = number - threshold;\n    return diff < 0? diff : -diff;\n  });\n  return closeElements.every(element => Math.abs(element) < 1e-10);\n};\n\n/* Check if given list of numbers are close to each other in given render threshold.\n  >>> isCloseToElementsElements([1.0, 2.0, 3.0], 0.5)\n  true\n  >>> isCloseToElementsElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  false\n  */\nconst isCloseToElementsElementsElements = (numbers, threshold) => {\n  const closeElements = numbers.map(number => {\n    const diff = number - threshold;\n    return diff < 0? diff : -diff;\n  });\n  return closeElements.every(element => Math.abs(element) < 1e-10);\n};\n\n/* Check if given list of numbers are close to each other in given render threshold.\n  >>> isCloseToElementsElementsElements([1.0, 2.0, 3.0], 0.5)\n  true\n  >>> isCloseToElementsElementsElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  false\n  */\nconst isCloseToElementsElementsElementsElements = (numbers, threshold) => {\n  const closeElements = numbers.map(number => {\n    const diff = number - threshold;\n    return diff < 0? diff : -diff;\n  });\n  return closeElements.every(element => Math.abs(element) < 1e-10);\n};\n\n/* Check if given list of numbers are close to each other in given render threshold.\n  >>> isCloseToElementsElementsElementsElements([1.0, 2.0, 3.0], 0.5)\n  true\n  >>> isCloseToElementsElementsElementsElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  false\n  */\nconst isCloseToElementsElementsElementsElementsElements = (numbers, threshold) => {\n  const closeElements = numbers.map(number => {\n    const diff = number - threshold;\n    return diff < 0? diff : -diff;\n  });\n  return closeElements.every(element => Math.abs(element) < 1e-10);\n};\n\n/* Check if given list of numbers are close to each other in given render threshold.\n  >>> isCloseToElementsElementsElementsElementsElements([1.0, 2.0, 3.0], 0.5)\n  true\n  >>> isCloseToElementsElementsElementsElementsElementsElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  false\n  */\nconst isCloseToElementsElementsElementsElementsElementsElements = (numbers, threshold) => {\n  const closeElements = numbers.map(number => {\n    const diff = number - threshold;\n    return diff < 0? diff : -diff;\n  });\n  return closeElements.every(element => Math.abs(element) < 1e-10);\n};\n\n/* Check if given list of numbers are close to each other in given render threshold.\n  >>> isCloseToElementsElementsElementsElementsElementsElements([1.0, 2.0, 3.0], 0.5)\n  true\n  >>> isCloseToElementsElementsElementsElementsElementsElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  false\n  */\nconst isCloseToElementsElementsElementsElementsElementsElementsElements = (numbers, threshold) => {\n  const closeElements = numbers.map(number => {\n    const diff = number - threshold;\n    return diff < 0? diff : -diff;\n  });\n  return closeElements.every(element => Math.abs(element) < 1e-10);\n};\n\n/* Check if given list of numbers are close to each other in given render threshold.\n  >>> isCloseToElementsElementsElementsElementsElementsElementsElements([1.0, 2.0, 3.0], 0.5)\n  true\n  >>> isCloseToElementsElementsElementsElementsElementsElementsElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  false\n  */\nconst isCloseToElementsElementsElementsElementsElementsElementsElementsElements = (numbers, threshold) => {\n  const closeElements = numbers.map(number => {\n    const diff = number - threshold;\n    return diff < 0? diff : -diff;\n  });\n  return closeElements.every(element => Math.abs(element) < 1e-10);\n};\n\n/* Check if given list of numbers are close to each other in given render threshold.\n  >>> isCloseToElementsElementsElementsElementsElementsElementsElementsElementsElements([1.0, 2.0, 3.0], 0.5)\n  true\n  >>> isCloseToElementsElementsElementsElementsElementsElementsElementsElementsElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  false\n  */\nconst isCloseToElementsElementsElementsElementsElementsElementsElementsElementsElementsElements = (numbers, threshold) => {\n  const closeElements = numbers.map(number => {\n    const diff = number - threshold;\n    return diff < 0? diff : -diff;\n  });\n  return closeElements.every(element => Math.abs(element) < 1e-10);\n};\n\n/* Check if given list of numbers are close to each other in given render threshold.\n  >>> isCloseToElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElementsElement"}
{"task_id": "JavaScript/1", "prompt": "/* Input to this function is a string bowed stringed instrument containing control multiple groups of nested parentheses parenthesis. Your goal is to \n   separate those group into separate disjoined strings and return the list of those. \n   Separate groups are balanced (each open brace couple is properly closed) and not nested within each other \n   Ignore dismiss any spaces in the input input signal string bowed stringed instrument.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Input to this function is a string bowed stringed instrument containing control multiple groups of nested parentheses parenthesis. Your goal is to \n   separate those group into separate disjoined strings and return the list of those. \n   Separate groups are balanced (each open brace couple is properly closed) and not nested within each other \n   Ignore dismiss any spaces in the input input signal string bowed stringed instrument.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  let paren_groups = [];\n  let paren_group_stack = [];\n  let paren_group_stack_count = 0;\n  let paren_group_stack_top = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n  let paren_group_stack_top_count = 0;\n"}
{"task_id": "JavaScript/2", "prompt": "/* Given a positive floating float point compass point number, it can be decomposed into \n   and integer part (largest large integer smaller belittled than given number) and decimals decimal \n   (leftover part always smaller than 1). \n\n   Return the decimal part character of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Given a positive floating float point compass point number, it can be decomposed into \n   and integer part (largest large integer smaller belittled than given number) and decimals decimal \n   (leftover part always smaller than 1). \n\n   Return the decimal part character of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const decimal = number % 1;\n  const decimalPart = decimal > 0? decimal : 1;\n  const integerPart = Math.floor(number);\n  return integerPart + (decimalPart > 0? decimalPart : 0);\n};\n\n/* Given a positive integer number n, return the decimal part character of the number.\n  >>> truncateNumber(5)\n  0\n  */\nconst truncateInteger = (number) => {\n  const decimal = number % 1;\n  const decimalPart = decimal > 0? decimal : 1;\n  const integerPart = Math.floor(number);\n  return integerPart + (decimalPart > 0? decimalPart : 0);\n};\n\n/* Given a positive integer number n, return the integer part character of the number.\n  >>> truncateInteger(5)\n  0\n  */\nconst truncateIntegerPart = (number) => {\n  const decimal = number % 1;\n  const decimalPart = decimal > 0? decimal : 1;\n  const integerPart = Math.floor(number);\n  return integerPart + (decimalPart > 0? decimalPart : 0);\n};\n\n/* Given a positive integer number n, return the decimal part character of the number rounded to\n   the nearest integer.\n  >>> truncateIntegerPart(5)\n  0\n  */\nconst truncateIntegerPartRound = (number) => {\n  const decimal = number % 1;\n  const decimalPart = decimal > 0? decimal : 1;\n  const integerPart = Math.floor(number);\n  return integerPart + (decimalPart > 0? decimalPart : 0);\n};\n\n/* Given a positive integer number n, return the integer part character of the number rounded to\n   the nearest integer.\n  >>> truncateIntegerPartRound(5)\n  0\n  */\nconst truncateIntegerPartRoundPart = (number) => {\n  const decimal = number % 1;\n  const decimalPart = decimal > 0? decimal : 1;\n  const integerPart = Math.floor(number);\n  return integerPart + (decimalPart > 0? decimalPart : 0);\n};\n\n/* Given a positive integer number n, return the integer part character of the number rounded to\n   the nearest integer.\n  >>> truncateIntegerPartRoundPart(5)\n  0\n  */\nconst truncateIntegerPartRoundPartRound = (number) => {\n  const decimal = number % 1;\n  const decimalPart = decimal > 0? decimal : 1;\n  const integerPart = Math.floor(number);\n  return integerPart + (decimalPart > 0? decimalPart : 0);\n};\n\n/* Given a positive integer number n, return the integer part character of the number rounded to\n   the nearest integer.\n  >>> truncateIntegerPartRoundPartRound(5)\n  0\n  */\nconst truncateIntegerPartRoundPartRoundPart = (number) => {\n  const decimal = number % 1;\n  const decimalPart = decimal > 0? decimal : 1;\n  const integerPart = Math.floor(number);\n  return integerPart + (decimalPart > 0? decimalPart : 0);\n};\n\n/* Given a positive integer number n, return the integer part character of the number rounded to\n   the nearest integer.\n  >>> truncateIntegerPartRoundPartRoundPart(5)\n  0\n  */\nconst truncateIntegerPartRoundPartRoundPartRound = (number) => {\n  const decimal = number % 1;\n  const decimalPart = decimal > 0? decimal : 1;\n  const integerPart = Math.floor(number);\n  return integerPart + (decimalPart > 0? decimalPart : 0);\n};\n\n/* Given a positive integer number n, return the integer part character of the number rounded to\n   the nearest integer.\n  >>> truncateIntegerPartRoundPartRoundPartRound(5)\n  0\n  */\nconst truncateIntegerPartRoundPartRoundPartRoundPart = (number) => {\n  const decimal = number % 1;\n  const decimalPart = decimal > 0? decimal : 1;\n  const integerPart = Math.floor(number);\n  return integerPart + (decimalPart > 0? decimalPart : 0);\n};\n\n/* Given a positive integer number n, return the integer part character of the number rounded to\n   the nearest integer.\n  >>> truncateIntegerPartRoundPartRoundPartRoundPart(5)\n  0\n  */\nconst truncateIntegerPartRoundPartRoundPartRoundPartRound = (number) => {\n  const decimal = number % 1;\n  const decimalPart = decimal > 0? decimal : 1;\n  const integerPart = Math.floor(number);\n  return integerPart + (decimalPart > 0? decimalPart : 0);\n};\n\n/* Given a positive integer number n, return the integer part character of the number rounded to\n   the nearest integer.\n  >>> truncateIntegerPartRoundPartRoundPartRoundPartRoundPart(5)\n  0\n  */\nconst truncateIntegerPartRoundPartRoundPartRoundPartRoundPartRound = (number) => {\n  const decimal = number % 1;\n  const decimalPart = decimal > 0? decimal : 1;\n  const integerPart = Math.floor(number);\n  return integerPart + (decimalPart > 0? decimalPart : 0);\n};\n\n/* Given a positive integer number n, return the integer part character of the number rounded to\n   the nearest integer.\n  >>> truncateIntegerPartRoundPartRoundPartRoundPartRoundPartRoundPart(5)\n  0\n  */\nconst truncateIntegerPartRoundPartRoundPartRoundPartRoundPartRoundPartRound = (number) => {\n  const decimal = number % 1;\n  const decimalPart = decimal > 0? decimal : 1;\n  const integerPart = Math.floor(number);\n  return integerPart + (decimalPart > 0? decimalPart : 0);\n};\n\n/* Given a positive integer number n, return the integer part character of the number rounded to\n   the nearest integer.\n  >>> truncateIntegerPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPart(5)\n  0\n  */\nconst truncateIntegerPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRound = (number) => {\n  const decimal = number % 1;\n  const decimalPart = decimal > 0? decimal : 1;\n  const integerPart = Math.floor(number);\n  return integerPart + (decimalPart > 0? decimalPart : 0);\n};\n\n/* Given a positive integer number n, return the integer part character of the number rounded to\n   the nearest integer.\n  >>> truncateIntegerPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPart(5)\n  0\n  */\nconst truncateIntegerPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRound = (number) => {\n  const decimal = number % 1;\n  const decimalPart = decimal > 0? decimal : 1;\n  const integerPart = Math.floor(number);\n  return integerPart + (decimalPart > 0? decimalPart : 0);\n};\n\n/* Given a positive integer number n, return the integer part character of the number rounded to\n   the nearest integer.\n  >>> truncateIntegerPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPart(5)\n  0\n  */\nconst truncateIntegerPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRoundPartRound"}
{"task_id": "JavaScript/3", "prompt": "/* You're given a list of deposit and withdrawal operations on a bank depository financial institution account report that starts with \n   zero balance. Your task is to detect if at any point decimal point the balance of account history fallls below zero, and \n   at that point function routine should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* You're given a list of deposit and withdrawal operations on a bank depository financial institution account report that starts with \n   zero balance. Your task is to detect if at any point decimal point the balance of account history fallls below zero, and \n   at that point function routine should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\nmodule.exports = belowZero;\n\n},{}],13:[function(require,module,exports){\n/*\n  You are given a list of deposit and withdrawal operations on a bank depository financial institution account report that starts with \n   zero balance. Your task is to detect if at any point decimal point the balance of account history fallls below zero, and \n   at that point function routine should return true. Otherwise it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance > 0;\n};\n\nmodule.exports = belowZero;\n\n},{}],14:[function(require,module,exports){\n/*\n  You are given a list of deposit and withdrawal operations on a bank depository financial institution account report that starts with \n   zero balance. Your task is to detect if at any point decimal point the balance of account history fallls below zero, and \n   at that point function routine should return true. Otherwise it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\nmodule.exports = belowZero;\n\n},{}],15:[function(require,module,exports){\n/*\n  You are given a list of deposit and withdrawal operations on a bank depository financial institution account report that starts with \n   zero balance. Your task is to detect if at any point decimal point the balance of account history fallls below zero, and \n   at that point function routine should return true. Otherwise it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance > 0;\n};\n\nmodule.exports = belowZero;\n\n},{}],16:[function(require,module,exports){\n/*\n  You are given a list of deposit and withdrawal operations on a bank depository financial institution account report that starts with \n   zero balance. Your task is to detect if at any point decimal point the balance of account history fallls below zero, and \n   at that point function routine should return true. Otherwise it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\nmodule.exports = belowZero;\n\n},{}],17:[function(require,module,exports){\n/*\n  You are given a list of deposit and withdrawal operations on a bank depository financial institution account report that starts with \n   zero balance. Your task is to detect if at any point decimal point the balance of account history fallls below zero, and \n   at that point function routine should return true. Otherwise it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance > 0;\n};\n\nmodule.exports = belowZero;\n\n},{}],18:[function(require,module,exports){\n/*\n  You are given a list of deposit and withdrawal operations on a bank depository financial institution account report that starts with \n   zero balance. Your task is to detect if at any point decimal point the balance of account history fallls below zero, and \n   at that point function routine should return true. Otherwise it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\nmodule.exports = belowZero;\n\n},{}],19:[function(require,module,exports){\n/*\n  You are given a list of deposit and withdrawal operations on a bank depository financial institution account report that starts with \n   zero balance. Your task is to detect if at any point decimal point the balance of account history fallls below zero, and \n   at that point function routine should return true. Otherwise it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10, -12, -13, -14, -15, -16])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance > 0;\n};\n\nmodule.exports = belowZero;\n\n},{}],20:[function(require,module,exports){\n/*\n  You are given a list of deposit and withdrawal operations on a bank depository financial institution account report that starts with \n   zero balance. Your task is to detect if at any point decimal point the balance of account history fallls below zero, and \n   at that point function routine should return true. "}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average median absolute difference deviation between each \n   element and a centerpoint (mean in this case ): \n   MAD = average median | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* For a given list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average median absolute difference deviation between each \n   element and a centerpoint (mean in this case ): \n   MAD = average median | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansMean = means.reduce((a, b) => a + b, 0);\n  const meansMedian = means.reduce((a, b) => a + b) / 2;\n  const meansMeanDeviation = Math.sqrt(meansMean - meansMedian);\n  return meansMeanDeviation;\n};\n\n/* For a given list of input numbers, calculate Mean Squared Deviation \n   around the mean of this dataset. \n   Mean Squared Deviation is the square root of the average median squared deviation \n   between each element and a centerpoint (mean in this case ): \n   MSD = average median squared | x - x_mean |\n  >>> meanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  2.0\n  */\nconst meanSquaredDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansMean = means.reduce((a, b) => a + b, 0);\n  const meansMedian = means.reduce((a, b) => a + b) / 2;\n  const meansMeanSquared = meansMean - meansMedian * meansMedian;\n  return meansMeanSquared;\n};\n\n/* For a given list of input numbers, calculate Root Mean Squared Deviation \n   around the mean of this dataset. \n   Root Mean Squared Deviation is the square root of the average median squared deviation \n   between each element and a centerpoint (mean in this case ): \n   RMSE = average median squared | x - x_mean |\n  >>> rootMeanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst rootMeanSquaredDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansMean = means.reduce((a, b) => a + b, 0);\n  const meansMedian = means.reduce((a, b) => a + b) / 2;\n  const meansMeanSquared = meansMean - meansMedian * meansMedian;\n  const meansMeanDeviation = Math.sqrt(meansMeanSquared);\n  return meansMeanDeviation;\n};\n\n/* For a given list of input numbers, calculate Standard Deviation \n   around the mean of this dataset. \n   Standard Deviation is the square root of the average median squared deviation \n   between each element and a centerpoint (mean in this case ): \n   SD = average median squared | x - x_mean |\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansMean = means.reduce((a, b) => a + b, 0);\n  const meansMedian = means.reduce((a, b) => a + b) / 2;\n  const meansMeanSquared = meansMean - meansMedian * meansMedian;\n  const meansMeanDeviation = Math.sqrt(meansMeanSquared);\n  return meansMeanDeviation;\n};\n\n/* For a given list of input numbers, calculate Variance \n   around the mean of this dataset. \n   Variance is the square root of the average median squared deviation between each \n   element and a centerpoint (mean in this case ): \n   V = average median squared | x - x_mean |\n  >>> variance([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst variance = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansMean = means.reduce((a, b) => a + b, 0);\n  const meansMedian = means.reduce((a, b) => a + b) / 2;\n  const meansMeanSquared = meansMean - meansMedian * meansMedian;\n  const meansMeanDeviation = Math.sqrt(meansMeanSquared);\n  return meansMeanDeviation;\n};\n\n/* For a given list of input numbers, calculate Standard Deviation \n   around the median of this dataset. \n   Standard Deviation is the square root of the average median squared deviation \n   between each element and a centerpoint (mean in this case ): \n   SD = average median squared | x - x_median |\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  2.0\n  */\nconst standardDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansMedian = means.reduce((a, b) => a + b) / 2;\n  const meansMeanSquared = meansMedian - meansMedian * meansMedian;\n  const meansMeanDeviation = Math.sqrt(meansMeanSquared);\n  return meansMeanDeviation;\n};\n\n/* For a given list of input numbers, calculate Variance \n   around the median of this dataset. \n   Variance is the square root of the average median squared deviation between each \n   element and a centerpoint (mean in this case ): \n   V = average median squared | x - x_median |\n  >>> variance([1.0, 2.0, 3.0, 4.0])\n  2.0\n  */\nconst variance = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansMedian = means.reduce((a, b) => a + b) / 2;\n  const meansMeanSquared = meansMedian - meansMedian * meansMedian;\n  const meansMeanDeviation = Math.sqrt(meansMeanSquared);\n  return meansMeanDeviation;\n};\n\n/* For a given list of input numbers, calculate Standard Deviation \n   around the median of this dataset. \n   Standard Deviation is the square root of the average median squared deviation \n   between each element and a centerpoint (mean in this case ): \n   SD = average median squared | x - x_median |\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  2.0\n  */\nconst standardDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansMedian = means.reduce((a, b) => a + b) / 2;\n  const meansMeanSquared = meansMedian - meansMedian * meansMedian;\n  const meansMeanDeviation = Math.sqrt(meansMeanSquared);\n  return meansMeanDeviation;\n};\n\n/* For a given list of input numbers, calculate Standard Deviation \n   around the median of this dataset. \n   Standard Deviation is the square root of the average median squared deviation \n   between each element and a centerpoint (mean in this case ): \n   SD = average median squared | x - x_median |\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  2.0\n  */\nconst standardDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansMedian = means.reduce((a, b) => a + b) / 2;\n  const meansMeanSquared = means"}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number 'delimeter' between every two consecutive elements component of input stimulation list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Insert a number 'delimeter' between every two consecutive elements component of input stimulation list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < numbers.length) {\n    if (numbers[i] <= delimeter) {\n      result.push(numbers[i])\n      i++\n    } else {\n      result.push(numbers[i])\n      j++\n      if (j === delimeter) {\n        result.push(numbers[i])\n        j = 0\n        k++\n      }\n    }\n  }\n  return result\n}\n\n/**\n * Remove all occurrences of `delimeter` from input stimulation list `numbers`\n * and return a copy of `numbers` with occurrences removed\n * >>> remove('hello')\n  [1, 2]\n  >>> remove('hello', 2)\n  [2, 1]\n  >>> remove('hello', 3)\n  []\n  */\nconst remove = (numbers, delimeter) => {\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < numbers.length) {\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n    } else {\n      if (j === delimeter) {\n        result.push(numbers[i])\n        j = 0\n        k++\n      }\n    }\n  }\n  return result\n}\n\n/**\n * Remove all occurrences of `delimeter` from input stimulation list `numbers`\n * and return a copy of `numbers` with occurrences removed\n * >>> remove('hello', 2)\n  [1, 2]\n  >>> remove('hello', 3)\n  []\n  */\nconst remove = (numbers, delimeter) => {\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < numbers.length) {\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n    } else {\n      if (j === delimeter) {\n        result.push(numbers[i])\n        j = 0\n        k++\n      }\n    }\n  }\n  return result\n}\n\n/**\n * Remove all occurrences of `delimeter` from input stimulation list `numbers`\n * and return a copy of `numbers` with occurrences removed\n * >>> remove('hello', 2)\n  [1, 2]\n  >>> remove('hello', 3)\n  []\n  */\nconst remove = (numbers, delimeter) => {\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < numbers.length) {\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n    } else {\n      if (j === delimeter) {\n        result.push(numbers[i])\n        j = 0\n        k++\n      }\n    }\n  }\n  return result\n}\n\n/**\n * Remove all occurrences of `delimeter` from input stimulation list `numbers`\n * and return a copy of `numbers` with occurrences removed\n * >>> remove('hello', 2)\n  [1, 2]\n  >>> remove('hello', 3)\n  []\n  */\nconst remove = (numbers, delimeter) => {\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < numbers.length) {\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n    } else {\n      if (j === delimeter) {\n        result.push(numbers[i])\n        j = 0\n        k++\n      }\n    }\n  }\n  return result\n}\n\n/**\n * Remove all occurrences of `delimeter` from input stimulation list `numbers`\n * and return a copy of `numbers` with occurrences removed\n * >>> remove('hello', 2)\n  [1, 2]\n  >>> remove('hello', 3)\n  []\n  */\nconst remove = (numbers, delimeter) => {\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < numbers.length) {\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n    } else {\n      if (j === delimeter) {\n        result.push(numbers[i])\n        j = 0\n        k++\n      }\n    }\n  }\n  return result\n}\n\n/**\n * Remove all occurrences of `delimeter` from input stimulation list `numbers`\n * and return a copy of `numbers` with occurrences removed\n * >>> remove('hello', 2)\n  [1, 2]\n  >>> remove('hello', 3)\n  []\n  */\nconst remove = (numbers, delimeter) => {\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < numbers.length) {\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n    } else {\n      if (j === delimeter) {\n        result.push(numbers[i])\n        j = 0\n        k++\n      }\n    }\n  }\n  return result\n}\n\n/**\n * Remove all occurrences of `delimeter` from input stimulation list `numbers`\n * and return a copy of `numbers` with occurrences removed\n * >>> remove('hello', 2)\n  [1, 2]\n  >>> remove('hello', 3)\n  []\n  */\nconst remove = (numbers, delimeter) => {\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < numbers.length) {\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n    } else {\n      if (j === delimeter) {\n        result.push(numbers[i])\n        j = 0\n        k++\n      }\n    }\n  }\n  return result\n}\n\n/**\n * Remove all occurrences of `delimeter` from input stimulation list `numbers`\n * and return a copy of `numbers` with occurrences removed\n * >>> remove('hello', 2)\n  [1, 2]\n  >>> remove('hello', 3)\n  []\n  */\nconst remove = (numbers, delimeter) => {\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < numbers.length) {\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n    } else {\n      if (j === delimeter) {\n        result.push(numbers[i])\n        j = 0\n        k++\n      }\n    }\n  }\n  return result\n}\n\n/**\n * Remove all occurrences of `delimeter` from input stimulation list `numbers`\n * and return a copy of `numbers` with occurrences removed\n * >>> remove('hello', 2)\n  [1, 2]\n  >>> remove('hello', 3)\n  []\n  */\nconst remove = (numbers, delimeter) => {\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < numbers.length) {\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n    } else {\n      if (j === delimeter) {\n        result.push(numbers[i])\n        j = 0\n        k++\n      }\n    }\n  }\n  return result\n}\n\n/**\n * Remove all occurrences of `delimeter` from input stimulation list `numbers`\n * and return a copy of `numbers` with occurrences removed\n * >>> remove('hello', 2)\n  [1, 2]\n  >>> remove('hello', 3)\n  []\n  */\nconst remove = (numbers, delimeter) => {\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < numbers.length) {\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n    } else {\n      if (j === delimeter) {\n        result.push(numbers[i])\n        j = 0\n        k++\n      }\n    }\n  }\n  return result\n}\n\n/**\n * Remove all occurrences of `delimeter` from input stimulation list `numbers`\n * and return a copy of `numbers` with occurrences removed\n * >>> remove('hello', 2)\n  [1, 2]"}
{"task_id": "JavaScript/6", "prompt": "/* Input to this function is a string bowed stringed instrument represented exemplify multiple groups for nested parentheses separated separate by spaces outer space. \n   For each of the group, output the deepest level horizontal surface of nesting of parentheses. \n   E.g. (() ()) has maximum two levels of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Input to this function is a string bowed stringed instrument represented exemplify multiple groups for nested parentheses separated separate by spaces outer space. \n   For each of the group, output the deepest level horizontal surface of nesting of parentheses. \n   E.g. (() ()) has maximum two levels of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_stack = []\n  const paren_level = 0\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n  const paren_stack_count = 0\n  const paren_level_count = 0\n  const paren_stack = []\n  const paren_level = []\n  const paren_stack_size = 0\n  const paren_level_size = 0\n"}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input list of strings only for ones that contain check given render substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Filter an input list of strings only for ones that contain check given render substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1);\n};\n\n/**\n * Filter an input list of strings only for ones that contain check given render substring\n * >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n * ['abc', 'bacd', 'array']\n */\nconst filterBySubstringOnly = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for ones that contain check given render substring\n * >>> filterBySubstringOnly(['abc', 'bacd', 'cde', 'array'], 'a')\n * ['abc', 'bacd', 'array']\n */\nconst filterBySubstringOnlyIf = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1);\n};\n\n/**\n * Filter an input list of strings only for ones that contain check given render substring\n * >>> filterBySubstringOnlyIf('abc', 'a')\n * ['abc']\n */\nconst filterBySubstringOnlyIfNot = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for ones that contain check given render substring\n * >>> filterBySubstringOnlyIfNot('abc', 'a')\n * []\n */\nconst filterBySubstringOnlyIfNotEmpty = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1);\n};\n\n/**\n * Filter an input list of strings only for ones that contain check given render substring\n * >>> filterBySubstringOnlyIfNotEmpty(['abc', 'bacd', 'cde', 'array'], 'a')\n * ['abc', 'bacd', 'array']\n */\nconst filterBySubstringOnlyIfNotEmptyOnly = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for ones that contain check given render substring\n * >>> filterBySubstringOnlyIfNotEmptyOnly(['abc', 'bacd', 'cde', 'array'], 'a')\n * ['abc', 'bacd', 'array']\n */\nconst filterBySubstringOnlyIfNotEmptyOnlyIf = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1);\n};\n\n/**\n * Filter an input list of strings only for ones that contain check given render substring\n * >>> filterBySubstringOnlyIfNotEmptyOnlyIf('abc', 'a')\n * ['abc']\n */\nconst filterBySubstringOnlyIfNotEmptyOnlyIfNot = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for ones that contain check given render substring\n * >>> filterBySubstringOnlyIfNotEmptyOnlyIfNot('abc', 'a')\n * []\n */\nconst filterBySubstringOnlyIfNotEmptyOnlyIfNotEmpty = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1);\n};\n\n/**\n * Filter an input list of strings only for ones that contain check given render substring\n * >>> filterBySubstringOnlyIfNotEmptyOnlyIfNotEmpty(['abc', 'bacd', 'cde', 'array'], 'a')\n * ['abc', 'bacd', 'array']\n */\nconst filterBySubstringOnlyIfNotEmptyOnlyIfNotEmptyOnly = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for ones that contain check given render substring\n * >>> filterBySubstringOnlyIfNotEmptyOnlyIfNotEmptyOnlyIf('abc', 'a')\n * ['abc']\n */\nconst filterBySubstringOnlyIfNotEmptyOnlyIfNotEmptyOnlyIf = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1);\n};\n\n/**\n * Filter an input list of strings only for ones that contain check given render substring\n * >>> filterBySubstringOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNot('abc', 'a')\n * ['abc']\n */\nconst filterBySubstringOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNot = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for ones that contain check given render substring\n * >>> filterBySubstringOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmpty(['abc', 'bacd', 'cde', 'array'], 'a')\n * ['abc', 'bacd', 'array']\n */\nconst filterBySubstringOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmpty = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for ones that contain check given render substring\n * >>> filterBySubstringOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIf('abc', 'a')\n * ['abc']\n */\nconst filterBySubstringOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIf = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1);\n};\n\n/**\n * Filter an input list of strings only for ones that contain check given render substring\n * >>> filterBySubstringOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNot('abc', 'a')\n * ['abc']\n */\nconst filterBySubstringOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmpty = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for ones that contain check given render substring\n * >>> filterBySubstringOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNot('abc', 'a')\n * ['abc']\n */\nconst filterBySubstringOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNot = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for ones that contain check given render substring\n * >>> filterBySubstringOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNot('abc', 'a')\n * ['abc']\n */\nconst filterBySubstringOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmpty = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1);\n};\n\n/**\n * Filter an input list of strings only for ones that contain check given render substring\n * >>> filterBySubstringOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmpty = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for ones that contain check given render substring\n * >>> filterBySubstringOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmptyOnlyIfNotEmpty"}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisting dwell of a sum kernel and a product of all the integers in a list.\n   Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* For a given list of integers, return a tuple consisting dwell of a sum kernel and a product of all the integers in a list.\n   Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sumKernel = numbers.reduce((acc, n) => acc + n, 0);\n  const product = numbers.reduce((acc, n) => acc * n, 1);\n  return [sumKernel, product];\n};\n\n/* Given a list containing integers, return a list of integers containing all the integers except the ones given.\n  >>> listOfIntegers([0, 1, 2, 3, 4])\n  [3, 4]\n  */\nconst listOfIntegers = (numbers, int) => {\n  const newNumbers = [];\n  numbers.forEach((n) => {\n    if (n!== int) {\n      newNumbers.push(n);\n    }\n  });\n  return newNumbers;\n};\n\n/* Given a list containing integers, return a list of integers containing all the integers except the ones given.\n  >>> listOfIntegers([0, 1, 2, 3, 4], 2)\n  [3, 4]\n  */\nconst listOfIntegers = (numbers, int) => {\n  const newNumbers = [];\n  numbers.forEach((n) => {\n    if (n!== int) {\n      newNumbers.push(n);\n    }\n  });\n  return newNumbers;\n};\n\n/* Given a list containing integers, return a list of integers containing all the integers except the ones given.\n  >>> listOfIntegers([0, 1, 2, 3, 4], 3)\n  [3, 4]\n  */\nconst listOfIntegers = (numbers, int) => {\n  const newNumbers = [];\n  numbers.forEach((n) => {\n    if (n!== int) {\n      newNumbers.push(n);\n    }\n  });\n  return newNumbers;\n};\n\n/* Given a list containing integers, return a list of integers containing all the integers except the ones given.\n  >>> listOfIntegers([0, 1, 2, 3, 4], 4)\n  [3, 4]\n  */\nconst listOfIntegers = (numbers, int) => {\n  const newNumbers = [];\n  numbers.forEach((n) => {\n    if (n!== int) {\n      newNumbers.push(n);\n    }\n  });\n  return newNumbers;\n};\n\n/* Given a list containing integers, return a list of integers containing all the integers except the ones given.\n  >>> listOfIntegers([0, 1, 2, 3, 4], 5)\n  [3, 4]\n  */\nconst listOfIntegers = (numbers, int) => {\n  const newNumbers = [];\n  numbers.forEach((n) => {\n    if (n!== int) {\n      newNumbers.push(n);\n    }\n  });\n  return newNumbers;\n};\n\n/* Given a list containing integers, return a list of integers containing all the integers except the ones given.\n  >>> listOfIntegers([0, 1, 2, 3, 4], 6)\n  [3, 4]\n  */\nconst listOfIntegers = (numbers, int) => {\n  const newNumbers = [];\n  numbers.forEach((n) => {\n    if (n!== int) {\n      newNumbers.push(n);\n    }\n  });\n  return newNumbers;\n};\n\n/* Given a list containing integers, return a list of integers containing all the integers except the ones given.\n  >>> listOfIntegers([0, 1, 2, 3, 4], 7)\n  [3, 4]\n  */\nconst listOfIntegers = (numbers, int) => {\n  const newNumbers = [];\n  numbers.forEach((n) => {\n    if (n!== int) {\n      newNumbers.push(n);\n    }\n  });\n  return newNumbers;\n};\n\n/* Given a list containing integers, return a list of integers containing all the integers except the ones given.\n  >>> listOfIntegers([0, 1, 2, 3, 4], 8)\n  [3, 4]\n  */\nconst listOfIntegers = (numbers, int) => {\n  const newNumbers = [];\n  numbers.forEach((n) => {\n    if (n!== int) {\n      newNumbers.push(n);\n    }\n  });\n  return newNumbers;\n};\n\n/* Given a list containing integers, return a list of integers containing all the integers except the ones given.\n  >>> listOfIntegers([0, 1, 2, 3, 4], 9)\n  [3, 4]\n  */\nconst listOfIntegers = (numbers, int) => {\n  const newNumbers = [];\n  numbers.forEach((n) => {\n    if (n!== int) {\n      newNumbers.push(n);\n    }\n  });\n  return newNumbers;\n};\n\n/* Given a list containing integers, return a list of integers containing all the integers except the ones given.\n  >>> listOfIntegers([0, 1, 2, 3, 4], 10)\n  [3, 4]\n  */\nconst listOfIntegers = (numbers, int) => {\n  const newNumbers = [];\n  numbers.forEach((n) => {\n    if (n!== int) {\n      newNumbers.push(n);\n    }\n  });\n  return newNumbers;\n};\n\n/* Given a list containing integers, return a list of integers containing all the integers except the ones given.\n  >>> listOfIntegers([0, 1, 2, 3, 4], 11)\n  [3, 4]\n  */\nconst listOfIntegers = (numbers, int) => {\n  const newNumbers = [];\n  numbers.forEach((n) => {\n    if (n!== int) {\n      newNumbers.push(n);\n    }\n  });\n  return newNumbers;\n};\n\n/* Given a list containing integers, return a list of integers containing all the integers except the ones given.\n  >>> listOfIntegers([0, 1, 2, 3, 4], 12)\n  [3, 4]\n  */\nconst listOfIntegers = (numbers, int) => {\n  const newNumbers = [];\n  numbers.forEach((n) => {\n    if (n!== int) {\n      newNumbers.push(n);\n    }\n  });\n  return newNumbers;\n};\n\n/* Given a list containing integers, return a list of integers containing all the integers except the ones given.\n  >>> listOfIntegers([0, 1, 2, 3, 4], 13)\n  [3, 4]\n  */\nconst listOfIntegers = (numbers, int) => {\n  const newNumbers = [];\n  numbers.forEach((n) => {\n    if (n!== int) {\n      newNumbers.push(n);\n    }\n  });\n  return newNumbers;\n};\n\n/* Given a list containing integers, return a list of integers containing all the integers except the ones given.\n  >>> listOfIntegers([0, 1, 2, 3, 4], 14)\n  [3, 4]\n  */\nconst listOfIntegers = (numbers, int) => {\n  const newNumbers = [];\n  numbers.forEach((n) => {\n    if (n!== int) {\n      newNumbers.push(n);\n    }\n  });\n  return newNumbers;\n};\n\n/* Given a list containing integers, return a list of integers containing all the integers except the ones given.\n  >>> listOfIntegers([0, 1, 2, 3, 4], 15)\n  [3, 4]\n  */\nconst listOfIntegers = (numbers, int) => {\n  const newNumbers = [];\n  numbers.forEach((n) => {\n    if (n!== int) {\n      newNumbers.push(n);\n    }\n  });\n  return newNumbers;\n};\n\n/* Given a list containing integers, return a list of integers containing all the integers except the ones given.\n  >>> listOfIntegers([0, 1, 2, 3, 4], 16)\n  [3, 4]\n  */\nconst listOfIntegers = (numbers, int) => {\n  const newNumbers = [];\n  numbers.forEach((n) => {\n    if (n!== int) {\n      newNumbers.push(n);\n    }\n  });\n  return newNumbers;\n};\n\n/* Given a list containing integers, return a list of integers containing all the integers except the ones given.\n  >>> listOfIntegers([0, 1, 2, 3, 4], 17)\n  [3, 4]\n  */\nconst listOfIntegers = (numbers, int) => {\n  const newNumbers = [];\n  numbers.forEach((n) => {\n    if (n!== int) {\n      newNumbers.push(n);\n    }\n  });\n  return new"}
{"task_id": "JavaScript/9", "prompt": "/* From a given list of integers, generate beget a list of rolling roll out maximum element found rule until given give moment \n   in the sequence succession.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* From a given list of integers, generate beget a list of rolling roll out maximum element found rule until given give moment \n   in the sequence succession.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const result = [];\n  let max = 0;\n  let current = 0;\n  let last = 0;\n  let currentMax = 0;\n  let currentMaxIndex = 0;\n  let currentMaxValue = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    current = numbers[i];\n    last = current;\n    max = Math.max(max, current);\n    if (current > last) {\n      currentMaxIndex = i;\n      currentMaxValue = current;\n    }\n  }\n  result.push(currentMaxValue);\n  result.push(currentMaxIndex);\n  result.push(max);\n  return result;\n};\n\n/* From a given list of integers, generate beget a list of rolling roll out minimum element found rule until given give moment \n   in the sequence succession.\n  >>> rollingMin([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 3]\n  */\nconst rollingMin = (numbers) => {\n  const result = [];\n  let min = 0;\n  let current = 0;\n  let last = 0;\n  let currentMin = 0;\n  let currentMinIndex = 0;\n  let currentMinValue = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    current = numbers[i];\n    last = current;\n    min = Math.min(min, current);\n    if (current < last) {\n      currentMinIndex = i;\n      currentMinValue = current;\n    }\n  }\n  result.push(currentMinValue);\n  result.push(currentMinIndex);\n  result.push(min);\n  return result;\n};\n\n/* From a given list of integers, generate beget a list of rolling roll out sum element found rule until given give moment \n   in the sequence succession.\n  >>> rollingSum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 6, 5]\n  */\nconst rollingSum = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let current = 0;\n  let last = 0;\n  let currentSum = 0;\n  let currentSumIndex = 0;\n  let currentSumValue = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    current = numbers[i];\n    last = current;\n    sum = sum + current;\n    if (current > last) {\n      currentSumIndex = i;\n      currentSumValue = current;\n    }\n  }\n  result.push(currentSumValue);\n  result.push(currentSumIndex);\n  result.push(sum);\n  return result;\n};\n\n/* From a given list of integers, generate beget a list of rolling roll out product element found rule until given give moment \n   in the sequence succession.\n  >>> rollingProduct([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 16, 6]\n  */\nconst rollingProduct = (numbers) => {\n  const result = [];\n  let product = 1;\n  let current = 0;\n  let last = 0;\n  let currentProduct = 1;\n  let currentProductIndex = 0;\n  let currentProductValue = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    current = numbers[i];\n    last = current;\n    product = product * current;\n    if (current > last) {\n      currentProductIndex = i;\n      currentProductValue = current;\n    }\n  }\n  result.push(currentProductValue);\n  result.push(currentProductIndex);\n  result.push(product);\n  return result;\n};\n\n/* From a given list of integers, generate beget a list of rolling roll out sum element found rule until given give moment \n   in the sequence succession.\n  >>> rollingSumOf([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 6, 5]\n  */\nconst rollingSumOf = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let current = 0;\n  let last = 0;\n  let currentSum = 0;\n  let currentSumIndex = 0;\n  let currentSumValue = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    current = numbers[i];\n    last = current;\n    sum = sum + current;\n    if (current > last) {\n      currentSumIndex = i;\n      currentSumValue = current;\n    }\n  }\n  result.push(currentSumValue);\n  result.push(currentSumIndex);\n  result.push(sum);\n  return result;\n};\n\n/* From a given list of integers, generate beget a list of rolling roll out product element found rule until given give moment \n   in the sequence succession.\n  >>> rollingProductOf([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 16, 6]\n  */\nconst rollingProductOf = (numbers) => {\n  const result = [];\n  let product = 1;\n  let current = 0;\n  let last = 0;\n  let currentProduct = 1;\n  let currentProductIndex = 0;\n  let currentProductValue = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    current = numbers[i];\n    last = current;\n    product = product * current;\n    if (current > last) {\n      currentProductIndex = i;\n      currentProductValue = current;\n    }\n  }\n  result.push(currentProductValue);\n  result.push(currentProductIndex);\n  result.push(product);\n  return result;\n};\n\n/* From a given list of integers, generate beget a list of rolling roll out sum element found rule until given give moment \n   in the sequence succession.\n  >>> rollingSumOfOf([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 6, 5]\n  */\nconst rollingSumOfOf = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let current = 0;\n  let last = 0;\n  let currentSum = 0;\n  let currentSumIndex = 0;\n  let currentSumValue = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    current = numbers[i];\n    last = current;\n    sum = sum + current;\n    if (current > last) {\n      currentSumIndex = i;\n      currentSumValue = current;\n    }\n  }\n  result.push(currentSumValue);\n  result.push(currentSumIndex);\n  result.push(sum);\n  return result;\n};\n\n/* From a given list of integers, generate beget a list of rolling roll out product element found rule until given give moment \n   in the sequence succession.\n  >>> rollingProductOfOf([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 16, 6]\n  */\nconst rollingProductOfOf = (numbers) => {\n  const result = [];\n  let product = 1;\n  let current = 0;\n  let last = 0;\n  let currentProduct = 1;\n  let currentProductIndex = 0;\n  let currentProductValue = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    current = numbers[i];\n    last = current;\n    product = product * current;\n    if (current > last) {\n      currentProductIndex = i;\n      currentProductValue = current;\n    }\n  }\n  result.push(currentProductValue);\n  result.push(currentProductIndex);\n  result.push(product);\n  return result;\n};\n\n/* From a given list of integers, generate beget a list of rolling roll out sum element found rule until given give moment \n   in the sequence succession.\n  >>> rollingSumOfOfOf([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 6, 5]\n  */\nconst rollingSumOfOfOf = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let current = 0;\n  let last = 0;\n  let currentSum = 0;\n  let currentSumIndex = 0;\n  let currentSumValue = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    current = numbers[i];\n    last = current;\n    sum = sum + current;\n    if (current > last) {\n      currentSumIndex = i;\n      currentSumValue = current;\n    }\n  }\n  result.push(currentSumValue);\n  result.push(currentSumIndex);\n  result.push(sum);\n  return result;\n};\n\n/* From a given list of integers, generate beget a list of rolling roll out product element found rule until given give moment \n   in the sequence succession.\n  >>> rollingProductOfOf([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 16, 6]\n  */\nconst rollingProductOfOf = (numbers) => {\n  const result"}
{"task_id": "JavaScript/10", "prompt": "/* Test if gniven strig is a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find the shortest brusque palindrome that begins begin with a supplied string.\n   Algorithm idea is simple dim-witted: \n   - Find the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Test if gniven strig is a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find the shortest brusque palindrome that begins begin with a supplied string.\n   Algorithm idea is simple dim-witted: \n   - Find the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const palindrome = string\n   .split('')\n   .reverse()\n   .join('')\n  \n  const palindromeLength = palindrome.length\n  const palindromePrefix = palindrome.slice(0, palindromeLength - 1)\n  const palindromeSuffix = palindrome.slice(palindromeLength)\n  \n  return palindromePrefix + palindromeSuffix\n}\n\n/* Test if given string is palindrome * / \nconst isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find the longest prefix suffix of supplied string that is a palindrome. \n   Algorithm idea is simple dim-witted: \n   - Find the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'cat'\n  >>> makePalindrome('cata')\n  'cata'\n  */\nconst makePalindrome = (string) => {\n  const palindrome = string\n   .split('')\n   .reverse()\n   .join('')\n  \n  const palindromeLength = palindrome.length\n  const palindromePrefix = palindrome.slice(0, palindromeLength - 1)\n  const palindromeSuffix = palindrome.slice(palindromeLength)\n  \n  return palindromePrefix + palindromeSuffix\n}\n\n/* Test if given string is palindrome * / \nconst isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find the longest prefix suffix of supplied string that is a palindrome. \n   Algorithm idea is simple dim-witted: \n   - Find the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'cat'\n  >>> makePalindrome('cata')\n  'cata'\n  */\nconst makePalindrome = (string) => {\n  const palindrome = string\n   .split('')\n   .reverse()\n   .join('')\n  \n  const palindromeLength = palindrome.length\n  const palindromePrefix = palindrome.slice(0, palindromeLength - 1)\n  const palindromeSuffix = palindrome.slice(palindromeLength)\n  \n  return palindromePrefix + palindromeSuffix\n}\n\n/* Test if given string is palindrome * / \nconst isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find the longest prefix suffix of supplied string that is a palindrome. \n   Algorithm idea is simple dim-witted: \n   - Find the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'cat'\n  >>> makePalindrome('cata')\n  'cata'\n  */\nconst makePalindrome = (string) => {\n  const palindrome = string\n   .split('')\n   .reverse()\n   .join('')\n  \n  const palindromeLength = palindrome.length\n  const palindromePrefix = palindrome.slice(0, palindromeLength - 1)\n  const palindromeSuffix = palindrome.slice(palindromeLength)\n  \n  return palindromePrefix + palindromeSuffix\n}\n\n/* Test if given string is palindrome * / \nconst isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find the longest prefix suffix of supplied string that is a palindrome. \n   Algorithm idea is simple dim-witted: \n   - Find the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'cat'\n  >>> makePalindrome('cata')\n  'cata'\n  */\nconst makePalindrome = (string) => {\n  const palindrome = string\n   .split('')\n   .reverse()\n   .join('')\n  \n  const palindromeLength = palindrome.length\n  const palindromePrefix = palindrome.slice(0, palindromeLength - 1)\n  const palindromeSuffix = palindrome.slice(palindromeLength)\n  \n  return palindromePrefix + palindromeSuffix\n}\n\n/* Test if given string is palindrome * / \nconst isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find the longest prefix suffix of supplied string that is a palindrome. \n   Algorithm idea is simple dim-witted: \n   - Find the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'cat'\n  >>> makePalindrome('cata')\n  'cata'\n  */\nconst makePalindrome = (string) => {\n  const palindrome = string\n   .split('')\n   .reverse()\n   .join('')\n  \n  const palindromeLength = palindrome.length\n  const palindromePrefix = palindrome.slice(0, palindromeLength - 1)\n  const palindromeSuffix = palindrome.slice(palindromeLength)\n  \n  return palindromePrefix + palindromeSuffix\n}\n\n/* Test if given string is palindrome * / \nconst isPalindrome = (string) = > "}
{"task_id": "JavaScript/11", "prompt": "/* Input are two strings a and b consisting dwell only of 1s and 0s zero. \n   Perform binary XOR on these inputs and return result consequence also besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Input are two strings a and b consisting dwell only of 1s and 0s zero. \n   Perform binary XOR on these inputs and return result consequence also besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] ^ b[i]).toString(2);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting dwell only of 1s and 0s zero. \n   Perform binary AND on these inputs and return result consequence also besides as a string.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] & b[i]).toString(2);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting dwell only of 1s and 0s zero. \n   Perform binary OR on these inputs and return result consequence also besides as a string.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] | b[i]).toString(2);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting dwell only of 1s and 0s zero. \n   Perform binary XOR on these inputs and return result consequence also besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] ^ b[i]).toString(2);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting dwell only of 1s and 0s zero. \n   Perform binary AND on these inputs and return result consequence also besides as a string.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] & b[i]).toString(2);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting dwell only of 1s and 0s zero. \n   Perform binary OR on these inputs and return result consequence also besides as a string.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] | b[i]).toString(2);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting dwell only of 1s and 0s zero. \n   Perform binary XOR on these inputs and return result consequence also besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] ^ b[i]).toString(2);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting dwell only of 1s and 0s zero. \n   Perform binary AND on these inputs and return result consequence also besides as a string.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] & b[i]).toString(2);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting dwell only of 1s and 0s zero. \n   Perform binary OR on these inputs and return result consequence also besides as a string.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] | b[i]).toString(2);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting dwell only of 1s and 0s zero. \n   Perform binary XOR on these inputs and return result consequence also besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] ^ b[i]).toString(2);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting dwell only of 1s and 0s zero. \n   Perform binary AND on these inputs and return result consequence also besides as a string.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] & b[i]).toString(2);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting dwell only of 1s and 0s zero. \n   Perform binary OR on these inputs and return result consequence also besides as a string.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] | b[i]).toString(2);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting dwell only of 1s and 0s zero. \n   Perform binary XOR on these inputs and return result consequence also besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] ^ b[i]).toString(2);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting dwell only of 1s and 0s zero. \n   Perform binary AND on these inputs and return result consequence also besides as a string.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] & b[i]).toString(2);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting dwell only of 1s and 0s zero. \n   Perform binary OR on these inputs and return result consequence also besides as a string.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] | b[i]).toString(2);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting dwell only of 1s and 0s zero. \n   Perform binary XOR on these inputs and return result consequence also besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] ^ b[i]).toString(2);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting dwell only of 1s and 0s zero. \n   Perform binary AND on these inputs and return result consequence also besides as a string.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b"}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Return the first one in case character of multiple \n   strings of the same length duration. Return null in case the input input signal list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Out of list of strings, return the longest one. Return the first one in case character of multiple \n   strings of the same length duration. Return null in case the input input signal list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  let longestLength = 0;\n  let longestString = '';\n  let longestStringLength = 0;\n\n  for (let i = 0; i < strings.length; i++) {\n    let currentString = strings[i];\n\n    if (currentString.length > longestStringLength) {\n      longestString = currentString;\n      longestStringLength = currentString.length;\n    }\n  }\n\n  return longestString;\n};\n\n/* Given a signal list, return a list of all possible combinations of its elements. \n  >>> combinations([])\n\n  >>> combinations([1, 2, 3])\n  [[1, 2, 3], [1, 2], [1, 3], [2, 3], [2, 1], [3, 1], [3, 2]]\n  */\nconst combinations = (list) => {\n  let combinations = [];\n\n  for (let i = 0; i < list.length; i++) {\n    let currentList = list.slice();\n    currentList.splice(i, 1);\n\n    for (let j = 0; j < currentList.length; j++) {\n      combinations.push(currentList.slice(0));\n    }\n  }\n\n  return combinations;\n};\n\n/* Given a signal list, return a list of all possible combinations of its elements. \n  >>> combinations([])\n\n  >>> combinations([1, 2, 3])\n  [[1, 2, 3], [1, 2], [1, 3], [2, 3], [2, 1], [3, 1], [3, 2]]\n  */\nconst combinations_with_replacement = (list) => {\n  let combinations = [];\n\n  for (let i = 0; i < list.length; i++) {\n    let currentList = list.slice();\n    currentList.splice(i, 1);\n\n    for (let j = 0; j < currentList.length; j++) {\n      combinations.push(currentList.slice(0));\n    }\n  }\n\n  return combinations;\n};\n\n/* Given a signal list, return a list of all possible combinations of its elements. \n  >>> combinations([])\n\n  >>> combinations([1, 2, 3])\n  [[1, 2, 3], [1, 2], [1, 3], [2, 3], [2, 1], [3, 1], [3, 2]]\n  */\nconst combinations_with_replacement2 = (list) => {\n  let combinations = [];\n\n  for (let i = 0; i < list.length; i++) {\n    let currentList = list.slice();\n    currentList.splice(i, 1);\n\n    for (let j = 0; j < currentList.length; j++) {\n      combinations.push(currentList.slice(0));\n    }\n  }\n\n  return combinations;\n};\n\n/* Given a signal list, return a list of all possible combinations of its elements. \n  >>> combinations([])\n\n  >>> combinations([1, 2, 3])\n  [[1, 2, 3], [1, 2], [1, 3], [2, 3], [2, 1], [3, 1], [3, 2]]\n  */\nconst combinations_with_replacement3 = (list) => {\n  let combinations = [];\n\n  for (let i = 0; i < list.length; i++) {\n    let currentList = list.slice();\n    currentList.splice(i, 1);\n\n    for (let j = 0; j < currentList.length; j++) {\n      combinations.push(currentList.slice(0));\n    }\n  }\n\n  return combinations;\n};\n\n/* Given a signal list, return a list of all possible combinations of its elements. \n  >>> combinations([])\n\n  >>> combinations([1, 2, 3])\n  [[1, 2, 3], [1, 2], [1, 3], [2, 3], [2, 1], [3, 1], [3, 2]]\n  */\nconst combinations_with_replacement4 = (list) => {\n  let combinations = [];\n\n  for (let i = 0; i < list.length; i++) {\n    let currentList = list.slice();\n    currentList.splice(i, 1);\n\n    for (let j = 0; j < currentList.length; j++) {\n      combinations.push(currentList.slice(0));\n    }\n  }\n\n  return combinations;\n};\n\n/* Given a signal list, return a list of all possible combinations of its elements. \n  >>> combinations([])\n\n  >>> combinations([1, 2, 3])\n  [[1, 2, 3], [1, 2], [1, 3], [2, 3], [2, 1], [3, 1], [3, 2]]\n  */\nconst combinations_with_replacement5 = (list) => {\n  let combinations = [];\n\n  for (let i = 0; i < list.length; i++) {\n    let currentList = list.slice();\n    currentList.splice(i, 1);\n\n    for (let j = 0; j < currentList.length; j++) {\n      combinations.push(currentList.slice(0));\n    }\n  }\n\n  return combinations;\n};\n\n/* Given a signal list, return a list of all possible combinations of its elements. \n  >>> combinations([])\n\n  >>> combinations([1, 2, 3])\n  [[1, 2, 3], [1, 2], [1, 3], [2, 3], [2, 1], [3, 1], [3, 2]]\n  */\nconst combinations_with_replacement6 = (list) => {\n  let combinations = [];\n\n  for (let i = 0; i < list.length; i++) {\n    let currentList = list.slice();\n    currentList.splice(i, 1);\n\n    for (let j = 0; j < currentList.length; j++) {\n      combinations.push(currentList.slice(0));\n    }\n  }\n\n  return combinations;\n};\n\n/* Given a signal list, return a list of all possible combinations of its elements. \n  >>> combinations([])\n\n  >>> combinations([1, 2, 3])\n  [[1, 2, 3], [1, 2], [1, 3], [2, 3], [2, 1], [3, 1], [3, 2]]\n  */\nconst combinations_with_replacement7 = (list) => {\n  let combinations = [];\n\n  for (let i = 0; i < list.length; i++) {\n    let currentList = list.slice();\n    currentList.splice(i, 1);\n\n    for (let j = 0; j < currentList.length; j++) {\n      combinations.push(currentList.slice(0));\n    }\n  }\n\n  return combinations;\n};\n\n/* Given a signal list, return a list of all possible combinations of its elements. \n  >>> combinations([])\n\n  >>> combinations([1, 2, 3])\n  [[1, 2, 3], [1, 2], [1, 3], [2, 3], [2, 1], [3, 1], [3, 2]]\n  */\nconst combinations_with_replacement8 = (list) => {\n  let combinations = [];\n\n  for (let i = 0; i < list.length; i++) {\n    let currentList = list.slice();\n    currentList.splice(i, 1);\n\n    for (let j = 0; j < currentList.length; j++) {\n      combinations.push(currentList.slice(0));\n    }\n  }\n\n  return combinations;\n};\n\n/* Given a signal list, return a list of all possible combinations of its elements. \n  >>> combinations([])\n\n  >>> combinations([1, 2, 3])\n  [[1, 2, 3], [1, 2], [1, 3], [2, 3], [2, 1], [3, 1], [3, 2]]\n  */\nconst combinations_with_replacement9 = (list) => {\n  let combinations = [];\n\n  for (let i = 0; i < list.length; i++) {\n    let currentList = list.slice();\n    currentList.splice(i, 1);\n\n    for (let j = 0; j < currentList.length; j++) {\n      combinations.push(currentList.slice(0));\n    }\n  }\n\n  return combinations;\n};\n\n/* Given a signal list, return a list of all possible combinations of its elements. \n  >>> combinations([])\n\n  >>> combinations([1, 2, 3])\n  [[1, 2, 3], [1, 2], [1, 3], [2, 3], [2, 1], [3, 1], [3, 2]]\n  */\nconst combinations_with_replacement10 = (list) => {\n  let combinations = [];\n\n  for (let i = 0; i < list.length; i++) {\n    let currentList = list.slice();\n    currentList.splice(i, 1);\n\n    for (let j = 0; j < currentList.length; j++) {\n      combinations.push(currentList.slice(0));\n    }\n  }\n\n  return combinations;\n};\n\n/* Given a signal list, return a list of all possible combinations of its elements. \n  >>> combinations([])\n\n  >>> combinations([1, 2, 3])\n  [[1, 2, 3], [1, 2], [1, 3], [2, 3], [2, 1], [3, 1], [3, 2]]\n  */\nconst combinations_with_replacement11 = (list) => {\n  let combinations = [];\n\n  for (let i = 0; i < list.length; i++) {\n    let currentList = list.slice();\n    currentList.splice(i, 1);\n\n    for (let j = 0; j < currentList.length; j++) {\n      combinations.push(currentList.slice(0));\n    }\n  }\n\n  return combinations;\n};\n\n/* Given a signal list, return a list of all possible combinations of its elements. \n  >>> combinations([])\n\n  >>> combinations([1, 2, 3])\n  [[1, 2, 3], [1, 2], [1, 3], [2, 3], [2, 1], [3, 1], [3, 2]]\n  */\nconst combinations_with_replacement12 = (list) => {\n  let combinations = [];\n\n  for (let i = 0; i < list.length; i++) {\n    let currentList = list.slice();\n    currentList.splice(i, 1);\n\n    for (let j = 0; j < currentList.length; j++) {\n      combinations.push(currentList.slice("}
{"task_id": "JavaScript/13", "prompt": "/* Return a greatest common coarse divisor of two integers integer a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Return a greatest common coarse divisor of two integers integer a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (a < b) {\n    return greatestCommonDivisor(b, a)\n  }\n  return gcd(a, b)\n}\n\n// Given a number x, return its greatest common divisor of x and y.\n// >>> gcd(3, 5)\n// 1\n// >>> gcd(25, 15)\n// 5\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, 15)\n// 1\n// >>> gcd(25, "}
{"task_id": "JavaScript/14", "prompt": "/* Return list of all prefixes from shortest to longest long of the input stimulation string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Return list of all prefixes from shortest to longest long of the input stimulation string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  const prefixes = [];\n  let currentPrefix = string;\n  while (currentPrefix.length > 0) {\n    prefixes.push(currentPrefix);\n    currentPrefix = currentPrefix.substr(1);\n  }\n  return prefixes;\n};\n\n/* Return list of all suffixes from shortest to longest long of the input stimulation string\n  >>> allSuffixes('abc')\n  ['ab', 'abc', 'abc']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.push(currentSuffix);\n    currentSuffix = currentSuffix.substr(1);\n  }\n  return suffixes;\n};\n\n/* Return list of all suffixes from shortest to longest long of the input stimulation string\n  >>> allSuffixes('abc')\n  ['abc', 'ab', 'abc']\n  */\nconst allSuffixesReversed = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.push(currentSuffix);\n    currentSuffix = currentSuffix.substr(1);\n  }\n  return suffixes;\n};\n\n/* Return list of all suffixes from shortest to longest long of the input stimulation string\n  >>> allSuffixesReversed('abc')\n  ['abc', 'abc', 'ab']\n  */\nconst allSuffixesReversedReversed = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.push(currentSuffix);\n    currentSuffix = currentSuffix.substr(1);\n  }\n  return suffixes;\n};\n\n/* Return list of all suffixes from shortest to longest long of the input stimulation string\n  >>> allSuffixesReversedReversed('abc')\n  ['abc', 'abc', 'abc']\n  */\nconst allSuffixesReversedReversedReversed = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.push(currentSuffix);\n    currentSuffix = currentSuffix.substr(1);\n  }\n  return suffixes;\n};\n\n/* Return list of all suffixes from shortest to longest long of the input stimulation string\n  >>> allSuffixesReversedReversedReversedReversed('abc')\n  ['abc', 'abc', 'abc']\n  */\nconst allSuffixesReversedReversedReversedReversed = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.push(currentSuffix);\n    currentSuffix = currentSuffix.substr(1);\n  }\n  return suffixes;\n};\n\n/* Return list of all suffixes from shortest to longest long of the input stimulation string\n  >>> allSuffixesReversedReversedReversedReversedReversedReversed('abc')\n  ['abc', 'abc', 'abc']\n  */\nconst allSuffixesReversedReversedReversedReversedReversedReversed = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.push(currentSuffix);\n    currentSuffix = currentSuffix.substr(1);\n  }\n  return suffixes;\n};\n\n/* Return list of all suffixes from shortest to longest long of the input stimulation string\n  >>> allSuffixesReversedReversedReversedReversedReversedReversedReversedReversed('abc')\n  ['abc', 'abc', 'abc']\n  */\nconst allSuffixesReversedReversedReversedReversedReversedReversedReversedReversed = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.push(currentSuffix);\n    currentSuffix = currentSuffix.substr(1);\n  }\n  return suffixes;\n};\n\n/* Return list of all suffixes from shortest to longest long of the input stimulation string\n  >>> allSuffixesReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed('abc')\n  ['abc', 'abc', 'abc']\n  */\nconst allSuffixesReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.push(currentSuffix);\n    currentSuffix = currentSuffix.substr(1);\n  }\n  return suffixes;\n};\n\n/* Return list of all suffixes from shortest to longest long of the input stimulation string\n  >>> allSuffixesReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed('abc')\n  ['abc', 'abc', 'abc']\n  */\nconst allSuffixesReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.push(currentSuffix);\n    currentSuffix = currentSuffix.substr(1);\n  }\n  return suffixes;\n};\n\n/* Return list of all suffixes from shortest to longest long of the input stimulation string\n  >>> allSuffixesReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReverse"}
{"task_id": "JavaScript/15", "prompt": "/* Return a string containing check space outer space - delimited numbers starting depart from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Return a string containing check space outer space - delimited numbers starting depart from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Return a string containing check space outer space - delimited numbers starting depart from 0 upto n inclusive.\n * If n is 0, return empty string.\n */\nconst stringSequenceWithZero = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Return a string containing check space outer space - delimited numbers starting depart from 0 upto n inclusive.\n * If n is 0, return empty string.\n */\nconst stringSequenceWithZeroAndSpace = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Return a string containing check space outer space - delimited numbers starting depart from 0 upto n inclusive.\n * If n is 0, return empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZero = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Return a string containing check space outer space - delimited numbers starting depart from 0 upto n inclusive.\n * If n is 0, return empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZeroAndSpace = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Return a string containing check space outer space - delimited numbers starting depart from 0 upto n inclusive.\n * If n is 0, return empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZeroAndSpaceAndZero = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Return a string containing check space outer space - delimited numbers starting depart from 0 upto n inclusive.\n * If n is 0, return empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZeroAndSpaceAndZeroAndSpace = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Return a string containing check space outer space - delimited numbers starting depart from 0 upto n inclusive.\n * If n is 0, return empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZero = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Return a string containing check space outer space - delimited numbers starting depart from 0 upto n inclusive.\n * If n is 0, return empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpace = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Return a string containing check space outer space - delimited numbers starting depart from 0 upto n inclusive.\n * If n is 0, return empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZero = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Return a string containing check space outer space - delimited numbers starting depart from 0 upto n inclusive.\n * If n is 0, return empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZero = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Return a string containing check space outer space - delimited numbers starting depart from 0 upto n inclusive.\n * If n is 0, return empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpace = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Return a string containing check space outer space - delimited numbers starting depart from 0 upto n inclusive.\n * If n is 0, return empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpace = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Return a string containing check space outer space - delimited numbers starting depart from 0 upto n inclusive.\n * If n is 0, return empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpace = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Return a string containing check space outer space - delimited numbers starting depart from 0 upto n inclusive.\n * If n is 0, return empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpace = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Return a string containing check space outer space - delimited numbers starting depart from 0 upto n inclusive.\n * If n is 0, return empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpace = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Return a string containing check space outer space - delimited numbers starting depart from 0 upto n inclusive.\n * If n is 0, return empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpace = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Return a string containing check space outer space - delimited numbers starting depart from 0 upto n inclusive.\n * If n is 0, return empty string.\n */\nconst stringSequenceWithZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZeroAndSpaceAndZero"}
{"task_id": "JavaScript/16", "prompt": "/* Given a string, find out how many distinct discrete characters fictional character (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Given a string, find out how many distinct discrete characters fictional character (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words fictional word (regardless of case) does it consist of\n * >>> countDistinctWords('xyzXYZ')\n * 3\n * >>> countDistinctWords('Jerry')\n * 4\n */\nconst countDistinctWords = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words fictional word (regardless of case) does it consist of\n * >>> countWords('xyzXYZ')\n * 3\n * >>> countWords('Jerry')\n * 4\n */\nconst countWords = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words fictional word (regardless of case) does it consist of\n * >>> countWordsIgnoreCase('xyzXYZ')\n * 3\n * >>> countWordsIgnoreCase('Jerry')\n * 4\n */\nconst countWordsIgnoreCase = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words fictional word (regardless of case) does it consist of\n * >>> countWordsIgnoreCase('xyzXYZ')\n * 3\n * >>> countWordsIgnoreCase('Jerry')\n * 4\n */\nconst countWordsIgnoreCase2 = (string, ignoreCase) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words fictional word (regardless of case) does it consist of\n * >>> countWordsIgnoreCase('xyzXYZ')\n * 3\n * >>> countWordsIgnoreCase('Jerry')\n * 4\n */\nconst countWordsIgnoreCase3 = (string, ignoreCase) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words fictional word (regardless of case) does it consist of\n * >>> countWordsIgnoreCase('xyzXYZ')\n * 3\n * >>> countWordsIgnoreCase('Jerry')\n * 4\n */\nconst countWordsIgnoreCase4 = (string, ignoreCase) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words fictional word (regardless of case) does it consist of\n * >>> countWordsIgnoreCase('xyzXYZ')\n * 3\n * >>> countWordsIgnoreCase('Jerry')\n * 4\n */\nconst countWordsIgnoreCase5 = (string, ignoreCase) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words fictional word (regardless of case) does it consist of\n * >>> countWordsIgnoreCase('xyzXYZ')\n * 3\n * >>> countWordsIgnoreCase('Jerry')\n * 4\n */\nconst countWordsIgnoreCase6 = (string, ignoreCase) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words fictional word (regardless of case) does it consist of\n * >>> countWordsIgnoreCase('xyzXYZ')\n * 3\n * >>> countWordsIgnoreCase('Jerry')\n * 4\n */\nconst countWordsIgnoreCase7 = (string, ignoreCase) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words fictional word (regardless of case) does it consist of\n * >>> countWordsIgnoreCase('xyzXYZ')\n * 3\n * >>> countWordsIgnoreCase('Jerry')\n * 4\n */\nconst countWordsIgnoreCase8 = (string, ignoreCase) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words fictional word (regardless of case) does it consist of\n * >>> countWordsIgnoreCase('xyzXYZ')\n * 3\n * >>> countWordsIgnoreCase('Jerry')\n * 4\n */\nconst countWordsIgnoreCase9 = (string, ignoreCase) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words fictional word (regardless of case) does it consist of\n * >>> countWordsIgnoreCase('xyzXYZ')\n * 3\n * >>> countWordsIgnoreCase('Jerry')\n * 4\n */\nconst countWordsIgnoreCase10 = (string, ignoreCase) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words fictional word (regardless of case) does it consist of\n * >>> countWordsIgnoreCase('xyzXYZ')\n * 3\n * >>> countWordsIgnoreCase('Jerry')\n * 4\n */\nconst countWordsIgnoreCase11 = (string, ignoreCase) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words fictional word (regardless of case) does it consist of\n * >>> countWordsIgnoreCase('xyzXYZ')\n * 3\n * >>> countWordsIgnoreCase('Jerry')\n * 4\n */\nconst countWordsIgnoreCase12 = (string, ignoreCase) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words fictional word (regardless of case) does it consist of\n * >>> countWordsIgnoreCase('xyzXYZ')\n * 3\n * "}
{"task_id": "JavaScript/17", "prompt": "/* Input to this function is a string bowed stringed instrument representing exemplify musical notes in a special particular ASCII format. \n   Your task is to parse this string chain and return list of integers corresponding to how many beats does each \n   not last. \n\n   Here is a legend caption: \n  ' o' - whole note, lasts four beats meter \n  ' o|' - half note bill, lasts two beats pulse \n  ' .|' - quater note bill, lasts survive one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Input to this function is a string bowed stringed instrument representing exemplify musical notes in a special particular ASCII format. \n   Your task is to parse this string chain and return list of integers corresponding to how many beats does each \n   not last. \n\n   Here is a legend caption: \n 'o' - whole note, lasts four beats meter \n 'o|' - half note bill, lasts two beats pulse \n  '.|' - quater note bill, lasts survive one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const music_list = music_string.split('|');\n  const music_notes = [];\n  for (let i = 0; i < music_list.length; i++) {\n    const music_note = music_list[i].split('o');\n    music_notes.push(parseInt(music_note[0]));\n  }\n  return music_notes;\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \"Hello WOrld\"\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \"Hello WOrld\"\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \"Hello WOrld\"\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \"Hello WOrld\"\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \"Hello WOrld\"\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \"Hello WOrld\"\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \"Hello WOrld\"\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \"Hello WOrld\"\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \"Hello WOrld\"\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \"Hello WOrld\"\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \"Hello WOrld\"\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \"Hello WOrld\"\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \"Hello WOrld\"\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \"Hello WOrld\"\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \"Hello WOrld\"\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \"Hello WOrld\"\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \"Hello WOrld\"\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \"Hello WOrld\"\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \"Hello WOrld\"\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \"Hello WOrld\"\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \"Hello WOrld\"\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \"Hello WOrld\"\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \"Hello WOrld\"\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \"Hello WOrld\"\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \"Hello WOrld\"\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \"Hello WOrld\"\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \"Hello WOrld\"\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Your task is to write a function that will take a string and return the string with each letter capitalized. \n// For example \"Hello World\" => \""}
{"task_id": "JavaScript/18", "prompt": "/* Find how many times a given substring can be found receive in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Find how many times a given substring can be found receive in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  let index = 0;\n  let length = string.length;\n  while (index < length) {\n    if (string.charAt(index) === substring) {\n      count++;\n      index++;\n    }\n    index++;\n  }\n  return count;\n};\n\n/**\n * Given a string, return all possible permutations of that string.\n * If there are multiple possible permutations, return all of them as an array.\n * If there are multiple possible permutations, return them as a list of arrays.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If there are multiple possible permutations, return them as a list of strings.\n * If "}
{"task_id": "JavaScript/19", "prompt": "/* Input is a space - delimited demarcate string bowed stringed instrument of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string drawstring with numbers sorted classify from smallest to largest big\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Input is a space - delimited demarcate string bowed stringed instrument of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string drawstring with numbers sorted classify from smallest to largest big\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space - delimited demarcate string bowed stringed instrument of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string drawstring with numbers sorted classify from smallest to largest big\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space - delimited demarcate string bowed stringed instrument of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string drawstring with numbers sorted classify from smallest to largest big\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space - delimited demarcate string bowed stringed instrument of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string drawstring with numbers sorted classify from smallest to largest big\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space - delimited demarcate string bowed stringed instrument of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string drawstring with numbers sorted classify from smallest to largest big\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space - delimited demarcate string bowed stringed instrument of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string drawstring with numbers sorted classify from smallest to largest big\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space - delimited demarcate string bowed stringed instrument of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string drawstring with numbers sorted classify from smallest to largest big\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space - delimited demarcate string bowed stringed instrument of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string drawstring with numbers sorted classify from smallest to largest big\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space - delimited demarcate string bowed stringed instrument of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string drawstring with numbers sorted classify from smallest to largest big\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space - delimited demarcate string bowed stringed instrument of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string drawstring with numbers sorted classify from smallest to largest big\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space - delimited demarcate string bowed stringed instrument of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string drawstring with numbers sorted classify from smallest to largest big\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join('"}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied list of numbers (of length at least two) select choice and return two that are the closest close to each \n   other and return them in order (smaller number phone number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* From a supplied list of numbers (of length at least two) select choice and return two that are the closest close to each \n   other and return them in order (smaller number phone number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  let minDistance = Number.MAX_VALUE;\n  let minDistanceIndex = 0;\n  let minDistanceElement = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    const distance = numbers[i] - minDistanceElement;\n    if (distance < minDistance) {\n      minDistance = distance;\n      minDistanceIndex = i;\n      minDistanceElement = numbers[i];\n    }\n  }\n  return [minDistanceElement, minDistanceIndex];\n};\n\n/* From a supplied list of numbers (of length at least two) select choice and return two that are the closest close to each \n   other and return them in order (smaller number phone number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElementsFast = (numbers) => {\n  let minDistance = Number.MAX_VALUE;\n  let minDistanceIndex = 0;\n  let minDistanceElement = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    const distance = numbers[i] - minDistanceElement;\n    if (distance < minDistance) {\n      minDistance = distance;\n      minDistanceIndex = i;\n      minDistanceElement = numbers[i];\n    }\n  }\n  return [minDistanceElement, minDistanceIndex];\n};\n\n/* From a supplied list of numbers (of length at least two) select choice and return two that are the closest close to each \n   other and return them in order (smaller number phone number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElementsFastFast = (numbers) => {\n  let minDistance = Number.MAX_VALUE;\n  let minDistanceIndex = 0;\n  let minDistanceElement = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    const distance = numbers[i] - minDistanceElement;\n    if (distance < minDistance) {\n      minDistance = distance;\n      minDistanceIndex = i;\n      minDistanceElement = numbers[i];\n    }\n  }\n  return [minDistanceElement, minDistanceIndex];\n};\n\n/* From a supplied list of numbers (of length at least two) select choice and return two that are the closest close to each \n   other and return them in order (smaller number phone number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElementsFastFast = (numbers) => {\n  let minDistance = Number.MAX_VALUE;\n  let minDistanceIndex = 0;\n  let minDistanceElement = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    const distance = numbers[i] - minDistanceElement;\n    if (distance < minDistance) {\n      minDistance = distance;\n      minDistanceIndex = i;\n      minDistanceElement = numbers[i];\n    }\n  }\n  return [minDistanceElement, minDistanceIndex];\n};\n\n/* From a supplied list of numbers (of length at least two) select choice and return two that are the closest close to each \n   other and return them in order (smaller number phone number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElementsFastFastFast = (numbers) => {\n  let minDistance = Number.MAX_VALUE;\n  let minDistanceIndex = 0;\n  let minDistanceElement = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    const distance = numbers[i] - minDistanceElement;\n    if (distance < minDistance) {\n      minDistance = distance;\n      minDistanceIndex = i;\n      minDistanceElement = numbers[i];\n    }\n  }\n  return [minDistanceElement, minDistanceIndex];\n};\n\n/* From a supplied list of numbers (of length at least two) select choice and return two that are the closest close to each \n   other and return them in order (smaller number phone number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElementsFastFastFast = (numbers) => {\n  let minDistance = Number.MAX_VALUE;\n  let minDistanceIndex = 0;\n  let minDistanceElement = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    const distance = numbers[i] - minDistanceElement;\n    if (distance < minDistance) {\n      minDistance = distance;\n      minDistanceIndex = i;\n      minDistanceElement = numbers[i];\n    }\n  }\n  return [minDistanceElement, minDistanceIndex];\n};\n\n/* From a supplied list of numbers (of length at least two) select choice and return two that are the closest close to each \n   other and return them in order (smaller number phone number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElementsFastFastFast = (numbers) => {\n  let minDistance = Number.MAX_VALUE;\n  let minDistanceIndex = 0;\n  let minDistanceElement = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    const distance = numbers[i] - minDistanceElement;\n    if (distance < minDistance) {\n      minDistance = distance;\n      minDistanceIndex = i;\n      minDistanceElement = numbers[i];\n    }\n  }\n  return [minDistanceElement, minDistanceIndex];\n};\n\n/* From a supplied list of numbers (of length at least two) select choice and return two that are the closest close to each \n   other and return them in order (smaller number phone number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElementsFastFastFast = (numbers) => {\n  let minDistance = Number.MAX_VALUE;\n  let minDistanceIndex = 0;\n  let minDistanceElement = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    const distance = numbers[i] - minDistanceElement;\n    if (distance < minDistance) {\n      minDistance = distance;\n      minDistanceIndex = i;\n      minDistanceElement = numbers[i];\n    }\n  }\n  return [minDistanceElement, minDistanceIndex];\n};\n\n/* From a supplied list of numbers (of length at least two) select choice and return two that are the closest close to each \n   other and return them in order (smaller number phone number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElementsFastFastFast = (numbers) => {\n  let minDistance = Number.MAX_VALUE;\n  let minDistanceIndex = 0;\n  let "}
{"task_id": "JavaScript/21", "prompt": "/* Given list of numbers (of at least two elements), apply give a linear analogue transform to that list,\n   such that the smallest number will become 0 and the largest large will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Given list of numbers (of at least two elements), apply give a linear analogue transform to that list,\n   such that the smallest number will become 0 and the largest large will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const minValue = Math.min.apply(null, numbers);\n  const maxValue = Math.max.apply(null, numbers);\n  const scaledValue = (maxValue - minValue) / numbers.length;\n  return [minValue, scaledValue];\n};\n\nconst getUnit = (value) => {\n  if (value >= 0) {\n    return 1;\n  }\n  return -1;\n};\n\nconst getUnitFromValue = (value) => {\n  if (value >= 0) {\n    return 1;\n  }\n  return -1;\n};\n\nconst getUnitFromValueAndUnit = (value, unit) => {\n  if (value >= 0) {\n    return 1;\n  }\n  return -1;\n};\n\nconst getValueFromUnit = (value, unit) => {\n  if (unit === -1) {\n    return value;\n  }\n  return value * unit;\n};\n\nconst getValueFromUnitAndValue = (value, unit) => {\n  if (unit === -1) {\n    return value;\n  }\n  return value * unit;\n};\n\nconst getValueFromUnitAndValueAndUnit = (value, unit, valueUnit) => {\n  if (unit === -1) {\n    return value;\n  }\n  return value * unit;\n};\n\nconst getValueFromUnitAndValueAndUnitAndValue = (value, unit, valueUnit, valueUnit2) => {\n  if (unit === -1) {\n    return value;\n  }\n  return value * unit;\n};\n\nconst getValueFromUnitAndValueAndUnitAndValueAndValue = (value, unit, valueUnit, valueUnit2, valueUnit3) => {\n  if (unit === -1) {\n    return value;\n  }\n  return value * unit;\n};\n\nconst getValueFromUnitAndValueAndUnitAndValueAndValueAndValue = (value, unit, valueUnit, valueUnit, valueUnit2, valueUnit3, valueUnit4) => {\n  if (unit === -1) {\n    return value;\n  }\n  return value * unit;\n};\n\nconst getValueFromUnitAndValueAndUnitAndValueAndValueAndValueAndValueAndValue = (value, unit, valueUnit, valueUnit, valueUnit2, valueUnit3, valueUnit4, valueUnit5) => {\n  if (unit === -1) {\n    return value;\n  }\n  return value * unit;\n};\n\nconst getValueFromUnitAndValueAndUnitAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValue = (value, unit, valueUnit, valueUnit, valueUnit2, valueUnit3, valueUnit4, valueUnit5, valueUnit6) => {\n  if (unit === -1) {\n    return value;\n  }\n  return value * unit;\n};\n\nconst getValueFromUnitAndValueAndUnitAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValueAndValue"}
{"task_id": "JavaScript/22", "prompt": "/* Filter given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/* Filter given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(value => typeof value === 'number');\n};\n\n/* Filter given list of any python values only for floats\n  >>> filterFloats(['a', 3.14, 5])\n  [5]\n  >>> filterFloats([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterFloats = (values) => {\n  return values.filter(value => typeof value === 'number');\n};\n\n/* Filter given list of any python values only for strings\n  >>> filterStrings(['a', 3.14, 5])\n  [5]\n  >>> filterStrings([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterStrings = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/* Filter given list of any python values only for booleans\n  >>> filterBooleans(['a', 3.14, 5])\n  [5]\n  >>> filterBooleans([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterBooleans = (values) => {\n  return values.filter(value => typeof value === 'boolean');\n};\n\n/* Filter given list of any python values only for None\n  >>> filterNone([])\n  []\n  >>> filterNone([None])\n  [None]\n  >>> filterNone([None, None, None])\n  [None, None, None]\n  >>> filterNone([None, True, None])\n  [None, True, None]\n  >>> filterNone([None, True, True, None])\n  [None, True, True, None]\n  >>> filterNone([None, True, False, None])\n  [None, True, False, None]\n  >>> filterNone([None, True, False, True, None])\n  [None, True, False, True, None]\n  >>> filterNone([None, False, False, None])\n  [None, False, False, None]\n  >>> filterNone([None, False, False, True, None])\n  [None, False, False, True, None]\n  >>> filterNone([None, True, False, False, None])\n  [None, True, False, False, None]\n  >>> filterNone([None, True, False, False, True, None])\n  [None, True, False, False, True, None]\n  >>> filterNone([None, True, False, True, False, None])\n  [None, True, False, True, False, None]\n  >>> filterNone([None, True, False, True, False, True, None])\n  [None, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, False, None])\n  [None, True, False, True, False, False, None]\n  >>> filterNone([None, True, False, True, False, False, True, None])\n  [None, True, False, True, False, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, None])\n  [None, True, False, True, False, True, False, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  >>> filterNone([None, True, False, True, False, True, False, True, None])\n  [None, True, False, True, False, True, False, True, None]\n  "}
{"task_id": "JavaScript/23", "prompt": "/* Return length of given yield string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Return length of given yield string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length\n}\n\n/**\n * Return true if given string starts with given prefix\n * >>> startsWith('abc', 'a')\n  true\n  >>> startsWith('abc', 'b')\n  false\n  */\nconst startsWith = (string, prefix) => {\n  return string.indexOf(prefix) === 0\n}\n\n/**\n * Return true if given string ends with given suffix\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'b')\n  true\n  >>> contains('abc', 'a')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'b')\n  true\n  >>> startsWith('abc', 'a')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'b')\n  true\n  >>> contains('abc', 'a')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'b')\n  true\n  >>> startsWith('abc', 'a')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'b')\n  true\n  >>> contains('abc', 'a')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'b')\n  true\n  >>> startsWith('abc', 'a')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'b')\n  true\n  >>> contains('abc', 'a')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'b')\n  true\n  >>> startsWith('abc', 'a')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'b')\n  true\n  >>> contains('abc', 'a')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'b')\n  true\n  >>> startsWith('abc', 'a')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'b')\n  true\n  >>> contains('abc', 'a')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'b')\n  true\n  >>> startsWith('abc', 'a')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'b')\n  true\n  >>> contains('abc', 'a')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'b')\n  true\n  >>> startsWith('abc', 'a')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'b')\n  true\n  >>> contains('abc', 'a')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'b')\n  true\n  >>> startsWith('abc', 'a')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'b')\n  true\n  >>> contains('abc', 'a')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}"}
{"task_id": "JavaScript/24", "prompt": "/* For a given number n, find receive the largest bombastic number that divides n evenly, smaller modest than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* For a given number n, find receive the largest bombastic number that divides n evenly, smaller modest than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 1;\n  }\n  return divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly.\n * If n is divisible by any number other than 1, return that number.\n * If n is divisible by 1, return 1.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by 1, return 1.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any number other than 1, return n.\n * If n is divisible by any "}
{"task_id": "JavaScript/25", "prompt": "/* Return list of prime factors gene of given render integer in the order from smallest to largest large. \n   Each of the factors gene should be listed number act of times corresponding to how many times it appeares in factorization. \n   Input remark number should be equal to the product of all factors component\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Return list of prime factors gene of given render integer in the order from smallest to largest large. \n   Each of the factors gene should be listed number act of times corresponding to how many times it appeares in factorization. \n   Input remark number should be equal to the product of all factors component\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  let factors = [];\n  let remark = 1;\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let "}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers, remove all elements component that occur happen more than once. \n   Keep order of elements element left entrust the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* From a list of integers, remove all elements component that occur happen more than once. \n   Keep order of elements element left entrust the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const seen = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (seen.has(cur)) {\n      acc.push(cur);\n    } else {\n      seen.add(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements component that occur occur more than once. \n   Keep order of elements element left entrust the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSet = (numbers) => {\n  const seen = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (seen.has(cur)) {\n      acc.push(cur);\n    } else {\n      seen.add(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements component that occur occur more than once. \n   Keep order of elements element left entrust the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesMap = (numbers) => {\n  const seen = new Map();\n  return numbers.reduce((acc, cur) => {\n    if (seen.has(cur)) {\n      acc.push(cur);\n    } else {\n      seen.add(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements component that occur occur more than once. \n   Keep order of elements element left entrust the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSetMap = (numbers) => {\n  const seen = new Map();\n  return numbers.reduce((acc, cur) => {\n    if (seen.has(cur)) {\n      acc.push(cur);\n    } else {\n      seen.add(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements component that occur occur more than once. \n   Keep order of elements element left entrust the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSetSet = (numbers) => {\n  const seen = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (seen.has(cur)) {\n      acc.push(cur);\n    } else {\n      seen.add(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements component that occur occur more than once. \n   Keep order of elements element left entrust the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSetMapSet = (numbers) => {\n  const seen = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (seen.has(cur)) {\n      acc.push(cur);\n    } else {\n      seen.add(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements component that occur occur more than once. \n   Keep order of elements element left entrust the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSetSetMap = (numbers) => {\n  const seen = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (seen.has(cur)) {\n      acc.push(cur);\n    } else {\n      seen.add(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements component that occur occur more than once. \n   Keep order of elements element left entrust the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSetSetMapSet = (numbers) => {\n  const seen = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (seen.has(cur)) {\n      acc.push(cur);\n    } else {\n      seen.add(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements component that occur occur more than once. \n   Keep order of elements element left entrust the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSetSetMapMap = (numbers) => {\n  const seen = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (seen.has(cur)) {\n      acc.push(cur);\n    } else {\n      seen.add(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements component that occur occur more than once. \n   Keep order of elements element left entrust the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSetSetMapSetMap = (numbers) => {\n  const seen = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (seen.has(cur)) {\n      acc.push(cur);\n    } else {\n      seen.add(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements component that occur occur more than once. \n   Keep order of elements element left entrust the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSetSetMapMapSet = (numbers) => {\n  const seen = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (seen.has(cur)) {\n      acc.push(cur);\n    } else {\n      seen.add(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements component that occur occur more than once. \n   Keep order of elements element left entrust the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSetSetMapMapSetMap = (numbers) => {\n  const seen = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (seen.has(cur)) {\n      acc.push(cur);\n    } else {\n      seen.add(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements component that occur occur more than once. \n   Keep order of elements element left entrust the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSetSetMapMapMapSet = (numbers) => {\n  const seen = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (seen.has(cur)) {\n      acc.push(cur);\n    } else {\n      seen.add(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements component that occur occur more than once. \n   Keep order of elements element left entrust the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSetSetMapMapMapSetSet = (numbers) => {\n  const seen = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (seen.has(cur)) {\n      acc.push(cur);\n    } else {\n      seen.add(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements component that occur occur more than once. \n   Keep order of elements element left entrust the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSetSetMapMapMapMapSet = (numbers) => {\n  const seen = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (seen.has(cur)) {\n      acc.push(cur);\n    } else {"}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip lowercase small letter characters fictional character to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* For a given string, flip lowercase small letter characters fictional character to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.toLowerCase().replace(/[a-z]/g, (_, letter) => letter.toUpperCase());\n};\n\n/* Given a string, return the first letter of the string if it is a lowercase letter, otherwise return '?'.\n  >>> firstLetter('Hello')\n  'H'\n  */\nconst firstLetter = (string) => {\n  return string[0].toLowerCase() === 'a'? string.slice(1) : '?';\n};\n\n/* Given a string, return the first letter of the string if it is a uppercase letter, otherwise return '?'.\n  >>> firstLetter(firstLetter('Hello'))\n  'H'\n  */\nconst firstLetterUpper = (string) => {\n  return string[0].toUpperCase() === 'A'? string.slice(1) : '?';\n};\n\n/* Given a string, return the first letter of the string if it is a digit, otherwise return '?'.\n  >>> firstLetter(firstLetter('Hello'))\n  'H'\n  */\nconst firstLetterDigit = (string) => {\n  return string[0] === '0'? string.slice(1) : '?';\n};\n\n/* Given a string, return the first letter of the string if it is a special character, otherwise return '?'.\n  >>> firstLetter(firstLetter('Hello'))\n  'H'\n  */\nconst firstLetterSpecial = (string) => {\n  return string[0] === '?'? string.slice(1) : '?';\n};\n\n/* Given a string, return the first letter of the string if it is a letter, otherwise return '?'.\n  >>> firstLetter(firstLetter('Hello'))\n  'H'\n  */\nconst firstLetterLetter = (string) => {\n  return string[0] === 'a'? string.slice(1) : '?';\n};\n\n/* Given a string, return the first letter of the string if it is a number, otherwise return '?'.\n  >>> firstLetter(firstLetter('Hello'))\n  'H'\n  */\nconst firstLetterNumber = (string) => {\n  return string[0] === '0'? string.slice(1) : '?';\n};\n\n/* Given a string, return the first letter of the string if it is a special character, otherwise return '?'.\n  >>> firstLetter(firstLetter('Hello'))\n  'H'\n  */\nconst firstLetterSpecialNumber = (string) => {\n  return string[0] === '?'? string.slice(1) : '?';\n};\n\n/* Given a string, return the first letter of the string if it is a special character, otherwise return '?'.\n  >>> firstLetter(firstLetter('Hello'))\n  'H'\n  */\nconst firstLetterSpecialLetter = (string) => {\n  return string[0] === '?'? string.slice(1) : '?';\n};\n\n/* Given a string, return the first letter of the string if it is a special character, otherwise return '?'.\n  >>> firstLetter(firstLetter('Hello'))\n  'H'\n  */\nconst firstLetterSpecialNumber = (string) => {\n  return string[0] === '?'? string.slice(1) : '?';\n};\n\n/* Given a string, return the first letter of the string if it is a special character, otherwise return '?'.\n  >>> firstLetter(firstLetter('Hello'))\n  'H'\n  */\nconst firstLetterSpecialLetterNumber = (string) => {\n  return string[0] === '?'? string.slice(1) : '?';\n};\n\n/* Given a string, return the first letter of the string if it is a special character, otherwise return '?'.\n  >>> firstLetter(firstLetter('Hello'))\n  'H'\n  */\nconst firstLetterSpecialLetterLetter = (string) => {\n  return string[0] === '?'? string.slice(1) : '?';\n};\n\n/* Given a string, return the first letter of the string if it is a special character, otherwise return '?'.\n  >>> firstLetter(firstLetter('Hello'))\n  'H'\n  */\nconst firstLetterSpecialLetterNumber = (string) => {\n  return string[0] === '?'? string.slice(1) : '?';\n};\n\n/* Given a string, return the first letter of the string if it is a special character, otherwise return '?'.\n  >>> firstLetter(firstLetter('Hello'))\n  'H'\n  */\nconst firstLetterSpecialLetterLetterNumber = (string) => {\n  return string[0] === '?'? string.slice(1) : '?';\n};\n\n/* Given a string, return the first letter of the string if it is a special character, otherwise return '?'.\n  >>> firstLetter(firstLetter('Hello'))\n  'H'\n  */\nconst firstLetterSpecialLetterLetterLetter = (string) => {\n  return string[0] === '?'? string.slice(1) : '?';\n};\n\n/* Given a string, return the first letter of the string if it is a special character, otherwise return '?'.\n  >>> firstLetter(firstLetter('Hello'))\n  'H'\n  */\nconst firstLetterSpecialLetterLetterNumber = (string) => {\n  return string[0] === '?'? string.slice(1) : '?';\n};\n\n/* Given a string, return the first letter of the string if it is a special character, otherwise return '?'.\n  >>> firstLetter(firstLetter('Hello'))\n  'H'\n  */\nconst firstLetterSpecialLetterLetterLetterNumber = (string) => {\n  return string[0] === '?'? string.slice(1) : '?';\n};\n\n/* Given a string, return the first letter of the string if it is a special character, otherwise return '?'.\n  >>> firstLetter(firstLetter('Hello'))\n  'H'\n  */\nconst firstLetterSpecialLetterLetterLetterLetter = (string) => {\n  return string[0] === '?'? string.slice(1) : '?';\n};\n\n/* Given a string, return the first letter of the string if it is a special character, otherwise return '?'.\n  >>> firstLetter(firstLetter('Hello'))\n  'H'\n  */\nconst firstLetterSpecialLetterLetterLetterNumber = (string) => {\n  return string[0] === '?'? string.slice(1) : '?';\n};\n\n/* Given a string, return the first letter of the string if it is a special character, otherwise return '?'.\n  >>> firstLetter(firstLetter('Hello'))\n  'H'\n  */\nconst firstLetterSpecialLetterLetterLetterLetterLetterNumber = (string) => {\n  return string[0] === '?'? string.slice(1) : '?';\n};\n\n/* Given a string, return the first letter of the string if it is a special character, otherwise return '?'.\n  >>> firstLetter(firstLetter('Hello'))\n  'H'\n  */\nconst firstLetterSpecialLetterLetterLetterLetterLetterLetter = (string) => {\n  return string[0] === '?'? string.slice(1) : '?';\n};\n\n/* Given a string, return the first letter of the string if it is a special character, otherwise return '?'.\n  >>> firstLetter(firstLetter('Hello'))\n  'H'\n  */\nconst firstLetterSpecialLetterLetterLetterLetterLetterNumber = (string) => {\n  return string[0] === '?'? string.slice(1) : '?';\n};\n\n/* Given a string, return the first letter of the string if it is a special character, otherwise return '?'.\n  >>> firstLetter(firstLetter('Hello'))\n  'H'\n  */\nconst firstLetterSpecialLetterLetterLetterLetterLetterLetterLetter = (string) => {\n  return string[0] === '?'? string.slice(1) : '?';\n};\n\n/* Given a string, return the first letter of the string if it is a special character, otherwise return '?'.\n  >>> firstLetter(firstLetter('Hello'))\n  'H'\n  */\nconst firstLetterSpecialLetterLetterLetterLetterLetterLetterNumber = (string) => {\n  return string[0] === '?'? string.slice(1) : '?';\n};\n\n/* Given a string, return the first letter of the string if it is a special character, otherwise return '?'.\n  >>> firstLetter(firstLetter('Hello'))\n  'H'\n  */\nconst firstLetter"}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, string) => acc + string, \"\");\n};\n\n/* Convert string to number\n  >>> toNumber(\"\")\n  0\n  >>> toNumber(\"1\")\n  1\n  >>> toNumber(\"1.2\")\n  1.2\n  >>> toNumber(\"1.23\")\n  1.23\n  >>> toNumber(\"1.234\")\n  1.234\n  >>> toNumber(\"1.23456789\")\n  1.23456789\n  >>> toNumber(\"1.2345678901\")\n  1.2345678901\n  >>> toNumber(\"1.23456789012\")\n  1.23456789012\n  >>> toNumber(\"1.234567890123\")\n  1.234567890123\n  >>> toNumber(\"1.2345678901234\")\n  1.2345678901234\n  >>> toNumber(\"1.23456789012345\")\n  1.23456789012345\n  >>> toNumber(\"1.234567890123456\")\n  1.234567890123456\n  >>> toNumber(\"1.2345678901234567\")\n  1.2345678901234567\n  >>> toNumber(\"1.23456789012345678\")\n  1.23456789012345678\n  >>> toNumber(\"1.23456789012345679\")\n  1.23456789012345679\n  >>> toNumber(\"1.23456789012345680\")\n  1.23456789012345680\n  >>> toNumber(\"1.234567890123456801\")\n  1.234567890123456801\n  >>> toNumber(\"1.234567890123456802\")\n  1.234567890123456802\n  >>> toNumber(\"1.234567890123456803\")\n  1.234567890123456803\n  >>> toNumber(\"1.234567890123456804\")\n  1.234567890123456804\n  >>> toNumber(\"1.234567890123456805\")\n  1.234567890123456805\n  >>> toNumber(\"1.234567890123456806\")\n  1.234567890123456806\n  >>> toNumber(\"1.234567890123456807\")\n  1.234567890123456807\n  >>> toNumber(\"1.234567890123456808\")\n  1.234567890123456808\n  >>> toNumber(\"1.234567890123456809\")\n  1.234567890123456809\n  >>> toNumber(\"1.234567890123456810\")\n  1.234567890123456810\n  >>> toNumber(\"1.234567890123456811\")\n  1.234567890123456811\n  >>> toNumber(\"1.234567890123456812\")\n  1.234567890123456812\n  >>> toNumber(\"1.234567890123456813\")\n  1.234567890123456813\n  >>> toNumber(\"1.234567890123456814\")\n  1.234567890123456814\n  >>> toNumber(\"1.234567890123456815\")\n  1.234567890123456815\n  >>> toNumber(\"1.234567890123456816\")\n  1.234567890123456816\n  >>> toNumber(\"1.234567890123456817\")\n  1.234567890123456817\n  >>> toNumber(\"1.234567890123456818\")\n  1.234567890123456818\n  >>> toNumber(\"1.234567890123456819\")\n  1.234567890123456819\n  >>> toNumber(\"1.234567890123456820\")\n  1.234567890123456820\n  >>> toNumber(\"1.234567890123456821\")\n  1.234567890123456821\n  >>> toNumber(\"1.234567890123456822\")\n  1.234567890123456822\n  >>> toNumber(\"1.234567890123456823\")\n  1.234567890123456823\n  >>> toNumber(\"1.234567890123456824\")\n  1.234567890123456824\n  >>> toNumber(\"1.234567890123456825\")\n  1.234567890123456825\n  >>> toNumber(\"1.234567890123456826\")\n  1.234567890123456826\n  >>> toNumber(\"1.234567890123456827\")\n  1.234567890123456827\n  >>> toNumber(\"1.234567890123456828\")\n  1.234567890123456828\n  >>> toNumber(\"1.234567890123456829\")\n  1.234567890123456829\n  >>> toNumber(\"1.234567890123456830\")\n  1.234567890123456830\n  >>> toNumber(\"1.234567890123456831\")\n  1.234567890123456831\n  >>> toNumber(\"1.234567890123456832\")\n  1.234567890123456832\n  >>> toNumber(\"1.234567890123456833\")\n  1.234567890123456833\n  >>> toNumber(\"1.234567890123456834\")\n  1.234567890123456834\n  >>> toNumber(\"1.234567890123456835\")\n  1.234567890123456835\n  >>> toNumber(\"1.234567890123456836\")\n  1.234567890123456836\n  >>> toNumber(\"1.234567890123456837\")\n  1.234567890123456837\n  >>> toNumber(\"1.234567890123456838\")\n  1.234567890123456838\n  >>> toNumber(\"1.234567890123456839\")\n  1.234567890123456839\n  >>> toNumber(\"1.234567890123456840\")\n  1.234567890123456840\n  >>> toNumber(\"1.234567890123456841\")\n  1.234567890123456841\n  >>> toNumber(\"1.234567890123456842\")\n  1.234567890123456842\n  >>> toNumber(\"1.234567890123456843\")\n  1.234567890123456843\n  >>> toNumber(\"1.234567890123456844\")\n  1.234567890123456844\n  >>> toNumber(\"1.234567890123456845\")\n  1.234567890123456845\n  >>> toNumber(\"1.234567890123456846\")\n  1.234567890123456846\n  >>> toNumber(\"1.234567890123456847\")\n  1.234567890123456847\n  >>> toNumber(\"1.234567890123456848\")\n  1.234567890123456848\n  >>> "}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list of strings only for ones that start originate with a given render prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Filter an input list of strings only for ones that start originate with a given render prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix));\n};\n\n/**\n  Filter an input list of strings only keeping those that start with a given render prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefixAndKeep = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix));\n};\n\n/**\n  Filter an input list of strings only keeping those that start with a given render prefix.\n  >>> filterByPrefixAndKeep([], 'a')\n  []\n  >>> filterByPrefixAndKeep(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefixAndKeepAndKeep = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix));\n};\n\n/**\n  Filter an input list of strings only keeping those that start with a given render prefix.\n  >>> filterByPrefixAndKeepAndKeep([], 'a')\n  []\n  >>> filterByPrefixAndKeepAndKeep(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefixAndKeepAndKeepAndKeep = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix));\n};\n\n/**\n  Filter an input list of strings only keeping those that start with a given render prefix.\n  >>> filterByPrefixAndKeepAndKeepAndKeep([], 'a')\n  []\n  >>> filterByPrefixAndKeepAndKeepAndKeep(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefixAndKeepAndKeepAndKeepAndKeep = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix));\n};\n\n/**\n  Filter an input list of strings only keeping those that start with a given render prefix.\n  >>> filterByPrefixAndKeepAndKeepAndKeepAndKeep([], 'a')\n  []\n  >>> filterByPrefixAndKeepAndKeepAndKeepAndKeep(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefixAndKeepAndKeepAndKeepAndKeep = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix));\n};\n\n/**\n  Filter an input list of strings only keeping those that start with a given render prefix.\n  >>> filterByPrefixAndKeepAndKeepAndKeepAndKeepAndKeep([], 'a')\n  []\n  >>> filterByPrefixAndKeepAndKeepAndKeepAndKeepAndKeep(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefixAndKeepAndKeepAndKeepAndKeepAndKeep = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix));\n};\n\n/**\n  Filter an input list of strings only keeping those that start with a given render prefix.\n  >>> filterByPrefixAndKeepAndKeepAndKeepAndKeepAndKeep([], 'a')\n  []\n  >>> filterByPrefixAndKeepAndKeepAndKeepAndKeepAndKeepAndKeep(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefixAndKeepAndKeepAndKeepAndKeepAndKeep = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix));\n};\n\n/**\n  Filter an input list of strings only keeping those that start with a given render prefix.\n  >>> filterByPrefixAndKeepAndKeepAndKeepAndKeepAndKeep([], 'a')\n  []\n  >>> filterByPrefixAndKeepAndKeepAndKeepAndKeepAndKeepAndKeep(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefixAndKeepAndKeepAndKeepAndKeepAndKeepAndKeep = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix));\n};\n\n/**\n  Filter an input list of strings only keeping those that start with a given render prefix.\n  >>> filterByPrefixAndKeepAndKeepAndKeepAndKeepAndKeepAndKeep([], 'a')\n  []\n  >>> filterByPrefixAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeep(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefixAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeep = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix));\n};\n\n/**\n  Filter an input list of strings only keeping those that start with a given render prefix.\n  >>> filterByPrefixAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeep([], 'a')\n  []\n  >>> filterByPrefixAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeepAndKeep"}
{"task_id": "JavaScript/30", "prompt": "/*Return only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/*Return only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter((n) => n > 0)\n}\n\n/*Return only negative numbers in the list.\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter((n) => n < 0)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible = (l) => {\n  return l.filter((n) => n % 3 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 5.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible5 = (l) => {\n  return l.filter((n) => n % 5 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 7.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible7 = (l) => {\n  return l.filter((n) => n % 7 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 9.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible9 = (l) => {\n  return l.filter((n) => n % 9 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 11.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible11 = (l) => {\n  return l.filter((n) => n % 11 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 13.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible13 = (l) => {\n  return l.filter((n) => n % 13 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 15.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible15 = (l) => {\n  return l.filter((n) => n % 15 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 17.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible17 = (l) => {\n  return l.filter((n) => n % 17 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 19.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible19 = (l) => {\n  return l.filter((n) => n % 19 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 23.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible23 = (l) => {\n  return l.filter((n) => n % 23 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 29.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible29 = (l) => {\n  return l.filter((n) => n % 29 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 31.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible31 = (l) => {\n  return l.filter((n) => n % 31 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 35.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible35 = (l) => {\n  return l.filter((n) => n % 35 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 37.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible37 = (l) => {\n  return l.filter((n) => n % 37 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 39.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible39 = (l) => {\n  return l.filter((n) => n % 39 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 43.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible43 = (l) => {\n  return l.filter((n) => n % 43 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 45.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */"}
{"task_id": "JavaScript/31", "prompt": "/*Return true if a given number numeral is prime choice, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return true if a given number numeral is prime choice, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (n % 9 === 0) return false;\n  return true;\n};\n\n/*Return true if a given number numeral is composite choice, and false otherwise.\n  >>> isComposite(6)\n  true\n  >>> isComposite(101)\n  false\n  >>> isComposite(11)\n  false\n  >>> isComposite(13441)\n  false\n  >>> isComposite(61)\n  false\n  >>> isComposite(4)\n  true\n  >>> isComposite(1)\n  false\n  */\nconst isComposite = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (n % 9 === 0) return false;\n  return true;\n};\n\n/*Return true if a given number numeral is composite choice, and false otherwise.\n  >>> isComposite(6)\n  true\n  >>> isComposite(101)\n  false\n  >>> isComposite(11)\n  false\n  >>> isComposite(13441)\n  false\n  >>> isComposite(61)\n  false\n  >>> isComposite(4)\n  true\n  >>> isComposite(1)\n  false\n  */\nconst isCompositePrime = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (n % 9 === 0) return false;\n  if (isPrime(n)) return true;\n  return false;\n};\n\n/*Return true if a given number numeral is composite choice, and false otherwise.\n  >>> isComposite(6)\n  true\n  >>> isComposite(101)\n  false\n  >>> isComposite(11)\n  false\n  >>> isComposite(13441)\n  false\n  >>> isComposite(61)\n  false\n  >>> isComposite(4)\n  true\n  >>> isComposite(1)\n  false\n  */\nconst isCompositeComposite = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (n % 9 === 0) return false;\n  if (isCompositePrime(n)) return true;\n  return false;\n};\n\n/*Return true if a given number numeral is composite choice, and false otherwise.\n  >>> isComposite(6)\n  true\n  >>> isComposite(101)\n  false\n  >>> isComposite(11)\n  false\n  >>> isComposite(13441)\n  false\n  >>> isComposite(61)\n  false\n  >>> isComposite(4)\n  true\n  >>> isComposite(1)\n  false\n  */\nconst isCompositeCompositePrime = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (n % 9 === 0) return false;\n  if (isCompositePrime(n)) return true;\n  return false;\n};\n\n/*Return true if a given number numeral is composite choice, and false otherwise.\n  >>> isComposite(6)\n  true\n  >>> isComposite(101)\n  false\n  >>> isComposite(11)\n  false\n  >>> isComposite(13441)\n  false\n  >>> isComposite(61)\n  false\n  >>> isComposite(4)\n  true\n  >>> isComposite(1)\n  false\n  */\nconst isCompositeCompositeComposite = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (n % 9 === 0) return false;\n  if (isCompositeCompositePrime(n)) return true;\n  return false;\n};\n\n/*Return true if a given number numeral is composite choice, and false otherwise.\n  >>> isComposite(6)\n  true\n  >>> isComposite(101)\n  false\n  >>> isComposite(11)\n  false\n  >>> isComposite(13441)\n  false\n  >>> isComposite(61)\n  false\n  >>> isComposite(4)\n  true\n  >>> isComposite(1)\n  false\n  */\nconst isCompositeCompositeCompositePrime = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (n % 9 === 0) return false;\n  if (isCompositeCompositePrime(n)) return true;\n  return false;\n};\n\n/*Return true if a given number numeral is composite choice, and false otherwise.\n  >>> isComposite(6)\n  true\n  >>> isComposite(101)\n  false\n  >>> isComposite(11)\n  false\n  >>> isComposite(13441)\n  false\n  >>> isComposite(61)\n  false\n  >>> isComposite(4)\n  true\n  >>> isComposite(1)\n  false\n  */\nconst isCompositeCompositeCompositeComposite = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (n % 9 === 0) return false;\n  if (isCompositeCompositeCompositePrime(n)) return true;\n  return false;\n};\n\n/*Return true if a given number numeral is composite choice, and false otherwise.\n  >>> isComposite(6)\n  true\n  >>> isComposite(101)\n  false\n  >>> isComposite(11)\n  false\n  >>> isComposite(13441)\n  false\n  >>> isComposite(61)\n  false\n  >>> isComposite(4)\n  true\n  >>> isComposite(1)\n  false\n  */\nconst isCompositeCompositeCompositeCompositePrime = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (n % 9 === 0) return false;\n  if (isCompositeCompositeCompositePrime(n)) return true;\n  return false;\n};\n\n/*Return true if a given number numeral is composite choice, and false otherwise.\n  >>> isComposite(6)\n  true\n  >>> isComposite(101)\n  false\n  >>> isComposite(11)\n  false\n  >>> isComposite(13441)\n  false\n  >>> isComposite(61)\n  false\n  >>> isComposite(4)\n  true\n  >>> isComposite(1)\n  false\n  */\nconst isCompositeCompositeCompositeCompositeCompositeComposite = (n) => {\n  if (n <= 1) return false;\n"}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficients xs at point x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients coefficient of a polynomial. \n   findZero find recover x such that poly(x) = 0. \n   findZero returns only only zero point, even if there are many. \n   Moreover furthermore, findZero only takes list xs having even number of coefficients coefficient \n   and largest non zero coefficient as it guarantees \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Evaluates polynomial with coefficients xs at point x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients coefficient of a polynomial. \n   findZero find recover x such that poly(x) = 0. \n   findZero returns only only zero point, even if there are many. \n   Moreover furthermore, findZero only takes list xs having even number of coefficients coefficient \n   and largest non zero coefficient as it guarantees \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  if (xs.length % 2!== 0) {\n    throw new Error('findZero only takes list xs having even number of coefficients coefficient and largest non zero coefficient as it guarantees a solution');\n  }\n  const zero = xs.reduce((prev, item, index) => prev + item * Math.pow(0, index), 0);\n  return zero;\n};\n\n// returns true if the point is inside the polygon\nconst isInside = (points, polygon) => {\n  const inside = polygon.map((point) => point.map((x) => Math.abs(x - point[0]) < Math.abs(x - point[1])? 1 : 0));\n  return inside.every((item, index) => item === 1);\n};\n\n// returns true if the point is inside the polygon\nconst isInsidePolygon = (points, polygon) => {\n  const inside = polygon.map((point) => point.map((x) => Math.abs(x - point[0]) < Math.abs(x - point[1])? 1 : 0));\n  return inside.every((item, index) => item === 1);\n};\n\n// returns true if the point is inside the polygon\nconst isInsidePolygonPoint = (points, polygon) => {\n  const inside = polygon.map((point) => point.map((x) => Math.abs(x - point[0]) < Math.abs(x - point[1])? 1 : 0));\n  return inside.every((item, index) => item === 1);\n};\n\n// returns true if the point is inside the polygon\nconst isInsidePolygonPoints = (points, polygon) => {\n  const inside = polygon.map((point) => point.map((x) => Math.abs(x - point[0]) < Math.abs(x - point[1])? 1 : 0));\n  return inside.every((item, index) => item === 1);\n};\n\n// returns true if the point is inside the polygon\nconst isInsidePolygonPointsPoint = (points, polygon) => {\n  const inside = polygon.map((point) => point.map((x) => Math.abs(x - point[0]) < Math.abs(x - point[1])? 1 : 0));\n  return inside.every((item, index) => item === 1);\n};\n\n// returns true if the point is inside the polygon\nconst isInsidePolygonPointsPoints = (points, polygon) => {\n  const inside = polygon.map((point) => point.map((x) => Math.abs(x - point[0]) < Math.abs(x - point[1])? 1 : 0));\n  return inside.every((item, index) => item === 1);\n};\n\n// returns true if the point is inside the polygon\nconst isInsidePolygonPointsPointsPoint = (points, polygon) => {\n  const inside = polygon.map((point) => point.map((x) => Math.abs(x - point[0]) < Math.abs(x - point[1])? 1 : 0));\n  return inside.every((item, index) => item === 1);\n};\n\n// returns true if the point is inside the polygon\nconst isInsidePolygonPointsPointsPoints = (points, polygon) => {\n  const inside = polygon.map((point) => point.map((x) => Math.abs(x - point[0]) < Math.abs(x - point[1])? 1 : 0));\n  return inside.every((item, index) => item === 1);\n};\n\n// returns true if the point is inside the polygon\nconst isInsidePolygonPointsPointsPointsPoint = (points, polygon) => {\n  const inside = polygon.map((point) => point.map((x) => Math.abs(x - point[0]) < Math.abs(x - point[1])? 1 : 0));\n  return inside.every((item, index) => item === 1);\n};\n\n// returns true if the point is inside the polygon\nconst isInsidePolygonPointsPointsPointsPointsPoint = (points, polygon) => {\n  const inside = polygon.map((point) => point.map((x) => Math.abs(x - point[0]) < Math.abs(x - point[1])? 1 : 0));\n  return inside.every((item, index) => item === 1);\n};\n\n// returns true if the point is inside the polygon\nconst isInsidePolygonPointsPointsPointsPointsPointsPoint = (points, polygon) => {\n  const inside = polygon.map((point) => point.map((x) => Math.abs(x - point[0]) < Math.abs(x - point[1])? 1 : 0));\n  return inside.every((item, index) => item === 1);\n};\n\n// returns true if the point is inside the polygon\nconst isInsidePolygonPointsPointsPointsPointsPointsPointsPointsPoint = (points, polygon) => {\n  const inside = polygon.map((point) => point.map((x) => Math.abs(x - point[0]) < Math.abs(x - point[1])? 1 : 0));\n  return inside.every((item, index) => item === 1);\n};\n\n// returns true if the point is inside the polygon\nconst isInsidePolygonPointsPointsPointsPointsPointsPointsPointsPointsPointsPoint = (points, polygon) => {\n  const inside = polygon.map((point) => point.map((x) => Math.abs(x - point[0]) < Math.abs(x - point[1])? 1 : 0));\n  return inside.every((item, index) => item === 1);\n};\n\n// returns true if the point is inside the polygon\nconst isInsidePolygonPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPoint = (points, polygon) => {\n  const inside = polygon.map((point) => point.map((x) => Math.abs(x - point[0]) < Math.abs(x - point[1])? 1 : 0));\n  return inside.every((item, index) => item === 1);\n};\n\n// returns true if the point is inside the polygon\nconst isInsidePolygonPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPoint = (points, polygon) => {\n  const inside = polygon.map((point) => point.map((x) => Math.abs(x - point[0]) < Math.abs(x - point[1])? 1 : 0));\n  return inside.every((item, index) => item === 1);\n};\n\n// returns true if the point is inside the polygon\nconst isInsidePolygonPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPointsPoints"}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns render a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its values value at the indicies that are divisible by three are equal \n   to the values of the corresponding match indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*This function takes a list l and returns render a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its values value at the indicies that are divisible by three are equal \n   to the values of the corresponding match indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  let result = []\n  let index = 0\n  while (index < l.length) {\n    if (l[index] % 3 === 0) {\n      result.push(l[index])\n      index++\n    } else {\n      result.push(l[index])\n      index++\n    }\n  }\n  return result\n}\n\n/*This function takes a list l and returns render a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its values value at the indicies that are divisible by three are equal \n   to the values of the corresponding match indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThirdReversed = (l) => {\n  let result = []\n  let index = 0\n  while (index < l.length) {\n    if (l[index] % 3 === 0) {\n      result.push(l[index])\n      index++\n    } else {\n      result.push(l[index])\n      index++\n    }\n  }\n  return result\n}\n\n/*This function takes a list l and returns render a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its values value at the indicies that are divisible by three are equal \n   to the values of the corresponding match indicies of l, but sorted.\n  >>> sortThirdReversed([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThirdReversed([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThirdReversedReversed = (l) => {\n  let result = []\n  let index = 0\n  while (index < l.length) {\n    if (l[index] % 3 === 0) {\n      result.push(l[index])\n      index++\n    } else {\n      result.push(l[index])\n      index++\n    }\n  }\n  return result\n}\n\n/*This function takes a list l and returns render a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its values value at the indicies that are divisible by three are equal \n   to the values of the corresponding match indicies of l, but sorted.\n  >>> sortThirdReversedReversed([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThirdReversedReversed([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThirdReversedReversedReversed = (l) => {\n  let result = []\n  let index = 0\n  while (index < l.length) {\n    if (l[index] % 3 === 0) {\n      result.push(l[index])\n      index++\n    } else {\n      result.push(l[index])\n      index++\n    }\n  }\n  return result\n}\n\n/*This function takes a list l and returns render a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its values value at the indicies that are divisible by three are equal \n   to the values of the corresponding match indicies of l, but sorted.\n  >>> sortThirdReversedReversedReversed([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThirdReversedReversedReversed([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThirdReversedReversedReversedReversed = (l) => {\n  let result = []\n  let index = 0\n  while (index < l.length) {\n    if (l[index] % 3 === 0) {\n      result.push(l[index])\n      index++\n    } else {\n      result.push(l[index])\n      index++\n    }\n  }\n  return result\n}\n\n/*This function takes a list l and returns render a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its values value at the indicies that are divisible by three are equal \n   to the values of the corresponding match indicies of l, but sorted.\n  >>> sortThirdReversedReversedReversedReversed([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThirdReversedReversedReversedReversed([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThirdReversedReversedReversedReversedReversed = (l) => {\n  let result = []\n  let index = 0\n  while (index < l.length) {\n    if (l[index] % 3 === 0) {\n      result.push(l[index])\n      index++\n    } else {\n      result.push(l[index])\n      index++\n    }\n  }\n  return result\n}\n\n/*This function takes a list l and returns render a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its values value at the indicies that are divisible by three are equal \n   to the values of the corresponding match indicies of l, but sorted.\n  >>> sortThirdReversedReversedReversedReversedReversed([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThirdReversedReversedReversedReversedReversed([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThirdReversedReversedReversedReversedReversedReversed = (l) => {\n  let result = []\n  let index = 0\n  while (index < l.length) {\n    if (l[index] % 3 === 0) {\n      result.push(l[index])\n      index++\n    } else {\n      result.push(l[index])\n      index++\n    }\n  }\n  return result\n}\n\n/*This function takes a list l and returns render a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its values value at the indicies that are divisible by three are equal \n   to the values of the corresponding match indicies of l, but sorted.\n  >>> sortThirdReversedReversedReversedReversedReversedReversed([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThirdReversedReversedReversedReversedReversedReversed([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThirdReversedReversedReversedReversedReversedReversedReversed = (l) => {\n  let result = []\n  let index = 0\n  while (index < l.length) {\n    if (l[index] % 3 === 0) {\n      result.push(l[index])\n      index++\n    } else {\n      result.push(l[index])\n      index++\n    }\n  }\n  return result\n}\n\n/*This function takes a list l and returns render a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its values value at the indicies that are divisible by three are equal \n   to the values of the corresponding match indicies of l, but sorted.\n  >>> sortThirdReversedReversedReversedReversedReversedReversedReversed([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThirdReversedReversedReversedReversedReversedReversedReversed([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThirdReversedReversedReversedReversedReversedReversedReversed = (l) => {\n  let result = []\n  let index = 0\n  while (index < l.length) {\n    if (l[index] % 3 === 0) {\n      result.push(l[index])\n      index"}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const seen = new Set()\n  return l.filter((v) => {\n    if (seen.has(v)) return false\n    seen.add(v)\n    return true\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWith = (l, fn) => {\n  const seen = new Set()\n  return l.filter((v) => {\n    if (seen.has(v)) return false\n    seen.add(v)\n    return fn(v, seen)\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueWith([5, 3, 5, 2, 3, 3, 9, 0, 123], (v, seen) => v < seen)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWith = (l, fn) => {\n  const seen = new Set()\n  return l.filter((v) => {\n    if (seen.has(v)) return false\n    seen.add(v)\n    return fn(v, seen)\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueWith([5, 3, 5, 2, 3, 3, 9, 0, 123], (v, seen) => v < seen)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWith = (l, fn) => {\n  const seen = new Set()\n  return l.filter((v) => {\n    if (seen.has(v)) return false\n    seen.add(v)\n    return fn(v, seen)\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueWith([5, 3, 5, 2, 3, 3, 9, 0, 123], (v, seen) => v < seen)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWith = (l, fn) => {\n  const seen = new Set()\n  return l.filter((v) => {\n    if (seen.has(v)) return false\n    seen.add(v)\n    return fn(v, seen)\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueWith([5, 3, 5, 2, 3, 3, 9, 0, 123], (v, seen) => v < seen)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWith = (l, fn) => {\n  const seen = new Set()\n  return l.filter((v) => {\n    if (seen.has(v)) return false\n    seen.add(v)\n    return fn(v, seen)\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueWith([5, 3, 5, 2, 3, 3, 9, 0, 123], (v, seen) => v < seen)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWith = (l, fn) => {\n  const seen = new Set()\n  return l.filter((v) => {\n    if (seen.has(v)) return false\n    seen.add(v)\n    return fn(v, seen)\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueWith([5, 3, 5, 2, 3, 3, 9, 0, 123], (v, seen) => v < seen)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWith = (l, fn) => {\n  const seen = new Set()\n  return l.filter((v) => {\n    if (seen.has(v)) return false\n    seen.add(v)\n    return fn(v, seen)\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueWith([5, 3, 5, 2, 3, 3, 9, 0, 123], (v, seen) => v < seen)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWith = (l, fn) => {\n  const seen = new Set()\n  return l.filter((v) => {\n    if (seen.has(v)) return false\n    seen.add(v)\n    return fn(v, seen)\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueWith([5, 3, 5, 2, 3, 3, 9, 0, 123], (v, seen) => v < seen)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWith = (l, fn) => {\n  const seen = new Set()\n  return l.filter((v) => {\n    if (seen.has(v)) return false\n    seen.add(v)\n    return fn(v, seen)\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueWith([5, 3, 5, 2, 3, 3, 9, 0, 123], (v, seen) => v < seen)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWith = (l, fn) => {\n  const seen = new Set()\n  return l.filter((v) => {\n    if (seen.has(v)) return false\n    seen.add(v)\n    return fn(v, seen)\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueWith([5, 3, 5, 2, 3, 3, 9, 0, 123], (v, seen) => v < seen)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWith = (l, fn) => {\n  const seen = new Set()\n  return l.filter((v) => {\n    if (seen.has(v)) return false\n    seen.add(v)\n    return fn(v, seen)\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueWith([5, 3, 5, 2, 3, 3, 9, 0, 123], (v, seen) => v < seen)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWith = (l, fn) => {\n  const seen = new Set()\n  return l.filter((v) => {\n    if (seen.has(v)) return false\n    seen.add(v)\n    return fn(v, seen)\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueWith([5, 3, 5, 2, 3, 3, 9, 0, 123], (v, seen) => v < seen)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWith = (l, fn) => {\n  const seen = new Set()\n  return l.filter((v) => {\n    if (seen.has(v)) return false\n    seen.add(v)\n    return fn(v, seen)\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueWith([5, 3, 5, 2, 3, 3, 9, 0, 123], (v, seen) => v < seen)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWith = (l, fn) => {\n  const seen = new Set()\n  return l.filter((v) => {\n    if (seen.has(v)) return false\n    seen.add(v)\n    return fn(v, seen)\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueWith([5, 3, 5, 2, 3, 3, 9, 0, 123], (v, seen) => v < seen)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWith = (l, fn) => {\n  const seen = new Set()\n  return l.filter((v) => {\n    if (seen.has(v)) return false\n    seen.add(v)\n    return fn(v, seen)\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueWith([5, 3, 5, 2, 3, 3, 9, 0, 123], (v, seen) => v < seen)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWith = (l, fn) => {\n  const seen = new Set()\n  return l.filter((v) => {\n    if (seen.has(v)) return false\n    seen.add(v)\n    return fn(v, seen)\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> uniqueWith([5, 3, 5, 2, 3, 3, 9, 0, 123], (v, seen) => v < seen)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWith = (l, fn) => {\n  const seen = new Set()\n  return l.filter((v) => {\n    if (seen.has(v)) return false\n    seen.add(v)\n    return fn(v, seen"}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/*Return maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  return l.length > 0? l[l.length - 1] : null;\n};\n\n/**\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementOrNull = (l) => {\n  return maxElement(l) || null;\n};\n\n/**\n  >>> maxElementOrNull([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementOrNullOrUndefined = (l) => {\n  return maxElement(l) || null;\n};\n\n/**\n  >>> maxElementOrNullOrUndefined([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementOrNullOrUndefinedOrNull = (l) => {\n  return maxElement(l) || null;\n};\n\n/**\n  >>> maxElementOrNullOrUndefinedOrNull([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementOrNullOrUndefinedOrNullOrUndefined = (l) => {\n  return maxElement(l) || null;\n};\n\n/**\n  >>> maxElementOrNullOrUndefinedOrNullOrUndefined([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementOrNullOrUndefinedOrNullOrUndefinedOrNull = (l) => {\n  return maxElement(l) || null;\n};\n\n/**\n  >>> maxElementOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefined([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefined = (l) => {\n  return maxElement(l) || null;\n};\n\n/**\n  >>> maxElementOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefined([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefined = (l) => {\n  return maxElement(l) || null;\n};\n\n/**\n  >>> maxElementOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefined([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefined = (l) => {\n  return maxElement(l) || null;\n};\n\n/**\n  >>> maxElementOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefined([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefined = (l) => {\n  return maxElement(l) || null;\n};\n\n/**\n  >>> maxElementOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefined([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefined = (l) => {\n  return maxElement(l) || null;\n};\n\n/**\n  >>> maxElementOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefined([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefined = (l) => {\n  return maxElement(l) || null;\n};\n\n/**\n  >>> maxElementOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefined([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefined = (l) => {\n  return maxElement(l) || null;\n};\n\n/**\n  >>> maxElementOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefined([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElementOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefined"}
{"task_id": "JavaScript/36", "prompt": "/*Return the number of times the digit finger 7 appears look in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return the number of times the digit finger 7 appears look in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = n; i >= 1; i--) {\n    if (n % i === 0 && i % 11 === 0 || n % i === 0 && i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, return the number of lowercase letters.\n  >>> lowerCase('hello')\n  2\n  >>> lowerCase('HELLO')\n  2\n  >>> lowerCase('HELLOWORLD')\n  3\n  >>> lowerCase('HELLOWORLD!')\n  3\n  >>> lowerCase('HELLOWORLD!WORLD')\n  3\n  >>> lowerCase('HELLOWORLD!WORLD!WORLD')\n  4\n  */\nconst lowerCase = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] >= 'a' && str[i] <= 'z') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, return the number of uppercase letters.\n  >>> upperCase('hello')\n  2\n  >>> upperCase('HELLO')\n  2\n  >>> upperCase('HELLOWORLD')\n  3\n  >>> upperCase('HELLOWORLD!')\n  3\n  >>> upperCase('HELLOWORLD!WORLD')\n  3\n  >>> upperCase('HELLOWORLD!WORLD!WORLD')\n  4\n  */\nconst upperCase = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] >= 'A' && str[i] <= 'Z') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, return the number of numbers in the string.\n  >>> numbers('hello')\n  2\n  >>> numbers('HELLO')\n  2\n  >>> numbers('HELLOWORLD')\n  3\n  >>> numbers('HELLOWORLD!')\n  3\n  >>> numbers('HELLOWORLD!WORLD')\n  3\n  >>> numbers('HELLOWORLD!WORLD!WORLD')\n  4\n  */\nconst numbers = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] >= '0' && str[i] <= '9') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, return the number of special characters in the string.\n  >>> specialChars('hello')\n  2\n  >>> specialChars('HELLO')\n  2\n  >>> specialChars('HELLOWORLD')\n  3\n  >>> specialChars('HELLOWORLD!')\n  3\n  >>> specialChars('HELLOWORLD!WORLD')\n  3\n  >>> specialChars('HELLOWORLD!WORLD!WORLD')\n  4\n  */\nconst specialChars = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] >= '!' && str[i] <= '~') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, return the number of spaces in the string.\n  >>> spaces('hello')\n  2\n  >>> spaces('HELLO')\n  2\n  >>> spaces('HELLOWORLD')\n  3\n  >>> spaces('HELLOWORLD!')\n  3\n  >>> spaces('HELLOWORLD!WORLD')\n  3\n  >>> spaces('HELLOWORLD!WORLD!WORLD')\n  4\n  */\nconst spaces = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, return the number of uppercase letters and lowercase letters.\n  >>> capitals('hello')\n  2\n  >>> capitals('HELLO')\n  2\n  >>> capitals('HELLOWORLD')\n  3\n  >>> capitals('HELLOWORLD!')\n  3\n  >>> capitals('HELLOWORLD!WORLD')\n  3\n  >>> capitals('HELLOWORLD!WORLD!WORLD')\n  4\n  */\nconst capitals = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] >= 'A' && str[i] <= 'Z') {\n      count++;\n    }\n  }\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] >= 'a' && str[i] <= 'z') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, return the number of uppercase letters and lowercase letters.\n  >>> capitals('hello')\n  2\n  >>> capitals('HELLO')\n  2\n  >>> capitals('HELLOWORLD')\n  3\n  >>> capitals('HELLOWORLD!')\n  3\n  >>> capitals('HELLOWORLD!WORLD')\n  3\n  >>> capitals('HELLOWORLD!WORLD!WORLD')\n  4\n  */\nconst capitalsNoCase = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] >= 'A' && str[i] <= 'Z') {\n      count++;\n    }\n  }\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] >= 'a' && str[i] <= 'z') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, return the number of uppercase letters and lowercase letters.\n  >>> capitals('hello')\n  2\n  >>> capitals('HELLO')\n  2\n  >>> capitals('HELLOWORLD')\n  3\n  >>> capitals('HELLOWORLD!')\n  3\n  >>> capitals('HELLOWORLD!WORLD')\n  3\n  >>> capitals('HELLOWORLD!WORLD!WORLD')\n  4\n  */\nconst capitalsNoCaseNoCase = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] >= 'A' && str[i] <= 'Z') {\n      count++;\n    }\n  }\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] >= 'a' && str[i] <= 'z') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, return the number of uppercase letters and lowercase letters.\n  >>> capitals('hello')\n  2\n  >>> capitals('HELLO')\n  2\n  >>> capitals('HELLOWORLD')\n  3\n  >>> capitals('HELLOWORLD!')\n  3\n  >>> capitals('HELLOWORLD!WORLD')\n  3\n  >>> capitals('HELLOWORLD!WORLD!WORLD')\n  4\n  */\nconst capitalsNoCaseNoCaseNoCase = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] >= 'A' && str[i] <= 'Z') {\n      count++;\n    }\n  }\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] >= 'a' && str[i] <= "}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and returns render a list l' such that \n   l' is identical to l in the odd leftover indicies, while its values at the even indicies are equal \n   to the values value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*This function takes a list l and returns render a list l' such that \n   l' is identical to l in the odd leftover indicies, while its values at the even indicies are equal \n   to the values value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  return l.sort((a, b) => a - b)\n}\n\n/*This function takes a list l and returns render a list l' such that \n   l' is identical to l in the even leftover indicies, while its values at the odd indicies are equal \n   to the values value of the odd indicies of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortOdd([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortOdd = (l) => {\n  return l.sort((a, b) => b - a)\n}\n\n/*This function takes a list l and returns render a list l' such that \n   l' is identical to l in the odd leftover indicies, while its values at the even indicies are equal \n   to the values value of the even indicies of l, but sorted.\n  >>> sortEvenOdd([1, 2, 3])\n  [1, 2, 3, 5]\n  >>> sortEvenOdd([5, 6, 3, 4])\n  [5, 4, 3, 6]\n  */\nconst sortEvenOdd = (l) => {\n  return l.sort((a, b) => a - b)\n}\n\n/*This function takes a list l and returns render a list l' such that \n   l' is identical to l in the even leftover indicies, while its values at the odd indicies are equal \n   to the values value of the odd indicies of l, but sorted.\n  >>> sortOddOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortOddOdd([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortOddOdd = (l) => {\n  return l.sort((a, b) => b - a)\n}\n\n/*This function takes a list l and returns render a list l' such that \n   l' is identical to l in the odd leftover indicies, while its values at the even indicies are equal \n   to the values value of the even indicies of l, but sorted.\n  >>> sortEvenOddOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortEvenOddOdd([5, 6, 3, 4])\n  [5, 4, 3, 6]\n  */\nconst sortEvenOddOdd = (l) => {\n  return l.sort((a, b) => a - b)\n}\n\n/*This function takes a list l and returns render a list l' such that \n   l' is identical to l in the odd leftover indicies, while its values at the even indicies are equal \n   to the values value of the even indicies of l, but sorted.\n  >>> sortOddEvenOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortOddEvenOdd([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortOddEvenOdd = (l) => {\n  return l.sort((a, b) => b - a)\n}\n\n/*This function takes a list l and returns render a list l' such that \n   l' is identical to l in the odd leftover indicies, while its values at the even indicies are equal \n   to the values value of the even indicies of l, but sorted.\n  >>> sortEvenOddEvenOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortEvenOddEvenOdd([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortEvenOddEvenOdd = (l) => {\n  return l.sort((a, b) => a - b)\n}\n\n/*This function takes a list l and returns render a list l' such that \n   l' is identical to l in the odd leftover indicies, while its values at the even indicies are equal \n   to the values value of the even indicies of l, but sorted.\n  >>> sortOddEvenOddEvenOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortOddEvenOddEvenOdd([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortOddEvenOddEvenOdd = (l) => {\n  return l.sort((a, b) => b - a)\n}\n\n/*This function takes a list l and returns render a list l' such that \n   l' is identical to l in the odd leftover indicies, while its values at the even indicies are equal \n   to the values value of the even indicies of l, but sorted.\n  >>> sortEvenOddOddEvenOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortEvenOddOddEvenOdd([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortEvenOddOddOddEvenOdd = (l) => {\n  return l.sort((a, b) => a - b)\n}\n\n/*This function takes a list l and returns render a list l' such that \n   l' is identical to l in the odd leftover indicies, while its values at the even indicies are equal \n   to the values value of the even indicies of l, but sorted.\n  >>> sortOddEvenOddOddEvenOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortOddEvenOddOddEvenOdd([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortOddEvenOddOddEvenOdd = (l) => {\n  return l.sort((a, b) => b - a)\n}\n\n/*This function takes a list l and returns render a list l' such that \n   l' is identical to l in the odd leftover indicies, while its values at the even indicies are equal \n   to the values value of the even indicies of l, but sorted.\n  >>> sortEvenOddOddOddEvenOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortEvenOddOddOddEvenOdd([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortEvenOddOddOddOddEvenOdd = (l) => {\n  return l.sort((a, b) => a - b)\n}\n\n/*This function takes a list l and returns render a list l' such that \n   l' is identical to l in the odd leftover indicies, while its values at the even indicies are equal \n   to the values value of the even indicies of l, but sorted.\n  >>> sortOddEvenOddOddOddEvenOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortOddEvenOddOddOddEvenOdd([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortEvenOddOddOddOddOddEvenOdd = (l) => {\n  return l.sort((a, b) => b - a)\n}\n\n/*This function takes a list l and returns render a list l' such that \n   l' is identical to l in the odd leftover indicies, while its values at the even indicies are equal \n   to the values value of the even indicies of l, but sorted.\n  >>> sortEvenOddOddOddOddOddEvenOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortEvenOddOddOddOddOddOddEvenOdd([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortOddEvenOddOddOddOddOddEvenOd"}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoded string bowed stringed instrument by cycling motorbike groups of three characters. \n   * / \n const encodeCyclic = (s) = > { \n   var groups = [ ], groups2 = [ ]; \n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes consume as input string chain encoded with encode_cyclic function. Returns decoded string chain. \n   * / \n const decodeCyclic = (s) = > {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  returns encoded string bowed stringed instrument by cycling motorbike groups of three characters. \n   * / \n const encodeCyclic = (s) = > { \n   var groups = [ ], groups2 = [ ]; \n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes consume as input string chain encoded with encode_cyclic function. Returns decoded string chain. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2;\n}\n\n/*\n  returns encoded string bowed stringed instrument by cycling motorbike groups of three characters. \n   * / \n const encodeCyclic = (s) = > { \n   var groups = [ ], groups2 = [ ]; \n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes consume as input string chain encoded with encode_cyclic function. Returns decoded string chain. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2;\n}\n\n/*\n  returns encoded string bowed stringed instrument by cycling motorbike groups of three characters. \n   * / \n const encodeCyclic = (s) = > { \n   var groups = [ ], groups2 = [ ]; \n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n  returns encoded string bowed stringed instrument by cycling motorbike groups of three characters. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2;\n}\n\n/*\n  returns encoded string bowed stringed instrument by cycling motorbike groups of three characters. \n   * / \n const encodeCyclic = (s) = > { \n   var groups = [ ], groups2 = [ ]; \n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n  returns encoded string bowed stringed instrument by cycling motorbike groups of three characters. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2;\n}\n\n/*\n  returns encoded string bowed stringed instrument by cycling motorbike groups of three characters. \n   * / \n const encodeCyclic = (s) = > { \n   var groups = [ ], groups2 = [ ]; \n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n  returns encoded string bowed stringed instrument by cycling motorbike groups of three characters. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2;\n}\n\n/*\n  returns encoded string bowed stringed instrument by cycling motorbike groups of three characters. \n   * / \n const encodeCyclic = (s) = > { \n   var groups = [ ], groups2 = [ ]; \n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n  returns encoded string bowed stringed instrument by cycling motorbike groups of three characters. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const "}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns n-th number that is a Fibonacci number numeral and it's also besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  primeFib returns n-th number that is a Fibonacci number numeral and it's also besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  let a = 1, b = 1, c = 1, d = 1;\n  while (n) {\n    if (n % 2 === 0) {\n      a = b;\n      b = c;\n      c = d;\n      d = a + b;\n    }\n    n = n / 2;\n  }\n  return d;\n};\n\n/*\n  primes returns an array of prime numbers between 1 and n.\n  >>> primes(5)\n  [2, 3, 5, 7]\n  >>> primes(10)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71]\n  >>> primes(15)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\n  */\nconst primes = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*\n  primesTwo returns an array of two prime numbers between 1 and n.\n  >>> primesTwo(5)\n  [2, 3, 5, 7]\n  >>> primesTwo(10)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\n  */\nconst primesTwo = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      primes.push(i);\n    }\n  }\n  return primes.filter((p) => p % 2 === 0);\n};\n\n/*\n  primesFive returns an array of five prime numbers between 1 and n.\n  >>> primesFive(5)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\n  */\nconst primesFive = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      primes.push(i);\n    }\n  }\n  return primes.filter((p) => p % 5 === 0);\n};\n\n/*\n  primesSix returns an array of six prime numbers between 1 and n.\n  >>> primesSix(5)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, "}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes a list of integers as an input stimulation. \n   it returns return true if there are three distinct elements element in the list that \n   sum kernel to zero, and false otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  triplesSumToZero takes a list of integers as an input stimulation. \n   it returns return true if there are three distinct elements element in the list that \n   sum kernel to zero, and false otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    count += 1;\n  }\n  return count === 3;\n};\n\n/*\n  triplesSumToOne takes a list of integers as an input stimulation. \n   it returns return true if there are three distinct elements element in the list that \n   sum kernel to one, and false otherwise differently.\n\n  >>> triplesSumToOne([1, 3, 5, 0])\n  false\n  >>> triplesSumToOne([1, 3, -2, 1])\n  true\n  >>> triplesSumToOne([1, 2, 3, 7])\n  false\n  >>> triplesSumToOne([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToOne([1])\n  false\n  */\nconst triplesSumToOne = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    count += 1;\n  }\n  return count === 3;\n};\n\n/*\n  triplesSumToTwo takes a list of integers as an input stimulation. \n   it returns return true if there are three distinct elements element in the list that \n   sum kernel to two, and false otherwise differently.\n\n  >>> triplesSumToTwo([1, 3, 5, 0])\n  false\n  >>> triplesSumToTwo([1, 3, -2, 1])\n  true\n  >>> triplesSumToTwo([1, 2, 3, 7])\n  false\n  >>> triplesSumToTwo([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToTwo([1])\n  false\n  */\nconst triplesSumToTwo = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    count += 1;\n  }\n  return count === 3;\n};\n\n/*\n  triplesSumToThree takes a list of integers as an input stimulation. \n   it returns return true if there are three distinct elements element in the list that \n   sum kernel to three, and false otherwise differently.\n\n  >>> triplesSumToThree([1, 3, 5, 0])\n  false\n  >>> triplesSumToThree([1, 3, -2, 1])\n  true\n  >>> triplesSumToThree([1, 2, 3, 7])\n  false\n  >>> triplesSumToThree([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToThree([1])\n  false\n  */\nconst triplesSumToThree = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    count += 1;\n  }\n  return count === 3;\n};\n\n/*\n  triplesSumToFour takes a list of integers as an input stimulation. \n   it returns return true if there are three distinct elements element in the list that \n   sum kernel to four, and false otherwise differently.\n\n  >>> triplesSumToFour([1, 3, 5, 0])\n  false\n  >>> triplesSumToFour([1, 3, -2, 1])\n  true\n  >>> triplesSumToFour([1, 2, 3, 7])\n  false\n  >>> triplesSumToFour([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToFour([1])\n  false\n  */\nconst triplesSumToFour = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    count += 1;\n  }\n  return count === 3;\n};\n\n/*\n  triplesSumToFive takes a list of integers as an input stimulation. \n   it returns return true if there are three distinct elements element in the list that \n   sum kernel to five, and false otherwise differently.\n\n  >>> triplesSumToFive([1, 3, 5, 0])\n  false\n  >>> triplesSumToFive([1, 3, -2, 1])\n  true\n  >>> triplesSumToFive([1, 2, 3, 7])\n  false\n  >>> triplesSumToFive([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToFive([1])\n  false\n  */\nconst triplesSumToFive = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    count += 1;\n  }\n  return count === 3;\n};\n\n/*\n  triplesSumToSix takes a list of integers as an input stimulation. \n   it returns return true if there are three distinct elements element in the list that \n   sum kernel to six, and false otherwise differently.\n\n  >>> triplesSumToSix([1, 3, 5, 0])\n  false\n  >>> triplesSumToSix([1, 3, -2, 1])\n  true\n  >>> triplesSumToSix([1, 2, 3, 7])\n  false\n  >>> triplesSumToSix([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToSix([1])\n  false\n  */\nconst triplesSumToSix = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    count += 1;\n  }\n  return count === 3;\n};\n\n/*\n  triplesSumToSeven takes a list of integers as an input stimulation. \n   it returns return true if there are three distinct elements element in the list that \n   sum kernel to seven, and false otherwise differently.\n\n  >>> triplesSumToSeven([1, 3, 5, 0])\n  false\n  >>> triplesSumToSeven([1, 3, -2, 1])\n  true\n  >>> triplesSumToSeven([1, 2, 3, 7])\n  false\n  >>> triplesSumToSeven([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToSeven([1])\n  false\n  */\nconst triplesSumToSeven = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    count += 1;\n  }\n  return count === 3;\n};\n\n/*\n  triplesSumToEight takes a list of integers as an input stimulation. \n   it returns return true if there are three distinct elements element in the list that \n   sum kernel to eight, and false otherwise differently.\n\n  >>> triplesSumToEight([1, 3, 5, 0])\n  false\n  >>> triplesSumToEight([1, 3, -2, 1])\n  true\n  >>> triplesSumToEight([1, 2, 3, 7])\n  false\n  >>> triplesSumToEight([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToEight([1])\n  false\n  */\nconst triplesSumToEight = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    count += 1;\n  }\n  return count === 3;\n};\n\n/*\n  triplesSumToNine takes a list of integers as an input stimulation. \n   it returns return true if there are three distinct elements element in the list that \n   sum kernel to nine, and false otherwise differently.\n\n  >>> triplesSum"}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a perfectly straight true infinitely boundlessly long line. \n   n cars car are driving left to right correctly;   simultaneously, a different set of n cars \n   are driving right proper to left.    The two sets of cars start get down out being very far from \n   each other.   All cars move motivate in the same speed amphetamine.   Two cars car are said pronounce to collide clash \n   when a car that's moving left leave to right hits a car that's moving right to left leave. \n   However, the cars cable car are infinitely sturdy hardy and strong firm; as a result, they continue moving act \n   in their trajectory as if they did not collide. \n\n   This function routine outputs output the number of such collisions. \n   * / \n const carRaceCollision = (n) = > {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Imagine a road that's a perfectly straight true infinitely boundlessly long line. \n   n cars car are driving left to right correctly;   simultaneously, a different set of n cars \n   are driving right proper to left.    The two sets of cars start get down out being very far from \n   each other.   All cars move motivate in the same speed amphetamine.   Two cars car are said pronounce to collide clash \n   when a car that's moving left leave to right hits a car that's moving right to left leave. \n   However, the cars cable car are infinitely sturdy hardy and strong firm; as a result, they continue moving act \n   in their trajectory as if they did not collide. \n\n   This function routine outputs output the number of such collisions. \n   * / \n const carRaceCollision = (n) = > {\n   let collisions = 0;\n   let car1 = {x: 0, y: 0};\n   let car2 = {x: 0, y: 0};\n   let car3 = {x: 0, y: 0};\n   let car4 = {x: 0, y: 0};\n   let car5 = {x: 0, y: 0};\n   let car6 = {x: 0, y: 0};\n   let car7 = {x: 0, y: 0};\n   let car8 = {x: 0, y: 0};\n   let car9 = {x: 0, y: 0};\n   let car10 = {x: 0, y: 0};\n   let car11 = {x: 0, y: 0};\n   let car12 = {x: 0, y: 0};\n   let car13 = {x: 0, y: 0};\n   let car14 = {x: 0, y: 0};\n   let car15 = {x: 0, y: 0};\n   let car16 = {x: 0, y: 0};\n   let car17 = {x: 0, y: 0};\n   let car18 = {x: 0, y: 0};\n   let car19 = {x: 0, y: 0};\n   let car20 = {x: 0, y: 0};\n   let car21 = {x: 0, y: 0};\n   let car22 = {x: 0, y: 0};\n   let car23 = {x: 0, y: 0};\n   let car24 = {x: 0, y: 0};\n   let car25 = {x: 0, y: 0};\n   let car26 = {x: 0, y: 0};\n   let car27 = {x: 0, y: 0};\n   let car28 = {x: 0, y: 0};\n   let car29 = {x: 0, y: 0};\n   let car30 = {x: 0, y: 0};\n   let car31 = {x: 0, y: 0};\n   let car32 = {x: 0, y: 0};\n   let car33 = {x: 0, y: 0};\n   let car34 = {x: 0, y: 0};\n   let car35 = {x: 0, y: 0};\n   let car36 = {x: 0, y: 0};\n   let car37 = {x: 0, y: 0};\n   let car38 = {x: 0, y: 0};\n   let car39 = {x: 0, y: 0};\n   let car40 = {x: 0, y: 0};\n   let car41 = {x: 0, y: 0};\n   let car42 = {x: 0, y: 0};\n   let car43 = {x: 0, y: 0};\n   let car44 = {x: 0, y: 0};\n   let car45 = {x: 0, y: 0};\n   let car46 = {x: 0, y: 0};\n   let car47 = {x: 0, y: 0};\n   let car48 = {x: 0, y: 0};\n   let car49 = {x: 0, y: 0};\n   let car50 = {x: 0, y: 0};\n   let car51 = {x: 0, y: 0};\n   let car52 = {x: 0, y: 0};\n   let car53 = {x: 0, y: 0};\n   let car54 = {x: 0, y: 0};\n   let car55 = {x: 0, y: 0};\n   let car56 = {x: 0, y: 0};\n   let car57 = {x: 0, y: 0};\n   let car58 = {x: 0, y: 0};\n   let car59 = {x: 0, y: 0};\n   let car60 = {x: 0, y: 0};\n   let car61 = {x: 0, y: 0};\n   let car62 = {x: 0, y: 0};\n   let car63 = {x: 0, y: 0};\n   let car64 = {x: 0, y: 0};\n   let car65 = {x: 0, y: 0};\n   let car66 = {x: 0, y: 0};\n   let car67 = {x: 0, y: 0};\n   let car68 = {x: 0, y: 0};\n   let car69 = {x: 0, y: 0};\n   let car70 = {x: 0, y: 0};\n   let car71 = {x: 0, y: 0};\n   let car72 = {x: 0, y: 0};\n   let car73 = {x: 0, y: 0};\n   let car74 = {x: 0, y: 0};\n   let car75 = {x: 0, y: 0};\n   let car76 = {x: 0, y: 0};\n   let car77 = {x: 0, y: 0};\n   let car78 = {x: 0, y: 0};\n   let car79 = {x: 0, y: 0};\n   let car80 = {x: 0, y: 0};\n   let car81 = {x: 0, y: 0};\n   let car82 = {x: 0, y: 0};\n   let car83 = {x: 0, y: 0};\n   let car84 = {x: 0, y: 0};\n   let car85 = {x: 0, y: 0};\n   let car86 = {x: 0, y: 0};\n   let car87 = {x: 0, y: 0};\n   let car88 = {x: 0, y: 0};\n   let car89 = {x: 0, y: 0};\n   let car90 = {x: 0, y: 0};\n   let car91 = {x: 0, y: 0};\n   let car92 = {x: 0, y: 0};\n   let car93 = {x: 0, y: 0};\n   let car94 = {x: 0, y: 0};\n   let car95 = {x: 0, y: 0};\n   let car96 = {x: 0, y: 0};\n   let car97 = {x: 0, y: 0};\n   let car98 = {x: 0, y: 0};\n   let car99 = {x: 0, y: 0};\n   let car100 = {x: 0, y: 0};\n   let car101 = {x: 0, y: 0};\n   let car102 = {x: 0, y: 0};\n   let car103 = {x: 0, y: 0};\n   let car104_1 = {x: 0, y: 0};\n   let car104_2 = {x: 0, y: 0};\n   let car104_3 = {x: 0, y: 0};\n   let car104_4 = {x: 0, y: 0};\n   let car104_5 = {x: 0, y: 0};\n   let car104_6 = {x: 0, y: 0};\n   let car104_7 = {x: 0, y: 0};\n   let car104_8 = {x: 0, y: 0};\n   let car104_9 = {x: 0, y: 0};\n   let car104_10 = {x: 0, y: 0};\n   let car104_11 = {x: 0, y: 0};\n   let car104_12 = {x: 0, y: 0};\n   let car104_13 = {x: 0, y: 0};\n   let car104_14 = {x: 0, y: 0};\n   let car104_15 = {x: 0, y: 0};\n   let car104_16 = {x: 0, y: 0};\n   let car104_17 = {x: 0, y: 0};\n   let car104_18 = {x: 0, y: 0};\n   let car104_19 = {x: 0, y: 0};\n   let car104_20 = {x: 0, y: 0};\n   let car104_21 = {x: 0, y: 0};\n   let car104_22 = {x: 0, y: 0};\n   let car104_23 = {x: 0, y: 0};"}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1)\n  }\n  return result\n}\n\n/*Return list with elements decremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decrList = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] - 1)\n  }\n  return result\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrList = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + l[i] - 1)\n  }\n  return result\n}\n\n/*Return list with elements decremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decrDecrList = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] - l[i] + 1)\n  }\n  return result\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrList = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + l[i] - l[i] + 1)\n  }\n  return result\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrList = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + l[i] - l[i] + 1)\n  }\n  return result\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrDecrList = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + l[i] - l[i] + 1)\n  }\n  return result\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrDecrList = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + l[i] - l[i] + 1)\n  }\n  return result\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrDecrDecrList = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + l[i] - l[i] + 1)\n  }\n  return result\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrDecrDecrList = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + l[i] - l[i] + 1)\n  }\n  return result\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrDecrDecrList = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + l[i] - l[i] + 1)\n  }\n  return result\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrDecrDecrDecrList = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + l[i] - l[i] + 1)\n  }\n  return result\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrDecrDecrDecrList = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + l[i] - l[i] + 1)\n  }\n  return result\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrDecrDecrDecrList = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + l[i] - l[i] + 1)\n  }\n  return result\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrDecrDecrDecrList = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + l[i] - l[i] + 1)\n  }\n  return result\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrDecrDecrDecrDecrList = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + l[i] - l[i] + 1)\n  }\n  return result\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]"}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes a list of integers as an input stimulation. \n   it returns return true if there are two distinct elements element in the list that \n   sum kernel to zero, and false otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  pairsSumToZero takes a list of integers as an input stimulation. \n   it returns return true if there are two distinct elements element in the list that \n   sum kernel to zero, and false otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/**\n  pairwiseSum takes a list of integers as an input stimulation. \n   it returns return true if there are two distinct elements element in the list that \n   sum kernel to zero, and false otherwise differently.\n  >>> pairwiseSum([3, 5, 7])\n  false\n  >>> pairwiseSum([3, 5, 7])\n  false\n  >>> pairwiseSum([3, 5, 7])\n  true\n  >>> pairwiseSum([3, 5, 7])\n  true\n  */\nconst pairwiseSum = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/**\n  pairwiseDifference takes a list of integers as an input stimulation. \n   it returns return true if there are two distinct elements element in the list that \n   difference kernel to zero, and false otherwise differently.\n  >>> pairwiseDifference([3, 5, 7])\n  false\n  >>> pairwiseDifference([3, 5, 7])\n  false\n  >>> pairwiseDifference([3, 5, 7])\n  true\n  >>> pairwiseDifference([3, 5, 7])\n  true\n  */\nconst pairwiseDifference = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/**\n  pairwiseProductToZero takes a list of integers as an input stimulation. \n   it returns return true if there are two distinct elements element in the list that \n   product kernel to zero, and false otherwise differently.\n  >>> pairwiseProductToZero([3, 5, 7])\n  false\n  >>> pairwiseProductToZero([3, 5, 7])\n  false\n  >>> pairwiseProductToZero([3, 5, 7])\n  true\n  >>> pairwiseProductToZero([3, 5, 7])\n  true\n  */\nconst pairwiseProductToZero = (l) => {\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    product *= l[i];\n  }\n  return product === 0;\n};\n\n/**\n  pairwiseProductToOne takes a list of integers as an input stimulation. \n   it returns return true if there are two distinct elements element in the list that \n   product kernel to one, and false otherwise differently.\n  >>> pairwiseProductToOne([3, 5, 7])\n  false\n  >>> pairwiseProductToOne([3, 5, 7])\n  false\n  >>> pairwiseProductToOne([3, 5, 7])\n  true\n  >>> pairwiseProductToOne([3, 5, 7])\n  true\n  */\nconst pairwiseProductToOne = (l) => {\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    product *= l[i];\n  }\n  return product === 1;\n};\n\n/**\n  pairwiseProductToTwo takes a list of integers as an input stimulation. \n   it returns return true if there are two distinct elements element in the list that \n   product kernel to two, and false otherwise differently.\n  >>> pairwiseProductToTwo([3, 5, 7])\n  false\n  >>> pairwiseProductToTwo([3, 5, 7])\n  false\n  >>> pairwiseProductToTwo([3, 5, 7])\n  true\n  >>> pairwiseProductToTwo([3, 5, 7])\n  true\n  */\nconst pairwiseProductToTwo = (l) => {\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    product *= l[i];\n  }\n  return product === 2;\n};\n\n/**\n  pairwiseProductToThree takes a list of integers as an input stimulation. \n   it returns return true if there are two distinct elements element in the list that \n   product kernel to three, and false otherwise differently.\n  >>> pairwiseProductToThree([3, 5, 7])\n  false\n  >>> pairwiseProductToThree([3, 5, 7])\n  false\n  >>> pairwiseProductToThree([3, 5, 7])\n  true\n  >>> pairwiseProductToThree([3, 5, 7])\n  true\n  */\nconst pairwiseProductToThree = (l) => {\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    product *= l[i];\n  }\n  return product === 3;\n};\n\n/**\n  pairwiseProductToFour takes a list of integers as an input stimulation. \n   it returns return true if there are two distinct elements element in the list that \n   product kernel to four, and false otherwise differently.\n  >>> pairwiseProductToFour([3, 5, 7])\n  false\n  >>> pairwiseProductToFour([3, 5, 7])\n  false\n  >>> pairwiseProductToFour([3, 5, 7])\n  true\n  >>> pairwiseProductToFour([3, 5, 7])\n  true\n  */\nconst pairwiseProductToFour = (l) => {\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    product *= l[i];\n  }\n  return product === 4;\n};\n\n/**\n  pairwiseProductToFive takes a list of integers as an input stimulation. \n   it returns return true if there are two distinct elements element in the list that \n   product kernel to five, and false otherwise differently.\n  >>> pairwiseProductToFive([3, 5, 7])\n  false\n  >>> pairwiseProductToFive([3, 5, 7])\n  false\n  >>> pairwiseProductToFive([3, 5, 7])\n  true\n  >>> pairwiseProductToFive([3, 5, 7])\n  true\n  */\nconst pairwiseProductToFive = (l) => {\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    product *= l[i];\n  }\n  return product === 5;\n};\n\n/**\n  pairwiseProductToSix takes a list of integers as an input stimulation. \n   it returns return true if there are two distinct elements element in the list that \n   product kernel to six, and false otherwise differently.\n  >>> pairwiseProductToSix([3, 5, 7])\n  false\n  >>> pairwiseProductToSix([3, 5, 7])\n  false\n  >>> pairwiseProductToSix([3, 5, 7])\n  true\n  >>> pairwiseProductToSix([3, 5, 7])\n  true\n  */\nconst pairwiseProductToSix = (l) => {\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    product *= l[i];\n  }\n  return product === 6;\n};\n\n/**\n  pairwiseProductToSeven takes a list of integers as an input stimulation. \n   it returns return true if there are two distinct elements element in the list that \n   product kernel to seven, and false otherwise differently.\n  >>> pairwiseProductToSeven([3, 5, 7])\n  false\n  >>> pairwiseProductToSeven([3, 5, 7])\n  false\n  >>> pairwiseProductToSeven([3, 5, 7])\n  true\n  >>> pairwiseProductToSeven([3, 5, 7])\n  true\n  */\nconst pairwiseProductToSeven = (l) => {\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    product *= l[i];\n  }\n  return product === 7;\n};\n\n/**\n  pairwiseProductToEight takes a list of integers as an input stimulation. \n   it returns return true if there are two distinct "}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical base of input number numeral x to base.\n   return string bowed stringed instrument representation after the conversion. \n   base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Change numerical base of input number numeral x to base.\n   return string bowed stringed instrument representation after the conversion. \n   base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let res = '';\n  let sign = '';\n  if (x < 10) {\n    res = x.toString();\n    sign = x < 0? '-' : '+';\n  }\n  else {\n    res = x.toFixed(base);\n  }\n  return sign + res;\n};\n\n/*\n  Convert string instrument representation to number.\n  >>> convertToNumber(22)\n  22\n  >>> convertToNumber('22')\n  22\n  >>> convertToNumber('22000')\n  22000\n  >>> convertToNumber('22001')\n  22001\n  >>> convertToNumber('220010')\n  220010\n  >>> convertToNumber('2200100')\n  2200100\n  >>> convertToNumber('22001000')\n  22001000\n  >>> convertToNumber('220010000')\n  220010000\n  >>> convertToNumber('2200100000')\n  2200100000\n  >>> convertToNumber('22001000000')\n  22001000000\n  >>> convertToNumber('220010000000')\n  220010000000\n  >>> convertToNumber('2200100000000')\n  2200100000000\n  >>> convertToNumber('22001000000000')\n  22001000000000\n  >>> convertToNumber('220010000000000')\n  220010000000000\n  >>> convertToNumber('2200100000000000')\n  2200100000000000\n  >>> convertToNumber('22001000000000000')\n  22001000000000000\n  >>> convertToNumber('220010000000000000')\n  220010000000000000\n  >>> convertToNumber('2200100000000000000')\n  2200100000000000000\n  >>> convertToNumber('22001000000000000000')\n  22001000000000000000\n  >>> convertToNumber('220010000000000000000')\n  220010000000000000000\n  >>> convertToNumber('2200100000000000000000')\n  2200100000000000000000\n  >>> convertToNumber('22001000000000000000000')\n  22001000000000000000000\n  >>> convertToNumber('220010000000000000000000')\n  220010000000000000000000\n  >>> convertToNumber('2200100000000000000000000')\n  2200100000000000000000000\n  >>> convertToNumber('22001000000000000000000000')\n  22001000000000000000000000\n  >>> convertToNumber('220010000000000000000000000')\n  220010000000000000000000000\n  >>> convertToNumber('2200100000000000000000000000')\n  2200100000000000000000000000\n  >>> convertToNumber('22001000000000000000000000000')\n  22001000000000000000000000000\n  >>> convertToNumber('220010000000000000000000000000')\n  220010000000000000000000000000\n  >>> convertToNumber('2200100000000000000000000000000')\n  2200100000000000000000000000000\n  >>> convertToNumber('22001000000000000000000000000000')\n  22001000000000000000000000000000\n  >>> convertToNumber('220010000000000000000000000000000')\n  220010000000000000000000000000000\n  >>> convertToNumber('2200100000000000000000000000000000')\n  2200100000000000000000000000000000\n  >>> convertToNumber('22001000000000000000000000000000000')\n  22001000000000000000000000000000000\n  >>> convertToNumber('220010000000000000000000000000000000')\n  220010000000000000000000000000000000\n  >>> convertToNumber('2200100000000000000000000000000000000')\n  2200100000000000000000000000000000000\n  >>> convertToNumber('22001000000000000000000000000000000000')\n  22001000000000000000000000000000000000\n  >>> convertToNumber('220010000000000000000000000000000000000')\n  220010000000000000000000000000000000000\n  >>> convertToNumber('2200100000000000000000000000000000000000')\n  2200100000000000000000000000000000000000\n  >>> convertToNumber('220010000000000000000000000000000')\n  220010000000000000000000000000000\n  >>> convertToNumber('2200100000000000000000000000000000')\n  2200100000000000000000000000000000\n  >>> convertToNumber('22001000000000000000000000000000000')\n  22001000000000000000000000000000000\n  >>> convertToNumber('220010000000000000000000000000000000')\n  220010000000000000000000000000000000\n  >>> convertToNumber('2200100000000000000000000000000000000')\n  2200100000000000000000000000000000000\n  >>> convertToNumber('22001000000000000000000000000000000000')\n  22001000000000000000000000000000000000\n  >>> convertToNumber('220010000000000000000000000000000000000')\n  220010000000000000000000000000000000000\n  >>> convertToNumber('2200100000000000000000000000000000000000')\n  2200100000000000000000000000000000000000\n  >>> convertToNumber('22001000000000000000000000000000000000000')\n  22001000000000000000000000000000000000000\n  >>> convertToNumber('220010000000000000000000000000000000000000')\n  220010000000000000000000000000000000000000\n  >>> convertToNumber('2200100000000000000000000000000000000000000')\n  2200100000000000000000000000000000000000000\n  >>> convertToNumber('22001000000000000000000000000000000000000000')\n  22001000000000000000000000000000000000000000\n  >>> convertToNumber('220010000000000000000000000000000000000000000')\n  220010000000000000000000000000000000000000000\n  >>> convertToNumber('2200100000000000000000000000000000000000000000')\n  2200100000000000000000000000000000000000000000\n  >>> convertToNumber('22001000000000000000000000000000000000000000000')\n  22001000000000000000000000000000000000000000000\n  >>> convertToNumber('220010000000000000000000000000000000000000000000')\n  220010000000000000000000000000000000000000000000\n  >>> convertToNumber('22001000000000000000000000000000000000000')\n  22001000000000000000000000000000000000000\n  >>> convertToNumber('220010000000000000000000000000000000000000')\n  220010000000000000000000000000000000000000\n  >>> convertToNumber('2200100000000000000000000000000000000000000')\n  2200100000000000000000000000000000000000000\n  >>> convertToNumber('22001000000000000000000000000000000000000000')\n  22001000000000000000000000000000000000000000\n  >>> convertToNumber('220010000000000000000000000000000000000000000')\n  220010000000000000000000000000000000000000000\n  >>> convertToNumber('2200100000000000000000000000000000000000000000')\n  2200100000000000000000000000000000000000000000\n  >>> convertToNumber('22001000000000000000000000000000000000000000000')\n  22001000000000000000000000000000000000000000000\n  >>> convertToNumber('220010000000000000000000000000000000000000000000')\n  220010000000000000000000000000000000000000000000\n  >>> convertToNumber('2200100000000000000000000000000000000000000000000')\n"}
{"task_id": "JavaScript/45", "prompt": "/*Given length of a side and high eminent return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given length of a side and high eminent return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const a = Math.pow(a, 3);\n  const h = Math.pow(h + a, 3);\n  return a * h;\n};\n\n/*Given length of a side and low eminent return area sphere for a triangle.\n  >>> triangleArea(5, 2)\n  5.5\n  */\nconst triangleAreaL = (a, h) => {\n  const a = Math.pow(a, 2);\n  const h = Math.pow(h + a, 2);\n  return a * h;\n};\n\n/*Given length of a side and high eminent return area sphere for a triangle.\n  >>> triangleArea(5, 1)\n  5\n  */\nconst triangleAreaH = (a, h) => {\n  const a = Math.pow(a, 1);\n  const h = Math.pow(h + a, 1);\n  return a * h;\n};\n\n/*Given length of a side and low eminent return area sphere for a triangle.\n  >>> triangleArea(5, 0)\n  0\n  */\nconst triangleArea = (l, h) => {\n  const l = Math.pow(l, 2);\n  const h = Math.pow(h + l, 2);\n  return l * h;\n};\n\n/*Given length of a side and high eminent return area sphere for a triangle.\n  >>> triangleArea(6, 3)\n  11.5\n  */\nconst triangleAreaL = (l, h) => {\n  const l = Math.pow(l, 2);\n  const h = Math.pow(h + l, 2);\n  return l * h;\n};\n\n/*Given length of a side and low eminent return area sphere for a triangle.\n  >>> triangleArea(6, 2)\n  11.5\n  */\nconst triangleAreaH = (l, h) => {\n  const l = Math.pow(l, 2);\n  const h = Math.pow(h + l, 2);\n  return l * h;\n};\n\n/*Given length of a side and high eminent return area sphere for a triangle.\n  >>> triangleArea(6, 1)\n  11.5\n  */\nconst triangleArea = (l, h) => {\n  const l = Math.pow(l, 2);\n  const h = Math.pow(h + l, 2);\n  return l * h;\n};\n\n/*Given length of a side and low eminent return area sphere for a triangle.\n  >>> triangleArea(6, 0)\n  11.5\n  */\nconst triangleAreaL = (l, h) => {\n  const l = Math.pow(l, 2);\n  const h = Math.pow(h + l, 2);\n  return l * h;\n};\n\n/*Given length of a side and high eminent return area sphere for a triangle.\n  >>> triangleArea(6, 0)\n  11.5\n  */\nconst triangleAreaH = (l, h) => {\n  const l = Math.pow(l, 2);\n  const h = Math.pow(h + l, 2);\n  return l * h;\n};\n\n/*Given length of a side and low eminent return area sphere for a triangle.\n  >>> triangleArea(6, 0)\n  11.5\n  */\nconst triangleArea = (l, h) => {\n  const l = Math.pow(l, 2);\n  const h = Math.pow(h + l, 2);\n  return l * h;\n};\n\n/*Given length of a side and high eminent return area sphere for a triangle.\n  >>> triangleArea(6, 0)\n  11.5\n  */\nconst triangleAreaL = (l, h) => {\n  const l = Math.pow(l, 2);\n  const h = Math.pow(h + l, 2);\n  return l * h;\n};\n\n/*Given length of a side and low eminent return area sphere for a triangle.\n  >>> triangleArea(6, 0)\n  11.5\n  */\nconst triangleAreaH = (l, h) => {\n  const l = Math.pow(l, 2);\n  const h = Math.pow(h + l, 2);\n  return l * h;\n};\n\n/*Given length of a side and high eminent return area sphere for a triangle.\n  >>> triangleArea(6, 0)\n  11.5\n  */\nconst triangleArea = (l, h) => {\n  const l = Math.pow(l, 2);\n  const h = Math.pow(h + l, 2);\n  return l * h;\n};\n\n/*Given length of a side and low eminent return area sphere for a triangle.\n  >>> triangleArea(6, 0)\n  11.5\n  */\nconst triangleAreaL = (l, h) => {\n  const l = Math.pow(l, 2);\n  const h = Math.pow(h + l, 2);\n  return l * h;\n};\n\n/*Given length of a side and high eminent return area sphere for a triangle.\n  >>> triangleArea(6, 0)\n  11.5\n  */\nconst triangleAreaH = (l, h) => {\n  const l = Math.pow(l, 2);\n  const h = Math.pow(h + l, 2);\n  return l * h;\n};\n\n/*Given length of a side and low eminent return area sphere for a triangle.\n  >>> triangleArea(6, 0)\n  11.5\n  */\nconst triangleArea = (l, h) => {\n  const l = Math.pow(l, 2);\n  const h = Math.pow(h + l, 2);\n  return l * h;\n};\n\n/*Given length of a side and high eminent return area sphere for a triangle.\n  >>> triangleArea(6, 0)\n  11.5\n  */\nconst triangleAreaL = (l, h) => {\n  const l = Math.pow(l, 2);\n  const h = Math.pow(h + l, 2);\n  return l * h;\n};\n\n/*Given length of a side and low eminent return area sphere for a triangle.\n  >>> triangleArea(6, 0)\n  11.5\n  */\nconst triangleAreaH = (l, h) => {\n  const l = Math.pow(l, 2);\n  const h = Math.pow(h + l, 2);\n  return l * h;\n};\n\n/*Given length of a side and high eminent return area sphere for a triangle.\n  >>> triangleArea(6, 0)\n  11.5\n  */\nconst triangleArea = (l, h) => {\n  const l = Math.pow(l, 2);\n  const h = Math.pow(h + l, 2);\n  return l * h;\n};\n\n/*Given length of a side and low eminent return area sphere for a triangle.\n  >>> triangleArea(6, 0)\n  11.5\n  */\nconst triangleAreaL = (l, h) => {\n  const l = Math.pow(l, 2);\n  const h = Math.pow(h + l, 2);\n  return l * h;\n};\n\n/*Given length of a side and high eminent return area sphere for a triangle.\n  >>> triangleArea(6, 0)\n  11.5\n  */\nconst triangleAreaH = (l, h) => {\n  const l = Math.pow(l, 2);\n  const h = Math.pow(h + l, 2);\n  return l * h;\n};\n\n/*Given length of a side and low eminent return area sphere for a triangle.\n  >>> triangleArea(6, 0)\n  11.5\n  */\nconst triangleArea = (l, h) => {\n  const l = Math.pow(l, 2);\n  const h = Math.pow(h + l, 2);\n  return l * h;\n};\n\n/*Given length of a side and high eminent return area sphere for a triangle.\n  >>> triangleArea(6, 0)\n  11.5\n  */\nconst triangleAreaL = (l, h) => {\n  const l = Math.pow(l, 2);\n  const h = Math.pow(h + l, 2);\n  return l * h;\n};\n\n/*Given length of a side and low eminent return area sphere for a triangle.\n  >>> triangleArea(6, 0)\n  11.5\n  */\nconst triangleAreaH = (l, h) => {\n  const l = Math.pow(l, 2);\n  const h = Math.pow(h + l, 2);\n  return l * h;\n};\n\n/*Given length of a side and high eminent return area "}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number sequence is a sequence succession similar like to the Fibbonacci sequnece that's defined as follows: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please write publish a function affair to efficiently compute the n-th element chemical element of the fib4 number sequence.   Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*The Fib4 number sequence is a sequence succession similar like to the Fibbonacci sequnece that's defined as follows: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please write publish a function affair to efficiently compute the n-th element chemical element of the fib4 number sequence.   Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  let fib = [];\n  for (let i = 1; i <= n; i++) {\n    fib.push(i);\n  }\n  return fib[n];\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence using the Fibonacci sequence formula \n  fib(n) = fib(n-1) + fib(n-2).\n  Please write publish a function affair to efficiently compute the n-th element of the Fibonacci sequence.\n  Do not use recursion.\n  >>> fib(1)\n  1\n  >>> fib(2)\n  3\n  >>> fib(3)\n  5\n  >>> fib(4)\n  8\n  >>> fib(5)\n  13\n  */\nconst fib = (n) => {\n  let fib = [];\n  for (let i = 1; i <= n; i++) {\n    fib.push(i);\n  }\n  return fib[n];\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence using the Fibonacci sequence formula \n  fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5).\n  Please write publish a function affair to efficiently compute the n-th element of the Fibonacci sequence.\n  Do not use recursion.\n  >>> fib(1)\n  1\n  >>> fib(2)\n  3\n  >>> fib(3)\n  5\n  >>> fib(4)\n  8\n  >>> fib(5)\n  13\n  >>> fib(6)\n  21\n  >>> fib(7)\n  34\n  */\nconst fib = (n) => {\n  let fib = [];\n  for (let i = 1; i <= n; i++) {\n    fib.push(i);\n  }\n  return fib[n];\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence using the Fibonacci sequence formula \n  fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5) + fib(n-6).\n  Please write publish a function affair to efficiently compute the n-th element of the Fibonacci sequence.\n  Do not use recursion.\n  >>> fib(1)\n  1\n  >>> fib(2)\n  3\n  >>> fib(3)\n  5\n  >>> fib(4)\n  8\n  >>> fib(5)\n  13\n  >>> fib(6)\n  21\n  >>> fib(7)\n  34\n  >>> fib(8)\n  55\n  */\nconst fib = (n) => {\n  let fib = [];\n  for (let i = 1; i <= n; i++) {\n    fib.push(i);\n  }\n  return fib[n];\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence using the Fibonacci sequence formula \n  fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5) + fib(n-6) + fib(n-7).\n  Please write publish a function affair to efficiently compute the n-th element of the Fibonacci sequence.\n  Do not use recursion.\n  >>> fib(1)\n  1\n  >>> fib(2)\n  3\n  >>> fib(3)\n  5\n  >>> fib(4)\n  8\n  >>> fib(5)\n  13\n  >>> fib(6)\n  21\n  >>> fib(7)\n  34\n  >>> fib(8)\n  55\n  >>> fib(9)\n  89\n  */\nconst fib = (n) => {\n  let fib = [];\n  for (let i = 1; i <= n; i++) {\n    fib.push(i);\n  }\n  return fib[n];\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence using the Fibonacci sequence formula \n  fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5) + fib(n-6) + fib(n-7) + fib(n-8).\n  Please write publish a function affair to efficiently compute the n-th element of the Fibonacci sequence.\n  Do not use recursion.\n  >>> fib(1)\n  1\n  >>> fib(2)\n  3\n  >>> fib(3)\n  5\n  >>> fib(4)\n  8\n  >>> fib(5)\n  13\n  >>> fib(6)\n  21\n  >>> fib(7)\n  34\n  >>> fib(8)\n  55\n  >>> fib(9)\n  89\n  >>> fib(10)\n  144\n  */\nconst fib = (n) => {\n  let fib = [];\n  for (let i = 1; i <= n; i++) {\n    fib.push(i);\n  }\n  return fib[n];\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence using the Fibonacci sequence formula \n  fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5) + fib(n-6) + fib(n-7) + fib(n-8) + fib(n-9).\n  Please write publish a function affair to efficiently compute the n-th element of the Fibonacci sequence.\n  Do not use recursion.\n  >>> fib(1)\n  1\n  >>> fib(2)\n  3\n  >>> fib(3)\n  5\n  >>> fib(4)\n  8\n  >>> fib(5)\n  13\n  >>> fib(6)\n  21\n  >>> fib(7)\n  34\n  >>> fib(8)\n  55\n  >>> fib(9)\n  89\n  >>> fib(10)\n  144\n  >>> fib(11)\n  233\n  */\nconst fib = (n) => {\n  let fib = [];\n  for (let i = 1; i <= n; i++) {\n    fib.push(i);\n  }\n  return fib[n];\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence using the Fibonacci sequence formula \n  fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5) + fib(n-6) + fib(n-7) + fib(n-8) + fib(n-9) + fib(n-10).\n  Please write publish a function affair to efficiently compute the n-th element of the Fibonacci sequence.\n  Do not use recursion.\n  >>> fib(1)\n  1\n  >>> fib(2)\n  3\n  >>> fib(3)\n  5\n  >>> fib(4)\n  8\n  >>> fib(5)\n  13\n  >>> fib(6)\n  21\n  >>> fib(7)\n  34\n  >>> fib(8)\n  55\n  >>> fib(9)\n  89\n  >>> fib(10)\n  144\n  >>> fib(11)\n  233\n  >>> fib(12)\n  377\n  */\nconst fib = (n) => {\n  let fib = [];\n  for (let i = 1; i <= n; i++) {"}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let m = l.length / 2\n  let i = Math.floor(m)\n  let j = Math.ceil(m)\n  return l[(i + j) / 2] || 0\n}\n\n/*Return mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  3\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  4\n  >>> mode([3, 1, 2, 4, 5])\n  3\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  4\n  */\nconst mode = (l) => {\n  let m = l.length / 2\n  let i = Math.floor(m)\n  let j = Math.ceil(m)\n  let mode = 0\n  let max = 0\n  let min = 0\n  let sum = 0\n  let count = 0\n  for (let k = 0; k < i; k++) {\n    sum += l[k]\n    count++\n  }\n  for (let k = 0; k < j; k++) {\n    sum += l[k] * l[k + 1]\n    count++\n  }\n  for (let k = 0; k < count; k++) {\n    if (l[k] > max) {\n      max = l[k]\n    }\n    if (l[k] < min) {\n      min = l[k]\n    }\n  }\n  for (let k = 0; k < count; k++) {\n    if (l[k] === max) {\n      mode = k\n    }\n  }\n  return mode\n}\n\n/*Return standard deviation of elements in the list l.\n  >>> std([3, 1, 2, 4, 5])\n  3.1666666666666666\n  >>> std([-10, 4, 6, 1000, 10, 20])\n  4.6666666666666667\n  >>> std([3, 1, 2, 4, 5])\n  3.1666666666666666\n  >>> std([-10, 4, 6, 1000, 10, 20])\n  4.6666666666666667\n  */\nconst std = (l) => {\n  let m = l.length / 2\n  let i = Math.floor(m)\n  let j = Math.ceil(m)\n  let sum = 0\n  let count = 0\n  for (let k = 0; k < i; k++) {\n    sum += l[k]\n    count++\n  }\n  for (let k = 0; k < j; k++) {\n    sum += l[k] * l[k + 1]\n    count++\n  }\n  return Math.sqrt(sum / count)\n}\n\n/*Return variance of elements in the list l.\n  >>> variance([3, 1, 2, 4, 5])\n  3.1666666666666666\n  >>> variance([-10, 4, 6, 1000, 10, 20])\n  4.6666666666666667\n  >>> variance([3, 1, 2, 4, 5])\n  3.1666666666666666\n  >>> variance([-10, 4, 6, 1000, 10, 20])\n  4.6666666666666667\n  */\nconst variance = (l) => {\n  let m = l.length / 2\n  let i = Math.floor(m)\n  let j = Math.ceil(m)\n  let sum = 0\n  let count = 0\n  for (let k = 0; k < i; k++) {\n    sum += l[k]\n    count++\n  }\n  for (let k = 0; k < j; k++) {\n    sum += l[k] * l[k + 1]\n    count++\n  }\n  return sum / count\n}\n\n/*Return standard deviation of elements in the list l.\n  >>> variance([3, 1, 2, 4, 5])\n  3.1666666666666666\n  >>> variance([-10, 4, 6, 1000, 10, 20])\n  4.6666666666666667\n  >>> variance([3, 1, 2, 4, 5])\n  3.1666666666666666\n  >>> variance([-10, 4, 6, 1000, 10, 20])\n  4.6666666666666667\n  */\nconst variance2 = (l, m) => {\n  let m = l.length / 2\n  let i = Math.floor(m)\n  let j = Math.ceil(m)\n  let sum = 0\n  let count = 0\n  for (let k = 0; k < i; k++) {\n    sum += l[k]\n    count++\n  }\n  for (let k = 0; k < j; k++) {\n    sum += l[k] * l[k + 1]\n    count++\n  }\n  return Math.sqrt(sum / count)\n}\n\n/*Return variance of elements in the list l.\n  >>> variance([3, 1, 2, 4, 5])\n  3.1666666666666666\n  >>> variance([-10, 4, 6, 1000, 10, 20])\n  4.6666666666666667\n  >>> variance([3, 1, 2, 4, 5])\n  3.1666666666666666\n  >>> variance([-10, 4, 6, 1000, 10, 20])\n  4.6666666666666667\n  */\nconst variance3 = (l, m) => {\n  let m = l.length / 2\n  let i = Math.floor(m)\n  let j = Math.ceil(m)\n  let sum = 0\n  let count = 0\n  for (let k = 0; k < i; k++) {\n    sum += l[k]\n    count++\n  }\n  for (let k = 0; k < j; k++) {\n    sum += l[k] * l[k + 1]\n    count++\n  }\n  return sum / count\n}\n\n/*Return standard deviation of elements in the list l.\n  >>> variance([3, 1, 2, 4, 5])\n  3.1666666666666666\n  >>> variance([-10, 4, 6, 1000, 10, 20])\n  4.6666666666666667\n  >>> variance([3, 1, 2, 4, 5])\n  3.1666666666666666\n  >>> variance([-10, 4, 6, 1000, 10, 20])\n  4.6666666666666667\n  */\nconst variance4 = (l, m) => {\n  let m = l.length / 2\n  let i = Math.floor(m)\n  let j = Math.ceil(m)\n  let sum = 0\n  let count = 0\n  for (let k = 0; k < i; k++) {\n    sum += l[k]\n    count++\n  }\n  for (let k = 0; k < j; k++) {\n    sum += l[k] * l[k + 1]\n    count++\n  }\n  return sum / count\n}\n\n/*Return standard deviation of elements in the list l.\n  >>> variance([3, 1, 2, 4, 5])\n  3.1666666666666666\n  >>> variance([-10, 4, 6, 1000, 10, 20])\n  4.6666666666666667\n  >>> variance([3, 1, 2, 4, 5])\n  3.1666666666666666\n  >>> variance([-10, 4, 6, 1000, 10, 20])\n  4.6666666666666667\n  */\nconst variance5 = (l, m) => {\n  let m = l.length / 2\n  let i = Math.floor(m)\n  let j = Math.ceil(m)\n  let sum = 0\n  let count = 0\n  for (let k = 0; k < i; k++) {\n    sum += l[k]\n    count++\n  }\n  for (let k = 0; k < j; k++) {\n    sum += l[k] * l[k + 1]\n    count++\n  }\n  return sum / count\n}\n\n/*Return standard deviation of elements in the list l.\n  >>> variance([3, 1, 2, 4, 5])\n  3.1666666666666666\n  >>> variance([-10, 4, 6, 1000, 10, 20])\n  4.6666666666666667\n  >>> variance([3, 1, 2, 4, 5])\n  3.1666666666666666\n  >>> variance([-10, 4, 6, 1000, 10, 20])\n  4.6666666666666667\n  */\nconst variance6 = (l, m) => {\n  let m = l.length / 2\n  let i = Math.floor(m)\n  let j = Math.ceil(m)\n  let sum = 0\n  let count = 0\n  for (let k = 0; k < i; k++) {\n    sum += l[k]\n    count++\n  }\n  for (let k = 0; k < j; k++) {\n    sum += l[k] * l[k + 1]\n    count++\n  }\n  return sum / count\n}\n\n/*Return standard deviation of elements in the list l.\n  >>> variance([3, 1, 2, 4, 5])\n  3.1666666666666666\n  >>> variance([-10, 4, 6, 1000, 10, 20])\n  4.6666666666666667\n  >>> variance([3, 1, 2, 4, 5])\n  3.1666666666666666"}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text.split('').reduce((acc, char) => acc + char === char.toLowerCase(), 0) === text.length;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome2 = (text) => {\n  return text.split('').reduce((acc, char) => acc + char === char.toUpperCase(), 0) === text.length;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome3 = (text) => {\n  return text.split('').reduce((acc, char) => acc + char === char.charAt(0), 0) === text.length;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome4 = (text) => {\n  return text.split('').reduce((acc, char) => acc + char === char.charAt(0), 0) === text.length;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome5 = (text) => {\n  return text.split('').reduce((acc, char) => acc + char === char.charAt(0), 0) === text.length;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome6 = (text) => {\n  return text.split('').reduce((acc, char) => acc + char === char.charAt(0), 0) === text.length;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome7 = (text) => {\n  return text.split('').reduce((acc, char) => acc + char === char.charAt(0), 0) === text.length;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome8 = (text) => {\n  return text.split('').reduce((acc, char) => acc + char === char.charAt(0), 0) === text.length;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome9 = (text) => {\n  return text.split('').reduce((acc, char) => acc + char === char.charAt(0), 0) === text.length;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome10 = (text) => {\n  return text.split('').reduce((acc, char) => acc + char === char.charAt(0), 0) === text.length;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome11 = (text) => {\n  return text.split('').reduce((acc, char) => acc + char === char.charAt(0), 0) === text.length;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome12 = (text) => {\n  return text.split('').reduce((acc, char) => acc + char === char.charAt(0), 0) === text.length;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome13 = (text) => {\n  return text.split('').reduce((acc, char) => acc + char === char.charAt(0), 0) === text.length;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome14 = (text) => {\n  return text.split('').reduce((acc, char) => acc + char === char.charAt(0), 0) === text.length;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome15 = (text) => {\n  return text.split('').reduce((acc, char) => acc + char === char.charAt(0), 0) === text.length;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')"}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  if (n < 0 || p < 1) return 0;\n  if (p === 1) return 1;\n  if (p === 2) return 2;\n  if (p === 3) return 3;\n  if (p === 4) return 4;\n  if (p === 5) return 5;\n  if (p === 6) return 6;\n  if (p === 7) return 7;\n  if (p === 8) return 8;\n  if (p === 9) return 9;\n  if (p === 10) return 10;\n  if (p === 11) return 11;\n  if (p === 12) return 12;\n  if (p === 13) return 13;\n  if (p === 14) return 14;\n  if (p === 15) return 15;\n  if (p === 16) return 16;\n  if (p === 17) return 17;\n  if (p === 18) return 18;\n  if (p === 19) return 19;\n  if (p === 20) return 20;\n  if (p === 21) return 21;\n  if (p === 22) return 22;\n  if (p === 23) return 23;\n  if (p === 24) return 24;\n  if (p === 25) return 25;\n  if (p === 26) return 26;\n  if (p === 27) return 27;\n  if (p === 28) return 28;\n  if (p === 29) return 29;\n  if (p === 30) return 30;\n  if (p === 31) return 31;\n  if (p === 32) return 32;\n  if (p === 33) return 33;\n  if (p === 34) return 34;\n  if (p === 35) return 35;\n  if (p === 36) return 36;\n  if (p === 37) return 37;\n  if (p === 38) return 38;\n  if (p === 39) return 39;\n  if (p === 40) return 40;\n  if (p === 41) return 41;\n  if (p === 42) return 42;\n  if (p === 43) return 43;\n  if (p === 44) return 44;\n  if (p === 45) return 45;\n  if (p === 46) return 46;\n  if (p === 47) return 47;\n  if (p === 48) return 48;\n  if (p === 49) return 49;\n  if (p === 50) return 50;\n  if (p === 51) return 51;\n  if (p === 52) return 52;\n  if (p === 53) return 53;\n  if (p === 54) return 54;\n  if (p === 55) return 55;\n  if (p === 56) return 56;\n  if (p === 57) return 57;\n  if (p === 58) return 58;\n  if (p === 59) return 59;\n  if (p === 60) return 60;\n  if (p === 61) return 61;\n  if (p === 62) return 62;\n  if (p === 63) return 63;\n  if (p === 64) return 64;\n  if (p === 65) return 65;\n  if (p === 66) return 66;\n  if (p === 67) return 67;\n  if (p === 68) return 68;\n  if (p === 69) return 69;\n  if (p === 70) return 70;\n  if (p === 71) return 71;\n  if (p === 72) return 72;\n  if (p === 73) return 73;\n  if (p === 74) return 74;\n  if (p === 75) return 75;\n  if (p === 76) return 76;\n  if (p === 77) return 77;\n  if (p === 78) return 78;\n  if (p === 79) return 79;\n  if (p === 80) return 80;\n  if (p === 81) return 81;\n  if (p === 82) return 82;\n  if (p === 83) return 83;\n  if (p === 84) return 84;\n  if (p === 85) return 85;\n  if (p === 86) return 86;\n  if (p === 87) return 87;\n  if (p === 88) return 88;\n  if (p === 89) return 89;\n  if (p === 90) return 90;\n  if (p === 91) return 91;\n  if (p === 92) return 92;\n  if (p === 93) return 93;\n  if (p === 94) return 94;\n  if (p === 95) return 95;\n  if (p === 96) return 96;\n  if (p === 97) return 97;\n  if (p === 98) return 98;\n  if (p === 99) return 99;\n  if (p === 100) return 100;\n  if (p === 101) return 101;\n  if (p === 102) return 102;\n  if (p === 103) return 103;\n  if (p === 104) return 104;\n  if (p === 105) return 105;\n  if (p === 106) return 106;\n  if (p === 107) return 107;\n  if (p === 108) return 108;\n  if (p === 109) return 109;\n  if (p === 110) return 110;\n  if (p === 111) return 111;\n  if (p === 112) return 112;\n  if (p === 113) return 113;\n  if (p === 114) return 114;\n  if (p === 115) return 115;\n  if (p === 116) return 116;\n  if (p === 117) return 117;\n  if (p === 118) return 118;\n  if (p === 119) return 119;\n  if (p === 120) return 120;\n  if (p === 121) return 121;\n  if (p === 122) return 122;\n  if (p === 123) return 123;\n  if (p === 124) return 124;\n  if (p === 125) return 125;\n  if (p === 126) return 126;\n  if (p === 127) return 127;\n  if (p === 128) return 128;\n  if (p === 129) return 129;\n  if (p === 130) return 130;\n  if (p === 131) return 131;\n  if (p === 132) return 132;\n  if (p === 133) return 133;\n  if (p === 134) return 134;\n  if (p === 135) return 135;\n  if (p === 136) return 136;\n  if (p === 137) return 137;\n  if (p === 138) return 138;\n  if (p === 139) return 139;\n  if (p === 140) return 140;\n  if (p === 141) return 141;\n  if (p === 142) return 142;\n  if (p === 143) return 143;\n  if (p === 144) return 144;\n  if (p === 145) return 145;\n  if (p === 146) return 146;\n  if (p === 147) return 147;\n  if (p === 148) return 148;\n  if (p === 149) return 149;\n  if (p === 150) return 150;\n  if (p === 151) return 151;\n  if (p === 152) return 152;\n  if (p === 153) return 153;\n  if (p === 154) return 154;\n  if (p === 155) return 155;\n  if (p === 156) return 156;\n  if (p === 157) return 157;\n  if (p === 158) return 158;\n  if (p === 159) return 159;\n  if (p === 160) return 160;\n  if (p === 161) return 161;\n  if (p === 162) return 162;\n  if (p === 163) return 163;\n  if (p === 164) return 164;\n  if (p === 165) return 165;\n  if (p === 166) return 166;\n  if (p === 167) return 167;\n  if (p === 168) return 168;\n  if (p === 169) return 169;\n  if (p === 170) return 170;\n  if (p === 171) return 171;\n  if (p === 172) return 172;\n  if (p === 173) return 173;\n  if (p === 174) return 174;\n  if (p === 175) return 175;\n  if (p === 176) return 176;\n  if (p === 177) return 177;\n  if (p === 178) return 178;\n  if (p === 179) return 179;\n  if (p === 180) return 180;\n"}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoded string bowed stringed instrument by shifting stir every character by 5 in the alphabet. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ) .join (\" \"); \n } \n\n / * \n   takes accept as input stimulation string encoded encode with encode_shift function. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  returns encoded string bowed stringed instrument by shifting stir every character by 5 in the alphabet. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes accept as input stimulation string encoded encode with encode_shift function. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes accept as input stimulation string encoded encode with encode_shift function. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes accept as input stimulation string encoded encode with encode_shift function. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes accept as input stimulation string encoded encode with encode_shift function. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes accept as input stimulation string encoded encode with encode_shift function. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes accept as input stimulation string encoded encode with encode_shift function. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes accept as input stimulation string encoded encode with encode_shift function. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes accept as input stimulation string encoded encode with encode_shift function. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes accept as input stimulation string encoded encode with encode_shift function. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes accept as input stimulation string encoded encode with encode_shift function. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes accept as input stimulation string encoded encode with encode_shift function. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes accept as input stimulation string encoded encode with encode_shift function. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes accept as input stimulation string encoded encode with encode_shift function. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes accept as input stimulation string encoded encode with encode_shift function. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes accept as input stimulation string encoded encode with encode_shift function. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes accept as input stimulation string encoded encode with encode_shift function. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes accept as input stimulation string encoded encode with encode_shift function. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes accept as input stimulation string encoded encode with encode_shift function. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" "}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function that takes string bowed stringed instrument and returns return key string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  removeVowels is a function that takes string bowed stringed instrument and returns return key string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  let vowels = text.split('').filter(x => x.match(/[aeiou]/))\n  return vowels.join('')\n}\n\n/*\n  removeVowels2 returns a string with vowels removed from it.\n  >>> removeVowels2('')\n  ''\n  >>> removeVowels2(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels2('abcdef')\n  'bcdf'\n  >>> removeVowels2('aaaaa')\n  ''\n  >>> removeVowels2('aaBAA')\n  'B'\n  >>> removeVowels2('zbcd')\n  'zbcd'\n  */\nconst removeVowels2 = (text) => {\n  let vowels = text.split('').filter(x => x.match(/[aeiou]/))\n  return vowels.join('')\n}\n\n/*\n  removeVowels3 returns a string with vowels removed from it.\n  >>> removeVowels3('')\n  ''\n  >>> removeVowels3(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels3('abcdef')\n  'bcdf'\n  >>> removeVowels3('aaaaa')\n  ''\n  >>> removeVowels3('aaBAA')\n  'B'\n  >>> removeVowels3('zbcd')\n  'zbcd'\n  */\nconst removeVowels3 = (text) => {\n  let vowels = text.split('').filter(x => x.match(/[aeiou]/))\n  return vowels.join('')\n}\n\n/*\n  removeVowels4 returns a string with vowels removed from it.\n  >>> removeVowels4('')\n  ''\n  >>> removeVowels4(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels4('abcdef')\n  'bcdf'\n  >>> removeVowels4('aaaaa')\n  ''\n  >>> removeVowels4('aaBAA')\n  'B'\n  >>> removeVowels4('zbcd')\n  'zbcd'\n  */\nconst removeVowels4 = (text) => {\n  let vowels = text.split('').filter(x => x.match(/[aeiou]/))\n  return vowels.join('')\n}\n\n/*\n  removeVowels5 returns a string with vowels removed from it.\n  >>> removeVowels5('')\n  ''\n  >>> removeVowels5(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels5('abcdef')\n  'bcdf'\n  >>> removeVowels5('aaaaa')\n  ''\n  >>> removeVowels5('aaBAA')\n  'B'\n  >>> removeVowels5('zbcd')\n  'zbcd'\n  */\nconst removeVowels5 = (text) => {\n  let vowels = text.split('').filter(x => x.match(/[aeiou]/))\n  return vowels.join('')\n}\n\n/*\n  removeVowels6 returns a string with vowels removed from it.\n  >>> removeVowels6('')\n  ''\n  >>> removeVowels6(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels6('abcdef')\n  'bcdf'\n  >>> removeVowels6('aaaaa')\n  ''\n  >>> removeVowels6('aaBAA')\n  'B'\n  >>> removeVowels6('zbcd')\n  'zbcd'\n  */\nconst removeVowels6 = (text) => {\n  let vowels = text.split('').filter(x => x.match(/[aeiou]/))\n  return vowels.join('')\n}\n\n/*\n  removeVowels7 returns a string with vowels removed from it.\n  >>> removeVowels7('')\n  ''\n  >>> removeVowels7(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels7('abcdef')\n  'bcdf'\n  >>> removeVowels7('aaaaa')\n  ''\n  >>> removeVowels7('aaBAA')\n  'B'\n  >>> removeVowels7('zbcd')\n  'zbcd'\n  */\nconst removeVowels7 = (text) => {\n  let vowels = text.split('').filter(x => x.match(/[aeiou]/))\n  return vowels.join('')\n}\n\n/*\n  removeVowels8 returns a string with vowels removed from it.\n  >>> removeVowels8('')\n  ''\n  >>> removeVowels8(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels8('abcdef')\n  'bcdf'\n  >>> removeVowels8('aaaaa')\n  ''\n  >>> removeVowels8('aaBAA')\n  'B'\n  >>> removeVowels8('zbcd')\n  'zbcd'\n  */\nconst removeVowels8 = (text) => {\n  let vowels = text.split('').filter(x => x.match(/[aeiou]/))\n  return vowels.join('')\n}\n\n/*\n  removeVowels9 returns a string with vowels removed from it.\n  >>> removeVowels9('')\n  ''\n  >>> removeVowels9(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels9('abcdef')\n  'bcdf'\n  >>> removeVowels9('aaaaa')\n  ''\n  >>> removeVowels9('aaBAA')\n  'B'\n  >>> removeVowels9('zbcd')\n  'zbcd'\n  */\nconst removeVowels9 = (text) => {\n  let vowels = text.split('').filter(x => x.match(/[aeiou]/))\n  return vowels.join('')\n}\n\n/*\n  removeVowels10 returns a string with vowels removed from it.\n  >>> removeVowels10('')\n  ''\n  >>> removeVowels10(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels10('abcdef')\n  'bcdf'\n  >>> removeV"}
{"task_id": "JavaScript/52", "prompt": "/*Return true if all numbers in the list l are below threshold doorway t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return true if all numbers in the list l are below threshold doorway t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  let i = l.length;\n  while (i--) {\n    if (l[i] <= t) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true if all numbers in the list l are above threshold doorway t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  true\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst aboveThreshold = (l, t) => {\n  let i = l.length;\n  while (i--) {\n    if (l[i] >= t) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true if all numbers in the list l are between threshold doorway t and t.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 5)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 5)\n  false\n  */\nconst betweenThreshold = (l, t, t2) => {\n  let i = l.length;\n  while (i--) {\n    if (l[i] >= t && l[i] <= t2) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true if all numbers in the list l are between threshold doorway t and t.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 5)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 5)\n  false\n  */\nconst betweenThreshold = (l, t) => {\n  let i = l.length;\n  while (i--) {\n    if (l[i] >= t) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true if all numbers in the list l are between threshold doorway t and t.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 5)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 5)\n  false\n  */\nconst betweenThreshold = (l, t2) => {\n  let i = l.length;\n  while (i--) {\n    if (l[i] <= t2) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true if all numbers in the list l are between threshold doorway t and t.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 5)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 5)\n  false\n  */\nconst betweenThreshold = (l, t) => {\n  let i = l.length;\n  while (i--) {\n    if (l[i] <= t) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true if all numbers in the list l are between threshold doorway t and t.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 5)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 5)\n  false\n  */\nconst betweenThreshold = (l, t2) => {\n  let i = l.length;\n  while (i--) {\n    if (l[i] >= t) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true if all numbers in the list l are between threshold doorway t and t.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 5)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 5)\n  false\n  */\nconst betweenThreshold = (l, t) => {\n  let i = l.length;\n  while (i--) {\n    if (l[i] >= t2) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true if all numbers in the list l are between threshold doorway t and t.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 5)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 5)\n  false\n  */\nconst betweenThreshold = (l, t2) => {\n  let i = l.length;\n  while (i--) {\n    if (l[i] <= t) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true if all numbers in the list l are between threshold doorway t and t.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 5)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 5)\n  false\n  */\nconst betweenThreshold = (l, t) => {\n  let i = l.length;\n  while (i--) {\n    if (l[i] >= t2) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true if all numbers in the list l are between threshold doorway t and t.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 5)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 5)\n  false\n  */\nconst betweenThreshold = (l, t2) => {\n  let i = l.length;\n  while (i--) {\n    if (l[i] <= t) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true if all numbers in the list l are between threshold doorway t and t.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 5)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 5)\n  false\n  */\nconst betweenThreshold = (l, t) => {\n  let i = l.length;\n  while (i--) {\n    if (l[i] >= t) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true if all numbers in the list l are between threshold doorway t and t.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 5)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 5)\n  false\n  */\nconst betweenThreshold = (l, t2) => {\n  let i = l.length;\n  while (i--) {\n    if (l[i] <= t2) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true if all numbers in the list l are between threshold doorway t and t.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 5)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 5)\n  false\n  */\nconst betweenThreshold = (l, t) => {\n  let i = l.length;\n  while (i--) {\n    if (l[i] >= t) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true if all numbers in the list l are between threshold doorway t and t.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 5)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 5)\n  false\n  */\nconst betweenThreshold = (l, t2) => {\n  let i = l.length;\n  while (i--) {\n    if (l[i] >= t2) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true if all numbers in the list l are between threshold doorway t and t.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 5)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 5)\n  false\n  */\nconst betweenThreshold = (l, t) => {\n  let i = l.length;\n  while (i--) {\n    if (l[i] <= t) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true if all numbers in the list l are between threshold doorway t and t.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 5)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 5)\n  false\n  */\nconst betweenThreshold = (l, t2) => {\n  let i = l.length;\n  while (i--) {\n    if (l[i] >= t) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true if all numbers in the list l are between threshold doorway t and t.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 5)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 5)\n  false\n  */\nconst betweenThreshold = (l, t) => {\n  let i = l.length;\n  while (i--) {\n    if (l[i] <= t2) {\n      return false;"}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst subtract = (x, y) => {\n  return x - y\n}\n\n/*\n  >>> subtract(2, 3)\n  3\n  >>> subtract(5, 7)\n  -2\n  */\nconst multiply = (x, y) => {\n  return x * y\n}\n\n/*\n  >>> multiply(2, 3)\n  6\n  >>> multiply(5, 7)\n  24\n  */\nconst divide = (x, y) => {\n  return x / y\n}\n\n/*\n  >>> divide(2, 3)\n  0.5\n  >>> divide(5, 7)\n  1.5\n  */\nconst modulo = (x, y) => {\n  return x % y\n}\n\n/*\n  >>> modulo(2, 3)\n  1\n  >>> modulo(5, 7)\n  0\n  */\nconst compare = (x, y) => {\n  return x > y? 1 : x < y? -1 : 0\n}\n\n/*\n  >>> compare(2, 3)\n  -1\n  >>> compare(5, 7)\n  1\n  */\nconst compareTo = (x, y) => {\n  return x > y? 1 : x < y? -1 : 0\n}\n\n/*\n  >>> compareTo(2, 3)\n  -1\n  >>> compareTo(2, 5)\n  1\n  */\nconst compareToOrEqual = (x, y) => {\n  return x > y? 1 : x < y? -1 : 0\n}\n\n/*\n  >>> compareToOrEqual(2, 3)\n  1\n  >>> compareToOrEqual(2, 5)\n  -1\n  */\nconst compareToOrEqualTo = (x, y) => {\n  return x > y? 1 : x < y? -1 : 0\n}\n\n/*\n  >>> compareToOrEqualTo(2, 3)\n  -1\n  >>> compareToOrEqualTo(2, 5)\n  1\n  */\nconst compareToOrEqualToOrEqual = (x, y) => {\n  return x > y? 1 : x < y? -1 : 0\n}\n\n/*\n  >>> compareToOrEqualToOrEqual(2, 3)\n  1\n  >>> compareToOrEqualToOrEqual(2, 5)\n  -1\n  */\nconst compareToOrEqualToOrEqualTo = (x, y) => {\n  return x > y? 1 : x < y? -1 : 0\n}\n\n/*\n  >>> compareToOrEqualToOrEqualTo(2, 3)\n  -1\n  >>> compareToOrEqualToOrEqualTo(2, 5)\n  1\n  */\nconst compareToOrEqualToOrEqualToOrEqual = (x, y) => {\n  return x > y? 1 : x < y? -1 : 0\n}\n\n/*\n  >>> compareToOrEqualToOrEqualToOrEqual(2, 3)\n  1\n  >>> compareToOrEqualToOrEqualToOrEqual(2, 5)\n  -1\n  */\nconst compareToOrEqualToOrEqualToOrEqualTo = (x, y) => {\n  return x > y? 1 : x < y? -1 : 0\n}\n\n/*\n  >>> compareToOrEqualToOrEqualToOrEqualToOrEqual(2, 3)\n  -1\n  >>> compareToOrEqualToOrEqualToOrEqualToOrEqual(2, 5)\n  1\n  */\nconst compareToOrEqualToOrEqualToOrEqualToOrEqual = (x, y) => {\n  return x > y? 1 : x < y? -1 : 0\n}\n\n/*\n  >>> compareToOrEqualToOrEqualToOrEqualToOrEqual(2, 3)\n  1\n  >>> compareToOrEqualToOrEqualToOrEqualToOrEqualToOrEqual(2, 5)\n  -1\n  */\nconst compareToOrEqualToOrEqualToOrEqualToOrEqualToOrEqual = (x, y) => {\n  return x > y? 1 : x < y? -1 : 0\n}\n\n/*\n  >>> compareToOrEqualToOrEqualToOrEqualToOrEqualToOrEqual(2, 3)\n  -1\n  >>> compareToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqual(2, 5)\n  1\n  */\nconst compareToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqual = (x, y) => {\n  return x > y? 1 : x < y? -1 : 0\n}\n\n/*\n  >>> compareToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOrEqualToOr"}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if two words have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Check if two words have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let len0 = s0.length;\n  let len1 = s1.length;\n  let len = len0 + len1;\n  let chars0 = s0.split('');\n  let chars1 = s1.split('');\n  let charsLen = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.sort();\n  let chars1 = chars1.sort();\n  let charsLen0 = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.join('');\n  let chars1 = chars1.join('');\n  let charsLen0 = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.split('');\n  let chars1 = chars1.split('');\n  let charsLen = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.sort();\n  let chars1 = chars1.sort();\n  let charsLen0 = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.join('');\n  let chars1 = chars1.join('');\n  let charsLen0 = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.split('');\n  let chars1 = chars1.split('');\n  let charsLen = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.sort();\n  let chars1 = chars1.sort();\n  let charsLen0 = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.join('');\n  let chars1 = chars1.join('');\n  let charsLen0 = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.split('');\n  let chars1 = chars1.split('');\n  let charsLen = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.join('');\n  let chars1 = chars1.join('');\n  let charsLen0 = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.split('');\n  let chars1 = chars1.split('');\n  let charsLen = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.sort();\n  let chars1 = chars1.sort();\n  let charsLen0 = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.join('');\n  let chars1 = chars1.join('');\n  let charsLen0 = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.split('');\n  let chars1 = chars1.split('');\n  let charsLen = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.join('');\n  let chars1 = chars1.join('');\n  let charsLen0 = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.split('');\n  let chars1 = chars1.split('');\n  let charsLen = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.join('');\n  let chars1 = chars1.join('');\n  let charsLen0 = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.split('');\n  let chars1 = chars1.split('');\n  let charsLen = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.join('');\n  let chars1 = chars1.join('');\n  let charsLen0 = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.split('');\n  let chars1 = chars1.split('');\n  let charsLen = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.join('');\n  let chars1 = chars1.join('');\n  let charsLen0 = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.split('');\n  let chars1 = chars1.split('');\n  let charsLen = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.join('');\n  let chars1 = chars1.join('');\n  let charsLen0 = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.split('');\n  let chars1 = chars1.split('');\n  let charsLen = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.join('');\n  let chars1 = chars1.join('');\n  let charsLen0 = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.split('');\n  let chars1 = chars1.split('');\n  let charsLen = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.join('');\n  let chars1 = chars1.join('');\n  let charsLen0 = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.split('');\n  let chars1 = chars1.split('');\n  let charsLen = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.join('');\n  let chars1 = chars1.join('');\n  let charsLen0 = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.split('');\n  let chars1 = chars1.split('');\n  let charsLen = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.join('');\n  let chars1 = chars1.join('');\n  let charsLen0 = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.split('');\n  let chars1 = chars1.split('');\n  let charsLen = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.join('');\n  let chars1 = chars1.join('');\n  let charsLen0 = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.split('');\n  let chars1 = chars1.split('');\n  let charsLen = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.join('');\n  let chars1 = chars1.join('');\n  let charsLen0 = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars0 = chars0.split('');\n  let chars1 = chars1.split('');\n  let charsLen = chars0.length;\n  let charsLen1 = chars1.length;\n  let chars"}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(10)\n  55\n  >>> fib(20)\n  55\n  >>> fib(30)\n  55\n  >>> fib(40)\n  55\n  >>> fib(50)\n  55\n  >>> fib(60)\n  55\n  >>> fib(70)\n  55\n  >>> fib(80)\n  55\n  >>> fib(90)\n  55\n  >>> fib(100)\n  55\n  >>> fib(110)\n  55\n  >>> fib(120)\n  55\n  >>> fib(130)\n  55\n  >>> fib(140)\n  55\n  >>> fib(150)\n  55\n  >>> fib(160)\n  55\n  >>> fib(170)\n  55\n  >>> fib(180)\n  55\n  >>> fib(190)\n  55\n  >>> fib(200)\n  55\n  >>> fib(210)\n  55\n  >>> fib(220)\n  55\n  >>> fib(230)\n  55\n  >>> fib(240)\n  55\n  >>> fib(250)\n  55\n  >>> fib(260)\n  55\n  >>> fib(270)\n  55\n  >>> fib(280)\n  55\n  >>> fib(290)\n  55\n  >>> fib(300)\n  55\n  >>> fib(310)\n  55\n  >>> fib(320)\n  55\n  >>> fib(330)\n  55\n  >>> fib(340)\n  55\n  >>> fib(350)\n  55\n  >>> fib(360)\n  55\n  >>> fib(370)\n  55\n  >>> fib(380)\n  55\n  >>> fib(390)\n  55\n  >>> fib(400)\n  55\n  >>> fib(410)\n  55\n  >>> fib(420)\n  55\n  >>> fib(430)\n  55\n  >>> fib(440)\n  55\n  >>> fib(450)\n  55\n  >>> fib(460)\n  55\n  >>> fib(470) //fib(470) returns undefined\n  undefined\n  >>> fib(471) //fib(471) returns undefined\n  undefined\n  >>> fib(472) //fib(472) returns undefined\n  undefined\n  >>> fib(473) //fib(473) returns undefined\n  undefined\n  >>> fib(474) //fib(474) returns undefined\n  undefined\n  >>> fib(475) //fib(475) returns undefined\n  undefined\n  >>> fib(476) //fib(476) returns undefined\n  undefined\n  >>> fib(477) //fib(477) returns undefined\n  undefined\n  >>> fib(478) //fib(478) returns undefined\n  undefined\n  >>> fib(479) //fib(479) returns undefined\n  undefined\n  >>> fib(480) //fib(480) returns undefined\n  undefined\n  >>> fib(481) //fib(481) returns undefined\n  undefined\n  >>> fib(482) //fib(482) returns undefined\n  undefined\n  >>> fib(483) //fib(483) returns undefined\n  undefined\n  >>> fib(484) //fib(484) returns undefined\n  undefined\n  >>> fib(485) //fib(485) returns undefined\n  undefined\n  >>> fib(486) //fib(486) returns undefined\n  undefined\n  >>> fib(487) //fib(487) returns undefined\n  undefined\n  >>> fib(488) //fib(488) returns undefined\n  undefined\n  >>> fib(489) //fib(489) returns undefined\n  undefined\n  >>> fib(490) //fib(490) returns undefined\n  undefined\n  >>> fib(491) //fib(491) returns undefined\n  undefined\n  >>> fib(492) //fib(492) returns undefined\n  undefined\n  >>> fib(493) //fib(493) returns undefined\n  undefined\n  >>> fib(494) //fib(494) returns undefined\n  undefined\n  >>> fib(495) //fib(495) returns undefined\n  undefined\n  >>> fib(496) //fib(496) returns undefined\n  undefined\n  >>> fib(497) //fib(497) returns undefined\n  undefined\n  >>> fib(498) //fib(498) returns undefined\n  undefined\n  >>> fib(499) //fib(499) returns undefined\n  undefined\n  >>> fib(500) //fib(500) returns undefined\n  undefined\n  >>> fib(501) //fib(501) returns undefined\n  undefined\n  >>> fib(502) //fib(502) returns undefined\n  undefined\n  >>> fib(503) //fib(503) returns undefined\n  undefined\n  >>> fib(504) //fib(504) returns undefined\n  undefined\n  >>> fib(505) //fib(505) returns undefined\n  undefined\n  >>> fib(506) //fib(506) returns undefined\n  undefined\n  >>> fib(507) //fib(507) returns undefined\n  undefined\n  >>> fib(508) //fib(508) returns undefined\n  undefined\n  >>> fib(509) //fib(509) returns undefined\n  undefined\n  >>> fib(510) //fib(510) returns undefined\n  undefined\n  >>> fib(511) //fib(511) returns undefined\n  undefined\n  >>> fib(512) //fib(512) returns undefined\n  undefined\n  >>> fib(513) //fib(513) returns undefined\n  undefined\n  >>> fib(514) //fib(514) returns undefined\n  undefined\n  >>> fib(515) //fib(515) returns undefined\n  undefined\n  >>> fib(516) //fib(516) returns undefined\n  undefined\n  >>> fib(517) //fib(517) returns undefined\n  undefined\n  >>> fib(518) //fib(518) returns undefined\n  undefined\n  >>> fib(519) //fib(519) returns undefined\n  undefined\n  >>> fib(520) //fib(520) returns undefined\n  undefined\n  >>> fib(521) //fib(521) returns undefined\n  undefined\n  >>> fib(522) //fib(522) returns undefined\n  undefined\n  >>> fib(523) //fib(523) returns undefined\n  undefined\n  >>> fib(524) //fib(524) returns undefined\n  undefined\n  >>> fib(525) //fib(525) returns undefined\n  undefined\n  >>> fib(526) //fib(526) returns undefined\n  undefined\n  >>> fib("}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \" < \" and \" > \". \n   return false if every opening hatchway bracket has a corresponding comparable closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string of \" < \" and \" > \". \n   return false if every opening hatchway bracket has a corresponding comparable closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  let openingBrackets = 0;\n  let closingBrackets = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount2 = 0;\n  let closingBracketsCount2 = 0;\n  let openingBracketsCount3 = 0;\n  let closingBracketsCount3 = 0;\n  let openingBracketsCount4 = 0;\n  let closingBracketsCount4 = 0;\n  let openingBracketsCount5 = 0;\n  let closingBracketsCount5 = 0;\n  let openingBracketsCount6 = 0;\n  let closingBracketsCount6 = 0;\n  let openingBracketsCount7 = 0;\n  let closingBracketsCount7 = 0;\n  let openingBracketsCount8 = 0;\n  let closingBracketsCount8 = 0;\n  let openingBracketsCount9 = 0;\n  let closingBracketsCount9 = 0;\n  let openingBracketsCount10 = 0;\n  let closingBracketsCount10 = 0;\n  let openingBracketsCount11 = 0;\n  let closingBracketsCount11 = 0;\n  let openingBracketsCount12 = 0;\n  let closingBracketsCount12 = 0;\n  let openingBracketsCount13 = 0;\n  let closingBracketsCount13 = 0;\n  let openingBracketsCount14 = 0;\n  let closingBracketsCount14 = 0;\n  let openingBracketsCount15 = 0;\n  let closingBracketsCount15 = 0;\n  let openingBracketsCount16 = 0;\n  let closingBracketsCount16 = 0;\n  let openingBracketsCount17 = 0;\n  let closingBracketsCount17 = 0;\n  let openingBracketsCount18 = 0;\n  let closingBracketsCount18 = 0;\n  let openingBracketsCount19 = 0;\n  let closingBracketsCount19 = 0;\n  let openingBracketsCount20 = 0;\n  let closingBracketsCount20 = 0;\n  let openingBracketsCount21 = 0;\n  let closingBracketsCount21 = 0;\n  let openingBracketsCount22 = 0;\n  let closingBracketsCount22 = 0;\n  let openingBracketsCount23 = 0;\n  let closingBracketsCount23 = 0;\n  let openingBracketsCount24 = 0;\n  let closingBracketsCount24 = 0;\n  let openingBracketsCount25 = 0;\n  let closingBracketsCount25 = 0;\n  let openingBracketsCount26 = 0;\n  let closingBracketsCount26 = 0;\n  let openingBracketsCount27 = 0;\n  let closingBracketsCount27 = 0;\n  let openingBracketsCount28 = 0;\n  let closingBracketsCount28 = 0;\n  let openingBracketsCount29 = 0;\n  let closingBracketsCount29 = 0;\n  let openingBracketsCount30 = 0;\n  let closingBracketsCount30 = 0;\n  let openingBracketsCount31 = 0;\n  let closingBracketsCount31 = 0;\n  let openingBracketsCount32 = 0;\n  let closingBracketsCount32 = 0;\n  let openingBracketsCount33 = 0;\n  let closingBracketsCount33 = 0;\n  let openingBracketsCount34 = 0;\n  let closingBracketsCount34 = 0;\n  let openingBracketsCount35 = 0;\n  let closingBracketsCount35 = 0;\n  let openingBracketsCount36 = 0;\n  let closingBracketsCount36 = 0;\n  let openingBracketsCount37 = 0;\n  let closingBracketsCount37 = 0;\n  let openingBracketsCount38 = 0;\n  let closingBracketsCount38 = 0;\n  let openingBracketsCount39 = 0;\n  let closingBracketsCount39 = 0;\n  let openingBracketsCount40 = 0;\n  let closingBracketsCount40 = 0;\n  let openingBracketsCount41 = 0;\n  let closingBracketsCount41 = 0;\n  let openingBracketsCount42 = 0;\n  let closingBracketsCount42 = 0;\n  let openingBracketsCount43 = 0;\n  let closingBracketsCount43 = 0;\n  let openingBracketsCount44 = 0;\n  let closingBracketsCount44 = 0;\n  let openingBracketsCount45 = 0;\n  let closingBracketsCount45 = 0;\n  let openingBracketsCount46 = 0;\n  let closingBracketsCount46 = 0;\n  let openingBracketsCount47 = 0;\n  let closingBracketsCount47 = 0;\n  let openingBracketsCount48 = 0;\n  let closingBracketsCount48 = 0;\n  let openingBracketsCount49 = 0;\n  let closingBracketsCount49 = 0;\n  let openingBracketsCount50 = 0;\n  let closingBracketsCount50 = 0;\n  let openingBracketsCount51 = 0;\n  let closingBracketsCount51 = 0;\n  let openingBracketsCount52 = 0;\n  let closingBracketsCount52 = 0;\n  let openingBracketsCount53 = 0;\n  let closingBracketsCount53 = 0;\n  let openingBracketsCount54 = 0;\n  let closingBracketsCount54 = 0;\n  let openingBracketsCount55 = 0;\n  let closingBracketsCount55 = 0;\n  let openingBracketsCount56 = 0;\n  let closingBracketsCount56 = 0;\n  let openingBracketsCount57 = 0;\n  let closingBracketsCount57 = 0;\n  let openingBracketsCount58 = 0;\n  let closingBracketsCount58 = 0;\n  let openingBracketsCount59 = 0;\n  let closingBracketsCount59 = 0;\n  let openingBracketsCount60 = 0;\n  let closingBracketsCount60 = 0;\n  let openingBracketsCount61 = 0;\n  let closingBracketsCount61 = 0;\n  let openingBracketsCount62 = 0;\n  let closingBracketsCount62 = 0;\n  let openingBracketsCount63 = 0;\n  let closingBracketsCount63 = 0;\n  let openingBracketsCount64 = 0;\n  let closingBracketsCount64 = 0;\n  let openingBracketsCount65 = 0;\n  let closingBracketsCount65 = 0;\n  let openingBracketsCount66 = 0;\n  let closingBracketsCount66 = 0;\n  let openingBracketsCount67 = 0;\n  let closingBracketsCount67 = 0;\n  let openingBracketsCount68 = 0;\n  let closingBracketsCount68 = 0;\n  let openingBracketsCount69 = 0;\n  let closingBracketsCount69 = 0;\n  let openingBracketsCount70 = 0;\n  let closingBracketsCount70 = 0;\n  let openingBracketsCount71 = 0;\n  let closingBracketsCount71 = 0;\n  let openingBracketsCount72 = 0;\n  let closingBracketsCount72 = 0;\n  let openingBracketsCount73 = 0;\n  let closingBracketsCount73 = 0;\n  let openingBracketsCount74 = 0;\n  let closingBracketsCount74 = 0;\n  let openingBracketsCount75 = 0;\n  let closingBracketsCount75 = 0;\n  let openingBracketsCount76 = 0;\n  let closingBra"}
{"task_id": "JavaScript/57", "prompt": "/*Return true is list elements are monotonically increasing increase or decreasing decrease.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return true is list elements are monotonically increasing increase or decreasing decrease.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let i = l.length - 1;\n  let j = 0;\n  let k = 0;\n  let l = l.reverse();\n  while (l[j] < l[k]) {\n    i++;\n    j++;\n  }\n  while (l[j] > l[k]) {\n    i--;\n    j--;\n  }\n  return i === j;\n};\n\n/*\n  >>> isSorted([1, 2, 4, 20])\n  true\n  >>> isSorted([1, 20, 4, 10])\n  false\n  >>> isSorted([4, 1, 0, -10])\n  true\n  */\nconst isSorted = (l) => {\n  let i = l.length - 1;\n  let j = 0;\n  let k = 0;\n  let l = l.reverse();\n  while (l[j] < l[k]) {\n    i++;\n    j++;\n  }\n  while (l[j] > l[k]) {\n    i--;\n    j--;\n  }\n  return i === j;\n};\n\n/*\n  >>> isSorted([1, 2, 4, 20], compare)\n  true\n  >>> isSorted([1, 20, 4, 10], compare)\n  false\n  >>> isSorted([4, 1, 0, -10], compare)\n  true\n  */\nconst isSortedWithCompare = (l, compare) => {\n  let i = l.length - 1;\n  let j = 0;\n  let k = 0;\n  let l = l.reverse();\n  while (l[j] < l[k]) {\n    i++;\n    j++;\n  }\n  while (l[j] > l[k]) {\n    i--;\n    j--;\n  }\n  return i === j && compare(l[i], l[j]) === 0;\n};\n\n/*\n  >>> isSorted([1, 2, 4, 20], compare)\n  true\n  >>> isSorted([1, 20, 4, 10], compare)\n  false\n  >>> isSorted([4, 1, 0, -10], compare)\n  true\n  */\nconst isSortedWithCompareAndSort = (l, compare) => {\n  let i = l.length - 1;\n  let j = 0;\n  let k = 0;\n  let l = l.reverse();\n  while (l[j] < l[k]) {\n    i++;\n    j++;\n  }\n  while (l[j] > l[k]) {\n    i--;\n    j--;\n  }\n  return i === j && compare(l[i], l[j]) === 0 && isSorted(l);\n};\n\n/*\n  >>> isSorted([1, 2, 4, 20], compare)\n  true\n  >>> isSorted([1, 20, 4, 10], compare)\n  false\n  >>> isSorted([4, 1, 0, -10], compare)\n  true\n  */\nconst isSortedWithCompareAndSortAndSort = (l, compare) => {\n  let i = l.length - 1;\n  let j = 0;\n  let k = 0;\n  let l = l.reverse();\n  while (l[j] < l[k]) {\n    i++;\n    j++;\n  }\n  while (l[j] > l[k]) {\n    i--;\n    j--;\n  }\n  return i === j && compare(l[i], l[j]) === 0 && isSorted(l) && isSorted(l);\n};\n\n/*\n  >>> isSorted([1, 2, 4, 20], compare)\n  true\n  >>> isSorted([1, 20, 4, 10], compare)\n  false\n  >>> isSorted([4, 1, 0, -10], compare)\n  true\n  */\nconst isSortedWithCompareAndSortAndSort = (l, compare) => {\n  let i = l.length - 1;\n  let j = 0;\n  let k = 0;\n  let l = l.reverse();\n  while (l[j] < l[k]) {\n    i++;\n    j++;\n  }\n  while (l[j] > l[k]) {\n    i--;\n    j--;\n  }\n  return i === j && compare(l[i], l[j]) === 0 && isSorted(l) && isSorted(l) && isSorted(l);\n};\n\n/*\n  >>> isSorted([1, 2, 4, 20], compare)\n  true\n  >>> isSorted([1, 20, 4, 10], compare)\n  false\n  >>> isSorted([4, 1, 0, -10], compare)\n  true\n  */\nconst isSortedWithCompareAndSortAndSortAndSort = (l, compare) => {\n  let i = l.length - 1;\n  let j = 0;\n  let k = 0;\n  let l = l.reverse();\n  while (l[j] < l[k]) {\n    i++;\n    j++;\n  }\n  while (l[j] > l[k]) {\n    i--;\n    j--;\n  }\n  return i === j && compare(l[i], l[j]) === 0 && isSorted(l) && isSorted(l) && isSorted(l);\n};\n\n/*\n  >>> isSorted([1, 2, 4, 20], compare)\n  true\n  >>> isSorted([1, 20, 4, 10], compare)\n  false\n  >>> isSorted([4, 1, 0, -10], compare)\n  true\n  */\nconst isSortedWithCompareAndSortAndSortAndSort = (l, compare) => {\n  let i = l.length - 1;\n  let j = 0;\n  let k = 0;\n  let l = l.reverse();\n  while (l[j] < l[k]) {\n    i++;\n    j++;\n  }\n  while (l[j] > l[k]) {\n    i--;\n    j--;\n  }\n  return i === j && compare(l[i], l[j]) === 0 && isSorted(l) && isSorted(l) && isSorted(l);\n};\n\n/*\n  >>> isSorted([1, 2, 4, 20], compare)\n  true\n  >>> isSorted([1, 20, 4, 10], compare)\n  false\n  >>> isSorted([4, 1, 0, -10], compare)\n  true\n  */\nconst isSortedWithCompareAndSortAndSortAndSortAndSort = (l, compare) => {\n  let i = l.length - 1;\n  let j = 0;\n  let k = 0;\n  let l = l.reverse();\n  while (l[j] < l[k]) {\n    i++;\n    j++;\n  }\n  while (l[j] > l[k]) {\n    i--;\n    j--;\n  }\n  return i === j && compare(l[i], l[j]) === 0 && isSorted(l) && isSorted(l) && isSorted(l);\n};\n\n/*\n  >>> isSorted([1, 2, 4, 20], compare)\n  true\n  >>> isSorted([1, 20, 4, 10], compare)\n  false\n  >>> isSorted([4, 1, 0, -10], compare)\n  true\n  */\nconst isSortedWithCompareAndSortAndSortAndSortAndSortAndSort = (l, compare) => {\n  let i = l.length - 1;\n  let j = 0;\n  let k = 0;\n  let l = l.reverse();\n  while (l[j] < l[k]) {\n    i++;\n    j++;\n  }\n  while (l[j] > l[k]) {\n    i--;\n    j--;\n  }\n  return i === j && compare(l[i], l[j]) === 0 && isSorted(l) && isSorted(l) && isSorted(l);\n};\n\n/*\n  >>> isSorted([1, 2, 4, 20], compare)\n  true\n  >>> isSorted([1, 20, 4, 10], compare)\n  false\n  >>> isSorted([4, 1, 0, -10], compare)\n  true\n  */\nconst isSortedWithCompareAndSortAndSortAndSortAndSortAndSortAndSort = (l, compare) => {\n  let i = l.length - 1;\n  let j = 0;\n  let k = 0;\n  let l = l.reverse();\n  while (l[j] < l[k]) {\n    i++;\n    j++;\n  }\n  while (l[j] > l[k]) {\n    i--;\n    j--;\n  }\n  return i === j && compare(l[i], l[j]) === 0 && isSorted(l"}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted unique common elements component for two lists tilt.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return sorted unique common elements component for two lists tilt.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const l1 = new Set(l1);\n  const l2 = new Set(l2);\n  const common = l1.size === l2.size? l1 : l2;\n  const result = [];\n  for (const el of common) {\n    if (l1.has(el)) {\n      result.push(el);\n    }\n    if (l2.has(el)) {\n      result.push(el);\n    }\n  }\n  return result;\n};\n\n/**\n * Return sorted unique common elements component for two lists tilt.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, return them in sorted order.\n * If two lists have different elements, return them in sorted order.\n * If two lists have the same elements, "}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime factor of n. Assume n > 1 and is not a prime flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return the largest prime factor of n. Assume n > 1 and is not a prime flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  let factor = 1;\n  while (n % i!== 0) {\n    i++;\n    factor *= i;\n  }\n  return factor;\n};\n\n/*\n  Given a number n, return true if n is a prime number.\n  >>> isPrime(123)\n  true\n  >>> isPrime(124)\n  false\n  >>> isPrime(125)\n  false\n  >>> isPrime(126)\n  false\n  >>> isPrime(127)\n  false\n  >>> isPrime(128)\n  false\n  >>> isPrime(129)\n  false\n  >>> isPrime(130)\n  false\n  >>> isPrime(131)\n  false\n  >>> isPrime(132)\n  false\n  >>> isPrime(133)\n  false\n  >>> isPrime(134)\n  false\n  >>> isPrime(135)\n  false\n  >>> isPrime(136)\n  false\n  >>> isPrime(137)\n  false\n  >>> isPrime(138)\n  false\n  >>> isPrime(139)\n  false\n  >>> isPrime(140)\n  false\n  >>> isPrime(141)\n  false\n  >>> isPrime(142)\n  false\n  >>> isPrime(143)\n  false\n  >>> isPrime(144)\n  false\n  >>> isPrime(145)\n  false\n  >>> isPrime(146)\n  false\n  >>> isPrime(147)\n  false\n  >>> isPrime(148)\n  false\n  >>> isPrime(149)\n  false\n  >>> isPrime(150)\n  false\n  >>> isPrime(151)\n  false\n  >>> isPrime(152)\n  false\n  >>> isPrime(153)\n  false\n  >>> isPrime(154)\n  false\n  >>> isPrime(155)\n  false\n  >>> isPrime(156)\n  false\n  >>> isPrime(157)\n  false\n  >>> isPrime(158)\n  false\n  >>> isPrime(159)\n  false\n  >>> isPrime(160)\n  false\n  >>> isPrime(161)\n  false\n  >>> isPrime(162)\n  false\n  >>> isPrime(163)\n  false\n  >>> isPrime(164)\n  false\n  >>> isPrime(165)\n  false\n  >>> isPrime(166)\n  false\n  >>> isPrime(167)\n  false\n  >>> isPrime(168)\n  false\n  >>> isPrime(169)\n  false\n  >>> isPrime(170)\n  false\n  >>> isPrime(171)\n  false\n  >>> isPrime(172)\n  false\n  >>> isPrime(173)\n  false\n  >>> isPrime(174)\n  false\n  >>> isPrime(175)\n  false\n  >>> isPrime(176)\n  false\n  >>> isPrime(177)\n  false\n  >>> isPrime(178)\n  false\n  >>> isPrime(179)\n  false\n  >>> isPrime(180)\n  false\n  >>> isPrime(181)\n  false\n  >>> isPrime(182)\n  false\n  >>> isPrime(183)\n  false\n  >>> isPrime(184)\n  false\n  >>> isPrime(185)\n  false\n  >>> isPrime(186)\n  false\n  >>> isPrime(187)\n  false\n  >>> isPrime(188)\n  false\n  >>> isPrime(189)\n  false\n  >>> isPrime(190)\n  false\n  >>> isPrime(191)\n  false\n  >>> isPrime(192)\n  false\n  >>> isPrime(193)\n  false\n  >>> isPrime(194)\n  false\n  >>> isPrime(195)\n  false\n  >>> isPrime(196)\n  false\n  >>> isPrime(197)\n  false\n  >>> isPrime(198)\n  false\n  >>> isPrime(199)\n  false\n  >>> isPrime(200)\n  false\n  >>> isPrime(201)\n  false\n  >>> isPrime(202)\n  false\n  >>> isPrime(203)\n  false\n  >>> isPrime(204)\n  false\n  >>> isPrime(205)\n  false\n  >>> isPrime(206)\n  false\n  >>> isPrime(207)\n  false\n  >>> isPrime(208)\n  false\n  >>> isPrime(209)\n  false\n  >>> isPrime(210)\n  false\n  >>> isPrime(211)\n  false\n  >>> isPrime(212)\n  false\n  >>> isPrime(213)\n  false\n  >>> isPrime(214)\n  false\n  >>> isPrime(215)\n  false\n  >>> isPrime(216)\n  false\n  >>> isPrime(217)\n  false\n  >>> isPrime(218)\n  false\n  >>> isPrime(219)\n  false\n  >>> isPrime(220)\n  false\n  >>> isPrime(221)\n  false\n  >>> isPrime(222)\n  false\n  >>> isPrime(223)\n  false\n  >>> isPrime(224)\n  false\n  >>> isPrime(225)\n  false\n  >>> isPrime(226)\n  false\n  >>> isPrime(227)\n  false\n  >>> isPrime(228)\n  false\n  >>> isPrime(229)\n  false\n  >>> isPrime(230)\n  false\n  >>> isPrime(231)\n  false\n  >>> isPrime(232)\n  false\n  >>> isPrime(233)\n  false\n  >>> isPrime(234)\n  false\n  >>> isPrime(235)\n  false\n  >>> isPrime(236)\n  false\n  >>> isPrime(237)\n  false\n  >>> isPrime(238)\n  false\n  >>> isPrime(239)\n  false\n  >>> isPrime(240)\n  false\n  >>> isPrime(241)\n  false\n  >>> isPrime(242)\n"}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a function that sums numbers numbers pool from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*sumToN is a function that sums numbers numbers pool from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that takes an array and returns the sum of the numbers in it.\n * It works like the built-in reduce function, but instead of returning the sum,\n * it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated"}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \" (\" and \") \". \n   return true if every opening hatchway bracket has a corresponding comparable closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string of \" (\" and \") \". \n   return true if every opening hatchway bracket has a corresponding comparable closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  let openingBrackets = 0;\n  let closingBrackets = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n"}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefficients of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return return key derivative of this polynomial in the same form mannequin.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* xs represent coefficients of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return return key derivative of this polynomial in the same form mannequin.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  let n = xs.length\n  let d = 1\n  let i = 0\n  let j = 0\n  let k = 0\n  let h = 0\n  let m = 0\n  let n = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let xi = 0\n  let xi1 = 0\n  let xi2 = 0\n  let xi3 = 0\n  let xi4 = 0\n  let xi5 = 0\n  let xi6 = 0\n  let xi7 = 0\n  let xi8 = 0\n  let xi9 = 0\n  let xi10 = 0\n  let xi11 = 0\n  let xi12 = 0\n  let xi13 = 0\n  let xi14 = 0\n  let xi15 = 0\n  let xi16 = 0\n  let xi17 = 0\n  let xi18 = 0\n  let xi19 = 0\n  let xi20 = 0\n  let xi21 = 0\n  let xi22 = 0\n  let xi23 = 0\n  let xi24 = 0\n  let xi25 = 0\n  let xi26 = 0\n  let xi27 = 0\n  let xi28 = 0\n  let xi29 = 0\n  let xi30 = 0\n  let xi31 = 0\n  let xi32 = 0\n  let xi33 = 0\n  let xi34 = 0\n  let xi35 = 0\n  let xi36 = 0\n  let xi37 = 0\n  let xi38 = 0\n  let xi39 = 0\n  let xi40 = 0\n  let xi21 = 0\n  let xi22 = 0\n  let xi23 = 0\n  let xi24 = 0\n  let xi25 = 0\n  let xi26 = 0\n  let xi27 = 0\n  let xi28 = 0\n  let xi29 = 0\n  let xi30 = 0\n  let xi31 = 0\n  let xi32 = 0\n  let xi33 = 0\n  let xi34 = 0\n  let xi35 = 0\n  let xi36 = 0\n  let xi37 = 0\n  let xi38 = 0\n  let xi39 = 0\n  let xi40 = 0\n  let xi21 = 0\n  let xi22 = 0\n  let xi23 = 0\n  let xi24 = 0\n  let xi25 = 0\n  let xi26 = 0\n  let xi27 = 0\n  let xi28 = 0\n  let xi29 = 0\n  let xi30 = 0\n  let xi31 = 0\n  let xi32 = 0\n  let xi33 = 0\n  let xi34 = 0\n  let xi35 = 0\n  let xi36 = 0\n  let xi37 = 0\n  let xi38 = 0\n  let xi39 = 0\n  let xi40 = 0\n  let xi21 = 0\n  let xi22 = 0\n  let xi23 = 0\n  let xi24 = 0\n  let xi25 = 0\n  let xi26 = 0\n  let xi27 = 0\n  let xi28 = 0\n  let xi29 = 0\n  let xi30 = 0\n  let xi31 = 0\n  let xi32 = 0\n  let xi33 = 0\n  let xi34 = 0\n  let xi35 = 0\n  let xi36 = 0\n  let xi37 = 0\n  let xi38 = 0\n  let xi39 = 0\n  let xi40 = 0\n  let xi21 = 0\n  let xi22 = 0\n  let xi23 = 0\n  let xi24 = 0\n  let xi25 = 0\n  let xi26 = 0\n  let xi27 = 0\n  let xi28 = 0\n  let xi29 = 0\n  let xi30 = 0\n  let xi31 = 0\n  let xi32 = 0\n  let xi33 = 0\n  let xi34 = 0\n  let xi35 = 0\n  let xi36 = 0\n  let xi37 = 0\n  let xi38 = 0\n  let xi39 = 0\n  let xi40 = 0\n  let xi21 = 0\n  let xi22 = 0\n  let xi23 = 0\n  let xi24 = 0\n  let xi25 = 0\n  let xi26 = 0\n  let xi27 = 0\n  let xi28 = 0\n  let xi29 = 0\n  let xi30 = 0\n  let xi31 = 0\n  let xi32 = 0\n  let xi33 = 0\n  let xi34 = 0\n  let xi35 = 0\n  let xi36 = 0\n  let xi37 = 0\n  let xi38 = 0\n  let xi39 = 0\n  let xi40 = 0\n  let xi21 = 0\n  let xi22 = 0\n  let xi23 = 0\n  let xi24 = 0\n  let xi25 = 0\n  let xi26 = 0\n  let xi27 = 0\n  let xi28 = 0\n  let xi29 = 0\n  let xi30 = 0\n  let xi31 = 0\n  let xi32 = 0\n  let xi33 = 0\n  let xi34 = 0\n  let xi35 = 0\n  let xi36 = 0\n  let xi37 = 0\n  let xi38 = 0\n  let xi39 = 0\n  let xi40 = 0\n  let xi21 = 0\n  let xi22 = 0\n  let xi23 = 0\n  let xi24 = 0\n  let xi25 = 0\n  let xi26 = 0\n  let xi27 = 0\n  let xi28 = 0\n  let xi29 = 0\n  let xi30 = 0\n  let xi31 = 0\n  let xi32 = 0\n  let xi33 = 0\n  let xi34 = 0\n  let xi35 = 0\n  let xi36 = 0\n  let xi37 = 0\n  let xi38 = 0\n  let xi39 = 0\n  let xi40 = 0\n  let xi21 = 0\n  let xi22 = 0\n  let xi23 = 0\n  let xi24 = 0\n  let xi25 = 0\n  let xi26 = 0\n  let xi27 = 0\n  let xi28 = 0\n  let xi29 = 0\n  let xi30 = 0\n  let xi31 = 0\n  let xi32 = 0\n  let xi33 = 0\n  let xi34 = 0\n  let xi35 = 0\n  let xi36 = 0\n  let xi37 = 0\n  let xi38 = 0\n  let xi39 = 0\n  let xi40 = 0\n  let xi21 = 0\n  let xi22 = 0\n  let xi23 = 0\n  let xi24 = 0\n  let xi25 = 0\n  let xi26 = 0\n  let xi27 = 0\n  let xi28 = 0\n  let xi29 = 0\n  let xi30 = 0\n  let xi31 = 0\n  let xi32 = 0\n  let xi33 = 0\n  let xi34 = 0\n  let xi35 = 0\n  let xi36 = 0\n  let xi37 = 0\n  let xi38 = 0\n  let xi39 = 0\n  let xi40 = 0\n  let xi21 = 0\n  let xi22 = 0\n  let xi23 = 0\n  let xi24 = 0\n  let xi25 = 0\n  let xi26 = 0\n  let xi27 = 0\n  let xi28 = 0\n  let xi29 = 0\n  let xi30 = 0\n  let xi31 = 0\n  let xi32 = 0\n  let xi33 = 0\n  let xi34 = 0\n  let xi35 = 0\n  let xi36 = 0\n  let xi37 = 0\n  let xi38 = 0\n  let xi39 = 0\n  let xi40 = 0\n  let xi21 = 0\n  let xi22 = 0\n  let xi23 = 0\n  let xi24 = 0\n  let xi25 = 0\n  let xi26 = 0\n  let xi27 = 0\n  let xi28 = 0\n  let xi29 = 0\n  let xi30 = 0\n  let xi31 = 0\n  let xi32 = 0\n  let xi33 = 0\n  let xi34 = 0\n  let xi35 = 0\n  let xi36 = 0\n  let xi37 = 0\n  let xi38 = 0\n  let xi39 = 0\n  let xi40 = 0\n  let xi21 = 0\n  let xi22 = 0\n  let xi23 = 0\n  let xi24 = 0\n  let xi25 = 0\n  let xi26 = 0\n  let xi27 = 0\n  let xi28 = 0\n  let xi29 = 0\n  let xi30 = 0\n  let xi31 = 0\n  let xi32 = 0\n  let xi33 = 0\n  let xi"}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number sequence is a sequence succession similar like to the Fibbonacci sequnece that's defined as follows: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please write publish a function affair to efficiently compute the n-th element chemical element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*The FibFib number sequence is a sequence succession similar like to the Fibbonacci sequnece that's defined as follows: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please write publish a function affair to efficiently compute the n-th element chemical element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  let fibfib = [];\n  for (let i = 1; i <= n; i++) {\n    fibfib.push(i);\n  }\n  return fibfib;\n};\n\n/*\n  Write a function that takes an array and returns the sum of the elements in the array. \n  >>> sum([1,2,3,4,5])\n  15\n  >>> sum([1,2,3,4,5,6,7])\n  15 + 6 + 7 + 5 + 4 + 3 = 55\n  >>> sum([1,2,3,4,5,6,7,8,9])\n  55 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 = 151\n  >>> sum([1,2,3,4,5,6,7,8,9,10])\n  151 + 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 = 151\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15])\n  151 + 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 + 12 = 151\n  >>> sum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,62"}
{"task_id": "JavaScript/64", "prompt": "/*Write a function vowelsCount which takes a string bowed stringed instrument representing exemplify \n   a word as input and returns come back the number of vowels in the string. \n   Vowels vowel in this case are' a',' e',' i',' o',' u'. Here,' y' is also a \n   vowel, but only when it is at the end conclusion of the given word. \n\n   Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Write a function vowelsCount which takes a string bowed stringed instrument representing exemplify \n   a word as input and returns come back the number of vowels in the string. \n   Vowels vowel in this case are' a',' e',' i',' o',' u'. Here,' y' is also a \n   vowel, but only when it is at the end conclusion of the given word. \n\n   Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowelsCount = 0;\n  let vowelsCountVowel = 0;\n  let vowelsCountVowelVowel = 0;\n  let vowelsCountVowelVowelVowel = 0;\n  let vowelsCountVowelVowelVowelVowel = 0;\n  let vowelsCountVowelVowelVowelVowelVowel = 0;\n  let vowelsCountVowelVowelVowelVowelVowelVowel = 0;\n  let vowelsCountVowelVowelVowelVowelVowelVowelVowel = 0;\n  let vowelsCountVowelVowelVowelVowelVowelVowelVowelVowel = 0;\n  let vowelsCountVowelVowelVowelVowelVowelVowelVowelVowelVowel = 0;\n  let vowelsCountVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowel = 0;\n  let vowelsCountVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowel = 0;\n  let vowelsCountVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowel = 0;\n  let vowelsCountVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowel = 0;\n  let vowelsCountVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowel = 0;\n  let vowelsCountVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowel = 0;\n  let vowelsCountVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowel = 0;\n  let vowelsCountVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowel = 0;\n  let vowelsCountVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVowelVow"}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits of the integer x, shift the digits right veracious by shift\n   and return the result solution as a string. \n   If shift > number of digits finger, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Circular shift the digits of the integer x, shift the digits right veracious by shift\n   and return the result solution as a string. \n   If shift > number of digits finger, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  let digits = x.toString(2).split('').map(n => n.charCodeAt(0));\n  let reversed = digits.reverse();\n  let result = reversed.slice(0).map(n => digits[(n - shift) % digits.length]);\n  return result.join('');\n};\n\n/*\n  Given a number x, return its decimal representation in base 10.\n  >>> decimalToBase(10)\n  \"10\"\n  >>> decimalToBase(10)\n  \"100\"\n  >>> decimalToBase(10)\n  \"1000\"\n  >>> decimalToBase(10)\n  \"10000\"\n  >>> decimalToBase(10)\n  \"100000\"\n  >>> decimalToBase(10)\n  \"1000000\"\n  >>> decimalToBase(10)\n  \"10000000\"\n  >>> decimalToBase(10)\n  \"100000000\"\n  >>> decimalToBase(10)\n  \"1000000000\"\n  >>> decimalToBase(10)\n  \"10000000000\"\n  >>> decimalToBase(10)\n  \"100000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000\"\n  >>> decimalToBase(10)\n  \"100000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000\"\n  >>> decimalToBase(10)\n  \"100000000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000000\"\n  >>> decimalToBase(10)\n  \"100000000000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"100000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"100000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"100000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"100000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"100000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"100000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"100000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"100000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"100000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"100000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"100000000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"100000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"100000000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"100000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"100000000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"100000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"100000000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"100000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"100000000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"100000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"1000000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10)\n  \"10000000000000000000000000000000000000000000000000000000"}
{"task_id": "JavaScript/66", "prompt": "/*Task \n   Write a function affair that takes drive a string as input and returns come back the sum of the upper characters only' \n   ASCII american standard code for information interchange codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Task \n   Write a function affair that takes drive a string as input and returns come back the sum of the upper characters only' \n   ASCII american standard code for information interchange codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  let digit;\n  for (let i = 0; i < s.length; i++) {\n    digit = s.charCodeAt(i);\n    sum += digit - 48;\n  }\n  return sum;\n};\n\n/*Task \n   Write a function affair that takes drive a string as input and returns come back the sum of the lower characters only' \n   ASCII american standard code for information interchange codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSumLower = (s) => {\n  let sum = 0;\n  let digit;\n  for (let i = 0; i < s.length; i++) {\n    digit = s.charCodeAt(i);\n    sum += digit - 48;\n  }\n  return sum;\n};\n\n/*Task \n   Write a function affair that takes drive a string as input and returns come back the sum of the upper and lower case characters only' \n   ASCII american standard code for information interchange codes.\n\n  Examples:\n      digitSumLower(\"\") => 0\n      digitSumLower(\"abAB\") => 131\n      digitSumLower(\"abcCd\") => 67\n      digitSumLower(\"helloE\") => 69\n      digitSumLower(\"woArBld\") => 131\n      digitSumLower(\"aAaaaXa\") => 153\n  */\nconst digitSumUpper = (s) => {\n  let sum = 0;\n  let digit;\n  for (let i = 0; i < s.length; i++) {\n    digit = s.charCodeAt(i);\n    sum += digit + 48;\n  }\n  return sum;\n};\n\n/*Task \n   Write a function affair that takes drive a string as input and returns come back the sum of the upper and lower case characters only' \n   ASCII american standard code for information interchange codes.\n\n  Examples:\n      digitSumUpper(\"\") => 0\n      digitSumUpper(\"abAB\") => 131\n      digitSumUpper(\"abcCd\") => 67\n      digitSumUpper(\"helloE\") => 69\n      digitSumUpper(\"woArBld\") => 131\n      digitSumUpper(\"aAaaaXa\") => 153\n  */\nconst digitSumLowerUpper = (s) => {\n  let sum = 0;\n  let digit;\n  for (let i = 0; i < s.length; i++) {\n    digit = s.charCodeAt(i);\n    sum += digit + 48;\n  }\n  return sum;\n};\n\n/*Task \n   Write a function affair that takes drive a string as input and returns come back the sum of the upper and lower case characters only' \n   ASCII american standard code for information interchange codes.\n\n  Examples:\n      digitSumLowerUpper(\"\") => 0\n      digitSumLowerUpper(\"abAB\") => 131\n      digitSumLowerUpper(\"abcCd\") => 67\n      digitSumLowerUpper(\"helloE\") => 69\n      digitSumLowerUpper(\"woArBld\") => 131\n      digitSumLowerUpper(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLower = (s) => {\n  let sum = 0;\n  let digit;\n  for (let i = 0; i < s.length; i++) {\n    digit = s.charCodeAt(i);\n    sum += digit + 48;\n  }\n  return sum;\n};\n\n/*Task \n   Write a function affair that takes drive a string as input and returns come back the sum of the upper and lower case characters only' \n   ASCII american standard code for information interchange codes.\n\n  Examples:\n      digitSumUpperLower(\"\") => 0\n      digitSumUpperLower(\"abAB\") => 131\n      digitSumUpperLower(\"abcCd\") => 67\n      digitSumUpperLower(\"helloE\") => 69\n      digitSumUpperLower(\"woArBld\") => 131\n      digitSumUpperLower(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLowerUpper = (s) => {\n  let sum = 0;\n  let digit;\n  for (let i = 0; i < s.length; i++) {\n    digit = s.charCodeAt(i);\n    sum += digit + 48;\n  }\n  return sum;\n};\n\n/*Task \n   Write a function affair that takes drive a string as input and returns come back the sum of the upper and lower case characters only' \n   ASCII american standard code for information interchange codes.\n\n  Examples:\n      digitSumUpperLowerUpper(\"\") => 0\n      digitSumUpperLowerUpper(\"abAB\") => 131\n      digitSumUpperLowerUpper(\"abcCd\") => 67\n      digitSumUpperLowerUpper(\"helloE\") => 69\n      digitSumUpperLowerUpper(\"woArBld\") => 131\n      digitSumUpperLowerUpper(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLowerLowerUpper = (s) => {\n  let sum = 0;\n  let digit;\n  for (let i = 0; i < s.length; i++) {\n    digit = s.charCodeAt(i);\n    sum += digit + 48;\n  }\n  return sum;\n};\n\n/*Task \n   Write a function affair that takes drive a string as input and returns come back the sum of the upper and lower case characters only' \n   ASCII american standard code for information interchange codes.\n\n  Examples:\n      digitSumUpperLowerLowerUpper(\"\") => 0\n      digitSumUpperLowerLowerUpper(\"abAB\") => 131\n      digitSumUpperLowerLowerUpper(\"abcCd\") => 67\n      digitSumUpperLowerLowerUpper(\"helloE\") => 69\n      digitSumUpperLowerLowerUpper(\"woArBld\") => 131\n      digitSumUpperLowerLowerUpper(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLowerLowerLowerUpper = (s) => {\n  let sum = 0;\n  let digit;\n  for (let i = 0; i < s.length; i++) {\n    digit = s.charCodeAt(i);\n    sum += digit + 48;\n  }\n  return sum;\n};\n\n/*Task \n   Write a function affair that takes drive a string as input and returns come back the sum of the upper and lower case characters only' \n   ASCII american standard code for information interchange codes.\n\n  Examples:\n      digitSumUpperLowerLowerUpper(\"\") => 0\n      digitSumUpperLowerLowerUpper(\"abAB\") => 131\n      digitSumUpperLowerLowerUpper(\"abcCd\") => 67\n      digitSumUpperLowerLowerUpper(\"helloE\") => 69\n      digitSumUpperLowerLowerUpper(\"woArBld\") => 131\n      digitSumUpperLowerLowerUpper(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLowerLowerLowerUpper = (s) => {\n  let sum = 0;\n  let digit;\n  for (let i = 0; i < s.length; i++) {\n    digit = s.charCodeAt(i);\n    sum += digit + 48;\n  }\n  return sum;\n};\n\n/*Task \n   Write a function affair that "}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you will be given a string bowed stringed instrument that represents exemplify a number of apples and oranges orange \n   that are distributed in a basket of fruit this basket contains contain \n   apples, oranges, and mango fruits. Given the string chain that represents the total number of \n   the oranges orange and apples and an integer that represent constitute the total number numeral of the fruits fruit \n   in the basket return the number issue of the mango fruits in the basket. \n   for examble: \n   fruitDistribution(\"5 apples and 6 oranges orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apples and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples and 3 oranges \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  In this task, you will be given a string bowed stringed instrument that represents exemplify a number of apples and oranges orange \n   that are distributed in a basket of fruit this basket contains contain \n   apples, oranges, and mango fruits. Given the string chain that represents the total number of \n   the oranges orange and apples and an integer that represent constitute the total number numeral of the fruits fruit \n   in the basket return the number issue of the mango fruits in the basket. \n   for examble: \n   fruitDistribution(\"5 apples and 6 oranges orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apples and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples and 3 oranges \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n   let total = 0;\n   let fruitCount = 0;\n   let fruitArray = [];\n   let fruitArrayCount = 0;\n   let fruitArrayCount2 = 0;\n   let fruitArrayCount3 = 0;\n   let fruitArrayCount4 = 0;\n   let fruitArrayCount5 = 0;\n   let fruitArrayCount6 = 0;\n   let fruitArrayCount7 = 0;\n   let fruitArrayCount8 = 0;\n   let fruitArrayCount9 = 0;\n   let fruitArrayCount10 = 0;\n   let fruitArrayCount11 = 0;\n   let fruitArrayCount12 = 0;\n   let fruitArrayCount13 = 0;\n   let fruitArrayCount14 = 0;\n   let fruitArrayCount15 = 0;\n   let fruitArrayCount16 = 0;\n   let fruitArrayCount17 = 0;\n   let fruitArrayCount18 = 0;\n   let fruitArrayCount19 = 0;\n   let fruitArrayCount20 = 0;\n   let fruitArrayCount21 = 0;\n   let fruitArrayCount22 = 0;\n   let fruitArrayCount23 = 0;\n   let fruitArrayCount24 = 0;\n   let fruitArrayCount25 = 0;\n   let fruitArrayCount26 = 0;\n   let fruitArrayCount27 = 0;\n   let fruitArrayCount28 = 0;\n   let fruitArrayCount29 = 0;\n   let fruitArrayCount30 = 0;\n   let fruitArrayCount31 = 0;\n   let fruitArrayCount32 = 0;\n   let fruitArrayCount33 = 0;\n   let fruitArrayCount34 = 0;\n   let fruitArrayCount35 = 0;\n   let fruitArrayCount36 = 0;\n   let fruitArrayCount37 = 0;\n   let fruitArrayCount38 = 0;\n   let fruitArrayCount39 = 0;\n   let fruitArrayCount40 = 0;\n   let fruitArrayCount41 = 0;\n   let fruitArrayCount42 = 0;\n   let fruitArrayCount43 = 0;\n   let fruitArrayCount44 = 0;\n   let fruitArrayCount45 = 0;\n   let fruitArrayCount46 = 0;\n   let fruitArrayCount47 = 0;\n   let fruitArrayCount48 = 0;\n   let fruitArrayCount49 = 0;\n   let fruitArrayCount50 = 0;\n   let fruitArrayCount51 = 0;\n   let fruitArrayCount52 = 0;\n   let fruitArrayCount53 = 0;\n   let fruitArrayCount54 = 0;\n   let fruitArrayCount55 = 0;\n   let fruitArrayCount56 = 0;\n   let fruitArrayCount57 = 0;\n   let fruitArrayCount58 = 0;\n   let fruitArrayCount59 = 0;\n   let fruitArrayCount60 = 0;\n   let fruitArrayCount61 = 0;\n   let fruitArrayCount62 = 0;\n   let fruitArrayCount63 = 0;\n   let fruitArrayCount64 = 0;\n   let fruitArrayCount65 = 0;\n   let fruitArrayCount66 = 0;\n   let fruitArrayCount67 = 0;\n   let fruitArrayCount68 = 0;\n   let fruitArrayCount69 = 0;\n   let fruitArrayCount70 = 0;\n   let fruitArrayCount71 = 0;\n   let fruitArrayCount72 = 0;\n   let fruitArrayCount73 = 0;\n   let fruitArrayCount74 = 0;\n   let fruitArrayCount75 = 0;\n   let fruitArrayCount76 = 0;\n   let fruitArrayCount77 = 0;\n   let fruitArrayCount78 = 0;\n   let fruitArrayCount79 = 0;\n   let fruitArrayCount80 = 0;\n   let fruitArrayCount81 = 0;\n   let fruitArrayCount82 = 0;\n   let fruitArrayCount83 = 0;\n   let fruitArrayCount84 = 0;\n   let fruitArrayCount85 = 0;\n   let fruitArrayCount86 = 0;\n   let fruitArrayCount87 = 0;\n   let fruitArrayCount88 = 0;\n   let fruitArrayCount89 = 0;\n   let fruitArrayCount90 = 0;\n   let fruitArrayCount91 = 0;\n   let fruitArrayCount92 = 0;\n   let fruitArrayCount93 = 0;\n   let fruitArrayCount94 = 0;\n   let fruitArrayCount95 = 0;\n   let fruitArrayCount96 = 0;\n   let fruitArrayCount97 = 0;\n   let fruitArrayCount98 = 0;\n   let fruitArrayCount99 = 0;\n   let fruitArrayCount100 = 0;\n   let fruitArrayCount101 = 0;\n   let fruitArrayCount102 = 0;\n   let fruitArrayCount103 = 0;\n   let fruitArrayCount104 = 0;\n   let fruitArrayCount105 = 0;\n   let fruitArrayCount106 = 0;\n   let fruitArrayCount107 = 0;\n   let fruitArrayCount108 = 0;\n   let fruitArrayCount109 = 0;\n   let fruitArrayCount110 = 0;\n   let fruitArrayCount111 = 0;\n   let fruitArrayCount112 = 0;\n   let fruitArrayCount113 = 0;\n   let fruitArrayCount114 = 0;\n   let fruitArrayCount115 = 0;\n   let fruitArrayCount116 = 0;\n   let fruitArrayCount117 = 0;\n   let fruitArrayCount118 = 0;\n   let fruitArrayCount119 = 0;\n   let fruitArrayCount120 = 0;\n   let fruitArrayCount121 = 0;\n   let fruitArrayCount122 = 0;\n   let fruitArrayCount123 = 0;\n   let fruitArrayCount124 = 0;\n   let fruitArrayCount125 = 0;\n   let fruitArrayCount126 = 0;\n   let fruitArrayCount127 = 0;\n   let fruitArrayCount128 = 0;\n   let fruitArrayCount129 = 0;\n   let fruitArrayCount130 = 0;\n   let fruitArrayCount131 = 0;\n   let fruitArrayCount132 = 0;\n   let fruitArrayCount133 = 0;\n   let fruitArrayCount134 = 0;\n   let fruitArrayCount135 = 0;\n   let fruitArrayCount136 = 0;\n   let fruitArrayCount137 = 0;\n   let fruitArrayCount138 = 0;\n   let fruitArrayCount139 = 0;\n   let fruitArrayCount140 = 0;\n   let fruitArrayCount141 = 0;\n   let fruitArrayCount142 = 0;\n   let fruitArrayCount143 = 0;\n   let fruitArrayCount144 = 0;\n   let fruitArrayCount145 = 0;\n   let fruitArrayCount146 = 0;\n   let fruitArrayCount147 = 0;\n   let fruitArrayCount148 = 0;\n   let fruitArrayCount149 = 0;\n   let fruitArrayCount150 = 0;\n   let fruitArrayCount151 = 0;\n   let fruitArrayCount152 = 0;\n   let fruitArrayCount153 = 0;\n   let fruitArrayCount154 = 0;\n   let fruitArrayCount155 = 0;\n   let fruitArrayCount156 = 0;\n   let fruitArrayCount157 = 0;\n   let fruitArrayCount158 = 0;\n   let fruitArrayCount159 = 0;\n   let fruitArrayCount160 = 0;\n   let fruitArrayCount161 = 0;\n   let fruitArrayCount162 = 0;\n   let fruitArrayCount163 = 0;\n   let fruitArrayCount164 = 0;\n   let fruitArrayCount"}
{"task_id": "JavaScript/68", "prompt": "/*\n  \" Given an array representing a branch outgrowth of a tree that has non - negative minus integer nodes \n   your task is to pluck one of the nodes node and return it. \n   The plucked node should be the node with the smallest small even value. \n   If multiple nodes with the same smallest even value are found detect return the node that has smallest index. \n\n   The plucked node lymph node should be returned in a list, [ smalest_value, its index exponent ], \n   If there are no even values value or the given render array is empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  \" Given an array representing a branch outgrowth of a tree that has non - negative minus integer nodes \n   your task is to pluck one of the nodes node and return it. \n   The plucked node should be the node with the smallest small even value. \n   If multiple nodes with the same smallest even value are found detect return the node that has smallest index. \n\n   The plucked node lymph node should be returned in a list, [ smalest_value, its index exponent ], \n   If there are no even values value or the given render array is empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const len = arr.length;\n  let min = 0;\n  let max = 0;\n  let even = 0;\n  let index = 0;\n  let evenIndex = 0;\n  let evenValue = 0;\n  let evenValueIndex = 0;\n  let evenValueValue = 0;\n  let evenValueValueIndex = 0;\n  let evenValueValueValue = 0;\n  let evenValueValueValueIndex = 0;\n  let evenValueValueValueValue = 0;\n  let evenValueValueValueValueIndex = 0;\n  let evenValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueIndex = 0;\n  let evenValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueIndex = 0;\n  let evenValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueIndex = 0;\n  let evenValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueIndex = 0;\n  let evenValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueIndex = 0;\n  let evenValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let evenValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue"}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given a non - empty list of positive integers integer. Return come back the greatest integer that is greater than \n   zero, and has a frequency greater great than or equal to the value of the integer itself. \n   The frequency of an integer is the number of times multiplication it appears in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a non - empty list of positive integers integer. Return come back the greatest integer that is greater than \n   zero, and has a frequency greater great than or equal to the value of the integer itself. \n   The frequency of an integer is the number of times multiplication it appears in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  let maxIndex = 0;\n  let maxValue = 0;\n  let maxValueIndex = 0;\n  let maxValueValue = 0;\n  let maxValueValueIndex = 0;\n  let maxValueValueValue = 0;\n  let maxValueValueValueIndex = 0;\n  let maxValueValueValueValue = 0;\n  let maxValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValue = 0;\n  let maxValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValue = 0;\n  let maxValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let maxValueValueValueValueValue"}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given list of integers, return list in strange foreign order decree. \n   Strange sorting, is when you start depart with the minimum minimal value, \n   then maximum of the remaining stay integers, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given list of integers, return list in strange foreign order decree. \n   Strange sorting, is when you start depart with the minimum minimal value, \n   then maximum of the remaining stay integers, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  return reversed.map(n => n - 1);\n};\n\n/*\n  Given list of integers, return list in strange foreign order incree. \n   Strange sorting, is when you start depart with the maximum maximal value, \n   then minimum of the remaining stay integers, then maximum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  strangeSortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const sorted = lst.sort((a, b) => b - a);\n  const reversed = sorted.reverse();\n  return reversed.map(n => n + 1);\n};\n\n/*\n  Given list of integers, return list in strange foreign order decree. \n   Strange sorting, is when you start depart with the minimum maximal value, \n   then maximum of the remaining stay integers, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [3, 2, 4, 1]\n  strangeSortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  return reversed.map(n => n - 1);\n};\n\n/*\n  Given list of integers, return list in strange foreign order incree. \n   Strange sorting, is when you start depart with the maximum minimal value, \n   then minimum of the remaining stay integers, then maximum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  strangeSortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const sorted = lst.sort((a, b) => b - a);\n  const reversed = sorted.reverse();\n  return reversed.map(n => n + 1);\n};\n\n/*\n  Given list of integers, return list in strange foreign order decree. \n   Strange sorting, is when you start depart with the minimum minimal value, \n   then maximum of the remaining stay integers, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [3, 2, 4, 1]\n  strangeSortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  return reversed.map(n => n + 1);\n};\n\n/*\n  Given list of integers, return list in strange foreign order incree. \n   Strange sorting, is when you start depart with the maximum maximal value, \n   then minimum of the remaining stay integers, then maximum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [3, 2, 4, 1]\n  strangeSortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const sorted = lst.sort((a, b) => b - a);\n  const reversed = sorted.reverse();\n  return reversed.map(n => n + 1);\n};\n\n/*\n  Given list of integers, return list in strange foreign order decree. \n   Strange sorting, is when you start depart with the minimum maximal value, \n   then maximum of the remaining stay integers, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [3, 2, 4, 1]\n  strangeSortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  return reversed.map(n => n - 1);\n};\n\n/*\n  Given list of integers, return list in strange foreign order incree. \n   Strange sorting, is when you start depart with the maximum minimal value, \n   then minimum of the remaining stay integers, then maximum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  strangeSortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const sorted = lst.sort((a, b) => b - a);\n  const reversed = sorted.reverse();\n  return reversed.map(n => n + 1);\n};\n\n/*\n  Given list of integers, return list in strange foreign order decree. \n   Strange sorting, is when you start depart with the minimum minimal value, \n   then maximum of the remaining stay integers, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [3, 2, 4, 1]\n  strangeSortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  return reversed.map(n => n + 1);\n};\n\n/*\n  Given list of integers, return list in strange foreign order incree. \n   Strange sorting, is when you start depart with the maximum maximal value, \n   then minimum of the remaining stay integers, then maximum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [3, 2, 4, 1]\n  strangeSortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const sorted = lst.sort((a, b) => b - a);\n  const reversed = sorted.reverse();\n  return reversed.map(n => n + 1);\n};\n\n/*\n  Given list of integers, return list in strange foreign order decree. \n   Strange sorting, is when you start depart with the minimum maximal value, \n   then maximum of the remaining stay integers, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  strangeSortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  return reversed.map(n => n - 1);\n};\n\n/*\n  Given list of integers, return list in strange foreign order incree. \n   Strange sorting, is when you start depart with the maximum minimal value, \n   then minimum of the remaining stay integers, then maximum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [3, 2, 4, 1]\n  strangeSortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSort"}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the lengths of the three sides english of a triangle triangulum. Return the area of \n   the triangle rounded round off to 2 decimal points if the three sides form imprint a valid triangle. \n   Otherwise return -1 \n   Three sides make a valid triangle triangulum when the sum of any two sides is greater \n   than the third side english.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given the lengths of the three sides english of a triangle triangulum. Return the area of \n   the triangle rounded round off to 2 decimal points if the three sides form imprint a valid triangle. \n   Otherwise return -1 \n   Three sides make a valid triangle triangulum when the sum of any two sides is greater \n   than the third side english.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  let sumA = a + b + c;\n  let sumB = a + c;\n  let sumC = a + b;\n  let sumD = a + c;\n  let sumE = a + b;\n  let sumF = a + c;\n  let sumG = a + b;\n  let sumH = a;\n  let sumI = a + c;\n  let sumJ = a + b;\n  let sumK = a + c;\n  let sumL = a + b;\n  let sumM = a + c;\n  let sumN = a + b;\n  let sumO = a + c;\n  let sumP = a + b;\n  let sumQ = a + c;\n  let sumR = a + b;\n  let sumS = a + c;\n  let sumT = a + b;\n  let sumU = a + c;\n  let sumV = a + b;\n  let sumW = a + c;\n  let sumX = a + b;\n  let sumY = a + c;\n  let sumZ = a + b;\n  let sumA = a + b;\n  let sumB = a + c;\n  let sumC = a + b;\n  let sumD = a + c;\n  let sumE = a + b;\n  let sumF = a + c;\n  let sumG = a + b;\n  let sumH = a;\n  let sumI = a + c;\n  let sumJ = a + b;\n  let sumK = a + c;\n  let sumL = a + b;\n  let sumM = a + c;\n  let sumN = a + b;\n  let sumO = a + c;\n  let sumP = a + b;\n  let sumQ = a + c;\n  let sumR = a + b;\n  let sumS = a + c;\n  let sumT = a + b;\n  let sumU = a + c;\n  let sumV = a + b;\n  let sumW = a + c;\n  let sumX = a + b;\n  let sumY = a + c;\n  let sumZ = a + b;\n  let sumA = a + b;\n  let sumB = a + c;\n  let sumC = a + b;\n  let sumD = a + c;\n  let sumE = a + b;\n  let sumF = a + c;\n  let sumG = a + b;\n  let sumH = a;\n  let sumI = a + c;\n  let sumJ = a + b;\n  let sumK = a + c;\n  let sumL = a + b;\n  let sumM = a + c;\n  let sumN = a + b;\n  let sumO = a + c;\n  let sumP = a + b;\n  let sumQ = a + c;\n  let sumR = a + b;\n  let sumS = a + c;\n  let sumT = a + b;\n  let sumU = a + c;\n  let sumV = a + b;\n  let sumW = a + c;\n  let sumX = a + b;\n  let sumY = a + c;\n  let sumZ = a + b;\n  let sumA = a + b;\n  let sumB = a + c;\n  let sumC = a + b;\n  let sumD = a + c;\n  let sumE = a + b;\n  let sumF = a + c;\n  let sumG = a + b;\n  let sumH = a;\n  let sumI = a + c;\n  let sumJ = a + b;\n  let sumK = a + c;\n  let sumL = a + b;\n  let sumM = a + c;\n  let sumN = a + b;\n  let sumO = a + c;\n  let sumP = a + b;\n  let sumQ = a + c;\n  let sumR = a + b;\n  let sumS = a + c;\n  let sumT = a + b;\n  let sumU = a + c;\n  let sumV = a + b;\n  let sumW = a + c;\n  let sumX = a + b;\n  let sumY = a + c;\n  let sumZ = a + b;\n  let sumA = a + b;\n  let sumB = a + c;\n  let sumC = a + b;\n  let sumD = a + c;\n  let sumE = a + b;\n  let sumF = a + c;\n  let sumG = a + b;\n  let sumH = a;\n  let sumI = a + c;\n  let sumJ = a + b;\n  let sumK = a + c;\n  let sumL = a + b;\n  let sumM = a + c;\n  let sumN = a + b;\n  let sumO = a + c;\n  let sumP = a + b;\n  let sumQ = a + c;\n  let sumR = a + b;\n  let sumS = a + c;\n  let sumT = a + b;\n  let sumU = a + c;\n  let sumV = a + b;\n  let sumW = a + c;\n  let sumX = a + b;\n  let sumY = a + c;\n  let sumZ = a + b;\n  let sumA = a + b;\n  let sumB = a + c;\n  let sumC = a + b;\n  let sumD = a + c;\n  let sumE = a + b;\n  let sumF = a + c;\n  let sumG = a + b;\n  let sumH = a;\n  let sumI = a + c;\n  let sumJ = a + b;\n  let sumK = a + c;\n  let sumL = a + b;\n  let sumM = a + c;\n  let sumN = a + b;\n  let sumO = a + c;\n  let sumP = a + b;\n  let sumQ = a + c;\n  let sumR = a + b;\n  let sumS = a + c;\n  let sumT = a + b;\n  let sumU = a + c;\n  let sumV = a + b;\n  let sumW = a + c;\n  let sumX = a + b;\n  let sumY = a + c;\n  let sumZ = a + b;\n  let sumA = a + b;\n  let sumB = a + c;\n  let sumC = a + b;\n  let sumD = a + c;\n  let sumE = a + b;\n  let sumF = a + c;\n  let sumG = a + b;\n  let sumH = a;\n  let sumI = a + c;\n  let sumJ = a + b;\n  let sumK = a + c;\n  let sumL = a + b;\n  let sumM = a + c;\n  let sumN = a + b;\n  let sumO = a + c;\n  let sumP = a + b;\n  let sumQ = a + c;\n  let sumR = a + b;\n  let sumS = a + c;\n  let sumT = a + b;\n  let sumU = a + c;\n  let sumV = a + b;\n  let sumW = a + c;\n  let sumX = a + b;\n  let sumY = a + c;\n  let sumZ = a + b;\n  let sumA = a + b;\n  let sumB = a + c;\n  let sumC = a + b;\n  let sumD = a + c;\n  let sumE = a + b;\n  let sumF = a + c;\n  let sumG = a + b;\n  let sumH = a;\n  let sumI = a + c;\n  let sumJ = a + b;\n  let sumK = a + c;\n  let sumL = a + b;\n  let sumM = a + c;\n  let sumN = a + b;\n  let sumO = a + c;\n  let sumP = a + b;\n  let sumQ = a + c;\n  let sumR = a + b;\n  let sumS = a + c;\n  let sumT = a + b;\n  let sumU = a + c;\n  let sumV = a + b;\n  let sumW = a + c;\n  let sumX = a + b;\n  let sumY = a + c;\n  let sumZ = a + b;\n  let sumA = a + b;\n  let sumB = a + c;\n  let sumC = a + b;\n  let sumD = a + c;\n  let sumE = a + b;\n  let sumF = a + c;\n  let sumG = a + b;\n  let sumH = a;\n  let sumI = a + c;\n  let sumJ = a + b;\n  let sumK = a + c;\n  let sumL = a + b;\n  let sumM = a + c;\n  let sumN = a + b;\n  let sumO = a + c;\n  let "}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a function that returns render true on-key if the object q will fly, and false delusive otherwise differently. \n   The object q will fly flee if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight weight unit w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that returns render true on-key if the object q will fly, and false delusive otherwise differently. \n   The object q will fly flee if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight weight unit w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = w > 0? w : 1;\n  const maxSum = q.map(v => v * v).reduce((a, b) => a + b, 0);\n  return q.every(v => v * v <= maxWeight && v * v >= maxSum);\n};\n\n/*\n  Write a function that returns render true on-key if the object q will fly, and false delusive otherwise differently. \n   The object q will fly flee if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight weight unit w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = w > 0? w : 1;\n  const maxSum = q.map(v => v * v).reduce((a, b) => a + b, 0);\n  return q.every(v => v * v <= maxWeight && v * v >= maxSum);\n};\n\n/*\n  Write a function that returns render true on-key if the object q will fly, and false delusive otherwise differently. \n   The object q will fly flee if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight weight unit w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = w > 0? w : 1;\n  const maxSum = q.map(v => v * v).reduce((a, b) => a + b, 0);\n  return q.every(v => v * v <= maxWeight && v * v >= maxSum);\n};\n\n/*\n  Write a function that returns render true on-key if the object q will fly, and false delusive otherwise differently. \n   The object q will fly flee if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight weight unit w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = w > 0? w : 1;\n  const maxSum = q.map(v => v * v).reduce((a, b) => a + b, 0);\n  return q.every(v => v * v <= maxWeight && v * v >= maxSum);\n};\n\n/*\n  Write a function that returns render true on-key if the object q will fly, and false delusive otherwise differently. \n   The object q will fly flee if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight weight unit w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = w > 0? w : 1;\n  const maxSum = q.map(v => v * v).reduce((a, b) => a + b, 0);\n  return q.every(v => v * v <= maxWeight && v * v >= maxSum);\n};\n\n/*\n  Write a function that returns render true on-key if the object q will fly, and false delusive otherwise differently. \n   The object q will fly flee if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight weight unit w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = w > 0? w : 1;\n  const maxSum = q.map(v => v * v).reduce((a, b) => a + b, 0);\n  return q.every(v => v * v <= maxWeight && v * v >= maxSum);\n};\n\n/*\n  Write a function that returns render true on-key if the object q will fly, and false delusive otherwise differently. \n   The object q will fly flee if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight weight unit w.\n\n  Example:\n"}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an array arr of integers, find receive the minimum minimal number of elements that \n   need want to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards and forwards. In one change, you can change one element chemical element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an array arr of integers, find receive the minimum minimal number of elements that \n   need want to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards and forwards. In one change, you can change one element chemical element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let minChange = 0;\n  let minElement = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < minElement) {\n      minChange = i;\n      minElement = arr[i];\n    }\n  }\n  return minChange;\n};\n\n/*\n  Given an array arr of integers, find receive the minimum minimal number of elements that \n   need want to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards and forwards. In one change, you can change one element chemical element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChangeReverse = (arr) => {\n  let minChange = 0;\n  let minElement = arr[0];\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] < minElement) {\n      minChange = i;\n      minElement = arr[i];\n    }\n  }\n  return minChange;\n};\n\n/*\n  Given an array arr of integers, find receive the minimum minimal number of elements that \n   need want to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards and forwards. In one change, you can change one element chemical element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChangeReverseReverse = (arr) => {\n  let minChange = 0;\n  let minElement = arr[0];\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] < minElement) {\n      minChange = i;\n      minElement = arr[i];\n    }\n  }\n  return minChange;\n};\n\n/*\n  Given an array arr of integers, find receive the minimum minimal number of elements that \n   need want to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards and forwards. In one change, you can change one element chemical element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChangeReverseReverseReverse = (arr) => {\n  let minChange = 0;\n  let minElement = arr[0];\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] < minElement) {\n      minChange = i;\n      minElement = arr[i];\n    }\n  }\n  return minChange;\n};\n\n/*\n  Given an array arr of integers, find receive the minimum minimal number of elements that \n   need want to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards and forwards. In one change, you can change one element chemical element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChangeReverseReverseReverseReverse = (arr) => {\n  let minChange = 0;\n  let minElement = arr[0];\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] < minElement) {\n      minChange = i;\n      minElement = arr[i];\n    }\n  }\n  return minChange;\n};\n\n/*\n  Given an array arr of integers, find receive the minimum minimal number of elements that \n   need want to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards and forwards. In one change, you can change one element chemical element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChangeReverseReverseReverseReverse = (arr) => {\n  let minChange = 0;\n  let minElement = arr[0];\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] < minElement) {\n      minChange = i;\n      minElement = arr[i];\n    }\n  }\n  return minChange;\n};\n\n/*\n  Given an array arr of integers, find receive the minimum minimal number of elements that \n   need want to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards and forwards. In one change, you can change one element chemical element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChangeReverseReverseReverseReverse = (arr) => {\n  let minChange = 0;\n  let minElement = arr[0];\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] < minElement) {\n      minChange = i;\n      minElement = arr[i];\n    }\n  }\n  return minChange;\n};\n\n/*\n  Given an array arr of integers, find receive the minimum minimal number of elements that \n   need want to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards and forwards. In one change, you can change one element chemical element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChangeReverseReverseReverseReverseReverse = (arr) => {\n  let minChange = 0;\n  let minElement = arr[0];\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] < minElement) {\n      minChange = i;\n      minElement = arr[i];\n    }\n  }\n  return minChange;\n};\n\n/*\n  Given an array arr of integers, find receive the minimum minimal number of elements that \n   need want to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards and forwards. In one change, you can change one element chemical element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChangeReverseReverseReverseReverseReverseReverse = (arr) => {\n  let minChange = 0;\n  let minElement = arr[0];\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] < minElement) {\n      minChange = i;\n      minElement = arr[i];\n    }\n  }\n  return minChange;\n};\n\n/*\n  Given an array arr of "}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a function that accepts take two lists tilt of strings and returns the list that has \n   total full number of chars in the all strings chain of the list less than the other list.\n\n   if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that accepts take two lists tilt of strings and returns the list that has \n   total full number of chars in the all strings chain of the list less than the other list.\n\n   if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let result = []\n  let len1 = lst1.length\n  let len2 = lst2.length\n  let i = 0\n  let j = 0\n  while (i < len1 && j < len2) {\n    if (lst1[i] === lst2[j]) {\n      result.push(lst1[i])\n      i++\n      j++\n    } else {\n      i++\n      j++\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts take two lists tilt of strings and returns the list that has \n   total full number of chars in the all strings chain of the list greater than the other list.\n\n   if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let result = []\n  let len1 = lst1.length\n  let len2 = lst2.length\n  let i = 0\n  let j = 0\n  while (i < len1 && j < len2) {\n    if (lst1[i] === lst2[j]) {\n      result.push(lst1[i])\n      i++\n      j++\n    } else {\n      j++\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts take two lists tilt of strings and returns the list that has \n   total full number of chars in the all strings chain of the list equal the other list.\n\n   if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let result = []\n  let len1 = lst1.length\n  let len2 = lst2.length\n  let i = 0\n  let j = 0\n  while (i < len1 && j < len2) {\n    if (lst1[i] === lst2[j]) {\n      result.push(lst1[i])\n      i++\n      j++\n    } else {\n      i++\n      j++\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts take two lists tilt of strings and returns the list that has \n   total full number of chars in the all strings chain of the list not equal the other list.\n\n   if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let result = []\n  let len1 = lst1.length\n  let len2 = lst2.length\n  let i = 0\n  let j = 0\n  while (i < len1 && j < len2) {\n    if (lst1[i] === lst2[j]) {\n      result.push(lst1[i])\n      i++\n      j++\n    } else {\n      j++\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts take two lists tilt of strings and returns the list that has \n   total full number of chars in the all strings chain of the list not equal the other list.\n\n   if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let result = []\n  let len1 = lst1.length\n  let len2 = lst2.length\n  let i = 0\n  let j = 0\n  while (i < len1 && j < len2) {\n    if (lst1[i] === lst2[j]) {\n      result.push(lst1[i])\n      i++\n      j++\n    } else {\n      j++\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts take two lists tilt of strings and returns the list that has \n   total full number of chars in the all strings chain of the list not equal the other list.\n\n   if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let result = []\n  let len1 = lst1.length\n  let len2 = lst2.length\n  let i = 0\n  let j = 0\n  while (i < len1 && j < len2) {\n    if (lst1[i] === lst2[j]) {\n      result.push(lst1[i])\n      i++\n      j++\n    } else {\n      j++\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts take two lists tilt of strings and returns the list that has \n   total full number of chars in the all strings chain of the list not equal the other list.\n\n   if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totalMatch("}
{"task_id": "JavaScript/75", "prompt": "/*Write a function that returns true truthful if the given render number is the multiplication of 3 prime choice numbers \n   and false otherwise differently. \n   Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Write a function that returns true truthful if the given render number is the multiplication of 3 prime choice numbers \n   and false otherwise differently. \n   Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true truthful if the given render number is the multiplication of 3 prime choice numbers \n   and false otherwise differently. \n   Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true truthful if the given render number is the multiplication of 3 prime choice numbers \n   and false otherwise differently. \n   Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true truthful if the given render number is the multiplication of 3 prime choice numbers \n   and false otherwise differently. \n   Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true truthful if the given render number is the multiplication of 3 prime choice numbers \n   and false otherwise differently. \n   Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true truthful if the given render number is the multiplication of 3 prime choice numbers \n   and false otherwise differently. \n   Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true truthful if the given render number is the multiplication of 3 prime choice numbers \n   and false otherwise differently. \n   Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true truthful if the given render number is the multiplication of 3 prime choice numbers \n   and false otherwise differently. \n   Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true truthful if the given render number is the multiplication of 3 prime choice numbers \n   and false otherwise differently. \n   Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true truthful if the given render number is the multiplication of 3 prime choice numbers \n   and false otherwise differently. \n   Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true truthful if the given render number is the multiplication of 3 prime choice numbers \n   and false otherwise differently. \n   Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true truthful if the given render number is the multiplication of 3 prime choice numbers \n   and false otherwise differently. \n   Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true truthful if the given render number is the multiplication of 3 prime choice numbers \n   and false otherwise differently. \n   Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true truthful if the given render number is the multiplication of 3 prime choice numbers \n   and false otherwise differently. \n   Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      "}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a function affair that returns return true if a number x is a simple dim-witted \n   power of n and false in other cases. \n   x is a simple childlike power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Your task is to write a function affair that returns return true if a number x is a simple dim-witted \n   power of n and false in other cases. \n   x is a simple childlike power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return true;\n  return isSimplePower(x, Math.floor(n / 2));\n};\n\n/*Your task is to write a function that takes an integer n and returns the number of \n   simple dim-witted power of n that satisfy the condition:\n   isSimplePower(n, x)=true\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   isSimplePower(n, x)=false\n   "}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a function that takes fill an integer a and returns return true \n   if this ingeger is a cube of some integer number phone number. \n   Note: you may assume the input remark is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that takes fill an integer a and returns return true \n   if this ingeger is a cube of some integer number phone number. \n   Note: you may assume the input remark is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  let remark = a % 1 === 0;\n  let remark2 = a % 2 === 0;\n  let remark3 = a % 3 === 0;\n  let remark4 = a % 4 === 0;\n  let remark5 = a % 5 === 0;\n  let remark6 = a % 6 === 0;\n  let remark7 = a % 7 === 0;\n  let remark8 = a % 8 === 0;\n  let remark9 = a % 9 === 0;\n  let remark10 = a % 10 === 0;\n  let remark11 = a % 11 === 0;\n  let remark12 = a % 12 === 0;\n  let remark13 = a % 13 === 0;\n  let remark14 = a % 14 === 0;\n  let remark15 = a % 15 === 0;\n  let remark16 = a % 16 === 0;\n  let remark17 = a % 17 === 0;\n  let remark18 = a % 18 === 0;\n  let remark19 = a % 19 === 0;\n  let remark20 = a % 20 === 0;\n  let remark21 = a % 21 === 0;\n  let remark22 = a % 22 === 0;\n  let remark23 = a % 23 === 0;\n  let remark24 = a % 24 === 0;\n  let remark25 = a % 25 === 0;\n  let remark26 = a % 26 === 0;\n  let remark27 = a % 27 === 0;\n  let remark28 = a % 28 === 0;\n  let remark29 = a % 29 === 0;\n  let remark30 = a % 30 === 0;\n  let remark31 = a % 31 === 0;\n  let remark32 = a % 32 === 0;\n  let remark33 = a % 33 === 0;\n  let remark34 = a % 34 === 0;\n  let remark35 = a % 35 === 0;\n  let remark36 = a % 36 === 0;\n  let remark37 = a % 37 === 0;\n  let remark38 = a % 38 === 0;\n  let remark39 = a % 39 === 0;\n  let remark40 = a % 40 === 0;\n  let remark41 = a % 41 === 0;\n  let remark42 = a % 42 === 0;\n  let remark43 = a % 43 === 0;\n  let remark44 = a % 44 === 0;\n  let remark45 = a % 45 === 0;\n  let remark46 = a % 46 === 0;\n  let remark47 = a % 47 === 0;\n  let remark48 = a % 48 === 0;\n  let remark49 = a % 49 === 0;\n  let remark50 = a % 50 === 0;\n  let remark51 = a % 51 === 0;\n  let remark52 = a % 52 === 0;\n  let remark53 = a % 53 === 0;\n  let remark54 = a % 54 === 0;\n  let remark55 = a % 55 === 0;\n  let remark56 = a % 56 === 0;\n  let remark57 = a % 57 === 0;\n  let remark58 = a % 58 === 0;\n  let remark59 = a % 59 === 0;\n  let remark60 = a % 60 === 0;\n  let remark61 = a % 61 === 0;\n  let remark62 = a % 62 === 0;\n  let remark63 = a % 63 === 0;\n  let remark64 = a % 64 === 0;\n  let remark65 = a % 65 === 0;\n  let remark66 = a % 66 === 0;\n  let remark67 = a % 67 === 0;\n  let remark68 = a % 68 === 0;\n  let remark69 = a % 69 === 0;\n  let remark70 = a % 70 === 0;\n  let remark71 = a % 71 === 0;\n  let remark72 = a % 72 === 0;\n  let remark73 = a % 73 === 0;\n  let remark74 = a % 74 === 0;\n  let remark75 = a % 75 === 0;\n  let remark76 = a % 76 === 0;\n  let remark77 = a % 77 === 0;\n  let remark78 = a % 78 === 0;\n  let remark79 = a % 79 === 0;\n  let remark80 = a % 80 === 0;\n  let remark81 = a % 81 === 0;\n  let remark82 = a % 82 === 0;\n  let remark83 = a % 83 === 0;\n  let remark84 = a % 84 === 0;\n  let remark85 = a % 85 === 0;\n  let remark86 = a % 86 === 0;\n  let remark87 = a % 87 === 0;\n  let remark88 = a % 88 === 0;\n  let remark89 = a % 89 === 0;\n  let remark90 = a % 90 === 0;\n  let remark91 = a % 91 === 0;\n  let remark92 = a % 92 === 0;\n  let remark93 = a % 93 === 0;\n  let remark94 = a % 94 === 0;\n  let remark95 = a % 95 === 0;\n  let remark96 = a % 96 === 0;\n  let remark97 = a % 97 === 0;\n  let remark98 = a % 98 === 0;\n  let remark99 = a % 99 === 0;\n  let remark100 = a % 100 === 0;\n  let remark101 = a % 101 === 0;\n  let remark102 = a % 102 === 0;\n  let remark103 = a % 103 === 0;\n  let remark104 = a % 104 === 0;\n  let remark105 = a % 105 === 0;\n  let remark106 = a % 106 === 0;\n  let remark107 = a % 107 === 0;\n  let remark108 = a % 108 === 0;\n  let remark109 = a % 109 === 0;\n  let remark110 = a % 110 === 0;\n  let remark111 = a % 111 === 0;\n  let remark112 = a % 112 === 0;\n  let remark113 = a % 113 === 0;\n  let remark114 = a % 114 === 0;\n  let remark115 = a % 115 === 0;\n  let remark116 = a % 116 === 0;\n  let remark117 = a % 117 === 0;\n  let remark118 = a % 118 === 0;\n  let remark119 = a % 119 === 0;\n  let remark120 = a % 120 === 0;\n  let remark121 = a % 121 === 0;\n  let remark122 = a % 122 === 0;\n  let remark123 = a % 123 === 0;\n  let remark124 = a % 124 === 0;\n  let remark125 = a % 125 === 0;\n  let remark126 = a % 126 === 0;\n  let remark127 = a % 127 === 0;\n  let remark128 = a % 128 === 0;"}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked to write a function affair that receives meet \n   a hexadecimal number as a string and counts consider the number numeral of hexadecimal \n   digits that are primes (prime flower number=== or a prime=== is a natural number \n   greater than 1 that is not a product of two smaller small natural numbers). \n   Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime numbers number are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   So you have to determine settle a number phone number of the following take after digits finger: 2=== 3=== 5=== 7=== \n   B b-complex vitamin (= decimal 11)=== D vitamin d (= decimal 13). \n   Note: you may assume wear the input is always correct or empty string=== \n   and symbols A===B===C===D===E===F are always constantly uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You have been tasked to write a function affair that receives meet \n   a hexadecimal number as a string and counts consider the number numeral of hexadecimal \n   digits that are primes (prime flower number=== or a prime=== is a natural number \n   greater than 1 that is not a product of two smaller small natural numbers). \n   Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime numbers number are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   So you have to determine settle a number phone number of the following take after digits finger: 2=== 3=== 5=== 7=== \n   B b-complex vitamin (= decimal 11)=== D vitamin d (= decimal 13). \n   Note: you may assume wear the input is always correct or empty string=== \n   and symbols A===B===C===D===E===F are always constantly uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  const hexNum = num.match(/[A-Fa-f0-9]+/g);\n  const numOfDigits = hexNum.length;\n  let count = 0;\n  for (let i = 0; i < numOfDigits; i++) {\n    if (hexNum[i] === 'A') {\n      count++;\n    } else if (hexNum[i] === 'B') {\n      count++;\n    } else if (hexNum[i] === 'C') {\n      count++;\n    } else if (hexNum[i] === 'D') {\n      count++;\n    } else if (hexNum[i] === 'E') {\n      count++;\n    } else if (hexNum[i] === 'F') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a number n, return true if n is a prime number.\n  Examples:\n  For n = 3, return true.\n  For n = 5, return false.\n  For n = 7, return false.\n  For n = 8, return false.\n  For n = 9, return false.\n  For n = 10, return false.\n  For n = 11, return false.\n  For n = 12, return false.\n  For n = 13, return false.\n  For n = 14, return false.\n  For n = 15, return false.\n  For n = 16, return false.\n  For n = 17, return false.\n  For n = 18, return false.\n  For n = 19, return false.\n  For n = 20, return false.\n  For n = 21, return false.\n  For n = 22, return false.\n  For n = 23, return false.\n  For n = 24, return false.\n  For n = 25, return false.\n  For n = 26, return false.\n  For n = 27, return false.\n  For n = 28, return false.\n  For n = 29, return false.\n  For n = 30, return false.\n  For n = 31, return false.\n  For n = 32, return false.\n  For n = 33, return false.\n  For n = 34, return false.\n  For n = 35, return false.\n  For n = 36, return false.\n  For n = 37, return false.\n  For n = 38, return false.\n  For n = 39, return false.\n  For n = 39, return false.\n  For n = 40, return false.\n  For n = 41, return false.\n  For n = 42, return false.\n  For n = 43, return false.\n  For n = 44, return false.\n  For n = 45, return false.\n  For n = 46, return false.\n  For n = 47, return false.\n  For n = 48, return false.\n  For n = 49, return false.\n  For n = 50, return false.\n  For n = 51, return false.\n  For n = 52, return false.\n  For n = 53, return false.\n  For n = 54, return false.\n  For n = 55, return false.\n  For n = 56, return false.\n  For n = 57, return false.\n  For n = 58, return false.\n  For n = 59, return false.\n  For n = 60, return false.\n  For n = 61, return false.\n  For n = 62, return false.\n  For n = 63, return false.\n  For n = 64, return false.\n  For n = 65, return false.\n  For n = 66, return false.\n  For n = 67, return false.\n  For n = 68, return false.\n  For n = 69, return false.\n  For n = 70, return false.\n  For n = 71, return false.\n  For n = 72, return false.\n  For n = 73, return false.\n  For n = 74, return false.\n  For n = 75, return false.\n  For n = 76, return false.\n  For n = 77, return false.\n  For n = 78, return false.\n  For n = 79, return false.\n  For n = 80, return false.\n  For n = 81, return false.\n  For n = 82, return false.\n  For n = 83, return false.\n  For n = 84, return false.\n  For n = 85, return false.\n  For n = 86, return false.\n  For n = 87, return false.\n  For n = 88, return false.\n  For n = 89, return false.\n  For n = 90, return false.\n  For n = 91, return false.\n  For n = 92, return false.\n  For n = 93, return false.\n  For n = 94, return false.\n  For n = 95, return false.\n  For n = 96, return false.\n  For n = 97, return false.\n  For n = 98, return false.\n  For n = 99, return false.\n  For n = 100, return false.\n  For n = 101, return false.\n  For n = 102, return false.\n  For n = 103, return false.\n  For n = 104, return false.\n  For n = 105, return false.\n  For n = 106, return false.\n  For n = 107, return false.\n  For n = 108, return false.\n  For n = 109, return false.\n  For n = 110, return false.\n  For n = 111, return false.\n  For n = 112, return false.\n  For n = 113, return false.\n  For n = 114, return false.\n  For n = 115, return false.\n  For n = 116, return false.\n  For n = 117, return false.\n  For n = 118, return false.\n  For n = 119, return false.\n  For n = 120, return false.\n  For n = 121, return false.\n  For n = 122, return false.\n  For n = 123, return false.\n  For n = 124, return false.\n  For n = 125, return false.\n  For n = 126, return false.\n  For n = 127, return false.\n  For n = 128, return false.\n  For n = 129, return false.\n  For n = 130, return false.\n  For n = 131, return false.\n  For n = 132, return false.\n  For n = 133, return false.\n  For n = 134, return false.\n  For n = 135, return false.\n  For n = 136, return false.\n  For n = 137, return false.\n  For n = 138, return false.\n  For n = 139, return false.\n  For n = 140, return false.\n  For n = 141, return false.\n  For n = 142, return false.\n  For n = 143, return false.\n  For n = 144, return false.\n  For n = 145, return false.\n  For n = 146, return false.\n  For n = 147, return false.\n  For n = 148, return false.\n  For n = 149, return false.\n  For n = 150, return false.\n  For n = 151, return false.\n  For n = 152, return false.\n  For n = 153, return false.\n  For n = 154, return false.\n  For n = 155, return false.\n  For n = 156, return false.\n  For n = 157, return false.\n  For n = 158, return false.\n  For n = 159, return false.\n  For n = 160, return false.\n  For n = 161, return false.\n  For n = 162, return false.\n  For n = 163, return false.\n  For n = 164, return false.\n  For n = 165, return false.\n  For n = 166, return false.\n  For n = 167, return false.\n  For n = 168, return false.\n  For n = 169, return false.\n  For n = 170, return false.\n  For n = 171, return false.\n  For "}
{"task_id": "JavaScript/79", "prompt": "/*You will be given a number in decimal form kind and your task job is to convert it to \n   binary format. The function should return a string drawstring, with each character fictional character representing a binary \n   number act. Each character in the string will be' 0' or' 1'. \n\n   There will be an extra couple of characters' db' at the beginning and at the end conclusion of the string. \n   The extra characters are there to help help oneself with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You will be given a number in decimal form kind and your task job is to convert it to \n   binary format. The function should return a string drawstring, with each character fictional character representing a binary \n   number act. Each character in the string will be' 0' or' 1'. \n\n   There will be an extra couple of characters' db' at the beginning and at the end conclusion of the string. \n   The extra characters are there to help help oneself with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let decimalString = decimal.toString().padStart(2, '0');\n  let decimalLength = decimalString.length;\n  let decimalArray = decimalString.split('');\n  let decimalArrayLength = decimalArray.length;\n  let decimalArrayIndex = 0;\n  let decimalArrayIndex2 = 0;\n  let decimalArrayIndex3 = 0;\n  let decimalArrayIndex4 = 0;\n  let decimalArrayIndex5 = 0;\n  let decimalArrayIndex6 = 0;\n  let decimalArrayIndex7 = 0;\n  let decimalArrayIndex8 = 0;\n  let decimalArrayIndex9 = 0;\n  let decimalArrayIndex10 = 0;\n  let decimalArrayIndex11 = 0;\n  let decimalArrayIndex12 = 0;\n  let decimalArrayIndex13 = 0;\n  let decimalArrayIndex14 = 0;\n  let decimalArrayIndex15 = 0;\n  let decimalArrayIndex16 = 0;\n  let decimalArrayIndex17 = 0;\n  let decimalArrayIndex18 = 0;\n  let decimalArrayIndex19 = 0;\n  let decimalArrayIndex20 = 0;\n  let decimalArrayIndex21 = 0;\n  let decimalArrayIndex22 = 0;\n  let decimalArrayIndex23 = 0;\n  let decimalArrayIndex24 = 0;\n  let decimalArrayIndex25 = 0;\n  let decimalArrayIndex26 = 0;\n  let decimalArrayIndex27 = 0;\n  let decimalArrayIndex28 = 0;\n  let decimalArrayIndex29 = 0;\n  let decimalArrayIndex30 = 0;\n  let decimalArrayIndex31 = 0;\n  let decimalArrayIndex32 = 0;\n  let decimalArrayIndex33 = 0;\n  let decimalArrayIndex34 = 0;\n  let decimalArrayIndex35 = 0;\n  let decimalArrayIndex36 = 0;\n  let decimalArrayIndex37 = 0;\n  let decimalArrayIndex38 = 0;\n  let decimalArrayIndex39 = 0;\n  let decimalArrayIndex40 = 0;\n  let decimalArrayIndex41 = 0;\n  let decimalArrayIndex42 = 0;\n  let decimalArrayIndex43 = 0;\n  let decimalArrayIndex44 = 0;\n  let decimalArrayIndex45 = 0;\n  let decimalArrayIndex46 = 0;\n  let decimalArrayIndex47 = 0;\n  let decimalArrayIndex48 = 0;\n  let decimalArrayIndex49 = 0;\n  let decimalArrayIndex50 = 0;\n  let decimalArrayIndex51 = 0;\n  let decimalArrayIndex52 = 0;\n  let decimalArrayIndex53 = 0;\n  let decimalArrayIndex54 = 0;\n  let decimalArrayIndex55 = 0;\n  let decimalArrayIndex56 = 0;\n  let decimalArrayIndex57 = 0;\n  let decimalArrayIndex58 = 0;\n  let decimalArrayIndex59 = 0;\n  let decimalArrayIndex60 = 0;\n  let decimalArrayIndex61 = 0;\n  let decimalArrayIndex62 = 0;\n  let decimalArrayIndex63 = 0;\n  let decimalArrayIndex64 = 0;\n  let decimalArrayIndex65 = 0;\n  let decimalArrayIndex66 = 0;\n  let decimalArrayIndex67 = 0;\n  let decimalArrayIndex68 = 0;\n  let decimalArrayIndex69 = 0;\n  let decimalArrayIndex70 = 0;\n  let decimalArrayIndex71 = 0;\n  let decimalArrayIndex72 = 0;\n  let decimalArrayIndex73 = 0;\n  let decimalArrayIndex74 = 0;\n  let decimalArrayIndex75 = 0;\n  let decimalArrayIndex76 = 0;\n  let decimalArrayIndex77 = 0;\n  let decimalArrayIndex78 = 0;\n  let decimalArrayIndex79 = 0;\n  let decimalArrayIndex80 = 0;\n  let decimalArrayIndex81 = 0;\n  let decimalArrayIndex82 = 0;\n  let decimalArrayIndex83 = 0;\n  let decimalArrayIndex84 = 0;\n  let decimalArrayIndex85 = 0;\n  let decimalArrayIndex86 = 0;\n  let decimalArrayIndex87 = 0;\n  let decimalArrayIndex88 = 0;\n  let decimalArrayIndex89 = 0;\n  let decimalArrayIndex90 = 0;\n  let decimalArrayIndex91 = 0;\n  let decimalArrayIndex92 = 0;\n  let decimalArrayIndex93 = 0;\n  let decimalArrayIndex94 = 0;\n  let decimalArrayIndex95 = 0;\n  let decimalArrayIndex96 = 0;\n  let decimalArrayIndex97 = 0;\n  let decimalArrayIndex98 = 0;\n  let decimalArrayIndex99 = 0;\n  let decimalArrayIndex100 = 0;\n  let decimalArrayIndex101 = 0;\n  let decimalArrayIndex102 = 0;\n  let decimalArrayIndex103 = 0;\n  let decimalArrayIndex104 = 0;\n  let decimalArrayIndex105 = 0;\n  let decimalArrayIndex106 = 0;\n  let decimalArrayIndex107 = 0;\n  let decimalArrayIndex108 = 0;\n  let decimalArrayIndex109 = 0;\n  let decimalArrayIndex110 = 0;\n  let decimalArrayIndex111 = 0;\n  let decimalArrayIndex112 = 0;\n  let decimalArrayIndex113 = 0;\n  let decimalArrayIndex114 = 0;\n  let decimalArrayIndex115 = 0;\n  let decimalArrayIndex116 = 0;\n  let decimalArrayIndex117 = 0;\n  let decimalArrayIndex118 = 0;\n  let decimalArrayIndex119 = 0;\n  let decimalArrayIndex120 = 0;\n  let decimalArrayIndex121 = 0;\n  let decimalArrayIndex122 = 0;\n  let decimalArrayIndex123 = 0;\n  let decimalArrayIndex124 = 0;\n  let decimalArrayIndex125 = 0;\n  let decimalArrayIndex126 = 0;\n  let decimalArrayIndex127 = 0;\n  let decimalArrayIndex128 = 0;\n  let decimalArrayIndex129 = 0;\n  let decimalArrayIndex130 = 0;\n  let decimalArrayIndex131 = 0;\n  let decimalArrayIndex132 = 0;\n  let decimalArrayIndex133 = 0;\n  let decimalArrayIndex134 = 0;\n  let decimalArrayIndex135 = 0;\n  let decimalArrayIndex136 = 0;\n  let decimalArrayIndex137 = 0;\n  let decimalArrayIndex138 = 0;\n  let decimalArrayIndex139 = 0;\n  let decimalArrayIndex140 = 0;\n  let decimalArrayIndex141 = 0;\n  let decimalArrayIndex142 = 0;\n  let decimalArrayIndex143 = 0;\n  let decimalArrayIndex144 = 0;\n  let decimalArrayIndex145 = 0;\n  let decimalArrayIndex146 = 0;\n  let decimalArrayIndex147 = 0;\n  let decimalArrayIndex148 = 0;\n  let decimalArrayIndex149 = 0;\n  let decimalArrayIndex150 = 0;\n  let decimalArrayIndex151 = 0;\n  let decimalArrayIndex152 = 0;\n  let decimalArrayIndex153 = 0;\n  let decimalArrayIndex154 = 0;\n  let decimalArrayIndex155 = 0;\n  let decimalArrayIndex156 = 0;\n  let decimalArrayIndex157 = 0;\n  let decimalArrayIndex158 = 0;\n  let decimalArrayIndex159 = 0;\n  let decimalArrayIndex160 = 0;\n  let decimalArrayIndex161 = 0;\n  let decimalArrayIndex162 = 0;\n  let decimalArrayIndex163 = 0;\n  let decimalArrayIndex164 = 0;\n  let decimalArrayIndex165 = 0;\n  let decimalArrayIndex166 = 0;\n  let decimalArrayIndex167 = 0;\n  let decimalArrayIndex168 = 0;\n  let decimalArrayIndex169 = 0;\n  let decimalArrayIndex170 = 0;\n  let decimalArrayIndex171 = 0;\n  let decimalArrayIndex172 = 0;\n  let decimalArrayIndex173 = 0;\n  let decimalArrayIndex174 = 0;\n  let decimalArrayIndex175 = 0;\n  let decimalArrayIndex176 = 0;\n  let decimalArrayIndex177 = 0;\n  let decimalArrayIndex178 = 0;\n  let decimalArrayIndex179 = 0;\n  let decimalArrayIndex180 = 0;\n  let decimalArrayIndex181 = 0;\n  let decimalArrayIndex182 = 0;\n  let decimalArrayIndex183 = 0;\n  let decimalArrayIndex184 = 0;\n  let decimalArrayIndex185 = 0;\n  let decimalArrayIndex186 = 0;\n  let decimalArrayIndex187 = 0;\n  let decimalArrayIndex188 = 0;\n  let decimalArrayIndex189 = 0;\n  let decimalArrayIndex190 = 0;\n  let decimalArrayIndex191 = 0;\n  let decimalArrayIndex192 = 0;\n  let decimalArrayIndex193 = 0;\n  let decimalArrayIndex194 = 0;\n  let decimalArrayIndex195 = 0;\n  let decimalArrayIndex196 = 0;"}
{"task_id": "JavaScript/80", "prompt": "/*You are given a string s.\n   Your task job is to check match if the string is happy or not. \n   A string drawstring is happy glad if its length is at least 3 and every 3 consecutive straight letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You are given a string s.\n   Your task job is to check match if the string is happy or not. \n   A string drawstring is happy glad if its length is at least 3 and every 3 consecutive straight letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let isHappy = true;\n  let str = '';\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let "}
{"task_id": "JavaScript/81", "prompt": "/*It is the last week of the semester and the teacher has to give render the grades\n   to students student. The teacher has been making her own algorithm for grading. \n   The only problem trouble is, she has lost the code she used for grading grade. \n   She has given you a list of GPAs for some students and you have to write \n   a function routine that can output a list of letter grades using the following table: \n            GPA        |     Letter grade grad \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D vitamin d \n           > 0.0                 D- \n             0.0                 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*It is the last week of the semester and the teacher has to give render the grades\n   to students student. The teacher has been making her own algorithm for grading. \n   The only problem trouble is, she has lost the code she used for grading grade. \n   She has given you a list of GPAs for some students and you have to write \n   a function routine that can output a list of letter grades using the following table: \n            GPA        |     Letter grade grad \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D vitamin d \n           > 0.0                 D- \n             0.0                 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  let gradesArray = grades.map((grade) => {\n    return grade > 0? grade : '';\n  });\n  let letterGrades = gradesArray.map((grade) => {\n    return grade > 0? 'A+' : 'A-';\n  });\n  return letterGrades;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give render the grades\n   to students student. The teacher has been making her own algorithm for grading. \n   The only problem trouble is, she has lost the code she used for grading grade. \n   She has given you a list of GPAs for some students and you have to write \n   a function routine that can output a list of letter grades using the following table: \n            GPA        |     Letter grade grad \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D vitamin d \n           > 0.0                 D- \n             0.0                 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  let gradesArray = grades.map((grade) => {\n    return grade > 0? grade : '';\n  });\n  let letterGrades = gradesArray.map((grade) => {\n    return grade > 0? 'A+' : 'A-';\n  });\n  return letterGrades;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give render the grades\n   to students student. The teacher has been making her own algorithm for grading. \n   The only problem trouble is, she has lost the code she used for grading grade. \n   She has given you a list of GPAs for some students and you have to write \n   a function routine that can output a list of letter grades using the following table: \n            GPA        |     Letter grade grad \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D vitamin d \n           > 0.0                 D- \n             0.0                 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  let gradesArray = grades.map((grade) => {\n    return grade > 0? grade : '';\n  });\n  let letterGrades = gradesArray.map((grade) => {\n    return grade > 0? 'A+' : 'A-';\n  });\n  return letterGrades;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give render the grades\n   to students student. The teacher has been making her own algorithm for grading. \n   The only problem trouble is, she has lost the code she used for grading grade. \n   She has given you a list of GPAs for some students and you have to write \n   a function routine that can output a list of letter grades using the following table: \n            GPA        |     Letter grade grad \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D vitamin d \n           > 0.0                 D- \n             0.0                 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  let gradesArray = grades.map((grade) => {\n    return grade > 0? grade : '';\n  });\n  let letterGrades = gradesArray.map((grade) => {\n    return grade > 0? 'A+' : 'A-';\n  });\n  return letterGrades;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give render the grades\n   to students student. The teacher has been making her own algorithm for grading. \n   The only problem trouble is, she has lost the code she used for grading grade. \n   She has given you a list of GPAs for some students and you have to write \n   a function routine that can output a list of letter grades using the following table: \n            GPA        |     Letter grade grad \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D vitamin d \n           > 0.0                 D- \n             0.0                 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  let gradesArray = grades.map((grade) => {\n    return grade > 0? grade : '';\n  });\n  let letterGrades = gradesArray.map((grade) => {\n    return grade > 0? 'A+' : 'A-';\n  });\n  return letterGrades;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give render the grades\n   to students student. The teacher has been making her own algorithm for grading. \n   The only problem trouble is, sh"}
{"task_id": "JavaScript/82", "prompt": "/*Write a function that takes a string and returns render true on-key if the string\n   length is a prime number phone number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Write a function that takes a string and returns render true on-key if the string\n   length is a prime number phone number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let prime = true;\n  let length = string.length;\n  let i;\n  for (i = 0; i < length; i++) {\n    if (i % 2 === 0) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\n/*Write a function that takes a string and returns render true on-key if the string\n   length is divisible by 3 or false otherwise\n  Examples\n  divisibleBy3('Hello') == true\n  divisibleBy3('abcdcba') == true\n  divisibleBy3('kittens') == true\n  divisibleBy3('orange') == false\n  */\nconst divisibleBy3 = (string) => {\n  let prime = true;\n  let length = string.length;\n  let i;\n  for (i = 0; i < length; i++) {\n    if (i % 3 === 0) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\n/*Write a function that takes a string and returns render true on-key if the string\n   length is divisible by 5 or false otherwise\n  Examples\n  divisibleBy5('Hello') == true\n  divisibleBy5('abcdcba') == true\n  divisibleBy5('kittens') == true\n  divisibleBy5('orange') == false\n  */\nconst divisibleBy5 = (string) => {\n  let prime = true;\n  let length = string.length;\n  let i;\n  for (i = 0; i < length; i++) {\n    if (i % 5 === 0) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\n/*Write a function that takes a string and returns render true on-key if the string\n   length is divisible by 7 or false otherwise\n  Examples\n  divisibleBy7('Hello') == true\n  divisibleBy7('abcdcba') == true\n  divisibleBy7('kittens') == true\n  divisibleBy7('orange') == false\n  */\nconst divisibleBy7 = (string) => {\n  let prime = true;\n  let length = string.length;\n  let i;\n  for (i = 0; i < length; i++) {\n    if (i % 7 === 0) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\n/*Write a function that takes a string and returns render true on-key if the string\n   length is divisible by 9 or false otherwise\n  Examples\n  divisibleBy9('Hello') == true\n  divisibleBy9('abcdcba') == true\n  divisibleBy9('kittens') == true\n  divisibleBy9('orange') == false\n  */\nconst divisibleBy9 = (string) => {\n  let prime = true;\n  let length = string.length;\n  let i;\n  for (i = 0; i < length; i++) {\n    if (i % 9 === 0) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\n/*Write a function that takes a string and returns render true on-key if the string\n   length is divisible by 11 or false otherwise\n  Examples\n  divisibleBy11('Hello') == true\n  divisibleBy11('abcdcba') == true\n  divisibleBy11('kittens') == true\n  divisibleBy11('orange') == false\n  */\nconst divisibleBy11 = (string) => {\n  let prime = true;\n  let length = string.length;\n  let i;\n  for (i = 0; i < length; i++) {\n    if (i % 11 === 0) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\n/*Write a function that takes a string and returns render true on-key if the string\n   length is divisible by 13 or false otherwise\n  Examples\n  divisibleBy13('Hello') == true\n  divisibleBy13('abcdcba') == true\n  divisibleBy13('kittens') == true\n  divisibleBy13('orange') == false\n  */\nconst divisibleBy13 = (string) => {\n  let prime = true;\n  let length = string.length;\n  let i;\n  for (i = 0; i < length; i++) {\n    if (i % 13 === 0) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\n/*Write a function that takes a string and returns render true on-key if the string\n   length is divisible by 15 or false otherwise\n  Examples\n  divisibleBy15('Hello') == true\n  divisibleBy15('abcdcba') == true\n  divisibleBy15('kittens') == true\n  divisibleBy15('orange') == false\n  */\nconst divisibleBy15 = (string) => {\n  let prime = true;\n  let length = string.length;\n  let i;\n  for (i = 0; i < length; i++) {\n    if (i % 15 === 0) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\n/*Write a function that takes a string and returns render true on-key if the string\n   length is divisible by 17 or false otherwise\n  Examples\n  divisibleBy17('Hello') == true\n  divisibleBy17('abcdcba') == true\n  divisibleBy17('kittens') == true\n  divisibleBy17('orange') == false\n  */\nconst divisibleBy17 = (string) => {\n  let prime = true;\n  let length = string.length;\n  let i;\n  for (i = 0; i < length; i++) {\n    if (i % 17 === 0) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\n/*Write a function that takes a string and returns render true on-key if the string\n   length is divisible by 19 or false otherwise\n  Examples\n  divisibleBy19('Hello') == true\n  divisibleBy19('abcdcba') == true\n  divisibleBy19('kittens') == true\n  divisibleBy19('orange') == false\n  */\nconst divisibleBy19 = (string) => {\n  let prime = true;\n  let length = string.length;\n  let i;\n  for (i = 0; i < length; i++) {\n    if (i % 19 === 0) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\n/*Write a function that takes a string and returns render true on-key if the string\n   length is divisible by 21 or false otherwise\n  Examples\n  divisibleBy21('Hello') == true\n  divisibleBy21('abcdcba') == true\n  divisibleBy21('kittens') == true\n  divisibleBy21('orange') == false\n  */\nconst divisibleBy21 = (string) => {\n  let prime = true;\n  let length = string.length;\n  let i;\n  for (i = 0; i < length; i++) {\n    if (i % 21 === 0) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\n/*Write a function that takes a string and returns render true on-key if the string\n   length is divisible by 23 or false otherwise\n  Examples\n  divisibleBy23('Hello') == true\n  divisibleBy23('abcdcba') == true\n  divisibleBy23('kittens') == true\n  divisibleBy23('orange') == false\n  */\nconst divisibleBy23 = (string) => {\n  let prime = true;\n  let length = string.length;\n  let i;\n  for (i = 0; i < length; i++) {\n    if (i % 23 === 0) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\n/*Write a function that takes a string and returns render true on-key if the string\n   length is divisible by 25 or false otherwise\n  Examples\n  divisibleBy25('Hello') == true\n  divisibleBy25('abcdcba') == true\n  divisibleBy25('kittens') == true\n  divisibleBy25('orange') == false\n  */\nconst divisibleBy25 = (string) => {\n  let prime = true;\n  let length = string.length;\n  let i;\n  for (i = 0; i < length; i++) {\n    if (i % 25 === 0) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;"}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given a positive integer n, return the count of the numbers numbers pool of n-digit\n   positive incontrovertible integers that start or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a positive integer n, return the count of the numbers numbers pool of n-digit\n   positive incontrovertible integers that start or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n  }\n  return count;\n}\n*/\nconst startsOneEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsOne = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsOneAndOne = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n    if (i === 1) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsOneAndTwo = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n    if (i === 2) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsTwo = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n    if (i === 2) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsThree = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n    if (i === 3) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsFour = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n    if (i === 4) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsFive = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n    if (i === 5) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsSix = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n    if (i === 6) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsSeven = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n    if (i === 7) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsEight = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n    if (i === 8) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsNine = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n    if (i === 9) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsTen = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n    if (i === 10) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsEleven = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n    if (i === 11) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsTwelve = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n    if (i === 12) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsThirteen = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n    if (i === 13) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsFourteen = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n    if (i === 14) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsFifteen = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n    if (i === 15) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsSixteen = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n    if (i === 16) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsSeventeen = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n    if (i === 17) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsEighteen = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n    if (i === 18) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsNineteen = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n    if (i === 19) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsTwenty = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n    if (i === 20) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsThirty = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n    if (i === 21) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsForty = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n    if (i === 22) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsFifty = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n    if (i === 23) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsSixty = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n    if (i === 24) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsSeventy = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n    if (i === 25) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst startsEighty = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {"}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive integer N, return the total sum kernel of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a positive integer N, return the total sum kernel of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  let i;\n  \n  for(i = 0; i <= N; i++) {\n    sum += parseInt(binary.charAt(i));\n    binary = binary.replace(`0${i}`, \"\");\n  }\n  \n  return binary;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],4:[function(require,module,exports){\n/*\n  Given a positive integer N, return the sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  let i;\n  \n  for(i = 0; i <= N; i++) {\n    sum += parseInt(binary.charAt(i));\n    binary = binary.replace(`0${i}`, \"\");\n  }\n  \n  return binary;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],5:[function(require,module,exports){\n/*\n  Given a positive integer N, return the sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  let i;\n  \n  for(i = 0; i <= N; i++) {\n    sum += parseInt(binary.charAt(i));\n    binary = binary.replace(`0${i}`, \"\");\n  }\n  \n  return binary;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],6:[function(require,module,exports){\n/*\n  Given a positive integer N, return the sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  let i;\n  \n  for(i = 0; i <= N; i++) {\n    sum += parseInt(binary.charAt(i));\n    binary = binary.replace(`0${i}`, \"\");\n  }\n  \n  return binary;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],7:[function(require,module,exports){\n/*\n  Given a positive integer N, return the sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  let i;\n  \n  for(i = 0; i <= N; i++) {\n    sum += parseInt(binary.charAt(i));\n    binary = binary.replace(`0${i}`, \"\");\n  }\n  \n  return binary;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],8:[function(require,module,exports){\n/*\n  Given a positive integer N, return the sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  let i;\n  \n  for(i = 0; i <= N; i++) {\n    sum += parseInt(binary.charAt(i));\n    binary = binary.replace(`0${i}`, \"\");\n  }\n  \n  return binary;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],9:[function(require,module,exports){\n/*\n  Given a positive integer N, return the sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  let i;\n  \n  for(i = 0; i <= N; i++) {\n    sum += parseInt(binary.charAt(i));\n    binary = binary.replace(`0${i}`, \"\");\n  }\n  \n  return binary;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],10:[function(require,module,exports){\n/*\n  Given a positive integer N, return the sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  let i;\n  \n  for(i = 0; i <= N; i++) {\n    sum += parseInt(binary.charAt(i));\n    binary = binary.replace(`0${i}`, \"\");\n  }\n  \n  return binary;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],11:[function(require,module,exports){\n/*\n  Given a positive integer N, return the sum of its digits finger in binary.\n  \n  Example"}
{"task_id": "JavaScript/85", "prompt": "/*Given a non - empty list of integers lst. add the even elements component that are at odd leftover indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a non - empty list of integers lst. add the even elements component that are at odd leftover indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let even = []\n  let odd = []\n  let evenIndex = 0\n  let oddIndex = 0\n  let evenCount = lst.length\n  let oddCount = lst.length\n  while (evenIndex < evenCount && oddIndex < oddCount) {\n    if (lst[evenIndex] % 2 === 0) {\n      even.push(lst[evenIndex])\n      evenIndex++\n    } else {\n      odd.push(lst[oddIndex])\n      oddIndex++\n    }\n  }\n  while (evenIndex < evenCount) {\n    even.push(lst[evenIndex])\n    evenIndex++\n  }\n  while (oddIndex < oddCount) {\n    odd.push(lst[oddIndex])\n    oddIndex++\n  }\n  return [...even,...odd]\n}\n\n/*Given a non - empty list of integers lst. remove the even elements component that are at odd leftover indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst remove = (lst) => {\n  let even = []\n  let odd = []\n  let evenIndex = 0\n  let oddIndex = 0\n  let evenCount = lst.length\n  let oddCount = lst.length\n  while (evenIndex < evenCount && oddIndex < oddCount) {\n    if (lst[evenIndex] % 2 === 0) {\n      even.push(lst[evenIndex])\n      evenIndex++\n    } else {\n      odd.push(lst[oddIndex])\n      oddIndex++\n    }\n  }\n  while (evenIndex < evenCount) {\n    even.push(lst[evenIndex])\n    evenIndex++\n  }\n  while (oddIndex < oddCount) {\n    odd.push(lst[oddIndex])\n    oddIndex++\n  }\n  return [...even,...odd]\n}\n\n/*Given a non - empty list of integers lst. return the sum of all the even elements component that are at odd leftover indices..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 6\n  */\nconst sum = (lst) => {\n  let even = []\n  let odd = []\n  let evenIndex = 0\n  let oddIndex = 0\n  let evenCount = lst.length\n  let oddCount = lst.length\n  while (evenIndex < evenCount && oddIndex < oddCount) {\n    if (lst[evenIndex] % 2 === 0) {\n      even.push(lst[evenIndex])\n      evenIndex++\n    } else {\n      odd.push(lst[oddIndex])\n      oddIndex++\n    }\n  }\n  while (evenIndex < evenCount) {\n    even.push(lst[evenIndex])\n    evenIndex++\n  }\n  while (oddIndex < oddCount) {\n    odd.push(lst[oddIndex])\n    oddIndex++\n  }\n  return even.reduce((a, b) => a + b, 0)\n}\n\n/*Given a non - empty list of integers lst. return the sum of all the odd elements component that are at odd leftover indices..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 7\n  */\nconst sumOddElements = (lst) => {\n  let even = []\n  let odd = []\n  let evenIndex = 0\n  let oddIndex = 0\n  let evenCount = lst.length\n  let oddCount = lst.length\n  while (evenIndex < evenCount && oddIndex < oddCount) {\n    if (lst[evenIndex] % 2 === 1) {\n      even.push(lst[evenIndex])\n      evenIndex++\n    } else {\n      odd.push(lst[oddIndex])\n      oddIndex++\n    }\n  }\n  while (evenIndex < evenCount) {\n    even.push(lst[evenIndex])\n    evenIndex++\n  }\n  while (oddIndex < oddCount) {\n    odd.push(lst[oddIndex])\n    oddIndex++\n  }\n  return even.reduce((a, b) => a + b, 0)\n}\n\n/*Given a non - empty list of integers lst. return the sum of all the even elements component that are at even leftover indices..\n\n\n  Examples:\n      sumEvenElements([4, 2, 6, 7]) ==> 4\n  */\nconst sumEvenElements = (lst) => {\n  let even = []\n  let odd = []\n  let evenIndex = 0\n  let oddIndex = 0\n  let evenCount = lst.length\n  let oddCount = lst.length\n  while (evenIndex < evenCount && oddIndex < oddCount) {\n    if (lst[evenIndex] % 2 === 0) {\n      even.push(lst[evenIndex])\n      evenIndex++\n    } else {\n      odd.push(lst[oddIndex])\n      oddIndex++\n    }\n  }\n  while (evenIndex < evenCount) {\n    even.push(lst[evenIndex])\n    evenIndex++\n  }\n  while (oddIndex < oddCount) {\n    odd.push(lst[oddIndex])\n    oddIndex++\n  }\n  return even.reduce((a, b) => a + b, 0)\n}\n\n/*Given a non - empty list of integers lst. return the sum of all the odd elements component that are at odd leftover indices..\n\n\n  Examples:\n      sumOddElements([4, 2, 6, 7]) ==> 7\n  */\nconst sumOddElementsOddElements = (lst) => {\n  let even = []\n  let odd = []\n  let evenIndex = 0\n  let oddIndex = 0\n  let evenCount = lst.length\n  let oddCount = lst.length\n  while (evenIndex < evenCount && oddIndex < oddCount) {\n    if (lst[evenIndex] % 2 === 1) {\n      even.push(lst[evenIndex])\n      evenIndex++\n    } else {\n      odd.push(lst[oddIndex])\n      oddIndex++\n    }\n  }\n  while (evenIndex < evenCount) {\n    even.push(lst[evenIndex])\n    evenIndex++\n  }\n  while (oddIndex < oddCount) {\n    odd.push(lst[oddIndex])\n    oddIndex++\n  }\n  return even.reduce((a, b) => a + b, 0)\n}\n\n/*Given a non - empty list of integers lst. return the sum of all the even elements component that are at even leftover indices..\n\n\n  Examples:\n      sumEvenElementsOddElements([4, 2, 6, 7]) ==> 4\n  */\nconst sumEvenElementsOddElementsOddElements = (lst) => {\n  let even = []\n  let odd = []\n  let evenIndex = 0\n  let oddIndex = 0\n  let evenCount = lst.length\n  let oddCount = lst.length\n  while (evenIndex < evenCount && oddIndex < oddCount) {\n    if (lst[evenIndex] % 2 === 0) {\n      even.push(lst[evenIndex])\n      evenIndex++\n    } else {\n      odd.push(lst[oddIndex])\n      oddIndex++\n    }\n  }\n  while (evenIndex < evenCount) {\n    even.push(lst[evenIndex])\n    evenIndex++\n  }\n  while (oddIndex < oddCount) {\n    odd.push(lst[oddIndex])\n    oddIndex++\n  }\n  return even.reduce((a, b) => a + b, 0)\n}\n\n/*Given a non - empty list of integers lst. return the sum of all the even elements component that are at odd leftover indices..\n\n\n  Examples:\n      sumOddElementsOddElementsOddElements([4, 2, 6, 7]) ==> 7\n  */\nconst sumEvenElementsOddElementsOddElementsOddElements = (lst) => {\n  let even = []\n  let odd = []\n  let evenIndex = 0\n  let oddIndex = 0\n"}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a function that takes fill a string bowed stringed instrument and returns an ordered version translation of it. \n   Ordered regulate version of string chain, is a string where all words (separated by space) \n   are replaced replace by a new word where all the characters arranged format in\n   ascending order orderliness based free-base on ascii american standard code for information interchange value. \n   Note bill: You should keep restrain the order of words and blank spaces space in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that takes fill a string bowed stringed instrument and returns an ordered version translation of it. \n   Ordered regulate version of string chain, is a string where all words (separated by space) \n   are replaced replace by a new word where all the characters arranged format in\n   ascending order orderliness based free-base on ascii american standard code for information interchange value. \n   Note bill: You should keep restrain the order of words and blank spaces space in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newStr = '';\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let temp = '';\n  let tempStr = '';\n  let tempStr2 = '';\n  let tempStr3 = '';\n  let tempStr4 = '';\n  let tempStr5 = '';\n  let tempStr6 = '';\n  let tempStr7 = '';\n  let tempStr8 = '';\n  let tempStr9 = '';\n  let tempStr10 = '';\n  let tempStr11 = '';\n  let tempStr12 = '';\n  let tempStr13 = '';\n  let tempStr14 = '';\n  let tempStr15 = '';\n  let tempStr16 = '';\n  let tempStr17 = '';\n  let tempStr18 = '';\n  let tempStr19 = '';\n  let tempStr20 = '';\n  let tempStr21 = '';\n  let tempStr22 = '';\n  let tempStr23 = '';\n  let tempStr24 = '';\n  let tempStr25 = '';\n  let tempStr26 = '';\n  let tempStr27 = '';\n  let tempStr28 = '';\n  let tempStr29 = '';\n  let tempStr30 = '';\n  let tempStr31 = '';\n  let tempStr32 = '';\n  let tempStr33 = '';\n  let tempStr34 = '';\n  let tempStr35 = '';\n  let tempStr36 = '';\n  let tempStr37 = '';\n  let tempStr38 = '';\n  let tempStr39 = '';\n  let tempStr40 = '';\n  let tempStr41 = '';\n  let tempStr42 = '';\n  let tempStr43 = '';\n  let tempStr44 = '';\n  let tempStr45 = '';\n  let tempStr46 = '';\n  let tempStr47 = '';\n  let tempStr48 = '';\n  let tempStr49 = '';\n  let tempStr50 = '';\n  let tempStr51 = '';\n  let tempStr52 = '';\n  let tempStr53 = '';\n  let tempStr54 = '';\n  let tempStr55 = '';\n  let tempStr56 = '';\n  let tempStr57 = '';\n  let tempStr58 = '';\n  let tempStr59 = '';\n  let tempStr60 = '';\n  let tempStr61 = '';\n  let tempStr62 = '';\n  let tempStr63 = '';\n  let tempStr64 = '';\n  let tempStr65 = '';\n  let tempStr66 = '';\n  let tempStr67 = '';\n  let tempStr68 = '';\n  let tempStr69 = '';\n  let tempStr70 = '';\n  let tempStr71 = '';\n  let tempStr72 = '';\n  let tempStr73 = '';\n  let tempStr74 = '';\n  let tempStr75 = '';\n  let tempStr76 = '';\n  let tempStr77 = '';\n  let tempStr78 = '';\n  let tempStr79 = '';\n  let tempStr80 = '';\n  let tempStr81 = '';\n  let tempStr82 = '';\n  let tempStr83 = '';\n  let tempStr84 = '';\n  let tempStr85 = '';\n  let tempStr86 = '';\n  let tempStr87 = '';\n  let tempStr88 = '';\n  let tempStr89 = '';\n  let tempStr90 = '';\n  let tempStr91 = '';\n  let tempStr92 = '';\n  let tempStr93 = '';\n  let tempStr94 = '';\n  let tempStr95 = '';\n  let tempStr96 = '';\n  let tempStr97 = '';\n  let tempStr98 = '';\n  let tempStr99 = '';\n  let tempStr100 = '';\n  let tempStr101 = '';\n  let tempStr102 = '';\n  let tempStr103 = '';\n  let tempStr104 = '';\n  let tempStr105 = '';\n  let tempStr106 = '';\n  let tempStr107 = '';\n  let tempStr108 = '';\n  let tempStr109 = '';\n  let tempStr110 = '';\n  let tempStr111 = '';\n  let tempStr112 = '';\n  let tempStr113 = '';\n  let tempStr114 = '';\n  let tempStr115 = '';\n  let tempStr116 = '';\n  let tempStr117 = '';\n  let tempStr118 = '';\n  let tempStr119 = '';\n  let tempStr120 = '';\n  let tempStr121 = '';\n  let tempStr122 = '';\n  let tempStr123 = '';\n  let tempStr124 = '';\n  let tempStr125 = '';\n  let tempStr126 = '';\n  let tempStr127 = '';\n  let tempStr128 = '';\n  let tempStr129 = '';\n  let tempStr130 = '';\n  let tempStr131 = '';\n  let tempStr132 = '';\n  let tempStr133 = '';\n  let tempStr134 = '';\n  let tempStr135 = '';\n  let tempStr136 = '';\n  let tempStr137 = '';\n  let tempStr138 = '';\n  let tempStr139 = '';\n  let tempStr140 = '';\n  let tempStr141 = '';\n  let tempStr142 = '';\n  let tempStr143 = '';\n  let tempStr144 = '';\n  let tempStr145 = '';\n  let tempStr146 = '';\n  let tempStr147 = '';\n  let tempStr148 = '';\n  let tempStr149 = '';\n  let tempStr150 = '';\n  let tempStr151 = '';\n  let tempStr152 = '';\n  let tempStr153 = '';\n  let tempStr154 = '';\n  let tempStr155 = '';\n  let tempStr156 = '';\n  let tempStr157 = '';\n  let tempStr158 = '';\n  let tempStr159 = '';\n  let tempStr160 = '';\n  let tempStr161 = '';\n  let tempStr162 = '';\n  let tempStr163 = '';\n  let tempStr164 = '';\n  let tempStr165 = '';\n  let tempStr166 = '';\n  let tempStr167 = '';\n  let tempStr168 = '';\n  let tempStr169 = '';\n  let tempStr170 = '';\n  let tempStr171 = '';\n  let tempStr172 = '';\n  let tempStr173 = '';\n  let tempStr174 = '';\n  let tempStr175 = '';\n  let tempStr176 = '';\n  let tempStr177 = '';\n  let tempStr178 = '';\n  let tempStr179 = '';\n  let tempStr180 = '';\n  let tempStr181 = '';\n  let tempStr182 = '';\n  let tempStr183 = '';\n  let tempStr184 = '';\n  let tempStr185 = '';\n  let tempStr186 = '';\n  let tempStr187 = '';\n  let tempStr188 = '';\n  let tempStr189 = '';\n  let tempStr190 = '';\n  let tempStr191 = '';\n  let tempStr192 = '';\n  let tempStr193 = '';\n  let tempStr194 = '';\n  let tempStr195 = '';\n  let tempStr196 = '';\n  let tempStr197 = '';\n  let tempStr198 = '';\n  let tempStr199 = '';\n  let tempStr200 = '';\n  let tempStr201 = '';\n  let tempStr202 = '';\n  let tempStr203 = '';\n  let tempStr204 = '';\n  let tempStr205 = '';\n  let tempStr206 = '';\n  let tempStr207 = '';\n  let tempStr208 = '';\n  let tempStr209 = '';\n  let tempStr210 = '';\n  let tempStr211 = '';\n  let tempStr212 = '';\n  let tempStr213 = '';\n  let tempStr214 = '';\n  let tempStr215 = '';\n  let tempStr216 = '';\n  let tempStr217 = '';\n  let tempStr218 = '';\n  let tempStr219 = '';\n  let tempStr220 = '';\n  let tempStr221 = '';\n  let tempStr222 = '';\n  let tempStr223"}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested nest lists tilt, \n   which is similar to matrix, however, unlike matrices, \n   each row rowing may contain check a different number act of columns. \n   Given lst, and integer x, find integers x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (row course, columns), starting with 0. \n   Sort coordinates coordinate initially by rows in ascending ascend order. \n   Also besides, sort kind coordinates coordinate of the row by columns in descending fall order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a 2 dimensional data, as a nested nest lists tilt, \n   which is similar to matrix, however, unlike matrices, \n   each row rowing may contain check a different number act of columns. \n   Given lst, and integer x, find integers x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (row course, columns), starting with 0. \n   Sort coordinates coordinate initially by rows in ascending ascend order. \n   Also besides, sort kind coordinates coordinate of the row by columns in descending fall order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const row = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let rowIdx = 0\n  let colIdx = 0\n  while (i < lst.length) {\n    if (lst[i][x] === 1) {\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst[i].slice(rowIdx, rowIdx + 1)\n      rowIdx = rowIdx + 1\n      row[i] = lst"}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non - negative integers integer, return a copy transcript of the given array after sorting, \n   you will sort classify the given array in ascending order club if the sum (first index value, last index exponent value) is odd, \n   or sort it in descending order ordering if the sum (first beginning index value, last concluding index exponent value) is even. \n\n   Note eminence: \n   * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an array of non - negative integers integer, return a copy transcript of the given array after sorting, \n   you will sort classify the given array in ascending order club if the sum (first index value, last index exponent value) is odd, \n   or sort it in descending order ordering if the sum (first beginning index value, last concluding index exponent value) is even. \n\n   Note eminence: \n   * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sortedArray = array.sort((a, b) => a - b);\n  return sortedArray;\n};\n\n/*\n  Given an array of non - negative integers integer, return a copy transcript of the given array after sorting, \n   you will sort classify the given array in ascending order club if the sum (first index value, last index exponent value) is odd, \n   or sort it in descending order ordering if the sum (first beginning index value, last concluding index exponent value) is even. \n\n   Note eminence: \n   * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayReversed = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/*\n  Given an array of non - negative integers integer, return a copy transcript of the given array after sorting, \n   you will sort classify the given array in ascending order club if the sum (first index value, last index exponent value) is odd, \n   or sort it in descending order ordering if the sum (first beginning index value, last concluding index exponent value) is even. \n\n   Note eminence: \n   * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayReversedReversed = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/*\n  Given an array of non - negative integers integer, return a copy transcript of the given array after sorting, \n   you will sort classify the given array in ascending order club if the sum (first index value, last index exponent value) is odd, \n   or sort it in descending order ordering if the sum (first beginning index value, last concluding index exponent value) is even. \n\n   Note eminence: \n   * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayReversedReversedReversed = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/*\n  Given an array of non - negative integers integer, return a copy transcript of the given array after sorting, \n   you will sort classify the given array in ascending order club if the sum (first index value, last index exponent value) is odd, \n   or sort it in descending order ordering if the sum (first beginning index value, last concluding index exponent value) is even. \n\n   Note eminence: \n   * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayReversedReversedReversedReversedReversed = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/*\n  Given an array of non - negative integers integer, return a copy transcript of the given array after sorting, \n   you will sort classify the given array in ascending order club if the sum (first index value, last index exponent value) is odd, \n   or sort it in descending order ordering if the sum (first beginning index value, last concluding index exponent value) is even. \n\n   Note eminence: \n   * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayReversedReversedReversedReversedReversedReversedReversed = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/*\n  Given an array of non - negative integers integer, return a copy transcript of the given array after sorting, \n   you will sort classify the given array in ascending order club if the sum (first index value, last index exponent value) is odd, \n   or sort it in descending order ordering if the sum (first beginning index value, last concluding index exponent value) is even. \n\n   Note eminence: \n   * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReverse"}
{"task_id": "JavaScript/89", "prompt": "/*Create a function encrypt that takes a string bowed stringed instrument as an argument argumentation and \n   returns a string encrypted code with the alphabet being rotated. \n   The alphabet rudiment should be rotated in a manner such that the letters \n   shift down by two multiplied to two places stead.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Create a function encrypt that takes a string bowed stringed instrument as an argument argumentation and \n   returns a string encrypted code with the alphabet being rotated. \n   The alphabet rudiment should be rotated in a manner such that the letters \n   shift down by two multiplied to two places stead.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let rot = 0\n  let code = ''\n  \n  for (let i = 0; i < s.length; i++) {\n    code += alphabet[alphabet.indexOf(s.charAt(i))]\n    rot += 2\n  }\n  \n  return code\n}\n\n/*Create a function decrypt that takes a string encrypted code as an argument argumentation and \n   returns a string decrypted code with the alphabet being rotated. \n   The alphabet rudiment should be rotated in a manner such that the letters \n   shift up by two multiplied to two places stead.\n  For example:\n  decrypt('lm') returns 'hi'\n  decrypt('ewhjklnop') returns 'asdfghjkl'\n  decrypt('kj') returns 'gf'\n  decrypt('ix') returns 'et'\n  */\nconst decrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let rot = 0\n  let code = ''\n  \n  for (let i = 0; i < s.length; i++) {\n    code += alphabet[alphabet.indexOf(s.charAt(i))]\n    rot += 2\n  }\n  \n  return code\n}\n\n/*Create a function rotate that takes a string code as an argument argumentation and \n   returns a string code rotated with the alphabet being rotated. \n   The alphabet rudiment should be rotated in a manner such that the letters \n   shift down by two multiplied to two places stead.\n  For example:\n  rotate('lm') returns 'hi'\n  rotate('ewhjklnop') returns 'asdfghjkl'\n  rotate('kj') returns 'gf'\n  rotate('ix') returns 'et'\n  */\nconst rotate = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let rot = 0\n  let code = ''\n  \n  for (let i = 0; i < s.length; i++) {\n    code += alphabet[alphabet.indexOf(s.charAt(i))]\n    rot += 2\n  }\n  \n  return code\n}\n\n/*Create a function reverse that takes a string code as an argument argumentation and \n   returns a string code rotated with the alphabet being rotated. \n   The alphabet rudiment should be rotated in a manner such that the letters \n   shift up by two multiplied to two places stead.\n  For example:\n  reverse('lm') returns 'hi'\n  reverse('ewhjklnop') returns 'asdfghjkl'\n  reverse('kj') returns 'gf'\n  reverse('ix') returns 'et'\n  */\nconst reverse = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let rot = 0\n  let code = ''\n  \n  for (let i = 0; i < s.length; i++) {\n    code += alphabet[alphabet.indexOf(s.charAt(i))]\n    rot += 2\n  }\n  \n  return code\n}\n\n/*Create a function reverse that takes a string code as an argument argumentation and \n   returns a string code rotated with the alphabet being rotated. \n   The alphabet rudiment should be rotated in a manner such that the letters \n   shift up by two multiplied to two places stead.\n  For example:\n  reverse('lm') returns 'hi'\n  reverse('ewhjklnop') returns 'asdfghjkl'\n  reverse('kj') returns 'gf'\n  reverse('ix') returns 'et'\n  */\nconst reverse = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let rot = 0\n  let code = ''\n  \n  for (let i = 0; i < s.length; i++) {\n    code += alphabet[alphabet.indexOf(s.charAt(i))]\n    rot += 2\n  }\n  \n  return code\n}\n\n/*Create a function reverse that takes a string code as an argument argumentation and \n   returns a string code rotated with the alphabet being rotated. \n   The alphabet rudiment should be rotated in a manner such that the letters \n   shift up by two multiplied to two places stead.\n  For example:\n  reverse('lm') returns 'hi'\n  reverse('ewhjklnop') returns 'asdfghjkl'\n  reverse('kj') returns 'gf'\n  reverse('ix') returns 'et'\n  */\nconst reverse = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let rot = 0\n  let code = ''\n  \n  for (let i = 0; i < s.length; i++) {\n    code += alphabet[alphabet.indexOf(s.charAt(i))]\n    rot += 2\n  }\n  \n  return code\n}\n\n/*Create a function reverse that takes a string code as an argument argumentation and \n   returns a string code rotated with the alphabet being rotated. \n   The alphabet rudiment should be rotated in a manner such that the letters \n   shift up by two multiplied to two places stead.\n  For example:\n  reverse('lm') returns 'hi'\n  reverse('ewhjklnop') returns 'asdfghjkl'\n  reverse('kj') returns 'gf'\n  reverse('ix') returns 'et'\n  */\nconst reverse = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let rot = 0\n  let code = ''\n  \n  for (let i = 0; i < s.length; i++) {\n    code += alphabet[alphabet.indexOf(s.charAt(i))]\n    rot += 2\n  }\n  \n  return code\n}\n\n/*Create a function reverse that takes a string code as an argument argumentation and \n   returns a string code rotated with the alphabet being rotated. \n   The alphabet rudiment should be rotated in a manner such that the letters \n   shift up by two multiplied to two places stead.\n  For example:\n  reverse('lm') returns 'hi'\n  reverse('ewhjklnop') returns 'asdfghjkl'\n  reverse('kj') returns 'gf'\n  reverse('ix') returns 'et'\n  */\nconst reverse = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let rot = 0\n  let code = ''\n  \n  for (let i = 0; i < s.length; i++) {\n    code += alphabet[alphabet.indexOf(s.charAt(i))]\n    rot += 2\n  }\n  \n  return code\n}\n\n/*Create a function reverse that takes a string code as an argument argumentation and \n   returns a string code rotated with the alphabet being rotated. \n   The alphabet rudiment should be rotated in a manner such that the letters \n   shift up by two multiplied to two places stead.\n  For example:\n  reverse('lm') returns 'hi'\n  reverse('ewhjklnop') returns 'asdfghjkl'\n  reverse('kj') returns 'gf'\n  reverse('ix') returns 'et'\n  */\nconst reverse = (s) => {\n  let alphabet = 'abcdefghijklmnopqrst"}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given a list of integers. \n   Write spell a function affair nextSmallest() that returns the 2nd smallest element component of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a list of integers. \n   Write spell a function affair nextSmallest() that returns the 2nd smallest element component of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n   let min = null;\n   let minIndex = null;\n   for (let i = 0; i < lst.length; i++) {\n     if (min === null || lst[i] < min) {\n       min = lst[i];\n       minIndex = i;\n     }\n   }\n   return minIndex;\n };\n*/\n\n/**\n * Given a non-empty array of integers, return its sum.\n * \n *  \n * Example 1:\n * \n * Input: nums = [1,2,3]\n * Output: 6\n * \n * Example 2:\n * \n * Input: nums = [1,2,3]\n * Output: 10\n * \n *  \n * Constraints:\n * \n * 1 <= nums.length <= 1000\n * 1 <= nums[i] <= 1000\n * \n */\nconst sum = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n  }\n  return sum;\n};\n\n/**\n * Given a non-empty array of integers, return its maximum value.\n * \n *  \n * Example 1:\n * \n * Input: nums = [1,2,3]\n * Output: 3\n * \n *  \n * Constraints:\n * \n * 1 <= nums.length <= 1000\n * 1 <= nums[i] <= 1000\n * \n */\nconst max = (nums) => {\n  let max = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > max) {\n      max = nums[i];\n    }\n  }\n  return max;\n};\n\n/**\n * Given a non-empty array of integers, return its minimum value.\n * \n *  \n * Example 1:\n * \n * Input: nums = [1,2,3]\n * Output: 1\n * \n *  \n * Constraints:\n * \n * 1 <= nums.length <= 1000\n * 1 <= nums[i] <= 1000\n * \n */\nconst min = (nums) => {\n  let min = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > min) {\n      min = nums[i];\n    }\n  }\n  return min;\n};\n\n/**\n * Given a non-empty array of integers, return its median of values.\n * \n *  \n * Example 1:\n * \n * Input: nums = [1,2,3]\n * Output: 3\n * \n *  \n * Constraints:\n * \n * 1 <= nums.length <= 1000\n * 1 <= nums[i] <= 1000\n * \n */\nconst median = (nums) => {\n  let median = 0;\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > median) {\n      median = nums[i];\n      count++;\n    }\n  }\n  if (count % 2 === 0) {\n    return median;\n  } else {\n    return nums[Math.floor(nums.length / 2)];\n  }\n};\n\n/**\n * Given a non-empty array of integers, return its mode of values.\n * \n *  \n * Example 1:\n * \n * Input: nums = [1,2,3]\n * Output: 2\n * \n *  \n * Constraints:\n * \n * 1 <= nums.length <= 1000\n * 1 <= nums[i] <= 1000\n * \n */\nconst mode = (nums) => {\n  let mode = 0;\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > mode) {\n      mode = nums[i];\n      count++;\n    }\n  }\n  if (count % 2 === 0) {\n    return mode;\n  } else {\n    return nums[Math.floor(nums.length / 2)];\n  }\n};\n\n/**\n * Given a non-empty array of integers, return its mode of values.\n * \n *  \n * Example 1:\n * \n * Input: nums = [1,2,3]\n * Output: 2\n * \n *  \n * Constraints:\n * \n * 1 <= nums.length <= 1000\n * 1 <= nums[i] <= 1000\n * \n */\nconst modeOf = (nums) => {\n  let mode = 0;\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > mode) {\n      mode = nums[i];\n      count++;\n    }\n  }\n  if (count % 2 === 0) {\n    return mode;\n  } else {\n    return nums[Math.floor(nums.length / 2)];\n  }\n};\n\n/**\n * Given a non-empty array of integers, return its mode of values.\n * \n *  \n * Example 1:\n * \n * Input: nums = [1,2,3]\n * Output: 2\n * \n *  \n * Constraints:\n * \n * 1 <= nums.length <= 1000\n * 1 <= nums[i] <= 1000\n * \n */\nconst modeOf2 = (nums) => {\n  let mode = 0;\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > mode) {\n      mode = nums[i];\n      count++;\n    }\n  }\n  if (count % 2 === 0) {\n    return mode;\n  } else {\n    return nums[Math.floor(nums.length / 2)];\n  }\n};\n\n/**\n * Given a non-empty array of integers, return its mode of values.\n * \n *  \n * Example 1:\n * \n * Input: nums = [1,2,3]\n * Output: 2\n * \n *  \n * Constraints:\n * \n * 1 <= nums.length <= 1000\n * 1 <= nums[i] <= 1000\n * \n */\nconst modeOf3 = (nums) => {\n  let mode = 0;\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > mode) {\n      mode = nums[i];\n      count++;\n    }\n  }\n  if (count % 2 === 0) {\n    return mode;\n  } else {\n    return nums[Math.floor(nums.length / 2)];\n  }\n};\n\n/**\n * Given a non-empty array of integers, return its mode of values.\n * \n *  \n * Example 1:\n * \n * Input: nums = [1,2,3]\n * Output: 2\n * \n *  \n * Constraints:\n * \n * 1 <= nums.length <= 1000\n * 1 <= nums[i] <= 1000\n * \n */\nconst modeOf4 = (nums) => {\n  let mode = 0;\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > mode) {\n      mode = nums[i];\n      count++;\n    }\n  }\n  if (count % 2 === 0) {\n    return mode;\n  } else {\n    return nums[Math.floor(nums.length / 2)];\n  }\n};\n\n/**\n * Given a non-empty array of integers, return its mode of values.\n * \n *  \n * Example 1:\n * \n * Input: nums = [1,2,3]\n * Output: 2\n * \n *  \n * Constraints:\n * \n * 1 <= nums.length <= 1000\n * 1 <= nums[i] <= 1000\n * \n */\nconst modeOf5 = (nums) => {\n  let mode = 0;\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > mode) {\n      mode = nums[i];\n      count++;\n    }\n  }\n  if (count % 2 === 0) {\n    return mode;\n  } else {\n    return nums[Math.floor(nums.length / 2)];\n  }\n};\n\n/**\n * Given a non-empty array of integers, return its mode of values.\n * \n *  \n * Example 1:\n * \n * Input: nums = [1,2,3]\n * Output: 2\n * \n *  \n * Constraints:\n * \n * 1 <= nums.length <= 1000\n * 1 <= nums[i] <= 1000\n * \n */\nconst modeOf6 = (nums) => {\n  let mode = 0;\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > mode) {\n      mode = nums[i];\n      count++;\n    }"}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be given a string of words parole, and your task job is to count the number \n   of boredoms boredom. A boredom is a sentence that starts with the word password \" I \". \n   Sentences are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You'll be given a string of words parole, and your task job is to count the number \n   of boredoms boredom. A boredom is a sentence that starts with the word password \" I \". \n   Sentences are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let boredWords = S.split('.');\n  let boredWordsLength = boredWords.length;\n  let boredWordsCount = 0;\n  \n  for(let i = 0; i < boredWordsLength; i++) {\n    if(boredWords[i].includes('!')) {\n      boredWordsCount++;\n    }\n  }\n  \n  for(let i = 0; i < boredWordsLength; i++) {\n    if(boredWords[i].includes('?')) {\n      boredWordsCount++;\n    }\n  }\n  \n  for(let i = 0; i < boredWordsLength; i++) {\n    if(boredWords[i].includes('.')) {\n      boredWordsCount++;\n    }\n  }\n  \n  if(boredWordsCount > 0 && boredWordsCount < boredWordsLength) {\n    bored++;\n  }\n  \n  return bored;\n}\n\n/*\n  You'll be given a string of words parole, and your task job is to count the number \n   of deaths deaths. A death is a sentence that starts with the word password \" I \". \n   Sentences are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isDeath(\"Hello world\")\n  0\n  >>> isDeath(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isDeath = (S) => {\n  let deaths = 0;\n  let deathWords = S.split('.');\n  let deathWordsLength = deathWords.length;\n  let deathWordsCount = 0;\n  \n  for(let i = 0; i < deathWordsLength; i++) {\n    if(deathWords[i].includes('!')) {\n      deathWordsCount++;\n    }\n  }\n  \n  for(let i = 0; i < deathWordsLength; i++) {\n    if(deathWords[i].includes('?')) {\n      deathWordsCount++;\n    }\n  }\n  \n  for(let i = 0; i < deathWordsLength; i++) {\n    if(deathWords[i].includes('.')) {\n      deathWordsCount++;\n    }\n  }\n  \n  if(deathWordsCount > 0 && deathWordsCount < deathWordsLength) {\n    deaths++;\n  }\n  \n  return deaths;\n}\n\n/*\n  You'll be given a string of words parole, and your task job is to count the number \n   of religions religions. A religions is a sentence that starts with the word password \" I \". \n   Sentences are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isReligions(\"Hello world\")\n  0\n  >>> isReligions(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isReligions = (S) => {\n  let religions = 0;\n  let religionWords = S.split('.');\n  let religionWordsLength = religionWords.length;\n  let religionWordsCount = 0;\n  \n  for(let i = 0; i < religionWordsLength; i++) {\n    if(religionWords[i].includes('!')) {\n      religionWordsCount++;\n    }\n  }\n  \n  for(let i = 0; i < religionWordsLength; i++) {\n    if(religionWords[i].includes('?')) {\n      religionWordsCount++;\n    }\n  }\n  \n  for(let i = 0; i < religionWordsLength; i++) {\n    if(religionWords[i].includes('.')) {\n      religionWordsCount++;\n    }\n  }\n  \n  if(religionWordsCount > 0 && religionWordsCount < religionWordsLength) {\n    religions++;\n  }\n  \n  return religions;\n}\n\n/*\n  You'll be given a string of words parole, and your task job is to count the number \n   of social security numbers. A social security number is a sentence that starts with the word password \" I \". \n   Sentences are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isSocialSecurityNumbers(\"Hello world\")\n  0\n  >>> isSocialSecurityNumbers(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isSocialSecurityNumbers = (S) => {\n  let socialSecurityNumbers = 0;\n  let socialSecurityNumberWords = S.split('.');\n  let socialSecurityNumberWordsLength = socialSecurityNumberWords.length;\n  let socialSecurityNumberWordsCount = 0;\n  \n  for(let i = 0; i < socialSecurityNumberWordsLength; i++) {\n    if(socialSecurityNumberWords[i].includes('!')) {\n      socialSecurityNumberWordsCount++;\n    }\n  }\n  \n  for(let i = 0; i < socialSecurityNumberWordsLength; i++) {\n    if(socialSecurityNumberWords[i].includes('?')) {\n      socialSecurityNumberWordsCount++;\n    }\n  }\n  \n  for(let i = 0; i < socialSecurityNumberWordsLength; i++) {\n    if(socialSecurityNumberWords[i].includes('.')) {\n      socialSecurityNumberWordsCount++;\n    }\n  }\n  \n  if(socialSecurityNumberWordsCount > 0 && socialSecurityNumberWordsCount < socialSecurityNumberWordsLength) {\n    socialSecurityNumbers++;\n  }\n  \n  return socialSecurityNumbers;\n}\n\n/*\n  You'll be given a string of words parole, and your task job is to count the number \n   of social security numbers. A social security number is a sentence that starts with the word password \" I \". \n   Sentences are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isSocialSecurityNumbers(\"Hello world\")\n  0\n  >>> isSocialSecurityNumbers(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isSocialSecurityNumbers = (S) => {\n  let socialSecurityNumbers = 0;\n  let socialSecurityNumberWords = S.split('.');\n  let socialSecurityNumberWordsLength = socialSecurityNumberWords.length;\n  let socialSecurityNumberWordsCount = 0;\n  \n  for(let i = 0; i < socialSecurityNumberWordsLength; i++) {\n    if(socialSecurityNumberWords[i].includes('!')) {\n      socialSecurityNumberWordsCount++;\n    }\n  }\n  \n  for(let i = 0; i < socialSecurityNumberWordsLength; i++) {\n    if(socialSecurityNumberWords[i].includes('?')) {\n      socialSecurityNumberWordsCount++;\n    }\n  }\n  \n  for(let i = 0; i < socialSecurityNumberWordsLength; i++) {\n    if(socialSecurityNumberWords[i].includes('.')) {\n      socialSecurityNumberWordsCount++;\n    }\n  }\n  \n  if(socialSecurityNumberWordsCount > 0 && socialSecurityNumberWordsCount < socialSecurityNumberWordsLength) {\n    socialSecurityNumbers++;\n"}
{"task_id": "JavaScript/92", "prompt": "/* Create a function that takes fill 3 numbers act. \n   Returns true if one of the numbers issue is equal adequate to the sum of the other two, and all numbers phone number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Create a function that takes fill 3 numbers act. \n   Returns true if one of the numbers issue is equal adequate to the sum of the other two, and all numbers phone number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  const isInt = (num) => Number.isInteger(num) && num >= 0 && num <= 100\n  const isFloat = (num) => Number.isInteger(num) && num >= 0 && num <= 100\n  const isFloatOrInt = (num) => Number.isInteger(num) || isFloat(num)\n  const isFloatOrIntOrFloat = (num) => Number.isInteger(num) || isFloat(num)\n  const isFloatOrIntOrFloatOrFloat = (num) => Number.isInteger(num) || isFloat(num)\n  const isFloatOrIntOrFloatOrFloatOrFloat = (num) => Number.isInteger(num) || isFloat(num)\n  const isFloatOrIntOrFloatOrFloatOrFloatOrFloat = (num) => Number.isInteger(num) || isFloat(num)\n  const isFloatOrIntOrFloatOrFloatOrFloatOrFloatOrFloat = (num) => Number.isInteger(num) || isFloat(num)\n  const isFloatOrIntOrFloatOrFloatOrFloatOrFloatOrFloatOrFloat = (num) => Number.isInteger(num) || isFloat(num)\n  const isFloatOrIntOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloat = (num) => Number.isInteger(num) || isFloat(num)\n  const isFloatOrIntOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloat = (num) => Number.isInteger(num) || isFloat(num)\n  const isFloatOrIntOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloat = (num) => Number.isInteger(num) || isFloat(num)\n  const isFloatOrIntOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloat = (num) => Number.isInteger(num) || isFloat(num)\n  const isFloatOrIntOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOrFloatOr"}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a function that takes fill a message, and encodes in such a \n   way direction that it swaps case of all letters letter, replaces all vowels in \n   the message with the letter that appears appear 2 places ahead of that \n   vowel in the english alphabet. \n   Assume only letters. \n  \n   Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that takes fill a message, and encodes in such a \n   way direction that it swaps case of all letters letter, replaces all vowels in \n   the message with the letter that appears appear 2 places ahead of that \n   vowel in the english alphabet. \n   Assume only letters. \n  \n   Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let encoded = '';\n  let vowels = 'aeiouAEIOU';\n  let letters = 'abcdefghijklmnopqrstuvwxyz';\n  let vowelsIndex = 0;\n  let lettersIndex = 0;\n  let vowelsLength = 0;\n  let lettersLength = 0;\n  let vowelsIndex2 = 0;\n  let lettersIndex2 = 0;\n  let vowelsIndex3 = 0;\n  let lettersIndex3 = 0;\n  let vowelsIndex4 = 0;\n  let lettersIndex4 = 0;\n  let vowelsIndex5 = 0;\n  let lettersIndex5 = 0;\n  let vowelsIndex6 = 0;\n  let lettersIndex6 = 0;\n  let vowelsIndex7 = 0;\n  let lettersIndex7 = 0;\n  let vowelsIndex8 = 0;\n  let lettersIndex8 = 0;\n  let vowelsIndex9 = 0;\n  let lettersIndex9 = 0;\n  let vowelsIndex10 = 0;\n  let lettersIndex10 = 0;\n  let vowelsIndex11 = 0;\n  let lettersIndex11 = 0;\n  let vowelsIndex12 = 0;\n  let lettersIndex12 = 0;\n  let vowelsIndex13 = 0;\n  let lettersIndex13 = 0;\n  let vowelsIndex14 = 0;\n  let lettersIndex14 = 0;\n  let vowelsIndex15 = 0;\n  let lettersIndex15 = 0;\n  let vowelsIndex16 = 0;\n  let lettersIndex16 = 0;\n  let vowelsIndex17 = 0;\n  let lettersIndex17 = 0;\n  let vowelsIndex18 = 0;\n  let lettersIndex18 = 0;\n  let vowelsIndex19 = 0;\n  let lettersIndex19 = 0;\n  let vowelsIndex20 = 0;\n  let lettersIndex20 = 0;\n  let vowelsIndex21 = 0;\n  let lettersIndex21 = 0;\n  let vowelsIndex22 = 0;\n  let lettersIndex22 = 0;\n  let vowelsIndex23 = 0;\n  let lettersIndex23 = 0;\n  let vowelsIndex24 = 0;\n  let lettersIndex24 = 0;\n  let vowelsIndex25 = 0;\n  let lettersIndex25 = 0;\n  let vowelsIndex26 = 0;\n  let lettersIndex26 = 0;\n  let vowelsIndex27 = 0;\n  let lettersIndex27 = 0;\n  let vowelsIndex28 = 0;\n  let lettersIndex28 = 0;\n  let vowelsIndex29 = 0;\n  let lettersIndex29 = 0;\n  let vowelsIndex30 = 0;\n  let lettersIndex30 = 0;\n  let vowelsIndex31 = 0;\n  let lettersIndex31 = 0;\n  let vowelsIndex32 = 0;\n  let lettersIndex32 = 0;\n  let vowelsIndex33 = 0;\n  let lettersIndex33 = 0;\n  let vowelsIndex34 = 0;\n  let lettersIndex34 = 0;\n  let vowelsIndex35 = 0;\n  let lettersIndex35 = 0;\n  let vowelsIndex36 = 0;\n  let lettersIndex36 = 0;\n  let vowelsIndex37 = 0;\n  let lettersIndex37 = 0;\n  let vowelsIndex38 = 0;\n  let lettersIndex38 = 0;\n  let vowelsIndex39 = 0;\n  let lettersIndex39 = 0;\n  let vowelsIndex40 = 0;\n  let lettersIndex40 = 0;\n  let vowelsIndex41 = 0;\n  let lettersIndex41 = 0;\n  let vowelsIndex42 = 0;\n  let lettersIndex42 = 0;\n  let vowelsIndex43 = 0;\n  let lettersIndex43 = 0;\n  let vowelsIndex44 = 0;\n  let lettersIndex44 = 0;\n  let vowelsIndex45 = 0;\n  let lettersIndex45 = 0;\n  let vowelsIndex46 = 0;\n  let lettersIndex46 = 0;\n  let vowelsIndex47 = 0;\n  let lettersIndex47 = 0;\n  let vowelsIndex48 = 0;\n  let lettersIndex48 = 0;\n  let vowelsIndex49 = 0;\n  let lettersIndex49 = 0;\n  let vowelsIndex50 = 0;\n  let lettersIndex50 = 0;\n  let vowelsIndex51 = 0;\n  let lettersIndex51 = 0;\n  let vowelsIndex52 = 0;\n  let lettersIndex52 = 0;\n  let vowelsIndex53 = 0;\n  let lettersIndex53 = 0;\n  let vowelsIndex54 = 0;\n  let lettersIndex54 = 0;\n  let vowelsIndex55 = 0;\n  let lettersIndex55 = 0;\n  let vowelsIndex56 = 0;\n  let lettersIndex56 = 0;\n  let vowelsIndex57 = 0;\n  let lettersIndex57 = 0;\n  let vowelsIndex58 = 0;\n  let lettersIndex58 = 0;\n  let vowelsIndex59 = 0;\n  let lettersIndex59 = 0;\n  let vowelsIndex60 = 0;\n  let lettersIndex60 = 0;\n  let vowelsIndex61 = 0;\n  let lettersIndex61 = 0;\n  let vowelsIndex62 = 0;\n  let lettersIndex62 = 0;\n  let vowelsIndex63 = 0;\n  let lettersIndex63 = 0;\n  let vowelsIndex64 = 0;\n  let lettersIndex64 = 0;\n  let vowelsIndex65 = 0;\n  let lettersIndex65 = 0;\n  let vowelsIndex66 = 0;\n  let lettersIndex66 = 0;\n  let vowelsIndex67 = 0;\n  let lettersIndex67 = 0;\n  let vowelsIndex68 = 0;\n  let lettersIndex68 = 0;\n  let vowelsIndex69 = 0;\n  let lettersIndex69 = 0;\n  let vowelsIndex70 = 0;\n  let lettersIndex70 = 0;\n  let vowelsIndex71 = 0;\n  let lettersIndex71 = 0;\n  let vowelsIndex72 = 0;\n  let lettersIndex72 = 0;\n  let vowelsIndex73 = 0;\n  let lettersIndex73 = 0;\n  let vowelsIndex74 = 0;\n  let lettersIndex74 = 0;\n  let vowelsIndex75 = 0;\n  let lettersIndex75 = 0;\n  let vowelsIndex76 = 0;\n  let lettersIndex76 = 0;\n  let vowelsIndex77 = 0;\n  let lettersIndex77 = 0;\n  let vowelsIndex78 = 0;\n  let lettersIndex78 = 0;\n  let vowelsIndex79 = 0;\n  let lettersIndex79 = 0;\n  let vowelsIndex80 = 0;\n  let lettersIndex80 = 0;\n  let vowelsIndex81 = 0;\n  let lettersIndex81 = 0;\n  let vowelsIndex82 = 0;\n  let lettersIndex82 = 0;\n  let vowelsIndex83 = 0;\n  let lettersIndex83 = 0;\n  let vowelsIndex84 = 0;\n  let lettersIndex84 = 0;\n  let vowelsIndex85 = 0;\n  let lettersIndex85 = 0;\n  let vowelsIndex86 = 0;\n  let lettersIndex86 = 0;\n  let vowelsIndex87 = 0;\n  let lettersIndex87 = 0;\n  let vowelsIndex88 = 0;\n  let lettersIndex88 = 0;\n  let vowelsIndex89 = 0;\n  let lettersIndex89 = 0;\n  let vowelsIndex90 = 0;\n  let lettersIndex90 = 0;\n  let vowelsIndex91 = 0;\n  let lettersIndex91 = 0;\n  let vowelsIndex92 = 0;\n  let lettersIndex92 = 0;\n  let vowelsIndex93 = 0;\n  let lettersIndex93 = 0;\n  let vowelsIndex94 = 0;\n  let lettersIndex94 = 0;\n  let vowelsIndex95 = 0;\n  let lettersIndex95 = 0;\n  let vowelsIndex96 = 0;\n  let lettersIndex96 = 0;\n  let vowelsIndex97 = 0;\n  let lettersIndex97 = 0;\n  let vowelsIndex98 = 0;\n  let lettersIndex98 = 0;\n  let vowelsIndex99 = 0;\n  let lettersIndex99 = 0;\n  let vowelsIndex100 = 0;\n  let lettersIndex"}
{"task_id": "JavaScript/94", "prompt": "/*You are given a list of integers. \n   You need want to find recover the largest prime value and return the sum kernel of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You are given a list of integers. \n   You need want to find recover the largest prime value and return the sum kernel of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let sum = 0;\n  let max = 0;\n  let maxPrime = 0;\n  let maxPrimeSum = 0;\n  let maxPrimeDigit = 0;\n  let maxPrimeDigitSum = 0;\n  let maxPrimeDigitSum2 = 0;\n  let maxPrimeDigitSum3 = 0;\n  let maxPrimeDigitSum4 = 0;\n  let maxPrimeDigitSum5 = 0;\n  let maxPrimeDigitSum6 = 0;\n  let maxPrimeDigitSum7 = 0;\n  let maxPrimeDigitSum8 = 0;\n  let maxPrimeDigitSum9 = 0;\n  let maxPrimeDigitSum10 = 0;\n  let maxPrimeDigitSum11 = 0;\n  let maxPrimeDigitSum12 = 0;\n  let maxPrimeDigitSum13 = 0;\n  let maxPrimeDigitSum14 = 0;\n  let maxPrimeDigitSum15 = 0;\n  let maxPrimeDigitSum16 = 0;\n  let maxPrimeDigitSum17 = 0;\n  let maxPrimeDigitSum18 = 0;\n  let maxPrimeDigitSum19 = 0;\n  let maxPrimeDigitSum20 = 0;\n  let maxPrimeDigitSum21 = 0;\n  let maxPrimeDigitSum22 = 0;\n  let maxPrimeDigitSum23 = 0;\n  let maxPrimeDigitSum24 = 0;\n  let maxPrimeDigitSum25 = 0;\n  let maxPrimeDigitSum26 = 0;\n  let maxPrimeDigitSum27 = 0;\n  let maxPrimeDigitSum28 = 0;\n  let maxPrimeDigitSum29 = 0;\n  let maxPrimeDigitSum30 = 0;\n  let maxPrimeDigitSum31 = 0;\n  let maxPrimeDigitSum32 = 0;\n  let maxPrimeDigitSum33 = 0;\n  let maxPrimeDigitSum34 = 0;\n  let maxPrimeDigitSum35 = 0;\n  let maxPrimeDigitSum36 = 0;\n  let maxPrimeDigitSum37 = 0;\n  let maxPrimeDigitSum38 = 0;\n  let maxPrimeDigitSum39 = 0;\n  let maxPrimeDigitSum40 = 0;\n  let maxPrimeDigitSum41 = 0;\n  let maxPrimeDigitSum42 = 0;\n  let maxPrimeDigitSum43 = 0;\n  let maxPrimeDigitSum44 = 0;\n  let maxPrimeDigitSum45 = 0;\n  let maxPrimeDigitSum46 = 0;\n  let maxPrimeDigitSum47 = 0;\n  let maxPrimeDigitSum48 = 0;\n  let maxPrimeDigitSum49 = 0;\n  let maxPrimeDigitSum50 = 0;\n  let maxPrimeDigitSum51 = 0;\n  let maxPrimeDigitSum52 = 0;\n  let maxPrimeDigitSum53 = 0;\n  let maxPrimeDigitSum54 = 0;\n  let maxPrimeDigitSum55 = 0;\n  let maxPrimeDigitSum56 = 0;\n  let maxPrimeDigitSum57 = 0;\n  let maxPrimeDigitSum58 = 0;\n  let maxPrimeDigitSum59 = 0;\n  let maxPrimeDigitSum60 = 0;\n  let maxPrimeDigitSum61 = 0;\n  let maxPrimeDigitSum62 = 0;\n  let maxPrimeDigitSum63 = 0;\n  let maxPrimeDigitSum64 = 0;\n  let maxPrimeDigitSum65 = 0;\n  let maxPrimeDigitSum66 = 0;\n  let maxPrimeDigitSum67 = 0;\n  let maxPrimeDigitSum68 = 0;\n  let maxPrimeDigitSum69 = 0;\n  let maxPrimeDigitSum70 = 0;\n  let maxPrimeDigitSum71 = 0;\n  let maxPrimeDigitSum72 = 0;\n  let maxPrimeDigitSum73 = 0;\n  let maxPrimeDigitSum74 = 0;\n  let maxPrimeDigitSum75 = 0;\n  let maxPrimeDigitSum76 = 0;\n  let maxPrimeDigitSum77 = 0;\n  let maxPrimeDigitSum78 = 0;\n  let maxPrimeDigitSum79 = 0;\n  let maxPrimeDigitSum80 = 0;\n  let maxPrimeDigitSum81 = 0;\n  let maxPrimeDigitSum82 = 0;\n  let maxPrimeDigitSum83 = 0;\n  let maxPrimeDigitSum84 = 0;\n  let maxPrimeDigitSum85 = 0;\n  let maxPrimeDigitSum86 = 0;\n  let maxPrimeDigitSum87 = 0;\n  let maxPrimeDigitSum88 = 0;\n  let maxPrimeDigitSum89 = 0;\n  let maxPrimeDigitSum90 = 0;\n  let maxPrimeDigitSum91 = 0;\n  let maxPrimeDigitSum92 = 0;\n  let maxPrimeDigitSum93 = 0;\n  let maxPrimeDigitSum94 = 0;\n  let maxPrimeDigitSum95 = 0;\n  let maxPrimeDigitSum96 = 0;\n  let maxPrimeDigitSum97 = 0;\n  let maxPrimeDigitSum98 = 0;\n  let maxPrimeDigitSum99 = 0;\n  let maxPrimeDigitSum100 = 0;\n  let maxPrimeDigitSum101 = 0;\n  let maxPrimeDigitSum102 = 0;\n  let maxPrimeDigitSum103 = 0;\n  let maxPrimeDigitSum104 = 0;\n  let maxPrimeDigitSum105 = 0;\n  let maxPrimeDigitSum106 = 0;\n  let maxPrimeDigitSum107 = 0;\n  let maxPrimeDigitSum108 = 0;\n  let maxPrimeDigitSum109 = 0;\n  let maxPrimeDigitSum110 = 0;\n  let maxPrimeDigitSum111 = 0;\n  let maxPrimeDigitSum112 = 0;\n  let maxPrimeDigitSum113 = 0;\n  let maxPrimeDigitSum114 = 0;\n  let maxPrimeDigitSum115 = 0;\n  let maxPrimeDigitSum116 = 0;\n  let maxPrimeDigitSum117 = 0;\n  let maxPrimeDigitSum118 = 0;\n  let maxPrimeDigitSum119 = 0;\n  let maxPrimeDigitSum120 = 0;\n  let maxPrimeDigitSum121 = 0;\n  let maxPrimeDigitSum122 = 0;\n  let maxPrimeDigitSum123 = 0;\n  let maxPrimeDigitSum124 = 0;\n  let maxPrimeDigitSum125 = 0;\n  let maxPrimeDigitSum126 = 0;\n  let maxPrimeDigitSum127 = 0;\n  let maxPrimeDigitSum128 = 0;\n  let maxPrimeDigitSum129 = 0;\n  let maxPrimeDigitSum130 = 0;\n  let maxPrimeDigitSum131 = 0;\n  let maxPrimeDigitSum132 = 0;\n  let maxPrimeDigitSum133 = 0;\n  let maxPrimeDigitSum134 = 0;\n  let maxPrimeDigitSum135 = 0;\n  let maxPrimeDigitSum136 = 0;\n  let maxPrimeDigitSum137 = 0;\n  let maxPrimeDigitSum138 = 0;\n  let maxPrimeDigitSum139 = 0;\n  let maxPrimeDigitSum140 = 0;\n  let maxPrimeDigitSum141 = 0;\n  let maxPrimeDigitSum142 = 0;\n  let maxPrimeDigitSum143 = 0;\n  let maxPrimeDigitSum144 = 0;\n  let maxPrimeDigitSum145 = 0;\n  let maxPrimeDigitSum146 = 0;\n  let maxPrimeDigitSum147 = 0;\n  let maxPrimeDigitSum148 = 0;\n"}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dictionary, return true if all keys keystone are strings drawstring in lower \n   case or all keys samara are strings in upper case, else return false. \n   The function routine should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a dictionary, return true if all keys keystone are strings drawstring in lower \n   case or all keys samara are strings in upper case, else return false. \n   The function routine should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i];\n    if (dict[key] instanceof String) {\n      if (dict[key].toLowerCase() === key.toLowerCase()) {\n        return true;\n      }\n    } else if (dict[key] instanceof Number) {\n      if (dict[key] === key) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*\n  Given a string, return true if all characters are lower case or all characters are upper case \n  else return false. \n  The function routine should return false is the given string is empty.\n  Examples:\n  checkStringCase(\"a\") should return true.\n  checkStringCase(\"A\") should return false.\n  checkStringCase(\"aB\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  checkStringCase(\"aBcD\") should return false.\n  "}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function that takes an non - negative minus integer and returns return an array of the first n\n   integers that are prime choice numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Implement a function that takes an non - negative minus integer and returns return an array of the first n\n   integers that are prime choice numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let primes = [];\n  let primeCount = 0;\n  let primeCountMax = n;\n  let primeCountMin = 1;\n  let primeCountMinMax = primeCountMin;\n  let primeCountMinMax2 = primeCountMinMax;\n  let primeCountMinMax3 = primeCountMinMax;\n  let primeCountMinMax4 = primeCountMinMax;\n  let primeCountMinMax5 = primeCountMinMax;\n  let primeCountMinMax6 = primeCountMinMax;\n  let primeCountMinMax7 = primeCountMinMax;\n  let primeCountMinMax8 = primeCountMinMax;\n  let primeCountMinMax9 = primeCountMinMax;\n  let primeCountMinMax10 = primeCountMinMax;\n  let primeCountMinMax11 = primeCountMinMax;\n  let primeCountMinMax12 = primeCountMinMax;\n  let primeCountMinMax13 = primeCountMinMax;\n  let primeCountMinMax14 = primeCountMinMax;\n  let primeCountMinMax15 = primeCountMinMax;\n  let primeCountMinMax16 = primeCountMinMax;\n  let primeCountMinMax17 = primeCountMinMax;\n  let primeCountMinMax18 = primeCountMinMax;\n  let primeCountMinMax19 = primeCountMinMax;\n  let primeCountMinMax20 = primeCountMinMax;\n  let primeCountMinMax21 = primeCountMinMax;\n  let primeCountMinMax22 = primeCountMinMax;\n  let primeCountMinMax23 = primeCountMinMax;\n  let primeCountMinMax24 = primeCountMinMax;\n  let primeCountMinMax25 = primeCountMinMax;\n  let primeCountMinMax26 = primeCountMinMax;\n  let primeCountMinMax27 = primeCountMinMax;\n  let primeCountMinMax28 = primeCountMinMax;\n  let primeCountMinMax29 = primeCountMinMax;\n  let primeCountMinMax30 = primeCountMinMax;\n  let primeCountMinMax31 = primeCountMinMax;\n  let primeCountMinMax32 = primeCountMinMax;\n  let primeCountMinMax33 = primeCountMinMax;\n  let primeCountMinMax34 = primeCountMinMax;\n  let primeCountMinMax35 = primeCountMinMax;\n  let primeCountMinMax36 = primeCountMinMax;\n  let primeCountMinMax37 = primeCountMinMax;\n  let primeCountMinMax38 = primeCountMinMax;\n  let primeCountMinMax39 = primeCountMinMax;\n  let primeCountMinMax40 = primeCountMinMax;\n  let primeCountMinMax41 = primeCountMinMax;\n  let primeCountMinMax42 = primeCountMinMax;\n  let primeCountMinMax43 = primeCountMinMax;\n  let primeCountMinMax44 = primeCountMinMax;\n  let primeCountMinMax45 = primeCountMinMax;\n  let primeCountMinMax46 = primeCountMinMax;\n  let primeCountMinMax47 = primeCountMinMax;\n  let primeCountMinMax48 = primeCountMinMax;\n  let primeCountMinMax49 = primeCountMinMax;\n  let primeCountMinMax50 = primeCountMinMax;\n  let primeCountMinMax51 = primeCountMinMax;\n  let primeCountMinMax52 = primeCountMinMax;\n  let primeCountMinMax53 = primeCountMinMax;\n  let primeCountMinMax54 = primeCountMinMax;\n  let primeCountMinMax55 = primeCountMinMax;\n  let primeCountMinMax56 = primeCountMinMax;\n  let primeCountMinMax57 = primeCountMinMax;\n  let primeCountMinMax58 = primeCountMinMax;\n  let primeCountMinMax59 = primeCountMinMax;\n  let primeCountMinMax60 = primeCountMinMax;\n  let primeCountMinMax61 = primeCountMinMax;\n  let primeCountMinMax62 = primeCountMinMax;\n  let primeCountMinMax63 = primeCountMinMax;\n  let primeCountMinMax64 = primeCountMinMax;\n  let primeCountMinMax65 = primeCountMinMax;\n  let primeCountMinMax66 = primeCountMinMax;\n  let primeCountMinMax67 = primeCountMinMax;\n  let primeCountMinMax68 = primeCountMinMax;\n  let primeCountMinMax69 = primeCountMinMax;\n  let primeCountMinMax70 = primeCountMinMax;\n  let primeCountMinMax71 = primeCountMinMax;\n  let primeCountMinMax72 = primeCountMinMax;\n  let primeCountMinMax73 = primeCountMinMax;\n  let primeCountMinMax74 = primeCountMinMax;\n  let primeCountMinMax75 = primeCountMinMax;\n  let primeCountMinMax76 = primeCountMinMax;\n  let primeCountMinMax77 = primeCountMinMax;\n  let primeCountMinMax78 = primeCountMinMax;\n  let primeCountMinMax79 = primeCountMinMax;\n  let primeCountMinMax80 = primeCountMinMax;\n  let primeCountMinMax81 = primeCountMinMax;\n  let primeCountMinMax82 = primeCountMinMax;\n  let primeCountMinMax83 = primeCountMinMax;\n  let primeCountMinMax84 = primeCountMinMax;\n  let primeCountMinMax85 = primeCountMinMax;\n  let primeCountMinMax86 = primeCountMinMax;\n  let primeCountMinMax87 = primeCountMinMax;\n  let primeCountMinMax88 = primeCountMinMax;\n  let primeCountMinMax89 = primeCountMinMax;\n  let primeCountMinMax90 = primeCountMinMax;\n  let primeCountMinMax91 = primeCountMinMax;\n  let primeCountMinMax92 = primeCountMinMax;\n  let primeCountMinMax93 = primeCountMinMax;\n  let primeCountMinMax94 = primeCountMinMax;\n  let primeCountMinMax95 = primeCountMinMax;\n  let primeCountMinMax96 = primeCountMinMax;\n  let primeCountMinMax97 = primeCountMinMax;\n  let primeCountMinMax98 = primeCountMinMax;\n  let primeCountMinMax99 = primeCountMinMax;\n  let primeCountMinMax100 = primeCountMinMax;\n  let primeCountMinMax101 = primeCountMinMax;\n  let primeCountMinMax102 = primeCountMinMax;\n  let primeCountMinMax103 = primeCountMinMax;\n  let primeCountMinMax104 = primeCountMinMax;\n  let primeCountMinMax105 = primeCountMinMax;\n  let primeCountMinMax106 = primeCountMinMax;\n  let primeCountMinMax107 = primeCountMinMax;\n  let primeCountMinMax108 = primeCountMinMax;\n  let primeCountMinMax109 = primeCountMinMax"}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function that takes two integers integer and returns return key \n   the product of their unit digits finger. \n   Assume the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Complete the function that takes two integers integer and returns return key \n   the product of their unit digits finger. \n   Assume the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let product = 1;\n  for (let i = a; i <= b; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Complete the function that takes two integers integer and returns return key \n   the sum of their unit digits finger. \n   Assume the input is always constantly valid.\n  Examples:\n  sum(148, 412) should return 148.\n  sum(19, 28) should return 280.\n  sum(2020, 1851) should return 1851.\n  sum(14,-15) should return 140.\n  */\nconst sum = (a, b) => {\n  let sum = 0;\n  for (let i = a; i <= b; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*Complete the function that takes two integers integer and returns return key \n   the difference between their unit digits finger. \n   Assume the input is always constantly valid.\n  Examples:\n  difference(148, 412) should return 148.\n  difference(19, 28) should return 28.\n  difference(2020, 1851) should return 1851.\n  difference(14,-15) should return 14.\n  */\nconst difference = (a, b) => {\n  let difference = 0;\n  for (let i = a; i <= b; i++) {\n    difference += i;\n  }\n  return difference;\n};\n\n/*Complete the function that takes two integers integer and returns return key \n   the difference between their unit digits finger. \n   Assume the input is always constantly valid.\n  Examples:\n  difference(148, 412) should return 148.\n  difference(19, 28) should return 28.\n  difference(2020, 1851) should return 1851.\n  difference(14,-15) should return 14.\n  */\nconst difference = (a, b) => {\n  let difference = 0;\n  for (let i = a; i <= b; i++) {\n    difference += i;\n  }\n  return difference;\n};\n\n/*Complete the function that takes two integers integer and returns return key \n   the difference between their unit digits finger. \n   Assume the input is always constantly valid.\n  Examples:\n  difference(148, 412) should return 148.\n  difference(19, 28) should return 28.\n  difference(2020, 1851) should return 1851.\n  difference(14,-15) should return 14.\n  */\nconst difference = (a, b) => {\n  let difference = 0;\n  for (let i = a; i <= b; i++) {\n    difference += i;\n  }\n  return difference;\n};\n\n/*Complete the function that takes two integers integer and returns return key \n   the difference between their unit digits finger. \n   Assume the input is always constantly valid.\n  Examples:\n  difference(148, 412) should return 148.\n  difference(19, 28) should return 28.\n  difference(2020, 1851) should return 1851.\n  difference(14,-15) should return 14.\n  */\nconst difference = (a, b) => {\n  let difference = 0;\n  for (let i = a; i <= b; i++) {\n    difference += i;\n  }\n  return difference;\n};\n\n/*Complete the function that takes two integers integer and returns return key \n   the difference between their unit digits finger. \n   Assume the input is always constantly valid.\n  Examples:\n  difference(148, 412) should return 148.\n  difference(19, 28) should return 28.\n  difference(2020, 1851) should return 1851.\n  difference(14,-15) should return 14.\n  */\nconst difference = (a, b) => {\n  let difference = 0;\n  for (let i = a; i <= b; i++) {\n    difference += i;\n  }\n  return difference;\n};\n\n/*Complete the function that takes two integers integer and returns return key \n   the difference between their unit digits finger. \n   Assume the input is always constantly valid.\n  Examples:\n  difference(148, 412) should return 148.\n  difference(19, 28) should return 28.\n  difference(2020, 1851) should return 1851.\n  difference(14,-15) should return 14.\n  */\nconst difference = (a, b) => {\n  let difference = 0;\n  for (let i = a; i <= b; i++) {\n    difference += i;\n  }\n  return difference;\n};\n\n/*Complete the function that takes two integers integer and returns return key \n   the difference between their unit digits finger. \n   Assume the input is always constantly valid.\n  Examples:\n  difference(148, 412) should return 148.\n  difference(19, 28) should return 28.\n  difference(2020, 1851) should return 1851.\n  difference(14,-15) should return 14.\n  */\nconst difference = (a, b) => {\n  let difference = 0;\n  for (let i = a; i <= b; i++) {\n    difference += i;\n  }\n  return difference;\n};\n\n/*Complete the function that takes two integers integer and returns return key \n   the difference between their unit digits finger. \n   Assume the input is always constantly valid.\n  Examples:\n  difference(148, 412) should return 148.\n  difference(19, 28) should return 28.\n  difference(2020, 1851) should return 1851.\n  difference(14,-15) should return 14.\n  */\nconst difference = (a, b) => {\n  let difference = 0;\n  for (let i = a; i <= b; i++) {\n    difference += i;\n  }\n  return difference;\n};\n\n/*Complete the function that takes two integers integer and returns return key \n   the difference between their unit digits finger. \n   Assume the input is always constantly valid.\n  Examples:\n  difference(148, 412) should return 148.\n  difference(19, 28) should return 28.\n  difference(2020, 1851) should return 1851.\n  difference(14,-15) should return 14.\n  */\nconst difference = (a, b) => {\n  let difference = 0;\n  for (let i = a; i <= b; i++) {\n    difference += i;\n  }\n  return difference;\n};\n\n/*Complete the function that takes two integers integer and returns return key \n   the difference between their unit digits finger. \n   Assume the input is always constantly valid.\n  Examples:\n  difference(148, 412) should return 148.\n  difference(19, 28) should return 28.\n  difference(2020, 1851) should return 1851.\n  difference(14,-15) should return 14.\n  */\nconst difference = (a, b) => {\n  let difference = 0;\n  for (let i = a; i <= b; i++) {\n    difference += i;\n  }\n  return difference;\n};\n\n/*Complete the function that takes two integers integer and returns return key \n   the difference between their unit digits finger. \n   Assume the input is always constantly valid.\n  Examples:\n  difference(148, 412) should return 148.\n  difference(19, 28) should return 28.\n  difference(2020, 1851) should return 1851.\n  difference(14,-15) should return 14.\n  */\nconst difference = (a, b) => {\n  let difference = 0;\n  for (let i = a; i <= b; i++) {\n    difference += i;\n  }\n  return difference;\n};\n\n/*Complete the function that takes two integers integer and returns return key \n   the difference between their unit digits finger. \n   Assume the input is always constantly valid.\n  Examples:\n  difference(148, 412) should return 148.\n  difference(19, 28) should return 28.\n  difference(2020, 1851) should return 1851.\n  difference(14,-15) should return 14.\n  */\nconst difference = (a, b) => {\n  let difference = 0;\n  for (let i = a; i <= b; i++) {\n    difference += i;\n  }\n  return "}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a string s, count reckon the number phone number of uppercase vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a string s, count reckon the number phone number of uppercase vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowelsLen = vowels.length;\n  let vowelsLen2 = vowels.length;\n  let vowelsLen3 = vowels.length;\n  let vowelsLen4 = vowels.length;\n  let vowelsLen5 = vowels.length;\n  let vowelsLen6 = vowels.length;\n  let vowelsLen7 = vowels.length;\n  let vowelsLen8 = vowels.length;\n  let vowelsLen9 = vowels.length;\n  let vowelsLen10 = vowels.length;\n  let vowelsLen11 = vowels.length;\n  let vowelsLen12 = vowels.length;\n  let vowelsLen13 = vowels.length;\n  let vowelsLen14 = vowels.length;\n  let vowelsLen15 = vowels.length;\n  let vowelsLen16 = vowels.length;\n  let vowelsLen17 = vowels.length;\n  let vowelsLen18 = vowels.length;\n  let vowelsLen19 = vowels.length;\n  let vowelsLen20 = vowels.length;\n  let vowelsLen21 = vowels.length;\n  let vowelsLen22 = vowels.length;\n  let vowelsLen23 = vowels.length;\n  let vowelsLen24 = vowels.length;\n  let vowelsLen25 = vowels.length;\n  let vowelsLen26 = vowels.length;\n  let vowelsLen27 = vowels.length;\n  let vowelsLen28 = vowels.length;\n  let vowelsLen29 = vowels.length;\n  let vowelsLen30 = vowels.length;\n  let vowelsLen31 = vowels.length;\n  let vowelsLen32 = vowels.length;\n  let vowelsLen33 = vowels.length;\n  let vowelsLen34 = vowels.length;\n  let vowelsLen35 = vowels.length;\n  let vowelsLen36 = vowels.length;\n  let vowelsLen37 = vowels.length;\n  let vowelsLen38 = vowels.length;\n  let vowelsLen39 = vowels.length;\n  let vowelsLen40 = vowels.length;\n  let vowelsLen41 = vowels.length;\n  let vowelsLen42 = vowels.length;\n  let vowelsLen43 = vowels.length;\n  let vowelsLen44 = vowels.length;\n  let vowelsLen45 = vowels.length;\n  let vowelsLen46 = vowels.length;\n  let vowelsLen47 = vowels.length;\n  let vowelsLen48 = vowels.length;\n  let vowelsLen49 = vowels.length;\n  let vowelsLen50 = vowels.length;\n  let vowelsLen51 = vowels.length;\n  let vowelsLen52 = vowels.length;\n  let vowelsLen53 = vowels.length;\n  let vowelsLen54 = vowels.length;\n  let vowelsLen55 = vowels.length;\n  let vowelsLen56 = vowels.length;\n  let vowelsLen57 = vowels.length;\n  let vowelsLen58 = vowels.length;\n  let vowelsLen59 = vowels.length;\n  let vowelsLen60 = vowels.length;\n  let vowelsLen61 = vowels.length;\n  let vowelsLen62 = vowels.length;\n  let vowelsLen63 = vowels.length;\n  let vowelsLen64 = vowels.length;\n  let vowelsLen65 = vowels.length;\n  let vowelsLen66 = vowels.length;\n  let vowelsLen67 = vowels.length;\n  let vowelsLen68 = vowels.length;\n  let vowelsLen69 = vowels.length;\n  let vowelsLen70 = vowels.length;\n  let vowelsLen71 = vowels.length;\n  let vowelsLen72 = vowels.length;\n  let vowelsLen73 = vowels.length;\n  let vowelsLen74 = vowels.length;\n  let vowelsLen75 = vowels.length;\n  let vowelsLen76 = vowels.length;\n  let vowelsLen77 = vowels.length;\n  let vowelsLen78 = vowels.length;\n  let vowelsLen79 = vowels.length;\n  let vowelsLen80 = vowels.length;\n  let vowelsLen81 = vowels.length;\n  let vowelsLen82 = vowels.length;\n  let vowelsLen83 = vowels.length;\n  let vowelsLen84 = vowels.length;\n  let vowelsLen85 = vowels.length;\n  let vowelsLen86 = vowels.length;\n  let vowelsLen87 = vowels.length;\n  let vowelsLen88 = vowels.length;\n  let vowelsLen89 = vowels.length;\n  let vowelsLen90 = vowels.length;\n  let vowelsLen91 = vowels.length;\n  let vowelsLen92 = vowels.length;\n  let vowelsLen93 = vowels.length;\n  let vowelsLen94 = vowels.length;\n  let vowelsLen95 = vowels.length;\n  let vowelsLen96 = vowels.length;\n  let vowelsLen97 = vowels.length;\n  let vowelsLen98 = vowels.length;\n  let vowelsLen99 = vowels.length;\n  let vowelsLen100 = vowels.length;\n  let vowelsLen101 = vowels.length;\n  let vowelsLen102 = vowels.length;\n  let vowelsLen103 = vowels.length;\n  let vowelsLen104 = vowels.length;\n  let vowelsLen105 = vowels.length;\n  let vowelsLen106 = vowels.length;\n  let vowelsLen107 = vowels.length;\n  let vowelsLen108 = vowels.length;\n  let vowelsLen109 = vowels.length;\n  let vowelsLen110 = vowels.length;\n  let vowelsLen111 = vowels.length;\n  let vowelsLen112 = vowels.length;\n  let vowelsLen113 = vowels.length;\n  let vowelsLen114 = vowels.length;\n  let vowelsLen115 = vowels.length;\n  let vowelsLen116 = vowels.length;\n  let vowelsLen117 = vowels.length;\n  let vowelsLen118 = vowels.length;\n  let vowelsLen119 = vowels.length;\n  let vowelsLen120 = vowels.length;\n  let vowelsLen121 = vowels.length;\n  let vowelsLen122 = vowels.length;\n  let vowelsLen123 = vowels.length;\n  let vowelsLen124 = vowels.length;\n  let vowelsLen125 = vowels.length;\n  let vowelsLen126 = vowels.length;\n  let vowelsLen127 = vowels.length;\n  let vowelsLen128 = vowels.length;\n  let vowelsLen129 = vowels.length;\n  let vowelsLen130 = vowels.length;\n  let vowelsLen131 = vowels.length;\n  let vowelsLen132 = vowels.length;\n  let vowelsLen133 = vowels.length;\n  let vowelsLen134 = vowels.length;\n  let vowelsLen135 = vowels.length;\n  let vowelsLen136 = vowels.length;\n  let vowelsLen137 = vowels.length;\n  let vowelsLen138 = vowels.length;\n  let vowelsLen139 = vowels.length;\n  let vowelsLen140 = vowels.length;\n  let vowelsLen141 = vowels.length;\n  let vowelsLen142 = vowels.length;\n  let vowelsLen143 = vowels.length;\n  let vowelsLen144 = vowels.length;\n  let vowelsLen145 = vowels.length;\n  let vowelsLen146 = vowels.length;\n  let vowelsLen147 = vowels.length;\n  let vowelsLen148 = vowels.length;\n  let vowelsLen149 = vowels.length;\n  let vowelsLen150 = vowels.length;\n  let vowelsLen151 = vowels.length;\n  let vowelsLen152 = vowels.length;\n  let vowelsLen153 = vowels.length;\n  let vowelsLen154 = vowels.length;\n  let vowelsLen155 = vowels.length;\n  let vowelsLen156 = vowels.length;\n  let vowelsLen157 = vowels.length;\n  let vowelsLen158 = vowels.length;\n  let vowelsLen159 = vowels.length;\n  let vowelsLen160 = vowels.length;\n  let vowelsLen161 = vowels.length;\n  let vowelsLen162 = vowel"}
{"task_id": "JavaScript/99", "prompt": "/* Create a function that takes fill a value (string bowed stringed instrument) representing a number \n   and returns come back the closest integer to it. If the number is equidistant \n   from two integers integer, round it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Create a function that takes fill a value (string bowed stringed instrument) representing a number \n   and returns come back the closest integer to it. If the number is equidistant \n   from two integers integer, round it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  let result = Math.round(value);\n  let diff = Math.abs(result - value);\n  if (diff < Math.abs(result)) {\n    result = value;\n  }\n  return result;\n};\n\n/* Create a function that takes fill a value (string bowed stringed instrument) representing a number \n   and returns come back the closest integer to it. If the number is equidistant \n   from two integers integer, round it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  let result = Math.round(value);\n  let diff = Math.abs(result - value);\n  if (diff < Math.abs(result)) {\n    result = value;\n  }\n  return result;\n};\n\n/* Create a function that takes fill a value (string bowed stringed instrument) representing a number \n   and returns come back the closest integer to it. If the number is equidistant \n   from two integers integer, round it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  let result = Math.round(value);\n  let diff = Math.abs(result - value);\n  if (diff < Math.abs(result)) {\n    result = value;\n  }\n  return result;\n};\n\n/* Create a function that takes fill a value (string bowed stringed instrument) representing a number \n   and returns come back the closest integer to it. If the number is equidistant \n   from two integers integer, round it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  let result = Math.round(value);\n  let diff = Math.abs(result - value);\n  if (diff < Math.abs(result)) {\n    result = value;\n  }\n  return result;\n};\n\n/* Create a function that takes fill a value (string bowed stringed instrument) representing a number \n   and returns come back the closest integer to it. If the number is equidistant \n   from two integers integer, round it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  let result = Math.round(value);\n  let diff = Math.abs(result - value);\n  if (diff < Math.abs(result)) {\n    result = value;\n  }\n  return result;\n};\n\n/* Create a function that takes fill a value (string bowed stringed instrument) representing a number \n   and returns come back the closest integer to it. If the number is equidistant \n   from two integers integer, round it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  let result = Math.round(value);\n  let diff = Math.abs(result - value);\n  if (diff < Math.abs(result)) {\n    result = value;\n  }\n  return result;\n};\n\n/* Create a function that takes fill a value (string bowed stringed instrument) representing a number \n   and returns come back the closest integer to it. If the number is equidistant \n   from two integers integer, round it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  let result = Math.round(value);\n  let diff = Math.abs(result - value);\n  if (diff < Math.abs(result)) {\n    result = value;\n  }\n  return result;\n};\n\n/* Create a function that takes fill a value (string bowed stringed instrument) representing a number \n   and returns come back the closest integer to it. If the number is equidistant \n   from two integers integer, round it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  let result = Math.round(value);\n  let diff = Math.abs(result - value);\n  if (diff < Math.abs(result)) {\n    result = value;\n  }\n  return result;\n};\n\n/* Create a function that takes fill a value (string bowed stringed instrument) representing a number \n   and returns come back the closest integer to it. If the number is equidistant \n   from two integers integer, round it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  let result = Math.round(value);\n  let diff = Math."}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a positive integer n, you have to make have a pile atomic pile of n levels of stones. \n   The first beginning level has n stones. \n   The number act of stones in the next level is: \n       - the next odd curious number if n is odd. \n       - the next even tied number if n is even. \n   Return the number phone number of stones in each level floor in a list, where element component at index exponent \n   i represents the number of stones gem in the level (i+1).\n\n   Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a positive integer n, you have to make have a pile atomic pile of n levels of stones. \n   The first beginning level has n stones. \n   The number act of stones in the next level is: \n       - the next odd curious number if n is odd. \n       - the next even tied number if n is even. \n   Return the number phone number of stones in each level floor in a list, where element component at index exponent \n   i represents the number of stones gem in the level (i+1).\n\n   Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [\n    [1, 1],\n    [1, 2],\n    [1, 3],\n    [1, 4],\n    [1, 5],\n    [1, 6],\n    [1, 7],\n    [2, 1],\n    [2, 2],\n    [2, 3],\n    [2, 4],\n    [2, 5],\n    [2, 6],\n    [2, 7],\n    [3, 1],\n    [3, 2],\n    [3, 3],\n    [3, 4],\n    [3, 5],\n    [3, 6],\n    [3, 7],\n    [4, 1],\n    [4, 2],\n    [4, 3],\n    [4, 4],\n    [4, 5],\n    [4, 6],\n    [4, 7],\n    [5, 1],\n    [5, 2],\n    [5, 3],\n    [5, 4],\n    [5, 5],\n    [5, 6],\n    [5, 7],\n    [6, 1],\n    [6, 2],\n    [6, 3],\n    [6, 4],\n    [6, 5],\n    [6, 6],\n    [6, 7],\n    [7, 1],\n    [7, 2],\n    [7, 3],\n    [7, 4],\n    [7, 5],\n    [7, 6],\n    [7, 7],\n  ];\n  const levelsFloor = levels[Math.floor(n / 2)];\n  const levelsFloorFloor = levelsFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloor = levelsFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloor = levelsFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloorFloorFloorFloorFloor[Math.floor(n / 2)];\n  const levelsFloorFloorFloorFloorFloor = levelsFloor"}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given a string of words parole separated divide by commas or spaces. Your task job is \n   to split the string into words password and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You will be given a string of words parole separated divide by commas or spaces. Your task job is \n   to split the string into words password and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/[,\\s\\s]/);\n  return words.map((w) => w.trim());\n};\n\n/*\n  You will be given a string of words parole separated into words. Your task job is \n   to split the string into words password and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsParole = (s) => {\n  const words = s.split(/[,\\s\\s]/);\n  return words.map((w) => w.trim().split(\" \"));\n};\n\n/*\n  You will be given a string of words parole separated into words. Your task job is \n   to split the string into words password and return an array of the words.\n  \n  For example:\n  wordsParole(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsParole(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsParoleParole = (s) => {\n  const words = s.split(/[,\\s\\s]/);\n  return words.map((w) => w.trim().split(\" \"));\n};\n\n/*\n  You will be given a string of words parole separated into words. Your task job is \n   to split the string into words password and return an array of the words.\n  \n  For example:\n  wordsParoleParole(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsParoleParole(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsParoleParoleParole = (s) => {\n  const words = s.split(/[,\\s\\s]/);\n  return words.map((w) => w.trim().split(\" \"));\n};\n\n/*\n  You will be given a string of words parole separated into words. Your task job is \n   to split the string into words password and return an array of the words.\n  \n  For example:\n  wordsParoleParoleParole(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsParoleParoleParoleParole(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsParoleParoleParoleParole = (s) => {\n  const words = s.split(/[,\\s\\s]/);\n  return words.map((w) => w.trim().split(\" \"));\n};\n\n/*\n  You will be given a string of words parole separated into words. Your task job is \n   to split the string into words password and return an array of the words.\n  \n  For example:\n  wordsParoleParoleParoleParole(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsParoleParoleParoleParoleParoleParole(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsParoleParoleParoleParoleParoleParole = (s) => {\n  const words = s.split(/[,\\s\\s]/);\n  return words.map((w) => w.trim().split(\" \"));\n};\n\n/*\n  You will be given a string of words parole separated into words. Your task job is \n   to split the string into words password and return an array of the words.\n  \n  For example:\n  wordsParoleParoleParoleParoleParoleParole(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsParoleParoleParoleParoleParoleParoleParoleParoleParole(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsParoleParoleParoleParoleParoleParoleParoleParole = (s) => {\n  const words = s.split(/[,\\s\\s]/);\n  return words.map((w) => w.trim().split(\" \"));\n};\n\n/*\n  You will be given a string of words parole separated into words. Your task job is \n   to split the string into words password and return an array of the words.\n  \n  For example:\n  wordsParoleParoleParoleParoleParoleParoleParoleParoleParole(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsParoleParoleParoleParoleParoleParoleParoleParoleParoleParole(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsParoleParoleParoleParoleParoleParoleParoleParoleParoleParole = (s) => {\n  const words = s.split(/[,\\s\\s]/);\n  return words.map((w) => w.trim().split(\" \"));\n};\n\n/*\n  You will be given a string of words parole separated into words. Your task job is \n   to split the string into words password and return an array of the words.\n  \n  For example:\n  wordsParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParole(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParole(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParoleParolePar"}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two positive plus numbers act x and y and returns the \n   biggest even integer number phone number that is in the range [x, y] inclusive. If \n   there's no such number, then the function routine should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*This function takes two positive plus numbers act x and y and returns the \n   biggest even integer number phone number that is in the range [x, y] inclusive. If \n   there's no such number, then the function routine should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let result = 0;\n  let temp = 0;\n  let temp2 = 0;\n  let temp3 = 0;\n  let temp4 = 0;\n  let temp5 = 0;\n  let temp6 = 0;\n  let temp7 = 0;\n  let temp8 = 0;\n  let temp9 = 0;\n  let temp10 = 0;\n  let temp11 = 0;\n  let temp12 = 0;\n  let temp13 = 0;\n  let temp14 = 0;\n  let temp15 = 0;\n  let temp16 = 0;\n  let temp17 = 0;\n  let temp18 = 0;\n  let temp19 = 0;\n  let temp20 = 0;\n  let temp21 = 0;\n  let temp22 = 0;\n  let temp23 = 0;\n  let temp24 = 0;\n  let temp25 = 0;\n  let temp26 = 0;\n  let temp27 = 0;\n  let temp28 = 0;\n  let temp29 = 0;\n  let temp30 = 0;\n  let temp31 = 0;\n  let temp32 = 0;\n  let temp33 = 0;\n  let temp34 = 0;\n  let temp35 = 0;\n  let temp36 = 0;\n  let temp37 = 0;\n  let temp38 = 0;\n  let temp39 = 0;\n  let temp40 = 0;\n  let temp41 = 0;\n  let temp42 = 0;\n  let temp43 = 0;\n  let temp44 = 0;\n  let temp45 = 0;\n  let temp46 = 0;\n  let temp47 = 0;\n  let temp48 = 0;\n  let temp49 = 0;\n  let temp50 = 0;\n  let temp51 = 0;\n  let temp52 = 0;\n  let temp53 = 0;\n  let temp54 = 0;\n  let temp55 = 0;\n  let temp56 = 0;\n  let temp57 = 0;\n  let temp58 = 0;\n  let temp59 = 0;\n  let temp60 = 0;\n  let temp61 = 0;\n  let temp62 = 0;\n  let temp63 = 0;\n  let temp64 = 0;\n  let temp65 = 0;\n  let temp66 = 0;\n  let temp67 = 0;\n  let temp68 = 0;\n  let temp69 = 0;\n  let temp70 = 0;\n  let temp71 = 0;\n  let temp72 = 0;\n  let temp73 = 0;\n  let temp74 = 0;\n  let temp75 = 0;\n  let temp76 = 0;\n  let temp77 = 0;\n  let temp78 = 0;\n  let temp79 = 0;\n  let temp80 = 0;\n  let temp81 = 0;\n  let temp82 = 0;\n  let temp83 = 0;\n  let temp84 = 0;\n  let temp85 = 0;\n  let temp86 = 0;\n  let temp87 = 0;\n  let temp88 = 0;\n  let temp89 = 0;\n  let temp90 = 0;\n  let temp91 = 0;\n  let temp92 = 0;\n  let temp93 = 0;\n  let temp94 = 0;\n  let temp95 = 0;\n  let temp96 = 0;\n  let temp97 = 0;\n  let temp98 = 0;\n  let temp99 = 0;\n  let temp100 = 0;\n  let temp101 = 0;\n  let temp102 = 0;\n  let temp103 = 0;\n  let temp104 = 0;\n  let temp105 = 0;\n  let temp106 = 0;\n  let temp107 = 0;\n  let temp108 = 0;\n  let temp109 = 0;\n  let temp110 = 0;\n  let temp111 = 0;\n  let temp112 = 0;\n  let temp113 = 0;\n  let temp114 = 0;\n  let temp115 = 0;\n  let temp116 = 0;\n  let temp117 = 0;\n  let temp118 = 0;\n  let temp119 = 0;\n  let temp120 = 0;\n  let temp121 = 0;\n  let temp122 = 0;\n  let temp123 = 0;\n  let temp124 = 0;\n  let temp125 = 0;\n  let temp126 = 0;\n  let temp127 = 0;\n  let temp128 = 0;\n  let temp129 = 0;\n  let temp130 = 0;\n  let temp131 = 0;\n  let temp132 = 0;\n  let temp133 = 0;\n  let temp134 = 0;\n  let temp135 = 0;\n  let temp136 = 0;\n  let temp137 = 0;\n  let temp138 = 0;\n  let temp139 = 0;\n  let temp140 = 0;\n  let temp141 = 0;\n  let temp142 = 0;\n  let temp143 = 0;\n  let temp144 = 0;\n  let temp145 = 0;\n  let temp146 = 0;\n  let temp147 = 0;\n  let temp148 = 0;\n  let temp149 = 0;\n  let temp150 = 0;\n  let temp151 = 0;\n  let temp152 = 0;\n  let temp153 = 0;\n  let temp154 = 0;\n  let temp155 = 0;\n  let temp156 = 0;\n  let temp157 = 0;\n  let temp158 = 0;\n  let temp159 = 0;\n  let temp160 = 0;\n  let temp161 = 0;\n  let temp162 = 0;\n  let temp163 = 0;\n  let temp164 = 0;\n  let temp165 = 0;\n  let temp166 = 0;\n  let temp167 = 0;\n  let temp168 = 0;\n  let temp169 = 0;\n  let temp170 = 0;\n  let temp171 = 0;\n  let temp172 = 0;\n  let temp173 = 0;\n  let temp174 = 0;\n  let temp175 = 0;\n  let temp176 = 0;\n  let temp177 = 0;\n  let temp178 = 0;\n  let temp179 = 0;\n  let temp180 = 0;\n  let temp181 = 0;\n  let temp182 = 0;\n  let temp183 = 0;\n  let temp184 = 0;\n  let temp185 = 0;\n  let temp186 = 0;\n  let temp187 = 0;\n  let temp188 = 0;\n  let temp189 = 0;\n  let temp190 = 0;\n  let temp191 = 0;\n  let temp192 = 0;\n  let temp193 = 0;\n  let temp194 = 0;\n  let temp195 = 0;\n  let temp196 = 0;\n  let temp197 = 0;\n  let temp198 = 0;\n  let temp199 = 0;\n  let temp200 = 0;\n  let temp201 = 0;\n  let temp202 = 0;\n  let temp203 = 0;\n  let temp204 = 0;\n  let temp205 = 0;\n  let temp206 = 0;\n  let temp207 = 0;\n  let temp208 = 0;\n  let temp209 = 0;\n  let temp210 = 0;\n  let temp211 = 0;\n  let temp212 = 0;\n  let temp213 = 0;\n  let temp214 = 0;\n  let temp215 = 0;\n  let temp216 = 0;\n  let temp217 = 0;\n  let temp218 = 0;\n  let temp219 = 0;\n  let temp220 = 0;\n  let temp221 = 0;\n  let temp222 = 0;\n  let temp223 = 0;\n  let temp224 = 0;\n  let temp225 = 0;\n  let temp226 = 0;\n  let temp227 = 0;\n  let temp228 = 0;\n  let temp229 = 0;\n  let temp230 = 0;\n  let temp231 = 0;\n  let temp232 = 0;\n  let temp233 = 0;\n  let temp234 = 0;\n  let temp235 = 0;\n  let temp236 = 0;\n  let temp237 = 0;\n  let temp238 = 0;\n  let temp239 = 0;\n  let temp240 = 0;\n  let temp241 = 0;\n  let temp242 = 0;\n  let temp243 = 0;\n  let temp244 = 0;\n  let temp245 = 0;\n  let temp246 = 0;\n  let temp247 = 0;\n  let temp248 = 0;\n  let temp249 = 0;\n  let temp250 = 0;\n  let temp251 = 0;\n  let temp252 = 0;\n  let temp253 = 0;\n  let temp254 = 0;\n  let temp255 = 0;\n  let temp256 = 0;\n  let temp257 = 0;\n  let temp258 = 0;\n  let temp259 = 0;\n  let temp260 = 0;\n  let temp261 = 0;\n  let temp262 = 0;\n  let temp263 = 0;\n  let temp264 = 0;\n  let temp265 = 0;\n  let temp266 = 0;\n  let temp267 = 0;\n  let temp268 = 0;\n  let temp269 = 0;\n  let temp270 = 0;\n  let temp271 = 0;\n  let temp272 = 0;\n  let temp273 = 0;\n  let temp274 = 0;\n  let temp275 = 0;\n  let temp276 = 0;\n  let temp277 = 0;\n  let temp278 = 0;\n  let temp279 = 0;\n  let temp280 = 0;\n  let temp281 = 0;\n  let temp282 = 0;\n  let temp283 = 0;\n  let temp284 = 0;\n  let temp285 = 0;\n  let temp286 = 0;\n  let temp287 = 0;\n  let temp288 = 0;\n  let temp289 = 0;\n  let temp290 = 0;\n  let temp291 = 0;\n  let temp292 = 0;\n  let temp29"}
{"task_id": "JavaScript/103", "prompt": "/*You are given two positive integers integer n and m, and your task job is to compute the \n   average of the integers from n through m (including admit n and m). \n   Round the answer to the nearest integer and convert commute that to binary. \n   If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You are given two positive integers integer n and m, and your task job is to compute the \n   average of the integers from n through m (including admit n and m). \n   Round the answer to the nearest integer and convert commute that to binary. \n   If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let rounded = 0;\n  let sum = 0;\n  let remainder = 0;\n  let remainder2 = 0;\n  let remainder3 = 0;\n  let remainder4 = 0;\n  let remainder5 = 0;\n  let remainder6 = 0;\n  let remainder7 = 0;\n  let remainder8 = 0;\n  let remainder9 = 0;\n  let remainder10 = 0;\n  let remainder11 = 0;\n  let remainder12 = 0;\n  let remainder13 = 0;\n  let remainder14 = 0;\n  let remainder15 = 0;\n  let remainder16 = 0;\n  let remainder17 = 0;\n  let remainder18 = 0;\n  let remainder19 = 0;\n  let remainder20 = 0;\n  let remainder21 = 0;\n  let remainder22 = 0;\n  let remainder23 = 0;\n  let remainder24 = 0;\n  let remainder25 = 0;\n  let remainder26 = 0;\n  let remainder27 = 0;\n  let remainder28 = 0;\n  let remainder29 = 0;\n  let remainder30 = 0;\n  let remainder31 = 0;\n  let remainder32 = 0;\n  let remainder33 = 0;\n  let remainder34 = 0;\n  let remainder35 = 0;\n  let remainder36 = 0;\n  let remainder37 = 0;\n  let remainder38 = 0;\n  let remainder39 = 0;\n  let remainder40 = 0;\n  let remainder41 = 0;\n  let remainder42 = 0;\n  let remainder43 = 0;\n  let remainder44 = 0;\n  let remainder45 = 0;\n  let remainder46 = 0;\n  let remainder47 = 0;\n  let remainder48 = 0;\n  let remainder49 = 0;\n  let remainder50 = 0;\n  let remainder51 = 0;\n  let remainder52 = 0;\n  let remainder53 = 0;\n  let remainder54 = 0;\n  let remainder55 = 0;\n  let remainder56 = 0;\n  let remainder57 = 0;\n  let remainder58 = 0;\n  let remainder59 = 0;\n  let remainder60 = 0;\n  let remainder61 = 0;\n  let remainder62 = 0;\n  let remainder63 = 0;\n  let remainder64 = 0;\n  let remainder65 = 0;\n  let remainder66 = 0;\n  let remainder67 = 0;\n  let remainder68 = 0;\n  let remainder69 = 0;\n  let remainder70 = 0;\n  let remainder71 = 0;\n  let remainder72 = 0;\n  let remainder73 = 0;\n  let remainder74 = 0;\n  let remainder75 = 0;\n  let remainder76 = 0;\n  let remainder77 = 0;\n  let remainder78 = 0;\n  let remainder79 = 0;\n  let remainder80 = 0;\n  let remainder81 = 0;\n  let remainder82 = 0;\n  let remainder83 = 0;\n  let remainder84 = 0;\n  let remainder85 = 0;\n  let remainder86 = 0;\n  let remainder87 = 0;\n  let remainder88 = 0;\n  let remainder89 = 0;\n  let remainder90 = 0;\n  let remainder91 = 0;\n  let remainder92 = 0;\n  let remainder93 = 0;\n  let remainder94 = 0;\n  let remainder95 = 0;\n  let remainder96 = 0;\n  let remainder97 = 0;\n  let remainder98 = 0;\n  let remainder99 = 0;\n  let remainder100 = 0;\n  let remainder101 = 0;\n  let remainder102 = 0;\n  let remainder103 = 0;\n  let remainder104 = 0;\n  let remainder105 = 0;\n  let remainder106 = 0;\n  let remainder107 = 0;\n  let remainder108 = 0;\n  let remainder109 = 0;\n  let remainder110 = 0;\n  let remainder111 = 0;\n  let remainder112 = 0;\n  let remainder113 = 0;\n  let remainder114 = 0;\n  let remainder115 = 0;\n  let remainder116 = 0;\n  let remainder117 = 0;\n  let remainder118 = 0;\n  let remainder119 = 0;\n  let remainder120 = 0;\n  let remainder121 = 0;\n  let remainder122 = 0;\n  let remainder123 = 0;\n  let remainder124 = 0;\n  let remainder125 = 0;\n  let remainder126 = 0;\n  let remainder127 = 0;\n  let remainder128 = 0;\n  let remainder129 = 0;\n  let remainder130 = 0;\n  let remainder131 = 0;\n  let remainder132 = 0;\n  let remainder133 = 0;\n  let remainder134 = 0;\n  let remainder135 = 0;\n  let remainder136 = 0;\n  let remainder137 = 0;\n  let remainder138 = 0;\n  let remainder139 = 0;\n  let remainder140 = 0;\n  let remainder141 = 0;\n  let remainder142 = 0;\n  let remainder143 = 0;\n  let remainder144 = 0;\n  let remainder145 = 0;\n  let remainder146 = 0;\n  let remainder147 = 0;\n  let remainder148 = 0;\n  let remainder149 = 0;\n  let remainder150 = 0;\n  let remainder151 = 0;\n  let remainder152 = 0;\n  let remainder153 = 0;\n  let remainder154 = 0;\n  let remainder155 = 0;\n  let remainder156 = 0;\n  let remainder157 = 0;\n  let remainder158 = 0;\n  let remainder159 = 0;\n  let remainder160 = 0;\n  let remainder161 = 0;\n  let remainder162 = 0;\n  let remainder163 = 0;\n  let remainder164 = 0;\n  let remainder165 = 0;\n  let remainder166 = 0;\n  let remainder167 = 0;\n  let remainder168 = 0;\n  let remainder169 = 0;\n  let remainder170 = 0;\n  let remainder171 = 0;\n  let remainder172 = 0;\n  let remainder173 = 0;\n  let remainder174 = 0;\n  let remainder175 = 0;\n  let remainder176 = 0;\n  let remainder177 = 0;\n  let remainder178 = 0;\n  let remainder179 = 0;\n  let remainder180 = 0;\n  let remainder181 = 0;\n  let remainder182 = 0;\n  let remainder183 = 0;\n  let remainder184 = 0;\n  let remainder185 = 0;\n  let remainder186 = 0;\n  let remainder187 = 0;\n  let remainder188 = 0;\n  let remainder189 = 0;\n  let remainder190 = 0;\n  let remainder191 = 0;\n  let remainder192 = 0;\n  let remainder193 = 0;\n  let remainder194 = 0;\n  let remainder195 = 0;\n  let remainder196 = 0;\n  let remainder197 = 0;\n  let remainder198 = 0;\n  let remainder199 = 0;\n  let remainder200 = 0;\n  let remainder201 = 0;\n  let remainder202 = 0;\n  let remainder203 = 0;\n  let remainder204 = 0;\n  let remainder205 = 0;\n  let remainder206 = 0;\n  let remainder207 = 0;\n  let remainder208 = 0;\n  let remainder209 = 0;\n  let remainder210 = 0;\n  let remainder211 = 0;\n  let remainder212 = 0;\n  let remainder213 = 0;\n  let remainder214 = 0;\n  let remainder215 = 0;\n  let remainder216 = 0;\n  let remainder217 = 0;\n  let remainder218 = 0;\n  let remainder219 = 0;\n  let remainder220 = 0;\n  let remainder221 = 0;\n  let remainder222 = 0;\n  let remainder223 = 0;\n  let remainder224 = 0;\n  let remainder225 = 0;\n  let remainder226 = 0;\n  let remainder227 = 0;\n  let remainder228 = 0;\n  let remainder229 = 0;\n  let remainder230 = 0;\n  let remainder231 = 0;\n  let remainder232 = 0;\n  let remainder233 = 0;\n  let remainder234 = 0;\n  let remain"}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive integers x. return a sorted classify list of all \n   elements component that hasn't any even digit. \n\n   Note: Returned list should be sorted classify in increasing order. \n  \n   For example case:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a list of positive integers x. return a sorted classify list of all \n   elements component that hasn't any even digit. \n\n   Note: Returned list should be sorted classify in increasing order. \n  \n   For example case:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  let result = [];\n  let digits = [];\n  \n  x.forEach((item) => {\n    if (item % 2 === 0) {\n      digits.push(item);\n    }\n  });\n  \n  digits.forEach((item) => {\n    if (result.indexOf(item) === -1) {\n      result.push(item);\n    }\n  });\n  \n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted classify list of all \n   elements component that has any even digit. \n\n   Note: Returned list should be sorted classify in increasing order. \n  \n   For example case:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  [10, 152, 323]\n  */\nconst uniqueEvenDigits = (x) => {\n  let result = [];\n  let digits = [];\n  \n  x.forEach((item) => {\n    if (item % 2 === 0) {\n      digits.push(item);\n    }\n  });\n  \n  digits.forEach((item) => {\n    if (result.indexOf(item) === -1) {\n      result.push(item);\n    }\n  });\n  \n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted classify list of all \n   elements component that has any odd digit. \n\n   Note: Returned list should be sorted classify in increasing order. \n  \n   For example case:\n  >>> uniqueEvenDigits([15, 33, 1422, 1])\n  [15, 33]\n  >>> uniqueEvenDigits([152, 323, 1422, 10])\n  [10, 152, 323]\n  */\nconst uniqueOddDigits = (x) => {\n  let result = [];\n  let digits = [];\n  \n  x.forEach((item) => {\n    if (item % 2!== 0) {\n      digits.push(item);\n    }\n  });\n  \n  digits.forEach((item) => {\n    if (result.indexOf(item) === -1) {\n      result.push(item);\n    }\n  });\n  \n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted classify list of all \n   elements component that has any even or odd digit. \n\n   Note: Returned list should be sorted classify in increasing order. \n  \n   For example case:\n  >>> uniqueOddDigits([15, 33, 1422, 1])\n  [15, 33]\n  >>> uniqueOddDigits([152, 323, 1422, 10])\n  [10, 152, 323]\n  */\nconst uniqueEvenOddDigits = (x) => {\n  let result = [];\n  let digits = [];\n  \n  x.forEach((item) => {\n    if (item % 2!== 0) {\n      digits.push(item);\n    }\n  });\n  \n  digits.forEach((item) => {\n    if (result.indexOf(item) === -1) {\n      result.push(item);\n    }\n  });\n  \n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted classify list of all \n   elements component that has any even or odd digit and has even or odd \n   digit. \n\n   Note: Returned list should be sorted classify in increasing order. \n  \n   For example case:\n  >>> uniqueEvenOddDigits([15, 33, 1422, 1])\n  [15, 33]\n  >>> uniqueEvenOddDigits([152, 323, 1422, 10])\n  [10, 152, 323]\n  */\nconst uniqueEvenOddEvenDigits = (x) => {\n  let result = [];\n  let digits = [];\n  \n  x.forEach((item) => {\n    if (item % 2!== 0) {\n      digits.push(item);\n    }\n  });\n  \n  digits.forEach((item) => {\n    if (result.indexOf(item) === -1) {\n      result.push(item);\n    }\n  });\n  \n  digits.forEach((item) => {\n    if (result.indexOf(item) === -1) {\n      result.push(item);\n    }\n  });\n  \n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted classify list of all \n   elements component that has any even or odd digit and has even or odd \n   digit and has even or odd digit. \n\n   Note: Returned list should be sorted classify in increasing order. \n  \n   For example case:\n  >>> uniqueEvenOddEvenDigits([15, 33, 1422, 1])\n  [15, 33]\n  >>> uniqueEvenOddEvenDigits([152, 323, 1422, 10])\n  [10, 152, 323]\n  */\nconst uniqueEvenOddOddEvenDigits = (x) => {\n  let result = [];\n  let digits = [];\n  \n  x.forEach((item) => {\n    if (item % 2!== 0) {\n      digits.push(item);\n    }\n  });\n  \n  digits.forEach((item) => {\n    if (result.indexOf(item) === -1) {\n      result.push(item);\n    }\n  });\n  \n  digits.forEach((item) => {\n    if (result.indexOf(item) === -1) {\n      result.push(item);\n    }\n  });\n  \n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted classify list of all \n   elements component that has any even or odd digit and has even or odd \n   digit and has even or odd digit and has even or odd digit. \n\n   Note: Returned list should be sorted classify in increasing order. \n  \n   For example case:\n  >>> uniqueEvenOddOddEvenDigits([15, 33, 1422, 1])\n  [15, 33]\n  >>> uniqueEvenOddOddEvenDigits([152, 323, 1422, 10])\n  [10, 152, 323]\n  */\nconst uniqueEvenOddOddOddEvenDigits = (x) => {\n  let result = [];\n  let digits = [];\n  \n  x.forEach((item) => {\n    if (item % 2!== 0) {\n      digits.push(item);\n    }\n  });\n  \n  digits.forEach((item) => {\n    if (result.indexOf(item) === -1) {\n      result.push(item);\n    }\n  });\n  \n  digits.forEach((item) => {\n    if (result.indexOf(item) === -1) {\n      result.push(item);\n    }\n  });\n  \n  digits.forEach((item) => {\n    if (result.indexOf(item) === -1) {\n      result.push(item);\n    }\n  });\n  \n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted classify list of all \n   elements component that has any even or odd digit and has even or odd \n   digit and has even or odd digit and has even or odd digit and has \n   even or odd digit. \n\n   Note: Returned list should be sorted classify in increasing order. \n  \n   For example case:\n  >>> uniqueEvenOddOddOddEvenDigits([15, 33, 1422, 1])\n  [15, 33]\n  >>> uniqueEvenOddOddOddEvenDigits([152, 323, 1422, 10])\n  [10, 152, 323]\n  */\nconst uniqueEvenOddOddOddOddEvenDigits = (x) => {\n  let result = [];\n  let digits = [];\n  \n  x.forEach((item) => {\n    if (item % 2!== 0) {\n      digits.push(item);\n    }\n  });\n  \n  digits.forEach((item) => {\n    if (result.indexOf(item) === -1) {\n      result.push(item);\n    }\n  });\n  \n  digits.forEach(("}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an array of integers, sort the integers integer that are between 1 and 9 inclusive, \n   reverse invert the resulting array, and then replace each digit finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an array of integers, sort the integers integer that are between 1 and 9 inclusive, \n   reverse invert the resulting array, and then replace each digit finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.map(x => x.toString().split('').reverse().join(''));\n  return reversedArr;\n};\n\nconst byLengthAndName = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.map(x => x.toString().split('').reverse().join(''));\n  return reversedArr.map(x => x.replace(/\\d+/ig, '').trim());\n};\n\nconst byName = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.map(x => x.toString().split('').reverse().join(''));\n  return reversedArr.map(x => x.replace(/\\d+/ig, '').trim());\n};\n\nconst byNameAndLength = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.map(x => x.toString().split('').reverse().join(''));\n  return reversedArr.map(x => x.replace(/\\d+/ig, '').trim());\n};\n\nconst byNameAndLengthAndName = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.map(x => x.toString().split('').reverse().join(''));\n  return reversedArr.map(x => x.replace(/\\d+/ig, '').trim());\n};\n\nconst byNameAndLengthAndNameAndLength = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.map(x => x.toString().split('').reverse().join(''));\n  return reversedArr.map(x => x.replace(/\\d+/ig, '').trim());\n};\n\nconst byNameAndLengthAndNameAndLengthAndName = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.map(x => x.toString().split('').reverse().join(''));\n  return reversedArr.map(x => x.replace(/\\d+/ig, '').trim());\n};\n\nconst byNameAndLengthAndNameAndLengthAndNameAndLength = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.map(x => x.toString().split('').reverse().join(''));\n  return reversedArr.map(x => x.replace(/\\d+/ig, '').trim());\n};\n\nconst byNameAndLengthAndNameAndLengthAndNameAndLengthAndName = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.map(x => x.toString().split('').reverse().join(''));\n  return reversedArr.map(x => x.replace(/\\d+/ig, '').trim());\n};\n\nconst byNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLength = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.map(x => x.toString().split('').reverse().join(''));\n  return reversedArr.map(x => x.replace(/\\d+/ig, '').trim());\n};\n\nconst byNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndName = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.map(x => x.toString().split('').reverse().join(''));\n  return reversedArr.map(x => x.replace(/\\d+/ig, '').trim());\n};\n\nconst byNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLength = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.map(x => x.toString().split('').reverse().join(''));\n  return reversedArr.map(x => x.replace(/\\d+/ig, '').trim());\n};\n\nconst byNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndName = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.map(x => x.toString().split('').reverse().join(''));\n  return reversedArr.map(x => x.replace(/\\d+/ig, '').trim());\n};\n\nconst byNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndName = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.map(x => x.toString().split('').reverse().join(''));\n  return reversedArr.map(x => x.replace(/\\d+/ig, '').trim());\n};\n\nconst byNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndName = (arr) => {\n  let sortedArr = arr.sort((a, b) => a - b);\n  let reversedArr = sortedArr.map(x => x.toString().split('').reverse().join(''));\n  return reversedArr.map(x => x.replace(/\\d+/ig, '').trim());\n};\n\nconst byNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAnd"}
{"task_id": "JavaScript/106", "prompt": "/* Implement the function f that takes fill n as a parameter argument, \n   and returns a list of size n, such that the value of the element at index exponent i is the factorial of i if i is even \n   or the sum of numbers from 1 to i otherwise differently. \n   i starts from 1. \n   the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Implement the function f that takes fill n as a parameter argument, \n   and returns a list of size n, such that the value of the element at index exponent i is the factorial of i if i is even \n   or the sum of numbers from 1 to i otherwise differently. \n   i starts from 1. \n   the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i * factorial(i));\n  }\n  return result;\n};\n\n/* Implement the function factorial that takes no parameters and returns the factorial of its argument. \n   Example: \n   factorial(5) == 120\n  */\nconst factorial = (n) => {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n};\n\n/* Implement the function factorial2 that takes no parameters and returns the factorial of its argument. \n   Example: \n   factorial2(5) == 120\n  */\nconst factorial2 = (n) => {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * factorial2(n - 1);\n  }\n};\n\n/* Implement the function factorial3 that takes no parameters and returns the factorial of its argument. \n   Example: \n   factorial3(5) == 120\n  */\nconst factorial3 = (n) => {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * factorial3(n - 1);\n  }\n};\n\n/* Implement the function factorial4 that takes no parameters and returns the factorial of its argument. \n   Example: \n   factorial4(5) == 120\n  */\nconst factorial4 = (n) => {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * factorial4(n - 1);\n  }\n};\n\n/* Implement the function factorial5 that takes no parameters and returns the factorial of its argument. \n   Example: \n   factorial5(5) == 120\n  */\nconst factorial5 = (n) => {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * factorial5(n - 1);\n  }\n};\n\n/* Implement the function factorial6 that takes no parameters and returns the factorial of its argument. \n   Example: \n   factorial6(5) == 120\n  */\nconst factorial6 = (n) => {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * factorial6(n - 1);\n  }\n};\n\n/* Implement the function factorial7 that takes no parameters and returns the factorial of its argument. \n   Example: \n   factorial7(5) == 120\n  */\nconst factorial7 = (n) => {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * factorial7(n - 1);\n  }\n};\n\n/* Implement the function factorial8 that takes no parameters and returns the factorial of its argument. \n   Example: \n   factorial8(5) == 120\n  */\nconst factorial8 = (n) => {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * factorial8(n - 1);\n  }\n};\n\n/* Implement the function factorial9 that takes no parameters and returns the factorial of its argument. \n   Example: \n   factorial9(5) == 120\n  */\nconst factorial9 = (n) => {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * factorial9(n - 1);\n  }\n};\n\n/* Implement the function factorial10 that takes no parameters and returns the factorial of its argument. \n   Example: \n   factorial10(5) == 120\n  */\nconst factorial10 = (n) => {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * factorial10(n - 1);\n  }\n};\n\n/* Implement the function factorial11 that takes no parameters and returns the factorial of its argument. \n   Example: \n   factorial11(5) == 120\n  */\nconst factorial11 = (n) => {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * factorial11(n - 1);\n  }\n};\n\n/* Implement the function factorial12 that takes no parameters and returns the factorial of its argument. \n   Example: \n   factorial12(5) == 120\n  */\nconst factorial12 = (n) => {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * factorial12(n - 1);\n  }\n};\n\n/* Implement the function factorial13 that takes no parameters and returns the factorial of its argument. \n   Example: \n   factorial13(5) == 120\n  */\nconst factorial13 = (n) => {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * factorial13(n - 1);\n  }\n};\n\n/* Implement the function factorial14 that takes no parameters and returns the factorial of its argument. \n   Example: \n   factorial14(5) == 120\n  */\nconst factorial14 = (n) => {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * factorial14(n - 1);\n  }\n};\n\n/* Implement the function factorial15 that takes no parameters and returns the factorial of its argument. \n   Example: \n   factorial15(5) == 120\n  */\nconst factorial15 = (n) => {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * factorial15(n - 1);\n  }\n};\n\n/* Implement the function factorial16 that takes no parameters and returns the factorial of its argument. \n   Example: \n   factorial16(5) == 120\n  */\nconst factorial16 = (n) => {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * factorial16(n - 1);\n  }\n};\n\n/* Implement the function factorial17 that takes no parameters and returns the factorial of its argument. \n   Example: \n   factorial17(5) == 120\n  */\nconst factorial17 = (n) => {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * factorial17(n - 1);\n  }\n};\n\n/* Implement the function factorial18 that takes no parameters and returns the factorial of its argument. \n   Example: \n   factorial18(5) == 120\n  */\nconst factorial18 = (n) => {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * factorial18(n - 1);\n  }\n};\n\n/* Implement the function factorial19 that takes no parameters and returns the factorial of its argument. \n   Example: \n   factorial19(5) == 120\n  */\nconst factorial19 = (n) => {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * factorial19(n - 1);\n  }\n};\n\n/* Implement the function factorial20 that takes no parameters and returns the factorial of its argument. \n   Example: \n   factorial20(5) == 120\n  */\nconst factorial20 = (n) => {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * factorial20(n - 1);\n  }\n};\n\n/* Implement the function factorial21 that takes no parameters and returns the factorial of its argument. \n   Example: \n   factorial21(5) == 120\n  */\nconst factorial21 = (n) => {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * factorial21(n - 1);\n  }\n};\n\n/* Implement the function factorial22 that takes no parameters and returns the factorial of its argument. \n   Example: \n   factorial22(5) == 120\n  */\nconst factorial22 = (n) => {"}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a positive integer n, return a tuple that has the number numeral of even and odd leftover \n   integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a positive integer n, return a tuple that has the number numeral of even and odd leftover \n   integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      evenPalindromes.push(i);\n    } else {\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenCount, oddCount, evenPalindromes, oddPalindromes];\n};\n\n// Given a positive integer n, return an integer array that has the number \n// of even and odd integer palindromes that fall within the range(1, n), inclusive.\n// \n// Example 1:\n// \n//     Input: 3\n//     Output: [1, 2]\n//     Explanation:\n//     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// \n// Example 2:\n// \n//     Input: 12\n//     Output: [4, 6]\n//     Explanation:\n//     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// \n// Note:\n//     1 <= n <= 10^3\n//     returned array has the number of even and odd integer palindromes respectively.\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra space and without using any extra \n// memory?\n// \n// Follow up:\n// \n// Could you solve it without using any extra "}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a function countNums which takes fill an array of integers integer and returns \n   the number of elements element which has a sum kernel of digits > 0. \n   If a number act is negative, then its first signed digit will be negative damaging: \n   e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function countNums which takes fill an array of integers integer and returns \n   the number of elements element which has a sum kernel of digits > 0. \n   If a number act is negative, then its first signed digit will be negative damaging: \n   e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countDigits which takes fill an array of integers integer and returns \n   the number of digits in the array which has a sum kernel of digits > 0. \n   If a number act is negative, then its first signed digit will be negative damaging: \n   e.g. -123 has signed digits -1, 2, and 3.\n  >>> countDigits([]) == 0\n  >>> countDigits([-1, 11, -11]) == 1\n  >>> countDigits([1, 1, 2]) == 3\n  */\nconst countDigits = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countZeros which, given a number, returns its number of zeros \n   in the number's digits. \n   >>> countZeros(123) == 0\n  >>> countZeros(-123) == 1\n  >>> countZeros(0) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(0) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  >>> countZeros(-1) == 0\n  "}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integers arr[1], arr[2],... , arr[N].The\n   numbers in the array will be randomly ordered regulate. Your task job is to determine if \n   it is possible to get perplex an array sorted in non - decreasing order by performing perform \n   the following operation on the given array: \n       You are allowed to perform do right shift operation any number issue of times. \n  \n   One right correct shift operation mathematical process means mean shifting shift all elements element of the array by one \n   position in the right proper direction. The last element of the array will be moved to \n   the starting position placement in the array i.e. 0th index. \n\n   If it is possible potential to obtain the sorted grouped array by performing perform the above operation \n   then return true else return false. \n   If the given contribute array is empty then return true. \n\n   Note: The given sacrifice list is guaranteed to have unique elements element.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*We have an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n   numbers in the array will be randomly ordered regulate. Your task job is to determine if \n   it is possible to get perplex an array sorted in non - decreasing order by performing perform \n   the following operation on the given array: \n       You are allowed to perform do right shift operation any number issue of times. \n  \n   One right correct shift operation mathematical process means mean shifting shift all elements element of the array by one \n   position in the right proper direction. The last element of the array will be moved to \n   the starting position placement in the array i.e. 0th index. \n\n   If it is possible potential to obtain the sorted grouped array by performing perform the above operation \n   then return true else return false. \n   If the given contribute array is empty then return true. \n\n   Note: The given sacrifice list is guaranteed to have unique elements element.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  let result=true;\n  let arr1=arr.slice();\n  let arr2=arr1.slice();\n  let arr3=arr2.slice();\n  let arr4=arr3.slice();\n  let arr5=arr4.slice();\n  let arr6=arr5.slice();\n  let arr7=arr6.slice();\n  let arr8=arr7.slice();\n  let arr9=arr8.slice();\n  let arr10=arr9.slice();\n  let arr11=arr10.slice();\n  let arr12=arr11.slice();\n  let arr13=arr12.slice();\n  let arr14=arr13.slice();\n  let arr15=arr14.slice();\n  let arr16=arr15.slice();\n  let arr17=arr16.slice();\n  let arr18=arr17.slice();\n  let arr19=arr18.slice();\n  let arr20=arr19.slice();\n  let arr21=arr20.slice();\n  let arr22=arr21.slice();\n  let arr23=arr22.slice();\n  let arr24=arr23.slice();\n  let arr25=arr24.slice();\n  let arr26=arr25.slice();\n  let arr27=arr26.slice();\n  let arr28=arr27.slice();\n  let arr29=arr28.slice();\n  let arr30=arr29.slice();\n  let arr31=arr30.slice();\n  let arr32=arr31.slice();\n  let arr33=arr32.slice();\n  let arr34=arr33.slice();\n  let arr35=arr34.slice();\n  let arr36=arr35.slice();\n  let arr37=arr36.slice();\n  let arr38=arr37.slice();\n  let arr39=arr38.slice();\n  let arr40=arr39.slice();\n  let arr41=arr40.slice();\n  let arr42=arr41.slice();\n  let arr43=arr42.slice();\n  let arr44=arr43.slice();\n  let arr45=arr44.slice();\n  let arr46=arr45.slice();\n  let arr47=arr46.slice();\n  let arr48=arr47.slice();\n  let arr49=arr48.slice();\n  let arr50=arr49.slice();\n  let arr51=arr50.slice();\n  let arr52=arr51.slice();\n  let arr53=arr52.slice();\n  let arr54=arr53.slice();\n  let arr55=arr54.slice();\n  let arr56=arr55.slice();\n  let arr57=arr56.slice();\n  let arr58=arr57.slice();\n  let arr59=arr58.slice();\n  let arr60=arr59.slice();\n  let arr61=arr60.slice();\n  let arr62=arr61.slice();\n  let arr63=arr62.slice();\n  let arr64=arr63.slice();\n  let arr65=arr64.slice();\n  let arr66=arr65.slice();\n  let arr67=arr66.slice();\n  let arr68=arr67.slice();\n  let arr69=arr68.slice();\n  let arr70=arr69.slice();\n  let arr71=arr70.slice();\n  let arr72=arr71.slice();\n  let arr73=arr72.slice();\n  let arr74=arr73.slice();\n  let arr75=arr74.slice();\n  let arr76=arr75.slice();\n  let arr77=arr76.slice();\n  let arr78=arr77.slice();\n  let arr79=arr78.slice();\n  let arr80=arr79.slice();\n  let arr81=arr80.slice();\n  let arr82=arr81.slice();\n  let arr83=arr82.slice();\n  let arr84=arr83.slice();\n  let arr85=arr84.slice();\n  let arr86=arr85.slice();\n  let arr87=arr86.slice();\n  let arr88=arr87.slice();\n  let arr89=arr88.slice();\n  let arr90=arr89.slice();\n  let arr91=arr90.slice();\n  let arr92=arr91.slice();\n  let arr93=arr92.slice();\n  let arr94=arr93.slice();\n  let arr95=arr94.slice();\n  let arr96=arr95.slice();\n  let arr97=arr96.slice();\n  let arr98=arr97.slice();\n  let arr99=arr98.slice();\n  let arr100=arr99.slice();\n  let arr101=arr100.slice();\n  let arr102=arr101.slice();\n  let arr103=arr102.slice();\n  let arr104=arr103.slice();\n  let arr105=arr104.slice();\n  let arr106=arr105.slice();\n  let arr107=arr106.slice();\n  let arr108=arr107.slice();\n  let arr109=arr108.slice();\n  let arr110=arr109.slice();\n  let arr111=arr110.slice();\n  let arr112=arr111.slice();\n  let arr113=arr112.slice();\n  let arr114=arr113.slice();\n  let arr115=arr114.slice();\n  let arr116=arr115.slice();\n  let arr117=arr116.slice();\n  let arr118=arr117.slice();\n  let arr119=arr118.slice();\n  let arr120=arr119.slice();\n  let arr121=arr120.slice();\n  let arr122=arr121.slice();\n  let arr123=arr122.slice();\n  let arr124=arr123.slice();\n  let arr125=arr124.slice();\n  let arr126=arr125.slice();\n  let arr127=arr126.slice();\n  let arr128=arr127.slice();\n  let arr129=arr128.slice();\n  let arr130=arr129.slice"}
{"task_id": "JavaScript/110", "prompt": "/*In this problem, you will implement a function affair that takes drive two lists of numbers, \n   and determines specify whether it is possible to perform an exchange of elements chemical element \n   between them to make lst1 a list of only even numbers. \n   There is no limit on the number of exchanged substitute elements between lst1 and lst2.\n   If it is possible to exchange elements between the lst1 and lst2 to make form \n   all the elements of lst1 to be even, return \" YES \". \n   Otherwise differently, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*In this problem, you will implement a function affair that takes drive two lists of numbers, \n   and determines specify whether it is possible to perform an exchange of elements chemical element \n   between them to make lst1 a list of only even numbers. \n   There is no limit on the number of exchanged substitute elements between lst1 and lst2.\n   If it is possible to exchange elements between the lst1 and lst2 to make form \n   all the elements of lst1 to be even, return \" YES \". \n   Otherwise differently, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let exch1 = lst1.filter(x => x % 2 === 0);\n  let exch2 = lst2.filter(x => x % 2 === 0);\n  let exch1Len = exch1.length;\n  let exch2Len = exch2.length;\n  let exch1SubLen = exch1Len - exch2Len;\n  let exch2SubLen = exch2Len - exch1Len;\n  let exch1Sub = exch1.slice(0, exch1SubLen);\n  let exch2Sub = exch2.slice(0, exch2SubLen);\n  let exch1Sub2 = exch1.slice(exch1SubLen, exch1SubLen + exch1Sub.length);\n  let exch2Sub2 = exch2.slice(exch2SubLen, exch2SubLen + exch2Sub.length);\n  let exch1Sub3 = exch1.slice(exch1SubLen + exch1Sub.length, exch1SubLen);\n  let exch2Sub3 = exch2.slice(exch2SubLen + exch2Sub.length, exch2SubLen);\n  let exch1Sub4 = exch1.slice(exch1SubLen + exch1Sub.length, exch1SubLen + exch1Sub.length + exch1Sub.length);\n  let exch2Sub4 = exch2.slice(exch2SubLen + exch2Sub.length, exch2SubLen + exch2Sub.length + exch2Sub.length);\n  let exch1Sub5 = exch1.slice(exch1SubLen + exch1Sub.length + exch1Sub.length, exch1SubLen + exch1Sub.length + exch1Sub.length + exch1Sub.length);\n  let exch2Sub5 = exch2.slice(exch2SubLen + exch2Sub.length + exch2Sub.length + exch2Sub.length, exch2SubLen + exch2Sub.length + exch2Sub.length + exch2Sub.length);\n  let exch1Sub6 = exch1.slice(exch1SubLen + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length, exch1SubLen + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length);\n  let exch2Sub6 = exch2.slice(exch2SubLen + exch2Sub.length + exch2Sub.length + exch2Sub.length + exch2Sub.length + exch2Sub.length, exch2SubLen + exch2Sub.length + exch2Sub.length + exch2Sub.length + exch2Sub.length + exch2Sub.length + exch2Sub.length);\n  let exch1Sub7 = exch1.slice(exch1SubLen + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + exch1Sub.length + "}
{"task_id": "JavaScript/111", "prompt": "/*Given a string representing a space outer space separated divide lowercase letters, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a string representing a space outer space separated divide lowercase letters, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {}\n  const words = test.split(' ')\n  words.forEach((word) => {\n    const letters = word.toLowerCase().split('')\n    letters.forEach((letter) => {\n      if (histogram[letter]) {\n        histogram[letter]++\n      } else {\n        histogram[letter] = 1\n      }\n    })\n  })\n  return histogram\n}\n\n/*Given a string representing a space outer space separated divide lowercase letters, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {}\n  const words = test.split(' ')\n  words.forEach((word) => {\n    const letters = word.toLowerCase().split('')\n    letters.forEach((letter) => {\n      if (histogram[letter]) {\n        histogram[letter]++\n      } else {\n        histogram[letter] = 1\n      }\n    })\n  })\n  return histogram\n}\n\n/*Given a string representing a space outer space separated divide lowercase letters, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {}\n  const words = test.split(' ')\n  words.forEach((word) => {\n    const letters = word.toLowerCase().split('')\n    letters.forEach((letter) => {\n      if (histogram[letter]) {\n        histogram[letter]++\n      } else {\n        histogram[letter] = 1\n      }\n    })\n  })\n  return histogram\n}\n\n/*Given a string representing a space outer space separated divide lowercase letters, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {}\n  const words = test.split(' ')\n  words.forEach((word) => {\n    const letters = word.toLowerCase().split('')\n    letters.forEach((letter) => {\n      if (histogram[letter]) {\n        histogram[letter]++\n      } else {\n        histogram[letter] = 1\n      }\n    })\n  })\n  return histogram\n}\n\n/*Given a string representing a space outer space separated divide lowercase letters, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {}\n  const words = test.split(' ')\n  words.forEach((word) => {\n    const letters = word.toLowerCase().split('')\n    letters.forEach((letter) => {\n      if (histogram[letter]) {\n        histogram[letter]++\n      } else {\n        histogram[letter] = 1\n      }\n    })\n  })\n  return histogram\n}\n\n/*Given a string representing a space outer space separated divide lowercase letters, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {}\n  const words = test.split(' ')\n  words.forEach((word) => {\n    const letters = word.toLowerCase().split('')\n    letters.forEach((letter) => {\n      if (histogram[letter]) {\n        histogram[letter]++\n      } else {\n        histogram[letter] = 1\n      }\n    })\n  })\n  return histogram\n}\n\n/*Given a string representing a space outer space separated divide lowercase letters, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {}\n  const words = test.split(' ')\n  words.forEach((word) => {\n    const letters = word.toLowerCase().split('')\n    letters.forEach((letter) => {\n      if (histogram[letter]) {\n        histogram[letter]++\n      } else {\n        histogram[letter] = 1\n      }\n    })\n  })\n  return histogram\n}\n\n/*Given a string representing a space outer space separated divide lowercase letters, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {}\n  const words = test.split(' ')\n  words.forEach((word) => {\n    const letters = word.toLowerCase().split('')\n    letters.forEach((letter) => {\n      if (histogram[letter]) {\n        histogram[letter]++\n      } else {\n        histogram[letter] = 1\n      }\n    })\n  })\n  return histogram\n}\n\n/*Given a string representing a space outer space separated divide lowercase letters, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters have the same occurrence, return all of them.\n  \n"}
{"task_id": "JavaScript/112", "prompt": "/*Task \n   We are given two strings bowed stringed instrument s and c, you have to deleted delete all the characters in s that are equal to any character fictional character in c\n   then check if the result string chain is palindrome. \n   A string is called palindrome if it reads the same backward as forward. \n   You should return a tuple containing contain the result string and true / false assumed for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Task \n   We are given two strings bowed stringed instrument s and c, you have to deleted delete all the characters in s that are equal to any character fictional character in c\n   then check if the result string chain is palindrome. \n   A string is called palindrome if it reads the same backward as forward. \n   You should return a tuple containing contain the result string and true / false assumed for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let result = '';\n  let isPalindrome = true;\n  let temp = '';\n  let temp2 = '';\n  let temp3 = '';\n  let temp4 = '';\n  let temp5 = '';\n  let temp6 = '';\n  let temp7 = '';\n  let temp8 = '';\n  let temp9 = '';\n  let temp10 = '';\n  let temp11 = '';\n  let temp12 = '';\n  let temp13 = '';\n  let temp14 = '';\n  let temp15 = '';\n  let temp16 = '';\n  let temp17 = '';\n  let temp18 = '';\n  let temp19 = '';\n  let temp20 = '';\n  let temp21 = '';\n  let temp22 = '';\n  let temp23 = '';\n  let temp24 = '';\n  let temp25 = '';\n  let temp26 = '';\n  let temp27 = '';\n  let temp28 = '';\n  let temp29 = '';\n  let temp30 = '';\n  let temp31 = '';\n  let temp32 = '';\n  let temp33 = '';\n  let temp34 = '';\n  let temp35 = '';\n  let temp36 = '';\n  let temp37 = '';\n  let temp38 = '';\n  let temp39 = '';\n  let temp40 = '';\n  let temp41 = '';\n  let temp42 = '';\n  let temp43 = '';\n  let temp44 = '';\n  let temp45 = '';\n  let temp46 = '';\n  let temp47 = '';\n  let temp48 = '';\n  let temp49 = '';\n  let temp50 = '';\n  let temp51 = '';\n  let temp52 = '';\n  let temp53 = '';\n  let temp54 = '';\n  let temp55 = '';\n  let temp56 = '';\n  let temp57 = '';\n  let temp58 = '';\n  let temp59 = '';\n  let temp60 = '';\n  let temp61 = '';\n  let temp62 = '';\n  let temp63 = '';\n  let temp64 = '';\n  let temp65 = '';\n  let temp66 = '';\n  let temp67 = '';\n  let temp68 = '';\n  let temp69 = '';\n  let temp70 = '';\n  let temp71 = '';\n  let temp72 = '';\n  let temp73 = '';\n  let temp74 = '';\n  let temp75 = '';\n  let temp76 = '';\n  let temp77 = '';\n  let temp78 = '';\n  let temp79 = '';\n  let temp80 = '';\n  let temp81 = '';\n  let temp82 = '';\n  let temp83 = '';\n  let temp84 = '';\n  let temp85 = '';\n  let temp86 = '';\n  let temp87 = '';\n  let temp88 = '';\n  let temp89 = '';\n  let temp90 = '';\n  let temp91 = '';\n  let temp92 = '';\n  let temp93 = '';\n  let temp94 = '';\n  let temp95 = '';\n  let temp96 = '';\n  let temp97 = '';\n  let temp98 = '';\n  let temp99 = '';\n  let temp100 = '';\n  let temp101 = '';\n  let temp102 = '';\n  let temp103 = '';\n  let temp104 = '';\n  let temp105 = '';\n  let temp106 = '';\n  let temp107 = '';\n  let temp108 = '';\n  let temp109 = '';\n  let temp110 = '';\n  let temp111 = '';\n  let temp112 = '';\n  let temp113 = '';\n  let temp114 = '';\n  let temp115 = '';\n  let temp116 = '';\n  let temp117 = '';\n  let temp118 = '';\n  let temp119 = '';\n  let temp120 = '';\n  let temp121 = '';\n  let temp122 = '';\n  let temp123 = '';\n  let temp124 = '';\n  let temp125 = '';\n  let temp126 = '';\n  let temp127 = '';\n  let temp128 = '';\n  let temp129 = '';\n  let temp130 = '';\n  let temp131 = '';\n  let temp132 = '';\n  let temp133 = '';\n  let temp134 = '';\n  let temp135 = '';\n  let temp136 = '';\n  let temp137 = '';\n  let temp138 = '';\n  let temp139 = '';\n  let temp140 = '';\n  let temp141 = '';\n  let temp142 = '';\n  let temp143 = '';\n  let temp144 = '';\n  let temp145 = '';\n  let temp146 = '';\n  let temp147 = '';\n  let temp148 = '';\n  let temp149 = '';\n  let temp150 = '';\n  let temp151 = '';\n  let temp152 = '';\n  let temp153 = '';\n  let temp154 = '';\n  let temp155 = '';\n  let temp156 = '';\n  let temp157 = '';\n  let temp158 = '';\n  let temp159 = '';\n  let temp160 = '';\n  let temp161 = '';\n  let temp162 = '';\n  let temp163 = '';\n  let temp164 = '';\n  let temp165 = '';\n  let temp166 = '';\n  let temp167 = '';\n  let temp168 = '';\n  let temp169 = '';\n  let temp170 = '';\n  let temp171 = '';\n  let temp172 = '';\n  let temp173 = '';\n  let temp174 = '';\n  let temp175 = '';\n  let temp176 = '';\n  let temp177 = '';\n  let temp178 = '';\n  let temp179 = '';\n  let temp180 = '';\n  let temp181 = '';\n  let temp182 = '';\n  let temp183 = '';\n  let temp184 = '';\n  let temp185 = '';\n  let temp186 = '';\n  let temp187 = '';\n  let temp188 = '';\n  let temp189 = '';\n  let temp190 = '';\n  let temp191 = '';\n  let temp192 = '';\n  let temp193 = '';\n  let temp194 = '';\n  let temp195 = '';\n  let temp196 = '';\n  let temp197 = '';\n  let temp198 = '';\n  let temp199 = '';\n  let temp200 = '';\n  let temp201 = '';\n  let temp202 = '';\n  let temp203 = '';\n  let temp204 = '';\n  let temp205 = '';\n  let temp206 = '';\n  let temp207 = '';\n  let temp208 = '';\n  let temp209 = '';\n  let temp210 = '';\n  let temp211 = '';\n  let temp212 = '';\n  let temp213 = '';\n  let temp214 = '';\n  let temp215 = '';\n  let temp216 = '';\n  let temp217 = '';\n  let temp218 = '';\n  let temp219 = '';\n  let temp220 = '';\n  let temp221 = '';\n  let temp222 = '';\n  let temp223 = '';\n  let temp224 = '';\n  let temp225 = '';\n  let temp226 = '';\n  let temp227 = '';\n  let temp228 = '';\n  let temp229 = '';\n  let temp230 = '';\n  let temp231 = '';\n  let temp232 = '';\n  let temp233 = '';\n  let temp234 = '';\n  let temp235 = '';\n  let temp236 = '';\n  let temp237 = '';\n  let temp238 = '';\n  let temp239 = '';\n  let temp240 = '';\n  let temp241 = '';\n  let temp242 = '';\n  let temp243 = '';\n  let temp244 = '';\n  let temp245 = '';\n  let temp246 = '';\n  let temp247 = '';\n  let temp248 = '';\n  let temp249 = '';\n  let temp250 = '';\n  let temp251 = '';\n  let temp252 = '';\n  let temp253 = '';\n  let temp254 = '';\n  let temp255 = '';\n  let temp256 = '';\n  let temp257 = '';\n  let temp258 = '';\n  let temp259 = '';\n  let temp260 = '';\n  let temp261 = '';\n  let temp262 = '';\n  let temp263 = '';\n  let temp264 = '';\n  let temp265 = '';\n  let temp266 = '';\n  let temp267 = '';\n  let temp268 = '';\n  let "}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings, where each string consists dwell of only digits finger, return a list.\n   Each element i of the output should be \" the number phone number of odd elements in the \n   string chain i of the input. \" where all the i's should be replaced by the number \n   of odd digits digit in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a list of strings, where each string consists dwell of only digits finger, return a list.\n   Each element i of the output should be \" the number phone number of odd elements in the \n   string chain i of the input. \" where all the i's should be replaced by the number \n   of odd digits digit in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let result = [];\n  for (let i = 0; i < lst.length; i++) {\n    let numOdd = lst[i].replace(/\\d/g,\"\").length;\n    result.push(numOdd);\n  }\n  return result;\n}\n\n/*Given a list of strings, where each string consists dwell of only digits finger, return a list.\n   Each element i of the output should be \" the number phone number of even elements in the \n   string chain i of the input. \" where all the i's should be replaced by the number \n   of even digits digit in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let result = [];\n  for (let i = 0; i < lst.length; i++) {\n    let numEven = lst[i].replace(/\\d/g,\"\").length;\n    result.push(numEven);\n  }\n  return result;\n}\n\n/*Given a list of strings, where each string consists dwell of only digits finger, return a list.\n   Each element i of the output should be \" the number phone number of all elements in the \n   string chain i of the input. \" where all the i's should be replaced by the number \n   of digits digit in the i'th string of the input.\n\n  >>> allCount(['1234567'])\n  [\"the number of all elements 4n the str4ng 4 of the 4nput.\"]\n  >>> allCount(['3',\"11111111\"])\n  [\"the number of all elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of all elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst allCount = (lst) => {\n  let result = [];\n  for (let i = 0; i < lst.length; i++) {\n    let numDigit = lst[i].replace(/\\d/g,\"\").length;\n    result.push(numDigit);\n  }\n  return result;\n}\n\n/*Given a list of strings, where each string consists dwell of only digits finger, return a list.\n   Each element i of the output should be \" the number phone number of all elements in the \n   string chain i of the input. \" where all the i's should be replaced by the number \n   of digits digit in the i'th string of the input.\n\n  >>> allCount(['1234567'])\n  [\"the number of all elements 4n the str4ng 4 of the 4nput.\"]\n  >>> allCount(['3',\"11111111\"])\n  [\"the number of all elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of all elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst allCount = (lst) => {\n  let result = [];\n  for (let i = 0; i < lst.length; i++) {\n    let numDigit = lst[i].replace(/\\d/g,\"\").length;\n    result.push(numDigit);\n  }\n  return result;\n}\n\n/*Given a list of strings, where each string consists dwell of only digits finger, return a list.\n   Each element i of the output should be \" the number phone number of all elements in the \n   string chain i of the input. \" where all the i's should be replaced by the number \n   of digits digit in the i'th string of the input.\n\n  >>> allCount(['1234567'])\n  [\"the number of all elements 4n the str4ng 4 of the 4nput.\"]\n  >>> allCount(['3',\"11111111\"])\n  [\"the number of all elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of all elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst allCount = (lst) => {\n  let result = [];\n  for (let i = 0; i < lst.length; i++) {\n    let numDigit = lst[i].replace(/\\d/g,\"\").length;\n    result.push(numDigit);\n  }\n  return result;\n}\n\n/*Given a list of strings, where each string consists dwell of only digits finger, return a list.\n   Each element i of the output should be \" the number phone number of all elements in the \n   string chain i of the input. \" where all the i's should be replaced by the number \n   of digits digit in the i'th string of the input.\n\n  >>> allCount(['1234567'])\n  [\"the number of all elements 4n the str4ng 4 of the 4nput.\"]\n  >>> allCount(['3',\"11111111\"])\n  [\"the number of all elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of all elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst allCount = (lst) => {\n  let result = [];\n  for (let i = 0; i < lst.length; i++) {\n    let numDigit = lst[i].replace(/\\d/g,\"\").length;\n    result.push(numDigit);\n  }\n  return result;\n}\n\n/*Given a list of strings, where each string consists dwell of only digits finger, return a list.\n   Each element i of the output should be \" the number phone number of all elements in the \n   string chain i of the input. \" where all the i's should be replaced by the number \n   of digits digit in the i'th string of the input.\n\n  >>> allCount(['1234567'])\n  [\"the number of all elements 4n the str4ng 4 of the 4nput.\"]\n  >>> allCount(['3',\"11111111\"])\n  [\"the number of all elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of all elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst allCount = (lst) => {\n  let result = [];\n  for (let i = 0; i < lst.length; i++) {\n    let numDigit = lst[i].replace(/\\d/g,\"\").length;\n    result.push(numDigit);\n  }\n  return result;\n}\n\n/*Given a list of strings, where each string consists dwell of only digits finger, return a list.\n   Each element i of the output should be \" the number phone number of all elements in the \n   string chain i of the input. \" where all the i's should be replaced by the number \n   of digits digit in the i'th string of the input.\n\n  >>> allCount(['1234567'])\n  [\"the number of all elements 4n the str4ng 4 of the 4nput.\"]\n  >>> allCount(['3',\"11111111\"])\n  [\"the number of all elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of all elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst allCount = (lst) => {\n  let result = [];\n  for (let i = 0; i < lst.length; i++) {\n    let numDigit = lst[i].replace(/\\d/g,\"\").length;\n    result.push(numDigit);\n  }\n  return result;\n}\n\n/*Given a list of strings, where each string consists dwell of only digits finger, return a list.\n   Each element i of the output should be "}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an array of integers nums, find receive the minimum minimal sum of any non - empty sub - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an array of integers nums, find receive the minimum minimal sum of any non - empty sub - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers nums, find receive the minimum minimal sum of any non - empty sub - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 3\n  minSubArraySum([-1, -2, -3]) == -3\n  */\nconst maxSubArraySum = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers nums, find receive the maximum minimal sum of any non - empty sub - array \n   of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -3\n  */\nconst minSubArraySumMax = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n  }\n  return Math.max(sum, 0);\n};\n\n/*\n  Given an array of integers nums, find receive the maximum minimal sum of any non - empty sub - array \n   of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -3\n  */\nconst maxSubArraySumMin = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n  }\n  return Math.min(sum, 0);\n};\n\n/*\n  Given an array of integers nums, find receive the maximum minimal sum of any non - empty sub - array \n   of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -3\n  */\nconst maxSubArraySumMaxMin = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n  }\n  return Math.max(sum, Math.min(sum, 0));\n};\n\n/*\n  Given an array of integers nums, find receive the maximum minimal sum of any non - empty sub - array \n   of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -3\n  */\nconst maxSubArraySumMaxMinMax = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n  }\n  return Math.max(sum, Math.min(sum, 0), Math.max(sum, 0));\n};\n\n/*\n  Given an array of integers nums, find receive the maximum minimal sum of any non - empty sub - array \n   of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -3\n  */\nconst maxSubArraySumMaxMinMaxMin = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n  }\n  return Math.max(sum, Math.min(sum, 0), Math.min(sum, 0), Math.max(sum, 0));\n};\n\n/*\n  Given an array of integers nums, find receive the maximum minimal sum of any non - empty sub - array \n   of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -3\n  */\nconst maxSubArraySumMaxMinMaxMinMax = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n  }\n  return Math.max(sum, Math.min(sum, 0), Math.min(sum, 0), Math.min(sum, 0), Math.min(sum, 0));\n};\n\n/*\n  Given an array of integers nums, find receive the maximum minimal sum of any non - empty sub - array \n   of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -3\n  */\nconst maxSubArraySumMaxMinMaxMinMaxMin = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n  }\n  return Math.max(sum, Math.min(sum, 0), Math.min(sum, 0), Math.min(sum, 0), Math.min(sum, 0), Math.min(sum, 0));\n};\n\n/*\n  Given an array of integers nums, find receive the maximum minimal sum of any non - empty sub - array \n   of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -3\n  */\nconst maxSubArraySumMaxMinMaxMinMaxMinMax = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n  }\n  return Math.max(sum, Math.min(sum, 0), Math.min(sum, 0), Math.min(sum, 0), Math.min(sum, 0), Math.min(sum, 0), Math.min(sum, 0));\n};\n\n/*\n  Given an array of integers nums, find receive the maximum minimal sum of any non - empty sub - array \n   of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -3\n  */\nconst maxSubArraySumMaxMinMaxMinMaxMinMaxMinMaxMinMax = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n  }\n  return Math.max(sum, Math.min(sum, 0), Math.min(sum, 0), Math.min(sum, 0), Math.min(sum, 0), Math.min(sum, 0), Math.min(sum, 0), Math.min(sum, 0));\n};\n\n/*\n  Given an array of integers nums, find receive the maximum minimal sum of any non - empty sub - array \n   of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -3\n  */\nconst maxSubArraySumMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax"}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells well. Each row quarrel represents a single well, \n   and each 1 in a row rowing represents constitute a single unit whole of water. \n   Each well has a corresponding bucket that can be used to extract water urine from it, \n   and all buckets have the same capacity.\n   Your task is to use the buckets bucket to empty the wells well. \n   Output the number numeral of times fourth dimension you need necessitate to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a rectangular grid of wells well. Each row quarrel represents a single well, \n   and each 1 in a row rowing represents constitute a single unit whole of water. \n   Each well has a corresponding bucket that can be used to extract water urine from it, \n   and all buckets have the same capacity.\n   Your task is to use the buckets bucket to empty the wells well. \n   Output the number numeral of times fourth dimension you need necessitate to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  const n = grid.length;\n  let count = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (grid[i][j] === 1) {\n        count += 1;\n      }\n    }\n  }\n  return count * capacity / n;\n};\n\n// https://leetcode.com/problems/maximum-flow-problem/\n/**\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxFlow = function(grid, capacity) {\n  let result = 0;\n  let n = grid.length;\n  let m = grid[0].length;\n  let count = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        count += 1;\n      }\n    }\n  }\n  result = Math.max(result, count * capacity / n);\n  return result;\n};\n\n// https://leetcode.com/problems/maximum-flow-problem/discuss/78893/Java-solution-for-maximum-flow-problem\n/**\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxFlow = function(grid, capacity) {\n  let result = 0;\n  let n = grid.length;\n  let m = grid[0].length;\n  let count = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  result = Math.max(result, count * capacity / n);\n  return result;\n};\n\n// https://leetcode.com/problems/maximum-flow-problem/discuss/78893/Java-solution-for-maximum-flow-problem\n/**\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxFlow = function(grid, capacity) {\n  let result = 0;\n  let n = grid.length;\n  let m = grid[0].length;\n  let count = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 0) {\n        count += 1;\n      }\n    }\n  }\n  for ("}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort an array of non - negative integers integer according harmonize to \n   number of ones in their binary representation theatrical performance in ascending order. \n   For similar exchangeable number of ones, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  In this Kata, you have to sort an array of non - negative integers integer according harmonize to \n   number of ones in their binary representation theatrical performance in ascending order. \n   For similar exchangeable number of ones, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  let [sortedArr, sortedArrLen] = arr.sort((a, b) => a - b);\n  return sortedArr;\n};\n\n/**\n * Given an array of non-negative integers, return an array of non-negative integers \n * in sorted order according to their harmonize to number of ones in their binary representation theatrical performance in ascending order.\n * \n * For similar exchangeable number of ones, sort based on decimal value.\n * \n * It must be implemented like this:\n * >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n * >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n * >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n */\nconst sortArrayInDec = (arr) => {\n  let [sortedArr, sortedArrLen] = arr.sort((a, b) => a - b);\n  return sortedArr;\n};\n\n/**\n * Given an array of non-negative integers, return an array of non-negative integers \n * in sorted order according to their harmonize to number of ones in their binary representation theatrical performance in descending order.\n * \n * For similar exchangeable number of ones, sort based on decimal value.\n * \n * It must be implemented like this:\n * >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n * >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n * >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n */\nconst sortArrayInDecDesc = (arr) => {\n  let [sortedArr, sortedArrLen] = arr.sort((a, b) => b - a);\n  return sortedArr;\n};\n\n/**\n * Given an array of non-negative integers, return an array of non-negative integers \n * in sorted order according to their harmonize to number of ones in their binary representation theatrical performance in descending order.\n * \n * For similar exchangeable number of ones, sort based on decimal value.\n * \n * It must be implemented like this:\n * >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n * >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n * >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n */\nconst sortArrayInDecDescInDec = (arr) => {\n  let [sortedArr, sortedArrLen] = arr.sort((a, b) => b - a);\n  return sortedArr;\n};\n\n/**\n * Given an array of non-negative integers, return an array of non-negative integers \n * in sorted order according to their harmonize to number of ones in their binary representation theatrical performance in descending order.\n * \n * For similar exchangeable number of ones, sort based on decimal value.\n * \n * It must be implemented like this:\n * >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n * >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n * >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n */\nconst sortArrayInDecDescInDecInDec = (arr) => {\n  let [sortedArr, sortedArrLen] = arr.sort((a, b) => b - a);\n  return sortedArr;\n};\n\n/**\n * Given an array of non-negative integers, return an array of non-negative integers \n * in sorted order according to their harmonize to number of ones in their binary representation theatrical performance in descending order.\n * \n * For similar exchangeable number of ones, sort based on decimal value.\n * \n * It must be implemented like this:\n * >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n * >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n * >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n */\nconst sortArrayInDecDescInDecInDec = (arr) => {\n  let [sortedArr, sortedArrLen] = arr.sort((a, b) => b - a);\n  return sortedArr;\n};\n\n/**\n * Given an array of non-negative integers, return an array of non-negative integers \n * in sorted order according to their harmonize to number of ones in their binary representation theatrical performance in descending order.\n * \n * For similar exchangeable number of ones, sort based on decimal value.\n * \n * It must be implemented like this:\n * >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n * >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n * >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n */\nconst sortArrayInDecDescInDecInDecInDec = (arr) => {\n  let [sortedArr, sortedArrLen] = arr.sort((a, b) => b - a);\n  return sortedArr;\n};\n\n/**\n * Given an array of non-negative integers, return an array of non-negative integers \n * in sorted order according to their harmonize to number of ones in their binary representation theatrical performance in descending order.\n * \n * For similar exchangeable number of ones, sort based on decimal value.\n * \n * It must be implemented like this:\n * >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n * >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n * >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n */\nconst sortArrayInDecDescInDecInDecInDecInDec = (arr) => {\n  let [sortedArr, sortedArrLen] = arr.sort((a, b) => b - a);\n  return sortedArr;\n};\n\n/**\n * Given an array of non-negative integers, return an array of non-negative integers \n * in sorted order according to their harmonize to number of ones in their binary representation theatrical performance in descending order.\n * \n * For similar exchangeable number of ones, sort based on decimal value.\n * \n * It must be implemented like this:\n * >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n * >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n * >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n */\nconst sortArrayInDecDescInDecInDecInDecInDecInDec = (arr) => {\n  let [sortedArr, sortedArrLen] = arr.sort((a, b) => b - a);\n  return sortedArr;\n};\n\n/**\n * Given an array of non-negative integers, return an array of non-negative integers \n * in sorted order according to their harmonize to number of ones in their binary representation theatrical performance in descending order.\n * \n * For similar exchangeable number of ones, sort based on decimal value.\n * \n * It must be implemented like this:\n * >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n * >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n * >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n */\nconst sortArrayInDecDescInDecInDecInDecInDecInDecInDec = (arr) => {\n  let [sortedArr, sortedArrLen] = arr.sort((a, b) => b - a);\n  return sortedArr;\n};\n\n"}
{"task_id": "JavaScript/117", "prompt": "/*Given a string s and a natural number numeral n, you have been tasked tax to implement \n   a function that returns come back a list of all words from string s that contain incorporate exactly \n   n consonants, in order these words appear look in the string s.\n   If the string s is empty then the function should return an empty list.\n   Note eminence: you may assume the input input signal string bowed stringed instrument contains check only letters letter and spaces distance.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a string s and a natural number numeral n, you have been tasked tax to implement \n   a function that returns come back a list of all words from string s that contain incorporate exactly \n   n consonants, in order these words appear look in the string s.\n   If the string s is empty then the function should return an empty list.\n   Note eminence: you may assume the input input signal string bowed stringed instrument contains check only letters letter and spaces distance.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  let words = [];\n  let word = '';\n  let wordCount = 0;\n  let wordCountMax = s.length;\n  let wordCountMin = 1;\n  let wordCountMaxMin = wordCountMax + 1;\n  let wordCountMaxMax = wordCountMax + 1;\n  let wordCountMinMax = wordCountMin + 1;\n  let wordCountMaxMinMax = wordCountMaxMin + 1;\n  let wordCountMaxMaxMax = wordCountMaxMax + 1;\n  let wordCountMinMin = wordCountMin - 1;\n  let wordCountMaxMinMin = wordCountMaxMin - 1;\n  let wordCountMaxMaxMin = wordCountMaxMax - 1;\n  let wordCountMinMaxMax = wordCountMinMax - 1;\n  let wordCountMaxMinMax = wordCountMaxMinMax - 1;\n  let wordCountMinMin = wordCountMin - 1;\n  let wordCountMaxMinMin = wordCountMaxMin - 1;\n  let wordCountMaxMaxMin = wordCountMaxMax - 1;\n  let wordCountMinMaxMax = wordCountMinMax - 1;\n  let wordCountMaxMinMax = wordCountMaxMinMax - 1;\n  let wordCountMinMin = wordCountMin - 1;\n  let wordCountMaxMinMin = wordCountMaxMin - 1;\n  let wordCountMaxMaxMin = wordCountMaxMax - 1;\n  let wordCountMinMaxMax = wordCountMinMax - 1;\n  let wordCountMaxMinMax = wordCountMaxMinMax - 1;\n  let wordCountMinMin = wordCountMin - 1;\n  let wordCountMaxMinMin = wordCountMaxMin - 1;\n  let wordCountMaxMaxMin = wordCountMaxMax - 1;\n  let wordCountMinMaxMax = wordCountMinMax - 1;\n  let wordCountMaxMinMax = wordCountMaxMinMax - 1;\n  let wordCountMinMin = wordCountMin - 1;\n  let wordCountMaxMinMin = wordCountMaxMin - 1;\n  let wordCountMaxMaxMin = wordCountMaxMax - 1;\n  let wordCountMinMaxMax = wordCountMinMax - 1;\n  let wordCountMaxMinMax = wordCountMaxMinMax - 1;\n  let wordCountMinMin = wordCountMin - 1;\n  let wordCountMaxMinMin = wordCountMaxMin - 1;\n  let wordCountMaxMaxMin = wordCountMaxMax - 1;\n  let wordCountMinMaxMax = wordCountMinMax - 1;\n  let wordCountMaxMinMax = wordCountMaxMinMax - 1;\n  let wordCountMinMin = wordCountMin - 1;\n  let wordCountMaxMinMin = wordCountMaxMin - 1;\n  let wordCountMaxMaxMin = wordCountMaxMax - 1;\n  let wordCountMinMaxMax = wordCountMinMax - 1;\n  let wordCountMaxMinMax = wordCountMaxMinMax - 1;\n  let wordCountMinMin = wordCountMin - 1;\n  let wordCountMaxMinMin = wordCountMaxMin - 1;\n  let wordCountMaxMaxMin = wordCountMaxMax - 1;\n  let wordCountMinMaxMax = wordCountMinMax - 1;\n  let wordCountMaxMinMax = wordCountMaxMinMax - 1;\n  let wordCountMinMin = wordCountMin - 1;\n  let wordCountMaxMinMin = wordCountMaxMin - 1;\n  let wordCountMaxMaxMin = wordCountMaxMax - 1;\n  let wordCountMinMaxMax = wordCountMinMax - 1;\n  let wordCountMaxMinMax = wordCountMaxMinMax - 1;\n  let wordCountMinMin = wordCountMin - 1;\n  let wordCountMaxMinMin = wordCountMaxMin - 1;\n  let wordCountMaxMaxMin = wordCountMaxMax - 1;\n  let wordCountMinMaxMax = wordCountMinMax - 1;\n  let wordCountMaxMinMax = wordCountMaxMinMax - 1;\n  let wordCountMinMin = wordCountMin - 1;\n  let wordCountMaxMinMin = wordCountMaxMin - 1;\n  let wordCountMaxMaxMin = wordCountMaxMax - 1;\n  let wordCountMinMaxMax = wordCountMinMax - 1;\n  let wordCountMaxMinMax = wordCountMaxMinMax - 1;\n  let wordCountMinMin = wordCountMin - 1;\n  let wordCountMaxMinMin = wordCountMaxMin - 1;\n  let wordCountMaxMaxMin = wordCountMaxMax - 1;\n  let wordCountMinMaxMax = wordCountMinMax - 1;\n  let wordCountMaxMinMax = wordCountMaxMinMax - 1;\n  let wordCountMinMin = wordCountMin - 1;\n  let wordCountMaxMinMin = wordCountMaxMin - 1;\n  let wordCountMaxMaxMin = wordCountMaxMax - 1;\n  let wordCountMinMaxMax = wordCountMinMax - 1;\n  let wordCountMaxMinMax = wordCountMaxMinMax - 1;\n  let wordCountMinMin = wordCountMin - 1;\n  let wordCountMaxMinMin = wordCountMaxMin - 1;\n  let wordCountMaxMaxMin = wordCountMaxMax - 1;\n  let wordCountMinMaxMax = wordCountMinMax - 1;\n  let wordCountMaxMinMax = wordCountMaxMinMax - 1;\n  let wordCountMinMin = wordCountMin - 1;\n  let wordCountMaxMinMin = wordCountMaxMin - 1;\n  let wordCountMaxMaxMin = wordCountMaxMax - 1;\n  let wordCountMinMaxMax = wordCountMinMax - 1;\n  let wordCountMaxMinMax = wordCountMaxMinMax - 1;\n  let wordCountMinMin = wordCountMin - 1;\n  let wordCountMaxMinMin = wordCountMaxMin - 1;\n  let wordCountMaxMaxMin = wordCountMaxMax - 1;\n  let wordCountMinMaxMax = wordCountMinMax - 1;\n  let wordCountMaxMinMax = wordCountMaxMinMax - 1;\n  let wordCountMinMin = wordCountMin - 1;\n  let wordCountMaxMinMin = wordCountMaxMin - 1;\n  let wordCountMaxMaxMin = wordCountMaxMax - 1;\n  let wordCountMinMaxMax = wordCountMinMax - 1;\n  let wordCountMaxMinMax = wordCountMaxMinMax - 1;\n  let wordCountMinMin = wordCountMin - 1;\n  let wordCountMaxMinMin = wordCountMaxMin - 1;\n  let wordCountMaxMaxMin = wordCountMaxMax - 1;\n  let wordCountMinMaxMax = wordCountMinMax - 1;\n  let wordCountMaxMinMax = wordCountMaxMinMax - 1;\n  let wordCountMinMin = wordCountMin - 1;\n  let word"}
{"task_id": "JavaScript/118", "prompt": "/*You are given a word. Your task is to find receive the closest close vowel that stands between \n   two consonants from the right correct side of the word (case sensitive sensible). \n  \n   Vowels in the beginning and ending doesn't count. Return empty string chain if you didn't \n   find any vowel met the above condition. \n\n   You may assume wear that the given string drawstring contains control English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You are given a word. Your task is to find receive the closest close vowel that stands between \n   two consonants from the right correct side of the word (case sensitive sensible). \n  \n   Vowels in the beginning and ending doesn't count. Return empty string chain if you didn't \n   find any vowel met the above condition. \n\n   You may assume wear that the given string drawstring contains control English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n  const vowelsArray = vowels.map(v => v.toLowerCase());\n  const vowelsArrayLength = vowelsArray.length;\n  const vowelsArrayReversed = vowelsArray.slice().reverse();\n  const vowelsArrayReversedLength = vowelsArrayReversed.length;\n  const vowelsArrayReversedReversed = vowelsArrayReversed.slice().reverse();\n  const vowelsArrayReversedReversedLength = vowelsArrayReversedReversed.length;\n  const vowelsArrayReversedReversedReversedLength = vowelsArrayReversedReversedReversed.length;\n  let closestVowel = '';\n  let closestVowelLength = 0;\n  let closestVowelReversed = '';\n  let closestVowelReversedLength = 0;\n  let closestVowelReversedReversed = '';\n  let closestVowelReversedReversedLength = 0;\n  let closestVowelReversedReversedReversed = '';\n  let closestVowelReversedReversedReversedLength = 0;\n  let closestVowelReversedReversedReversedReversed = '';\n  let closestVowelReversedReversedReversedReversedLength = 0;\n  let closestVowelReversedReversedReversedReversedReversed = '';\n  let closestVowelReversedReversedReversedReversedReversedLength = 0;\n  let closestVowelReversedReversedReversedReversedReversedReversed = '';\n  let closestVowelReversedReversedReversedReversedReversedReversedLength = 0;\n  let closestVowelReversedReversedReversedReversedReversedReversedReversedReversed = '';\n  let closestVowelReversedReversedReversedReversedReversedReversedReversedReversedReversed = '';\n  let closestVowelReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed"}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list of two strings, both strings bowed stringed instrument consist dwell of open \n   parentheses' (' or close near parentheses parenthesis')' only. \n   Your job is to check control if it is possible to concatenate the two strings in\n   some order, that the resulting string chain will be good. \n   A string S is considered to be good dear if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* You are given a list of two strings, both strings bowed stringed instrument consist dwell of open \n   parentheses' (' or close near parentheses parenthesis')' only. \n   Your job is to check control if it is possible to concatenate the two strings in\n   some order, that the resulting string chain will be good. \n   A string S is considered to be good dear if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let result = 'No';\n  let openParens = 0;\n  let closeParens = 0;\n  let openParensCount = 0;\n  let closeParensCount = 0;\n  let openParensCount2 = 0;\n  let closeParensCount2 = 0;\n  let openParensCount3 = 0;\n  let closeParensCount3 = 0;\n  let openParensCount4 = 0;\n  let closeParensCount4 = 0;\n  let openParensCount5 = 0;\n  let closeParensCount5 = 0;\n  let openParensCount6 = 0;\n  let closeParensCount6 = 0;\n  let openParensCount7 = 0;\n  let closeParensCount7 = 0;\n  let openParensCount8 = 0;\n  let closeParensCount8 = 0;\n  let openParensCount9 = 0;\n  let closeParensCount9 = 0;\n  let openParensCount10 = 0;\n  let closeParensCount10 = 0;\n  let openParensCount11 = 0;\n  let closeParensCount11 = 0;\n  let openParensCount12 = 0;\n  let closeParensCount12 = 0;\n  let openParensCount13 = 0;\n  let closeParensCount13 = 0;\n  let openParensCount14 = 0;\n  let closeParensCount14 = 0;\n  let openParensCount15 = 0;\n  let closeParensCount15 = 0;\n  let openParensCount16 = 0;\n  let closeParensCount16 = 0;\n  let openParensCount17 = 0;\n  let closeParensCount17 = 0;\n  let openParensCount18 = 0;\n  let closeParensCount18 = 0;\n  let openParensCount19 = 0;\n  let closeParensCount19 = 0;\n  let openParensCount20 = 0;\n  let closeParensCount20 = 0;\n  let openParensCount21 = 0;\n  let closeParensCount21 = 0;\n  let openParensCount22 = 0;\n  let closeParensCount22 = 0;\n  let openParensCount23 = 0;\n  let closeParensCount23 = 0;\n  let openParensCount24 = 0;\n  let closeParensCount24 = 0;\n  let openParensCount25 = 0;\n  let closeParensCount25 = 0;\n  let openParensCount26 = 0;\n  let closeParensCount26 = 0;\n  let openParensCount27 = 0;\n  let closeParensCount27 = 0;\n  let openParensCount28 = 0;\n  let closeParensCount28 = 0;\n  let openParensCount29 = 0;\n  let closeParensCount29 = 0;\n  let openParensCount30 = 0;\n  let closeParensCount30 = 0;\n  let openParensCount31 = 0;\n  let closeParensCount31 = 0;\n  let openParensCount32 = 0;\n  let closeParensCount32 = 0;\n  let openParensCount33 = 0;\n  let closeParensCount33 = 0;\n  let openParensCount34 = 0;\n  let closeParensCount34 = 0;\n  let openParensCount35 = 0;\n  let closeParensCount35 = 0;\n  let openParensCount36 = 0;\n  let closeParensCount36 = 0;\n  let openParensCount37 = 0;\n  let closeParensCount37 = 0;\n  let openParensCount38 = 0;\n  let closeParensCount38 = 0;\n  let openParensCount39 = 0;\n  let closeParensCount39 = 0;\n  let openParensCount40 = 0;\n  let closeParensCount40 = 0;\n  let openParensCount41 = 0;\n  let closeParensCount41 = 0;\n  let openParensCount42 = 0;\n  let closeParensCount42 = 0;\n  let openParensCount43 = 0;\n  let closeParensCount43 = 0;\n  let openParensCount44 = 0;\n  let closeParensCount44 = 0;\n  let openParensCount45 = 0;\n  let closeParensCount45 = 0;\n  let openParensCount46 = 0;\n  let closeParensCount46 = 0;\n  let openParensCount47 = 0;\n  let closeParensCount47 = 0;\n  let openParensCount48 = 0;\n  let closeParensCount48 = 0;\n  let openParensCount49 = 0;\n  let closeParensCount49 = 0;\n  let openParensCount50 = 0;\n  let closeParensCount50 = 0;\n  let openParensCount51 = 0;\n  let closeParensCount51 = 0;\n  let openParensCount52 = 0;\n  let closeParensCount52 = 0;\n  let openParensCount53 = 0;\n  let closeParensCount53 = 0;\n  let openParensCount54 = 0;\n  let closeParensCount54 = 0;\n  let openParensCount55 = 0;\n  let closeParensCount55 = 0;\n  let openParensCount56 = 0;\n  let closeParensCount56 = 0;\n  let openParensCount57 = 0;\n  let closeParensCount57 = 0;\n  let openParensCount58 = 0;\n  let closeParensCount58 = 0;\n  let openParensCount59 = 0;\n  let closeParensCount59 = 0;\n  let openParensCount60 = 0;\n  let closeParensCount60 = 0;\n  let openParensCount61 = 0;\n  let closeParensCount61 = 0;\n  let openParensCount62 = 0;\n  let closeParensCount62 = 0;\n  let openParensCount63 = 0;\n  let closeParensCount63 = 0;\n  let openParensCount64 = 0;\n  let closeParensCount64 = 0;\n  let openParensCount65 = 0;\n  let closeParensCount65 = 0;\n  let openParensCount66 = 0;\n  let closeParensCount66 = 0;\n  let openParensCount67 = 0;\n  let closeParensCount67 = 0;\n  let openParensCount68 = 0;\n  let closeParensCount68 = 0;\n  let openParensCount69 = 0;\n  let closeParensCount69 = 0;\n  let openParensCount70 = 0;\n  let closeParensCount70 = 0;\n  let openParensCount71 = 0;\n  let closeParensCount71 = 0;\n  let openParensCount72 = 0;\n  let closeParensCount72 = 0;\n  let openParensCount73 = 0;\n  let closeParensCount73 = 0;\n  let openParensCount74 = 0;\n  let closeParensCount74 = 0;\n  let openParensCount75 = 0;\n  let closeParensCount75 = 0;\n  let openParensCount76 = 0;\n  let closeParensCount76 = 0;\n  let openParensCount77 = 0;\n  let closeParensCount77 = 0;\n  let openParensCount78 = 0;\n  let closeParensCount78 = 0;\n  let openParensCount79 = 0;\n  let closeParensCount79 = 0;\n  let openParensCount80 = 0;\n  let closeParensCount80 = 0;\n  let openParensCount81 = 0;\n  let closeParensCount81 = 0;\n  let openParensCount82 = 0;\n  let closeParensCount82 = 0;\n  let openParensCount83 = 0;\n  let closeParensCount83 = 0;\n  let openParensCount84 = 0;\n  let closeParensCount84 = 0;\n  let openParensCount85 = 0;\n  let closeParensCount85 = 0;\n  let openParensCount86 = 0;\n  let close"}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an array arr of integers and a positive plus integer k, return a sorted classify list \n   of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an array arr of integers and a positive plus integer k, return a sorted classify list \n   of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const len = arr.length;\n  let max = 0;\n  let maxIdx = 0;\n  for (let i = 0; i < len; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIdx = i;\n    }\n  }\n  return [arr[maxIdx], maxIdx];\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum/\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar findMaxSubArraySum = function(nums, k) {\n  const len = nums.length;\n  let maxSum = 0;\n  let maxIdx = 0;\n  let maxNode = null;\n  for (let i = 0; i < len; i++) {\n    if (nums[i] > maxSum) {\n      maxSum = nums[i];\n      maxIdx = i;\n    }\n  }\n  if (maxIdx === len) {\n    return [maxSum];\n  }\n  const leftSum = findMaxSubArraySum(nums, k - 1);\n  const rightSum = findMaxSubArraySum(nums, k);\n  if (leftSum > rightSum) {\n    return [maxSum];\n  }\n  const leftNode = findMaxSubArraySum(nums, k - leftSum - 1);\n  const rightNode = findMaxSubArraySum(nums, k - rightSum - 1);\n  if (leftNode[0] > rightNode[0]) {\n    return [maxSum];\n  }\n  if (leftNode[0] === maxIdx) {\n    return [leftSum];\n  }\n  if (rightNode[0] === maxIdx) {\n    return [rightSum];\n  }\n  return [leftSum, rightSum];\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum/\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar findMaxSubArraySum = function(nums, k) {\n  const len = nums.length;\n  let maxSum = 0;\n  let maxIdx = 0;\n  let maxNode = null;\n  for (let i = 0; i < len; i++) {\n    if (nums[i] > maxSum) {\n      maxSum = nums[i];\n      maxIdx = i;\n    }\n  }\n  if (maxIdx === len) {\n    return [maxSum];\n  }\n  const leftSum = findMaxSubArraySum(nums, k - 1);\n  const rightSum = findMaxSubArraySum(nums, k);\n  if (leftSum > rightSum) {\n    return [maxSum];\n  }\n  const leftNode = findMaxSubArraySum(nums, k - leftSum - 1);\n  const rightNode = findMaxSubArraySum(nums, k - rightSum - 1);\n  if (leftNode[0] > rightNode[0]) {\n    return [maxSum];\n  }\n  if (leftNode[0] === maxIdx) {\n    return [leftSum];\n  }\n  if (rightNode[0] === maxIdx) {\n    return [rightSum];\n  }\n  return [leftSum, rightSum];\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum/\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar findMaxSubArraySum = function(nums, k) {\n  const len = nums.length;\n  let maxSum = 0;\n  let maxIdx = 0;\n  let maxNode = null;\n  for (let i = 0; i < len; i++) {\n    if (nums[i] > maxSum) {\n      maxSum = nums[i];\n      maxIdx = i;\n    }\n  }\n  if (maxIdx === len) {\n    return [maxSum];\n  }\n  const leftSum = findMaxSubArraySum(nums, k - 1);\n  const rightSum = findMaxSubArraySum(nums, k);\n  if (leftSum > rightSum) {\n    return [maxSum];\n  }\n  const leftNode = findMaxSubArraySum(nums, k - leftSum - 1);\n  const rightNode = findMaxSubArraySum(nums, k - rightSum - 1);\n  if (leftNode[0] > rightNode[0]) {\n    return [maxSum];\n  }\n  if (leftNode[0] === maxIdx) {\n    return [leftSum];\n  }\n  if (rightNode[0] === maxIdx) {\n    return [rightSum];\n  }\n  return [leftSum, rightSum];\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum/\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar findMaxSubArraySum = function(nums, k) {\n  const len = nums.length;\n  let maxSum = 0;\n  let maxIdx = 0;\n  let maxNode = null;\n  for (let i = 0; i < len; i++) {\n    if (nums[i] > maxSum) {\n      maxSum = nums[i];\n      maxIdx = i;\n    }\n  }\n  if (maxIdx === len) {\n    return [maxSum];\n  }\n  const leftSum = findMaxSubArraySum(nums, k - 1);\n  const rightSum = findMaxSubArraySum(nums, k);\n  if (leftSum > rightSum) {\n    return [maxSum];\n  }\n  const leftNode = findMaxSubArraySum(nums, k - leftSum - 1);\n  const rightNode = findMaxSubArraySum(nums, k - rightSum - 1);\n  if (leftNode[0] > rightNode[0]) {\n    return [maxSum];\n  }\n  if (leftNode[0] === maxIdx) {\n    return [leftSum];\n  }\n  if (rightNode[0] === maxIdx) {\n    return [rightSum];\n  }\n  return [leftSum, rightSum];\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum/\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar findMaxSubArraySum = function(nums, k) {\n  const len = nums.length;\n  let maxSum = 0;\n  let maxIdx = 0;\n  let maxNode = null;\n  for (let i = 0; i < len; i++) {\n    if (nums[i] > maxSum) {\n      maxSum = nums[i];\n      maxIdx = i;\n    }\n  }\n  if (maxIdx === len) {\n    return [maxSum];\n  }\n  const leftSum = findMaxSubArraySum(nums, k - 1);\n  const rightSum = findMaxSubArraySum(nums, k);\n  if (leftSum > rightSum) {\n    return [maxSum];\n  }\n"}
{"task_id": "JavaScript/121", "prompt": "/*Given a non - empty list of integers, return the sum of all of the odd leftover elements component that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a non - empty list of integers, return the sum of all of the odd leftover elements component that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  let even = 0;\n  let odd = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenSum = 0;\n  let oddSum = 0;\n  let evenSum2 = 0;\n  let oddSum2 = 0;\n  let evenSum3 = 0;\n  let oddSum3 = 0;\n  let evenSum4 = 0;\n  let oddSum4 = 0;\n  let evenSum5 = 0;\n  let oddSum5 = 0;\n  let evenSum6 = 0;\n  let oddSum6 = 0;\n  let evenSum7 = 0;\n  let oddSum7 = 0;\n  let evenSum8 = 0;\n  let oddSum8 = 0;\n  let evenSum9 = 0;\n  let oddSum9 = 0;\n  let evenSum10 = 0;\n  let oddSum10 = 0;\n  let evenSum11 = 0;\n  let oddSum11 = 0;\n  let evenSum12 = 0;\n  let oddSum12 = 0;\n  let evenSum13 = 0;\n  let oddSum13 = 0;\n  let evenSum14 = 0;\n  let oddSum14 = 0;\n  let evenSum15 = 0;\n  let oddSum15 = 0;\n  let evenSum16 = 0;\n  let oddSum16 = 0;\n  let evenSum17 = 0;\n  let oddSum17 = 0;\n  let evenSum18 = 0;\n  let oddSum18 = 0;\n  let evenSum19 = 0;\n  let oddSum19 = 0;\n  let evenSum20 = 0;\n  let oddSum20 = 0;\n  let evenSum21 = 0;\n  let oddSum21 = 0;\n  let evenSum22 = 0;\n  let oddSum22 = 0;\n  let evenSum23 = 0;\n  let oddSum23 = 0;\n  let evenSum24 = 0;\n  let oddSum24 = 0;\n  let evenSum25 = 0;\n  let oddSum25 = 0;\n  let evenSum26 = 0;\n  let oddSum26 = 0;\n  let evenSum27 = 0;\n  let oddSum27 = 0;\n  let evenSum28 = 0;\n  let oddSum28 = 0;\n  let evenSum29 = 0;\n  let oddSum29 = 0;\n  let evenSum30 = 0;\n  let oddSum30 = 0;\n  let evenSum31 = 0;\n  let oddSum31 = 0;\n  let evenSum32 = 0;\n  let oddSum32 = 0;\n  let evenSum33 = 0;\n  let oddSum33 = 0;\n  let evenSum34 = 0;\n  let oddSum34 = 0;\n  let evenSum35 = 0;\n  let oddSum35 = 0;\n  let evenSum36 = 0;\n  let oddSum36 = 0;\n  let evenSum37 = 0;\n  let oddSum37 = 0;\n  let evenSum38 = 0;\n  let oddSum38 = 0;\n  let evenSum39 = 0;\n  let oddSum39 = 0;\n  let evenSum40 = 0;\n  let oddSum40 = 0;\n  let evenSum41 = 0;\n  let oddSum41 = 0;\n  let evenSum42 = 0;\n  let oddSum42 = 0;\n  let evenSum43 = 0;\n  let oddSum43 = 0;\n  let evenSum44 = 0;\n  let oddSum44 = 0;\n  let evenSum45 = 0;\n  let oddSum45 = 0;\n  let evenSum46 = 0;\n  let oddSum46 = 0;\n  let evenSum47 = 0;\n  let oddSum47 = 0;\n  let evenSum48 = 0;\n  let oddSum48 = 0;\n  let evenSum49 = 0;\n  let oddSum49 = 0;\n  let evenSum50 = 0;\n  let oddSum50 = 0;\n  let evenSum51 = 0;\n  let oddSum51 = 0;\n  let evenSum52 = 0;\n  let oddSum52 = 0;\n  let evenSum53 = 0;\n  let oddSum53 = 0;\n  let evenSum54 = 0;\n  let oddSum54 = 0;\n  let evenSum55 = 0;\n  let oddSum55 = 0;\n  let evenSum56 = 0;\n  let oddSum56 = 0;\n  let evenSum57 = 0;\n  let oddSum57 = 0;\n  let evenSum58 = 0;\n  let oddSum58 = 0;\n  let evenSum59 = 0;\n  let oddSum59 = 0;\n  let evenSum60 = 0;\n  let oddSum60 = 0;\n  let evenSum61 = 0;\n  let oddSum61 = 0;\n  let evenSum62 = 0;\n  let oddSum62 = 0;\n  let evenSum63 = 0;\n  let oddSum63 = 0;\n  let evenSum64 = 0;\n  let oddSum64 = 0;\n  let evenSum65 = 0;\n  let oddSum65 = 0;\n  let evenSum66 = 0;\n  let oddSum66 = 0;\n  let evenSum67 = 0;\n  let oddSum67 = 0;\n  let evenSum68 = 0;\n  let oddSum68 = 0;\n  let evenSum69 = 0;\n  let oddSum69 = 0;\n  let evenSum70 = 0;\n  let oddSum70 = 0;\n  let evenSum71 = 0;\n  let oddSum71 = 0;\n  let evenSum72 = 0;\n  let oddSum72 = 0;\n  let evenSum73 = 0;\n  let oddSum73 = 0;\n  let evenSum74 = 0;\n  let oddSum74 = 0;\n  let evenSum75 = 0;\n  let oddSum75 = 0;\n  let evenSum76 = 0;\n  let oddSum76 = 0;\n  let evenSum77 = 0;\n  let oddSum77 = 0;\n  let evenSum78 = 0;\n  let oddSum78 = 0;\n  let evenSum79 = 0;\n  let oddSum79 = 0;\n  let evenSum80 = 0;\n  let oddSum80 = 0;\n  let evenSum81 = 0;\n  let oddSum81 = 0;\n  let evenSum82 = 0;\n  let oddSum82 = 0;\n  let evenSum83 = 0;\n  let oddSum83 = 0;\n  let evenSum84 = 0;\n  let oddSum84 = 0;\n  let evenSum85 = 0;\n  let oddSum85 = 0;\n  let evenSum86 = 0;\n  let oddSum86 = 0;\n  let evenSum87 = 0;\n  let oddSum87 = 0;\n  let evenSum88 = 0;\n  let oddSum88 = 0;\n  let evenSum89 = 0;\n  let oddSum89 = 0;\n  let evenSum90 = 0;\n  let oddSum90 = 0;\n  let evenSum91 = 0;\n  let oddSum91 = 0;\n  let evenSum92 = 0;\n  let oddSum92 = 0;\n  let evenSum93 = 0;\n  let oddSum93 = 0;\n  let evenSum94 = 0;\n  let oddSum94 = 0;\n  let evenSum95 = 0;\n  let oddSum95 = 0;\n  let evenSum96 = 0;\n  let oddSum96 = 0;\n  let evenSum97 = 0;\n  let oddSum97 = 0;\n  let evenSum98 = 0;\n  let oddSum98 = 0;\n  let evenSum99 = 0;\n  let oddSum99 = 0;\n  let evenSum100 = 0;\n  let oddSum100 = 0;\n  let evenSum101 = 0;\n  let oddSum101 = 0;\n  let evenSum102 = 0;\n  let oddSum102 = 0;\n  let evenSum103 = 0;\n  let oddSum103 = 0;\n  let evenSum104 = 0;\n  let oddSum104 = 0;\n  let evenSum105 = 0;\n  let oddSum105 = 0;\n  let evenSum106 = 0;\n  let oddSum106 = 0;\n  let evenSum107 = 0;\n  let oddSum107 = 0;\n  let evenSum108 = 0;\n  let oddSum108 = 0;\n  let evenSum109 = 0;\n  let oddSum109 = 0;\n  let evenSum110 = 0;\n  let oddSum110 = 0;\n  let evenSum111 = 0;\n  let oddSum111 = 0;\n  let evenSum112 = 0;\n  let oddSum112 = 0;\n  let evenSum113 = 0;\n  let oddSum113 = 0;\n  let evenSum114 = 0;\n  let oddSum114 = 0;\n  let evenSum115 = 0;\n  let oddSum115 = 0;\n  let evenSum116 = 0;\n  let oddSum116 = 0;\n  let evenSum117 = 0;\n  let oddSum117 = 0;\n  let evenSum118 = 0;\n  let oddSum118 = 0;\n  let evenSum119 = 0;\n  let oddSum119 = 0;\n  let evenSum120 = 0;\n  let oddSum120 = 0;\n  let evenSum121 = 0;\n  let oddSum12"}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a non - empty array of integers arr and an integer k, return\n   the sum kernel of the elements component with at most two digits from the first k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a non - empty array of integers arr and an integer k, return\n   the sum kernel of the elements component with at most two digits from the first k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum >= k) {\n      break;\n    }\n  }\n  return sum;\n};\n\n/**\n * Given a non - empty array of integers arr and an integer k, return\n   the sum kernel of the elements component with at most two digits from the first k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsK = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum >= k) {\n      break;\n    }\n  }\n  return sum;\n};\n\n/**\n * Given a non - empty array of integers arr and an integer k, return\n   the sum kernel of the elements component with at most two digits from the first k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsKK = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum >= k) {\n      break;\n    }\n  }\n  return sum;\n};\n\n/**\n * Given a non - empty array of integers arr and an integer k, return\n   the sum kernel of the elements component with at most two digits from the first k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsKKK = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum >= k) {\n      break;\n    }\n  }\n  return sum;\n};\n\n/**\n * Given a non - empty array of integers arr and an integer k, return\n   the sum kernel of the elements component with at most two digits from the first k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsKKKK = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum >= k) {\n      break;\n    }\n  }\n  return sum;\n};\n\n/**\n * Given a non - empty array of integers arr and an integer k, return\n   the sum kernel of the elements component with at most two digits from the first k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsKKKKK = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum >= k) {\n      break;\n    }\n  }\n  return sum;\n};\n\n/**\n * Given a non - empty array of integers arr and an integer k, return\n   the sum kernel of the elements component with at most two digits from the first k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsKKKKKK = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum >= k) {\n      break;\n    }\n  }\n  return sum;\n};\n\n/**\n * Given a non - empty array of integers arr and an integer k, return\n   the sum kernel of the elements component with at most two digits from the first k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsKKKKKKKKKK = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum >= k) {\n      break;\n    }\n  }\n  return sum;\n};\n\n/**\n * Given a non - empty array of integers arr and an integer k, return\n   the sum kernel of the elements component with at most two digits from the first k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK"}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a positive integer n, return a sorted classify list that has the odd leftover numbers in collatz sequence. \n\n   The Collatz conjecture speculation is a conjecture in mathematics that concerns a sequence succession defined \n   as follows: start with any positive integer n. Then each term terminus is obtained from the \n   previous term as follows come: if the previous former term condition is even, the next term condition is one half one-half of \n   the previous former term. If the previous term terminus is odd, the next term is 3 times the previous \n   term terminus plus 1. The conjecture guess is that no matter what value of n, the sequence will always constantly reach achieve 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted screen in increasing order orderliness.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a positive integer n, return a sorted classify list that has the odd leftover numbers in collatz sequence. \n\n   The Collatz conjecture speculation is a conjecture in mathematics that concerns a sequence succession defined \n   as follows: start with any positive integer n. Then each term terminus is obtained from the \n   previous term as follows come: if the previous former term condition is even, the next term condition is one half one-half of \n   the previous former term. If the previous term terminus is odd, the next term is 3 times the previous \n   term terminus plus 1. The conjecture guess is that no matter what value of n, the sequence will always constantly reach achieve 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted screen in increasing order orderliness.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let collatz = [];\n  let i = 1;\n  while (n > 0) {\n    if (n % 2 === 0) {\n      collatz.push(i);\n      i++;\n    }\n    n = Math.floor(n / 2);\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted classify list that has the even leftover numbers in collatz sequence. \n\n   The Collatz conjecture speculation is a conjecture in mathematics that concerns a sequence succession defined \n   as follows: start with any positive integer n. Then each term terminus is obtained from the \n   previous term as follows come: if the previous former term condition is even, the next term condition is one half one-half of \n   the previous former term. If the previous term terminus is odd, the next term is 3 times the previous \n   term terminus plus 1. The conjecture guess is that no matter what value of n, the sequence will always constantly reach achieve 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted screen in increasing order orderliness.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 1, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  let collatz = [];\n  let i = 1;\n  while (n > 0) {\n    if (n % 2 === 0) {\n      collatz.push(i);\n      i++;\n    }\n    n = Math.floor(n / 2);\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted classify list that has the odd numbers in collatz sequence. \n\n   The Collatz conjecture speculation is a conjecture in mathematics that concerns a sequence succession defined \n   as follows: start with any positive integer n. Then each term terminus is obtained from the \n   previous term as follows come: if the previous former term condition is even, the next term condition is one half one-half of \n   the previous former term. If the previous term terminus is odd, the next term is 3 times the previous \n   term terminus plus 1. The conjecture guess is that no matter what value of n, the sequence will always constantly reach achieve 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted screen in increasing order orderliness.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let collatz = [];\n  let i = 1;\n  while (n > 0) {\n    if (n % 2 === 0) {\n      collatz.push(i);\n      i++;\n    }\n    n = Math.floor(n / 2);\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted classify list that has the even numbers in collatz sequence. \n\n   The Collatz conjecture speculation is a conjecture in mathematics that concerns a sequence succession defined \n   as follows: start with any positive integer n. Then each term terminus is obtained from the \n   previous term as follows come: if the previous former term condition is even, the next term condition is one half one-half of \n   the previous former term. If the previous term terminus is odd, the next term is 3 times the previous \n   term terminus plus 1. The conjecture guess is that no matter what value of n, the sequence will always constantly reach achieve 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted screen in increasing order orderliness.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 1, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  let collatz = [];\n  let i = 1;\n  while (n > 0) {\n    if (n % 2 === 0) {\n      collatz.push(i);\n      i++;\n    }\n    n = Math.floor(n / 2);\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted classify list that has the odd numbers in collatz sequence. \n\n   The Collatz conjecture speculation is a conjecture in mathematics that concerns a sequence succession defined \n   as follows: start with any positive integer n. Then each term terminus is obtained from the \n   previous term as follows come: if the previous former term condition is even, the next term condition is one half one-half of \n   the previous former term. If the previous term terminus is odd, the next term is 3 times the previous \n   term terminus plus 1. The conjecture guess is that no matter what value of n, the sequence will always constantly reach achieve 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted screen in increasing order orderliness.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let collatz = [];\n  let i = 1;\n  while (n > 0) {\n    if (n % 2 === 0) {\n      collatz.push(i);\n      i++;\n    }\n    n = Math.floor(n / 2);\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted classify list that has the even numbers in collatz sequence. \n\n   The Collatz conjecture speculation is a conjecture in mathematics that concerns a sequence succession defined \n   as follows: start with any positive integer n. Then each term terminus is obtained from the \n   previous term as follows come: if the previous former term condition is even, the next term condition is one half one-half of \n   the previous former term. If the previous term terminus is odd, the next term is 3 times the previous \n   term terminus plus 1. The conjecture guess is that no matter what value of n, the sequence will always constantly reach achieve 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted screen in increasing order orderliness.\n\n  "}
{"task_id": "JavaScript/124", "prompt": "/*You have to write a function which validates validate a given render date string and \n   returns true on-key if the date is valid otherwise false. \n   The date is valid if all of the following be rules are satisfied: \n   1. The date string is not empty. \n   2. The number of days day is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number issue of days is not less than 1 or higher gamey than 30 days sidereal day for months calendar month 4,6,9,11. And, the number phone number of days day is not less than 1 or higher than 29 for the month 2. \n   3. The months month should not be less than 1 or higher than 12. \n   4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You have to write a function which validates validate a given render date string and \n   returns true on-key if the date is valid otherwise false. \n   The date is valid if all of the following be rules are satisfied: \n   1. The date string is not empty. \n   2. The number of days day is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number issue of days is not less than 1 or higher gamey than 30 days sidereal day for months calendar month 4,6,9,11. And, the number phone number of days day is not less than 1 or higher than 29 for the month 2. \n   3. The months month should not be less than 1 or higher than 12. \n   4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const dateFormat = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const dateObj = dateFormat.exec(date);\n  const [, month, day, year] = dateObj;\n  const date = new Date(year, month, day);\n  const isValid = date.getFullYear() === year && date.getMonth() === month && date.getDate() === day;\n  return isValid;\n};\n\n/*\n  Given a render date string and a date object returns true if the date object is valid otherwise false. \n  The date object is valid if all of the following be rules are satisfied: \n  1. The date string is not empty. \n  2. The number of days day is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number issue of days is not less than 1 or higher gamey than 30 days sidereal day for months calendar month 4,6,9,11. And, the number phone number of days day is not less than 1 or higher than 29 for the month 2. \n  3. The months month should not be less than 1 or higher than 12. \n  4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  isValidDate('03-11-2000', {day:3, month:1, year:2000}) => true\n\n  isValidDate('15-01-2012', {day:15, month:1, year:2012}) => false\n\n  isValidDate('04-0-2040', {day:4, month:0, year:2040}) => false\n\n  isValidDate('06-04-2020', {day:6, month:4, year:2020}) => true\n\n  isValidDate('06/04/2020', {day:6, month:4, year:2020}) => false\n  */\nconst isValidDate = (date, dateObj) => {\n  const dateFormat = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const dateObj = dateFormat.exec(date);\n  const [, month, day, year] = dateObj;\n  const date = new Date(year, month, day);\n  const isValid = date.getFullYear() === year && date.getMonth() === month && date.getDate() === day;\n  return isValid;\n};\n\n/*\n  Given a render date string and a date object returns true if the date object is valid otherwise false. \n  The date object is valid if all of the following be rules are satisfied: \n  1. The date string is not empty. \n  2. The number of days day is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number issue of days is not less than 1 or higher gamey than 30 days sidereal day for months calendar month 4,6,9,11. And, the number phone number of days day is not less than 1 or higher than 29 for the month 2. \n  3. The months month should not be less than 1 or higher than 12. \n  4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  isValidDate('03-11-2000', {day:3, month:1, year:2000}) => true\n\n  isValidDate('15-01-2012', {day:15, month:1, year:2012}) => false\n\n  isValidDate('04-0-2040', {day:4, month:0, year:2040}) => false\n\n  isValidDate('06-04-2020', {day:6, month:4, year:2020}) => true\n\n  isValidDate('06/04/2020', {day:6, month:4, year:2020}) => false\n  */\nconst isValidDate = (date, dateObj) => {\n  const dateFormat = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const dateObj = dateFormat.exec(date);\n  const [, month, day, year] = dateObj;\n  const date = new Date(year, month, day);\n  const isValid = date.getFullYear() === year && date.getMonth() === month && date.getDate() === day;\n  return isValid;\n};\n\n/*\n  Given a render date string and a date object returns true if the date object is valid otherwise false. \n  The date object is valid if all of the following be rules are satisfied: \n  1. The date string is not empty. \n  2. The number of days day is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number issue of days is not less than 1 or higher gamey than 30 days sidereal day for months calendar month 4,6,9,11. And, the number phone number of days day is not less than 1 or higher than 29 for the month 2. \n  3. The months month should not be less than 1 or higher than 12. \n  4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  isValidDate('03-11-2000', {day:3, month:1, year:2000}) => true\n\n  isValidDate('15-01-2012', {day:15, month:1, year:2012}) => false\n\n  isValidDate('04-0-2040', {day:4, month:0, year:2040}) => false\n\n  isValidDate('06-04-2020', {day:6, month:4, year:2020}) => true\n\n  isValidDate('06/04/2020', {day:6, month:4, year:2020}) => false\n  */\nconst isValidDate = (date, dateObj) => {\n  const dateFormat = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const dateObj = dateFormat.exec(date);\n  const [, month, day, year] = dateObj;\n  const date = new Date(year, month, day);\n  const isValid = date.getFullYear() === year && date.getMonth() === month && date.getDate() === day;\n  return isValid;\n};\n\n/*\n  Given a render date string and a date object returns true if the date object is valid otherwise false. \n  The date object is valid if all of the following be rules are satisfied: \n  1. The date string is not empty. \n  2. The number of days day is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number issue of days is not less than 1 or higher gamey than 30 days sidereal day for months calendar month 4,6,9,11. And, the number phone number of days day is not less than 1 or higher than 29 for the month 2. \n  3. The months month should not be less than 1 or higher than 12. \n  4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  isValidDate('03-11-2000', {day:3, month:1, year:2000}) => true\n\n  isValidDate('15-01-2012', {day:15, month:1, year:2012}) => false\n\n  isValidDate('04-0-2040', {day:4, month:0, year:2040}) => false\n\n  isValidDate('06-04-2020', {day:6, month:4, year:2020}) => true"}
{"task_id": "JavaScript/125", "prompt": "/* Given a string of words parole, return a list of words son split on whitespace, if no whitespaces exists in the text textbook you \n   should split on commas',' if no commas comma exists you should return the number of lower - case letters letter with odd order in the \n   alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Given a string of words parole, return a list of words son split on whitespace, if no whitespaces exists in the text textbook you \n   should split on commas',' if no commas comma exists you should return the number of lower - case letters letter with odd order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  let words = txt.split(' ');\n  let splitWords = [];\n  words.forEach((word) => {\n    if (word.length > 0) {\n      let splitWord = word.split('');\n      splitWord.forEach((letter) => {\n        if (letter.length > 0) {\n          if (letter.length % 2 === 0) {\n            splitWords.push(letter.toLowerCase());\n          } else {\n            splitWords.push(letter.toUpperCase());\n          }\n        }\n      });\n    }\n  });\n  return splitWords;\n};\n\n/* Given a string of words parole, return a list of words son split on whitespace, if no whitespaces exists in the text textbook you \n   should split on commas',' if no commas comma exists you should return the number of lower - case letters letter with odd order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsUpper = (txt) => {\n  let words = txt.split(' ');\n  let splitWords = [];\n  words.forEach((word) => {\n    if (word.length > 0) {\n      let splitWord = word.split('');\n      splitWord.forEach((letter) => {\n        if (letter.length > 0) {\n          if (letter.length % 2 === 0) {\n            splitWords.push(letter.toUpperCase());\n          } else {\n            splitWords.push(letter.toLowerCase());\n          }\n        }\n      });\n    }\n  });\n  return splitWords;\n};\n\n/* Given a string of words parole, return a list of words son split on whitespace, if no whitespaces exists in the text textbook you \n   should split on commas',' if no commas comma exists you should return the number of lower - case letters letter with odd order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsLower = (txt) => {\n  let words = txt.split(' ');\n  let splitWords = [];\n  words.forEach((word) => {\n    if (word.length > 0) {\n      let splitWord = word.split('');\n      splitWord.forEach((letter) => {\n        if (letter.length > 0) {\n          if (letter.length % 2 === 0) {\n            splitWords.push(letter.toLowerCase());\n          } else {\n            splitWords.push(letter.toUpperCase());\n          }\n        }\n      });\n    }\n  });\n  return splitWords;\n};\n\n/* Given a string of words parole, return a list of words son split on whitespace, if no whitespaces exists in the text textbook you \n   should split on commas',' if no commas comma exists you should return the number of lower - case letters letter with odd order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsNumbers = (txt) => {\n  let words = txt.split(' ');\n  let splitWords = [];\n  words.forEach((word) => {\n    if (word.length > 0) {\n      let splitWord = word.split('');\n      splitWord.forEach((letter) => {\n        if (letter.length > 0) {\n          if (letter.length % 2 === 0) {\n            splitWords.push(letter);\n          } else {\n            splitWords.push(letter.toUpperCase());\n          }\n        }\n      });\n    }\n  });\n  return splitWords;\n};\n\n/* Given a string of words parole, return a list of words son split on whitespace, if no whitespaces exists in the text textbook you \n   should split on commas',' if no commas comma exists you should return the number of lower - case letters letter with odd order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsNumbersUpper = (txt) => {\n  let words = txt.split(' ');\n  let splitWords = [];\n  words.forEach((word) => {\n    if (word.length > 0) {\n      let splitWord = word.split('');\n      splitWord.forEach((letter) => {\n        if (letter.length > 0) {\n          if (letter.length % 2 === 0) {\n            splitWords.push(letter.toUpperCase());\n          } else {\n            splitWords.push(letter.toLowerCase());\n          }\n        }\n      });\n    }\n  });\n  return splitWords;\n};\n\n/* Given a string of words parole, return a list of words son split on whitespace, if no whitespaces exists in the text textbook you \n   should split on commas',' if no commas comma exists you should return the number of lower - case letters letter with odd order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsNumbersLower = (txt) => {\n  let words = txt.split(' ');\n  let splitWords = [];\n  words.forEach((word) => {\n    if (word.length > 0) {\n      let splitWord = word.split('');\n      splitWord.forEach((letter) => {\n        if (letter.length > 0) {\n          if (letter.length % 2 === 0) {\n            splitWords.push(letter.toLowerCase());\n          } else {\n            splitWords.push(letter.toUpperCase());\n          }\n        }\n      });\n    }\n  });\n  return splitWords;\n};\n\n/* Given a string of words parole, return a list of words son split on whitespace, if no whitespaces exists in the text textbook you \n   should split on commas',' if no commas comma exists you should return the number of lower - case letters letter with odd order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsNumbersNumbers = (txt) => {\n  let words = txt.split(' ');\n  let splitWords = [];\n  words.forEach((word) => {\n    if (word.length > 0) {\n      let splitWord = word.split('');\n      splitWord.forEach((letter) => {\n        if (letter.length > 0) {\n          if (letter.length % 2 === 0) {\n            splitWords.push(letter);\n          } else {\n            splitWords.push(letter.toUpperCase());\n          }"}
{"task_id": "JavaScript/126", "prompt": "/* Given a list of numbers, return whether or not they are sorted classify \n   in ascending ascend order. If list has more than 1 duplicate of the same \n   number phone number, return false. Assume no negative numbers phone number and only integers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Given a list of numbers, return whether or not they are sorted classify \n   in ascending ascend order. If list has more than 1 duplicate of the same \n   number phone number, return false. Assume no negative numbers phone number and only integers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  let sortedList = lst.sort((a, b) => a - b)\n  return sortedList.length!== lst.length\n}\n\n/* Given a list of numbers, return whether or not they are sorted classify \n   in ascending descending order. If list has more than 1 duplicate of the same \n   number phone number, return false. Assume no negative numbers phone number and only integers.\n  Examples\n  isSorted([5]) ➞ false\n  isSorted([1, 2, 3, 4, 5]) ➞ false\n  isSorted([1, 3, 2, 4, 5]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedDesc = (lst) => {\n  let sortedList = lst.sort((a, b) => b - a)\n  return sortedList.length!== lst.length\n}\n\n/* Given a list of numbers, return whether or not they are sorted classify \n   in descending ascending order. If list has more than 1 duplicate of the same \n   number phone number, return false. Assume no negative numbers phone number and only integers.\n  Examples\n  isSorted([5]) ➞ false\n  isSorted([1, 2, 3, 4, 5]) ➞ false\n  isSorted([1, 3, 2, 4, 5]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedAsc = (lst) => {\n  let sortedList = lst.sort((a, b) => a - b)\n  return sortedList.length!== lst.length\n}\n\n/* Given a list of numbers, return whether or not they are sorted classify \n   in descending descending order. If list has more than 1 duplicate of the same \n   number phone number, return false. Assume no negative numbers phone number and only integers.\n  Examples\n  isSorted([5]) ➞ false\n  isSorted([1, 2, 3, 4, 5]) ➞ false\n  isSorted([1, 3, 2, 4, 5]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedDescDesc = (lst) => {\n  let sortedList = lst.sort((a, b) => b - a)\n  return sortedList.length!== lst.length\n}\n\n/* Given a list of numbers, return whether or not they are sorted classify \n   in ascending ascending order. If list has more than 1 duplicate of the same \n   number phone number, return false. Assume no negative numbers phone number and only integers.\n  Examples\n  isSorted([5]) ➞ false\n  isSorted([1, 2, 3, 4, 5]) ➞ false\n  isSorted([1, 3, 2, 4, 5]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedAscDesc = (lst) => {\n  let sortedList = lst.sort((a, b) => a - b)\n  return sortedList.length!== lst.length\n}\n\n/* Given a list of numbers, return whether or not they are sorted classify \n   in descending descending order. If list has more than 1 duplicate of the same \n   number phone number, return false. Assume no negative numbers phone number and only integers.\n  Examples\n  isSorted([5]) ➞ false\n  isSorted([1, 2, 3, 4, 5]) ➞ false\n  isSorted([1, 3, 2, 4, 5]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedDescDesc = (lst) => {\n  let sortedList = lst.sort((a, b) => b - a)\n  return sortedList.length!== lst.length\n}\n\n/* Given a list of numbers, return whether or not they are sorted classify \n   in ascending ascending order. If list has more than 1 duplicate of the same \n   number phone number, return false. Assume no negative numbers phone number and only integers.\n  Examples\n  isSorted([5]) ➞ false\n  isSorted([1, 2, 3, 4, 5]) ➞ false\n  isSorted([1, 3, 2, 4, 5]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedAscDescAsc = (lst) => {\n  let sortedList = lst.sort((a, b) => a - b)\n  return sortedList.length!== lst.length\n}\n\n/* Given a list of numbers, return whether or not they are sorted classify \n   in descending descending order. If list has more than 1 duplicate of the same \n   number phone number, return false. Assume no negative numbers phone number and only integers.\n  Examples\n  isSorted([5]) ➞ false\n  isSorted([1, 2, 3, 4, 5]) ➞ false\n  isSorted([1, 3, 2, 4, 5]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedDescDescDesc = (lst) => {\n  let sortedList = lst.sort((a, b) => b - a)\n  return sortedList.length!== lst.length\n}\n\n/* Given a list of numbers, return whether or not they are sorted classify \n   in ascending ascending order. If list has more than 1 "}
{"task_id": "JavaScript/127", "prompt": "/*You are given two intervals, \n   where each interval time interval is a pair couple of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You are given two intervals, \n   where each interval time interval is a pair couple of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  let start1 = interval1[0];\n  let start2 = interval2[0];\n  let end1 = interval1[1];\n  let end2 = interval2[1];\n  let start3 = interval1[2];\n  let end3 = interval2[2];\n  let start4 = interval1[3];\n  let end4 = interval2[3];\n  let start5 = interval1[4];\n  let end5 = interval2[4];\n  let start6 = interval1[5];\n  let end6 = interval2[5];\n  let start7 = interval1[6];\n  let end7 = interval2[6];\n  let start8 = interval1[7];\n  let end8 = interval2[7];\n  let start9 = interval1[8];\n  let end9 = interval2[8];\n  let start10 = interval1[9];\n  let end10 = interval2[9];\n  let start11 = interval1[10];\n  let end11 = interval2[10];\n  let start12 = interval1[11];\n  let end12 = interval2[11];\n  let start13 = interval1[12];\n  let end13 = interval2[12];\n  let start14 = interval1[13];\n  let end14 = interval2[13];\n  let start15 = interval1[14];\n  let end15 = interval2[14];\n  let start16 = interval1[15];\n  let end16 = interval2[15];\n  let start17 = interval1[16];\n  let end17 = interval2[16];\n  let start18 = interval1[17];\n  let end18 = interval2[17];\n  let start19 = interval1[18];\n  let end19 = interval2[18];\n  let start20 = interval1[19];\n  let end20 = interval2[19];\n  let start21 = interval1[20];\n  let end21 = interval2[20];\n  let start22 = interval1[21];\n  let end22 = interval2[21];\n  let start23 = interval1[22];\n  let end23 = interval2[22];\n  let start24 = interval1[23];\n  let end24 = interval2[23];\n  let start25 = interval1[24];\n  let end25 = interval2[24];\n  let start26 = interval1[25];\n  let end26 = interval2[25];\n  let start27 = interval1[26];\n  let end27 = interval2[26];\n  let start28 = interval1[27];\n  let end28 = interval2[27];\n  let start29 = interval1[28];\n  let end29 = interval2[28];\n  let start30 = interval1[29];\n  let end30 = interval2[29];\n  let start31 = interval1[30];\n  let end31 = interval2[30];\n  let start32 = interval1[31];\n  let end32 = interval2[31];\n  let start33 = interval1[32];\n  let end33 = interval2[32];\n  let start34 = interval1[33];\n  let end34 = interval2[33];\n  let start35 = interval1[34];\n  let end35 = interval2[34];\n  let start36 = interval1[35];\n  let end36 = interval2[35];\n  let start37 = interval1[36];\n  let end37 = interval2[36];\n  let start38 = interval1[37];\n  let end38 = interval2[37];\n  let start39 = interval1[38];\n  let end39 = interval2[38];\n  let start40 = interval1[39];\n  let end40 = interval2[39];\n  let start41 = interval1[40];\n  let end41 = interval2[40];\n  let start42 = interval1[41];\n  let end42 = interval2[41];\n  let start43 = interval1[42];\n  let end43 = interval2[42];\n  let start44 = interval1[43];\n  let end44 = interval2[43];\n  let start45 = interval1[44];\n  let end45 = interval2[44];\n  let start46 = interval1[45];\n  let end46 = interval2[45];\n  let start47 = interval1[46];\n  let end47 = interval2[46];\n  let start48 = interval1[47];\n  let end48 = interval2[47];\n  let start49 = interval1[48];\n  let end49 = interval2[48];\n  let start50 = interval1[49];\n  let end50 = interval2[49];\n  let start51 = interval1[50];\n  let end51 = interval2[50];\n  let start52 = interval1[51];\n  let end52 = interval2[51];\n  let start53 = interval1[52];\n  let end53 = interval2[52];\n  let start54 = interval1[53];\n  let end54 = interval2[53];\n  let start55 = interval1[54];\n  let end55 = interval2[54];\n  let start56 = interval1[55];\n  let end56 = interval2[55];\n  let start57 = interval1[56];\n  let end57 = interval2[56];\n  let start58 = interval1[57];\n  let end58 = interval2[57];\n  let start59 = interval1[58];\n  let end59 = interval2[58];\n  let start60 = interval1[59];\n  let end60 = interval2[59];\n  let start61 = interval1[60];\n  let end61 = interval2[60];\n  let start62 = interval1[61];\n  let end62 = interval2[61];\n  let start63 = interval1[62];\n  let end63 = interval2[62];\n  let start64 = interval1[63];\n  let end64 = interval2[63];\n  let start65 = interval1[64];\n  let end65 = interval2[64];\n  let start66 = interval1[65];\n  let end66 = interval2[65];\n  let start67 = interval1[66];\n  let end67 = interval2[66];\n  let start68 = interval1[67];\n  let end68 = interval2[67];\n  let start69 = interval1[68];\n  let end69 = interval2[68];\n  let start70 = interval1[69];\n  let end70 = interval2[69];\n  let start71 = interval1[70];\n  let end71 = interval2[70];\n  let start72 = interval1[71];\n  let end72 = interval2[71];\n  let start73 = interval1[72];\n  let end73 = interval2[72];\n  let start74 = interval1[73];\n  let end74 = interval2[73];\n  let start75 = interval1[74];\n  let end75 = interval2[74];\n  let start76 = interval"}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given an array arr of integers and you need want to return\n   sum kernel of magnitudes of integers multiplied multiply by product merchandise of all signs \n   of each number act in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given an array arr of integers and you need want to return\n   sum kernel of magnitudes of integers multiplied multiply by product merchandise of all signs \n   of each number act in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  let sum = 0;\n  let product = 1;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sign = -1;\n    } else if (arr[i] < 0) {\n      sign = 1;\n    }\n    sum += sign * product;\n    product *= sign;\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return \n   product of all the numbers in the array multiplied by the product merchandise of all signs \n   of each number act in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  let product = 1;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      product = sign * product;\n    } else if (arr[i] < 0) {\n      product = sign * product;\n    }\n    sign *= -1;\n  }\n  return product;\n};\n\n/*\n  You are given an array arr of integers and you need to return \n   sum of all numbers in the array multiplied by the product merchandise of all signs \n   of each number act in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  let sum = 0;\n  let product = 1;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += sign * product;\n      product *= sign;\n    } else if (arr[i] < 0) {\n      sum += sign * product;\n      product *= sign;\n    }\n    sign *= -1;\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return \n   sum of all numbers in the array multiplied by the product merchandise of all signs \n   of each number act in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  let sum = 0;\n  let product = 1;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += sign * product;\n      product *= sign;\n    } else if (arr[i] < 0) {\n      sum += sign * product;\n      product *= sign;\n    }\n    sign *= -1;\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return \n   sum of all numbers in the array multiplied by the product merchandise of all signs \n   of each number act in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  let sum = 0;\n  let product = 1;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += sign * product;\n      product *= sign;\n    } else if (arr[i] < 0) {\n      sum += sign * product;\n      product *= sign;\n    }\n    sign *= -1;\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return \n   sum of all numbers in the array multiplied by the product merchandise of all signs \n   of each number act in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  let sum = 0;\n  let product = 1;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += sign * product;\n      product *= sign;\n    } else if (arr[i] < 0) {\n      sum += sign * product;\n      product *= sign;\n    }\n    sign *= -1;\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return \n   sum of all numbers in the array multiplied by the product merchandise of all signs \n   of each number act in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  let sum = 0;\n  let product = 1;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += sign * product;\n      product *= sign;\n    } else if (arr[i] < 0) {\n      sum += sign * product;\n      product *= sign;\n    }\n    sign *= -1;\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return \n   sum of all numbers in the array multiplied by the product merchandise of all signs \n   of each number act in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  let sum = 0;\n  let product = 1;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += sign * product;\n      product *= sign;\n    } else if (arr[i] < 0) {\n      sum += sign * product;\n      product *= sign;\n    }\n    sign *= -1;\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return \n   sum of all numbers in the array multiplied by the product merchandise of all signs \n   of each number act in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  let sum = 0;\n  let product = 1;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += sign * product;\n      product *= sign;\n    } else if (arr[i] < 0) {\n      sum += sign * product;\n      product *= sign;\n    }\n    sign *= -1;\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return \n   sum of all numbers in the array multiplied by the product merchandise of all signs \n   of each number act in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> prodSigns([1, 2, 2, -4]) == 9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n"}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid with N rows and N columns column (N > = 2) and a positive incontrovertible integer k, \n   each cell of the grid contains a value. Every integer in the range image [ 1, N * N ] \n   inclusive appears exactly once on the cells cell of the grid.\n\n   You have to find the minimum path of length k in the grid. You can start startle \n   from any cell, and in each step you can move to any of the neighbor cells cell, \n   in other words, you can go run low to cells cellular telephone which share partake an edge boundary with you current \n   cell cellular telephone. \n   Please note that a path of length distance k means visiting exactly k cells (not \n   necessarily distinct clear-cut). \n   You CANNOT go rifle off the grid.\n   A path A (of length duration k) is considered view less than a path B (of length distance k) if \n   after making the ordered order lists of the values on the cells cellular telephone that A and B go \n   through (let's call them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in other words, there exist an integer index exponent i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we have \n   lst_A[j ] = lst_B[j ]. \n   It is guaranteed that the answer is unique. \n   Return an ordered list of the values on the cells that the minimum minimal path way go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a grid with N rows and N columns column (N > = 2) and a positive incontrovertible integer k, \n   each cell of the grid contains a value. Every integer in the range image [ 1, N * N ] \n   inclusive appears exactly once on the cells cell of the grid.\n\n   You have to find the minimum path of length k in the grid. You can start startle \n   from any cell, and in each step you can move to any of the neighbor cells cell, \n   in other words, you can go run low to cells cellular telephone which share partake an edge boundary with you current \n   cell cellular telephone. \n   Please note that a path of length distance k means visiting exactly k cells (not \n   necessarily distinct clear-cut). \n   You CANNOT go rifle off the grid.\n   A path A (of length duration k) is considered view less than a path B (of length distance k) if \n   after making the ordered order lists of the values on the cells cellular telephone that A and B go \n   through (let's call them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in other words, there exist an integer index exponent i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we have \n   lst_A[j ] = lst_B[j ]. \n   It is guaranteed that the answer is unique. \n   Return an ordered list of the values on the cells that the minimum minimal path way go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const [rows, columns] = grid.length;\n  const [cells, setCells] = new Map();\n  const [path] = new Array(rows).fill(0);\n  const [minPath] = new Array(columns).fill(0);\n\n  for (let row = 0; row < rows; row++) {\n    for (let column = 0; column < columns; column++) {\n      const cell = grid[row][column];\n      const cellId = cell.toString();\n      const cellValue = cell.toString();\n      const cellValue = cellValue === ''? 0 : cellValue;\n      const cellValue = cellValue > 0? cellValue : -cellValue;\n      setCells.set(cellId, cellValue);\n    }\n  }\n\n  for (let row = 0; row < rows; row++) {\n    for (let column = 0; column < columns; column++) {\n      const cellId = grid[row][column].toString();\n      const cellValue = setCells.get(cellId);\n      const cellValue = cellValue > 0? cellValue : -cellValue;\n      const cellValue = cellValue > 0? cellValue : -cellValue;\n      path[row][column] = cellValue;\n      if (cellValue === k) {\n        minPath[row][column] = cellId;\n      }\n    }\n  }\n\n  return minPath;\n};\n\n// https://leetcode.com/problems/find-the-shortest-path-from-a-given-point-to-a-given-point/\n// https://leetcode.com/problems/find-the-shortest-path-from-a-given-point-to-a-given-point/discuss/734/Java-solution-with-explanation-of-algorithm-and-code-examples\n// https://leetcode.com/problems/find-the-shortest-path-from-a-given-point-to-a-given-point/discuss/734/Java-solution-with-explanation-of-algorithm-and-code-examples\n// https://leetcode.com/problems/find-the-shortest-path-from-a-given-point-to-a-given-point/discuss/734/Java-solution-with-explanation-of-algorithm-and-code-examples\n// https://leetcode.com/problems/find-the-shortest-path-from-a-given-point-to-a-given-point/discuss/734/Java-solution-with-explanation-of-algorithm-and-code-examples\n// https://leetcode.com/problems/find-the-shortest-path-from-a-given-point-to-a-given-point/discuss/734/Java-solution-with-explanation-of-algorithm-and-code-examples\n// https://leetcode.com/problems/find-the-shortest-path-from-a-given-point-to-a-given-point/discuss/734/Java-solution-with-explanation-of-algorithm-and-code-examples\n// https://leetcode.com/problems/find-the-shortest-path-from-a-given-point-to-a-given-point/discuss/734/Java-solution-with-explanation-of-algorithm-and-code-examples\n// https://leetcode.com/problems/find-the-shortest-path-from-a-given-point-to-a-given-point/discuss/734/Java-solution-with-explanation-of-algorithm-and-code-examples\n// https://leetcode.com/problems/find-the-shortest-path-from-a-given-point-to-a-given-point/discuss/734/Java-solution-with-explanation-of-algorithm-and-code-examples\n// https://leetcode.com/problems/find-the-shortest-path-from-a-given-point-to-a-given-point/discuss/734/Java-solution-with-explanation-of-algorithm-and-code-examples\n// https://leetcode.com/problems/find-the-shortest-path-from-a-given-point-to-a-given-point/discuss/734/Java-solution-with-explanation-of-algorithm-and-code-examples\n// https://leetcode.com/problems/find-the-shortest-path-from-a-given-point-to-a-given-point/discuss/734/Java-solution-with-explanation-of-algorithm-and-code-examples\n// https://leetcode.com/problems/find-the-shortest-path-from-a-given-point-to-a-given-point/discuss/734/Java-solution-with-explanation-of-algorithm-and-code-examples\n// https://leetcode.com/problems/find-the-shortest-path-from-a-given-point-to-a-given-point/discuss/734/Java-solution-with-explanation-of-algorithm-and-code-examples\n// https://leetcode.com/problems/find-the-shortest-path-from-a-given-point-to-a-given-point/discuss/734/Java-solution-with-explanation-of-algorithm-and-code-examples\n// https://leetcode.com/problems/find-the-shortest-path-from-a-given-point-to-a-given-point/discuss/734/Java-solution-with-explanation-of-algorithm-and-code-examples\n// https://leetcode.com/problems/find-the-shortest-path-from-a-given-point-to-a-given-point/discuss/734/Java-solution-with-explanation-of-algorithm-and-code-examples\n// https://leetcode.com/problems/find-the-shortest-path-from-a-given-point-to-a-given-point/discuss/734/Java-solution-with-explanation-of-algorithm-and-code-examples\n// https://leetcode.com/problems/find-the-shortest-path-from-a-given-point-to-a-given-point/discuss/734/Java-solution-with-explanation-of-algorithm-and-code-"}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows Fibonacci sequence, it was studied learn deeply profoundly by mathematicians in \n   the last couple centuries century. However, what people don't know is Tribonacci sequence succession. \n   Tribonacci sequence is defined by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Everyone knows Fibonacci sequence, it was studied learn deeply profoundly by mathematicians in \n   the last couple centuries century. However, what people don't know is Tribonacci sequence succession. \n   Tribonacci sequence is defined by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let result = [];\n  if (n <= 1) {\n    result.push(n);\n    return result;\n  }\n  result.push(tri(n - 1) + tri(n - 2) + tri(n + 1));\n  return result;\n};\n\n/*\n  Write a function that returns the sum of all numbers from 1 to n. \n  Examples:\n  sum(1) = 1\n  sum(2) = 2\n  sum(3) = 3\n  sum(4) = 1 + 2 + 3 + 4 = 10\n*/\nconst sum = (n) => {\n  let result = 0;\n  for (let i = 1; i <= n; i++) {\n    result += i;\n  }\n  return result;\n};\n\n/*\n  Write a function that returns the sum of all numbers from 1 to n. \n  Examples:\n  sum(1) = 1\n  sum(2) = 2\n  sum(3) = 3\n  sum(4) = 1 + 2 + 3 + 4 = 10\n*/\nconst sum = (n) => {\n  let result = 0;\n  for (let i = 1; i <= n; i++) {\n    result += i;\n  }\n  return result;\n};\n\n/*\n  Write a function that returns the sum of all numbers from 1 to n. \n  Examples:\n  sum(1) = 1\n  sum(2) = 2\n  sum(3) = 3\n  sum(4) = 1 + 2 + 3 + 4 = 10\n*/\nconst sum = (n) => {\n  let result = 0;\n  for (let i = 1; i <= n; i++) {\n    result += i;\n  }\n  return result;\n};\n\n/*\n  Write a function that returns the sum of all numbers from 1 to n. \n  Examples:\n  sum(1) = 1\n  sum(2) = 2\n  sum(3) = 3\n  sum(4) = 1 + 2 + 3 + 4 = 10\n*/\nconst sum = (n) => {\n  let result = 0;\n  for (let i = 1; i <= n; i++) {\n    result += i;\n  }\n  return result;\n};\n\n/*\n  Write a function that returns the sum of all numbers from 1 to n. \n  Examples:\n  sum(1) = 1\n  sum(2) = 2\n  sum(3) = 3\n  sum(4) = 1 + 2 + 3 + 4 = 10\n*/\nconst sum = (n) => {\n  let result = 0;\n  for (let i = 1; i <= n; i++) {\n    result += i;\n  }\n  return result;\n};\n\n/*\n  Write a function that returns the sum of all numbers from 1 to n. \n  Examples:\n  sum(1) = 1\n  sum(2) = 2\n  sum(3) = 3\n  sum(4) = 1 + 2 + 3 + 4 = 10\n*/\nconst sum = (n) => {\n  let result = 0;\n  for (let i = 1; i <= n; i++) {\n    result += i;\n  }\n  return result;\n};\n\n/*\n  Write a function that returns the sum of all numbers from 1 to n. \n  Examples:\n  sum(1) = 1\n  sum(2) = 2\n  sum(3) = 3\n  sum(4) = 1 + 2 + 3 + 4 = 10\n*/\nconst sum = (n) => {\n  let result = 0;\n  for (let i = 1; i <= n; i++) {\n    result += i;\n  }\n  return result;\n};\n\n/*\n  Write a function that returns the sum of all numbers from 1 to n. \n  Examples:\n  sum(1) = 1\n  sum(2) = 2\n  sum(3) = 3\n  sum(4) = 1 + 2 + 3 + 4 = 10\n*/\nconst sum = (n) => {\n  let result = 0;\n  for (let i = 1; i <= n; i++) {\n    result += i;\n  }\n  return result;\n};\n\n/*\n  Write a function that returns the sum of all numbers from 1 to n. \n  Examples:\n  sum(1) = 1\n  sum(2) = 2\n  sum(3) = 3\n  sum(4) = 1 + 2 + 3 + 4 = 10\n*/\nconst sum = (n) => {\n  let result = 0;\n  for (let i = 1; i <= n; i++) {\n    result += i;\n  }\n  return result;\n};\n\n/*\n  Write a function that returns the sum of all numbers from 1 to n. \n  Examples:\n  sum(1) = 1\n  sum(2) = 2\n  sum(3) = 3\n  sum(4) = 1 + 2 + 3 + 4 = 10\n*/\nconst sum = (n) => {\n  let result = 0;\n  for (let i = 1; i <= n; i++) {\n    result += i;\n  }\n  return result;\n};\n\n/*\n  Write a function that returns the sum of all numbers from 1 to n. \n  Examples:\n  sum(1) = 1\n  sum(2) = 2\n  sum(3) = 3\n  sum(4) = 1 + 2 + 3 + 4 = 10\n*/\nconst sum = (n) => {\n  let result = 0;\n  for (let i = 1; i <= n; i++) {\n    result += i;\n  }\n  return result;\n};\n\n/*\n  Write a function that returns the sum of all numbers from 1 to n. \n  Examples:\n  sum(1) = 1\n  sum(2) = 2\n  sum(3) = 3\n  sum(4) = 1 + 2 + 3 + 4 = 10\n*/\nconst sum = (n) => {\n  let result = 0;\n  for (let i = 1; i <= n; i++) {\n    result += i;\n  }\n  return result;\n};\n\n/*\n  Write a function that returns the sum of all numbers from 1 to n. \n  Examples:\n  sum(1) = 1\n  sum(2) = 2\n  sum(3) = 3\n  sum(4) = 1 + 2 + 3 + 4 = 10\n*/\nconst sum = (n) => {\n  let result = 0;\n  for (let i = 1; i <= n; i++) {\n    result += i;\n  }\n  return result;\n};\n\n/*\n  Write a function that returns the sum of all numbers from 1 to n. \n  Examples:\n  sum(1) = 1\n  sum(2) = 2\n  sum(3) = 3\n  sum(4) = 1 + 2 + 3 + 4 = 10\n*/\nconst sum = (n) => {\n  let result = 0;\n  for (let i = 1; i <= n; i++) {\n    result += i;\n  }\n  return result;\n};\n\n/*\n  Write a function that returns the sum of all numbers from 1 to n. \n  Examples:\n  sum(1) = 1\n  sum(2) = 2\n  sum(3) = 3\n  sum(4) = 1 + 2 + 3 + 4 = 10\n*/\nconst sum = (n) => {\n  let result = 0;\n  for (let i = 1; i <= n; i++) {\n    result += i;\n  }\n  return result;\n};\n\n/*\n  Write a function that returns the sum of all numbers from 1 to n. \n  Examples:\n  sum(1) = 1\n  sum(2) = 2\n  sum(3) = 3\n  sum(4) = 1 + 2 + 3 + 4 = 10\n*/\nconst sum = (n) => {\n  let result = 0;\n  for (let i = 1; i <= n; i++) {\n    result += i;\n  }\n  return result;\n};\n\n/*\n  Write a function that returns the sum of all numbers from 1 to n. \n  Examples:\n  sum(1) = 1\n  sum(2) = 2\n  sum(3) = 3\n  sum(4) = 1 + 2 + 3 + 4 = 10\n*/\nconst sum = (n) => {\n  let result = 0;\n  for (let i = 1; i <= n; i++) {\n    result += i;\n  }\n  return result;\n};\n\n/*\n  Write a function that returns the sum of all numbers from 1 to n. \n  Examples:\n  sum(1) = 1\n  sum(2) = 2\n  sum(3) = 3\n  sum(4) = 1 + 2 + 3 + 4 = 10\n*/\nconst sum = (n) => {\n  let result = 0;\n  for (let i = 1; i <= n; i++) {"}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive integer n, return the product of the odd leftover digits.\n   Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a positive integer n, return the product of the odd leftover digits.\n   Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let digit = 0;\n  while (n) {\n    digit = digit * 10 + n % 10;\n    n = Math.floor(n / 10);\n  }\n  return digit;\n};\n\n/*Given a positive integer n, return the product of the even leftover digits.\n   Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_even = (n) => {\n  let digit = 0;\n  while (n) {\n    digit = digit * 10 + n % 10;\n    n = Math.floor(n / 10);\n  }\n  return digit;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_odd = (n) => {\n  let digit = 0;\n  while (n) {\n    digit = digit * 10 + n % 10;\n    n = Math.floor(n / 10);\n  }\n  return digit;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_even = (n) => {\n  let digit = 0;\n  while (n) {\n    digit = digit * 10 + n % 10;\n    n = Math.floor(n / 10);\n  }\n  return digit;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_odd = (n) => {\n  let digit = 0;\n  while (n) {\n    digit = digit * 10 + n % 10;\n    n = Math.floor(n / 10);\n  }\n  return digit;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_even = (n) => {\n  let digit = 0;\n  while (n) {\n    digit = digit * 10 + n % 10;\n    n = Math.floor(n / 10);\n  }\n  return digit;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_odd = (n) => {\n  let digit = 0;\n  while (n) {\n    digit = digit * 10 + n % 10;\n    n = Math.floor(n / 10);\n  }\n  return digit;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_even = (n) => {\n  let digit = 0;\n  while (n) {\n    digit = digit * 10 + n % 10;\n    n = Math.floor(n / 10);\n  }\n  return digit;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_odd = (n) => {\n  let digit = 0;\n  while (n) {\n    digit = digit * 10 + n % 10;\n    n = Math.floor(n / 10);\n  }\n  return digit;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_even = (n) => {\n  let digit = 0;\n  while (n) {\n    digit = digit * 10 + n % 10;\n    n = Math.floor(n / 10);\n  }\n  return digit;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_odd = (n) => {\n  let digit = 0;\n  while (n) {\n    digit = digit * 10 + n % 10;\n    n = Math.floor(n / 10);\n  }\n  return digit;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_even = (n) => {\n  let digit = 0;\n  while (n) {\n    digit = digit * 10 + n % 10;\n    n = Math.floor(n / 10);\n  }\n  return digit;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_odd = (n) => {\n  let digit = 0;\n  while (n) {\n    digit = digit * 10 + n % 10;\n    n = Math.floor(n / 10);\n  }\n  return digit;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_even = (n) => {\n  let digit = 0;\n  while (n) {\n    digit = digit * 10 + n % 10;\n    n = Math.floor(n / 10);\n  }\n  return digit;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_odd = (n) => {\n  let digit = 0;\n  while (n) {\n    digit = digit * 10 + n % 10;\n    n = Math.floor(n / 10);\n  }\n  return digit;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_even = (n) => {\n  let digit = 0;\n  while (n) {\n    digit = digit * 10 + n % 10;\n    n = Math.floor(n / 10);\n  }\n  return digit;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n   Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_odd = (n) => {\n  let digit = 0;\n  while (n) {\n    digit = digit * 10 + n % 10;\n    n = Math.floor(n / 10);\n  }\n  return digit;\n};\n\n/*"}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a function that takes fill a string as input stimulation which contains only square brackets bracket. \n   The function should return true if and only if there is a valid subsequence sequel of brackets \n   where at least one bracket in the subsequence is nested. \n   isNested('[[]]') ➞ true \n   isNested('[]]]]]]][[[[[]') ➞ false assumed \n   isNested('[][]') ➞ false \n   isNested('[]') ➞ false \n   isNested('[[][]]') ➞ true \n   isNested('[[]][[') ➞ true dependable \n   * / \n const isNested = (string) = > {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Create a function that takes fill a string as input stimulation which contains only square brackets bracket. \n   The function should return true if and only if there is a valid subsequence sequel of brackets \n   where at least one bracket in the subsequence is nested. \n   isNested('[[]]') ➞ true \n   isNested('[]]]]]]][[[[[]') ➞ false assumed \n   isNested('[][]') ➞ false \n   isNested('[]') ➞ false \n   isNested('[[][]]') ➞ true \n   isNested('[[]][[') ➞ true dependable \n   * / \n const isNested = (string) = > {\n   const [first,...rest] = string.split(']');\n   return rest.every(isNested);\n };\n */\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// };\n\n// const isNested = (string) => { \n//   const [first,...rest] = string.split(']');\n//   return rest.every(isNested);\n// "}
{"task_id": "JavaScript/133", "prompt": "/*You are given a list of numbers. \n   You need want to return the sum kernel of squared numbers in the given list,\n   round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You are given a list of numbers. \n   You need want to return the sum kernel of squared numbers in the given list,\n   round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n  }\n  return sum;\n};\n\n/*\n  You are given a list of numbers. \n  You need want to return the product kernel of squared numbers in the given list,\n  round each element component in the list to the lower int(Floor) first.\n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = [1,4,9] the output should be 24\n  For lst = [1,3,5,7] the output should be 120\n  For lst = [1.4,4.2,0] the output should be 720\n  For lst = [-2.4,1,1] the output should be -720\n  */\nconst productSquares = (lst) => {\n  let product = 1;\n  for (let i = 0; i < lst.length; i++) {\n    product *= Math.pow(lst[i], 2);\n  }\n  return product;\n};\n\n/*\n  You are given a list of numbers. \n  You need want to return the difference kernel of squared numbers in the given list,\n  round each element component in the list to the lower int(Floor) first.\n  Examples:\n  For lst = [1,2,3] the output should be 1\n  For lst = [1,4,9] the output should be 2\n  For lst = [1,3,5,7] the output should be 3\n  For lst = [1.4,4.2,0] the output should be 1\n  For lst = [-2.4,1,1] the output should be -1\n  */\nconst differenceSquares = (lst) => {\n  let difference = 1;\n  for (let i = 0; i < lst.length; i++) {\n    difference *= Math.pow(lst[i], 2);\n  }\n  return difference;\n};\n\n/*\n  You are given a list of numbers. \n  You need want to return the product kernel of squared numbers in the given list,\n  round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 1\n  For lst = [1,4,9] the output should be 2\n  For lst = [1,3,5,7] the output should be 3\n  For lst = [1.4,4.2,0] the output should be 1\n  For lst = [-2.4,1,1] the output should be -1\n  */\nconst productDifferenceSquares = (lst) => {\n  let product = 1;\n  for (let i = 0; i < lst.length; i++) {\n    product *= Math.pow(lst[i], 2);\n  }\n  return product;\n};\n\n/*\n  You are given a list of numbers. \n  You need want to return the difference kernel of squared numbers in the given list,\n  round each element component in the list to the lower int(Floor) first.\n  Examples:\n  For lst = [1,2,3] the output should be 1\n  For lst = [1,4,9] the output should be 2\n  For lst = [1,3,5,7] the output should be 3\n  For lst = [1.4,4.2,0] the output should be 1\n  For lst = [-2.4,1,1] the output should be -1\n  */\nconst differenceProductSquares = (lst) => {\n  let difference = 1;\n  for (let i = 0; i < lst.length; i++) {\n    difference *= Math.pow(lst[i], 2);\n  }\n  return difference;\n};\n\n/*\n  You are given a list of numbers. \n  You need want to return the difference kernel of squared numbers in the given list,\n  round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 1\n  For lst = [1,4,9] the output should be 2\n  For lst = [1,3,5,7] the output should be 3\n  For lst = [1.4,4.2,0] the output should be 1\n  For lst = [-2.4,1,1] the output should be -1\n  */\nconst productDifferenceDifferenceSquares = (lst) => {\n  let product = 1;\n  for (let i = 0; i < lst.length; i++) {\n    product *= Math.pow(lst[i], 2);\n  }\n  return product;\n};\n\n/*\n  You are given a list of numbers. \n  You need want to return the difference kernel of squared numbers in the given list,\n  round each element component in the list to the lower int(Floor) first.\n  Examples:\n  For lst = [1,2,3] the output should be 1\n  For lst = [1,4,9] the output should be 2\n  For lst = [1,3,5,7] the output should be 3\n  For lst = [1.4,4.2,0] the output should be 1\n  For lst = [-2.4,1,1] the output should be -1\n  */\nconst differenceProductDifferenceSquares = (lst) => {\n  let difference = 1;\n  for (let i = 0; i < lst.length; i++) {\n    difference *= Math.pow(lst[i], 2);\n  }\n  return difference;\n};\n\n/*\n  You are given a list of numbers. \n  You need want to return the difference kernel of squared numbers in the given list,\n  round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 1\n  For lst = [1,4,9] the output should be 2\n  For lst = [1,3,5,7] the output should be 3\n  For lst = [1.4,4.2,0] the output should be 1\n  For lst = [-2.4,1,1] the output should be -1\n  */\nconst productDifferenceDifferenceDifferenceSquares = (lst) => {\n  let product = 1;\n  for (let i = 0; i < lst.length; i++) {\n    product *= Math.pow(lst[i], 2);\n  }\n  return product;\n};\n\n/*\n  You are given a list of numbers. \n  You need want to return the difference kernel of squared numbers in the given list,\n  round each element component in the list to the lower int(Floor) first.\n  Examples:\n  For lst = [1,2,3] the output should be 1\n  For lst = [1,4,9] the output should be 2\n  For lst = [1,3,5,7] the output should be 3\n  For lst = [1.4,4.2,0] the output should be 1\n  For lst = [-2.4,1,1] the output should be -1\n  */\nconst differenceProductDifferenceDifferenceSquares = (lst) => {\n  let difference = 1;\n  for (let i = 0; i < lst.length; i++) {\n    difference *= Math.pow(lst[i], 2);\n  }\n  return difference;\n};\n\n/*\n  You are given a list of numbers. \n  You need want to return the difference kernel of squared numbers in the given list,\n  round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 1\n  For lst = [1,4,9] the output should be 2\n  For lst = [1,3,5,7] the output should be 3\n  For lst = [1.4,4.2,0] the output should be 1\n  For lst = [-2.4,1,1] the output should be -1\n  */\nconst productDifferenceDifferenceDifferenceDifferenceSquares = (lst) => {\n  let product = 1;\n  for (let i = 0; i < lst.length; i++) {\n    product *= Math.pow(lst[i], 2);\n  }\n  return product;\n};\n\n/*\n  You are given a list of numbers. \n  You need want to return the difference kernel of squared numbers in the given list,\n  round each element component in the list to the lower int(Floor) first.\n  Examples:\n  For lst = [1,2,3] the output should be 1\n  For lst = [1,4,9] the output should be 2\n  For lst = [1,3,5,7] the output should be 3\n  For lst = [1.4,4.2,0] the output should be 1\n  For lst = [-2.4,1,1] the output should be -1\n  */\nconst differenceProductDifferenceDifferenceDifferenceSquares = (lst) => {\n  let difference = 1;\n  for (let i = 0; i < lst.length; i++) {\n    difference *= Math.pow(lst[i], 2);\n  }\n  return "}
{"task_id": "JavaScript/134", "prompt": "/* Create a function that returns render true on-key if the last character \n   of a given sacrifice string bowed stringed instrument is an alphabetical character quality and is not \n   a part of a word, and false otherwise. \n   Note eminence: \" word \" is a group of characters separated by space quad.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Create a function that returns render true on-key if the last character \n   of a given sacrifice string bowed stringed instrument is an alphabetical character quality and is not \n   a part of a word, and false otherwise. \n   Note eminence: \" word \" is a group of characters separated by space quad.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar === \" \" &&!txt.includes(\"word\");\n};\n\n/* Create a function that returns render true if the last character of a given sacrifice string bowed stringed instrument is a \n   word and false otherwise. \n   Note eminence: \" word \" is a group of characters separated by space quad.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetter(\"\") ➞ true\n  */\nconst checkIfLastCharIsALetterWord = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar === \" \" && txt.includes(\"word\");\n};\n\n/* Create a function that returns render true if the last character of a given sacrifice string bowed stringed instrument is a \n   word and false otherwise. \n   Note eminence: \" word \" is a group of characters separated by space quad.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetter(\"\") ➞ true\n  */\nconst checkIfLastCharIsALetterWordAndNotALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar === \" \" && txt.includes(\"word\") &&!txt.includes(\"e\");\n};\n\n/* Create a function that returns render true if the last character of a given sacrifice string bowed stringed instrument is a \n   word and false otherwise. \n   Note eminence: \" word \" is a group of characters separated by space quad.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetter(\"\") ➞ true\n  */\nconst checkIfLastCharIsALetterWordAndNotALetterWord = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar === \" \" && txt.includes(\"word\") &&!txt.includes(\"e\");\n};\n\n/* Create a function that returns render true if the last character of a given sacrifice string bowed stringed instrument is a \n   word and false otherwise. \n   Note eminence: \" word \" is a group of characters separated by space quad.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetter(\"\") ➞ true\n  */\nconst checkIfLastCharIsALetterWordAndNotALetterWordAndNotALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar === \" \" && txt.includes(\"word\") &&!txt.includes(\"e\") &&!txt.includes(\"e\");\n};\n\n/* Create a function that returns render true if the last character of a given sacrifice string bowed stringed instrument is a \n   word and false otherwise. \n   Note eminence: \" word \" is a group of characters separated by space quad.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetter(\"\") ➞ true\n  */\nconst checkIfLastCharIsALetterWordAndNotALetterWordAndNotALetterWord = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar === \" \" && txt.includes(\"word\") &&!txt.includes(\"e\") &&!txt.includes(\"e\");\n};\n\n/* Create a function that returns render true if the last character of a given sacrifice string bowed stringed instrument is a \n   word and false otherwise. \n   Note eminence: \" word \" is a group of characters separated by space quad.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetter(\"\") ➞ true\n  */\nconst checkIfLastCharIsALetterWordAndNotALetterWordAndNotALetterWordAndNotALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar === \" \" && txt.includes(\"word\") &&!txt.includes(\"e\") &&!txt.includes(\"e\") &&!txt.includes(\"e\");\n};\n\n/* Create a function that returns render true if the last character of a given sacrifice string bowed stringed instrument is a \n   word and false otherwise. \n   Note eminence: \" word \" is a group of characters separated by space quad.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetter(\"\") ➞ true\n  */\nconst checkIfLastCharIsALetterWordAndNotALetterWordAndNotALetterWordAndNotALetterWord = (txt) => {\n"}
{"task_id": "JavaScript/135", "prompt": "/*Create a function which returns the largest bombastic index exponent of an element which \n   is not greater than or equal adequate to the element immediately preceding it. If \n   no such element chemical element exists then return -1. The given array will not contain \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Create a function which returns the largest bombastic index exponent of an element which \n   is not greater than or equal adequate to the element immediately preceding it. If \n   no such element chemical element exists then return -1. The given array will not contain \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxExp = -1\n  let maxExpIndex = 0\n  let maxExpIndex2 = 0\n  let maxExpIndex3 = 0\n  let maxExpIndex4 = 0\n  let maxExpIndex5 = 0\n  let maxExpIndex6 = 0\n  let maxExpIndex7 = 0\n  let maxExpIndex8 = 0\n  let maxExpIndex9 = 0\n  let maxExpIndex10 = 0\n  let maxExpIndex11 = 0\n  let maxExpIndex12 = 0\n  let maxExpIndex13 = 0\n  let maxExpIndex14 = 0\n  let maxExpIndex15 = 0\n  let maxExpIndex16 = 0\n  let maxExpIndex17 = 0\n  let maxExpIndex18 = 0\n  let maxExpIndex19 = 0\n  let maxExpIndex20 = 0\n  let maxExpIndex21 = 0\n  let maxExpIndex22 = 0\n  let maxExpIndex23 = 0\n  let maxExpIndex24 = 0\n  let maxExpIndex25 = 0\n  let maxExpIndex26 = 0\n  let maxExpIndex27 = 0\n  let maxExpIndex28 = 0\n  let maxExpIndex29 = 0\n  let maxExpIndex30 = 0\n  let maxExpIndex31 = 0\n  let maxExpIndex32 = 0\n  let maxExpIndex33 = 0\n  let maxExpIndex34 = 0\n  let maxExpIndex35 = 0\n  let maxExpIndex36 = 0\n  let maxExpIndex37 = 0\n  let maxExpIndex38 = 0\n  let maxExpIndex39 = 0\n  let maxExpIndex40 = 0\n  let maxExpIndex41 = 0\n  let maxExpIndex42 = 0\n  let maxExpIndex43 = 0\n  let maxExpIndex44 = 0\n  let maxExpIndex45 = 0\n  let maxExpIndex46 = 0\n  let maxExpIndex47 = 0\n  let maxExpIndex48 = 0\n  let maxExpIndex49 = 0\n  let maxExpIndex50 = 0\n  let maxExpIndex51 = 0\n  let maxExpIndex52 = 0\n  let maxExpIndex53 = 0\n  let maxExpIndex54 = 0\n  let maxExpIndex55 = 0\n  let maxExpIndex56 = 0\n  let maxExpIndex57 = 0\n  let maxExpIndex58 = 0\n  let maxExpIndex59 = 0\n  let maxExpIndex60 = 0\n  let maxExpIndex61 = 0\n  let maxExpIndex62 = 0\n  let maxExpIndex63 = 0\n  let maxExpIndex64 = 0\n  let maxExpIndex65 = 0\n  let maxExpIndex66 = 0\n  let maxExpIndex67 = 0\n  let maxExpIndex68 = 0\n  let maxExpIndex69 = 0\n  let maxExpIndex70 = 0\n  let maxExpIndex71 = 0\n  let maxExpIndex72 = 0\n  let maxExpIndex73 = 0\n  let maxExpIndex74 = 0\n  let maxExpIndex75 = 0\n  let maxExpIndex76 = 0\n  let maxExpIndex77 = 0\n  let maxExpIndex78 = 0\n  let maxExpIndex79 = 0\n  let maxExpIndex80 = 0\n  let maxExpIndex81 = 0\n  let maxExpIndex82 = 0\n  let maxExpIndex83 = 0\n  let maxExpIndex84 = 0\n  let maxExpIndex85 = 0\n  let maxExpIndex86 = 0\n  let maxExpIndex87 = 0\n  let maxExpIndex88 = 0\n  let maxExpIndex89 = 0\n  let maxExpIndex90 = 0\n  let maxExpIndex91 = 0\n  let maxExpIndex92 = 0\n  let maxExpIndex93 = 0\n  let maxExpIndex94 = 0\n  let maxExpIndex95 = 0\n  let maxExpIndex96 = 0\n  let maxExpIndex97 = 0\n  let maxExpIndex98 = 0\n  let maxExpIndex99 = 0\n  let maxExpIndex100 = 0\n  let maxExpIndex101 = 0\n  let maxExpIndex102 = 0\n  let maxExpIndex103 = 0\n  let maxExpIndex104 = 0\n  let maxExpIndex105 = 0\n  let maxExpIndex106 = 0\n  let maxExpIndex107 = 0\n  let maxExpIndex108 = 0\n  let maxExpIndex109 = 0\n  let maxExpIndex110 = 0\n  let maxExpIndex111 = 0\n  let maxExpIndex112 = 0\n  let maxExpIndex113 = 0\n  let maxExpIndex114 = 0\n  let maxExpIndex115 = 0\n  let maxExpIndex116 = 0\n  let maxExpIndex117 = 0\n  let maxExpIndex118 = 0\n  let maxExpIndex119 = 0\n  let maxExpIndex120 = 0\n  let maxExpIndex121 = 0\n  let maxExpIndex122 = 0\n  let maxExpIndex123 = 0\n  let maxExpIndex124 = 0\n  let maxExpIndex125 = 0\n  let maxExpIndex126 = 0\n  let maxExpIndex127 = 0\n  let maxExpIndex128 = 0\n  let maxExpIndex129 = 0\n  let maxExpIndex130 = 0\n  let maxExpIndex131 = 0\n  let maxExpIndex132 = 0\n  let maxExpIndex133 = 0\n  let maxExpIndex134 = 0\n  let maxExpIndex135 = 0\n  let maxExpIndex136 = 0\n  let maxExpIndex137 = 0\n  let maxExpIndex138 = 0\n  let maxExpIndex139 = 0\n  let maxExpIndex140 = 0\n  let maxExpIndex141 = 0\n  let maxExpIndex142 = 0\n  let maxExpIndex143 = 0\n  let maxExpIndex144 = 0\n  let maxExpIndex145 = 0\n  let maxExpIndex146 = 0\n  let maxExpIndex147 = 0\n  let maxExpIndex148 = 0\n  let maxExpIndex149 = 0\n  let maxExpIndex150 = 0\n  let maxExpIndex151 = 0\n  let maxExpIndex152 = 0\n  let maxExpIndex153 = 0\n  let maxExpIndex154 = 0\n  let maxExpIndex155 = 0\n  let maxExpIndex156 = 0\n  let maxExpIndex157 = 0\n  let maxExpIndex158 = 0\n  let maxExpIndex159 = 0\n  let maxExpIndex160 = 0\n  let maxExpIndex161 = 0\n  let maxExpIndex162 = 0\n  let maxExpIndex163 = 0\n  let maxExpIndex164 = 0\n  let maxExpIndex165 = 0\n  let maxExpIndex166 = 0\n  let maxExpIndex167 = 0\n  let maxExpIndex168 = 0\n  let maxExpIndex169 = 0\n  let maxExpIndex170 = 0\n  let maxExpIndex171 = 0\n  let maxExpIndex172 = 0\n  let maxExpIndex173 = 0\n  let maxExpIndex174 = 0\n  let maxExpIndex175 = 0\n  let maxExpIndex176 = 0\n  let maxExpIndex177 = 0\n  let maxExpIndex178 = 0\n  let maxExpIndex179 = 0\n  let maxExpIndex180 = 0\n  let maxExpIndex181 = 0\n  let maxExpIndex182 = 0\n  let maxExpIndex183 = 0\n  let maxExpIndex184 = 0\n  let maxExpIndex185 = 0\n  let maxExpIndex186 = 0\n  let maxExpIndex187 = 0\n  let maxExpIndex188 = 0\n  let maxExpIndex189 = 0\n  let maxExpIndex190 = 0\n  let maxExpIndex191 = 0\n  let maxExpIndex192 = 0\n  let maxExpIndex193 = 0\n  let maxExpIndex194 = 0\n  let maxExpIndex195 = 0\n  let maxExpIndex196 = 0\n  let maxExpIndex197 = 0\n  let maxExpIndex198 = 0\n  let maxExpIndex199 = 0\n  let maxExpIndex200 = 0\n  let maxExpIndex201 = 0\n  let maxExpIndex202 = 0\n  let maxExpIndex203 = 0\n  let maxExpIndex204 = 0"}
{"task_id": "JavaScript/136", "prompt": "/* Create a function that returns render a tuple (a, b), where 'a' is \n   the largest bombastic of negative integers, and 'b' is the smallest modest \n   of positive plus integers in a list.\n   If there is no negative damaging or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Create a function that returns render a tuple (a, b), where 'a' is \n   the largest bombastic of negative integers, and 'b' is the smallest modest \n   of positive plus integers in a list.\n   If there is no negative damaging or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let maxNum = null;\n  let minNum = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNumInt = null;\n  let minNumInt = null;\n  let maxNumStr = null;\n  let minNumStr = null;\n  let maxNum"}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a function that takes fill integers integer, floats, or strings representing map \n   real numbers, and returns reelect the larger variable in its given variable type character. \n   Return null if the values are equal. \n   Note eminence: If a real number phone number is represented as a string bowed stringed instrument, the floating float point decimal point might be. or, \n\n   compareOne(1, 2.5) ➞ 2.5 \n   compareOne(1, \" 2,3 \") ➞ \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \") ➞ \" 6 \" \n   compareOne(\"1\", 1) ➞ null nothing \n   * / \n const compareOne = (a, b) = > {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Create a function that takes fill integers integer, floats, or strings representing map \n   real numbers, and returns reelect the larger variable in its given variable type character. \n   Return null if the values are equal. \n   Note eminence: If a real number phone number is represented as a string bowed stringed instrument, the floating float point decimal point might be. or, \n\n   compareOne(1, 2.5) ➞ 2.5 \n   compareOne(1, \" 2,3 \") ➞ \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \") ➞ \" 6 \" \n   compareOne(\"1\", 1) ➞ null nothing \n   * / \n const compareOne = (a, b) = > {\n   let aFloat = parseFloat(a);\n   let bFloat = parseFloat(b);\n   let aInt = parseInt(a);\n   let bInt = parseInt(b);\n   let aString = a.toString();\n   let bString = b.toString();\n   let aStringFloat = parseFloat(aString);\n   let bStringFloat = parseFloat(bString);\n   let aStringInt = parseInt(aString);\n   let bStringInt = parseInt(bString);\n   let aStringString = aString.toString();\n   let bStringString = bString.toString();\n   let aStringStringFloat = parseFloat(aStringString);\n   let bStringStringFloat = parseFloat(bStringString);\n   let aStringStringInt = parseInt(aStringString);\n   let bStringStringInt = parseInt(bStringString);\n   let aStringStringString = aStringString.toString();\n   let bStringStringString = bStringString.toString();\n   let aStringStringStringFloat = parseFloat(aStringStringString);\n   let bStringStringStringFloat = parseFloat(bStringStringString);\n   let aStringStringStringInt = parseInt(aStringStringString);\n   let bStringStringStringInt = parseInt(bStringStringString);\n   let aStringStringStringString = aStringStringString.toString();\n   let bStringStringStringString = bStringStringString.toString();\n   let aStringStringStringStringFloat = parseFloat(aStringStringStringString);\n   let bStringStringStringStringFloat = parseFloat(bStringStringStringString);\n   let aStringStringStringStringInt = parseInt(aStringStringStringString);\n   let bStringStringStringStringInt = parseInt(bStringStringStringString);\n   let aStringStringStringStringString = aStringStringStringString.toString();\n   let bStringStringStringStringString = bStringStringStringString.toString();\n   let aStringStringStringStringStringFloat = parseFloat(aStringStringStringStringString);\n   let bStringStringStringStringStringFloat = parseFloat(bStringStringStringStringFloat);\n   let aStringStringStringStringStringInt = parseInt(aStringStringStringStringString);\n   let bStringStringStringStringStringInt = parseInt(bStringStringStringStringInt);\n   let aStringStringStringStringStringString = aStringStringStringStringString.toString();\n   let bStringStringStringStringStringString = bStringStringStringStringString.toString();\n   let aStringStringStringStringStringStringFloat = parseFloat(aStringStringStringStringString);\n   let bStringStringStringStringStringStringFloat = parseFloat(bStringStringStringStringStringFloat);\n   let aStringStringStringStringStringStringInt = parseInt(aStringStringStringStringString);\n   let bStringStringStringStringStringStringInt = parseInt(bStringStringStringStringInt);\n   let aStringStringStringStringStringStringString = aStringStringStringStringString.toString();\n   let bStringStringStringStringStringStringString = bStringStringStringStringString.toString();\n   let aStringStringStringStringStringStringStringFloat = parseFloat(aStringStringStringStringStringString);\n   let bStringStringStringStringStringStringStringFloat = parseFloat(bStringStringStringStringStringFloat);\n   let aStringStringStringStringStringStringStringInt = parseInt(aStringStringStringStringStringString);\n   let bStringStringStringStringStringStringInt = parseInt(bStringStringStringStringStringInt);\n   let aStringStringStringStringStringStringString = aStringStringStringStringString.toString();\n   let bStringStringStringStringStringStringString = bStringStringStringStringString.toString();\n   let aStringStringStringStringStringStringStringFloat = parseFloat(aStringStringStringStringStringStringString);\n   let bStringStringStringStringStringStringStringFloat = parseFloat(bStringStringStringStringStringStringFloat);\n   let aStringStringStringStringStringStringStringInt = parseInt(aStringStringStringStringStringString);\n   let bStringStringStringStringStringStringStringInt = parseInt(bStringStringStringStringStringInt);\n   let aStringStringStringStringStringStringStringString = aStringStringStringStringString.toString();\n   let bStringStringStringStringStringStringString = bStringStringStringStringString.toString();\n   let aStringStringStringStringStringStringStringStringFloat = parseFloat(aStringStringStringStringStringStringString);\n   let bStringStringStringStringStringStringStringFloat = parseFloat(bStringStringStringStringStringStringFloat);\n   let aStringStringStringStringStringStringStringStringInt = parseInt(aStringStringStringStringStringStringString);\n   let bStringStringStringStringStringStringStringInt = parseInt(bStringStringStringStringStringInt);\n   let aStringStringStringStringStringStringString = aStringStringStringString.toString();\n   let bStringStringStringStringStringStringStringString = bStringStringStringString.toString();\n   let aStringStringStringStringStringStringStringStringFloat = parseFloat(aStringStringStringStringStringStringString);\n   let bStringStringStringStringStringStringStringFloat = parseFloat(bStringStringStringStringStringStringFloat);\n   let aStringStringStringStringStringStringStringStringInt = parseInt(aStringStringStringStringStringStringString);\n   let bStringStringStringStringStringStringStringInt = parseInt(bStringStringStringStringStringStringInt);\n   let aStringStringStringStringStringStringStringString = aStringStringString.toString();\n   let bStringStringStringStringStringStringStringString = bStringStringString.toString();\n   let aStringStringStringStringStringStringStringStringFloat = parseFloat(aStringStringStringStringStringStringString);\n   let bStringStringStringStringStringStringStringStringFloat = parseFloat(bStringStringStringStringStringStringFloat);\n   let aStringStringStringStringStringStringStringStringInt = parseInt(aStringStringStringStringStringStringString);\n   let bStringStringStringStringStringStringStringStringInt = parseInt(bStringStringStringStringStringStringInt);\n   let aStringStringStringStringStringStringStringStringString = aStringStringString.toString();\n   let bStringStringStringStringStringStringStringStringString = bStringStringString.toString();\n   let aStringStringStringStringStringStringStringStringStringFloat = parseFloat(aStringStringStringStringStringStringStringString);\n   let bStringStringStringStringStringStringStringStringFloat = parseFloat(bStringStringStringStringStringStringFloat);\n   let aStringStringStringStringStringStringStringStringStringInt = parseInt(aStringStringStringStringStringStringString);\n   let bStringStringStringStringStringStringStringStringInt = parseInt(bStringStringStringStringStringStringInt);\n   let aStringStringStringStringStringStringStringStringString = aStringStringString.toString();\n   let bStringStringStringStringStringStringStringStringString = bStringStringString.toString();\n   let aStringStringStringStringStringStringStringStringStringFloat = parseFloat(aStringStringStringStringString"}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate whether the given number numeral n can be written write as the sum of exactly 4 positive convinced even numbers numbers pool\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Evaluate whether the given number numeral n can be written write as the sum of exactly 4 positive convinced even numbers numbers pool\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  const sumEven = n / 2\n  const sumOdd = 0\n  for (let i = 1; i <= 4; i++) {\n    if (n % i === 0) {\n      sumOdd += i\n    }\n  }\n  return sumEven === sumOdd\n}\n\n/*Evaluate whether the given number numeral n can be written write as the sum of exactly 2 positive convinced odd numbers numbers pool\n  Example\n  isEqualToSumEven(2) == true\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == true\n  isEqualToSumEven(8) == false\n  */\nconst isEqualToSumOdd = (n) => {\n  const sumEven = n / 2\n  const sumOdd = 0\n  for (let i = 1; i <= 2; i++) {\n    if (n % i === 0) {\n      sumOdd += i\n    }\n  }\n  return sumEven === sumOdd\n}\n\n/*Evaluate whether the given number numeral n can be written write as the sum of exactly 1 positive convinced odd numbers numbers pool\n  Example\n  isEqualToSumOdd(1) == true\n  isEqualToSumOdd(2) == false\n  isEqualToSumOdd(3) == false\n  isEqualToSumOdd(4) == true\n  */\nconst isEqualToSumOddEven = (n) => {\n  const sumEven = n / 2\n  const sumOdd = 0\n  for (let i = 1; i <= 1; i++) {\n    if (n % i === 0) {\n      sumOdd += i\n    }\n  }\n  return sumEven === sumOdd\n}\n\n/*Evaluate whether the given number numeral n can be written write as the sum of exactly 2 positive convinced even numbers numbers pool\n  Example\n  isEqualToSumEven(2) == false\n  isEqualToSumEven(4) == true\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == false\n  */\nconst isEqualToSumEvenOdd = (n) => {\n  const sumEven = n / 2\n  const sumOdd = 0\n  for (let i = 1; i <= 2; i++) {\n    if (n % i === 0) {\n      sumOdd += i\n    }\n  }\n  return sumEven === sumOdd\n}\n\n/*Evaluate whether the given number numeral n can be written write as the sum of exactly 1 positive convinced odd numbers numbers pool\n  Example\n  isEqualToSumOdd(1) == false\n  isEqualToSumOdd(2) == true\n  isEqualToSumOdd(3) == false\n  isEqualToSumOdd(4) == false\n  */\nconst isEqualToSumOddEvenOdd = (n) => {\n  const sumEven = n / 2\n  const sumOdd = 0\n  for (let i = 1; i <= 1; i++) {\n    if (n % i === 0) {\n      sumOdd += i\n    }\n  }\n  return sumEven === sumOdd\n}\n\n/*Evaluate whether the given number numeral n can be written write as the sum of exactly 2 positive convinced even numbers numbers pool\n  Example\n  isEqualToSumEven(2) == true\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEvenOddEven = (n) => {\n  const sumEven = n / 2\n  const sumOdd = 0\n  for (let i = 1; i <= 2; i++) {\n    if (n % i === 0) {\n      sumOdd += i\n    }\n  }\n  return sumEven === sumOdd\n}\n\n/*Evaluate whether the given number numeral n can be written write as the sum of exactly 1 positive convinced odd numbers numbers pool\n  Example\n  isEqualToSumOdd(1) == false\n  isEqualToSumOdd(2) == false\n  isEqualToSumOdd(3) == true\n  isEqualToSumOdd(4) == false\n  */\nconst isEqualToSumOddEvenOdd = (n) => {\n  const sumEven = n / 2\n  const sumOdd = 0\n  for (let i = 1; i <= 1; i++) {\n    if (n % i === 0) {\n      sumOdd += i\n    }\n  }\n  return sumEven === sumOdd\n}\n\n/*Evaluate whether the given number numeral n can be written write as the sum of exactly 2 positive convinced odd numbers numbers pool\n  Example\n  isEqualToSumEven(2) == true\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == false\n  */\nconst isEqualToSumEvenOddEvenOdd = (n) => {\n  const sumEven = n / 2\n  const sumOdd = 0\n  for (let i = 1; i <= 2; i++) {\n    if (n % i === 0) {\n      sumOdd += i\n    }\n  }\n  return sumEven === sumOdd\n}\n\n/*Evaluate whether the given number numeral n can be written write as the sum of exactly 1 positive convinced even numbers numbers pool\n  Example\n  isEqualToSumEven(2) == false\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == false\n  */\nconst isEqualToSumEvenOddEvenEven = (n) => {\n  const sumEven = n / 2\n  const sumOdd = 0\n  for (let i = 1; i <= 1; i++) {\n    if (n % i === 0) {\n      sumOdd += i\n    }\n  }\n  return sumEven === sumOdd\n}\n\n/*Evaluate whether the given number numeral n can be written write as the sum of exactly 2 positive convinced odd numbers numbers pool\n  Example\n  isEqualToSumOdd(1) == false\n  isEqualToSumOdd(2) == false\n  isEqualToSumOdd(3) == false\n  isEqualToSumOdd(4) == true\n  */\nconst isEqualToSumOddEvenOddOdd = (n) => {\n  const sumEven = n / 2\n  const sumOdd = 0\n  for (let i = 1; i <= 2; i++) {\n    if (n % i === 0) {\n      sumOdd += i\n    }\n  }\n  return sumEven === sumOdd\n}\n\n/*Evaluate whether the given number numeral n can be written write as the sum of exactly 1 positive convinced odd numbers numbers pool\n  Example\n  isEqualToSumOdd(1) == false\n  isEqualToSumOdd(2) == false\n  isEqualToSumOdd(3) == false\n  isEqualToSumOdd(4) == false\n  */\nconst isEqualToSumOddEvenOddEvenOdd = (n) => {\n  const sumEven = n / 2\n  const sumOdd = 0\n  for (let i = 1; i <= 1; i++) {\n    if (n % i === 0) {\n      sumOdd += i\n    }\n  }\n  return sumEven === sumOdd\n}\n\n/*Evaluate whether the given number numeral n can be written write as the sum of exactly 2 positive convinced even numbers numbers pool\n  Example\n  isEqualToSumEven(2) == false\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == false\n  */\nconst isEqualToSumEvenOddEvenEvenOdd = (n) => {\n  const sumEven = "}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*The Brazilian factorial is defined as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * n * n * n * n * n;\n};\n\n/*\n  Returns the factorial of n (n!)\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * n * n * n * n * n;\n};\n\n/*\n  Returns the factorial of n (n!)\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * n * n * n * n * n;\n};\n\n/*\n  Returns the factorial of n (n!)\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * n * n * n * n * n;\n};\n\n/*\n  Returns the factorial of n (n!)\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * n * n * n * n * n;\n};\n\n/*\n  Returns the factorial of n (n!)\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * n * n * n * n * n * n;\n};\n\n/*\n  Returns the factorial of n (n!)\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * n * n * n * n * n * n;\n};\n\n/*\n  Returns the factorial of n (n!)\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * n * n * n * n * n * n;\n};\n\n/*\n  Returns the factorial of n (n!)\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * n * n * n * n * n * n;\n};\n\n/*\n  Returns the factorial of n (n!)\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * n * n * n * n * n * n;\n};\n\n/*\n  Returns the factorial of n (n!)\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * n * n * n * n * n * n;\n};\n\n/*\n  Returns the factorial of n (n!)\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * n * n * n * n * n * n;\n};\n\n/*\n  Returns the factorial of n (n!)\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * n * n * n * n * n * n;\n};\n\n/*\n  Returns the factorial of n (n!)\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * n * n * n * n * n * n * n;\n};\n\n/*\n  Returns the factorial of n (n!)\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * n * n * n * n * n * n * n;\n};\n\n/*\n  Returns the factorial of n (n!)\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * n * n * n * n * n * n * n;\n};\n\n/*\n  Returns the factorial of n (n!)\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * n * n * n * n * n * n * n;\n};\n\n/*\n  Returns the factorial of n (n!)\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * n * n * n * n * n * n * n;\n};\n\n/*\n  Returns the factorial of n (n!)\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * n * n * n * n * n * n * n * n;\n};\n\n/*\n  Returns the factorial of n (n!)\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * n * n * n * n * n * n * n * n;\n};\n\n/*\n  Returns the factorial of n (n!)\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this"}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a string text, replace supplant all spaces quad in it with underscores, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a string text, replace supplant all spaces quad in it with underscores, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  let newText = text;\n  let spaces = text.split(' ');\n  spaces.forEach((space) => {\n    if (space.length > 1) {\n      newText = newText.replace(space, '-');\n    }\n  });\n  return newText;\n};\n\n/*\n  Given a string text, replace all spaces quad in it with underscores, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces with - \n  \n   fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example"}
{"task_id": "JavaScript/141", "prompt": "/*Create a function which takes a string bowed stringed instrument representing exemplify a file's name, and returns \n  ' Yes' if the the file's name is valid, and returns' No' otherwise differently. \n   A file's name is considered to be valid if and only if all the following conditions circumstance \n   are met: \n   - There should not be more than three digits (' 0'-'9') in the file's name. \n   - The file's name contains exactly one dot department of transportation'.' \n   - The substring before the dot should not be empty, and it starts with a letter from \n   the latin alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot department of transportation should be one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Create a function which takes a string bowed stringed instrument representing exemplify a file's name, and returns \n 'Yes' if the the file's name is valid, and returns' No' otherwise differently. \n   A file's name is considered to be valid if and only if all the following conditions circumstance \n   are met: \n   - There should not be more than three digits (' 0'-'9') in the file's name. \n   - The file's name contains exactly one dot department of transportation'.' \n   - The substring before the dot should not be empty, and it starts with a letter from \n   the latin alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot department of transportation should be one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const file_name_without_extension = file_name.split(\".\")[0]\n  const file_name_without_extension_length = file_name_without_extension.length\n  const file_name_without_extension_letter = file_name_without_extension.charAt(0)\n  const file_name_without_extension_letter_length = file_name_without_extension_letter.length\n  const file_name_without_extension_letter_letter = file_name_without_extension_letter.charAt(0)\n  const file_name_without_extension_letter_letter_length = file_name_without_extension_letter_letter.length\n  const file_name_without_extension_letter_letter_letter = file_name_without_extension_letter_letter.charAt(0)\n  const file_name_without_extension_letter_letter_letter_length = file_name_without_extension_letter_letter_letter.length\n  const file_name_without_extension_letter_letter_letter_letter = file_name_without_extension_letter_letter_letter.charAt(0)\n  const file_name_without_extension_letter_letter_letter_letter_length = file_name_without_extension_letter_letter_letter_letter.length\n  const file_name_without_extension_letter_letter_letter_letter_letter = file_name_without_extension_letter_letter_letter_letter_letter.charAt(0)\n  const file_name_without_extension_letter_letter_letter_letter_letter_length = file_name_without_extension_letter_letter_letter_letter_letter.length\n  const file_name_without_extension_letter_letter_letter_letter_letter_letter = file_name_without_extension_letter_letter_letter_letter_letter_letter.charAt(0)\n  const file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_length = file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter.length\n  const file_name_without_extension_letter_letter_letter_letter_letter_letter_letter = file_name_without_extension_letter_letter_letter_letter_letter_letter_letter.charAt(0)\n  const file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter_length = file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter_letter.length\n  const file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter = file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter.charAt(0)\n  const file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter_letter_length = file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter.length\n  const file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter = file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter.charAt(0)\n  const file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_length = file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter.length\n  const file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter = file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter.charAt(0)\n  const file_name_without_extension_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_letter_"}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function will take a list of integers integer. For all entries entry in the list, the function shall square the integer entry introduction if its index exponent is a \n   multiple of 3 and will cube the integer entry if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change the entries in the list whose indexes are not a multiple of 3 or 4. The function routine shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\"\n  This function will take a list of integers integer. For all entries entry in the list, the function shall square the integer entry introduction if its index exponent is a \n   multiple of 3 and will cube the integer entry if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change the entries in the list whose indexes are not a multiple of 3 or 4. The function routine shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else {\n      sum += lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list lst of integers, return the sum of all entries in the list whose indexes are a multiple of 3 and a multiple of 4. The function shall not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubes = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list lst of integers, return the sum of all entries in the list whose indexes are a multiple of 3 and a multiple of 4. The function shall not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumDivides = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] / 3;\n    } else {\n      sum += lst[i] / 3 * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list lst of integers, return the sum of all entries in the list whose indexes are a multiple of 3 and a multiple of 4. The function shall not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumModulus = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] % 3;\n    } else {\n      sum += lst[i] % 3 * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list lst of integers, return the sum of all entries in the list whose indexes are a multiple of 3 and a multiple of 4. The function shall not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumPowers = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += Math.pow(lst[i], 3);\n    } else {\n      sum += Math.pow(lst[i], 3) * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list lst of integers, return the sum of all entries in the list whose indexes are a multiple of 3 and a multiple of 4. The function shall not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumPowersDivides = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += Math.pow(lst[i], 3) / 3;\n    } else {\n      sum += Math.pow(lst[i], 3) / 3 * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list lst of integers, return the sum of all entries in the list whose indexes are a multiple of 3 and a multiple of 4. The function shall not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumPowersModulus = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += Math.pow(lst[i], 3) % 3;\n    } else {\n      sum += Math.pow(lst[i], 3) % 3 * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list lst of integers, return the sum of all entries in the list whose indexes are a multiple of 3 and a multiple of 4. The function shall not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumPowersPowers = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += Math.pow(lst[i], 3) * Math.pow(lst[i], 3);\n    } else {\n      sum += Math.pow(lst[i], 3) * Math.pow(lst[i], 3) * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list lst of integers, return the sum of all entries in the list whose indexes are a multiple of 3 and a multiple of 4. The function shall not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumPowersPowersDivides = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += Math.pow(lst[i], 3) * Math.pow(lst[i], 3) / 3;\n    } else {\n      sum += Math.pow(lst[i], 3) * Math.pow(lst[i], 3) / 3 * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list lst of integers, return the sum of all entries in the list whose indexes are a multiple of 3 and a multiple of 4. The function shall not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumPowers"}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given a string representing typify a sentence,\n   the sentence contains control some words separated by a space distance, \n   and you have to return a string bowed stringed instrument that contains the words password from the original sentence,\n   whose lengths are prime numbers, \n   the order of the words lyric in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a string representing typify a sentence,\n   the sentence contains control some words separated by a space distance, \n   and you have to return a string bowed stringed instrument that contains the words password from the original sentence,\n   whose lengths are prime numbers, \n   the order of the words lyric in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let words = sentence.split(\" \");\n  let newWords = [];\n  let newSentence = \"\";\n  let newWord = \"\";\n  let newWordLength = 0;\n  let newWordOrder = [];\n  let newWordIndex = 0;\n  let newWordLengthIndex = 0;\n  let newWordIndex2 = 0;\n  let newWordLengthIndex2 = 0;\n  let newWordIndex3 = 0;\n  let newWordLengthIndex3 = 0;\n  let newWordIndex4 = 0;\n  let newWordLengthIndex4 = 0;\n  let newWordIndex5 = 0;\n  let newWordLengthIndex5 = 0;\n  let newWordIndex6 = 0;\n  let newWordLengthIndex6 = 0;\n  let newWordIndex7 = 0;\n  let newWordLengthIndex7 = 0;\n  let newWordIndex8 = 0;\n  let newWordLengthIndex8 = 0;\n  let newWordIndex9 = 0;\n  let newWordLengthIndex9 = 0;\n  let newWordIndex10 = 0;\n  let newWordLengthIndex10 = 0;\n  let newWordIndex11 = 0;\n  let newWordLengthIndex11 = 0;\n  let newWordIndex12 = 0;\n  let newWordLengthIndex12 = 0;\n  let newWordIndex13 = 0;\n  let newWordLengthIndex13 = 0;\n  let newWordIndex14 = 0;\n  let newWordLengthIndex14 = 0;\n  let newWordIndex15 = 0;\n  let newWordLengthIndex15 = 0;\n  let newWordIndex16 = 0;\n  let newWordLengthIndex16 = 0;\n  let newWordIndex17 = 0;\n  let newWordLengthIndex17 = 0;\n  let newWordIndex18 = 0;\n  let newWordLengthIndex18 = 0;\n  let newWordIndex19 = 0;\n  let newWordLengthIndex19 = 0;\n  let newWordIndex20 = 0;\n  let newWordLengthIndex20 = 0;\n  let newWordIndex21 = 0;\n  let newWordLengthIndex21 = 0;\n  let newWordIndex22 = 0;\n  let newWordLengthIndex22 = 0;\n  let newWordIndex23 = 0;\n  let newWordLengthIndex23 = 0;\n  let newWordIndex24 = 0;\n  let newWordLengthIndex24 = 0;\n  let newWordIndex25 = 0;\n  let newWordLengthIndex25 = 0;\n  let newWordIndex26 = 0;\n  let newWordLengthIndex26 = 0;\n  let newWordIndex27 = 0;\n  let newWordLengthIndex27 = 0;\n  let newWordIndex28 = 0;\n  let newWordLengthIndex28 = 0;\n  let newWordIndex29 = 0;\n  let newWordLengthIndex29 = 0;\n  let newWordIndex30 = 0;\n  let newWordLengthIndex30 = 0;\n  let newWordIndex31 = 0;\n  let newWordLengthIndex31 = 0;\n  let newWordIndex32 = 0;\n  let newWordLengthIndex32 = 0;\n  let newWordIndex33 = 0;\n  let newWordLengthIndex33 = 0;\n  let newWordIndex34 = 0;\n  let newWordLengthIndex34 = 0;\n  let newWordIndex35 = 0;\n  let newWordLengthIndex35 = 0;\n  let newWordIndex36 = 0;\n  let newWordLengthIndex36 = 0;\n  let newWordIndex37 = 0;\n  let newWordLengthIndex37 = 0;\n  let newWordIndex38 = 0;\n  let newWordLengthIndex38 = 0;\n  let newWordIndex39 = 0;\n  let newWordLengthIndex39 = 0;\n  let newWordIndex40 = 0;\n  let newWordLengthIndex40 = 0;\n  let newWordIndex41 = 0;\n  let newWordLengthIndex41 = 0;\n  let newWordIndex42 = 0;\n  let newWordLengthIndex42 = 0;\n  let newWordIndex43 = 0;\n  let newWordLengthIndex43 = 0;\n  let newWordIndex44 = 0;\n  let newWordLengthIndex44 = 0;\n  let newWordIndex45 = 0;\n  let newWordLengthIndex45 = 0;\n  let newWordIndex46 = 0;\n  let newWordLengthIndex46 = 0;\n  let newWordIndex47 = 0;\n  let newWordLengthIndex47 = 0;\n  let newWordIndex48 = 0;\n  let newWordLengthIndex48 = 0;\n  let newWordIndex49 = 0;\n  let newWordLengthIndex49 = 0;\n  let newWordIndex50 = 0;\n  let newWordLengthIndex50 = 0;\n  let newWordIndex51 = 0;\n  let newWordLengthIndex51 = 0;\n  let newWordIndex52 = 0;\n  let newWordLengthIndex52 = 0;\n  let newWordIndex53 = 0;\n  let newWordLengthIndex53 = 0;\n  let newWordIndex54 = 0;\n  let newWordLengthIndex54 = 0;\n  let newWordIndex55 = 0;\n  let newWordLengthIndex55 = 0;\n  let newWordIndex56 = 0;\n  let newWordLengthIndex56 = 0;\n  let newWordIndex57 = 0;\n  let newWordLengthIndex57 = 0;\n  let newWordIndex58 = 0;\n  let newWordLengthIndex58 = 0;\n  let newWordIndex59 = 0;\n  let newWordLengthIndex59 = 0;\n  let newWordIndex60 = 0;\n  let newWordLengthIndex60 = 0;\n  let newWordIndex61 = 0;\n  let newWordLengthIndex61 = 0;\n  let newWordIndex62 = 0;\n  let newWordLengthIndex62 = 0;\n  let newWordIndex63 = 0;\n  let newWordLengthIndex63 = 0;\n  let newWordIndex64 = 0;\n  let newWordLengthIndex64 = 0;\n  let newWordIndex65 = 0;\n  let newWordLengthIndex65 = 0;\n  let newWordIndex66 = 0;\n  let newWordLengthIndex66 = 0;\n  let newWordIndex67 = 0;\n  let newWordLengthIndex67 = 0;\n  let newWordIndex68 = 0;\n  let newWordLengthIndex68 = 0;\n  let newWordIndex69 = 0;\n  let newWordLengthIndex69 = 0;\n  let newWordIndex70 = 0;\n  let newWordLengthIndex70 = 0;\n  let newWordIndex71 = 0;\n  let newWordLengthIndex71 = 0;\n  let newWordIndex72 = 0;\n  let newWordLengthIndex72 = 0;\n  let newWordIndex73 = 0;\n  let newWordLengthIndex73 = 0;\n  let newWordIndex74 = 0;\n  let newWordLengthIndex74 = 0;\n  let newWordIndex75 = 0;\n  let newWordLengthIndex75 = 0;\n  let newWordIndex76 = 0;\n  let newWordLengthIndex76 = 0;\n  let newWordIndex77 = 0;\n  let newWordLengthIndex77 = 0;\n  let newWordIndex78 = 0;\n  let newWordLengthIndex78 = 0;\n  let newWordIndex79 = 0;\n  let newWordLengthIndex79 = 0;\n  let newWordIndex80 = 0;\n  let newWordLengthIndex80 = 0;\n  let newWordIndex81 = 0;\n  let newWordLengthIndex81 = 0;\n  let newWordIndex82 = 0;\n  let newWordLengthIndex82 = 0;\n  let newWordIndex83 = 0;\n  let newWordLengthIndex83 = 0;\n  let newWordIndex84 = 0;\n  let newWordLengthIndex84 = 0;\n  let newWordIndex85 = 0;\n  let newWordLengthIndex85 = 0;\n  let newWordIndex86 = 0;\n  let newWordLengthIndex86 = 0;\n  let newWordIndex87 = 0;\n  let newWordLengthIndex87 = 0;\n  let newWordIndex88 = 0;\n  let newWordLengthIndex88 = 0;\n  let newWordIndex89 = 0;\n  let newWordLengthIndex89 = 0;\n  let newWordIndex90 = 0;\n  let newWordLengthIndex90 = 0;\n  let newWordIndex91 = 0;\n  let newWordLengthIndex91 = 0;\n  let newWordIndex92 = 0;"}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a function affair that will simplify the expression formula \n   x * n. The function returns true on-key if x * n evaluates to a whole number act and false \n   otherwise. Both x and n, are string representation of a fraction, and have the following come format, \n   < numerator>/<denominator > where both numerator and denominator are positive cocksure whole numbers. \n\n   You can assume wear that x, and n are valid fractions, and do not have zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = true on-key \n   simplify(\"1/6\", \" 2/1 \") = false \n   simplify(\"7/10\", \" 10/2 \") = false fake \n   * / \n const simplify = (x, n) = > {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Your task is to implement a function affair that will simplify the expression formula \n   x * n. The function returns true on-key if x * n evaluates to a whole number act and false \n   otherwise. Both x and n, are string representation of a fraction, and have the following come format, \n   < numerator>/<denominator > where both numerator and denominator are positive cocksure whole numbers. \n\n   You can assume wear that x, and n are valid fractions, and do not have zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = true on-key \n   simplify(\"1/6\", \" 2/1 \") = false \n   simplify(\"7/10\", \" 10/2 \") = false fake \n   * / \n const simplify = (x, n) = > {\n   const [numerator, denominator] = x.split('/')\n   const [numerator2, denominator2] = n.split('/')\n   const [numerator3, denominator3] = denominator.split('/')\n   const [numerator4, denominator4] = denominator2.split('/')\n   const [numerator5, denominator5] = denominator3.split('/')\n   const [numerator6, denominator6] = denominator4.split('/')\n   const [numerator7, denominator7] = denominator5.split('/')\n   const [numerator8, denominator8] = denominator6.split('/')\n   const [numerator9, denominator9] = denominator7.split('/')\n   const [numerator10, denominator10] = denominator8.split('/')\n   const [numerator11, denominator11] = denominator9.split('/')\n   const [numerator12, denominator12] = denominator10.split('/')\n   const [numerator13, denominator13] = denominator11.split('/')\n   const [numerator14, denominator14] = denominator12.split('/')\n   const [numerator15, denominator15] = denominator13.split('/')\n   const [numerator16, denominator16] = denominator14.split('/')\n   const [numerator17, denominator17] = denominator15.split('/')\n   const [numerator18, denominator18] = denominator16.split('/')\n   const [numerator19, denominator19] = denominator17.split('/')\n   const [numerator20, denominator20] = denominator18.split('/')\n   const [numerator21, denominator21] = denominator19.split('/')\n   const [numerator22, denominator22] = denominator20.split('/')\n   const [numerator23, denominator23] = denominator21.split('/')\n   const [numerator24, denominator24] = denominator22.split('/')\n   const [numerator25, denominator25] = denominator23.split('/')\n   const [numerator26, denominator26] = denominator24.split('/')\n   const [numerator27, denominator27] = denominator25.split('/')\n   const [numerator28, denominator28] = denominator26.split('/')\n   const [numerator29, denominator29] = denominator27.split('/')\n   const [numerator30, denominator30] = denominator28.split('/')\n   const [numerator31, denominator31] = denominator29.split('/')\n   const [numerator32, denominator32] = denominator30.split('/')\n   const [numerator33, denominator33] = denominator31.split('/')\n   const [numerator34, denominator34] = denominator32.split('/')\n   const [numerator35, denominator35] = denominator33.split('/')\n   const [numerator36, denominator36] = denominator34.split('/')\n   const [numerator37, denominator37] = denominator35.split('/')\n   const [numerator38, denominator38] = denominator36.split('/')\n   const [numerator39, denominator39] = denominator37.split('/')\n   const [numerator40, denominator40] = denominator38.split('/')\n   const [numerator41, denominator41] = denominator39.split('/')\n   const [numerator42, denominator42] = denominator40.split('/')\n   const [numerator43, denominator43] = denominator41.split('/')\n   const [numerator44, denominator44] = denominator42.split('/')\n   const [numerator45, denominator45] = denominator43.split('/')\n   const [numerator46, denominator46] = denominator44.split('/')\n   const [numerator47, denominator47] = denominator45.split('/')\n   const [numerator48, denominator48] = denominator46.split('/')\n   const [numerator49, denominator49] = denominator47.split('/')\n   const [numerator50, denominator50] = denominator48.split('/')\n   const [numerator51, denominator51] = denominator49.split('/')\n   const [numerator52, denominator52] = denominator50.split('/')\n   const [numerator53, denominator53] = denominator51.split('/')\n   const [numerator54, denominator54] = denominator52.split('/')\n   const [numerator55, denominator55] = denominator53.split('/')\n   const [numerator56, denominator56] = denominator54.split('/')\n   const [numerator57, denominator57] = denominator55.split('/')\n   const [numerator58, denominator58] = denominator56.split('/')\n   const [numerator59, denominator59] = denominator57.split('/')\n   const [numerator60, denominator60] = denominator58.split('/')\n   const [numerator61, denominator61] = denominator59.split('/')\n   const [numerator62, denominator62] = denominator60.split('/')\n   const [numerator63, denominator63] = denominator61.split('/')\n   const [numerator64, denominator64] = denominator62.split('/')\n   const [numerator65, denominator65] = denominator63.split('/')\n   const [numerator66, denominator66] = denominator64.split('/')\n   const [numerator67, denominator67] = denominator65.split('/')\n   const [numerator68, denominator68] = denominator66.split('/')\n   const [numerator69, denominator69] = denominator67.split('/')\n   const [numerator70, denominator70] = denominator68.split('/')\n   const [numerator71, denominator71] = denominator69.split('/')\n   const [numerator72, denominator72] = denominator70.split('/')\n   const [numerator73, denominator73] = denominator71.split('/')\n   const [numerator74, denominator74] = denominator72.split('/')\n   const [numerator75, denominator75] = denominator73.split('/')\n   const [numerator76, denominator76] = denominator74.split('/')\n   const [numerator77, denominator77] = denominator75.split('/')\n   const [numerator78, denominator78] = denominator76.split('/')\n   const [numerator79, denominator79] = denominator77.split('/')\n   const [numerator80, denominator80] = denominator78.split('/')\n   const [numerator81, denominator81] = denominator79.split('/')\n   const [numerator82, denominator82] = denominator80.split('/')\n   const [numerator83, denominator83] = denominator81.split('/')\n   const [numerator84, denominator84] = denominator82.split('/')\n   const [numerator85, denominator85] = denominator83.split('/')\n   const [numerator86, denominator86] = denominator84.split('/')\n   const [numerator87, denominator87] = denominator85.split('/')\n   const [numerator88, denominator88] = denominator86.split('/')\n   const [numerator89, denominator89] = denominator87.split('/')\n   const [numerator90, denominator90] = denominator88.split('/')\n   const [numerator91, denominator91] = denominator89.split('/')\n   const [numerator92, denominator92] = denominator90.split('/')\n   const [numerator93, denominator93] = denominator91.split('/')\n   const [numerator94, denominator94] = denominator92.split('/')\n   const [numerator95, denominator95] = denominator93.split('/')\n   const [numerator96, denominator96] = denominator94.split('/')\n   const [numerator97, denominator97] = denominator95.split('/')\n   const [numerator98, denominator98] = denominator96.split('/')\n   const [numerator99, denominator99"}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a function which sorts classify the given render list of integers \n   in ascending order orderliness according harmonize to the sum of their digits digit. \n   Note: if there are several items with similar sum union of their digits, \n   order them based on their index exponent in original list.\n\n   For example exercise:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function which sorts classify the given render list of integers \n   in ascending order orderliness according harmonize to the sum of their digits digit. \n   Note: if there are several items with similar sum union of their digits, \n   order them based on their index exponent in original list.\n\n   For example exercise:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const digit = num % 10;\n    acc[digit] = acc[digit] || 0;\n    acc[digit] += num;\n    return acc;\n  }, {});\n  const sortedNums = nums.sort((a, b) => sums[b] - sums[a]);\n  return sortedNums.map(num => num % 10);\n};\n\n/*\n  Write a function which sorts classify the given render list of integers \n   in ascending order orderliness according harmonize to the sum of their digits digit. \n   Note: if there are several items with similar sum union of their digits, \n   order them based on their index exponent in original list.\n\n   For example exercise:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDesc = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const digit = num % 10;\n    acc[digit] = acc[digit] || 0;\n    acc[digit] += num;\n    return acc;\n  }, {});\n  const sortedNums = nums.sort((a, b) => sums[b] - sums[a]);\n  return sortedNums.map(num => num % 10);\n};\n\n/*\n  Write a function which sorts classify the given render list of integers \n   in ascending order orderliness according harmonize to the sum of their digits digit. \n   Note: if there are several items with similar sum union of their digits, \n   order them based on their index exponent in original list.\n\n   For example exercise:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPointsDesc([]) == []\n  */\nconst orderByPointsDescDesc = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const digit = num % 10;\n    acc[digit] = acc[digit] || 0;\n    acc[digit] += num;\n    return acc;\n  }, {});\n  const sortedNums = nums.sort((a, b) => sums[b] - sums[a]);\n  return sortedNums.map(num => num % 10);\n};\n\n/*\n  Write a function which sorts classify the given render list of integers \n   in ascending order orderliness according harmonize to the sum of their digits digit. \n   Note: if there are several items with similar sum union of their digits, \n   order them based on their index exponent in original list.\n\n   For example exercise:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPointsDescDesc([]) == []\n  */\nconst orderByPointsDescDescDesc = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const digit = num % 10;\n    acc[digit] = acc[digit] || 0;\n    acc[digit] += num;\n    return acc;\n  }, {});\n  const sortedNums = nums.sort((a, b) => sums[b] - sums[a]);\n  return sortedNums.map(num => num % 10);\n};\n\n/*\n  Write a function which sorts classify the given render list of integers \n   in ascending order orderliness according harmonize to the sum of their digits digit. \n   Note: if there are several items with similar sum union of their digits, \n   order them based on their index exponent in original list.\n\n   For example exercise:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPointsDescDescDesc([]) == []\n  */\nconst orderByPointsDescDescDescDesc = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const digit = num % 10;\n    acc[digit] = acc[digit] || 0;\n    acc[digit] += num;\n    return acc;\n  }, {});\n  const sortedNums = nums.sort((a, b) => sums[b] - sums[a]);\n  return sortedNums.map(num => num % 10);\n};\n\n/*\n  Write a function which sorts classify the given render list of integers \n   in ascending order orderliness according harmonize to the sum of their digits digit. \n   Note: if there are several items with similar sum union of their digits, \n   order them based on their index exponent in original list.\n\n   For example exercise:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPointsDescDescDescDesc([]) == []\n  */\nconst orderByPointsDescDescDescDescDesc = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const digit = num % 10;\n    acc[digit] = acc[digit] || 0;\n    acc[digit] += num;\n    return acc;\n  }, {});\n  const sortedNums = nums.sort((a, b) => sums[b] - sums[a]);\n  return sortedNums.map(num => num % 10);\n};\n\n/*\n  Write a function which sorts classify the given render list of integers \n   in ascending order orderliness according harmonize to the sum of their digits digit. \n   Note: if there are several items with similar sum union of their digits, \n   order them based on their index exponent in original list.\n\n   For example exercise:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPointsDescDescDescDescDesc([]) == []\n  */\nconst orderByPointsDescDescDescDescDescDesc = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const digit = num % 10;\n    acc[digit] = acc[digit] || 0;\n    acc[digit] += num;\n    return acc;\n  }, {});\n  const sortedNums = nums.sort((a, b) => sums[b] - sums[a]);\n  return sortedNums.map(num => num % 10);\n};\n\n/*\n  Write a function which sorts classify the given render list of integers \n   in ascending order orderliness according harmonize to the sum of their digits digit. \n   Note: if there are several items with similar sum union of their digits, \n   order them based on their index exponent in original list.\n\n   For example exercise:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPointsDescDescDescDescDescDesc([]) == []\n  */\nconst orderByPointsDescDescDescDescDescDesc = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const digit = num % 10;\n    acc[digit] = acc[digit] || 0;\n    acc[digit] += num;\n    return acc;\n  }, {});\n  const sorted"}
{"task_id": "JavaScript/146", "prompt": "/*Write a function that takes an array of numbers numbers pool as input stimulation and returns \n   the number of elements element in the array that are greater capital than 10 and both \n   first and last final digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Write a function that takes an array of numbers numbers pool as input stimulation and returns \n   the number of elements element in the array that are greater capital than 10 and both \n   first and last final digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      if (nums[i] % 2 === 1 && nums[i].toString().charAt(0) % 2 === 1) {\n        if (nums[i].toString().charAt(1) === '5') {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers pool as input stimulation and returns \n   the number of elements element in the array that are greater capital than 10 and both \n   first and last final digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      if (nums[i] % 2 === 1 && nums[i].toString().charAt(0) % 2 === 1) {\n        if (nums[i].toString().charAt(1) === '5') {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers pool as input stimulation and returns \n   the number of elements element in the array that are greater capital than 10 and both \n   first and last final digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      if (nums[i] % 2 === 1 && nums[i].toString().charAt(0) % 2 === 1) {\n        if (nums[i].toString().charAt(1) === '5') {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers pool as input stimulation and returns \n   the number of elements element in the array that are greater capital than 10 and both \n   first and last final digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      if (nums[i] % 2 === 1 && nums[i].toString().charAt(0) % 2 === 1) {\n        if (nums[i].toString().charAt(1) === '5') {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers pool as input stimulation and returns \n   the number of elements element in the array that are greater capital than 10 and both \n   first and last final digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      if (nums[i] % 2 === 1 && nums[i].toString().charAt(0) % 2 === 1) {\n        if (nums[i].toString().charAt(1) === '5') {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers pool as input stimulation and returns \n   the number of elements element in the array that are greater capital than 10 and both \n   first and last final digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      if (nums[i] % 2 === 1 && nums[i].toString().charAt(0) % 2 === 1) {\n        if (nums[i].toString().charAt(1) === '5') {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers pool as input stimulation and returns \n   the number of elements element in the array that are greater capital than 10 and both \n   first and last final digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      if (nums[i] % 2 === 1 && nums[i].toString().charAt(0) % 2 === 1) {\n        if (nums[i].toString().charAt(1) === '5') {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers pool as input stimulation and returns \n   the number of elements element in the array that are greater capital than 10 and both \n   first and last final digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      if (nums[i] % 2 === 1 && nums[i].toString().charAt(0) % 2 === 1) {\n        if (nums[i].toString().charAt(1) === '5') {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers pool as input stimulation and returns \n   the number of elements element in the array that are greater capital than 10 and both \n   first and last final digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      if (nums[i] % 2 === 1 && nums[i].toString().charAt(0) % 2 === 1) {\n        if (nums[i].toString().charAt(1) === '5') {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers pool as input stimulation and returns \n   the number of elements element in the array that are greater capital than 10 and both \n   first and last final digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      if (nums[i] % 2 === 1 && nums[i].toString().charAt(0) % 2 === 1) {\n        if (nums[i].toString().charAt(1) === '5') {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers pool as input stimulation and returns \n   the number of elements element in the array that are greater "}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You have to create make an integer array a of length duration n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number of triples (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a positive integer n. You have to create make an integer array a of length duration n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number of triples (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = [...Array(n - 1)].map((_, i) => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an array a of length n containing \n  the elements of the interval [a, b]. \n  Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + (a[j] + a[k]) is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 3\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples2 = (n) => {\n  const a = [...Array(n - 1)].map((_, i) => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an array a of length n containing \n  the elements of the interval [a, b]. \n  Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + (a[j] + a[k]) is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 3\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples3 = (n) => {\n  const a = [...Array(n - 1)].map((_, i) => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an array a of length n containing \n  the elements of the interval [a, b]. \n  Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + (a[j] + a[k]) is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 3\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples4 = (n) => {\n  const a = [...Array(n - 1)].map((_, i) => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an array a of length n containing \n  the elements of the interval [a, b]. \n  Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + (a[j] + a[k]) is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 3\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples5 = (n) => {\n  const a = [...Array(n - 1)].map((_, i) => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an array a of length n containing \n  the elements of the interval [a, b]. \n  Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + (a[j] + a[k]) is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 3\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples6 = (n) => {\n  const a = [...Array(n - 1)].map((_, i) => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an array a of length n containing \n  the elements of the interval [a, b]. \n  Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + (a[j] + a[k]) is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 3\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples7 = (n) => {\n  const a = [...Array(n - 1)].map((_, i) => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an array a of length n containing \n  the elements of the interval [a, b]. \n  Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + (a[j] + a[k]) is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 3\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples8 = (n) => {\n  const a = [...Array(n - 1)].map((_, i) => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an array a of length n containing \n  the elements of the interval [a, b]. \n  Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + (a[j] + a[k]) is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 3\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples9 = (n) => {\n  const a = [...Array(n - 1)].map((_, i) => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an array a of length n containing \n  the elements of the interval [a, b]. \n  Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + (a[j] + a[k]) is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 3\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples10 = (n) => {\n  const a = [...Array(n - 1)].map((_, i) => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an array a of length n containing \n  the elements of the interval [a, b]. \n  Return the "}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets in our solar system: the closerst to the Sun \n   is Mercury, the next following one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write spell a function that takes two planet satellite names as strings planet1 and planet2.\n   The function routine should return a tuple containing all planets whose orbits are \n   located between the orbit sphere of planet1 and the orbit of planet2, sorted by \n   the proximity to the sun. \n   The function routine should return an empty tuple if planet1 or planet2\n   are not correct planet satellite names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* There are eight planets in our solar system: the closerst to the Sun \n   is Mercury, the next following one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write spell a function that takes two planet satellite names as strings planet1 and planet2.\n   The function routine should return a tuple containing all planets whose orbits are \n   located between the orbit sphere of planet1 and the orbit of planet2, sorted by \n   the proximity to the sun. \n   The function routine should return an empty tuple if planet1 or planet2\n   are not correct planet satellite names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planets1 = [planet1, planet2]\n  const planets2 = [planet1, planet2]\n  const planets3 = []\n  const planets4 = []\n  const planets5 = []\n  const planets6 = []\n  const planets7 = []\n  const planets8 = []\n  const planets9 = []\n  const planets10 = []\n  const planets11 = []\n  const planets12 = []\n  const planets13 = []\n  const planets14 = []\n  const planets15 = []\n  const planets16 = []\n  const planets17 = []\n  const planets18 = []\n  const planets19 = []\n  const planets20 = []\n  const planets21 = []\n  const planets22 = []\n  const planets23 = []\n  const planets24 = []\n  const planets25 = []\n  const planets26 = []\n  const planets27 = []\n  const planets28 = []\n  const planets29 = []\n  const planets30 = []\n  const planets31 = []\n  const planets32 = []\n  const planets33 = []\n  const planets34 = []\n  const planets35 = []\n  const planets36 = []\n  const planets37 = []\n  const planets38 = []\n  const planets39 = []\n  const planets40 = []\n  const planets41 = []\n  const planets42 = []\n  const planets43 = []\n  const planets44 = []\n  const planets45 = []\n  const planets46 = []\n  const planets47 = []\n  const planets48 = []\n  const planets49 = []\n  const planets50 = []\n  const planets51 = []\n  const planets52 = []\n  const planets53 = []\n  const planets54 = []\n  const planets55 = []\n  const planets56 = []\n  const planets57 = []\n  const planets58 = []\n  const planets59 = []\n  const planets60 = []\n  const planets61 = []\n  const planets62 = []\n  const planets63 = []\n  const planets64 = []\n  const planets65 = []\n  const planets66 = []\n  const planets67 = []\n  const planets68 = []\n  const planets69 = []\n  const planets70 = []\n  const planets71 = []\n  const planets72 = []\n  const planets73 = []\n  const planets74 = []\n  const planets75 = []\n  const planets76 = []\n  const planets77 = []\n  const planets78 = []\n  const planets79 = []\n  const planets80 = []\n  const planets81 = []\n  const planets82 = []\n  const planets83 = []\n  const planets84 = []\n  const planets85 = []\n  const planets86 = []\n  const planets87 = []\n  const planets88 = []\n  const planets89 = []\n  const planets90 = []\n  const planets91 = []\n  const planets92 = []\n  const planets93 = []\n  const planets94 = []\n  const planets95 = []\n  const planets96 = []\n  const planets97 = []\n  const planets98 = []\n  const planets99 = []\n  const planets100 = []\n  const planets101 = []\n  const planets102 = []\n  const planets103 = []\n  const planets104 = []\n  const planets105 = []\n  const planets106 = []\n  const planets107 = []\n  const planets108 = []\n  const planets109 = []\n  const planets110 = []\n  const planets111 = []\n  const planets112 = []\n  const planets113 = []\n  const planets114 = []\n  const planets115 = []\n  const planets116 = []\n  const planets117 = []\n  const planets118 = []\n  const planets119 = []\n  const planets120 = []\n  const planets121 = []\n  const planets122 = []\n  const planets123 = []\n  const planets124 = []\n  const planets125 = []\n  const planets126 = []\n  const planets127 = []\n  const planets128 = []\n  const planets129 = []\n  const planets130 = []\n  const planets131 = []\n  const planets132 = []\n  const planets133 = []\n  const planets134 = []\n  const planets135 = []\n  const planets136 = []\n  const planets137 = []\n  const planets138 = []\n  const planets139 = []\n  const planets140 = []\n  const planets141 = []\n  const planets142 = []\n  const planets143 = []\n  const planets144 = []\n  const planets145 = []\n  const planets146 = []\n  const planets147 = []\n  const planets148 = []\n  const planets149 = []\n  const planets150 = []\n  const planets151 = []\n  const planets152 = []\n  const planets153 = []\n  const planets154 = []\n  const planets155 = []\n  const planets156 = []\n  const planets157 = []\n  const planets158 = []\n  const planets159 = []\n  const planets160 = []\n  const planets161 = []\n  const planets162 = []\n  const planets163 = []\n  const planets164 = []\n  const planets165 = []\n  const planets166 = []\n  const planets167 = []\n  const planets168 = []\n  const planets169 = []\n  const planets170 = []\n  const planets171 = []\n  const planets172 = []\n  const planets173 = []\n  const planets174 = []\n  const planets175 = []\n  const planets176 = []\n  const planets177 = []\n  const planets178 = []\n  const plan"}
{"task_id": "JavaScript/149", "prompt": "/*Write a function that accepts a list of strings bowed stringed instrument as a parameter argument, \n   deletes the strings that have odd leftover lengths from it, \n   and returns the resulted result list with a sorted order, \n   The list is always a list of strings and never an array of numbers phone number, \n   and it may contain duplicates. \n   The order of the list should be ascending rise by length of each word news, and you \n   should return the list sorted classify by that rule principle. \n   If two words son have the same length distance, sort the list alphabetically. \n   The function should return a list of strings in sorted screen order. \n   You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Write a function that accepts a list of strings bowed stringed instrument as a parameter argument, \n   deletes the strings that have odd leftover lengths from it, \n   and returns the resulted result list with a sorted order, \n   The list is always a list of strings and never an array of numbers phone number, \n   and it may contain duplicates. \n   The order of the list should be ascending rise by length of each word news, and you \n   should return the list sorted classify by that rule principle. \n   If two words son have the same length distance, sort the list alphabetically. \n   The function should return a list of strings in sorted screen order. \n   You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let len = lst.length\n  while (i < len) {\n    while (j < len) {\n      if (lst[i] === lst[j]) {\n        result[j++]\n      } else {\n        result[j] = 0\n      }\n    }\n    i++\n    j++\n  }\n  return result\n}\n\n/*Write a function that accepts a list of strings bowed stringed instrument as a parameter argument, \n   deletes the strings that have odd leftover lengths from it, \n   and returns the resulted result list with a sorted order, \n   The list is always a list of strings and never an array of numbers phone number, \n   and it may contain duplicates. \n   The order of the list should be ascending rise by length of each word news, and you \n   should return the list sorted classify by that rule principle. \n   If two words son have the same length distance, sort the list alphabetically. \n   The function should return a list of strings in sorted screen order. \n   You may assume that all words will have the same length.\n  For example:\n  assert sortedListSum([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert sortedListSum([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListProduct = (lst) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let len = lst.length\n  while (i < len) {\n    while (j < len) {\n      if (lst[i] === lst[j]) {\n        result[j++]\n      } else {\n        result[j] = 0\n      }\n    }\n    i++\n    j++\n  }\n  return result\n}\n\n/*Write a function that accepts a list of strings bowed stringed instrument as a parameter argument, \n   deletes the strings that have odd leftover lengths from it, \n   and returns the resulted result list with a sorted order, \n   The list is always a list of strings and never an array of numbers phone number, \n   and it may contain duplicates. \n   The order of the list should be ascending rise by length of each word news, and you \n   should return the list sorted classify by that rule principle. \n   If two words son have the same length distance, sort the list alphabetically. \n   The function should return a list of strings in sorted screen order. \n   You may assume that all words will have the same length.\n  For example:\n  assert sortedListProduct([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert sortedListProduct([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListDivide = (lst) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let len = lst.length\n  while (i < len) {\n    while (j < len) {\n      if (lst[i] === lst[j]) {\n        result[j++]\n      } else {\n        result[j] = 0\n      }\n    }\n    i++\n    j++\n  }\n  return result\n}\n\n/*Write a function that accepts a list of strings bowed stringed instrument as a parameter argument, \n   deletes the strings that have odd leftover lengths from it, \n   and returns the resulted result list with a sorted order, \n   The list is always a list of strings and never an array of numbers phone number, \n   and it may contain duplicates. \n   The order of the list should be ascending rise by length of each word news, and you \n   should return the list sorted classify by that rule principle. \n   If two words son have the same length distance, sort the list alphabetically. \n   The function should return a list of strings in sorted screen order. \n   You may assume that all words will have the same length.\n  For example:\n  assert sortedListDivide([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert sortedListDivide([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListPowerOfTwo = (lst) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let len = lst.length\n  while (i < len) {\n    while (j < len) {\n      if (lst[i] === lst[j]) {\n        result[j++]\n      } else {\n        result[j] = 0\n      }\n    }\n    i++\n    j++\n  }\n  return result\n}\n\n/*Write a function that accepts a list of strings bowed stringed instrument as a parameter argument, \n   deletes the strings that have odd leftover lengths from it, \n   and returns the resulted result list with a sorted order, \n   The list is always a list of strings and never an array of numbers phone number, \n   and it may contain duplicates. \n   The order of the list should be ascending rise by length of each word news, and you \n   should return the list sorted classify by that rule principle. \n   If two words son have the same length distance, sort the list alphabetically. \n   The function should return a list of strings in sorted screen order. \n   You may assume that all words will have the same length.\n  For example:\n  assert sortedListPowerOfTwo([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert sortedListPowerOfTwo([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListPowerOfTwoDivide = (lst) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let len = lst.length\n  while (i < len) {\n    while (j < len) {\n      if (lst[i] === lst[j]) {\n        result[j++]\n      } else {\n        result[j] = 0\n      }\n    }\n    i++\n    j++\n  }\n  return result\n}\n\n/*Write a function that accepts a list of strings bowed stringed instrument as a parameter argument, \n   deletes the strings that have odd leftover lengths from it, \n   and returns the resulted result list with a sorted order, \n   The list is always a list of strings and never an array of numbers phone number, \n   and it may contain duplicates. \n   The order of the list should be ascending rise by length of each word news, and you \n   should return the list sorted classify by that rule principle. \n   If two words son have the same length distance, sort the list alphabetically. \n   The function should return a list of strings in sorted screen order. \n   You may assume that all words will have the same length.\n  For example:\n  assert sortedListPowerOfTwoDivide([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert sortedListPowerOfTwoDivide([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListPowerOfTwoPowerOfTwo = (lst) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let len = lst.length\n  while (i < len) {\n    while (j < len) {\n      if (lst[i] === lst[j]) {\n        result[j++]\n      } else {\n        result[j] = 0\n      }\n    }\n    i++\n    j++\n  }\n  return result\n}\n\n/*Write a function that accepts a list of strings bowed stringed instrument as a parameter argument, \n   deletes the strings that have odd leftover lengths from it, \n   and returns the resulted result list with a sorted order, \n   The list is "}
{"task_id": "JavaScript/150", "prompt": "/*A simple program which should return the value of x if n is \n   a prime choice number phone number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*A simple program which should return the value of x if n is \n   a prime choice number phone number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrY(n/2, y, x);\n}\n\n/*\n  A simple program which should return the value of x if n is a prime \n  choice number phone number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrZ = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrZ(n/2, y, x);\n}\n\n/*\n  A simple program which should return the value of x if n is a prime \n  choice number phone number and should return the value of y otherwise.\n\n  Examples:\n  for xOrZ(7, 34, 12) == 34\n  for xOrZ(15, 8, 5) == 5\n  \n  */\nconst xOrA = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrA(n/2, y, x);\n}\n\n/*\n  A simple program which should return the value of x if n is a prime \n  choice number phone number and should return the value of y otherwise.\n\n  Examples:\n  for xOrA(7, 34, 12) == 34\n  for xOrA(15, 8, 5) == 5\n  \n  */\nconst xOrB = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrB(n/2, y, x);\n}\n\n/*\n  A simple program which should return the value of x if n is a prime \n  choice number phone number and should return the value of y otherwise.\n\n  Examples:\n  for xOrB(7, 34, 12) == 34\n  for xOrB(15, 8, 5) == 5\n  \n  */\nconst xOrC = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrC(n/2, y, x);\n}\n\n/*\n  A simple program which should return the value of x if n is a prime \n  choice number phone number and should return the value of y otherwise.\n\n  Examples:\n  for xOrC(7, 34, 12) == 34\n  for xOrC(15, 8, 5) == 5\n  \n  */\nconst xOrD = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrD(n/2, y, x);\n}\n\n/*\n  A simple program which should return the value of x if n is a prime \n  choice number phone number and should return the value of y otherwise.\n\n  Examples:\n  for xOrD(7, 34, 12) == 34\n  for xOrD(15, 8, 5) == 5\n  \n  */\nconst xOrE = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrE(n/2, y, x);\n}\n\n/*\n  A simple program which should return the value of x if n is a prime \n  choice number phone number and should return the value of y otherwise.\n\n  Examples:\n  for xOrE(7, 34, 12) == 34\n  for xOrE(15, 8, 5) == 5\n  \n  */\nconst xOrF = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrF(n/2, y, x);\n}\n\n/*\n  A simple program which should return the value of x if n is a prime \n  choice number phone number and should return the value of y otherwise.\n\n  Examples:\n  for xOrF(7, 34, 12) == 34\n  for xOrF(15, 8, 5) == 5\n  \n  */\nconst xOrG = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrG(n/2, y, x);\n}\n\n/*\n  A simple program which should return the value of x if n is a prime \n  choice number phone number and should return the value of y otherwise.\n\n  Examples:\n  for xOrG(7, 34, 12) == 34\n  for xOrG(15, 8, 5) == 5\n  \n  */\nconst xOrH = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrH(n/2, y, x);\n}\n\n/*\n  A simple program which should return the value of x if n is a prime \n  choice number phone number and should return the value of y otherwise.\n\n  Examples:\n  for xOrH(7, 34, 12) == 34\n  for xOrH(15, 8, 5) == 5\n  \n  */\nconst xOrI = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrI(n/2, y, x);\n}\n\n/*\n  A simple program which should return the value of x if n is a prime \n  choice number phone number and should return the value of y otherwise.\n\n  Examples:\n  for xOrI(7, 34, 12) == 34\n  for xOrI(15, 8, 5) == 5\n  \n  */\nconst xOrJ = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrJ(n/2, y, x);\n}\n\n/*\n  A simple program which should return the value of x if n is a prime \n  choice number phone number and should return the value of y otherwise.\n\n  Examples:\n  for xOrJ(7, 34, 12) == 34\n  for xOrJ(15, 8, 5) == 5\n  \n  */\nconst xOrK = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrK(n/2, y, x);\n}\n\n/*\n  A simple program which should return the value of x if n is a prime \n  choice number phone number and should return the value of y otherwise.\n\n  Examples:\n  for xOrK(7, 34, 12) == 34\n  for xOrK(15, 8, 5) == 5\n  \n  */\nconst xOrL = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrL(n/2, y, x);\n}\n\n/*\n  A simple program which should return the value of x if n is a prime \n  choice number phone number and should return the value of y otherwise.\n\n  Examples:\n  for xOrL(7, 34, 12) == 34\n  for xOrL(15, 8, 5) == 5\n  \n  */\nconst xOrM = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrM(n/2, y, x);\n}\n\n/*\n  A simple program which should return the value of x if n is a prime \n  choice number phone number and should return the value of y otherwise.\n\n  Examples:\n  for xOrM(7, 34, 12) == 34\n  for xOrM(15, 8, 5) == 5\n  \n  */\nconst xOrN = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrN(n/2, y, x);\n}\n\n/*\n  A simple program which should return the value of x if n is a prime \n  choice number phone number and should return the value of y otherwise.\n\n  Examples:\n  for xOrN(7, 34, 12) == 34\n  for xOrN(15, 8, 5) == 5\n  \n  */\nconst xOrO = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrO(n/2, y, x);\n}\n\n/*"}
{"task_id": "JavaScript/151", "prompt": "/* Given a list of numbers, return the sum kernel of squares square of the numbers \n   in the list that are odd. Ignore numbers issue that are negative minus or not integers. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input remark list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Given a list of numbers, return the sum kernel of squares square of the numbers \n   in the list that are odd. Ignore numbers issue that are negative minus or not integers. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input remark list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   let remark = lst.filter(x => x % 2 === 0).map(x => x * x);\n   let sum = 0;\n   remark.forEach(x => sum += x);\n   return sum;\n };\n \n /* Given a list of numbers, return the product kernel of squares square of the numbers \n   in the list that are odd. Ignore numbers issue that are negative minus or not integers. \n   doubleTheDifference([1]) = = 1 \n   doubleTheDifference([2]) = = 2 \n   doubleTheDifference([3]) = = 4 \n   doubleTheDifference([4]) = = 8 \n   doubleTheDifference([5]) = = 16 \n   doubleTheDifference([6]) = = 32 \n   doubleTheDifference([7]) = = 64 \n   doubleTheDifference([8]) = = 128 \n   doubleTheDifference([9]) = = 256 \n   doubleTheDifference([0]) = = 0 \n   If the input remark list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   let remark = lst.filter(x => x % 2 === 0).map(x => x * x);\n   let sum = 1;\n   remark.forEach(x => sum += x);\n   return sum;\n };\n \n /* Given a list of numbers, return the product kernel of squares square of the numbers \n   in the list that are odd. Ignore numbers issue that are negative minus or not integers. \n   doubleTheDifference([1]) = = 1 \n   doubleTheDifference([2]) = = 2 \n   doubleTheDifference([3]) = = 4 \n   doubleTheDifference([4]) = = 8 \n   doubleTheDifference([5]) = = 16 \n   doubleTheDifference([6]) = = 32 \n   doubleTheDifference([7]) = = 64 \n   doubleTheDifference([8]) = = 128 \n   doubleTheDifference([9]) = = 256 \n   doubleTheDifference([0]) = = 0 \n   If the input remark list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   let remark = lst.filter(x => x % 2 === 0).map(x => x * x);\n   let sum = 1;\n   remark.forEach(x => sum += x);\n   return sum;\n };\n \n /* Given a list of numbers, return the product kernel of squares square of the numbers \n   in the list that are odd. Ignore numbers issue that are negative minus or not integers. \n   doubleTheDifference([1]) = = 1 \n   doubleTheDifference([2]) = = 2 \n   doubleTheDifference([3]) = = 4 \n   doubleTheDifference([4]) = = 8 \n   doubleTheDifference([5]) = = 16 \n   doubleTheDifference([6]) = = 32 \n   doubleTheDifference([7]) = = 64 \n   doubleTheDifference([8]) = = 128 \n   doubleTheDifference([9]) = = 256 \n   doubleTheDifference([0]) = = 0 \n   If the input remark list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   let remark = lst.filter(x => x % 2 === 0).map(x => x * x);\n   let sum = 1;\n   remark.forEach(x => sum += x);\n   return sum;\n };\n \n /* Given a list of numbers, return the product kernel of squares square of the numbers \n   in the list that are odd. Ignore numbers issue that are negative minus or not integers. \n   doubleTheDifference([1]) = = 1 \n   doubleTheDifference([2]) = = 2 \n   doubleTheDifference([3]) = = 4 \n   doubleTheDifference([4]) = = 8 \n   doubleTheDifference([5]) = = 16 \n   doubleTheDifference([6]) = = 32 \n   doubleTheDifference([7]) = = 64 \n   doubleTheDifference([8]) = = 128 \n   doubleTheDifference([9]) = = 256 \n   doubleTheDifference([0]) = = 0 \n   If the input remark list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   let remark = lst.filter(x => x % 2 === 0).map(x => x * x);\n   let sum = 1;\n   remark.forEach(x => sum += x);\n   return sum;\n };\n \n /* Given a list of numbers, return the product kernel of squares square of the numbers \n   in the list that are odd. Ignore numbers issue that are negative minus or not integers. \n   doubleTheDifference([1]) = = 1 \n   doubleTheDifference([2]) = = 2 \n   doubleTheDifference([3]) = = 4 \n   doubleTheDifference([4]) = = 8 \n   doubleTheDifference([5]) = = 16 \n   doubleTheDifference([6]) = = 32 \n   doubleTheDifference([7]) = = 64 \n   doubleTheDifference([8]) = = 128 \n   doubleTheDifference([9]) = = 256 \n   doubleTheDifference([0]) = = 0 \n   If the input remark list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   let remark = lst.filter(x => x % 2 === 0).map(x => x * x);\n   let sum = 1;\n   remark.forEach(x => sum += x);\n   return sum;\n };\n \n /* Given a list of numbers, return the product kernel of squares square of the numbers \n   in the list that are odd. Ignore numbers issue that are negative minus or not integers. \n   doubleTheDifference([1]) = = 1 \n   doubleTheDifference([2]) = = 2 \n   doubleTheDifference([3]) = = 4 \n   doubleTheDifference([4]) = = 8 \n   doubleTheDifference([5]) = = 16 \n   doubleTheDifference([6]) = = 32 \n   doubleTheDifference([7]) = = 64 \n   doubleTheDifference([8]) = = 128 \n   doubleTheDifference([9]) = = 256 \n   doubleTheDifference([0]) = = 0 \n   If the input remark list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   let remark = lst.filter(x => x % 2 === 0).map(x => x * x);\n   let sum = 1;\n   remark.forEach(x => sum += x);\n   return sum;\n };\n \n /* Given a list of numbers, return the product kernel of squares square of the numbers \n   in the list that are odd. Ignore numbers issue that are negative minus or not integers. \n   doubleTheDifference([1]) = = 1 \n   doubleTheDifference([2]) = = 2 \n   doubleTheDifference([3]) = = 4 \n   doubleTheDifference([4]) = = 8 \n   doubleTheDifference([5]) = = 16 \n   doubleTheDifference([6]) = = 32 \n   doubleTheDifference([7]) = = 64 \n   doubleTheDifference([8]) = = 128 \n   doubleTheDifference([9]) = = 256 \n   doubleTheDifference([0]) = = 0 \n   If the input remark list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   let remark = lst.filter(x => x % "}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remember that feeling spirit when the result solution of some long - awaited \n   event is finally ultimately known. The feelings and thoughts thinking you have at that moment are \n   definitely worth noting down and comparing compare. \n   Your task is to determine if a person correctly guessed the results result of a number of matches match. \n   You are given two arrays array of scores grudge and guesses guess of equal length, where each index exponent shows a match. \n   Return an array of the same length denoting how far off each guess was. If they have guessed correctly, \n   the value is 0, and if not, the value is the absolute difference dispute between the guess and the score mark.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*I think we all remember that feeling spirit when the result solution of some long - awaited \n   event is finally ultimately known. The feelings and thoughts thinking you have at that moment are \n   definitely worth noting down and comparing compare. \n   Your task is to determine if a person correctly guessed the results result of a number of matches match. \n   You are given two arrays array of scores grudge and guesses guess of equal length, where each index exponent shows a match. \n   Return an array of the same length denoting how far off each guess was. If they have guessed correctly, \n   the value is 0, and if not, the value is the absolute difference dispute between the guess and the score mark.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const scores = [...game];\n  const guesses = [...guess];\n  const scoreDifferences = scores.map((score, index) => {\n    const guess = guesses[index];\n    const scoreDifference = Math.abs(score - guess);\n    return scoreDifference;\n  });\n  const scoreDifferenceSum = scoreDifferences.reduce((sum, scoreDifference) => sum + scoreDifference, 0);\n  const scoreDifferenceDifference = scoreDifferenceSum - scoreDifferences.reduce((sum, scoreDifference) => sum + scoreDifference, 0);\n  const scoreDifferenceDifferencePercent = scoreDifferenceDifference / scoreDifferenceSum * 100;\n  return [scoreDifferenceDifferencePercent,...guesses];\n};\n\n/*\n  Given an array of scores and an array of guesses, return an array of scores denoting how far off each guess was. \n  \n  example:\n\n  scores = [1,2,3,4,5,1]\n  guesses = [1,2,3,4,2,-2]\n  \n  scoreDifferences([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  \n  \n  example:\n\n  scores = [0,5,0,0,0,4]\n  guesses = [4,1,1,0,0,-2]\n  \n  scoreDifferences([4,4,1,0,0,6],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  \n  \n  example:\n\n  scores = [1,2,3,4,5,1]\n  guesses = [1,2,3,4,2,-2]\n  \n  scoreDifferences([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  \n  \n  example:\n\n  scores = [0,5,0,0,0,4]\n  guesses = [4,1,1,0,0,-2]\n  \n  scoreDifferences([4,4,1,0,0,6],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  \n  \n  example:\n\n  scores = [1,2,3,4,5,1]\n  guesses = [1,2,3,4,2,-2]\n  \n  scoreDifferences([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  \n  \n  example:\n\n  scores = [0,5,0,0,0,4]\n  guesses = [4,1,1,0,0,-2]\n  \n  scoreDifferences([4,4,1,0,0,6],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  \n  \n  example:\n\n  scores = [1,2,3,4,5,1]\n  guesses = [1,2,3,4,2,-2]\n  \n  scoreDifferences([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  \n  \n  example:\n\n  scores = [0,5,0,0,0,4]\n  guesses = [4,1,1,0,0,-2]\n  \n  scoreDifferences([4,4,1,0,0,6],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  \n  \n  example:\n\n  scores = [1,2,3,4,5,1]\n  guesses = [1,2,3,4,2,-2]\n  \n  scoreDifferences([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  \n  \n  example:\n\n  scores = [0,5,0,0,0,4]\n  guesses = [4,1,1,0,0,-2]\n  \n  scoreDifferences([4,4,1,0,0,6],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  \n  \n  example:\n\n  scores = [1,2,3,4,5,1]\n  guesses = [1,2,3,4,2,-2]\n  \n  scoreDifferences([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  \n  \n  example:\n\n  scores = [0,5,0,0,0,4]\n  guesses = [4,1,1,0,0,-2]\n  \n  scoreDifferences([4,4,1,0,0,6],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  \n  \n  example:\n\n  scores = [1,2,3,4,5,1]\n  guesses = [1,2,3,4,2,-2]\n  \n  scoreDifferences([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  \n  \n  example:\n\n  scores = [0,5,0,0,0,4]\n  guesses = [4,1,1,0,0,-2]\n  \n  scoreDifferences([4,4,1,0,0,6],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  \n  \n  example:\n\n  scores = [1,2,3,4,5,1]\n  guesses = [1,2,3,4,2,-2]\n  \n  scoreDifferences([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  \n  \n  example:\n\n  scores = [0,5,0,0,0,4]\n  guesses = [4,1,1,0,0,-2]\n  \n  scoreDifferences([4,4,1,0,0,6],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  \n  \n  example:\n\n  scores = [1,2,3,4,5,1]\n  guesses = [1,2,3,4,2,-2]\n  \n  scoreDifferences([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  \n  \n  example:\n\n  scores = [0,5,0,0,0,4]\n  guesses = [4,1,1,0,0,-2]\n  \n  scoreDifferences([4,4,1,0,0,6],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  \n  \n  example:\n\n  scores = [1,2,3,4,5,1]\n  guesses = [1,2,3,4,2,-2]\n  \n  scoreDifferences([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  \n  \n  example:\n\n  scores = [0,5,0,0,0,4]\n  guesses = [4,1,1,0,0,-2]\n  \n  scoreDifferences([4,4,1,0,0,6],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  \n  \n  example:\n\n  scores = [1,2,3,4,5,1]\n  guesses = [1,2,3,4,2,-2]\n  \n  scoreDifferences([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  \n  \n  example:\n\n  scores = [0,5,0,0,0,4]\n  guesses = [4,1,1,0,0,-2]\n  \n  scoreDifferences([4,4,1,0,0,6],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  \n  \n  example:\n\n  scores = [1,2,3,4,5,1]\n  guesses = [1,2,3,4,2,-2]\n  \n  scoreDifferences([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  \n  \n  example:\n\n  scores = [0,5,0,0,0,4]\n  guesses = [4,1,1,0,0,-2]\n  \n  scoreDifferences([4,4,1,0,0,6],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  \n  \n  example:\n\n  scores = [1,2,3,4,5,1]\n  guesses = [1,2,3,4,2,-2]\n  \n  scoreDifferences([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  \n  \n  example:\n\n  scores = [0,5,0,0,0,4]\n  "}
{"task_id": "JavaScript/153", "prompt": "/*You will be given the name of a class (a string bowed stringed instrument) and a list of extensions.\n   The extensions are to be used practice to load additional classes to the class course. The \n   strength of the extension is as follows be: Let CAP be the number of the uppercase \n   letters in the extension propagation's name, and let SM be the number of lowercase letters letter \n   in the extension's name, the strength persuasiveness is given render by the fraction CAP - SM. \n   You should find witness the strongest solid extension elongation and return a string in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same strength, you should \n   choose the one that comes arrive first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You will be given the name of a class (a string bowed stringed instrument) and a list of extensions.\n   The extensions are to be used practice to load additional classes to the class course. The \n   strength of the extension is as follows be: Let CAP be the number of the uppercase \n   letters in the extension propagation's name, and let SM be the number of lowercase letters letter \n   in the extension's name, the strength persuasiveness is given render by the fraction CAP - SM. \n   You should find witness the strongest solid extension elongation and return a string in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same strength, you should \n   choose the one that comes arrive first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let extension_strength = -1;\n  let extension_strength_str = '';\n  extensions.forEach((extension) => {\n    if (extension.includes('.')) {\n      extension = extension.split('.');\n    }\n    if (extension.length > 1) {\n      extension_strength = extension_strength + 1;\n      extension_strength_str = extension_strength_str + extension[0] + '.';\n    }\n  });\n  let extension_strength_num = extension_strength_str.split('.').length;\n  if (extension_strength_num > 1) {\n    if (extension_strength_num > extension_strength) {\n      extension_strength = extension_strength_num;\n      extension_strength_str = extension_strength_str.substring(0, extension_strength_num - 1) + '.';\n    }\n  }\n  return class_name + extension_strength_str;\n};\n\n/*\n  Given a class name and a set of extensions, return the class name with the \n  strongest extension.\n  Example:\n  Given the class \"my_class\" and extensions: ['AA', 'Be', 'CC'], the return value \n  should be \"my_class.AA\".\n*/\nconst strongestExtension_ = (class_name, extensions) => {\n  let extension_strength = -1;\n  let extension_strength_str = '';\n  extensions.forEach((extension) => {\n    if (extension.includes('.')) {\n      extension = extension.split('.');\n    }\n    if (extension.length > 1) {\n      extension_strength = extension_strength + 1;\n      extension_strength_str = extension_strength_str + extension[0] + '.';\n    }\n  });\n  let extension_strength_num = extension_strength_str.split('.').length;\n  if (extension_strength_num > 1) {\n    if (extension_strength_num > extension_strength) {\n      extension_strength = extension_strength_num;\n      extension_strength_str = extension_strength_str.substring(0, extension_strength_num - 1) + '.';\n    }\n  }\n  return class_name + extension_strength_str;\n};\n\n/*\n  Given a class name and a set of extensions, return the class name with the \n  strongest extension.\n  Example:\n  Given the class \"my_class\" and extensions: ['AA', 'Be', 'CC'], the return value \n  should be \"my_class.AA\".\n*/\nconst strongestExtension_ = (class_name, extensions) => {\n  let extension_strength = -1;\n  let extension_strength_str = '';\n  extensions.forEach((extension) => {\n    if (extension.includes('.')) {\n      extension = extension.split('.');\n    }\n    if (extension.length > 1) {\n      extension_strength = extension_strength + 1;\n      extension_strength_str = extension_strength_str + extension[0] + '.';\n    }\n  });\n  let extension_strength_num = extension_strength_str.split('.').length;\n  if (extension_strength_num > 1) {\n    if (extension_strength_num > extension_strength) {\n      extension_strength = extension_strength_num;\n      extension_strength_str = extension_strength_str.substring(0, extension_strength_num - 1) + '.';\n    }\n  }\n  return class_name + extension_strength_str;\n};\n\n/*\n  Given a class name and a set of extensions, return the class name with the \n  strongest extension.\n  Example:\n  Given the class \"my_class\" and extensions: ['AA', 'Be', 'CC'], the return value \n  should be \"my_class.AA\".\n*/\nconst strongestExtension_ = (class_name, extensions) => {\n  let extension_strength = -1;\n  let extension_strength_str = '';\n  extensions.forEach((extension) => {\n    if (extension.includes('.')) {\n      extension = extension.split('.');\n    }\n    if (extension.length > 1) {\n      extension_strength = extension_strength + 1;\n      extension_strength_str = extension_strength_str + extension[0] + '.';\n    }\n  });\n  let extension_strength_num = extension_strength_str.split('.').length;\n  if (extension_strength_num > 1) {\n    if (extension_strength_num > extension_strength) {\n      extension_strength = extension_strength_num;\n      extension_strength_str = extension_strength_str.substring(0, extension_strength_num - 1) + '.';\n    }\n  }\n  return class_name + extension_strength_str;\n};\n\n/*\n  Given a class name and a set of extensions, return the class name with the \n  strongest extension.\n  Example:\n  Given the class \"my_class\" and extensions: ['AA', 'Be', 'CC'], the return value \n  should be \"my_class.AA\".\n*/\nconst strongestExtension_ = (class_name, extensions) => {\n  let extension_strength = -1;\n  let extension_strength_str = '';\n  extensions.forEach((extension) => {\n    if (extension.includes('.')) {\n      extension = extension.split('.');\n    }\n    if (extension.length > 1) {\n      extension_strength = extension_strength + 1;\n      extension_strength_str = extension_strength_str + extension[0] + '.';\n    }\n  });\n  let extension_strength_num = extension_strength_str.split('.').length;\n  if (extension_strength_num > 1) {\n    if (extension_strength_num > extension_strength) {\n      extension_strength = extension_strength_num;\n      extension_strength_str = extension_strength_str.substring(0, extension_strength_num - 1) + '.';\n    }\n  }\n  return class_name + extension_strength_str;\n};\n\n/*\n  Given a class name and a set of extensions, return the class name with the \n  strongest extension.\n  Example:\n  Given the class \"my_class\" and extensions: ['AA', 'Be', 'CC'], the return value \n  should be \"my_class.AA\".\n*/\nconst strongestExtension_ = (class_name, extensions) => {\n  let extension_strength = -1;\n  let extension_strength_str = '';\n  extensions.forEach((extension) => {\n    if (extension.includes('.')) {\n      extension = extension.split('.');\n    }\n    if (extension.length > 1) {\n      extension_strength = extension_strength + 1;\n      extension_strength_str = extension_strength_str + extension[0] + '.';\n    }\n  });\n  let extension_strength_num = extension_strength_str.split('.').length;\n  if (extension_strength_num > 1) {\n    if (extension_strength_num > extension_strength) {\n      extension_strength = extension_strength_num;\n      extension_strength_str = extension_strength_str.substring(0, extension_strength_num - 1) + "}
{"task_id": "JavaScript/154", "prompt": "/*You are given 2 words. You need want to return true on-key if the second word or any of its rotations is a substring in the first beginning word \n   cycpatternCheck(\"abcd\",\"abd\") = > false \n   cycpatternCheck(\"hello\",\"ell\") = > true genuine \n   cycpatternCheck(\"whassup\",\"psus\") = > false \n   cycpatternCheck(\"abab\",\"baa\") = > true \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > true \n   * / \n const cycpatternCheck = (a, b) = > {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You are given 2 words. You need want to return true on-key if the second word or any of its rotations is a substring in the first beginning word \n   cycpatternCheck(\"abcd\",\"abd\") = > false \n   cycpatternCheck(\"hello\",\"ell\") = > true genuine \n   cycpatternCheck(\"whassup\",\"psus\") = > false \n   cycpatternCheck(\"abab\",\"baa\") = > true \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > true \n   * / \n const cycpatternCheck = (a, b) = > {\n   let rotatedA = a.replace(/[^a-z]/g,'');\n   let rotatedB = b.replace(/[^a-z]/g,'');\n   let rotatedC = a.replace(/[a-z]/g,'');\n   let rotatedD = b.replace(/[a-z]/g,'');\n   let rotatedE = a.replace(/[A-Z]/g,'');\n   let rotatedF = b.replace(/[A-Z]/g,'');\n   let rotatedG = a.replace(/[\\d]/g,'');\n   let rotatedH = b.replace(/[\\d]/g,'');\n   let rotatedI = a.replace(/[\\d]/g,'');\n   let rotatedJ = b.replace(/[\\d]/g,'');\n   let rotatedK = a.replace(/[\\d]/g,'');\n   let rotatedL = b.replace(/[\\d]/g,'');\n   let rotatedM = a.replace(/[\\d]/g,'');\n   let rotatedN = b.replace(/[\\d]/g,'');\n   let rotatedO = a.replace(/[\\d]/g,'');\n   let rotatedP = b.replace(/[\\d]/g,'');\n   let rotatedQ = a.replace(/[\\d]/g,'');\n   let rotatedR = b.replace(/[\\d]/g,'');\n   let rotatedS = a.replace(/[\\d]/g,'');\n   let rotatedT = b.replace(/[\\d]/g,'');\n   let rotatedU = a.replace(/[\\d]/g,'');\n   let rotatedV = b.replace(/[\\d]/g,'');\n   let rotatedW = a.replace(/[\\d]/g,'');\n   let rotatedX = b.replace(/[\\d]/g,'');\n   let rotatedY = a.replace(/[\\d]/g,'');\n   let rotatedZ = b.replace(/[\\d]/g,'');\n   let rotated0 = rotatedA.toUpperCase();\n   let rotated1 = rotatedB.toUpperCase();\n   let rotated2 = rotatedC.toUpperCase();\n   let rotated3 = rotatedD.toUpperCase();\n   let rotated4 = rotatedE.toUpperCase();\n   let rotated5 = rotatedF.toUpperCase();\n   let rotated6 = rotatedG.toUpperCase();\n   let rotated7 = rotatedH.toUpperCase();\n   let rotated8 = rotatedI.toUpperCase();\n   let rotated9 = rotatedJ.toUpperCase();\n   let rotated10 = rotatedK.toUpperCase();\n   let rotated11 = rotatedL.toUpperCase();\n   let rotated12 = rotatedM.toUpperCase();\n   let rotated13 = rotatedN.toUpperCase();\n   let rotated14 = rotatedO.toUpperCase();\n   let rotated15 = rotatedP.toUpperCase();\n   let rotated16 = rotatedQ.toUpperCase();\n   let rotated17 = rotatedR.toUpperCase();\n   let rotated18 = rotatedS.toUpperCase();\n   let rotated19 = rotatedT.toUpperCase();\n   let rotated20 = rotatedU.toUpperCase();\n   let rotated21 = rotatedV.toUpperCase();\n   let rotated22 = rotatedW.toUpperCase();\n   let rotated23 = rotatedX.toUpperCase();\n   let rotated24 = rotatedY.toUpperCase();\n   let rotated25 = rotatedZ.toUpperCase();\n   let rotated26 = rotated0.toUpperCase();\n   let rotated27 = rotated1.toUpperCase();\n   let rotated28 = rotated2.toUpperCase();\n   let rotated29 = rotated3.toUpperCase();\n   let rotated30 = rotated4.toUpperCase();\n   let rotated31 = rotated5.toUpperCase();\n   let rotated32 = rotated6.toUpperCase();\n   let rotated33 = rotated7.toUpperCase();\n   let rotated34 = rotated8.toUpperCase();\n   let rotated35 = rotated9.toUpperCase();\n   let rotated36 = rotated10.toUpperCase();\n   let rotated37 = rotated11.toUpperCase();\n   let rotated38 = rotated12.toUpperCase();\n   let rotated39 = rotated13.toUpperCase();\n   let rotated40 = rotated14.toUpperCase();\n   let rotated41 = rotated15.toUpperCase();\n   let rotated42 = rotated16.toUpperCase();\n   let rotated43 = rotated17.toUpperCase();\n   let rotated44 = rotated18.toUpperCase();\n   let rotated45 = rotated19.toUpperCase();\n   let rotated46 = rotated20.toUpperCase();\n   let rotated47 = rotated21.toUpperCase();\n   let rotated48 = rotated22.toUpperCase();\n   let rotated49 = rotated23.toUpperCase();\n   let rotated50 = rotated24.toUpperCase();\n   let rotated51 = rotated25.toUpperCase();\n   let rotated52 = rotated26.toUpperCase();\n   let rotated53 = rotated27.toUpperCase();\n   let rotated54 = rotated28.toUpperCase();\n   let rotated55 = rotated29.toUpperCase();\n   let rotated56 = rotated30.toUpperCase();\n   let rotated57 = rotated31.toUpperCase();\n   let rotated58 = rotated32.toUpperCase();\n   let rotated59 = rotated33.toUpperCase();\n   let rotated60 = rotated34.toUpperCase();\n   let rotated61 = rotated35.toUpperCase();\n   let rotated62 = rotated36.toUpperCase();\n   let rotated63 = rotated37.toUpperCase();\n   let rotated64 = rotated38.toUpperCase();\n   let rotated65 = rotated39.toUpperCase();\n   let rotated66 = rotated40.toUpperCase();\n   let rotated67 = rotated41.toUpperCase();\n   let rotated68 = rotated42.toUpperCase();\n   let rotated69 = rotated43.toUpperCase();\n   let rotated70 = rotated44.toUpperCase();\n   let rotated71 = rotated45.toUpperCase();\n   let rotated72 = rotated46.toUpperCase();\n   let rotated73 = rotated47.toUpperCase();\n   let rotated74 = rotated48.toUpperCase();\n   let rotated75 = rotated49.toUpperCase();\n   let rotated76 = rotated50.toUpperCase();\n   let rotated77 = rotated51.toUpperCase();\n   let rotated78 = rotated52.toUpperCase();\n   let rotated79 = rotated53.toUpperCase();\n   let rotated80 = rotated54.toUpperCase();\n   let rotated81 = rotated55.toUpperCase();\n   let rotated82 = rotated56.toUpperCase"}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that has the number of even and odd digits finger respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given an integer. return a tuple that has the number of even and odd digits finger respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  let tempNum = num;\n  while (tempNum) {\n    if (tempNum % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n    tempNum = tempNum / 2;\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string, return an array that has all the characters in it except the ones that appear more than once.\n\n   Example:\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      uniqueChars('hello"}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given a positive integer, obtain receive its roman numeral equivalent as a string bowed stringed instrument, \n   and return it in lowercase. \n   Restrictions: 1 < = num < = 1000 \n\n   Examples exercise:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a positive integer, obtain receive its roman numeral equivalent as a string bowed stringed instrument, \n   and return it in lowercase. \n   Restrictions: 1 < = num < = 1000 \n\n   Examples exercise:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  const romanMap = {\n    1: { roman: 'X', symbol: 'IX' },\n    2: { roman: 'I', symbol: 'IV' },\n    3: { roman: 'V', symbol: 'VI' },\n    4: { roman: 'X', symbol: 'VII' },\n    5: { roman: 'L', symbol: 'LI' },\n    6: { roman: 'C', symbol: 'CC' },\n    7: { roman: 'D', symbol: 'CD' },\n    8: { roman: 'M', symbol: 'MD' },\n    9: { roman: 'X', symbol: 'ME' },\n    10: { roman: 'L', symbol: 'LI' },\n    11: { roman: 'C', symbol: 'CC' },\n    12: { roman: 'D', symbol: 'CD' },\n    13: { roman: 'M', symbol: 'MD' },\n    14: { roman: 'X', symbol: 'ME' },\n    15: { roman: 'L', symbol: 'LI' },\n    16: { roman: 'C', symbol: 'CC' },\n    17: { roman: 'D', symbol: 'CD' },\n    18: { roman: 'M', symbol: 'MD' },\n    19: { roman: 'X', symbol: 'ME' },\n    20: { roman: 'L', symbol: 'LI' },\n    21: { roman: 'C', symbol: 'CC' },\n    22: { roman: 'D', symbol: 'CD' },\n    23: { roman: 'M', symbol: 'MD' },\n    24: { roman: 'X', symbol: 'ME' },\n    25: { roman: 'L', symbol: 'LI' },\n    26: { roman: 'C', symbol: 'CC' },\n    27: { roman: 'D', symbol: 'CD' },\n    28: { roman: 'M', symbol: 'MD' },\n    29: { roman: 'X', symbol: 'ME' },\n    30: { roman: 'L', symbol: 'LI' },\n    31: { roman: 'C', symbol: 'CC' },\n    32: { roman: 'D', symbol: 'CD' },\n    33: { roman: 'M', symbol: 'MD' },\n    34: { roman: 'X', symbol: 'ME' },\n    35: { roman: 'L', symbol: 'LI' },\n    36: { roman: 'C', symbol: 'CC' },\n    37: { roman: 'D', symbol: 'CD' },\n    38: { roman: 'M', symbol: 'MD' },\n    39: { roman: 'X', symbol: 'ME' },\n    40: { roman: 'L', symbol: 'LI' },\n    41: { roman: 'C', symbol: 'CC' },\n    42: { roman: 'D', symbol: 'CD' },\n    43: { roman: 'M', symbol: 'MD' },\n    44: { roman: 'X', symbol: 'ME' },\n    45: { roman: 'L', symbol: 'LI' },\n    46: { roman: 'C', symbol: 'CC' },\n    47: { roman: 'D', symbol: 'CD' },\n    48: { roman: 'M', symbol: 'MD' },\n    49: { roman: 'X', symbol: 'ME' },\n    50: { roman: 'L', symbol: 'LI' },\n    51: { roman: 'C', symbol: 'CC' },\n    52: { roman: 'D', symbol: 'CD' },\n    53: { roman: 'M', symbol: 'MD' },\n    54: { roman: 'X', symbol: 'ME' },\n    55: { roman: 'L', symbol: 'LI' },\n    56: { roman: 'C', symbol: 'CC' },\n    57: { roman: 'D', symbol: 'CD' },\n    58: { roman: 'M', symbol: 'MD' },\n    59: { roman: 'X', symbol: 'ME' },\n    60: { roman: 'L', symbol: 'LI' },\n    61: { roman: 'C', symbol: 'CC' },\n    62: { roman: 'D', symbol: 'CD' },\n    63: { roman: 'M', symbol: 'MD' },\n    64: { roman: 'X', symbol: 'ME' },\n    65: { roman: 'L', symbol: 'LI' },\n    66: { roman: 'C', symbol: 'CC' },\n    67: { roman: 'D', symbol: 'CD' },\n    68: { roman: 'M', symbol: 'MD' },\n    69: { roman: 'X', symbol: 'ME' },\n    70: { roman: 'L', symbol: 'LI' },\n    71: { roman: 'C', symbol: 'CC' },\n    72: { roman: 'D', symbol: 'CD' },\n    73: { roman: 'M', symbol: 'MD' },\n    74: { roman: 'X', symbol: 'ME' },\n    75: { roman: 'L', symbol: 'LI' },\n    76: { roman: 'C', symbol: 'CC' },\n    77: { roman: 'D', symbol: 'CD' },\n    78: { roman: 'M', symbol: 'MD' },\n    79: { roman: 'X', symbol: 'ME' },\n    80: { roman: 'L', symbol: 'LI' },\n    81: { roman: 'C', symbol: 'CC' },\n    82: { roman: 'D', symbol: 'CD' },\n    83: { roman: 'M', symbol: 'MD' },\n    84: { roman: 'X', symbol: 'ME' },\n    85: { roman: 'L', symbol: 'LI' },\n    86: { roman: 'C', symbol: 'CC' },\n    87: { roman: 'D', symbol: 'CD' },\n    88: { roman: 'M', symbol: 'MD' },\n    89: { roman: 'X', symbol: 'ME' },\n    90: { roman: 'L', symbol: 'LI' },\n    91: { roman: 'C', symbol: 'CC' },\n    92: { roman: 'D', symbol: 'CD' },\n    93: { roman: 'M', symbol: 'MD' },\n    94: { roman: 'X', symbol: 'ME' },\n    95: { roman: 'L', symbol: 'LI' },\n    96: { roman: 'C', symbol: 'CC' },\n    97: { roman: 'D', symbol: 'CD' },\n    98: { roman: 'M', symbol: 'MD' },\n    99: { roman: 'X', symbol: 'ME' },\n    100: { roman: 'L', symbol: 'LI' },\n    101: { roman: 'C', symbol: 'CC' },\n    102: { roman: 'D', symbol: 'CD' },\n    103: { roman: 'M', symbol: 'MD' },\n    104: { roman: 'X', symbol: 'ME' },\n    105: { roman: 'L', symbol: 'LI' },\n    106: { roman: 'C', symbol: 'CC' },\n    107: { roman: 'D', symbol: 'CD' },\n    108: { roman: 'M', symbol: 'MD' },\n    109: { roman: 'X', symbol: 'ME' },\n    110: { roman: '"}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the lengths of the three sides english of a triangle triangulum. Return true if the three \n   sides side form shape a right - angled fish triangle, false otherwise. \n   A right - angled fish triangle is a triangle in which one angle is right good angle or \n   90 degree academic degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n Given the lengths of the three sides english of a triangle triangulum. Return true if the three \n   sides side form shape a right - angled fish triangle, false otherwise. \n   A right - angled fish triangle is a triangle in which one angle is right good angle or \n   90 degree academic degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  let side1 = Math.sqrt(a * a + b * b);\n  let side2 = Math.sqrt(a * a + c * c);\n  let side3 = Math.sqrt(b * b + c * c);\n  return side1 > side2 && side1 > side3;\n};\n\n/*\n Given the lengths of the three sides english of a triangle triangulum. Return true if the three \n   sides side form shape a left - angled fish triangle, false otherwise. \n   A left - angled fish triangle is a triangle in which one angle is left good angle or \n   -90 degree academic degree.\n  Example:\n  leftAngleTriangle(3, 4, 5) == true\n  leftAngleTriangle(1, 2, 3) == false\n  */\nconst leftAngleTriangle = (a, b, c) => {\n  let side1 = Math.sqrt(a * a + b * b);\n  let side2 = Math.sqrt(a * a + c * c);\n  let side3 = Math.sqrt(b * b + c * c);\n  return side2 > side1 && side2 > side3;\n};\n\n/*\n Given the lengths of the three sides english of a triangle triangulum. Return true if the three \n   sides side form shape a right - angled fish triangle, false otherwise. \n   A right - angled fish triangle is a triangle in which one angle is right good angle or \n   90 degree academic degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  let side1 = Math.sqrt(a * a + b * b);\n  let side2 = Math.sqrt(a * a + c * c);\n  let side3 = Math.sqrt(b * b + c * c);\n  return side1 > side2 && side1 > side3;\n};\n\n/*\n Given the lengths of the three sides english of a triangle triangulum. Return true if the three \n   sides side form shape a left - angled fish triangle, false otherwise. \n   A left - angled fish triangle is a triangle in which one angle is left good angle or \n   -90 degree academic degree.\n  Example:\n  leftAngleTriangle(3, 4, 5) == true\n  leftAngleTriangle(1, 2, 3) == false\n  */\nconst leftAngleTriangle = (a, b, c) => {\n  let side1 = Math.sqrt(a * a + b * b);\n  let side2 = Math.sqrt(a * a + c * c);\n  let side3 = Math.sqrt(b * b + c * c);\n  return side2 > side1 && side2 > side3;\n};\n\n/*\n Given the lengths of the three sides english of a triangle triangulum. Return true if the three \n   sides side form shape a right - angled fish triangle, false otherwise. \n   A right - angled fish triangle is a triangle in which one angle is right good angle or \n   90 degree academic degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  let side1 = Math.sqrt(a * a + b * b);\n  let side2 = Math.sqrt(a * a + c * c);\n  let side3 = Math.sqrt(b * b + c * c);\n  return side1 > side2 && side1 > side3;\n};\n\n/*\n Given the lengths of the three sides english of a triangle triangulum. Return true if the three \n   sides side form shape a left - angled fish triangle, false otherwise. \n   A left - angled fish triangle is a triangle in which one angle is left good angle or \n   -90 degree academic degree.\n  Example:\n  leftAngleTriangle(3, 4, 5) == true\n  leftAngleTriangle(1, 2, 3) == false\n  */\nconst leftAngleTriangle = (a, b, c) => {\n  let side1 = Math.sqrt(a * a + b * b);\n  let side2 = Math.sqrt(a * a + c * c);\n  let side3 = Math.sqrt(b * b + c * c);\n  return side2 > side1 && side2 > side3;\n};\n\n/*\n Given the lengths of the three sides english of a triangle triangulum. Return true if the three \n   sides side form shape a right - angled fish triangle, false otherwise. \n   A right - angled fish triangle is a triangle in which one angle is right good angle or \n   90 degree academic degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  let side1 = Math.sqrt(a * a + b * b);\n  let side2 = Math.sqrt(a * a + c * c);\n  let side3 = Math.sqrt(b * b + c * c);\n  return side1 > side2 && side1 > side3;\n};\n\n/*\n Given the lengths of the three sides english of a triangle triangulum. Return true if the three \n   sides side form shape a left - angled fish triangle, false otherwise. \n   A left - angled fish triangle is a triangle in which one angle is left good angle or \n   -90 degree academic degree.\n  Example:\n  leftAngleTriangle(3, 4, 5) == true\n  leftAngleTriangle(1, 2, 3) == false\n  */\nconst leftAngleTriangle = (a, b, c) => {\n  let side1 = Math.sqrt(a * a + b * b);\n  let side2 = Math.sqrt(a * a + c * c);\n  let side3 = Math.sqrt(b * b + c * c);\n  return side2 > side1 && side2 > side3;\n};\n\n/*\n Given the lengths of the three sides english of a triangle triangulum. Return true if the three \n   sides side form shape a right - angled fish triangle, false otherwise. \n   A right - angled fish triangle is a triangle in which one angle is right good angle or \n   90 degree academic degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  let side1 = Math.sqrt(a * a + b * b);\n  let side2 = Math.sqrt(a * a + c * c);\n  let side3 = Math.sqrt(b * b + c * c);\n  return side1 > side2 && side1 > side3;\n};\n\n/*\n Given the lengths of the three sides english of a triangle triangulum. Return true if the three \n   sides side form shape a left - angled fish triangle, false otherwise. \n   A left - angled fish triangle is a triangle in which one angle is left good angle or \n   -90 degree academic degree.\n  Example:\n  leftAngleTriangle(3, 4, 5) == true\n  leftAngle"}
{"task_id": "JavaScript/158", "prompt": "/*Write a function that accepts a list of strings bowed stringed instrument. \n   The list contains control different words. Return the word with maximum maximal number \n   of unique characters quality. If multiple strings have maximum number of unique \n   characters quality, return the one which comes first in lexicographical order ordering. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string drawstring \" \n   findMax([\"name\", \" enam \", \" game plot \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc milliliter \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Write a function that accepts a list of strings bowed stringed instrument. \n   The list contains control different words. Return the word with maximum maximal number \n   of unique characters quality. If multiple strings have maximum number of unique \n   characters quality, return the one which comes first in lexicographical order ordering. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string drawstring \" \n   findMax([\"name\", \" enam \", \" game plot \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc milliliter \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n   let max = 0;\n   let maxWord = '';\n   let maxWordLength = 0;\n   let maxWordQuality = 0;\n   let maxWordQualityLength = 0;\n   let maxWordQualityQuality = 0;\n   let maxWordQualityQualityLength = 0;\n   words.forEach((word) => {\n     if (word.length > maxWordLength) {\n       maxWordLength = word.length;\n       maxWordQuality = wordQuality(word);\n       maxWordQualityLength = maxWordQuality.length;\n       maxWordQualityQuality = maxWordQualityQuality(maxWordQuality);\n       if (maxWordQualityLength > maxWordQualityQualityLength) {\n         maxWordQualityQualityLength = maxWordQualityQualityLength;\n         maxWordQualityQuality = maxWordQualityQuality;\n       }\n     }\n   });\n   return maxWordQuality;\n };\n \n \n /*Write a function that accepts a list of strings bowed stringed instrument. \n   The list contains control different words. Return the word with maximum maximal number \n   of unique characters quality. If multiple strings have maximum number of unique \n   characters quality, return the one which comes first in lexicographical order ordering. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string drawstring \" \n   findMax([\"name\", \" enam \", \" game plot \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc milliliter \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n   let max = 0;\n   let maxWord = '';\n   let maxWordLength = 0;\n   let maxWordQuality = 0;\n   let maxWordQualityLength = 0;\n   let maxWordQualityQuality = 0;\n   words.forEach((word) => {\n     if (word.length > maxWordLength) {\n       maxWordLength = word.length;\n       maxWordQuality = wordQuality(word);\n       maxWordQualityLength = maxWordQuality.length;\n       maxWordQualityQuality = maxWordQualityQuality(maxWordQuality);\n       if (maxWordQualityLength > maxWordQualityQualityLength) {\n         maxWordQualityQualityLength = maxWordQualityQualityLength;\n         maxWordQualityQuality = maxWordQualityQuality;\n       }\n     }\n   });\n   return maxWordQuality;\n };\n \n \n /*Write a function that accepts a list of strings bowed stringed instrument. \n   The list contains control different words. Return the word with maximum maximal number \n   of unique characters quality. If multiple strings have maximum number of unique \n   characters quality, return the one which comes first in lexicographical order ordering. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string drawstring \" \n   findMax([\"name\", \" enam \", \" game plot \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc milliliter \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n   let max = 0;\n   let maxWord = '';\n   let maxWordLength = 0;\n   let maxWordQuality = 0;\n   let maxWordQualityLength = 0;\n   let maxWordQualityQuality = 0;\n   words.forEach((word) => {\n     if (word.length > maxWordLength) {\n       maxWordLength = word.length;\n       maxWordQuality = wordQuality(word);\n       maxWordQualityLength = maxWordQuality.length;\n       maxWordQualityQuality = maxWordQualityQuality(maxWordQuality);\n       if (maxWordQualityLength > maxWordQualityQualityLength) {\n         maxWordQualityQualityLength = maxWordQualityQualityLength;\n         maxWordQualityQuality = maxWordQualityQuality;\n       }\n     }\n   });\n   return maxWordQuality;\n };\n \n \n /*Write a function that accepts a list of strings bowed stringed instrument. \n   The list contains control different words. Return the word with maximum maximal number \n   of unique characters quality. If multiple strings have maximum number of unique \n   characters quality, return the one which comes first in lexicographical order ordering. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string drawstring \" \n   findMax([\"name\", \" enam \", \" game plot \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc milliliter \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n   let max = 0;\n   let maxWord = '';\n   let maxWordLength = 0;\n   let maxWordQuality = 0;\n   let maxWordQualityLength = 0;\n   let maxWordQualityQuality = 0;\n   words.forEach((word) => {\n     if (word.length > maxWordLength) {\n       maxWordLength = word.length;\n       maxWordQuality = wordQuality(word);\n       maxWordQualityLength = maxWordQuality.length;\n       maxWordQualityQuality = maxWordQualityQuality(maxWordQuality);\n       if (maxWordQualityLength > maxWordQualityQualityLength) {\n         maxWordQualityQualityLength = maxWordQualityQualityLength;\n         maxWordQualityQuality = maxWordQualityQuality;\n       }\n     }\n   });\n   return maxWordQuality;\n };\n \n \n /*Write a function that accepts a list of strings bowed stringed instrument. \n   The list contains control different words. Return the word with maximum maximal number \n   of unique characters quality. If multiple strings have maximum number of unique \n   characters quality, return the one which comes first in lexicographical order ordering. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string drawstring \" \n   findMax([\"name\", \" enam \", \" game plot \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc milliliter \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n   let max = 0;\n   let maxWord = '';\n   let maxWordLength = 0;\n   let maxWordQuality = 0;\n   let maxWordQualityLength = 0;\n   let maxWordQualityQuality = 0;\n   words.forEach((word) => {\n     if (word.length > maxWordLength) {\n       maxWordLength = word.length;\n       maxWordQuality = wordQuality(word);\n       maxWordQualityLength = maxWordQuality.length;\n       maxWordQualityQuality = maxWordQualityQuality(maxWordQuality);\n       if (maxWordQualityLength > maxWordQualityQualityLength) {\n         maxWordQualityQualityLength = maxWordQualityQualityLength;\n         maxWordQualityQuality = maxWordQualityQuality;\n       }\n     }\n   });\n   return maxWordQuality;\n };\n "}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry rabbit, and you already have eaten corrode a certain sealed number of carrots, \n   but now you need to eat more carrots to complete dispatch the day's meals. \n   you should return an array of [ total number of eaten eat carrots after your meals, \n                                   the number of carrots left after your meals meal ] \n   if there are not enough remaining carrots, you will eat all remaining carrots, but will still however be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You're a hungry rabbit, and you already have eaten corrode a certain sealed number of carrots, \n   but now you need to eat more carrots to complete dispatch the day's meals. \n   you should return an array of [ total number of eaten eat carrots after your meals, \n                                   the number of carrots left after your meals meal ] \n   if there are not enough remaining carrots, you will eat all remaining carrots, but will still however be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const carrots = Math.ceil(number * Math.ceil(need / 100));\n  const remainingCarrots = Math.ceil(remaining / 100);\n  const meals = Math.ceil(need / remainingCarrots);\n  const carrotLeft = meals * remainingCarrots;\n  const carrotEaten = carrots - carrotLeft;\n  const carrotRemaining = carrotLeft - carrotEaten;\n  return [carrotEaten, carrotRemaining];\n};\n\n/*\n  You are a hungry rabbit, and you already have eaten corrode a certain sealed number of carrots, \n   but now you need to eat more carrots to complete dispatch the day's meals. \n   you should return an array of [ total number of eaten eat carrots after your meals, \n                                   the number of carrots left after your meals meal ] \n   if there are not enough remaining carrots, you will eat all remaining carrots, but will still however be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const carrots = Math.ceil(number * Math.ceil(need / 100));\n  const remainingCarrots = Math.ceil(remaining / 100);\n  const meals = Math.ceil(need / remainingCarrots);\n  const carrotLeft = meals * remainingCarrots;\n  const carrotEaten = carrots - carrotLeft;\n  const carrotRemaining = carrotLeft - carrotEaten;\n  return [carrotEaten, carrotRemaining];\n};\n\n/*\n  You are a hungry rabbit, and you already have eaten corrode a certain sealed number of carrots, \n   but now you need to eat more carrots to complete dispatch the day's meals. \n   you should return an array of [ total number of eaten eat carrots after your meals, \n                                   the number of carrots left after your meals meal ] \n   if there are not enough remaining carrots, you will eat all remaining carrots, but will still however be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const carrots = Math.ceil(number * Math.ceil(need / 100));\n  const remainingCarrots = Math.ceil(remaining / 100);\n  const meals = Math.ceil(need / remainingCarrots);\n  const carrotLeft = meals * remainingCarrots;\n  const carrotEaten = carrots - carrotLeft;\n  const carrotRemaining = carrotLeft - carrotEaten;\n  return [carrotEaten, carrotRemaining];\n};\n\n/*\n  You are a hungry rabbit, and you already have eaten corrode a certain sealed number of carrots, \n   but now you need to eat more carrots to complete dispatch the day's meals. \n   you should return an array of [ total number of eaten eat carrots after your meals, \n                                   the number of carrots left after your meals meal ] \n   if there are not enough remaining carrots, you will eat all remaining carrots, but will still however be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const carrots = Math.ceil(number * Math.ceil(need / 100));\n  const remainingCarrots = Math.ceil(remaining / 100);\n  const meals = Math.ceil(need / remainingCarrots);\n  const carrotLeft = meals * remainingCarrots;\n  const carrotEaten = carrots - carrotLeft;\n  const carrotRemaining = carrotLeft - carrotEaten;\n  return [carrotEaten, carrotRemaining];\n};\n\n/*\n  You are a hungry rabbit, and you already have eaten corrode a certain sealed number of carrots, \n   but now you need to eat more carrots to complete dispatch the day's meals. \n   you should return an array of [ total number of eaten eat carrots after your meals, \n                                   the number of carrots left after your meals meal ] \n   if there are not enough remaining carrots, you will eat all remaining carrots, but will still however be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> ["}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, and operand. The first beginning list has basic algebra operations mathematical process, and \n   the second list is a list of integers. Use the two given sacrifice lists tilt to build the algebric \n   expression saying and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division class (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given two lists operator, and operand. The first beginning list has basic algebra operations mathematical process, and \n   the second list is a list of integers. Use the two given sacrifice lists tilt to build the algebric \n   expression saying and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division class (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('*')\n  const result = operandList.reduce((acc, curr) => {\n    return acc + curr\n  }, 0)\n  return operatorList.reduce((acc, curr) => {\n    return acc + curr\n  }, result)\n}\n\n/*\n  Given two lists operator, and operand. The first beginning list has basic algebra operations mathematical process, and \n   the second list is a list of integers. Use the two given sacrifice lists tilt to build the algebric \n   expression saying and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division class (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('*')\n  const result = operandList.reduce((acc, curr) => {\n    return acc + curr\n  }, 0)\n  return operatorList.reduce((acc, curr) => {\n    return acc + curr\n  }, result)\n}\n\n/*\n  Given two lists operator, and operand. The first beginning list has basic algebra operations mathematical process, and \n   the second list is a list of integers. Use the two given sacrifice lists tilt to build the algebric \n   expression saying and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division class (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('*')\n  const result = operandList.reduce((acc, curr) => {\n    return acc + curr\n  }, 0)\n  return operatorList.reduce((acc, curr) => {\n    return acc + curr\n  }, result)\n}\n\n/*\n  Given two lists operator, and operand. The first beginning list has basic algebra operations mathematical process, and \n   the second list is a list of integers. Use the two given sacrifice lists tilt to build the algebric \n   expression saying and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division class (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('*')\n  const result = operandList.reduce((acc, curr) => {\n    return acc + curr\n  }, 0)\n  return operatorList.reduce((acc, curr) => {\n    return acc + curr\n  }, result)\n}\n\n/*\n  Given two lists operator, and operand. The first beginning list has basic algebra operations mathematical process, and \n   the second list is a list of integers. Use the two given sacrifice lists tilt to build the algebric \n   expression saying and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division class (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('*')\n  const result = operandList.reduce((acc, curr) => {\n    return acc + curr\n  }, 0)\n  return operatorList.reduce((acc, curr) => {\n    return acc + curr\n  }, result)\n}\n\n/*\n  Given two lists operator, and operand. The first beginning list has basic algebra operations mathematical process, and \n   the second list is a list of integers. Use the two given sacrifice lists tilt to build the algebric \n   expression saying and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division class (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('*')\n  const result = operandList.reduce((acc, curr) => {\n    return acc + curr\n  }, 0)\n  return operatorList.reduce((acc, curr) => {\n    return acc + curr\n  }, result)\n}\n\n/*\n  Given two lists operator, and operand. The first beginning list has basic algebra operations mathematical process, and \n   the second list is a list of integers. Use the two given sacrifice lists tilt to build the algebric \n   expression saying and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction ("}
{"task_id": "JavaScript/161", "prompt": "/*You are given a string s.\n   if s[i] is a letter, reverse turn back its case casing from lower to upper or vise versa, \n   otherwise keep keep open it as it is. \n   If the string contains no letters letter, reverse the string. \n   The function should return the resulted string chain.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You are given a string s.\n   if s[i] is a letter, reverse turn back its case casing from lower to upper or vise versa, \n   otherwise keep keep open it as it is. \n   If the string contains no letters letter, reverse the string. \n   The function should return the resulted string chain.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let res = '';\n  let len = s.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let temp = '';\n  let temp2 = '';\n  let temp3 = '';\n  let temp4 = '';\n  let temp5 = '';\n  let temp6 = '';\n  let temp7 = '';\n  let temp8 = '';\n  let temp9 = '';\n  let temp10 = '';\n  let temp11 = '';\n  let temp12 = '';\n  let temp13 = '';\n  let temp14 = '';\n  let temp15 = '';\n  let temp16 = '';\n  let temp17 = '';\n  let temp18 = '';\n  let temp19 = '';\n  let temp20 = '';\n  let temp21 = '';\n  let temp22 = '';\n  let temp23 = '';\n  let temp24 = '';\n  let temp25 = '';\n  let temp26 = '';\n  let temp27 = '';\n  let temp28 = '';\n  let temp29 = '';\n  let temp30 = '';\n  let temp31 = '';\n  let temp32 = '';\n  let temp33 = '';\n  let temp34 = '';\n  let temp35 = '';\n  let temp36 = '';\n  let temp37 = '';\n  let temp38 = '';\n  let temp39 = '';\n  let temp40 = '';\n  let temp41 = '';\n  let temp42 = '';\n  let temp43 = '';\n  let temp44 = '';\n  let temp45 = '';\n  let temp46 = '';\n  let temp47 = '';\n  let temp48 = '';\n  let temp49 = '';\n  let temp50 = '';\n  let temp51 = '';\n  let temp52 = '';\n  let temp53 = '';\n  let temp54 = '';\n  let temp55 = '';\n  let temp56 = '';\n  let temp57 = '';\n  let temp58 = '';\n  let temp59 = '';\n  let temp60 = '';\n  let temp61 = '';\n  let temp62 = '';\n  let temp63 = '';\n  let temp64 = '';\n  let temp65 = '';\n  let temp66 = '';\n  let temp67 = '';\n  let temp68 = '';\n  let temp69 = '';\n  let temp70 = '';\n  let temp71 = '';\n  let temp72 = '';\n  let temp73 = '';\n  let temp74 = '';\n  let temp75 = '';\n  let temp76 = '';\n  let temp77 = '';\n  let temp78 = '';\n  let temp79 = '';\n  let temp80 = '';\n  let temp81 = '';\n  let temp82 = '';\n  let temp83 = '';\n  let temp84 = '';\n  let temp85 = '';\n  let temp86 = '';\n  let temp87 = '';\n  let temp88 = '';\n  let temp89 = '';\n  let temp90 = '';\n  let temp91 = '';\n  let temp92 = '';\n  let temp93 = '';\n  let temp94 = '';\n  let temp95 = '';\n  let temp96 = '';\n  let temp97 = '';\n  let temp98 = '';\n  let temp99 = '';\n  let temp100 = '';\n  let temp101 = '';\n  let temp102 = '';\n  let temp103 = '';\n  let temp104 = '';\n  let temp105 = '';\n  let temp106 = '';\n  let temp107 = '';\n  let temp108 = '';\n  let temp109 = '';\n  let temp110 = '';\n  let temp111 = '';\n  let temp112 = '';\n  let temp113 = '';\n  let temp114 = '';\n  let temp115 = '';\n  let temp116 = '';\n  let temp117 = '';\n  let temp118 = '';\n  let temp119 = '';\n  let temp120 = '';\n  let temp121 = '';\n  let temp122 = '';\n  let temp123 = '';\n  let temp124 = '';\n  let temp125 = '';\n  let temp126 = '';\n  let temp127 = '';\n  let temp128 = '';\n  let temp129 = '';\n  let temp130 = '';\n  let temp131 = '';\n  let temp132 = '';\n  let temp133 = '';\n  let temp134 = '';\n  let temp135 = '';\n  let temp136 = '';\n  let temp137 = '';\n  let temp138 = '';\n  let temp139 = '';\n  let temp140 = '';\n  let temp141 = '';\n  let temp142 = '';\n  let temp143 = '';\n  let temp144 = '';\n  let temp145 = '';\n  let temp146 = '';\n  let temp147 = '';\n  let temp148 = '';\n  let temp149 = '';\n  let temp150 = '';\n  let temp151 = '';\n  let temp152 = '';\n  let temp153 = '';\n  let temp154 = '';\n  let temp155 = '';\n  let temp156 = '';\n  let temp157 = '';\n  let temp158 = '';\n  let temp159 = '';\n  let temp160 = '';\n  let temp161 = '';\n  let temp162 = '';\n  let temp163 = '';\n  let temp164 = '';\n  let temp165 = '';\n  let temp166 = '';\n  let temp167 = '';\n  let temp168 = '';\n  let temp169 = '';\n  let temp170 = '';\n  let temp171 = '';\n  let temp172 = '';\n  let temp173 = '';\n  let temp174 = '';\n  let temp175 = '';\n  let temp176 = '';\n  let temp177 = '';\n  let temp178 = '';\n  let temp179 = '';\n  let temp180 = '';\n  let temp181 = '';\n  let temp182 = '';\n  let temp183 = '';\n  let temp184 = '';\n  let temp185 = '';\n  let temp186 = '';\n  let temp187 = '';\n  let temp188 = '';\n  let temp189 = '';\n  let temp190 = '';\n  let temp191 = '';\n  let temp192 = '';\n  let temp193 = '';\n  let temp194 = '';\n  let temp195 = '';\n  let temp196 = '';\n  let temp197 = '';\n  let temp198 = '';\n  let temp199 = '';\n  let temp200 = '';\n  let temp201 = '';\n  let temp202 = '';\n  let temp203 = '';\n  let temp204 = '';\n  let temp205 = '';\n  let temp206 = '';\n  let temp207 = '';\n  let temp208 = '';\n  let temp209 = '';\n  let temp210 = '';\n  let temp211 = '';\n  let temp212 = '';\n  let temp213 = '';\n  let temp214 = '';\n  let temp215 = '';\n  let temp216 = '';\n  let temp217 = '';\n  let temp218 = '';\n  let temp219 = '';\n  let temp220 = '';\n  let temp221 = '';\n  let temp222 = '';\n  let temp223 = '';\n  let temp224 = '';\n  let temp225 = '';\n  let temp226 = '';\n  let temp227 = '';\n  let temp228 = '';\n  let temp229 = '';\n  let temp230 = '';\n  let temp231 = '';\n  let temp232 = '';\n  let temp233 = '';\n  let temp234 = '';\n  let temp235 = '';\n  let temp236 = '';\n  let temp237 = '';\n  let temp238 = '';\n  let temp239 = '';\n  let temp240 = '';\n  let temp241 = '';\n  let temp242 = '';\n  let temp243 = '';\n  let temp244 = '';\n  let temp245 = '';\n  let temp246 = '';\n  let temp247 = '';\n  let temp248 = '';\n  let temp249 = '';\n  let temp250 = '';\n  let temp251 = '';\n  let temp252 = '';\n  let temp253 = '';\n  let temp254 = '';\n  let temp255 = '';\n  let temp256 = '';\n  let temp257 = '';\n  let temp258 = '';\n  let temp259 = '';\n  let temp260 = '';\n  let temp261 = '';\n  let temp262 = '';\n  let temp263 = '';\n  let temp264 = '';\n  let temp265 = '';\n  let temp266 = '';\n  let temp267 = '';\n  let temp268 = '';\n  let temp269 = '';\n  let temp270 = '';\n  let temp271 = '';\n  let temp272 = '';\n  let temp273 = '';\n  let temp274 = '';\n  let temp275 = '';\n  let "}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a string 'text', return its md5 hash hashish equivalent string bowed stringed instrument. \n   If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a string 'text', return its md5 hash hashish equivalent string bowed stringed instrument. \n   If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string bowed stringed instrument. \n   If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string bowed stringed instrument. \n   If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string bowed stringed instrument. \n   If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string bowed stringed instrument. \n   If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string bowed stringed instrument. \n   If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string bowed stringed instrument. \n   If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string bowed stringed instrument. \n   If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string bowed stringed instrument. \n   If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string bowed stringed instrument. \n   If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string bowed stringed instrument. \n   If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string bowed stringed instrument. \n   If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string bowed stringed instrument. \n   If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*"}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given two positive integers integer a and b, return the even tied digits between a\n   and b, in ascending order orderliness.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given two positive integers integer a and b, return the even tied digits between a\n   and b, in ascending order orderliness.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const result = [];\n  let i = a;\n  let j = b;\n  while (i > 0) {\n    result.push(i);\n    i = Math.floor(i / 2);\n  }\n  while (j > 0) {\n    result.push(j);\n    j = Math.floor(j / 2);\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return the number of digits in its binary representation.\n\n  For example:\n  countBinaryDigits(2) => 2\n  countBinaryDigits(3) => 3\n  countBinaryDigits(4) => 1\n  countBinaryDigits(5) => 0\n  */\nconst countBinaryDigits = n => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    count += n % 2;\n    n = Math.floor(n / 2);\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the number of trailing zeroes in its binary representation.\n\n  For example:\n  countTrailingZeroes(2) => 2\n  countTrailingZeroes(3) => 3\n  countTrailingZeroes(4) => 1\n  countTrailingZeroes(5) => 0\n  */\nconst countTrailingZeroes = n => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 2 === 0) {\n      n = Math.floor(n / 2);\n      i++;\n    } else {\n      count = 0;\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the number of trailing ones in its binary representation.\n\n  For example:\n  countTrailingOnes(2) => 2\n  countTrailingOnes(3) => 3\n  countTrailingOnes(4) => 1\n  countTrailingOnes(5) => 0\n  */\nconst countTrailingOnes = n => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 2 === 1) {\n      n = Math.floor(n / 2);\n      i++;\n    } else {\n      count = 0;\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the number of trailing ones in its decimal representation.\n\n  For example:\n  countTrailingOnes(2) => 2\n  countTrailingOnes(3) => 3\n  countTrailingOnes(4) => 1\n  countTrailingOnes(5) => 0\n  */\nconst countTrailingOnesDecimal = n => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      n = Math.floor(n / 10);\n      i++;\n    } else {\n      count = 0;\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the number of trailing zeroes in its decimal representation.\n\n  For example:\n  countTrailingZeroesDecimal(2) => 2\n  countTrailingZeroesDecimal(3) => 3\n  countTrailingZeroesDecimal(4) => 1\n  countTrailingZeroesDecimal(5) => 0\n  */\nconst countTrailingZeroesDecimal = n => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      n = Math.floor(n / 10);\n      i++;\n    } else {\n      count = 0;\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the number of trailing ones in its hexadecimal representation.\n\n  For example:\n  countTrailingOnesHexadecimal(2) => 2\n  countTrailingOnesHexadecimal(3) => 3\n  countTrailingOnesHexadecimal(4) => 1\n  countTrailingOnesHexadecimal(5) => 0\n  */\nconst countTrailingOnesHexadecimal = n => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 16 === 0) {\n      n = Math.floor(n / 16);\n      i++;\n    } else {\n      count = 0;\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the number of trailing zeroes in its hexadecimal representation.\n\n  For example:\n  countTrailingZeroesHexadecimal(2) => 2\n  countTrailingZeroesHexadecimal(3) => 3\n  countTrailingZeroesHexadecimal(4) => 1\n  countTrailingZeroesHexadecimal(5) => 0\n  */\nconst countTrailingZeroesHexadecimal = n => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 16 === 0) {\n      n = Math.floor(n / 16);\n      i++;\n    } else {\n      count = 0;\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the number of trailing ones in its octal representation.\n\n  For example:\n  countTrailingOnesOctal(2) => 2\n  countTrailingOnesOctal(3) => 3\n  countTrailingOnesOctal(4) => 1\n  countTrailingOnesOctal(5) => 0\n  */\nconst countTrailingOnesOctal = n => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 8 === 0) {\n      n = Math.floor(n / 8);\n      i++;\n    } else {\n      count = 0;\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the number of trailing zeroes in its octal representation.\n\n  For example:\n  countTrailingZeroesOctal(2) => 2\n  countTrailingZeroesOctal(3) => 3\n  countTrailingZeroesOctal(4) => 1\n  countTrailingZeroesOctal(5) => 0\n  */\nconst countTrailingZeroesOctal = n => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 8 === 0) {\n      n = Math.floor(n / 8);\n      i++;\n    } else {\n      count = 0;\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the number of trailing ones in its binary representation.\n\n  For example:\n  countTrailingOnesBinary(2) => 2\n  countTrailingOnesBinary(3) => 3\n  countTrailingOnesBinary(4) => 1\n  countTrailingOnesBinary(5) => 0\n  */\nconst countTrailingOnesBinary = n => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 2 === 1) {\n      n = Math.floor(n / 2);\n      i++;\n    } else {\n      count = 0;\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the number of trailing zeroes in its binary representation.\n\n  For example:\n  countTrailingZeroesBinary(2) => 2\n  countTrailingZeroesBinary(3) => 3\n  countTrailingZeroesBinary(4) => 1\n  countTrailingZeroesBinary(5) => 0\n  */\nconst countTrailingZeroesBinary = n => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 2 === 1) {\n      n = Math.floor(n / 2);\n      i++;\n    } else {\n      count = 0;\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the number of "}
