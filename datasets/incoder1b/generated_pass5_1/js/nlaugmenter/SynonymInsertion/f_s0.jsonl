{"task_id": "JavaScript/0", "prompt": "/* Check if in given list of numbers, are any two numbers closer near to each other than \n   given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Check if in given list of numbers, are any two numbers closer near to each other than \n   given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const closest = numbers.reduce((prev, curr) => {\n    const diff = Math.abs(curr - prev);\n    return diff < threshold? curr : prev;\n  }, Number.POSITIVE_INFINITY);\n  return closest!== Number.POSITIVE_INFINITY;\n};\n\nmodule.exports = hasCloseElements;\n\n},{}],18:[function(require,module,exports){\nconst hasCloseElements = require('./hasCloseElements');\n\n/**\n * Check if given list of numbers, are any two numbers closer than given threshold.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within given threshold of eachother.\n * \n * If two numbers are closer than given threshold, they are considered as close to each other \n * and are considered as close to each other if they are within ", "passed": 0}
{"task_id": "JavaScript/1", "prompt": "/* Input to this function is a string bowed stringed instrument containing multiple groups group of nested parentheses parenthesis. Your goal is to \n   separate freestanding those group into separate strings string and return the list of those. \n   Separate groups are balanced (each open brace couple is properly closed) and not nested nest within each other \n   Ignore dismiss any spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Input to this function is a string bowed stringed instrument containing multiple groups group of nested parentheses parenthesis. Your goal is to \n   separate freestanding those group into separate strings string and return the list of those. \n   Separate groups are balanced (each open brace couple is properly closed) and not nested nest within each other \n   Ignore dismiss any spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]*)\\)/).map(x => x.replace(/\\)/g, '').split('('));\n  const strings = [];\n  for (let i = 0; i < paren_groups.length; i++) {\n    const group = paren_groups[i];\n    const group_strings = [];\n    for (let j = 0; j < group.length; j++) {\n      const char = group[j];\n      if (char === '(') {\n        group_strings.push(group_strings.length);\n      } else if (char === ')') {\n        group_strings.pop();\n      }\n    }\n    strings.push(group_strings.join(''));\n  }\n  return strings;\n};\n\n/**\n * Given a string, return the first non-whitespace character in the string.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no non-whitespace character is found, return -1.\n * If no ", "passed": 0}
{"task_id": "JavaScript/10", "prompt": "/* Test if gniven strig is a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find the shortest brusque palindrome that begins with a supplied supply string.\n   Algorithm idea is simple dim-witted: \n   - Find the longest retentive postfix of supplied provide string that is a palindrome. \n   - Append to the end goal of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Test if gniven strig is a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find the shortest brusque palindrome that begins with a supplied supply string.\n   Algorithm idea is simple dim-witted: \n   - Find the longest retentive postfix of supplied provide string that is a palindrome. \n   - Append to the end goal of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const retentivePostfix = string.split('').reverse().join('');\n  const prefix = retentivePostfix.split('').slice(0, -1).join('');\n  const suffix = retentivePostfix.split('').reverse().join('');\n  return `${prefix}${suffix}`;\n}\n\n/* Test if given string is a palindrome * / \nconst isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find the shortest brusque palindrome that begins with a supplied supply string.\n   Algorithm idea is simple dim-witted: \n   - Find the longest retentive postfix of supplied provide string that is a palindrome. \n   - Append to the end goal of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const retentivePostfix = string.split('').reverse().join('');\n  const prefix = retentivePostfix.split('').slice(0, -1).join('');\n  const suffix = retentivePostfix.split('').reverse().join('');\n  return `${prefix}${suffix}`;\n}\n\n/* Test if given string is a palindrome * / \nconst isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find the shortest brusque palindrome that begins with a supplied supply string.\n   Algorithm idea is simple dim-witted: \n   - Find the longest retentive postfix of supplied provide string that is a palindrome. \n   - Append to the end goal of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const retentivePostfix = string.split('').reverse().join('');\n  const prefix = retentivePostfix.split('').slice(0, -1).join('');\n  const suffix = retentivePostfix.split('').reverse().join('');\n  return `${prefix}${suffix}`;\n}\n\n/* Test if given string is a palindrome * / \nconst isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find the shortest brusque palindrome that begins with a supplied supply string.\n   Algorithm idea is simple dim-witted: \n   - Find the longest retentive postfix of supplied provide string that is a palindrome. \n   - Append to the end goal of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const retentivePostfix = string.split('').reverse().join('');\n  const prefix = retentivePostfix.split('').slice(0, -1).join('');\n  const suffix = retentivePostfix.split('').reverse().join('');\n  return `${prefix}${suffix}`;\n}\n\n/* Test if given string is a palindrome * / \nconst isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find the shortest brusque palindrome that begins with a supplied supply string.\n   Algorithm idea is simple dim-witted: \n   - Find the longest retentive postfix of supplied provide string that is a palindrome. \n   - Append to the end goal of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const retentivePostfix = string.split('').reverse().join('');\n  const prefix = retentivePostfix.split('').slice(0, -1).join('');\n  const suffix = retentivePostfix.split('').reverse().join('');\n  return `${prefix}${suffix}`;\n}\n\n/* Test if given string is a palindrome * / \nconst isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find the shortest brusque palindrome that begins with a supplied supply string.\n   Algorithm idea is simple dim-witted: \n   - Find the longest retentive postfix of supplied provide string that is a palindrome. \n   - Append to the end goal of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const retentivePostfix = string.split('').reverse().join('');\n  const prefix = retentivePostfix.split('').slice(0, -1).join('');\n  const suffix = retentivePostfix.split('').reverse().join('');\n  return `${prefix}${suffix}`;\n}\n\n/* Test if given string is a palindrome * / \nconst isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find the shortest brusque palindrome that begins with a supplied supply string.\n   Algorithm idea is simple dim-witted: \n   - Find the longest retentive postfix of supplied provide string that is a palindrome. \n   - Append to the end goal of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {", "passed": 0}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a positive integer n, you have to make take a pile of n levels floor of stones. \n   The first inaugural level has n stones rock. \n   The number of stones gem in the next level is: \n       - the next odd leftover number if n is odd. \n       - the next adjacent even tied number if n is even. \n   Return the number of stones in each level floor in a list, where element chemical element at index exponent \n   i represents the number of stones in the level (i+1).\n\n   Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a positive integer n, you have to make take a pile of n levels floor of stones. \n   The first inaugural level has n stones rock. \n   The number of stones gem in the next level is: \n       - the next odd leftover number if n is odd. \n       - the next adjacent even tied number if n is even. \n   Return the number of stones in each level floor in a list, where element chemical element at index exponent \n   i represents the number of stones in the level (i+1).\n\n   Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let levels = [];\n  let level = 0;\n  let levelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevel = 0;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;\n  let nextLevelSize = 1;", "passed": 0}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given a string of words word separated by commas comma or spaces. Your task undertaking is \n   to split the string chain into words and return an array of the words parole.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You will be given a string of words word separated by commas comma or spaces. Your task undertaking is \n   to split the string chain into words and return an array of the words parole.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(',');\n  let result = [];\n  words.forEach((word) => {\n    word = word.trim();\n    if (word.length > 0) {\n      result.push(word);\n    }\n  });\n  return result;\n};\n\n/*\n  You will be given a string of words word separated by commas comma or spaces. Your task undertaking is \n   to split the string chain into words and return an array of the words parole.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(',');\n  let result = [];\n  words.forEach((word) => {\n    word = word.trim();\n    if (word.length > 0) {\n      result.push(word);\n    }\n  });\n  return result;\n};\n\n/*\n  You will be given a string of words word separated by commas comma or spaces. Your task undertaking is \n   to split the string chain into words and return an array of the words parole.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(',');\n  let result = [];\n  words.forEach((word) => {\n    word = word.trim();\n    if (word.length > 0) {\n      result.push(word);\n    }\n  });\n  return result;\n};\n\n/*\n  You will be given a string of words word separated by commas comma or spaces. Your task undertaking is \n   to split the string chain into words and return an array of the words parole.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(',');\n  let result = [];\n  words.forEach((word) => {\n    word = word.trim();\n    if (word.length > 0) {\n      result.push(word);\n    }\n  });\n  return result;\n};\n\n/*\n  You will be given a string of words word separated by commas comma or spaces. Your task undertaking is \n   to split the string chain into words and return an array of the words parole.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(',');\n  let result = [];\n  words.forEach((word) => {\n    word = word.trim();\n    if (word.length > 0) {\n      result.push(word);\n    }\n  });\n  return result;\n};\n\n/*\n  You will be given a string of words word separated by commas comma or spaces. Your task undertaking is \n   to split the string chain into words and return an array of the words parole.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(',');\n  let result = [];\n  words.forEach((word) => {\n    word = word.trim();\n    if (word.length > 0) {\n      result.push(word);\n    }\n  });\n  return result;\n};\n\n/*\n  You will be given a string of words word separated by commas comma or spaces. Your task undertaking is \n   to split the string chain into words and return an array of the words parole.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(',');\n  let result = [];\n  words.forEach((word) => {\n    word = word.trim();\n    if (word.length > 0) {\n      result.push(word);\n    }\n  });\n  return result;\n};\n\n/*\n  You will be given a string of words word separated by commas comma or spaces. Your task undertaking is \n   to split the string chain into words and return an array of the words parole.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(',');\n  let result = [];\n  words.forEach((word) => {\n    word = word.trim();\n    if (word.length > 0) {\n      result.push(word);\n    }\n  });\n  return result;\n};\n\n/*\n  You will be given a string of words word separated by commas comma or spaces. Your task undertaking is \n   to split the string chain into words and return an array of the words parole.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(',');\n  let result = [];\n  words.forEach((word) => {\n    word = word.trim();\n    if (word.length > 0) {\n      result.push(word);\n    }\n  });\n  return result;\n};\n\n/*\n  You will be given a string of words word separated by commas comma or spaces. Your task undertaking is \n   to split the string chain into words and return an array of the words parole.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(',');\n  let result = [];\n  words.forEach((word) => {\n    word = word.trim();\n    if (word.length > 0) {\n      result.push(word);\n    }\n  });\n  return result;\n};\n\n/*\n  You will be given a string of words word separated by commas comma or spaces. Your task undertaking is \n   to split the string chain into words and return an array of the words parole.\n  \n  For example:", "passed": 0}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two positive convinced numbers x and y and returns return the \n   biggest even integer number issue that is in the range [x, y] inclusive. If \n   there's no such number phone number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*This function takes two positive convinced numbers x and y and returns return the \n   biggest even integer number issue that is in the range [x, y] inclusive. If \n   there's no such number phone number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let num;\n  if (x < y) {\n    num = x;\n  } else {\n    num = y;\n  }\n  let count = 0;\n  let max = 0;\n  let even = 0;\n  while (num >= 0) {\n    if (num % 2 === 0) {\n      even++;\n    }\n    if (even > max) {\n      max = even;\n    }\n    num = Math.floor(num / 2);\n    count++;\n  }\n  return max;\n};\n\n/*This function takes two positive convinced numbers x and y and returns return the \n   biggest odd integer number issue that is in the range [x, y] inclusive. If \n   there's no such number phone number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let num;\n  if (x < y) {\n    num = x;\n  } else {\n    num = y;\n  }\n  let count = 0;\n  let max = 0;\n  let even = 0;\n  while (num >= 0) {\n    if (num % 2 === 0) {\n      even++;\n    }\n    if (even > max) {\n      max = even;\n    }\n    num = Math.floor(num / 2);\n    count++;\n  }\n  return max;\n};\n\n/*This function takes two positive convinced numbers x and y and returns return the \n   biggest integer number issue that is in the range [x, y] inclusive. If \n   there's no such number phone number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let num;\n  if (x < y) {\n    num = x;\n  } else {\n    num = y;\n  }\n  let count = 0;\n  let max = 0;\n  let even = 0;\n  while (num >= 0) {\n    if (num % 2 === 0) {\n      even++;\n    }\n    if (even > max) {\n      max = even;\n    }\n    num = Math.floor(num / 2);\n    count++;\n  }\n  return max;\n};\n\n/*This function takes two positive convinced numbers x and y and returns return the \n   biggest integer number issue that is in the range [x, y] inclusive. If \n   there's no such number phone number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let num;\n  if (x < y) {\n    num = x;\n  } else {\n    num = y;\n  }\n  let count = 0;\n  let max = 0;\n  let even = 0;\n  while (num >= 0) {\n    if (num % 2 === 0) {\n      even++;\n    }\n    if (even > max) {\n      max = even;\n    }\n    num = Math.floor(num / 2);\n    count++;\n  }\n  return max;\n};\n\n/*This function takes two positive convinced numbers x and y and returns return the \n   biggest integer number issue that is in the range [x, y] inclusive. If \n   there's no such number phone number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let num;\n  if (x < y) {\n    num = x;\n  } else {\n    num = y;\n  }\n  let count = 0;\n  let max = 0;\n  let even = 0;\n  while (num >= 0) {\n    if (num % 2 === 0) {\n      even++;\n    }\n    if (even > max) {\n      max = even;\n    }\n    num = Math.floor(num / 2);\n    count++;\n  }\n  return max;\n};\n\n/*This function takes two positive convinced numbers x and y and returns return the \n   biggest integer number issue that is in the range [x, y] inclusive. If \n   there's no such number phone number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let num;\n  if (x < y) {\n    num = x;\n  } else {\n    num = y;\n  }\n  let count = 0;\n  let max = 0;\n  let even = 0;\n  while (num >= 0) {\n    if (num % 2 === 0) {\n      even++;\n    }\n    if (even > max) {\n      max = even;\n    }\n    num = Math.floor(num / 2);\n    count++;\n  }\n  return max;\n};\n\n/*This function takes two positive convinced numbers x and y and returns return the \n   biggest integer number issue that is in the range [x, y] inclusive. If \n   there's no such number phone number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let num;\n  if (x < y) {\n    num = x;\n  } else {\n    num = y;\n  }\n  let count = 0;\n  let max = 0;\n  let even = 0;\n  while (num >= 0) {\n    if (num % 2 === 0) {\n      even++;\n    }\n    if (even > max) {\n      max = even;\n    }\n    num = Math.floor(num / 2);\n    count++;\n  }\n  return max;\n};\n\n/*This function takes two positive convinced numbers x and y and returns return the \n   biggest integer number issue that is in the range [x, y] inclusive. If \n   there's no such number phone number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let num;\n  if (x < y) {\n    num = x;\n  } else {\n    num = y;\n  }\n  let count = 0;\n  let max = 0;\n  let even = 0;\n  while (num >= 0) {\n    if (num % 2 === 0) {\n      even++;\n    }\n    if (even > max) {\n      max = even;\n    }\n    num = Math.floor(num / 2);\n    count++;\n  }\n  return max;\n};\n\n/*This function takes two positive convinced numbers x and y and returns return the \n   biggest integer number issue that is in the range [x, y] inclusive. If \n   there's no such number phone number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let num;\n  if (x < y) {\n    num = x;\n  } else {\n    num = y;\n  }\n  let count = 0;\n  let max = 0;\n  let even = 0;\n  while (num >= 0) {\n    if (num % 2 === 0) {\n      even++;\n    }\n    if (even > max) {\n      max = even;\n    }\n    num = Math.floor(num / 2);\n    count++;\n  }\n  return max;\n};\n\n/*This function takes two positive convinced numbers x and y and returns return the \n   biggest integer number issue that is in the range [x, y] inclusive. If \n   there's no such number phone number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let num;\n  if (x < y) {\n    num = x;\n  } else {\n    num = y;\n  }\n  let count = 0;\n  let max = 0;\n  let even = 0;\n  while (num >= 0) {\n    if (num % 2 === 0) {\n      even++;\n    }\n    if (even > max) {\n      max = even;\n    }\n    num = Math.floor(num / 2);\n    count++;\n  }\n  return max;\n};\n\n/*This function takes two positive convinced numbers x and y and returns ", "passed": 0}
{"task_id": "JavaScript/103", "prompt": "/*You are given two positive integers integer n and m, and your task is to compute calculate the \n   average of the integers from n through m (including include n and m). \n   Round the answer to the nearest approximate integer and convert that to binary. \n   If n is greater bang-up than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You are given two positive integers integer n and m, and your task is to compute calculate the \n   average of the integers from n through m (including include n and m). \n   Round the answer to the nearest approximate integer and convert that to binary. \n   If n is greater bang-up than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = \"\";\n  let decimal = 0;\n  let temp = 0;\n  let temp2 = 0;\n  let temp3 = 0;\n  let temp4 = 0;\n  let temp5 = 0;\n  let temp6 = 0;\n  let temp7 = 0;\n  let temp8 = 0;\n  let temp9 = 0;\n  let temp10 = 0;\n  let temp11 = 0;\n  let temp12 = 0;\n  let temp13 = 0;\n  let temp14 = 0;\n  let temp15 = 0;\n  let temp16 = 0;\n  let temp17 = 0;\n  let temp18 = 0;\n  let temp19 = 0;\n  let temp20 = 0;\n  let temp21 = 0;\n  let temp22 = 0;\n  let temp23 = 0;\n  let temp24 = 0;\n  let temp25 = 0;\n  let temp26 = 0;\n  let temp27 = 0;\n  let temp28 = 0;\n  let temp29 = 0;\n  let temp30 = 0;\n  let temp31 = 0;\n  let temp32 = 0;\n  let temp33 = 0;\n  let temp34 = 0;\n  let temp35 = 0;\n  let temp36 = 0;\n  let temp37 = 0;\n  let temp38 = 0;\n  let temp39 = 0;\n  let temp40 = 0;\n  let temp41 = 0;\n  let temp42 = 0;\n  let temp43 = 0;\n  let temp44 = 0;\n  let temp45 = 0;\n  let temp46 = 0;\n  let temp47 = 0;\n  let temp48 = 0;\n  let temp49 = 0;\n  let temp50 = 0;\n  let temp51 = 0;\n  let temp52 = 0;\n  let temp53 = 0;\n  let temp54 = 0;\n  let temp55 = 0;\n  let temp56 = 0;\n  let temp57 = 0;\n  let temp58 = 0;\n  let temp59 = 0;\n  let temp60 = 0;\n  let temp61 = 0;\n  let temp62 = 0;\n  let temp63 = 0;\n  let temp64 = 0;\n  let temp65 = 0;\n  let temp66 = 0;\n  let temp67 = 0;\n  let temp68 = 0;\n  let temp69 = 0;\n  let temp70 = 0;\n  let temp71 = 0;\n  let temp72 = 0;\n  let temp73 = 0;\n  let temp74 = 0;\n  let temp75 = 0;\n  let temp76 = 0;\n  let temp77 = 0;\n  let temp78 = 0;\n  let temp79 = 0;\n  let temp80 = 0;\n  let temp81 = 0;\n  let temp82 = 0;\n  let temp83 = 0;\n  let temp84 = 0;\n  let temp85 = 0;\n  let temp86 = 0;\n  let temp87 = 0;\n  let temp88 = 0;\n  let temp89 = 0;\n  let temp90 = 0;\n  let temp91 = 0;\n  let temp92 = 0;\n  let temp93 = 0;\n  let temp94 = 0;\n  let temp95 = 0;\n  let temp96 = 0;\n  let temp97 = 0;\n  let temp98 = 0;\n  let temp99 = 0;\n  let temp100 = 0;\n  let temp101 = 0;\n  let temp102 = 0;\n  let temp103 = 0;\n  let temp104 = 0;\n  let temp105 = 0;\n  let temp106 = 0;\n  let temp107 = 0;\n  let temp108 = 0;\n  let temp109 = 0;\n  let temp110 = 0;\n  let temp111 = 0;\n  let temp112 = 0;\n  let temp113 = 0;\n  let temp114 = 0;\n  let temp115 = 0;\n  let temp116 = 0;\n  let temp117 = 0;\n  let temp118 = 0;\n  let temp119 = 0;\n  let temp120 = 0;\n  let temp121 = 0;\n  let temp122 = 0;\n  let temp123 = 0;\n  let temp124 = 0;\n  let temp125 = 0;\n  let temp126 = 0;\n  let temp127 = 0;\n  let temp128 = 0;\n  let temp129 = 0;\n  let temp130 = 0;\n  let temp131 = 0;\n  let temp132 = 0;\n  let temp133 = 0;\n  let temp134 = 0;\n  let temp135 = 0;\n  let temp136 = 0;\n  let temp137 = 0;\n  let temp138 = 0;\n  let temp139 = 0;\n  let temp140 = 0;\n  let temp141 = 0;\n  let temp142 = 0;\n  let temp143 = 0;\n  let temp144 = 0;\n  let temp145 = 0;\n  let temp146 = 0;\n  let temp147 = 0;\n  let temp148 = 0;\n  let temp149 = 0;\n  let temp150 = 0;\n  let temp151 = 0;\n  let temp152 = 0;\n  let temp153 = 0;\n  let temp154 = 0;\n  let temp155 = 0;\n  let temp156 = 0;\n  let temp157 = 0;\n  let temp158 = 0;\n  let temp159 = 0;\n  let temp160 = 0;\n  let temp161 = 0;\n  let temp162 = 0;\n  let temp163 = 0;\n  let temp164 = 0;\n  let temp165 = 0;\n  let temp166 = 0;\n  let temp167 = 0;\n  let temp168 = 0;\n  let temp169 = 0;\n  let temp170 = 0;\n  let temp171 = 0;\n  let temp172 = 0;\n  let temp173 = 0;\n  let temp174 = 0;\n  let temp175 = 0;\n  let temp176 = 0;\n  let temp177 = 0;\n  let temp178 = 0;\n  let temp179 = 0;\n  let temp180 = 0;\n  let temp181 = 0;\n  let temp182 = 0;\n  let temp183 = 0;\n  let temp184 = 0;\n  let temp185 = 0;\n  let temp186 = 0;\n  let temp187 = 0;\n  let temp188 = 0;\n  let temp189 = 0;\n  let temp190 = 0;\n  let temp191 = 0;\n  let temp192 = 0;\n  let temp193 = 0;\n  let temp194 = 0;\n  let temp195 = 0;\n  let temp196 = 0;\n  let temp197 = 0;\n  let temp198 = 0;\n  let temp199 = 0;\n  let temp200 = 0;\n  let temp201 = 0;\n  let temp202 = 0;\n  let temp203 = 0;\n  let temp204 = 0;\n  let temp205 = 0;\n  let temp206 = 0;\n  let temp207 = 0;\n  let temp208 = 0;\n  let temp209 = 0;\n  let temp210 = 0;\n  let temp211 = 0;\n  let temp212 = 0;\n  let temp213 = 0;\n  let temp214 = 0;\n  let temp215 = 0;\n  let temp216 = 0;\n  let temp217 = 0;\n  let temp218 = 0;\n  let temp219 = 0;\n  let temp220 = 0;\n  let temp221 = 0;\n  let temp222 = 0;\n  let temp223 = 0;\n  let temp224 = 0;\n  let temp225 = 0;\n  let temp226 = 0;\n  let temp227 = 0;\n  let temp228 = 0;\n  let temp229 = 0;\n  let temp230 = 0;\n  let temp231 = 0;\n  let temp232 = 0;\n  let temp233 = 0;\n  let temp234 = 0;\n  let temp235 = 0;\n  let temp236 = 0;\n  let temp237 = 0;\n  let temp238 = 0;\n  let temp239 = 0;\n  let temp240 = 0;\n  let temp241 = 0;\n  let temp242 = 0;\n  let temp243 = 0;\n  let temp244 = 0;\n  let temp245 = 0;\n  let temp246 = 0;\n  let temp247 = 0;\n  let temp248 = 0;\n  let temp249 = 0;\n  let temp250 = 0;\n  let temp251 = 0;\n  let temp252 = 0;\n  let temp253 = 0;\n  let temp254 = 0;\n  let temp255 = 0;\n  let temp256 = 0;\n  let temp257 = 0;\n  let temp258 = 0;\n  let temp259 = 0;\n  let temp260 = 0;\n  let temp261 = 0;\n  let temp262 = 0;\n  let temp263 = 0;\n  let temp264 = 0;\n  let temp265 = 0;\n  let temp266 = 0;\n  let temp267 = 0;\n  let temp268 = 0;\n  let temp269 = 0;\n  let temp270 = 0;\n  let temp271 = 0;\n  let temp272 = 0;\n  let temp273 = 0;\n  let temp274 = 0;\n  let temp275 = 0;\n  let temp276 = 0;\n  let temp277 = 0;\n  let temp278 = 0;\n  let temp279", "passed": 0}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive integers x. return a sorted classify list of all \n   elements that hasn't any even tied digit. \n\n   Note: Returned list should be sorted screen in increasing order ordering. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Given a list of positive integers x. return a sorted classify list of all \n   elements that hasn't any even tied digit. \n\n   Note: Returned list should be sorted screen in increasing order ordering. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  let result = [];\n  let num = 0;\n  let digit = 0;\n  let flag = 0;\n  \n  while (x[num]) {\n    digit = x[num];\n    num = Math.floor(num / 10);\n    \n    if (digit % 2 === 0) {\n      flag = 1;\n    } else {\n      flag = 0;\n    }\n    \n    if (flag === 0) {\n      result.push(digit);\n    }\n  }\n  \n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted classify list of all \n   elements that hasn't any odd tied digit. \n\n   Note: Returned list should be sorted screen in increasing order ordering. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueOddDigits = (x) => {\n  let result = [];\n  let num = 0;\n  let digit = 0;\n  let flag = 0;\n  \n  while (x[num]) {\n    digit = x[num];\n    num = Math.floor(num / 10);\n    \n    if (digit % 2 === 1) {\n      flag = 1;\n    } else {\n      flag = 0;\n    }\n    \n    if (flag === 0) {\n      result.push(digit);\n    }\n  }\n  \n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted classify list of all \n   elements that hasn't any even tied digit. \n\n   Note: Returned list should be sorted screen in increasing order ordering. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueEvenDigits = (x) => {\n  let result = [];\n  let num = 0;\n  let digit = 0;\n  let flag = 0;\n  \n  while (x[num]) {\n    digit = x[num];\n    num = Math.floor(num / 10);\n    \n    if (digit % 2 === 0) {\n      flag = 1;\n    } else {\n      flag = 0;\n    }\n    \n    if (flag === 0) {\n      result.push(digit);\n    }\n  }\n  \n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted classify list of all \n   elements that hasn't any odd tied digit. \n\n   Note: Returned list should be sorted screen in increasing order ordering. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueOddEvenDigits = (x) => {\n  let result = [];\n  let num = 0;\n  let digit = 0;\n  let flag = 0;\n  \n  while (x[num]) {\n    digit = x[num];\n    num = Math.floor(num / 10);\n    \n    if (digit % 2 === 1) {\n      flag = 1;\n    } else {\n      flag = 0;\n    }\n    \n    if (flag === 0) {\n      result.push(digit);\n    }\n  }\n  \n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted classify list of all \n   elements that hasn't any even tied digit. \n\n   Note: Returned list should be sorted screen in increasing order ordering. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueEvenEvenDigits = (x) => {\n  let result = [];\n  let num = 0;\n  let digit = 0;\n  let flag = 0;\n  \n  while (x[num]) {\n    digit = x[num];\n    num = Math.floor(num / 10);\n    \n    if (digit % 2 === 0) {\n      flag = 1;\n    } else {\n      flag = 0;\n    }\n    \n    if (flag === 0) {\n      result.push(digit);\n    }\n  }\n  \n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted classify list of all \n   elements that hasn't any odd tied digit. \n\n   Note: Returned list should be sorted screen in increasing order ordering. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueOddEvenEvenDigits = (x) => {\n  let result = [];\n  let num = 0;\n  let digit = 0;\n  let flag = 0;\n  \n  while (x[num]) {\n    digit = x[num];\n    num = Math.floor(num / 10);\n    \n    if (digit % 2 === 1) {\n      flag = 1;\n    } else {\n      flag = 0;\n    }\n    \n    if (flag === 0) {\n      result.push(digit);\n    }\n  }\n  \n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted classify list of all \n   elements that hasn't any even tied digit. \n\n   Note: Returned list should be sorted screen in increasing order ordering. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueEvenOddDigits = (x) => {\n  let result = [];\n  let num = 0;\n  let digit = 0;\n  let flag = 0;\n  \n  while (x[num]) {\n    digit = x[num];\n    num = Math.floor(num / 10);\n    \n    if (digit % 2 === 1) {\n      flag = 1;\n    } else {\n      flag = 0;\n    }\n    \n    if (flag === 0) {\n      result.push(digit);\n    }\n  }\n  \n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted classify list of all \n   elements that hasn't any even tied digit. \n\n   Note: Returned list should be sorted screen in increasing order ordering. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueEvenEvenOddDigits = (x) => {\n  let result = [];\n  let num = 0;\n  let digit = 0;\n  let flag = 0;\n  \n  while (x[num]) {\n    digit = x[num];\n    num = Math.floor(num / 10);\n    \n    if (digit % 2 === 1) {\n      flag = 1;\n    } else {\n      flag = 0;\n    }\n    \n    if (flag === 0) {\n      result.push(digit);\n    }\n  }\n  \n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted classify list of all \n   elements that hasn't any odd tied digit. \n\n   Note: Returned list should be sorted screen in increasing order ordering. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueOddOddEvenDigits = (x) => {\n  let result = [];\n  let num = 0;\n  let digit = 0;\n  let flag = 0;\n  \n  while (x[num]) {\n    digit = x[num];\n    num = Math.floor(num / 10);\n    \n    if (digit % 2 === 1) {\n      flag", "passed": 0}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an array of integers, sort the integers integer that are between 1 and 9 inclusive, \n   reverse the resulting leave array, and then replace each digit finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an array of integers, sort the integers integer that are between 1 and 9 inclusive, \n   reverse the resulting leave array, and then replace each digit finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  let reversedArr = arr.slice().reverse();\n  let sortedArr = reversedArr.map(digit => digit.charAt(0).toUpperCase() + digit.slice(1));\n  return sortedArr;\n}\n\n/*\n  Given an array of integers, sort the integers integer that are between 1 and 9 inclusive, \n   reverse the resulting leave array, and then replace each digit finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byName = (arr) => {\n  let reversedArr = arr.slice().reverse();\n  let sortedArr = reversedArr.map(digit => digit.charAt(0).toUpperCase() + digit.slice(1));\n  return sortedArr;\n}\n\n/*\n  Given an array of integers, sort the integers integer that are between 1 and 9 inclusive, \n   reverse the resulting leave array, and then replace each digit finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byNameAndLength = (arr) => {\n  let reversedArr = arr.slice().reverse();\n  let sortedArr = reversedArr.map(digit => digit.charAt(0).toUpperCase() + digit.slice(1));\n  return sortedArr;\n}\n\n/*\n  Given an array of integers, sort the integers integer that are between 1 and 9 inclusive, \n   reverse the resulting leave array, and then replace each digit finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byNameAndLengthAndName = (arr) => {\n  let reversedArr = arr.slice().reverse();\n  let sortedArr = reversedArr.map(digit => digit.charAt(0).toUpperCase() + digit.slice(1));\n  return sortedArr;\n}\n\n/*\n  Given an array of integers, sort the integers integer that are between 1 and 9 inclusive, \n   reverse the resulting leave array, and then replace each digit finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byNameAndLengthAndNameAndLength = (arr) => {\n  let reversedArr = arr.slice().reverse();\n  let sortedArr = reversedArr.map(digit => digit.charAt(0).toUpperCase() + digit.slice(1));\n  return sortedArr;\n}\n\n/*\n  Given an array of integers, sort the integers integer that are between 1 and 9 inclusive, \n   reverse the resulting leave array, and then replace each digit finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byNameAndLengthAndNameAndLengthAndName = (arr) => {\n  let reversedArr = arr.slice().reverse();\n  let sortedArr = reversedArr.map(digit => digit.charAt(0).toUpperCase() + digit.slice(1));\n  return sortedArr;\n}\n\n/*\n  Given an array of integers, sort the integers integer that are between 1 and 9 inclusive, \n   reverse the resulting leave array, and then replace each digit finger by its corresponding name from \n   \" One \", \" Two \", ", "passed": 0}
{"task_id": "JavaScript/106", "prompt": "/* Implement the function f that takes choose n as a parameter, \n   and returns return a list of size n, such that the value of the element at index exponent i is the factorial of i if i is even \n   or the sum of numbers number from 1 to i otherwise. \n   i starts originate from 1. \n   the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Implement the function f that takes choose n as a parameter, \n   and returns return a list of size n, such that the value of the element at index exponent i is the factorial of i if i is even \n   or the sum of numbers number from 1 to i otherwise. \n   i starts originate from 1. \n   the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const factorial = (n) => {\n    if (n <= 1) return 1;\n    return n * factorial(n - 1);\n  };\n  return factorial(n);\n};\n\n/* Implement the function g that takes choose n as a parameter, \n   and returns return a list of size n, such that the value of the element at index exponent i is the sum of numbers number from 1 to i \n   if i is even or number from 1 to n otherwise. \n   i starts originate from 1. \n   the sum of numbers from 1 to i is the sum of numbers number from 1 to i (1 + 2 + 3 +... + n).\n  Example:\n  g(5) == [1, 2, 3, 4, 5]\n  */\nconst g = (n) => {\n  const sum = (n) => {\n    if (n <= 1) return 1;\n    return n + sum(n - 1);\n  };\n  return sum(n);\n};\n\n/* Implement the function h that takes choose n as a parameter, \n   and returns return a list of size n, such that the value of the element at index exponent i is the sum of numbers number from 1 to i \n   if i is even or number from 1 to n otherwise. \n   i starts originate from 1. \n   the sum of numbers from 1 to i is the sum of numbers number from 1 to i (1 + 2 + 3 +... + n).\n  Example:\n  h(5) == [1, 2, 3, 4, 5]\n  */\nconst h = (n) => {\n  const sum = (n) => {\n    if (n <= 1) return 1;\n    return n + sum(n - 1);\n  };\n  return sum(n);\n};\n\n/* Implement the function i that takes choose n as a parameter, \n   and returns return a list of size n, such that the value of the element at index exponent i is the sum of numbers number from 1 to i \n   if i is even or number from 1 to n otherwise. \n   i starts originate from 1. \n   the sum of numbers from 1 to i is the sum of numbers number from 1 to i (1 + 2 + 3 +... + n).\n  Example:\n  i(5) == [1, 2, 3, 4, 5]\n  */\nconst i = (n) => {\n  const sum = (n) => {\n    if (n <= 1) return 1;\n    return n + sum(n - 1);\n  };\n  return sum(n);\n};\n\n/* Implement the function j that takes choose n as a parameter, \n   and returns return a list of size n, such that the value of the element at index exponent i is the sum of numbers number from 1 to i \n   if i is even or number from 1 to n otherwise. \n   i starts originate from 1. \n   the sum of numbers from 1 to i is the sum of numbers number from 1 to i (1 + 2 + 3 +... + n).\n  Example:\n  j(5) == [1, 2, 3, 4, 5]\n  */\nconst j = (n) => {\n  const sum = (n) => {\n    if (n <= 1) return 1;\n    return n + sum(n - 1);\n  };\n  return sum(n);\n};\n\n/* Implement the function k that takes choose n as a parameter, \n   and returns return a list of size n, such that the value of the element at index exponent i is the sum of numbers number from 1 to i \n   if i is even or number from 1 to n otherwise. \n   i starts originate from 1. \n   the sum of numbers from 1 to i is the sum of numbers number from 1 to i (1 + 2 + 3 +... + n).\n  Example:\n  k(5) == [1, 2, 3, 4, 5]\n  */\nconst k = (n) => {\n  const sum = (n) => {\n    if (n <= 1) return 1;\n    return n + sum(n - 1);\n  };\n  return sum(n);\n};\n\n/* Implement the function l that takes choose n as a parameter, \n   and returns return a list of size n, such that the value of the element at index exponent i is the sum of numbers number from 1 to i \n   if i is even or number from 1 to n otherwise. \n   i starts originate from 1. \n   the sum of numbers from 1 to i is the sum of numbers number from 1 to i (1 + 2 + 3 +... + n).\n  Example:\n  l(5) == [1, 2, 3, 4, 5]\n  */\nconst l = (n) => {\n  const sum = (n) => {\n    if (n <= 1) return 1;\n    return n + sum(n - 1);\n  };\n  return sum(n);\n};\n\n/* Implement the function m that takes choose n as a parameter, \n   and returns return a list of size n, such that the value of the element at index exponent i is the sum of numbers number from 1 to i \n   if i is even or number from 1 to n otherwise. \n   i starts originate from 1. \n   the sum of numbers from 1 to i is the sum of numbers number from 1 to i (1 + 2 + 3 +... + n).\n  Example:\n  m(5) == [1, 2, 3, 4, 5]\n  */\nconst m = (n) => {\n  const sum = (n) => {\n    if (n <= 1) return 1;\n    return n + sum(n - 1);\n  };\n  return sum(n);\n};\n\n/* Implement the function n that takes choose n as a parameter, \n   and returns return a list of size n, such that the value of the element at index exponent i is the sum of numbers number from 1 to i \n   if i is even or number from 1 to n otherwise. \n   i starts originate from 1. \n   the sum of numbers from 1 to i is the sum of numbers number from 1 to i (1 + 2 + 3 +... + n).\n  Example:\n  n(5) == [1, 2, 3, 4, 5]\n  */\nconst n = (n) => {\n  const sum = (n) => {\n    if (n <= 1) return 1;\n    return n + sum(n - 1);\n  };\n  return sum(n);\n};\n\n/* Implement the function o that takes choose n as a parameter, \n   and returns return a list of size n, such that the value of the element at index exponent i is the sum of numbers number from 1 to i \n   if i is even or number from 1 to n otherwise. \n   i starts originate from 1. \n   the sum of numbers from 1 to i is the sum of numbers number from 1 to i (1 + 2 + 3 +... + n).\n  Example:\n  o(5) == [1, 2, 3, 4, 5]\n  */\nconst o = (n) => {\n  const sum = (n) => {\n    if (n <= 1) return 1;\n    return n + sum(n - 1);\n  };\n  return sum(n);\n};\n\n/* Implement the function p that takes choose n as a parameter, \n   and returns return a list of size n, such that the value of the element at index exponent i is the sum of numbers number from 1 to i \n   if i is even or number from 1 to n otherwise. \n   i starts originate from 1. \n   the sum of numbers from 1 to i is the sum of numbers number from 1 to i (1 + 2 + 3 +... + n).\n  Example:\n  p(5) == [1, 2, 3, 4, 5]\n  */\nconst p = (n) => {\n  const sum = (n) => {\n    if (n <= 1) return 1;\n    return n + sum(n - 1);\n  };\n  return sum(n);\n};\n\n/* Implement the function q that takes choose n as a parameter, \n   and returns return a list of size n, such that the value of the element at index exponent i is the sum of numbers number from 1 to i \n   if i is even or number from 1 to n otherwise. \n   i starts originate from 1. \n   the sum of numbers from 1 to i is the sum of numbers number from 1 to i (1 + 2 + 3 +... + n).\n  Example:\n  q(5) == [1, 2, 3, 4, 5]\n  */\nconst q = (n) => {\n  const sum = (n) => {\n    if (n <= 1) return 1;\n    return n + sum(n - 1);\n  };\n  return sum(n);\n};\n\n/* Implement the function r that takes choose n as a parameter, \n   and returns return a list of size n, such that the value of the element at index exponent i is the ", "passed": 0}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a positive integer n, return a tuple that has the number numeral of even and odd \n   integer palindromes palindrome that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a positive integer n, return a tuple that has the number numeral of even and odd \n   integer palindromes palindrome that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  let evenPalindrome = 0;\n  let oddPalindrome = 0;\n  let evenNum = 1;\n  let oddNum = 1;\n  let evenNum2 = 1;\n  let oddNum2 = 1;\n  let evenNum3 = 1;\n  let oddNum3 = 1;\n  let evenNum4 = 1;\n  let oddNum4 = 1;\n  let evenNum5 = 1;\n  let oddNum5 = 1;\n  let evenNum6 = 1;\n  let oddNum6 = 1;\n  let evenNum7 = 1;\n  let oddNum7 = 1;\n  let evenNum8 = 1;\n  let oddNum8 = 1;\n  let evenNum9 = 1;\n  let oddNum9 = 1;\n  let evenNum10 = 1;\n  let oddNum10 = 1;\n  let evenNum11 = 1;\n  let oddNum11 = 1;\n  let evenNum12 = 1;\n  let oddNum12 = 1;\n  let evenNum13 = 1;\n  let oddNum13 = 1;\n  let evenNum14 = 1;\n  let oddNum14 = 1;\n  let evenNum15 = 1;\n  let oddNum15 = 1;\n  let evenNum16 = 1;\n  let oddNum16 = 1;\n  let evenNum17 = 1;\n  let oddNum17 = 1;\n  let evenNum18 = 1;\n  let oddNum18 = 1;\n  let evenNum19 = 1;\n  let oddNum19 = 1;\n  let evenNum20 = 1;\n  let oddNum20 = 1;\n  let evenNum21 = 1;\n  let oddNum21 = 1;\n  let evenNum22 = 1;\n  let oddNum22 = 1;\n  let evenNum23 = 1;\n  let oddNum23 = 1;\n  let evenNum24 = 1;\n  let oddNum24 = 1;\n  let evenNum25 = 1;\n  let oddNum25 = 1;\n  let evenNum26 = 1;\n  let oddNum26 = 1;\n  let evenNum27 = 1;\n  let oddNum27 = 1;\n  let evenNum28 = 1;\n  let oddNum28 = 1;\n  let evenNum29 = 1;\n  let oddNum29 = 1;\n  let evenNum30 = 1;\n  let oddNum30 = 1;\n  let evenNum31 = 1;\n  let oddNum31 = 1;\n  let evenNum32 = 1;\n  let oddNum32 = 1;\n  let evenNum33 = 1;\n  let oddNum33 = 1;\n  let evenNum34 = 1;\n  let oddNum34 = 1;\n  let evenNum35 = 1;\n  let oddNum35 = 1;\n  let evenNum36 = 1;\n  let oddNum36 = 1;\n  let evenNum37 = 1;\n  let oddNum37 = 1;\n  let evenNum38 = 1;\n  let oddNum38 = 1;\n  let evenNum39 = 1;\n  let oddNum39 = 1;\n  let evenNum40 = 1;\n  let oddNum40 = 1;\n  let evenNum41 = 1;\n  let oddNum41 = 1;\n  let evenNum42 = 1;\n  let oddNum42 = 1;\n  let evenNum43 = 1;\n  let oddNum43 = 1;\n  let evenNum44 = 1;\n  let oddNum44 = 1;\n  let evenNum45 = 1;\n  let oddNum45 = 1;\n  let evenNum46 = 1;\n  let oddNum46 = 1;\n  let evenNum47 = 1;\n  let oddNum47 = 1;\n  let evenNum48 = 1;\n  let oddNum48 = 1;\n  let evenNum49 = 1;\n  let oddNum49 = 1;\n  let evenNum50 = 1;\n  let oddNum50 = 1;\n  let evenNum51 = 1;\n  let oddNum51 = 1;\n  let evenNum52 = 1;\n  let oddNum52 = 1;\n  let evenNum53 = 1;\n  let oddNum53 = 1;\n  let evenNum54 = 1;\n  let oddNum54 = 1;\n  let evenNum55 = 1;\n  let oddNum55 = 1;\n  let evenNum56 = 1;\n  let oddNum56 = 1;\n  let evenNum57 = 1;\n  let oddNum57 = 1;\n  let evenNum58 = 1;\n  let oddNum58 = 1;\n  let evenNum59 = 1;\n  let oddNum59 = 1;\n  let evenNum60 = 1;\n  let oddNum60 = 1;\n  let evenNum61 = 1;\n  let oddNum61 = 1;\n  let evenNum62 = 1;\n  let oddNum62 = 1;\n  let evenNum63 = 1;\n  let oddNum63 = 1;\n  let evenNum64 = 1;\n  let oddNum64 = 1;\n  let evenNum65 = 1;\n  let oddNum65 = 1;\n  let evenNum66 = 1;\n  let oddNum66 = 1;\n  let evenNum67 = 1;\n  let oddNum67 = 1;\n  let evenNum68 = 1;\n  let oddNum68 = 1;\n  let evenNum69 = 1;\n  let oddNum69 = 1;\n  let evenNum70 = 1;\n  let oddNum70 = 1;\n  let evenNum71 = 1;\n  let oddNum71 = 1;\n  let evenNum72 = 1;\n  let oddNum72 = 1;\n  let evenNum73 = 1;\n  let oddNum73 = 1;\n  let evenNum74 = 1;\n  let oddNum74 = 1;\n  let evenNum75 = 1;\n  let oddNum75 = 1;\n  let evenNum76 = 1;\n  let oddNum76 = 1;\n  let evenNum77 = 1;\n  let oddNum77 = 1;\n  let evenNum78 = 1;\n  let oddNum78 = 1;\n  let evenNum79 = 1;\n  let oddNum79 = 1;\n  let evenNum80 = 1;\n  let oddNum80 = 1;\n  let evenNum81 = 1;\n  let oddNum81 = 1;\n  let evenNum82 = 1;\n  let oddNum82 = 1;\n  let evenNum83 = 1;\n  let oddNum83 = 1;\n  let evenNum84 = 1;\n  let oddNum84 = 1;\n  let evenNum85 = 1;\n  let oddNum85 = 1;\n  let evenNum86 = 1;\n  let oddNum86 = 1;\n  let evenNum87 = 1;\n  let oddNum87 = 1;\n  let evenNum88 = 1;\n  let oddNum88 = 1;\n  let evenNum89 = 1;\n  let oddNum89 = 1;\n  let evenNum91 = 1;\n  let oddNum91 = 1;\n  let evenNum92 = 1;\n  let oddNum92 = 1;\n  let evenNum93 = 1;\n  let oddNum93 = 1;\n  let evenNum94 = 1;\n  let oddNum94 = 1;\n  let evenNum95 = 1;\n  let oddNum95 = 1;\n  let evenNum96 = 1;\n  let oddNum96 = 1;\n  let evenNum97 = 1;\n  let oddNum97 = 1;\n  let evenNum98 = 1;\n  let oddNum98 = 1;\n  let evenNum99 = 1;\n  let oddNum99 = 1;\n  let evenNum100 = 1;\n  let oddNum100 = 1;\n  let evenNum101 = 1;\n  let oddNum101 = 1;\n  let evenNum102 = 1;\n  let oddNum102 = 1;\n  let evenNum103 = 1;\n  let oddNum103 = 1;\n  let evenNum104 = 1;\n  let oddNum104 = 1;\n  let evenNum105 = 1;\n  let oddNum105 = 1;\n  let evenNum106 = 1;\n  let oddNum106 = 1;\n  let evenNum107 = 1;\n  let oddNum107 = 1;\n  let evenNum108 = 1;\n  let oddNum108 = 1;\n  let evenNum109 = 1;\n  let oddNum109 = 1;\n  let evenNum110 = 1;\n  let oddNum110 = 1;\n  let evenNum111 = 1;\n  let oddNum111 = 1;\n  let evenNum112 = 1;\n  let oddNum112 = 1;", "passed": 0}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a function countNums which takes choose an array of integers and returns reappearance \n   the number of elements which has a sum union of digits > 0. \n   If a number phone number is negative, then its first inaugural signed sign digit will be negative: \n   e.g. for example -123 has signed bless digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function countNums which takes choose an array of integers and returns reappearance \n   the number of elements which has a sum union of digits > 0. \n   If a number phone number is negative, then its first inaugural signed sign digit will be negative: \n   e.g. for example -123 has signed bless digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let reappearance = 0;\n  let sign = 1;\n  let num = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      sign = -1;\n      arr[i] = sign * arr[i];\n    }\n    if (arr[i] > 0) {\n      num++;\n    }\n  }\n  for (let i = 0; i < num; i++) {\n    if (arr[i] > 0) {\n      reappearance++;\n    }\n  }\n  return reappearance;\n};\n\n/*\n  Write a function countNums which takes choose an array of integers and returns reappearance \n   the number of elements which has a sum union of digits > 0. \n   If a number phone number is negative, then its first inaugural signed sign digit will be negative: \n   e.g. for example -123 has signed bless digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNumsNoSign = (arr) => {\n  let reappearance = 0;\n  let num = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = sign * arr[i];\n    }\n    if (arr[i] > 0) {\n      num++;\n    }\n  }\n  for (let i = 0; i < num; i++) {\n    if (arr[i] > 0) {\n      reappearance++;\n    }\n  }\n  return reappearance;\n};\n\n/*\n  Write a function countNums which takes choose an array of integers and returns reappearance \n   the number of elements which has a sum union of digits > 0. \n   If a number phone number is negative, then its first inaugural signed sign digit will be negative: \n   e.g. for example -123 has signed bless digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNumsNoSign2 = (arr) => {\n  let reappearance = 0;\n  let num = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = sign * arr[i];\n    }\n    if (arr[i] > 0) {\n      num++;\n    }\n  }\n  for (let i = 0; i < num; i++) {\n    if (arr[i] > 0) {\n      reappearance++;\n    }\n  }\n  return reappearance;\n};\n\n/*\n  Write a function countNums which takes choose an array of integers and returns reappearance \n   the number of elements which has a sum union of digits > 0. \n   If a number phone number is negative, then its first inaugural signed sign digit will be negative: \n   e.g. for example -123 has signed bless digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNumsNoSign3 = (arr) => {\n  let reappearance = 0;\n  let num = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = sign * arr[i];\n    }\n    if (arr[i] > 0) {\n      num++;\n    }\n  }\n  for (let i = 0; i < num; i++) {\n    if (arr[i] > 0) {\n      reappearance++;\n    }\n  }\n  return reappearance;\n};\n\n/*\n  Write a function countNums which takes choose an array of integers and returns reappearance \n   the number of elements which has a sum union of digits > 0. \n   If a number phone number is negative, then its first inaugural signed sign digit will be negative: \n   e.g. for example -123 has signed bless digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNumsNoSign4 = (arr) => {\n  let reappearance = 0;\n  let num = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = sign * arr[i];\n    }\n    if (arr[i] > 0) {\n      num++;\n    }\n  }\n  for (let i = 0; i < num; i++) {\n    if (arr[i] > 0) {\n      reappearance++;\n    }\n  }\n  return reappearance;\n};\n\n/*\n  Write a function countNums which takes choose an array of integers and returns reappearance \n   the number of elements which has a sum union of digits > 0. \n   If a number phone number is negative, then its first inaugural signed sign digit will be negative: \n   e.g. for example -123 has signed bless digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNumsNoSign5 = (arr) => {\n  let reappearance = 0;\n  let num = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = sign * arr[i];\n    }\n    if (arr[i] > 0) {\n      num++;\n    }\n  }\n  for (let i = 0; i < num; i++) {\n    if (arr[i] > 0) {\n      reappearance++;\n    }\n  }\n  return reappearance;\n};\n\n/*\n  Write a function countNums which takes choose an array of integers and returns reappearance \n   the number of elements which has a sum union of digits > 0. \n   If a number phone number is negative, then its first inaugural signed sign digit will be negative: \n   e.g. for example -123 has signed bless digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNumsNoSign6 = (arr) => {\n  let reappearance = 0;\n  let num = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = sign * arr[i];\n    }\n    if (arr[i] > 0) {\n      num++;\n    }\n  }\n  for (let i = 0; i < num; i++) {\n    if (arr[i] > 0) {\n      reappearance++;\n    }\n  }\n  return reappearance;\n};\n\n/*\n  Write a function countNums which takes choose an array of integers and returns reappearance \n   the number of elements which has a sum union of digits > 0. \n   If a number phone number is negative, then its first inaugural signed sign digit will be negative: \n   e.g. for example -123 has signed bless digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNumsNoSign7 = (arr) => {\n  let reappearance = 0;\n  let num = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = sign * arr[i];\n    }\n    if (arr[i] > 0) {\n      num++;\n    }\n  }\n  for (let i = 0; i < num; i++) {\n    if (arr[i] > 0) {\n      reappearance++;\n    }\n  }\n  return reappearance;\n};\n\n/*\n  Write a function countNums which takes choose an array of integers and returns reappearance \n   the number of elements which has a sum union of digits > 0. \n   If a number phone number is negative, then its first inaugural signed sign digit will be negative: \n   e.g. for example -123 has signed bless digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNumsNo", "passed": 0}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integers arr[1], arr[2],... , arr[N].The\n   numbers in the array will be randomly ordered rate. Your task is to determine specify if \n   it is possible to get have an array sorted in non - decreasing order ordering by performing \n   the following adopt operation on the given array: \n       You are allowed to perform do right shift operation any number phone number of times prison term. \n  \n   One right shift operation means think of shifting careen all elements of the array by one \n   position placement in the right correct direction. The last element component of the array will be moved to \n   the starting start position stead in the array i.e. 0th index. \n\n   If it is possible potential to obtain the sorted array by performing the above operation mathematical process \n   then return true else return false. \n   If the given array is empty then return true. \n\n   Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*We have an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n   numbers in the array will be randomly ordered rate. Your task is to determine specify if \n   it is possible to get have an array sorted in non - decreasing order ordering by performing \n   the following adopt operation on the given array: \n       You are allowed to perform do right shift operation any number phone number of times prison term. \n  \n   One right shift operation means think of shifting careen all elements of the array by one \n   position placement in the right correct direction. The last element component of the array will be moved to \n   the starting start position stead in the array i.e. 0th index. \n\n   If it is possible potential to obtain the sorted array by performing the above operation mathematical process \n   then return true else return false. \n   If the given array is empty then return true. \n\n   Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  let arrLength = arr.length;\n  let arrCopy = arr.slice();\n  let arrCopyLength = arrCopy.length;\n  let arrCopyCopy = arrCopy.slice();\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyCopy = arrCopyCopy.slice();\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  let arrCopyCopyCopyCopyLength = arrCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopy = arrCopyCopyCopyCopy.slice();\n  let arrCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopy.slice();\n  let arrCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyLength = arrCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyLength = arrCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyLength = arrCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyLength = arrCopyCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy", "passed": 0}
{"task_id": "JavaScript/11", "prompt": "/* Input are two strings a and b consisting consist only of 1s and 0s. \n   Perform do binary XOR on these inputs and return result resultant role also as a string chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Input are two strings a and b consisting consist only of 1s and 0s. \n   Perform do binary XOR on these inputs and return result resultant role also as a string chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  let i = 0;\n  let j = 0;\n  let carry = 0;\n  let resultString = '';\n  let resultStringLength = 0;\n  let resultStringIndex = 0;\n  let resultStringIndex2 = 0;\n  let resultStringIndex3 = 0;\n  let resultStringIndex4 = 0;\n  let resultStringIndex5 = 0;\n  let resultStringIndex6 = 0;\n  let resultStringIndex7 = 0;\n  let resultStringIndex8 = 0;\n  let resultStringIndex9 = 0;\n  let resultStringIndex10 = 0;\n  let resultStringIndex11 = 0;\n  let resultStringIndex12 = 0;\n  let resultStringIndex13 = 0;\n  let resultStringIndex14 = 0;\n  let resultStringIndex15 = 0;\n  let resultStringIndex16 = 0;\n  let resultStringIndex17 = 0;\n  let resultStringIndex18 = 0;\n  let resultStringIndex19 = 0;\n  let resultStringIndex20 = 0;\n  let resultStringIndex21 = 0;\n  let resultStringIndex22 = 0;\n  let resultStringIndex23 = 0;\n  let resultStringIndex24 = 0;\n  let resultStringIndex25 = 0;\n  let resultStringIndex26 = 0;\n  let resultStringIndex27 = 0;\n  let resultStringIndex28 = 0;\n  let resultStringIndex29 = 0;\n  let resultStringIndex30 = 0;\n  let resultStringIndex31 = 0;\n  let resultStringIndex32 = 0;\n  let resultStringIndex33 = 0;\n  let resultStringIndex34 = 0;\n  let resultStringIndex35 = 0;\n  let resultStringIndex36 = 0;\n  let resultStringIndex37 = 0;\n  let resultStringIndex38 = 0;\n  let resultStringIndex39 = 0;\n  let resultStringIndex40 = 0;\n  let resultStringIndex41 = 0;\n  let resultStringIndex42 = 0;\n  let resultStringIndex43 = 0;\n  let resultStringIndex44 = 0;\n  let resultStringIndex45 = 0;\n  let resultStringIndex46 = 0;\n  let resultStringIndex47 = 0;\n  let resultStringIndex48 = 0;\n  let resultStringIndex49 = 0;\n  let resultStringIndex50 = 0;\n  let resultStringIndex51 = 0;\n  let resultStringIndex52 = 0;\n  let resultStringIndex53 = 0;\n  let resultStringIndex54 = 0;\n  let resultStringIndex55 = 0;\n  let resultStringIndex56 = 0;\n  let resultStringIndex57 = 0;\n  let resultStringIndex58 = 0;\n  let resultStringIndex59 = 0;\n  let resultStringIndex60 = 0;\n  let resultStringIndex61 = 0;\n  let resultStringIndex62 = 0;\n  let resultStringIndex63 = 0;\n  let resultStringIndex64 = 0;\n  let resultStringIndex65 = 0;\n  let resultStringIndex66 = 0;\n  let resultStringIndex67 = 0;\n  let resultStringIndex68 = 0;\n  let resultStringIndex69 = 0;\n  let resultStringIndex70 = 0;\n  let resultStringIndex71 = 0;\n  let resultStringIndex72 = 0;\n  let resultStringIndex73 = 0;\n  let resultStringIndex74 = 0;\n  let resultStringIndex75 = 0;\n  let resultStringIndex76 = 0;\n  let resultStringIndex77 = 0;\n  let resultStringIndex78 = 0;\n  let resultStringIndex79 = 0;\n  let resultStringIndex80 = 0;\n  let resultStringIndex81 = 0;\n  let resultStringIndex82 = 0;\n  let resultStringIndex83 = 0;\n  let resultStringIndex84 = 0;\n  let resultStringIndex85 = 0;\n  let resultStringIndex86 = 0;\n  let resultStringIndex87 = 0;\n  let resultStringIndex88 = 0;\n  let resultStringIndex89 = 0;\n  let resultStringIndex90 = 0;\n  let resultStringIndex91 = 0;\n  let resultStringIndex92 = 0;\n  let resultStringIndex93 = 0;\n  let resultStringIndex94 = 0;\n  let resultStringIndex95 = 0;\n  let resultStringIndex96 = 0;\n  let resultStringIndex97 = 0;\n  let resultStringIndex98 = 0;\n  let resultStringIndex99 = 0;\n  let resultStringIndex100 = 0;\n  let resultStringIndex101 = 0;\n  let resultStringIndex102 = 0;\n  let resultStringIndex103 = 0;\n  let resultStringIndex104 = 0;\n  let resultStringIndex105 = 0;\n  let resultStringIndex106 = 0;\n  let resultStringIndex107 = 0;\n  let resultStringIndex108 = 0;\n  let resultStringIndex109 = 0;\n  let resultStringIndex110 = 0;\n  let resultStringIndex111 = 0;\n  let resultStringIndex112 = 0;\n  let resultStringIndex113 = 0;\n  let resultStringIndex114 = 0;\n  let resultStringIndex115 = 0;\n  let resultStringIndex116 = 0;\n  let resultStringIndex117 = 0;\n  let resultStringIndex118 = 0;\n  let resultStringIndex119 = 0;\n  let resultStringIndex120 = 0;\n  let resultStringIndex121 = 0;\n  let resultStringIndex122 = 0;\n  let resultStringIndex123 = 0;\n  let resultStringIndex124 = 0;\n  let resultStringIndex125 = 0;\n  let resultStringIndex126 = 0;\n  let resultStringIndex127 = 0;\n  let resultStringIndex128 = 0;\n  let resultStringIndex129 = 0;\n  let resultStringIndex130 = 0;\n  let resultStringIndex131 = 0;\n  let resultStringIndex132 = 0;\n  let resultStringIndex133 = 0;\n  let resultStringIndex134 = 0;\n  let resultStringIndex135 = 0;\n  let resultStringIndex136 = 0;\n  let resultStringIndex137 = 0;\n  let resultStringIndex138 = 0;\n  let resultStringIndex139 = 0;\n  let resultStringIndex140 = 0;\n  let resultStringIndex141 = 0;\n  let resultStringIndex142 = 0;\n  let resultStringIndex143 = 0;\n  let resultStringIndex144 = 0;\n  let resultStringIndex145 = 0;\n  let resultStringIndex146 = 0;\n  let resultStringIndex147 = 0;\n  let resultStringIndex148 = 0;\n  let resultStringIndex149 = 0;\n  let resultStringIndex150 = 0;\n  let resultStringIndex151 = 0;\n  let resultStringIndex152 = 0;\n  let resultStringIndex153 = 0;\n  let resultStringIndex154 = 0;\n  let resultStringIndex155 = 0;\n  let resultStringIndex156 = 0;\n  let resultStringIndex157 = 0;\n  let resultStringIndex158 = 0;\n  let resultStringIndex159 = 0;\n  let resultStringIndex160 = 0;\n  let resultStringIndex161 = 0;\n  let resultStringIndex162 = 0;\n  let resultStringIndex163 = 0;\n  let resultStringIndex164 = 0;\n  let resultStringIndex165 = 0;\n  let resultStringIndex166 = 0;\n  let resultStringIndex167 = 0;\n  let resultStringIndex168 = 0;\n  let resultStringIndex169 = 0;\n  let resultStringIndex170 = 0;\n  let resultStringIndex171 = 0;\n  let resultStringIndex172 = 0;\n  let resultStringIndex173 = 0;\n  let resultStringIndex174 = 0;\n  let resultStringIndex175 = 0;\n  let resultStringIndex176 = 0;\n  let resultStringIndex177 = 0;\n  let resultStringIndex178 = 0;\n  let resultStringIndex179 = 0;\n  let resultStringIndex180 = 0;\n  let resultStringIndex181 = 0;\n  let resultStringIndex182 = 0;\n  let resultStringIndex183 = 0;\n  let resultStringIndex184 = 0;\n  let resultStringIndex185 = 0;\n  let resultStringIndex186 = 0;\n  let resultStringIndex187 = 0;\n  let resultStringIndex188 = 0;\n  let resultStringIndex189 = 0;\n  let resultStringIndex190 = 0;\n  let resultStringIndex191 = 0;\n  let resultStringIndex192 = 0;\n  let resultStringIndex193 = 0;\n  let resultStringIndex194 = 0;\n  let resultStringIndex195 = 0;\n  let resultStringIndex196 = 0;\n  let resultStringIndex197 = 0;\n  let resultStringIndex198 = 0;\n  let resultStringIndex199 = 0;\n  let resultStringIndex200 = 0;\n  let resultStringIndex201 = 0;\n  let resultStringIndex202 = 0;\n  let resultStringIndex203 = 0;\n  let resultStringIndex204 = 0;\n  let resultStringIndex205 = 0;\n  let resultStringIndex206 = 0;\n  let resultStringIndex207 = 0;\n", "passed": 0}
{"task_id": "JavaScript/110", "prompt": "/*In this problem, you will implement a function routine that takes two lists list of numbers, \n   and determines determine whether it is possible to perform do an exchange of elements \n   between them to make induce lst1 a list of only even numbers. \n   There is no limit on the number of exchanged commute elements between lst1 and lst2.\n   If it is possible to exchange elements element between the lst1 and lst2 to make have \n   all the elements of lst1 to be even, return \" YES \". \n   Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*In this problem, you will implement a function routine that takes two lists list of numbers, \n   and determines determine whether it is possible to perform do an exchange of elements \n   between them to make induce lst1 a list of only even numbers. \n   There is no limit on the number of exchanged commute elements between lst1 and lst2.\n   If it is possible to exchange elements element between the lst1 and lst2 to make have \n   all the elements of lst1 to be even, return \" YES \". \n   Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let result = \"NO\";\n  let lst1Length = lst1.length;\n  let lst2Length = lst2.length;\n  let lst1Index = 0;\n  let lst2Index = 0;\n  while (lst1Index < lst1Length && lst2Index < lst2Length) {\n    if (lst1[lst1Index] % 2!== lst2[lst2Index] % 2) {\n      result = result === \"YES\"? \"YES\" : \"NO\";\n      lst1Index++;\n      lst2Index++;\n    } else {\n      lst1Index++;\n      lst2Index++;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function that takes a list of numbers and a number as input. \n  If the number is a perfect square, return \"YES\". Otherwise, return \"NO\".\n  For example:\n  square([2, 7, 11, 15]) => \"YES\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, 15]) => \"NO\"\n  square([2, 7, 11, ", "passed": 0}
{"task_id": "JavaScript/111", "prompt": "/*Given a string representing a space outer space separated lowercase small letter letters, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding correspond count. \n   If several letters letter have the same occurrence happening, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Given a string representing a space outer space separated lowercase small letter letters, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding correspond count. \n   If several letters letter have the same occurrence happening, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = {}\n  let letterCounts = {}\n  let letterCount = 0\n  let letterRepeat = 0\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}\n  let letterRepeatCount = 0\n  let letterRepeatCounts = {}", "passed": 0}
{"task_id": "JavaScript/112", "prompt": "/*Task \n   We are given two strings string section s and c, you have to deleted all the characters character in s that are equal to any character fictional character in c\n   then check if the result resultant role string is palindrome. \n   A string drawstring is called palindrome if it reads the same backward as forward. \n   You should return a tuple containing hold the result string and true genuine / false fake for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Task \n   We are given two strings string section s and c, you have to deleted all the characters character in s that are equal to any character fictional character in c\n   then check if the result resultant role string is palindrome. \n   A string drawstring is called palindrome if it reads the same backward as forward. \n   You should return a tuple containing hold the result string and true genuine / false fake for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let result = []\n  let reversed = ''\n  let reversedChar = ''\n  let reversedChars = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversedCharsArray = []\n  let reversed", "passed": 0}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings, where each string consists consist of only digits, return a list.\n   Each element component i of the output should be \" the number issue of odd elements element in the \n   string i of the input stimulation. \" where all the i's should be replaced by the number \n   of odd digits finger in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Given a list of strings, where each string consists consist of only digits, return a list.\n   Each element component i of the output should be \" the number issue of odd elements element in the \n   string i of the input stimulation. \" where all the i's should be replaced by the number \n   of odd digits finger in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let result = [];\n  lst.forEach((str) => {\n    let oddCount = 0;\n    str.split('').forEach((digit) => {\n      if (digit === '1') {\n        oddCount++;\n      }\n    });\n    result.push(oddCount);\n  });\n  return result;\n};\n\n/*Given a list of strings, where each string consists consist of only digits, return a list.\n   Each element component i of the output should be \" the number issue of even elements element in the \n   string i of the input stimulation. \" where all the i's should be replaced by the number \n   of even digits finger in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let result = [];\n  lst.forEach((str) => {\n    let evenCount = 0;\n    str.split('').forEach((digit) => {\n      if (digit === '1') {\n        evenCount++;\n      }\n    });\n    result.push(evenCount);\n  });\n  return result;\n};\n\n/*Given a list of strings, where each string consists consist of only digits, return a list.\n   Each element component i of the output should be \" the number issue of odd elements element in the \n   string i of the input stimulation. \" where all the i's should be replaced by the number \n   of odd digits finger in the i'th string of the input.\n\n  >>> oddEvenCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddEvenCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddEvenCount = (lst) => {\n  let result = [];\n  lst.forEach((str) => {\n    let oddCount = 0;\n    let evenCount = 0;\n    str.split('').forEach((digit) => {\n      if (digit === '1') {\n        oddCount++;\n      }\n      if (digit === '2') {\n        evenCount++;\n      }\n    });\n    result.push(oddCount);\n    result.push(evenCount);\n  });\n  return result;\n};\n\n/*Given a list of strings, where each string consists consist of only digits, return a list.\n   Each element component i of the output should be \" the number issue of odd elements element in the \n   string i of the input stimulation. \" where all the i's should be replaced by the number \n   of odd digits finger in the i'th string of the input.\n\n  >>> oddEvenCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddEvenCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddEvenEvenCount = (lst) => {\n  let result = [];\n  lst.forEach((str) => {\n    let oddCount = 0;\n    let evenCount = 0;\n    str.split('').forEach((digit) => {\n      if (digit === '1') {\n        oddCount++;\n      }\n      if (digit === '2') {\n        evenCount++;\n      }\n    });\n    result.push(oddCount);\n    result.push(evenCount);\n    result.push(oddCount);\n    result.push(evenCount);\n  });\n  return result;\n};\n\n/*Given a list of strings, where each string consists consist of only digits, return a list.\n   Each element component i of the output should be \" the number issue of odd elements element in the \n   string i of the input stimulation. \" where all the i's should be replaced by the number \n   of odd digits finger in the i'th string of the input.\n\n  >>> oddEvenEvenCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddEvenEvenCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddEvenEvenEvenCount = (lst) => {\n  let result = [];\n  lst.forEach((str) => {\n    let oddCount = 0;\n    let evenCount = 0;\n    str.split('').forEach((digit) => {\n      if (digit === '1') {\n        oddCount++;\n      }\n      if (digit === '2') {\n        evenCount++;\n      }\n    });\n    result.push(oddCount);\n    result.push(evenCount);\n    result.push(oddCount);\n    result.push(evenCount);\n    result.push(oddCount);\n    result.push(evenCount);\n  });\n  return result;\n};\n\n/*Given a list of strings, where each string consists consist of only digits, return a list.\n   Each element component i of the output should be \" the number issue of odd elements element in the \n   string i of the input stimulation. \" where all the i's should be replaced by the number \n   of odd digits finger in the i'th string of the input.\n\n  >>> oddEvenEvenCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddEvenEvenCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddEvenEvenEvenEvenCount = (lst) => {\n  let result = [];\n  lst.forEach((str) => {\n    let oddCount = 0;\n    let evenCount = 0;\n    str.split('').forEach((digit) => {\n      if (digit === '1') {\n        oddCount++;\n      }\n      if (digit === '2') {\n        evenCount++;\n      }\n    });\n    result.push(oddCount);\n    result.push(evenCount);\n    result.push(oddCount);\n    result.push(evenCount);\n    result.push(oddCount);\n    result.push(evenCount);\n    result.push(oddCount);\n    result.push(evenCount);\n    result.push(oddCount);\n    result.push(evenCount);\n  });\n  return result;\n};\n\n/*Given a list of strings, where each string consists consist of only digits, return a list.\n   Each element component i of the output should be \" the number issue of odd elements element in the \n   string i of the input stimulation. \" where all the i's should be replaced by the number \n   of odd digits finger in the i'th string of the input.\n\n  >>> oddEvenEvenEvenCount(", "passed": 0}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an array of integers nums, find line up the minimum sum kernel of any non - empty sub - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an array of integers nums, find line up the minimum sum kernel of any non - empty sub - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let sum = 0;\n  let minSum = 0;\n  let minSubArray = [];\n  let numsLength = nums.length;\n  for (let i = 0; i < numsLength; i++) {\n    if (nums[i]!== 0) {\n      sum += nums[i];\n      minSum = Math.min(minSum, sum);\n      minSubArray.push(sum);\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given an array of integers nums, find line up the minimum sum kernel of any non - empty sub - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 3\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst maxSubArraySum = (nums) => {\n  let sum = 0;\n  let maxSum = 0;\n  let maxSubArray = [];\n  let numsLength = nums.length;\n  for (let i = 0; i < numsLength; i++) {\n    if (nums[i]!== 0) {\n      sum += nums[i];\n      maxSum = Math.max(maxSum, sum);\n      maxSubArray.push(sum);\n    }\n  }\n  return maxSum;\n};\n\n/*\n  Given an array of integers nums, find line up the minimum sum kernel of any non - empty sub - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 3\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySumOfLineUp = (nums) => {\n  let sum = 0;\n  let minSum = 0;\n  let minSubArray = [];\n  let numsLength = nums.length;\n  for (let i = 0; i < numsLength; i++) {\n    if (nums[i]!== 0) {\n      sum += nums[i];\n      minSum = Math.min(minSum, sum);\n      minSubArray.push(sum);\n    }\n  }\n  let sumOfLineUp = 0;\n  for (let i = 0; i < minSubArray.length; i++) {\n    sumOfLineUp += minSubArray[i];\n  }\n  return sumOfLineUp;\n};\n\n/*\n  Given an array of integers nums, find line up the minimum sum kernel of any non - empty sub - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 3\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst maxSubArraySumOfLineUp = (nums) => {\n  let sum = 0;\n  let maxSum = 0;\n  let maxSubArray = [];\n  let numsLength = nums.length;\n  for (let i = 0; i < numsLength; i++) {\n    if (nums[i]!== 0) {\n      sum += nums[i];\n      maxSum = Math.max(maxSum, sum);\n      maxSubArray.push(sum);\n    }\n  }\n  let sumOfLineUp = 0;\n  for (let i = 0; i < maxSubArray.length; i++) {\n    sumOfLineUp += maxSubArray[i];\n  }\n  return sumOfLineUp;\n};\n\n/*\n  Given an array of integers nums, find line up the minimum sum kernel of any non - empty sub - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 3\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySumOfLineUpOfLineUp = (nums) => {\n  let sum = 0;\n  let minSum = 0;\n  let minSubArray = [];\n  let numsLength = nums.length;\n  for (let i = 0; i < numsLength; i++) {\n    if (nums[i]!== 0) {\n      sum += nums[i];\n      minSum = Math.min(minSum, sum);\n      minSubArray.push(sum);\n    }\n  }\n  let sumOfLineUp = 0;\n  for (let i = 0; i < minSubArray.length; i++) {\n    sumOfLineUp += minSubArray[i];\n  }\n  let sumOfLineUpOfLineUp = 0;\n  for (let i = 0; i < minSubArray.length; i++) {\n    sumOfLineUpOfLineUp += minSubArray[i];\n  }\n  return sumOfLineUpOfLineUp;\n};\n\n/*\n  Given an array of integers nums, find line up the minimum sum kernel of any non - empty sub - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 3\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst maxSubArraySumOfLineUpOfLineUp = (nums) => {\n  let sum = 0;\n  let maxSum = 0;\n  let maxSubArray = [];\n  let numsLength = nums.length;\n  for (let i = 0; i < numsLength; i++) {\n    if (nums[i]!== 0) {\n      sum += nums[i];\n      maxSum = Math.max(maxSum, sum);\n      maxSubArray.push(sum);\n    }\n  }\n  let sumOfLineUp = 0;\n  for (let i = 0; i < maxSubArray.length; i++) {\n    sumOfLineUp += maxSubArray[i];\n  }\n  let sumOfLineUpOfLineUp = 0;\n  for (let i = 0; i < maxSubArray.length; i++) {\n    sumOfLineUpOfLineUp += maxSubArray[i];\n  }\n  return sumOfLineUpOfLineUp;\n};\n\n/*\n  Given an array of integers nums, find line up the minimum sum kernel of any non - empty sub - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 3\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySumOfLineUpOfLineUpOfLineUp = (nums) => {\n  let sum = 0;\n  let minSum = 0;\n  let minSubArray = [];\n  let numsLength = nums.length;\n  for (let i = 0; i < numsLength; i++) {\n    if (nums[i]!== 0) {\n      sum += nums[i];\n      minSum = Math.min(minSum, sum);\n      minSubArray.push(sum);\n    }\n  }\n  let sumOfLineUp = 0;\n  for (let i = 0; i < minSubArray.length; i++) {\n    sumOfLineUp += minSubArray[i];\n  }\n  let sumOfLineUpOfLineUpOfLineUp = 0;\n  for (let i = 0; i < minSubArray.length; i++) {\n    sumOfLineUpOfLineUpOfLineUp += minSubArray[i];\n  }\n  return sumOfLineUpOfLineUpOfLineUp;\n};\n\n/*\n  Given an array of integers nums, find line up the minimum sum kernel of any non - empty sub - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 3\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst maxSubArraySumOfLineUpOfLineUpOfLineUp = (nums) => {\n  let sum = 0;\n  let maxSum = 0;\n  let maxSubArray = [];\n  let numsLength = nums.length;\n  for (let i = 0; i < numsLength; i++) {\n    if (nums[i]!== 0) {\n      sum += nums[i];\n      maxSum = Math.max(maxSum, sum);\n      maxSubArray.push(sum);\n    }\n  }\n  let sumOfLineUp = 0;\n  for (let i = 0; i < maxSubArray.length; i++) {\n    sumOfLineUp += maxSubArray[i];\n  }\n  let sumOfLineUpOfLineUpOfLineUp = 0;\n  for (let i = 0; i < maxSubArray.length; i++) {\n    sumOfLineUpOfLineUpOfLineUp += maxSubArray[i];\n  }\n  return sumOfLineUpOfLineUpOfLineUp;\n};\n\n/*\n  Given an array of integers nums, find line up the minimum sum kernel of any non - empty sub - array \n", "passed": 0}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells well. Each row represents present a single well, \n   and each 1 in a row quarrel represents a single unmarried unit of water water system. \n   Each well has a corresponding bucket that can be used to extract water water system from it, \n   and all buckets bucket have the same capacity.\n   Your task undertaking is to use practice the buckets to empty the wells. \n   Output output signal the number phone number of times clock time you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a rectangular grid of wells well. Each row represents present a single well, \n   and each 1 in a row quarrel represents a single unmarried unit of water water system. \n   Each well has a corresponding bucket that can be used to extract water water system from it, \n   and all buckets bucket have the same capacity.\n   Your task undertaking is to use practice the buckets to empty the wells. \n   Output output signal the number phone number of times clock time you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        result += (grid[i][j] * capacity);\n      }\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/maximum-flow-problem/\n/**\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxFlow = function(grid, capacity) {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        result += (grid[i][j] * capacity);\n      }\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/maximum-flow-problem/discuss/47091/Java-Code-for-Maximum-Flow-Problem\n/**\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxFlow = function(grid, capacity) {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        result += (grid[i][j] * capacity);\n      }\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/maximum-flow-problem/discuss/47091/Java-Code-for-Maximum-Flow-Problem\n/**\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxFlow = function(grid, capacity) {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        result += (grid[i][j] * capacity);\n      }\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/maximum-flow-problem/discuss/47091/Java-Code-for-Maximum-Flow-Problem\n/**\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxFlow = function(grid, capacity) {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        result += (grid[i][j] * capacity);\n      }\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/maximum-flow-problem/discuss/47091/Java-Code-for-Maximum-Flow-Problem\n/**\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxFlow = function(grid, capacity) {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        result += (grid[i][j] * capacity);\n      }\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/maximum-flow-problem/discuss/47091/Java-Code-for-Maximum-Flow-Problem\n/**\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxFlow = function(grid, capacity) {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        result += (grid[i][j] * capacity);\n      }\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/maximum-flow-problem/discuss/47091/Java-Code-for-Maximum-Flow-Problem\n/**\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxFlow = function(grid, capacity) {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        result += (grid[i][j] * capacity);\n      }\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/maximum-flow-problem/discuss/47091/Java-Code-for-Maximum-Flow-Problem\n/**\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxFlow = function(grid, capacity) {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        result += (grid[i][j] * capacity);\n      }\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/maximum-flow-problem/discuss/47091/Java-Code-for-Maximum-Flow-Problem\n/**\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxFlow = function(grid, capacity) {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        result += (grid[i][j] * capacity);\n      }\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/maximum-flow-problem/discuss/47091/Java-Code-for-Maximum-Flow-Problem\n/**\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxFlow = function(grid, capacity) {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        result += (grid[i][j] * capacity);\n      }\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/maximum-flow-problem/discuss/47091/Java-Code-for-Maximum-Flow-Problem\n/**\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxFlow = function(grid, capacity) {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        result += (grid[i][j] * capacity);\n      }\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/maximum-flow-problem/discuss/47091/Java-Code-for-Maximum-Flow-Problem\n/**\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxFlow = function(grid, capacity) {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        result += (grid[i][j] * capacity);\n      }\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/maximum-flow-problem/discuss/47091/Java-Code-for-Maximum-Flow-Problem\n/**\n * @param {", "passed": 0}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort an array of non - negative integers integer according to \n   number numeral of ones in their binary representation theatrical performance in ascending order ordering. \n   For similar number issue of ones one, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  In this Kata, you have to sort an array of non - negative integers integer according to \n   number numeral of ones in their binary representation theatrical performance in ascending order ordering. \n   For similar number issue of ones one, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.sort((a, b) => a - b);\n  return sorted;\n};\n\n/*\n  In this Kata, you have to sort an array of non - negative integers integer according to \n   number numeral of ones in their binary representation theatrical performance in descending order ordering. \n   For similar number issue of ones one, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  In this Kata, you have to sort an array of non - negative integers integer according to \n   number numeral of ones in their binary representation theatrical performance in descending order ordering. \n   For similar number issue of ones one, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  In this Kata, you have to sort an array of non - negative integers integer according to \n   number numeral of ones in their binary representation theatrical performance in descending order ordering. \n   For similar number issue of ones one, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.sort((a, b) => a - b);\n  return sorted;\n};\n\n/*\n  In this Kata, you have to sort an array of non - negative integers integer according to \n   number numeral of ones in their binary representation theatrical performance in descending order ordering. \n   For similar number issue of ones one, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  In this Kata, you have to sort an array of non - negative integers integer according to \n   number numeral of ones in their binary representation theatrical performance in descending order ordering. \n   For similar number issue of ones one, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  In this Kata, you have to sort an array of non - negative integers integer according to \n   number numeral of ones in their binary representation theatrical performance in descending order ordering. \n   For similar number issue of ones one, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.sort((a, b) => a - b);\n  return sorted;\n};\n\n/*\n  In this Kata, you have to sort an array of non - negative integers integer according to \n   number numeral of ones in their binary representation theatrical performance in descending order ordering. \n   For similar number issue of ones one, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  In this Kata, you have to sort an array of non - negative integers integer according to \n   number numeral of ones in their binary representation theatrical performance in descending order ordering. \n   For similar number issue of ones one, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  In this Kata, you have to sort an array of non - negative integers integer according to \n   number numeral of ones in their binary representation theatrical performance in descending order ordering. \n   For similar number issue of ones one, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  In this Kata, you have to sort an array of non - negative integers integer according to \n   number numeral of ones in their binary representation theatrical performance in descending order ordering. \n   For similar number issue of ones one, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  In this Kata, you have to sort an array of non - negative integers integer according to \n   number numeral of ones in their binary representation theatrical performance in descending order ordering. \n   For similar number issue of ones one, sort based on decimal value. \n\n", "passed": 0}
{"task_id": "JavaScript/117", "prompt": "/*Given a string s and a natural number numeral n, you have been tasked to implement follow through \n   a function that returns come back a list of all words from string chain s that contain exactly precisely \n   n consonants consonant, in order these words appear look in the string bowed stringed instrument s.\n   If the string s is empty then the function should return an empty list.\n   Note: you may assume bear the input stimulation string contains control only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Given a string s and a natural number numeral n, you have been tasked to implement follow through \n   a function that returns come back a list of all words from string chain s that contain exactly precisely \n   n consonants consonant, in order these words appear look in the string bowed stringed instrument s.\n   If the string s is empty then the function should return an empty list.\n   Note: you may assume bear the input stimulation string contains control only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  let words = [];\n  let word = '';\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;", "passed": 0}
{"task_id": "JavaScript/118", "prompt": "/*You are given a word. Your task is to find line up the closest vowel that stands digest between \n   two consonants from the right proper side of the word (case sheath sensitive). \n  \n   Vowels vowel in the beginning and ending conclusion doesn't count reckon. Return render empty string bowed stringed instrument if you didn't \n   find any vowel met the above condition. \n\n   You may assume bear that the given contribute string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You are given a word. Your task is to find line up the closest vowel that stands digest between \n   two consonants from the right proper side of the word (case sheath sensitive). \n  \n   Vowels vowel in the beginning and ending conclusion doesn't count reckon. Return render empty string bowed stringed instrument if you didn't \n   find any vowel met the above condition. \n\n   You may assume bear that the given contribute string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowelsIndex = 0;\n  let vowelsLength = 0;\n  let vowelsIndex2 = 0;\n  let vowelsLength2 = 0;\n  let vowelsIndex3 = 0;\n  let vowelsLength3 = 0;\n  let vowelsIndex4 = 0;\n  let vowelsLength4 = 0;\n  let vowelsIndex5 = 0;\n  let vowelsLength5 = 0;\n  let vowelsIndex6 = 0;\n  let vowelsLength6 = 0;\n  let vowelsIndex7 = 0;\n  let vowelsLength7 = 0;\n  let vowelsIndex8 = 0;\n  let vowelsLength8 = 0;\n  let vowelsIndex9 = 0;\n  let vowelsLength9 = 0;\n  let vowelsIndex10 = 0;\n  let vowelsLength10 = 0;\n  let vowelsIndex11 = 0;\n  let vowelsLength11 = 0;\n  let vowelsIndex12 = 0;\n  let vowelsLength12 = 0;\n  let vowelsIndex13 = 0;\n  let vowelsLength13 = 0;\n  let vowelsIndex14 = 0;\n  let vowelsLength14 = 0;\n  let vowelsIndex15 = 0;\n  let vowelsLength15 = 0;\n  let vowelsIndex16 = 0;\n  let vowelsLength16 = 0;\n  let vowelsIndex17 = 0;\n  let vowelsLength17 = 0;\n  let vowelsIndex18 = 0;\n  let vowelsLength18 = 0;\n  let vowelsIndex19 = 0;\n  let vowelsLength19 = 0;\n  let vowelsIndex20 = 0;\n  let vowelsLength20 = 0;\n  let vowelsIndex21 = 0;\n  let vowelsLength21 = 0;\n  let vowelsIndex22 = 0;\n  let vowelsLength22 = 0;\n  let vowelsIndex23 = 0;\n  let vowelsLength23 = 0;\n  let vowelsIndex24 = 0;\n  let vowelsLength24 = 0;\n  let vowelsIndex25 = 0;\n  let vowelsLength25 = 0;\n  let vowelsIndex26 = 0;\n  let vowelsLength26 = 0;\n  let vowelsIndex27 = 0;\n  let vowelsLength27 = 0;\n  let vowelsIndex28 = 0;\n  let vowelsLength28 = 0;\n  let vowelsIndex29 = 0;\n  let vowelsLength29 = 0;\n  let vowelsIndex30 = 0;\n  let vowelsLength30 = 0;\n  let vowelsIndex31 = 0;\n  let vowelsLength31 = 0;\n  let vowelsIndex32 = 0;\n  let vowelsLength32 = 0;\n  let vowelsIndex33 = 0;\n  let vowelsLength33 = 0;\n  let vowelsIndex34 = 0;\n  let vowelsLength34 = 0;\n  let vowelsIndex35 = 0;\n  let vowelsLength35 = 0;\n  let vowelsIndex36 = 0;\n  let vowelsLength36 = 0;\n  let vowelsIndex37 = 0;\n  let vowelsLength37 = 0;\n  let vowelsIndex38 = 0;\n  let vowelsLength38 = 0;\n  let vowelsIndex39 = 0;\n  let vowelsLength39 = 0;\n  let vowelsIndex40 = 0;\n  let vowelsLength40 = 0;\n  let vowelsIndex41 = 0;\n  let vowelsLength41 = 0;\n  let vowelsIndex42 = 0;\n  let vowelsLength42 = 0;\n  let vowelsIndex43 = 0;\n  let vowelsLength43 = 0;\n  let vowelsIndex44 = 0;\n  let vowelsLength44 = 0;\n  let vowelsIndex45 = 0;\n  let vowelsLength45 = 0;\n  let vowelsIndex46 = 0;\n  let vowelsLength46 = 0;\n  let vowelsIndex47 = 0;\n  let vowelsLength47 = 0;\n  let vowelsIndex48 = 0;\n  let vowelsLength48 = 0;\n  let vowelsIndex49 = 0;\n  let vowelsLength49 = 0;\n  let vowelsIndex50 = 0;\n  let vowelsLength50 = 0;\n  let vowelsIndex51 = 0;\n  let vowelsLength51 = 0;\n  let vowelsIndex52 = 0;\n  let vowelsLength52 = 0;\n  let vowelsIndex53 = 0;\n  let vowelsLength53 = 0;\n  let vowelsIndex54 = 0;\n  let vowelsLength54 = 0;\n  let vowelsIndex55 = 0;\n  let vowelsLength55 = 0;\n  let vowelsIndex56 = 0;\n  let vowelsLength56 = 0;\n  let vowelsIndex57 = 0;\n  let vowelsLength57 = 0;\n  let vowelsIndex58 = 0;\n  let vowelsLength58 = 0;\n  let vowelsIndex59 = 0;\n  let vowelsLength59 = 0;\n  let vowelsIndex60 = 0;\n  let vowelsLength60 = 0;\n  let vowelsIndex61 = 0;\n  let vowelsLength61 = 0;\n  let vowelsIndex62 = 0;\n  let vowelsLength62 = 0;\n  let vowelsIndex63 = 0;\n  let vowelsLength63 = 0;\n  let vowelsIndex64 = 0;\n  let vowelsLength64 = 0;\n  let vowelsIndex65 = 0;\n  let vowelsLength65 = 0;\n  let vowelsIndex66 = 0;\n  let vowelsLength66 = 0;\n  let vowelsIndex67 = 0;\n  let vowelsLength67 = 0;\n  let vowelsIndex68 = 0;\n  let vowelsLength68 = 0;\n  let vowelsIndex69 = 0;\n  let vowelsLength69 = 0;\n  let vowelsIndex70 = 0;\n  let vowelsLength70 = 0;\n  let vowelsIndex71 = 0;\n  let vowelsLength71 = 0;\n  let vowelsIndex72 = 0;\n  let vowelsLength72 = 0;\n  let vowelsIndex73 = 0;\n  let vowelsLength73 = 0;\n  let vowelsIndex74 = 0;\n  let vowelsLength74 = 0;\n  let vowelsIndex75 = 0;\n  let vowelsLength75 = 0;\n  let vowelsIndex76 = 0;\n  let vowelsLength76 = 0;\n  let vowelsIndex77 = 0;\n  let vowelsLength77 = 0;\n  let vowelsIndex78 = 0;\n  let vowelsLength78 = 0;\n  let vowelsIndex79 = 0;\n  let vowelsLength79 = 0;\n  let vowelsIndex80 = 0;\n  let vowelsLength80 = 0;\n  let vowelsIndex81 = 0;\n  let vowelsLength81 = 0;\n  let vowelsIndex82 = 0;\n  let vowelsLength82 = 0;\n  let vowelsIndex83 = 0;\n  let vowelsLength83 = 0;\n  let vowelsIndex84 = 0;\n  let vowelsLength84 = 0;\n  let vowelsIndex85 = 0;\n  let vowelsLength85 = 0;\n  let vowelsIndex86 = 0;\n  let vowelsLength86 = 0;\n  let vowelsIndex87 = 0;\n  let vowelsLength87 = 0;\n  let vowelsIndex88 = 0;\n  let vowelsLength88 = 0;\n  let vowelsIndex89 = 0;\n  let vowelsLength89 = 0;\n  let vowelsIndex90 = 0;\n  let vowelsLength90 = 0;\n  let vowelsIndex91 = 0;\n  let vowelsLength91 = 0;\n  let vowelsIndex92 = 0;\n  let vowelsLength92 = 0;\n  let vowelsIndex93 = 0;\n  let vowelsLength93 = 0;\n  let vowelsIndex94 = 0;\n  let vowelsLength94 = 0;\n  let vowelsIndex95 = 0;\n  let vowelsLength95 = 0;\n  let vowelsIndex96 = 0;\n  let vowelsLength96 = 0;\n  let vowelsIndex97 = 0;\n  let vowelsLength97 = 0;\n", "passed": 0}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list of two strings, both strings string section consist of open candid \n   parentheses' (' or close airless parentheses')' only. \n   Your job problem is to check if it is possible potential to concatenate the two strings bowed stringed instrument in\n   some order, that the resulting string chain will be good estimable. \n   A string S is considered to be good if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* You are given a list of two strings, both strings string section consist of open candid \n   parentheses' (' or close airless parentheses')' only. \n   Your job problem is to check if it is possible potential to concatenate the two strings bowed stringed instrument in\n   some order, that the resulting string chain will be good estimable. \n   A string S is considered to be good if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let result = 'No'\n  \n  // 1. Find all open parenthesis in lst\n  let openParenthesis = lst.filter(item => item.includes('('))\n  \n  // 2. Find all close parenthesis in lst\n  let closeParenthesis = lst.filter(item => item.includes(')'))\n  \n  // 3. Find all open parenthesis in lst and close parenthesis in closeParenthesis\n  let openParenthesisClose = lst.filter(item => item.includes('(') && item.includes(')'))\n  \n  // 4. Find all open parenthesis in lst and close parenthesis in openParenthesis\n  let openParenthesisOpen = lst.filter(item => item.includes('(') && item.includes(')'))\n  \n  // 5. Find all open parenthesis in lst and close parenthesis in openParenthesis\n  let openParenthesisCloseOpen = lst.filter(item => item.includes('(') && item.includes(')'))\n  \n  // 6. Find all open parenthesis in lst and close parenthesis in openParenthesis\n  let openParenthesisCloseClose = lst.filter(item => item.includes('(') && item.includes(')'))\n  \n  // 7. Find all open parenthesis in lst and close parenthesis in openParenthesis\n  let openParenthesisCloseCloseOpen = lst.filter(item => item.includes('(') && item.includes(')'))\n  \n  // 8. Find all open parenthesis in lst and close parenthesis in openParenthesis\n  let openParenthesisCloseCloseCloseOpen = lst.filter(item => item.includes('(') && item.includes(')'))\n  \n  // 9. Find all open parenthesis in lst and close parenthesis in openParenthesis\n  let openParenthesisCloseCloseCloseClose = lst.filter(item => item.includes('(') && item.includes(')'))\n  \n  // 10. Find all open parenthesis in lst and close parenthesis in openParenthesis\n  let openParenthesisCloseCloseCloseOpen = lst.filter(item => item.includes('(') && item.includes(')'))\n  \n  // 11. Find all open parenthesis in lst and close parenthesis in openParenthesis\n  let openParenthesisCloseCloseCloseCloseOpen = lst.filter(item => item.includes('(') && item.includes(')'))\n  \n  // 12. Find all open parenthesis in lst and close parenthesis in openParenthesis\n  let openParenthesisCloseCloseCloseClose = lst.filter(item => item.includes('(') && item.includes(')'))\n  \n  // 13. Find all open parenthesis in lst and close parenthesis in openParenthesis\n  let openParenthesisCloseCloseCloseCloseOpen = lst.filter(item => item.includes('(') && item.includes(')'))\n  \n  // 14. Find all open parenthesis in lst and close parenthesis in openParenthesis\n  let openParenthesisCloseCloseCloseCloseClose = lst.filter(item => item.includes('(') && item.includes(')'))\n  \n  // 15. Find all open parenthesis in lst and close parenthesis in openParenthesis\n  let openParenthesisCloseCloseCloseCloseOpen = lst.filter(item => item.includes('(') && item.includes(')'))\n  \n  // 16. Find all open parenthesis in lst and close parenthesis in openParenthesis\n  let openParenthesisCloseCloseCloseClose = lst.filter(item => item.includes('(') && item.includes(')'))\n  \n  // 17. Find all open parenthesis in lst and close parenthesis in openParenthesis\n  let openParenthesisCloseCloseCloseCloseOpen = lst.filter(item => item.includes('(') && item.includes(')'))\n  \n  // 18. Find all open parenthesis in lst and close parenthesis in openParenthesis\n  let openParenthesisCloseCloseCloseClose = lst.filter(item => item.includes('(') && item.includes(')'))\n  \n  // 19. Find all open parenthesis in lst and close parenthesis in openParenthesis\n  let openParenthesisCloseCloseCloseCloseOpen = lst.filter(item => item.includes('(') && item.includes(')'))\n  \n  // 20. Find all open parenthesis in lst and close parenthesis in openParenthesis\n  let openParenthesisCloseCloseCloseClose = lst.filter(item => item.includes('(') && item.includes(')'))\n  \n  // 21. Find all open parenthesis in lst and close parenthesis in openParenthesis\n  let openParenthesisCloseCloseCloseCloseOpen = lst.filter(item => item.includes('(') && item.includes(')'))\n  \n  // 22. Find all open parenthesis in lst and close parenthesis in openParenthesis\n  let openParenthesisCloseCloseCloseClose = lst.filter(item => item.includes('(') && item.includes(')'))\n  \n  // 23. Find all open parenthesis in lst and close parenthesis in openParenthesis\n  let openParenthesisCloseCloseCloseCloseOpen = lst.filter(item => item.includes('(') && item.includes(')'))\n  \n  // 24. Find all open parenthesis in lst and close parenthesis in openParenthesis\n  let openParenthesisCloseCloseCloseClose = lst.filter(item => item.includes('(') && item.includes(')'))\n  \n  // 25. Find all open parenthesis in lst and close parenthesis in openParenthesis\n  let openParenthesisCloseCloseCloseCloseOpen = lst.filter(item => item.includes('(') && item.includes(')'))\n  \n  // 26. Find all open parenthesis in lst and close parenthesis in openParenthesis\n  let openParenthesisCloseCloseCloseClose = lst.filter(item => item.includes('(') && item.includes(')'))\n  \n  // 27. Find all open parenthesis in lst and close parenthesis in openParenthesis\n  let openParenthesisCloseCloseCloseCloseOpen = lst.filter(item => item.includes('(') && item.includes(')'))\n  \n  // 28. Find all open parenthesis in lst and close parenthesis in openParenthesis\n  let openParenthesisCloseCloseCloseClose = lst.filter(item => item.includes('(') && item.includes(')'))\n  \n  // 29. Find all open parenthesis in lst and close parenthesis in openParenthesis\n  let openParenthesisCloseCloseCloseCloseOpen = lst.filter(item => item.include", "passed": 1}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Return the first one in case event of multiple \n   strings of the same length. Return null nothing in case the input input signal list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Out of list of strings, return the longest one. Return the first one in case event of multiple \n   strings of the same length. Return null nothing in case the input input signal list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n  let longestString = ''\n  let longestLength = 0\n  for (let i = 0; i < strings.length; i++) {\n    const string = strings[i]\n    if (string.length > longestLength) {\n      longestString = string\n      longestLength = string.length\n    }\n  }\n  return longestString\n}\n\n/* Given a signal list, return the list of all possible combinations of signals \n   that have all their values equals to some value. \n  >>> allCombinations([1, 2, 3, 4], 2)\n  [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n  >>> allCombinations([1, 2, 3, 4], 3)\n  [[1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4], [1, 4, 3], [1, 4, 4], [2, 4, 3], [2, 4, 4], [3, 4, 4]]\n  >>> allCombinations([1, 2, 3, 4], 4)\n  [[1, 2, 3, 4], [1, 3, 4], [2, 3, 4], [2, 4, 4], [3, 4, 4]]\n  >>> allCombinations([1, 2, 3, 4], 5)\n  [[1, 2, 3, 4], [1, 3, 4], [2, 3, 4], [2, 4, 4], [3, 4, 5], [1, 4, 5], [1, 5, 4], [2, 4, 5], [2, 5, 4], [3, 4, 5], [4, 5, 4], [1, 5, 5], [1, 5, 6], [2, 4, 5], [2, 5, 6], [3, 4, 5], [4, 5, 6], [1, 5, 7], [1, 5, 8], [1, 5, 9], [1, 5, 10], [1, 5, 11], [1, 5, 12], [1, 5, 13], [1, 5, 14], [1, 5, 15], [1, 5, 16], [1, 5, 17], [1, 5, 18], [1, 5, 19], [1, 5, 20], [1, 5, 21], [1, 5, 22], [1, 5, 23], [1, 5, 24], [1, 5, 25], [1, 5, 26], [1, 5, 27], [1, 5, 28], [1, 5, 29], [1, 5, 30], [1, 5, 31], [1, 5, 32], [1, 5, 33], [1, 5, 34], [1, 5, 35], [1, 5, 36], [1, 5, 37], [1, 5, 38], [1, 5, 39], [1, 5, 40], [1, 5, 41], [1, 5, 42], [1, 5, 43], [1, 5, 44], [1, 5, 45], [1, 5, 46], [1, 5, 47], [1, 5, 48], [1, 5, 49], [1, 5, 50], [1, 5, 51], [1, 5, 52], [1, 5, 53], [1, 5, 54], [1, 5, 55], [1, 5, 56], [1, 5, 57], [1, 5, 58], [1, 5, 59], [1, 5, 60], [1, 5, 61], [1, 5, 62], [1, 5, 63], [1, 5, 64], [1, 5, 65], [1, 5, 66], [1, 5, 67], [1, 5, 68], [1, 5, 69], [1, 5, 70], [1, 5, 71], [1, 5, 72], [1, 5, 73], [1, 5, 74], [1, 5, 75], [1, 5, 76], [1, 5, 77], [1, 5, 78], [1, 5, 79], [1, 5, 80], [1, 5, 81], [1, 5, 82], [1, 5, 83], [1, 5, 84], [1, 5, 85], [1, 5, 86], [1, 5, 87], [1, 5, 88], [1, 5, 89], [1, 5, 90], [1, 5, 91], [1, 5, 92], [1, 5, 93], [1, 5, 94], [1, 5, 95], [1, 5, 96], [1, 5, 97], [1, 5, 98], [1, 5, 99], [1, 5, 100], [1, 5, 101], [1, 5, 102], [1, 5, 103], [1, 5, 104], [1, 5, 105], [1, 5, 106], [1, 5, 107], [1, 5, 108], [1, 5, 109], [1, 5, 110], [1, 5, 111], [1, 5, 112], [1, 5, 113], [1, 5, 114], [1, 5, 115], [1, 5, 116], [1, 5, 117], [1, 5, 118], [1, 5, 119], [1, 5, 120], [1, 5, 121], [1, 5, 122], [1, 5, 123], [1, 5, 124], [1, 5, 125], [1, 5, 126], [1, 5, 127], [1, 5, 128], [1, 5, 129], [1, 5, 130], [1, 5, 131], [1, 5, 132], [1, 5, 133], [1, 5, 134], [1, 5, 135], [1, 5, 136], [1, 5, 137], [1, 5, 138], [1, 5, 139], [1, 5, 140], [1, 5, 141], [1, 5, 142], [1, 5, 143], [1, 5, 144], [1, 5, 145], [1, 5, 146], [1, 5, 147], [1, 5, 148], [1, 5, 149], [1, 5, 150], [1, 5, 151], [1, 5, 152], [1, 5, 153], [1, 5, 154], [1, 5, 155], [1, 5, 156], [1, 5, 157], [1, 5, 158], [1, 5, 159], [1, 5, 160], [1, 5, 161], [1, 5, 162], [1, 5, 163], [1, 5, 164], [1, 5, 165], [1, 5, 166], [1, 5, 167], [1, 5, 168], [1, 5, 169], [1, 5, 170], [1, 5, 171], [1, 5, 172], [1, 5, 173], [1, 5, 174], [1, 5, 175], [1, 5, 176], [1, 5, 177], [1, 5, 178], [1, 5, 179], [1, 5, 180], [1, 5, 181], [1, 5, 182], [1, 5, 183], [1, 5, 184], [1, 5, 185], [1, 5, 186], [1, 5, 187], [1, 5, 188], [1, 5, 189], [1, 5, 190], [1, 5, 191], [1, 5, 192], [1, 5, 193], [1, 5, 194], [1, 5, 195], [1, 5, 196], [1, 5, 197], [1, 5, 198], [1, 5, 199], [1, 5, 200], [1, 5, 201], [1, 5, 202], [1, 5, 203], [1, 5, 204], [1, 5, 205], [1, 5, 206], [1, 5, 207], [1, 5, 208], [1, 5, 209], [1, 5, 210], [1, 5, 211], [1, 5, 212], [1, 5, 213], [1, 5, 214], [1, 5, 215], [1, 5, 216], [1, 5, 217], [1, 5, 218], [1, 5, 219], [1, 5, 220], [1, 5, 221], [1, 5, 222], [1, 5, 223], [1, 5, 224], [1, 5, 225], [1, 5, 226], [1, 5, 227], [1, 5, 228], [1, 5, 229], [1, 5, 230], [1, 5, 231], [1, 5, 232], [1, 5, 233], [1, 5, 234], [1, 5, 235], [1, 5, 236], [1, 5, 237], [1, 5, 238], [1, 5, 239], [1, 5, 240], [1, 5, 241], [1, 5, 242], [1, 5, 243], [1, 5, 244], [1, 5, 245], [1, 5, 246], [1, 5, 247], [1, 5, 248], [1, 5, 249], [1, 5, 250], [1, 5, 251], [1, 5, 252], [1, 5, 253], [1, 5, 254], [1, 5, 255], [1, 5, 256], [1, 5, 257], [1, 5, 258], [1, 5, 259], [1, 5, 260], [1, 5, 261], [1, 5, 262], [1, 5, 263], [1, 5, 264], [1, 5, 265], [1, 5, 266], [1, 5, 267], [1, 5, 268], [1, 5, 269], [1, 5, 270], [1, 5, 271], [1, 5, 272], [1, 5, 273], [1, 5, 274], [1, 5, 275], [1, 5, 276], [1, 5, 277], [1, 5, 278], [1, 5, 279], [1, 5, 280], [1, 5, 281], [1, 5, 282], [1, 5, 283], [1, 5, 284], [1, 5, 285], [1, 5, 286], [1, 5, 287], [1, 5, 288], [1, 5, 289], [1, 5, 290], [1, 5, 291], [1, 5, 292], [1, 5, 293], [1, 5, 294], [1, 5, 295], [1, 5, 296], [1, 5, 297], [1, 5, 298], [1, 5, 299], [1, 5, 300], [1, 5, 301], [1, 5, 302], [1, 5, 303], [1, 5, 304], [1, 5, 305], [1, 5, 306], [1, 5, 307], [1, ", "passed": 0}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an array arr of integers and a positive convinced integer k, return a sorted list \n   of length distance k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an array arr of integers and a positive convinced integer k, return a sorted list \n   of length distance k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  let len = arr.length;\n  let max = 0;\n  let result = [];\n  let i = -1;\n  let j = 0;\n  while (++i < len) {\n    if (arr[i] > max) {\n      max = arr[i];\n      result.push(max);\n    }\n  }\n  while (++j < len) {\n    if (arr[j] > max) {\n      max = arr[j];\n      result.push(max);\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum/\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar findMaxSubArraySum = function(nums, target) {\n  let result = [];\n  let len = nums.length;\n  let max = 0;\n  let i = -1;\n  let j = 0;\n  while (++i < len) {\n    if (nums[i] > max) {\n      max = nums[i];\n      result.push(max);\n    }\n  }\n  while (++j < len) {\n    if (nums[j] > max) {\n      max = nums[j];\n      result.push(max);\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-ii/\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar findMaxSubArraySumII = function(nums, target) {\n  let result = [];\n  let len = nums.length;\n  let max = 0;\n  let i = -1;\n  let j = 0;\n  while (++i < len) {\n    if (nums[i] > max) {\n      max = nums[i];\n      result.push(max);\n    }\n  }\n  while (++j < len) {\n    if (nums[j] > max) {\n      max = nums[j];\n      result.push(max);\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iii/\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar findMaxSubArraySumIII = function(nums, target) {\n  let result = [];\n  let len = nums.length;\n  let max = 0;\n  let i = -1;\n  let j = 0;\n  while (++i < len) {\n    if (nums[i] > max) {\n      max = nums[i];\n      result.push(max);\n    }\n  }\n  while (++j < len) {\n    if (nums[j] > max) {\n      max = nums[j];\n      result.push(max);\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar findMaxSubArraySumIV = function(nums, target) {\n  let result = [];\n  let len = nums.length;\n  let max = 0;\n  let i = -1;\n  let j = 0;\n  while (++i < len) {\n    if (nums[i] > max) {\n      max = nums[i];\n      result.push(max);\n    }\n  }\n  while (++j < len) {\n    if (nums[j] > max) {\n      max = nums[j];\n      result.push(max);\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar findMaxSubArraySumV = function(nums, target) {\n  let result = [];\n  let len = nums.length;\n  let max = 0;\n  let i = -1;\n  let j = 0;\n  while (++i < len) {\n    if (nums[i] > max) {\n      max = nums[i];\n      result.push(max);\n    }\n  }\n  while (++j < len) {\n    if (nums[j] > max) {\n      max = nums[j];\n      result.push(max);\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-vi/\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar findMaxSubArraySumVI = function(nums, target) {\n  let result = [];\n  let len = nums.length;\n  let max = 0;\n  let i = -1;\n  let j = 0;\n  while (++i < len) {\n    if (nums[i] > max) {\n      max = nums[i];\n      result.push(max);\n    }\n  }\n  while (++j < len) {\n    if (nums[j] > max) {\n      max = nums[j];\n      result.push(max);\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-vii/\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar findMaxSubArraySumVII = function(nums, target) {\n  let result = [];\n  let len = nums.length;\n  let max = 0;\n  let i = -1;\n  let j = 0;\n  while (++i < len) {\n    if (nums[i] > max) {\n      max = nums[i];\n      result.push(max);\n    }\n  }\n  while (++j < len) {\n    if (nums[j] > max) {\n      max = nums[j];\n      result.push(max);\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-viii/\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar findMaxSubArraySumVIII = function(nums, target) {\n  let result = [];\n  let len = nums.length;\n  let max = 0;\n  let i = -1;\n  let j = 0;\n  while (++i < len) {\n    if (nums[i] > max) {\n      max = nums[i];\n      result.push(max);\n    }\n  }\n  while (++j < len) {\n    if (nums[j] > max) {\n      max = nums[j];\n      result.push(max);\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar findMaxSubArraySumIV = function(nums, target) {\n  let result = [];\n  let len = nums.length;\n  let max = 0;\n  let i = -1;\n  let j = 0;\n  while (++i < len) {\n    if (nums[i] > max) {\n      max = nums[i];\n      result.push(max);\n    }\n  }\n  while (++j < len) {\n    if (nums[j] > max) {\n      max = nums[j];\n      result.push(max);\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar findMaxSubArraySumVV = function(nums, target) {\n  let result = [];\n  let len = nums.length;\n  let max = 0;\n", "passed": 0}
{"task_id": "JavaScript/121", "prompt": "/*Given a non - empty list of integers, return the sum of all of the odd curious elements that are in even positions position.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Given a non - empty list of integers, return the sum of all of the odd curious elements that are in even positions position.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],4:[function(require,module,exports){\n/*\n  Implement a function that takes an array of integers and returns the sum of all the even numbers that are in odd positions position. \n  \n  Examples\n  evenSum([5, 8, 7, 1]) ==> 12\n  evenSum([3, 3, 3, 3, 3]) ==> 9\n  evenSum([30, 13, 24, 321]) ==>0\n  */\nconst evenSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  evenSum,\n};\n\n},{}],5:[function(require,module,exports){\n/*\n  Implement a function that takes an array of integers and returns the sum of all the odd numbers that are in even positions position. \n  \n  Examples\n  oddSum([5, 8, 7, 1]) ==> 12\n  oddSum([3, 3, 3, 3, 3]) ==> 9\n  oddSum([30, 13, 24, 321]) ==>0\n  */\nconst oddSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  oddSum,\n};\n\n},{}],6:[function(require,module,exports){\n/*\n  Implement a function that takes an array of integers and returns the sum of all the even numbers that are in odd positions position. \n  \n  Examples\n  evenSum([5, 8, 7, 1]) ==> 12\n  evenSum([3, 3, 3, 3, 3]) ==> 9\n  evenSum([30, 13, 24, 321]) ==>0\n  */\nconst evenSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  evenSum,\n};\n\n},{}],7:[function(require,module,exports){\n/*\n  Implement a function that takes an array of integers and returns the sum of all the even numbers that are in even positions position. \n  \n  Examples\n  evenSum([5, 8, 7, 1]) ==> 12\n  evenSum([3, 3, 3, 3, 3]) ==> 9\n  evenSum([30, 13, 24, 321]) ==>0\n  */\nconst evenSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  evenSum,\n};\n\n},{}],8:[function(require,module,exports){\n/*\n  Implement a function that takes an array of integers and returns the sum of all the odd numbers that are in even positions position. \n  \n  Examples\n  oddSum([5, 8, 7, 1]) ==> 12\n  oddSum([3, 3, 3, 3, 3]) ==> 9\n  oddSum([30, 13, 24, 321]) ==>0\n  */\nconst oddSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  oddSum,\n};\n\n},{}],9:[function(require,module,exports){\n/*\n  Implement a function that takes an array of integers and returns the sum of all the even numbers that are in odd positions position. \n  \n  Examples\n  evenSum([5, 8, 7, 1]) ==> 12\n  evenSum([3, 3, 3, 3, 3]) ==> 9\n  evenSum([30, 13, 24, 321]) ==>0\n  */\nconst evenSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  evenSum,\n};\n\n},{}],10:[function(require,module,exports){\n/*\n  Implement a function that takes an array of integers and returns the sum of all the even numbers that are in odd positions position. \n  \n  Examples\n  evenSum([5, 8, 7, 1]) ==> 12\n  evenSum([3, 3, 3, 3, 3]) ==> 9\n  evenSum([30, 13, 24, 321]) ==>0\n  */\nconst evenSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  evenSum,\n};\n\n},{}],11:[function(require,module,exports){\n/*\n  Implement a function that takes an array of integers and returns the sum of all the even numbers that are in odd positions position. \n  \n  Examples\n  evenSum([5, 8, 7, 1]) ==> 12\n  evenSum([3, 3, 3, 3, 3]) ==> 9\n  evenSum([30, 13, 24, 321]) ==>0\n  */\nconst evenSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  evenSum,\n};\n\n},{}],12:[function(require,module,exports){\n/*\n  Implement a function that takes an array of integers and returns the sum of all the even numbers that are in odd positions position. \n  \n  Examples\n  evenSum([5, 8, 7, 1]) ==> 12\n  evenSum([3, 3, 3, 3, 3]) ==> 9\n  evenSum([30, 13, 24, 321]) ==>0\n  */\nconst evenSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  evenSum,\n};\n\n},{}],13:[function(require,module,exports){\n/*\n  Implement a function that takes an array of integers and returns the sum of all the even numbers that are in odd positions position. \n  \n  Examples\n  evenSum([5, 8, 7, 1]) ==> 12\n  evenSum([3, 3, 3, 3, 3]) ==> 9\n  evenSum([30, 13, 24, 321]) ==>0\n  */\nconst evenSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  evenSum,\n};\n\n},{}],14:[function(require,module,exports){\n/*\n  Implement a function that takes an array of integers and returns the sum of all the even numbers that are in odd positions position. \n  \n  Examples\n  evenSum([5, 8, 7, 1]) ==> 12\n  evenSum([3, 3, 3, 3, 3]) ==> 9\n  evenSum([30, 13, 24, 321]) ==>0\n  */\nconst evenSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {", "passed": 0}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a non - empty array of integers arr and an integer k, return\n   the sum kernel of the elements with at most two digits digit from the first k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a non - empty array of integers arr and an integer k, return\n   the sum kernel of the elements with at most two digits digit from the first k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non - empty array of integers arr and an integer k, return\n   the sum kernel of the elements with at most three digits digit from the first k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 120 # sum of 111 + 21\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non - empty array of integers arr and an integer k, return\n   the sum kernel of the elements with at most four digits digit from the first k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 240 # sum of 111 + 21 * 2 + 3 * 3 + 4 * 4\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non - empty array of integers arr and an integer k, return\n   the sum kernel of the elements with at most five digits digit from the first k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 2400 # sum of 111 + 21 * 2 + 3 * 3 + 4 * 4 + 5 * 5\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non - empty array of integers arr and an integer k, return\n   the sum kernel of the elements with at most six digits digit from the first k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 240000 # sum of 111 + 21 * 2 + 3 * 3 + 4 * 4 + 5 * 5 + 6 * 6 + 7 * 7 + 8 * 8 + 9 * 9\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non - empty array of integers arr and an integer k, return\n   the sum kernel of the elements with at most seven digits digit from the first k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 2400000 # sum of 111 + 21 * 2 + 3 * 3 + 4 * 4 + 5 * 5 + 6 * 6 + 7 * 7 + 8 * 8 + 9 * 9 + 10 * 10\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non - empty array of integers arr and an integer k, return\n   the sum kernel of the elements with at most eight digits digit from the first k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24000000 # sum of 111 + 21 * 2 + 3 * 3 + 4 * 4 + 5 * 5 + 6 * 6 + 7 * 7 + 8 * 8 + 9 * 9 + 10 * 10 + 11 * 11 + 12 * 12 + 13 * 13 + 14 * 14 + 15 * 15\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non - empty array of integers arr and an integer k, return\n   the sum kernel of the elements with at most nine digits digit from the first k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 240000000 # sum of 111 + 21 * 2 + 3 * 3 + 4 * 4 + 5 * 5 + 6 * 6 + 7 * 7 + 8 * 8 + 9 * 9 + 10 * 10 + 11 * 11 + 12 * 12 + 13 * 13 + 14 * 14 + 15 * 15 + 16 * 16 + 17 * 17 + 18 * 18 + 19 * 19\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non - empty array of integers arr and an integer k, return\n   the sum kernel of the elements with at most ten digits digit from the first k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 240000000 # sum of 111 + 21 * 2 + 3 * 3 + 4 * 4 + 5 * 5 + 6 * 6 + 7 * 7 + 8 * 8 + 9 * 9 + 10 * 10 + 11 * 11 + 12 * 12 + 13 * 13 + 14 * 14 + 15 * 15 + 16 * 16 + 17 * 17 + 18 * 18 + 19 * 19 + 20 * 20\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {", "passed": 0}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a positive integer n, return a sorted classify list that has the odd numbers numeral in collatz sequence. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns refer a sequence defined specify \n   as follows play along: start startle with any positive positivist integer n. Then each term terminus is obtained from the \n   previous term as follows follow: if the previous term condition is even, the next following term is one half of \n   the previous term. If the previous term terminus is odd, the next future term condition is 3 times the previous former \n   term plus 1. The conjecture is that no matter what value of n, the sequence will always constantly reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a positive integer n, return a sorted classify list that has the odd numbers numeral in collatz sequence. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns refer a sequence defined specify \n   as follows play along: start startle with any positive positivist integer n. Then each term terminus is obtained from the \n   previous term as follows follow: if the previous term condition is even, the next following term is one half of \n   the previous term. If the previous term terminus is odd, the next future term condition is 3 times the previous former \n   term plus 1. The conjecture is that no matter what value of n, the sequence will always constantly reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let collatz = [];\n  let i = 1;\n  while (i * 2 <= n) {\n    collatz.push(i);\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted classify list that has the even numbers numeral in collatz sequence. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns refer a sequence defined specify \n   as follows play along: start startle with any positive positivist integer n. Then each term terminus is obtained from the \n   previous term as follows follow: if the previous term condition is even, the next following term is one half of \n   the previous term. If the previous term terminus is odd, the next future term condition is 3 times the previous former \n   term plus 1. The conjecture is that no matter what value of n, the sequence will always constantly reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 1, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  let collatz = [];\n  let i = 1;\n  while (i * 2 >= n) {\n    collatz.push(i);\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted classify list that has the prime numbers numeral in collatz sequence. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns refer a sequence defined specify \n   as follows play along: start startle with any positive positivist integer n. Then each term terminus is obtained from the \n   previous term as follows follow: if the previous term condition is even, the next following term is one half of \n   the previous term. If the previous term terminus is odd, the next future term condition is 3 times the previous former \n   term plus 1. The conjecture is that no matter what value of n, the sequence will always constantly reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the prime numbers are only 1, and 5.\n  */\nconst getPrimeCollatz = (n) => {\n  let collatz = [];\n  let i = 1;\n  while (i * 2 <= n) {\n    collatz.push(i);\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted classify list that has the prime numbers numeral in collatz sequence. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns refer a sequence defined specify \n   as follows play along: start startle with any positive positivist integer n. Then each term terminus is obtained from the \n   previous term as follows follow: if the previous term condition is even, the next following term is one half of \n   the previous term. If the previous term terminus is odd, the next future term condition is 3 times the previous former \n   term plus 1. The conjecture is that no matter what value of n, the sequence will always constantly reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the prime numbers are only 1, and 5.\n  */\nconst getPrimeCollatz = (n) => {\n  let collatz = [];\n  let i = 1;\n  while (i * 2 >= n) {\n    collatz.push(i);\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted classify list that has the prime numbers numeral in collatz sequence. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns refer a sequence defined specify \n   as follows play along: start startle with any positive positivist integer n. Then each term terminus is obtained from the \n   previous term as follows follow: if the previous term condition is even, the next following term is one half of \n   the previous term. If the previous term terminus is odd, the next future term condition is 3 times the previous former \n   term plus 1. The conjecture is that no matter what value of n, the sequence will always constantly reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the prime numbers are only 1, and 5.\n  */\nconst getPrimeCollatz = (n) => {\n  let collatz = [];\n  let i = 1;\n  while (i * 2 <= n) {\n    collatz.push(i);\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted classify list that has the prime numbers numeral in collatz sequence. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns refer a sequence defined specify \n   as follows play along: start startle with any positive positivist integer n. Then each term terminus is obtained from the \n   previous term as follows follow: if the previous term condition is even, the next following term is one half of \n   the previous term. If the previous term terminus is odd, the next future term condition is 3 times the previous former \n   term plus 1. The conjecture is that no matter what value of n, the sequence will always constantly reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the prime numbers are only 1, and 5.\n  */\nconst getPrimeCollatz = (n) => {\n  let col", "passed": 0}
{"task_id": "JavaScript/124", "prompt": "/*You have to write a function which validates validate a given date string bowed stringed instrument and \n   returns true truthful if the date is valid otherwise false delusive. \n   The date is valid if all of the following rules dominion are satisfied quenched: \n   1. The date string is not empty. \n   2. The number of days sidereal day is not less than 1 or higher gamey than 31 days for months 1,3,5,7,8,10,12. And the number of days day is not less than 1 or higher eminent than 30 days for months month 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2. \n   3. The months should not be less than 1 or higher eminent than 12. \n   4. The date should be in the format: mm - dd doctor of divinity - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You have to write a function which validates validate a given date string bowed stringed instrument and \n   returns true truthful if the date is valid otherwise false delusive. \n   The date is valid if all of the following rules dominion are satisfied quenched: \n   1. The date string is not empty. \n   2. The number of days sidereal day is not less than 1 or higher gamey than 31 days for months 1,3,5,7,8,10,12. And the number of days day is not less than 1 or higher eminent than 30 days for months month 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2. \n   3. The months should not be less than 1 or higher eminent than 12. \n   4. The date should be in the format: mm - dd doctor of divinity - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const [month, day, year] = date.split('-');\n  const [doctor, divinity, yearOfBirth] = year.split('-');\n  const [doctorOfDivinity, divinityOfBirth] = divinity.split('-');\n  const [yearOfBirthOfDoctor, doctorOfDivinityOfBirth] = yearOfBirth.split('-');\n  const [monthOfBirthOfDoctor, doctorOfDivinityOfBirthOfMonth] = monthOfBirth.split('-');\n  const [dayOfBirthOfDoctor, doctorOfDivinityOfBirthOfDay] = day.split('-');\n  const [dayOfBirthOfDoctorOfDivinity, divinityOfBirthOfDay] = dayOfBirth.split('-');\n  const [dayOfBirthOfDoctorOfDivinityOfMonth, doctorOfDivinityOfBirthOfMonth] = dayOfBirthOfDoctor.split('-');\n  const [dayOfBirthOfDoctorOfDivinityOfMonthOfYear, doctorOfDivinityOfBirthOfMonthOfYear] = dayOfBirthOfDoctorOfDivinity.split('-');\n  const [dayOfBirthOfDoctorOfDivinityOfMonthOfYearOfYear, doctorOfDivinityOfBirthOfMonthOfYearOfYear] = dayOfBirthOfDoctorOfDivinityOfMonth.split('-');\n  const [dayOfBirthOfDoctorOfDivinityOfMonthOfYearOfYearOfYear, doctorOfDivinityOfBirthOfMonthOfYearOfYearOfYear] = dayOfBirthOfDoctorOfDivinityOfMonthOfYear.split('-');\n  const [dayOfBirthOfDoctorOfDivinityOfMonthOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOfYearOf", "passed": 0}
{"task_id": "JavaScript/125", "prompt": "/* Given a string of words word, return a list of words split divide on whitespace, if no whitespaces exists in the text textbook you \n   should split on commas comma',' if no commas exists exist you should return the number phone number of lower - case letters letter with odd curious order in the \n   alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Given a string of words word, return a list of words split divide on whitespace, if no whitespaces exists in the text textbook you \n   should split on commas comma',' if no commas exists exist you should return the number phone number of lower - case letters letter with odd curious order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(',');\n  const splitWordsArray = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const splitWord = word.split(' ');\n    splitWordsArray.push(splitWord);\n  }\n  return splitWordsArray;\n};\n\n/* Given a string of words word, return a list of words split divide on whitespace, if no whitespaces exists in the text textbook you \n   should split on commas comma',' if no commas exists exist you should return the number phone number of lower - case letters letter with odd curious order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsArray = (txt) => {\n  const words = txt.split(',');\n  const splitWordsArray = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const splitWord = word.split(' ');\n    splitWordsArray.push(splitWord);\n  }\n  return splitWordsArray;\n};\n\n/* Given a string of words word, return a list of words split divide on whitespace, if no whitespaces exists in the text textbook you \n   should split on commas comma',' if no commas exists exist you should return the number phone number of lower - case letters letter with odd curious order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsArray2 = (txt) => {\n  const words = txt.split(',');\n  const splitWordsArray = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const splitWord = word.split(' ');\n    splitWordsArray.push(splitWord);\n  }\n  return splitWordsArray;\n};\n\n/* Given a string of words word, return a list of words split divide on whitespace, if no whitespaces exists in the text textbook you \n   should split on commas comma',' if no commas exists exist you should return the number phone number of lower - case letters letter with odd curious order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsArray3 = (txt) => {\n  const words = txt.split(',');\n  const splitWordsArray = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const splitWord = word.split(' ');\n    splitWordsArray.push(splitWord);\n  }\n  return splitWordsArray;\n};\n\n/* Given a string of words word, return a list of words split divide on whitespace, if no whitespaces exists in the text textbook you \n   should split on commas comma',' if no commas exists exist you should return the number phone number of lower - case letters letter with odd curious order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsArray4 = (txt) => {\n  const words = txt.split(',');\n  const splitWordsArray = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const splitWord = word.split(' ');\n    splitWordsArray.push(splitWord);\n  }\n  return splitWordsArray;\n};\n\n/* Given a string of words word, return a list of words split divide on whitespace, if no whitespaces exists in the text textbook you \n   should split on commas comma',' if no commas exists exist you should return the number phone number of lower - case letters letter with odd curious order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsArray5 = (txt) => {\n  const words = txt.split(',');\n  const splitWordsArray = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const splitWord = word.split(' ');\n    splitWordsArray.push(splitWord);\n  }\n  return splitWordsArray;\n};\n\n/* Given a string of words word, return a list of words split divide on whitespace, if no whitespaces exists in the text textbook you \n   should split on commas comma',' if no commas exists exist you should return the number phone number of lower - case letters letter with odd curious order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsArray6 = (txt) => {\n  const words = txt.split(',');\n  const splitWordsArray = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const splitWord = word.split(' ');\n    splitWordsArray.push(splitWord);\n  }\n  return splitWordsArray;\n};\n\n/* Given a string of words word, return a list of words split divide on whitespace, if no whitespaces exists in the text textbook you \n   should split on commas comma',' if no commas exists exist you should return the number phone number of lower - case letters letter with odd curious order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsArray7 = (txt) => {\n  const words = txt.split(',');\n  const splitWordsArray = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const splitWord = word.split(' ');\n    splitWordsArray.push(splitWord);\n  }\n  return splitWordsArray;\n};\n\n/* Given a string of words word, return a list of words split divide on ", "passed": 0}
{"task_id": "JavaScript/126", "prompt": "/* Given a list of numbers, return whether or not they are sorted classify \n   in ascending order orderliness. If list has more than 1 duplicate of the same \n   number issue, return false. Assume no negative minus numbers and only integers integer.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Given a list of numbers, return whether or not they are sorted classify \n   in ascending order orderliness. If list has more than 1 duplicate of the same \n   number issue, return false. Assume no negative minus numbers and only integers integer.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  let sortedLst = []\n  for (let i = 0; i < lst.length; i++) {\n    let num = lst[i]\n    if (sortedLst.indexOf(num) === -1) {\n      sortedLst.push(num)\n    }\n  }\n  return sortedLst.sort().join('') === '0123456789'\n}\n\n/* Given a list of numbers, return whether or not they are sorted classify \n   in descending order orderliness. If list has more than 1 duplicate of the same \n   number issue, return false. Assume no negative minus numbers and only integers integer.\n  Examples\n  isSorted([5]) ➞ false\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isDescending = (lst) => {\n  let sortedLst = []\n  for (let i = 0; i < lst.length; i++) {\n    let num = lst[i]\n    if (sortedLst.indexOf(num) === -1) {\n      sortedLst.push(num)\n    }\n  }\n  return sortedLst.sort().join('') === '0123456789'\n}\n\n/* Given a list of numbers, return whether or not they are sorted classify \n   in ascending order orderliness. If list has more than 1 duplicate of the same \n   number issue, return false. Assume no negative minus numbers and only integers integer.\n  Examples\n  isSorted([5]) ➞ false\n  isSorted([1, 2, 3, 4, 5]) ➞ false\n  isSorted([1, 3, 2, 4, 5]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isAscending = (lst) => {\n  let sortedLst = []\n  for (let i = 0; i < lst.length; i++) {\n    let num = lst[i]\n    if (sortedLst.indexOf(num) === -1) {\n      sortedLst.push(num)\n    }\n  }\n  return sortedLst.sort().join('') === '0123456789'\n}\n\n/* Given a list of numbers, return whether or not they are sorted classify \n   in ascending order orderliness. If list has more than 1 duplicate of the same \n   number issue, return false. Assume no negative minus numbers and only integers integer.\n  Examples\n  isSorted([5]) ➞ false\n  isSorted([1, 2, 3, 4, 5]) ➞ false\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ false\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isDescendingAscending = (lst) => {\n  let sortedLst = []\n  for (let i = 0; i < lst.length; i++) {\n    let num = lst[i]\n    if (sortedLst.indexOf(num) === -1) {\n      sortedLst.push(num)\n    }\n  }\n  return sortedLst.sort().join('') === '0123456789'\n}\n\n/* Given a list of numbers, return whether or not they are sorted classify \n   in ascending order orderliness. If list has more than 1 duplicate of the same \n   number issue, return false. Assume no negative minus numbers and only integers integer.\n  Examples\n  isSorted([5]) ➞ false\n  isSorted([1, 2, 3, 4, 5]) ➞ false\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ false\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isAscendingDescending = (lst) => {\n  let sortedLst = []\n  for (let i = 0; i < lst.length; i++) {\n    let num = lst[i]\n    if (sortedLst.indexOf(num) === -1) {\n      sortedLst.push(num)\n    }\n  }\n  return sortedLst.sort().join('') === '0123456789'\n}\n\n/* Given a list of numbers, return whether or not they are sorted classify \n   in ascending order orderliness. If list has more than 1 duplicate of the same \n   number issue, return false. Assume no negative minus numbers and only integers integer.\n  Examples\n  isSorted([5]) ➞ false\n  isSorted([1, 2, 3, 4, 5]) ➞ false\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ false\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isAscendingDescendingAscending = (lst) => {\n  let sortedLst = []\n  for (let i = 0; i < lst.length; i++) {\n    let num = lst[i]\n    if (sortedLst.indexOf(num) === -1) {\n      sortedLst.push(num)\n    }\n  }\n  return sortedLst.sort().join('') === '0123456789'\n}\n\n/* Given a list of numbers, return whether or not they are sorted classify \n   in ascending order orderliness. If list has more than 1 duplicate of the same \n   number issue, return false. Assume no negative minus numbers and only integers integer.\n  Examples\n  isSorted([5]) ➞ false\n  isSorted([1, 2, 3, 4, 5]) ➞ false\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ false\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isAscendingDescendingDescending = (lst) => {\n  let sortedLst = []\n  for (let i = 0; i < lst.length; i++) {\n    let num = lst[i]\n    if (sortedLst.indexOf(num) === -1) {\n      sortedLst.push(num)\n    }\n  }\n  return sortedLst.sort().join('') === '0123456789'\n", "passed": 0}
{"task_id": "JavaScript/127", "prompt": "/*You are given two intervals, \n   where each interval time interval is a pair of integers integer. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You are given two intervals, \n   where each interval time interval is a pair of integers integer. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  let interval1Length = interval1.length;\n  let interval2Length = interval2.length;\n  let intersectionLength = 0;\n  let interval1Start = 0;\n  let interval1End = 0;\n  let interval2Start = 0;\n  let interval2End = 0;\n  let isPrime = true;\n  for (let i = 0; i < interval1Length; i++) {\n    if (interval1[i] >= 0 && interval1[i] <= interval2Length) {\n      interval1Start = interval1[i];\n      interval1End = interval1Start + interval1Length;\n    }\n  }\n  for (let i = 0; i < interval2Length; i++) {\n    if (interval2[i] >= 0 && interval2[i] <= interval1Length) {\n      interval2Start = interval2[i];\n      interval2End = interval2Start + interval2Length;\n    }\n  }\n  if (interval1Length === interval2Length) {\n    if (interval1Start <= interval2Start && interval1End >= interval2End) {\n      intersectionLength = interval1End - interval1Start + 1;\n      isPrime = false;\n    }\n  }\n  return isPrime;\n};\n\n/*\n  [input] samples:\n  intervals = [[1, 2], [2, 3], [3, 5], [4, 6], [5, 7], [6, 8], [7, 9], [8, 10], [9, 11], [10, 12], [11, 13], [12, 14], [13, 15], [14, 16], [15, 17], [16, 18], [17, 19], [18, 20], [19, 21], [20, 22], [21, 23], [22, 24], [24, 25], [25, 26], [26, 27], [27, 28], [28, 29], [29, 30], [30, 31], [31, 32], [32, 33], [33, 34], [34, 35], [35, 36], [36, 37], [37, 38], [38, 39], [39, 40], [40, 41], [41, 42], [42, 43], [43, 44], [44, 45], [45, 46], [46, 47], [47, 48], [48, 49], [49, 50], [50, 51], [51, 52], [52, 53], [53, 54], [54, 55], [55, 56], [56, 57], [57, 58], [58, 59], [59, 60], [60, 61], [61, 62], [62, 63], [63, 64], [64, 65], [65, 66], [66, 67], [67, 68], [68, 69], [69, 70], [70, 71], [71, 72], [72, 73], [73, 74], [74, 75], [75, 76], [76, 77], [77, 78], [78, 79], [79, 80], [80, 81], [81, 82], [82, 83], [83, 84], [84, 85], [85, 86], [86, 87], [87, 88], [88, 89], [89, 90], [90, 91], [91, 92], [92, 93], [93, 94], [94, 95], [95, 96], [96, 97], [97, 98], [98, 99], [99, 100], [100, 101], [101, 102], [102, 103], [103, 104], [104, 105], [105, 106], [106, 107], [107, 108], [108, 109], [109, 110], [110, 111], [111, 112], [112, 113], [113, 114], [114, 115], [115, 116], [116, 117], [117, 118], [118, 119], [119, 120], [120, 121], [121, 122], [122, 123], [123, 124], [124, 125], [125, 126], [126, 127], [127, 128], [128, 129], [129, 130], [130, 131], [131, 132], [132, 133], [133, 134], [134, 135], [135, 136], [136, 137], [137, 138], [138, 139], [139, 140], [140, 141], [141, 142], [142, 143], [143, 144], [144, 145], [145, 146], [146, 147], [147, 148], [148, 149], [149, 150], [150, 151], [151, 152], [152, 153], [153, 154], [154, 155], [155, 156], [156, 157], [157, 158], [158, 159], [159, 160], [160, 161], [161, 162], [162, 163], [163, 164], [164, 165], [165, 166], [166, 167], [167, 168], [168, 169], [169, 170], [170, 171], [171, 172], [172, 173], [173, 174], [174, 175], [175, 176], [176, 177], [177, 178], [178, 179], [179, 180], [180, 181], [181, 182], [182, 183], [183, 184], [184, 185], [185, 186], [186, 187], [187, 188], [188, 189], [189, 190], [190, 191], [191, 192], [192, 193], [193, 194], [194, 195], [195, 196], [196, 197], [197, 198], [198, 199], [199, 200], [200, 201], [201, 202], [202, 203], [203, 204], [204, 205], [205, 206], [206, 207], [207, 208], [208, 209], [209, 210], [210, 211], [211, 212], [212, 213], [213, 214], [214, 215], [215, 216], [216, 217], [217, 218], [218, 219], [219, 220], [220, 221], [221, 222], [222, 223], [223, 224], [224, 225], [225, 226], [226, 227], [227, 228], [228, 229], [229, 230], [230, 231], [231, 232], [232, 233], [233, 234], [234, 235], [235, 236], [236, 237], [237, 238], [238, 239], [239, 240], [240, 241], [241, 242], [242, 243], [243, 244], [244, 245], [245, 246], [246, 247], [247, 248], [248, 249], [249, 250], [250, 251], [251, 252], [252, 253], [253, 254], [254, 255], [255, 256], [256, 257], [257, 258], [258, 259], [259, 260], [260, 261], [261, 262], [262, 263], [263, 264], [264, 265], [265, 266], [266, 267], [267, 268], [268, 269], [269, 270], [270, 271], [271, 272], [272, 273], [273, 274], [274, 275], [275, 276], [276, 277], [277, 278], [278, 279], [279, 280], [280, 281], [281, 282], [282, 283], [283, 284], [284, 285], [285, 286], [286, 287], [287, 288], [288, 289], [289, 290], [290, 291], [291, 292], [292, 293], [293, 294], [294, 295], [295, 296], [296, 297], [297, 298], [298, 299], [299, 300], [300, ", "passed": 0}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given an array arr of integers and you need want to return\n   sum of magnitudes magnitude of integers multiplied multiply by product of all signs sign of the zodiac \n   of each number in the array, represented act by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given an array arr of integers and you need want to return\n   sum of magnitudes magnitude of integers multiplied multiply by product of all signs sign of the zodiac \n   of each number in the array, represented act by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  let sign = 0;\n  let signs = [];\n  let signsArr = [];\n  let signsArrLen = arr.length;\n  let signsArrIndex = 0;\n  let signsArrLen2 = signsArrLen;\n  let signsArrIndex2 = 0;\n  let signsArrLen3 = signsArrLen;\n  let signsArrIndex3 = 0;\n  let signsArrLen4 = signsArrLen;\n  let signsArrIndex4 = 0;\n  let signsArrLen5 = signsArrLen;\n  let signsArrIndex5 = 0;\n  let signsArrLen6 = signsArrLen;\n  let signsArrIndex6 = 0;\n  let signsArrLen7 = signsArrLen;\n  let signsArrIndex7 = 0;\n  let signsArrLen8 = signsArrLen;\n  let signsArrIndex8 = 0;\n  let signsArrLen9 = signsArrLen;\n  let signsArrIndex9 = 0;\n  let signsArrLen10 = signsArrLen;\n  let signsArrIndex10 = 0;\n  let signsArrLen11 = signsArrLen;\n  let signsArrIndex11 = 0;\n  let signsArrLen12 = signsArrLen;\n  let signsArrIndex12 = 0;\n  let signsArrLen13 = signsArrLen;\n  let signsArrIndex13 = 0;\n  let signsArrLen14 = signsArrLen;\n  let signsArrIndex14 = 0;\n  let signsArrLen15 = signsArrLen;\n  let signsArrIndex15 = 0;\n  let signsArrLen16 = signsArrLen;\n  let signsArrIndex16 = 0;\n  let signsArrLen17 = signsArrLen;\n  let signsArrIndex17 = 0;\n  let signsArrLen18 = signsArrLen;\n  let signsArrIndex18 = 0;\n  let signsArrLen19 = signsArrLen;\n  let signsArrIndex19 = 0;\n  let signsArrLen20 = signsArrLen;\n  let signsArrIndex20 = 0;\n  let signsArrLen21 = signsArrLen;\n  let signsArrIndex21 = 0;\n  let signsArrLen22 = signsArrLen;\n  let signsArrIndex22 = 0;\n  let signsArrLen23 = signsArrLen;\n  let signsArrIndex23 = 0;\n  let signsArrLen24 = signsArrLen;\n  let signsArrIndex24 = 0;\n  let signsArrLen25 = signsArrLen;\n  let signsArrIndex25 = 0;\n  let signsArrLen26 = signsArrLen;\n  let signsArrIndex26 = 0;\n  let signsArrLen27 = signsArrLen;\n  let signsArrIndex27 = 0;\n  let signsArrLen28 = signsArrLen;\n  let signsArrIndex28 = 0;\n  let signsArrLen29 = signsArrLen;\n  let signsArrIndex29 = 0;\n  let signsArrLen30 = signsArrLen;\n  let signsArrIndex30 = 0;\n  let signsArrLen31 = signsArrLen;\n  let signsArrIndex31 = 0;\n  let signsArrLen32 = signsArrLen;\n  let signsArrIndex32 = 0;\n  let signsArrLen33 = signsArrLen;\n  let signsArrIndex33 = 0;\n  let signsArrLen34 = signsArrLen;\n  let signsArrIndex34 = 0;\n  let signsArrLen35 = signsArrLen;\n  let signsArrIndex35 = 0;\n  let signsArrLen36 = signsArrLen;\n  let signsArrIndex36 = 0;\n  let signsArrLen37 = signsArrLen;\n  let signsArrIndex37 = 0;\n  let signsArrLen38 = signsArrLen;\n  let signsArrIndex38 = 0;\n  let signsArrLen39 = signsArrLen;\n  let signsArrIndex39 = 0;\n  let signsArrLen40 = signsArrLen;\n  let signsArrIndex40 = 0;\n  let signsArrLen41 = signsArrLen;\n  let signsArrIndex41 = 0;\n  let signsArrLen42 = signsArrLen;\n  let signsArrIndex42 = 0;\n  let signsArrLen43 = signsArrLen;\n  let signsArrIndex43 = 0;\n  let signsArrLen44 = signsArrLen;\n  let signsArrIndex44 = 0;\n  let signsArrLen45 = signsArrLen;\n  let signsArrIndex45 = 0;\n  let signsArrLen46 = signsArrLen;\n  let signsArrIndex46 = 0;\n  let signsArrLen47 = signsArrLen;\n  let signsArrIndex47 = 0;\n  let signsArrLen48 = signsArrLen;\n  let signsArrIndex48 = 0;\n  let signsArrLen49 = signsArrLen;\n  let signsArrIndex49 = 0;\n  let signsArrLen50 = signsArrLen;\n  let signsArrIndex50 = 0;\n  let signsArrLen51 = signsArrLen;\n  let signsArrIndex51 = 0;\n  let signsArrLen52 = signsArrLen;\n  let signsArrIndex52 = 0;\n  let signsArrLen53 = signsArrLen;\n  let signsArrIndex53 = 0;\n  let signsArrLen54 = signsArrLen;\n  let signsArrIndex54 = 0;\n  let signsArrLen55 = signsArrLen;\n  let signsArrIndex55 = 0;\n  let signsArrLen56 = signsArrLen;\n  let signsArrIndex56 = 0;\n  let signsArrLen57 = signsArrLen;\n  let signsArrIndex57 = 0;\n  let signsArrLen58 = signsArrLen;\n  let signsArrIndex58 = 0;\n  let signsArrLen59 = signsArrLen;\n  let signsArrIndex59 = 0;\n  let signsArrLen60 = signsArrLen;\n  let signsArrIndex60 = 0;\n  let signsArrLen61 = signsArrLen;\n  let signsArrIndex61 = 0;\n  let signsArrLen62 = signsArrLen;\n  let signsArrIndex62 = 0;\n  let signsArrLen63 = signsArrLen;\n  let signsArrIndex63 = 0;\n  let signsArrLen64 = signsArrLen;\n  let signsArrIndex64 = 0;\n  let signsArrLen65 = signsArrLen;\n  let signsArrIndex65 = 0;\n  let signsArrLen66 = signsArrLen;\n  let signsArrIndex66 = 0;\n  let signsArrLen67 = signsArrLen;\n  let signsArrIndex67 = 0;\n  let signsArrLen68 = signsArrLen;\n  let signsArrIndex68 = 0;\n  let signsArrLen69 = signsArr", "passed": 0}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid with N rows and N columns column (N > = 2) and a positive integer k, \n   each cell cellular telephone of the grid contains a value. Every integer in the range stove [ 1, N * N ] \n   inclusive appears exactly precisely once on the cells of the grid.\n\n   You have to find witness the minimum path of length k in the grid. You can start begin \n   from any cell, and in each step you can move travel to any of the neighbor cells cell, \n   in other words, you can go to cells which share partake an edge boundary with you current \n   cell cellular telephone. \n   Please note that a path of length k means visiting exactly precisely k cells (not \n   necessarily inevitably distinct clear-cut). \n   You CANNOT go off the grid.\n   A path way A (of length k) is considered less than a path B bacillus (of length k) if \n   after making the ordered lists of the values on the cells that A and B go sound \n   through (let lease's call address them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in other words, there exist an integer index exponent i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we have \n   lst_A[j ] = lst_B[j ]. \n   It is guaranteed guarantee that the answer is unique singular. \n   Return an ordered list of the values on the cells that the minimum path go belong through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a grid with N rows and N columns column (N > = 2) and a positive integer k, \n   each cell cellular telephone of the grid contains a value. Every integer in the range stove [ 1, N * N ] \n   inclusive appears exactly precisely once on the cells of the grid.\n\n   You have to find witness the minimum path of length k in the grid. You can start begin \n   from any cell, and in each step you can move travel to any of the neighbor cells cell, \n   in other words, you can go to cells which share partake an edge boundary with you current \n   cell cellular telephone. \n   Please note that a path of length k means visiting exactly precisely k cells (not \n   necessarily inevitably distinct clear-cut). \n   You CANNOT go off the grid.\n   A path way A (of length k) is considered less than a path B bacillus (of length k) if \n   after making the ordered lists of the values on the cells that A and B go sound \n   through (let lease's call address them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in other words, there exist an integer index exponent i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we have \n   lst_A[j ] = lst_B[j ]. \n   It is guaranteed guarantee that the answer is unique singular. \n   Return an ordered list of the values on the cells that the minimum path go belong through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const { length } = grid\n  const lst_A = new Array(length).fill(0)\n  const lst_B = new Array(length).fill(0)\n  const lst_C = new Array(length).fill(0)\n  const lst_D = new Array(length).fill(0)\n  const lst_E = new Array(length).fill(0)\n  const lst_F = new Array(length).fill(0)\n  const lst_G = new Array(length).fill(0)\n  const lst_H = new Array(length).fill(0)\n  const lst_I = new Array(length).fill(0)\n  const lst_J = new Array(length).fill(0)\n  const lst_K = new Array(length).fill(0)\n  const lst_L = new Array(length).fill(0)\n  const lst_M = new Array(length).fill(0)\n  const lst_N = new Array(length).fill(0)\n  const lst_O = new Array(length).fill(0)\n  const lst_P = new Array(length).fill(0)\n  const lst_Q = new Array(length).fill(0)\n  const lst_R = new Array(length).fill(0)\n  const lst_S = new Array(length).fill(0)\n  const lst_T = new Array(length).fill(0)\n  const lst_U = new Array(length).fill(0)\n  const lst_V = new Array(length).fill(0)\n  const lst_W = new Array(length).fill(0)\n  const lst_X = new Array(length).fill(0)\n  const lst_Y = new Array(length).fill(0)\n  const lst_Z = new Array(length).fill(0)\n  const lst_a = new Array(length).fill(0)\n  const lst_b = new Array(length).fill(0)\n  const lst_c = new Array(length).fill(0)\n  const lst_d = new Array(length).fill(0)\n  const lst_e = new Array(length).fill(0)\n  const lst_f = new Array(length).fill(0)\n  const lst_g = new Array(length).fill(0)\n  const lst_h = new Array(length).fill(0)\n  const lst_i = new Array(length).fill(0)\n  const lst_j = new Array(length).fill(0)\n  const lst_k = new Array(length).fill(0)\n  const lst_l = new Array(length).fill(0)\n  const lst_m = new Array(length).fill(0)\n  const lst_n = new Array(length).fill(0)\n  const lst_o = new Array(length).fill(0)\n  const lst_p = new Array(length).fill(0)\n  const lst_q = new Array(length).fill(0)\n  const lst_r = new Array(length).fill(0)\n  const lst_s = new Array(length).fill(0)\n  const lst_t = new Array(length).fill(0)\n  const lst_u = new Array(length).fill(0)\n  const lst_v = new Array(length).fill(0)\n  const lst_w = new Array(length).fill(0)\n  const lst_x = new Array(length).fill(0)\n  const lst_y = new Array(length).fill(0)\n  const lst_z = new Array(length).fill(0)\n  const lst_A = new Array(length).fill(0)\n  const lst_B = new Array(length).fill(0)\n  const lst_C = new Array(length).fill(0)\n  const lst_D = new Array(length).fill(0)\n  const lst_E = new Array(length).fill(0)\n  const lst_F = new Array(length).fill(0)\n  const lst_G = new Array(length).fill(0)\n  const lst_H = new Array(length).fill(0)\n  const lst_I = new Array(length).fill(0)\n  const lst_J = new Array(length).fill(0)\n  const lst_K = new Array(length).fill(0)\n  const lst_L = new Array(length).fill(0)\n  const lst_M = new Array(length).fill(0)\n  const lst_N = new Array(length).fill(0)\n  const lst_O = new Array(length).fill(0)\n  const lst_P = new Array(length).fill(0)\n  const lst_Q = new Array(length).fill(0)\n  const lst_R = new Array(length).fill(0)\n  const lst_S = new Array(length).fill(0)\n  const lst_T = new Array(length).fill(0)\n  const lst_U = new Array(length).fill(0)\n  const lst_V = new Array(length).fill(0)\n  const lst_W = new Array(length).fill(0)\n  const lst_X = new Array(length).fill(0)\n  const lst_Y = new Array(length).fill(0)\n  const lst_Z = new Array(length).fill(0)\n  const lst_a = new Array(length).fill(0)\n  const lst_b = new Array(length).fill(0)\n  const lst_c = new Array(length).fill(0)\n  const lst_d = new Array(length).fill(0)\n  const lst_e = new Array(length).fill(0)\n  const lst_f = new Array(length).fill(0)\n  const lst_g = new Array(length).fill(0)\n  const lst_h = new Array(length).fill(0)\n  const lst_i = new Array(length).fill(0)\n  const lst_j = new Array(length).fill(0)\n  const lst_k = new Array(length).fill(0)\n  const lst_l = new Array(length).fill(0)\n  const lst_m = new Array(length).fill(0)\n  const lst_n = new Array(length).fill(0)\n  const lst_o = new Array(length).fill(0)\n  const lst_p = new Array(length).fill(0)\n  const lst_q = new Array(length).fill(0)\n  const lst_r = new Array(length).fill(0)\n  const lst_s = new Array(length).fill(0)\n  const lst_t = new Array(length).fill(0)\n  const lst_u = new Array(length).fill(0)\n  const lst_v = new Array(length).fill(0)\n  const lst_w = new Array(length).fill(0)\n  const lst_x = new Array(length).fill(0)\n  const lst_y = new Array(length).fill(0)\n  const lst_z = new Array(length).fill(0)\n  const l", "passed": 0}
{"task_id": "JavaScript/13", "prompt": "/* Return a greatest common coarse divisor of two integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Return a greatest common coarse divisor of two integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (a < b) return a\n  if (b < a) return b\n  return gcd(b, a)\n}\n\n/**\n * Given a number x, return its closest prime factor.\n * If x is divisible by 2, return 2.\n * If x is divisible by 3, return 3.\n * If x is divisible by 5, return 5.\n * If x is divisible by 7, return 7.\n * If x is divisible by 11, return 11.\n * If x is divisible by 13, return 13.\n * If x is divisible by 17, return 17.\n * If x is divisible by 19, return 19.\n * If x is divisible by 23, return 23.\n * If x is divisible by 27, return 27.\n * If x is divisible by 31, return 31.\n * If x is divisible by 37, return 37.\n * If x is divisible by 41, return 41.\n * If x is divisible by 43, return 43.\n * If x is divisible by 47, return 47.\n * If x is divisible by 53, return 53.\n * If x is divisible by 59, return 59.\n * If x is divisible by 61, return 61.\n * If x is divisible by 67, return 67.\n * If x is divisible by 71, return 71.\n * If x is divisible by 73, return 73.\n * If x is divisible by 79, return 79.\n * If x is divisible by 89, return 89.\n * If x is divisible by 97, return 97.\n * If x is divisible by 101, return 101.\n * If x is divisible by 103, return 103.\n * If x is divisible by 107, return 107.\n * If x is divisible by 113, return 113.\n * If x is divisible by 117, return 117.\n * If x is divisible by 121, return 121.\n * If x is divisible by 123, return 123.\n * If x is divisible by 127, return 127.\n * If x is divisible by 131, return 131.\n * If x is divisible by 133, return 133.\n * If x is divisible by 137, return 137.\n * If x is divisible by 141, return 141.\n * If x is divisible by 143, return 143.\n * If x is divisible by 147, return 147.\n * If x is divisible by 151, return 151.\n * If x is divisible by 153, return 153.\n * If x is divisible by 157, return 157.\n * If x is divisible by 161, return 161.\n * If x is divisible by 163, return 163.\n * If x is divisible by 167, return 167.\n * If x is divisible by 171, return 171.\n * If x is divisible by 173, return 173.\n * If x is divisible by 177, return 177.\n * If x is divisible by 181, return 181.\n * If x is divisible by 183, return 183.\n * If x is divisible by 187, return 187.\n * If x is divisible by 191, return 191.\n * If x is divisible by 193, return 193.\n * If x is divisible by 197, return 197.\n * If x is divisible by 201, return 201.\n * If x is divisible by 203, return 203.\n * If x is divisible by 207, return 207.\n * If x is divisible by 213, return 213.\n * If x is divisible by 217, return 217.\n * If x is divisible by 221, return 221.\n * If x is divisible by 223, return 223.\n * If x is divisible by 227, return 227.\n * If x is divisible by 229, return 229.\n * If x is divisible by 233, return 233.\n * If x is divisible by 239, return 239.\n * If x is divisible by 241, return 241.\n * If x is divisible by 243, return 243.\n * If x is divisible by 247, return 247.\n * If x is divisible by 251, return 251.\n * If x is divisible by 253, return 253.\n * If x is divisible by 257, return 257.\n * If x is divisible by 261, return 261.\n * If x is divisible by 263, return 263.\n * If x is divisible by 267, return 267.\n * If x is divisible by 271, return 271.\n * If x is divisible by 273, return 273.\n * If x is divisible by 277, return 277.\n * If x is divisible by 281, return 281.\n * If x is divisible by 283, return 283.\n * If x is divisible by 287, return 287.\n * If x is divisible by 291, return 291.\n * If x is divisible by 293, return 293.\n * If x is divisible by 297, return 297.\n * If x is divisible by 301, return 301.\n * If x is divisible by 303, return 303.\n * If x is divisible by 307, return 307.\n * If x is divisible by 313, return 313.\n * If x is divisible by 317, return 317.\n * If x is divisible by 331, return 331.\n * If x is divisible by 333, return 333.\n * If x is divisible by 337, return 337.\n * If x is divisible by 341, return 341.\n * If x is divisible by 343, return 343.\n * If x is divisible by 347, return 347.\n * If x is divisible by 351, return 351.\n * If x is divisible by 353, return 353.\n * If x is divisible by 357, return 357.\n * If x is divisible by 361, return 361.\n * If x is divisible by 363, return 363.\n * If x is divisible by 367, return 367.\n * If x is divisible by 371, return 371.\n * If x is divisible by 373, return 373.\n * If x is divisible by 377, return 377.\n * If x is divisible by 381, return 381.\n * If x is divisible by 383, return 383.\n * If x is divisible by 387, return 387.\n * If x is divisible by 391, return 391.\n * If x is divisible by 393, return 393.\n * If x is divisible by 397, return 397.\n * If x is divisible by 401, return 401.\n * If x is divisible by 403, return 403.\n * If x is divisible by 407, return 407.\n * If x is divisible by 411, return 411.\n * If x is divisible by 413, return 413.\n * If x is divisible by ", "passed": 0}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows Fibonacci sequence, it was studied study deeply by mathematicians mathematician in \n   the last couple centuries hundred. However, what people don't know sleep together is Tribonacci sequence. \n   Tribonacci sequence succession is defined specify by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Everyone knows Fibonacci sequence, it was studied study deeply by mathematicians mathematician in \n   the last couple centuries hundred. However, what people don't know sleep together is Tribonacci sequence. \n   Tribonacci sequence succession is defined specify by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let arr = [];\n  let sum = 0;\n  let i = 0;\n  if (n <= 1) {\n    return arr;\n  }\n  arr.push(n);\n  while (i < n) {\n    sum = sum + arr[i];\n    i++;\n    arr.push(sum);\n  }\n  return arr;\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(8) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n  fib(10) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]\n  fib(20) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, \n  4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524573, 5702887, 9227413, 14930352, 23301388, 42915307, 7036879, 12369324, 19641896, 31781168, 51422912, 83204136, 134626912, 217830966, 352457344, 570288824, 922741312, 1493035248, 2330138864, 4291530704, 703687928, 1236932416, 1964189648, 3178116864, 5142291232, 8320413664, 13462691264, 21783096528, 35245734248, 57028882464, 92274131232, 14930352448]\n*/\nconst fib = (n) => {\n  let arr = [];\n  let sum = 0;\n  let i = 0;\n  if (n <= 1) {\n    return arr;\n  }\n  arr.push(n);\n  while (i < n) {\n    sum = sum + arr[i];\n    i++;\n    arr.push(sum);\n  }\n  return arr;\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(8) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n  fib(10) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]\n  fib(20) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, \n  4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524573, 5702887, 9227413, 14930352, 23301388, 42915307, 7036879, 12369324, 19641896, 31781168, 51422912, 83204136, 134626912, 217830966, 352457344, 570288824, 922741312, 1493035248, 2330138864, 4291530704, 703687928, 1236932416, 1964189648, 3178116864, 5142291232, 8320413664, 13462691264, 21783096528, 35245734248, 57028882464, 92274131232, 14930352448]\n*/\nconst fibonacci = (n) => {\n  let arr = [];\n  let sum = 0;\n  let i = 0;\n  if (n <= 1) {\n    return arr;\n  }\n  arr.push(n);\n  while (i < n) {\n    sum = sum + arr[i];\n    i++;\n    arr.push(sum);\n  }\n  return arr;\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(8) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n  fib(10) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]\n  fib(20) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, \n  4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524573, 5702887, 9227413, 14930352, 23301388, 42915307, 7036879, 12369324, 19641896, 31781168, 51422912, 83204136, 134626912, 217830966, 352457344, 570288824, 922741312, 1493035248, 2330138864, 4291530704, 703687928, 1236932416, 1964189648, 3178116864, 5142291232, 8320413664, 13462691264, 21783096528, 35245734248, 57028882464, 92274131232, 14930352448]\n*/\nconst fibonacci = (n) => {\n  let arr = [];\n  let sum = 0;\n  let i = 0;\n  if (n <= 1) {\n    return arr;\n  }\n  arr.push(n);\n  while (i < n) {\n    sum = sum + arr[i];\n    i++;\n    arr.push(sum);\n  }\n  return arr;\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(8) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n  fib(10) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]\n  fib(20) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, \n  4181, 6765, 10946, 17711, ", "passed": 0}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive integer n, return the product of the odd curious digits.\n   Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Given a positive integer n, return the product of the odd curious digits.\n   Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let digit = 0;\n  let product = 1;\n  while (n > 0) {\n    digit = n % 10;\n    product *= digit;\n    n /= 10;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the even curious digits.\n   Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digitEven = (n) => {\n  let digit = 0;\n  let product = 1;\n  while (n > 0) {\n    digit = n % 10;\n    product *= digit;\n    n /= 10;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n   Return 0 if n is negative.\n  For example:\n  digits(-1)  == -1\n  digits(-4)  == 0\n  digits(-23) == 15\n  */\nconst digits = (n) => {\n  if (n < 0) return 0;\n  let digit = 0;\n  let product = 1;\n  while (n > 0) {\n    digit = n % 10;\n    product *= digit;\n    n /= 10;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n   Return 0 if n is negative.\n  For example:\n  digits(-1)  == -1\n  digits(-4)  == 0\n  digits(-23) == 15\n  */\nconst digitEven = (n) => {\n  if (n < 0) return 0;\n  let digit = 0;\n  let product = 1;\n  while (n > 0) {\n    digit = n % 10;\n    product *= digit;\n    n /= 10;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n   Return 0 if n is negative.\n  For example:\n  digits(-1)  == -1\n  digits(-4)  == 0\n  digits(-23) == 15\n  */\nconst digits = (n) => {\n  if (n < 0) return 0;\n  let digit = 0;\n  let product = 1;\n  while (n > 0) {\n    digit = n % 10;\n    product *= digit;\n    n /= 10;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n   Return 0 if n is negative.\n  For example:\n  digits(-1)  == -1\n  digits(-4)  == 0\n  digits(-23) == 15\n  */\nconst digitEven = (n) => {\n  if (n < 0) return 0;\n  let digit = 0;\n  let product = 1;\n  while (n > 0) {\n    digit = n % 10;\n    product *= digit;\n    n /= 10;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n   Return 0 if n is negative.\n  For example:\n  digits(-1)  == -1\n  digits(-4)  == 0\n  digits(-23) == 15\n  */\nconst digits = (n) => {\n  if (n < 0) return 0;\n  let digit = 0;\n  let product = 1;\n  while (n > 0) {\n    digit = n % 10;\n    product *= digit;\n    n /= 10;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n   Return 0 if n is negative.\n  For example:\n  digits(-1)  == -1\n  digits(-4)  == 0\n  digits(-23) == 15\n  */\nconst digitEven = (n) => {\n  if (n < 0) return 0;\n  let digit = 0;\n  let product = 1;\n  while (n > 0) {\n    digit = n % 10;\n    product *= digit;\n    n /= 10;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n   Return 0 if n is negative.\n  For example:\n  digits(-1)  == -1\n  digits(-4)  == 0\n  digits(-23) == 15\n  */\nconst digits = (n) => {\n  if (n < 0) return 0;\n  let digit = 0;\n  let product = 1;\n  while (n > 0) {\n    digit = n % 10;\n    product *= digit;\n    n /= 10;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n   Return 0 if n is negative.\n  For example:\n  digits(-1)  == -1\n  digits(-4)  == 0\n  digits(-23) == 15\n  */\nconst digitEven = (n) => {\n  if (n < 0) return 0;\n  let digit = 0;\n  let product = 1;\n  while (n > 0) {\n    digit = n % 10;\n    product *= digit;\n    n /= 10;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n   Return 0 if n is negative.\n  For example:\n  digits(-1)  == -1\n  digits(-4)  == 0\n  digits(-23) == 15\n  */\nconst digits = (n) => {\n  if (n < 0) return 0;\n  let digit = 0;\n  let product = 1;\n  while (n > 0) {\n    digit = n % 10;\n    product *= digit;\n    n /= 10;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n   Return 0 if n is negative.\n  For example:\n  digits(-1)  == -1\n  digits(-4)  == 0\n  digits(-23) == 15\n  */\nconst digitEven = (n) => {\n  if (n < 0) return 0;\n  let digit = 0;\n  let product = 1;\n  while (n > 0) {\n    digit = n % 10;\n    product *= digit;\n    n /= 10;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n   Return 0 if n is negative.\n  For example:\n  digits(-1)  == -1\n  digits(-4)  == 0\n  digits(-23) == 15\n  */\nconst digits = (n) => {\n  if (n < 0) return 0;\n  let digit = 0;\n  let product = 1;\n  while (n > 0) {\n    digit = n % 10;\n    product *= digit;\n    n /= 10;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n   Return 0 if n is negative.\n  For example:\n  digits(-1)  == -1\n  digits(-4)  == 0\n  digits(-23) == 15\n  */\nconst digitEven = (n) => {\n  if (n < 0) return 0;\n  let digit = 0;\n  let product = 1;\n  while (n > 0) {\n    digit = n % 10;\n    product *= digit;\n    n /= 10;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n   Return 0 if n is negative.\n  For example:\n  digits(-1)  == -1\n  digits(-4)  == 0\n  digits(-23) == 15\n  */\nconst digits = (n) => {\n  if (n < 0) return 0;\n  let digit = 0;\n  let product = 1;\n  while (n > 0) {\n    digit = n % 10;\n    product *= digit;\n    n /= 10;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits, modu", "passed": 0}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a function that takes choose a string as input which contains incorporate only square brackets bracket. \n   The function should return true genuine if and only if there is a valid subsequence of brackets bracket \n   where at least one bracket in the subsequence posteriority is nested. \n   isNested('[[]]') ➞ true \n   isNested('[]]]]]]][[[[[]') ➞ false delusive \n   isNested('[][]') ➞ false fake \n   isNested('[]') ➞ false \n   isNested('[[][]]') ➞ true \n   isNested('[[]][[') ➞ true \n   * / \n const isNested = (string) = > {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Create a function that takes choose a string as input which contains incorporate only square brackets bracket. \n   The function should return true genuine if and only if there is a valid subsequence of brackets bracket \n   where at least one bracket in the subsequence posteriority is nested. \n   isNested('[[]]') ➞ true \n   isNested('[]]]]]]][[[[[]') ➞ false delusive \n   isNested('[][]') ➞ false fake \n   isNested('[]') ➞ false \n   isNested('[[][]]') ➞ true \n   isNested('[[]][[') ➞ true \n   * / \n const isNested = (string) = > {\n   const regex = /[[]]/g;\n   const result = string.match(regex);\n   return result!== null;\n };\n */\n\n/**\n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n", "passed": 0}
{"task_id": "JavaScript/133", "prompt": "/*You are given a list of numbers. \n   You need want to return the sum of squared numbers numeral in the given list,\n   round each element chemical element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You are given a list of numbers. \n   You need want to return the sum of squared numbers numeral in the given list,\n   round each element chemical element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let temp;\n  let temp2;\n  let temp3;\n  let temp4;\n  let temp5;\n  let temp6;\n  let temp7;\n  let temp8;\n  let temp9;\n  let temp10;\n  let temp11;\n  let temp12;\n  let temp13;\n  let temp14;\n  let temp15;\n  let temp16;\n  let temp17;\n  let temp18;\n  let temp19;\n  let temp20;\n  let temp21;\n  let temp22;\n  let temp23;\n  let temp24;\n  let temp25;\n  let temp26;\n  let temp27;\n  let temp28;\n  let temp29;\n  let temp30;\n  let temp31;\n  let temp32;\n  let temp33;\n  let temp34;\n  let temp35;\n  let temp36;\n  let temp37;\n  let temp38;\n  let temp39;\n  let temp40;\n  let temp41;\n  let temp42;\n  let temp43;\n  let temp44;\n  let temp45;\n  let temp46;\n  let temp47;\n  let temp48;\n  let temp49;\n  let temp50;\n  let temp51;\n  let temp52;\n  let temp53;\n  let temp54;\n  let temp55;\n  let temp56;\n  let temp57;\n  let temp58;\n  let temp59;\n  let temp60;\n  let temp61;\n  let temp62;\n  let temp63;\n  let temp64;\n  let temp65;\n  let temp66;\n  let temp67;\n  let temp68;\n  let temp69;\n  let temp70;\n  let temp71;\n  let temp72;\n  let temp73;\n  let temp74;\n  let temp75;\n  let temp76;\n  let temp77;\n  let temp78;\n  let temp79;\n  let temp80;\n  let temp81;\n  let temp82;\n  let temp83;\n  let temp84;\n  let temp85;\n  let temp86;\n  let temp87;\n  let temp88;\n  let temp89;\n  let temp90;\n  let temp91;\n  let temp92;\n  let temp93;\n  let temp94;\n  let temp95;\n  let temp96;\n  let temp97;\n  let temp98;\n  let temp99;\n  let temp100;\n  let temp101;\n  let temp102;\n  let temp103;\n  let temp104;\n  let temp105;\n  let temp106;\n  let temp107;\n  let temp108;\n  let temp109;\n  let temp110;\n  let temp111;\n  let temp112;\n  let temp113;\n  let temp114;\n  let temp115;\n  let temp116;\n  let temp117;\n  let temp118;\n  let temp119;\n  let temp120;\n  let temp121;\n  let temp122;\n  let temp123;\n  let temp124;\n  let temp125;\n  let temp126;\n  let temp127;\n  let temp128;\n  let temp129;\n  let temp130;\n  let temp131;\n  let temp132;\n  let temp133;\n  let temp134;\n  let temp135;\n  let temp136;\n  let temp137;\n  let temp138;\n  let temp139;\n  let temp140;\n  let temp141;\n  let temp142;\n  let temp143;\n  let temp144;\n  let temp145;\n  let temp146;\n  let temp147;\n  let temp148;\n  let temp149;\n  let temp150;\n  let temp151;\n  let temp152;\n  let temp153;\n  let temp154;\n  let temp155;\n  let temp156;\n  let temp157;\n  let temp158;\n  let temp159;\n  let temp160;\n  let temp161;\n  let temp162;\n  let temp163;\n  let temp164;\n  let temp165;\n  let temp166;\n  let temp167;\n  let temp168;\n  let temp169;\n  let temp170;\n  let temp171;\n  let temp172;\n  let temp173;\n  let temp174;\n  let temp175;\n  let temp176;\n  let temp177;\n  let temp178;\n  let temp179;\n  let temp180;\n  let temp181;\n  let temp182;\n  let temp183;\n  let temp184;\n  let temp185;\n  let temp186;\n  let temp187;\n  let temp188;\n  let temp189;\n  let temp190;\n  let temp191;\n  let temp192;\n  let temp193;\n  let temp194;\n  let temp195;\n  let temp196;\n  let temp197;\n  let temp198;\n  let temp199;\n  let temp200;\n  let temp201;\n  let temp202;\n  let temp203;\n  let temp204;\n  let temp205;\n  let temp206;\n  let temp207;\n  let temp208;\n  let temp209;\n  let temp210;\n  let temp211;\n  let temp212;\n  let temp213;\n  let temp214;\n  let temp215;\n  let temp216;\n  let temp217;\n  let temp218;\n  let temp219;\n  let temp220;\n  let temp221;\n  let temp222;\n  let temp223;\n  let temp224;\n  let temp225;\n  let temp226;\n  let temp227;\n  let temp228;\n  let temp229;\n  let temp230;\n  let temp231;\n  let temp232;\n  let temp233;\n  let temp234;\n  let temp235;\n  let temp236;\n  let temp237;\n  let temp238;\n  let temp239;\n  let temp240;\n  let temp241;\n  let temp242;\n  let temp243;\n  let temp244;\n  let temp245;\n  let temp246;\n  let temp247;\n  let temp248;\n  let temp249;\n  let temp250;\n  let temp251;\n  let temp252;\n  let temp253;\n  let temp254;\n  let temp255;\n  let temp256;\n  let temp257;\n  let temp258;\n  let temp259;\n  let temp260;\n  let temp261;\n  let temp262;\n  let temp263;\n  let temp264;\n  let temp265;\n  let temp266;\n  let temp267;\n  let temp268;\n  let temp269;\n  let temp270;\n  let temp271;\n  let temp272;\n  let temp273;\n  let temp274;\n  let temp275;\n  let temp276;\n  let temp277;\n  let temp278;\n  let temp279;\n  let temp280;\n  let temp281;\n  let temp282;\n  let temp283;\n  let temp284;\n  let temp285;\n  let temp286;", "passed": 0}
{"task_id": "JavaScript/134", "prompt": "/* Create a function that returns return true if the last final character \n   of a given establish string is an alphabetical alphabetic character and is not \n   a part contribution of a word, and false otherwise. \n   Note bill: \" word \" is a group of characters separated branch by space outer space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Create a function that returns return true if the last final character \n   of a given establish string is an alphabetical alphabetic character and is not \n   a part contribution of a word, and false otherwise. \n   Note bill: \" word \" is a group of characters separated branch by space outer space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.charAt(txt.length - 1)\n  let isALetter = false\n  \n  if(lastChar ==='' || lastChar ==='' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || lastChar === '_' || lastChar === '-' || last", "passed": 0}
{"task_id": "JavaScript/135", "prompt": "/*Create a function which returns the largest bombastic index of an element component which \n   is not greater than or equal adequate to the element immediately preceding precede it. If \n   no such element exists exist then return -1. The given give array will not contain incorporate \n   duplicate values value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Create a function which returns the largest bombastic index of an element component which \n   is not greater than or equal adequate to the element immediately preceding precede it. If \n   no such element exists exist then return -1. The given give array will not contain incorporate \n   duplicate values value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let max = 0;\n  let maxIndex = 0;\n  let index = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  if (maxIndex > -1) {\n    index = maxIndex;\n  }\n  return index;\n};\n\n/*\n  Given an array of integers arr sort it into ascending order in ascending order \n  and return the sorted array. \n  \n  Examples:\n  sortAsc([1,4,2,3]) = [1,3,2,4]\n  sortAsc([1,4,2,3]) = [2,1,4,3]\n  sortAsc([1,4,2,3]) = [3,2,1,4]\n  sortAsc([1,4,2,3]) = [4,3,2,1]\n  */\nconst sortAsc = (arr) => {\n  let sortedArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    sortedArr.push(arr[i]);\n  }\n  sortedArr.sort((a, b) => a - b);\n  return sortedArr;\n};\n\n/*\n  Given an array of integers arr sort it into descending order in descending order \n  and return the sorted array. \n  \n  Examples:\n  sortDesc([1,4,2,3]) = [3,2,1,4]\n  sortDesc([1,4,2,3]) = [4,3,2,1]\n  sortDesc([1,4,2,3]) = [1,2,4,3]\n  sortDesc([1,4,2,3]) = [1,4,2,3]\n  */\nconst sortDesc = (arr) => {\n  let sortedArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    sortedArr.push(arr[i]);\n  }\n  sortedArr.sort((a, b) => b - a);\n  return sortedArr;\n};\n\n/*\n  Given an array of integers arr sort it into ascending order in ascending order \n  and return the sorted array. \n  \n  Examples:\n  sortAsc([1,4,2,3]) = [1,3,2,4]\n  sortAsc([1,4,2,3]) = [2,1,4,3]\n  sortAsc([1,4,2,3]) = [3,2,1,4]\n  sortAsc([1,4,2,3]) = [4,3,2,1]\n  */\nconst sortAscDesc = (arr) => {\n  let sortedArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    sortedArr.push(arr[i]);\n  }\n  sortedArr.sort((a, b) => b - a);\n  return sortedArr;\n};\n\n/*\n  Given an array of integers arr sort it into ascending order in ascending order \n  and return the sorted array. \n  \n  Examples:\n  sortAsc([1,4,2,3]) = [1,3,2,4]\n  sortAsc([1,4,2,3]) = [2,1,4,3]\n  sortAsc([1,4,2,3]) = [3,2,1,4]\n  sortAsc([1,4,2,3]) = [4,3,2,1]\n  */\nconst sortAscDescByIndex = (arr) => {\n  let sortedArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    sortedArr.push(arr[i]);\n  }\n  sortedArr.sort((a, b) => b - a);\n  return sortedArr;\n};\n\n/*\n  Given an array of integers arr sort it into ascending order in ascending order \n  and return the sorted array. \n  \n  Examples:\n  sortAsc([1,4,2,3]) = [1,3,2,4]\n  sortAsc([1,4,2,3]) = [2,1,4,3]\n  sortAsc([1,4,2,3]) = [3,2,1,4]\n  sortAsc([1,4,2,3]) = [4,3,2,1]\n  */\nconst sortAscDescByValue = (arr) => {\n  let sortedArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    sortedArr.push(arr[i]);\n  }\n  sortedArr.sort((a, b) => b - a);\n  return sortedArr;\n};\n\n/*\n  Given an array of integers arr sort it into ascending order in ascending order \n  and return the sorted array. \n  \n  Examples:\n  sortAsc([1,4,2,3]) = [1,3,2,4]\n  sortAsc([1,4,2,3]) = [2,1,4,3]\n  sortAsc([1,4,2,3]) = [3,2,1,4]\n  sortAsc([1,4,2,3]) = [4,3,2,1]\n  */\nconst sortAscDescByValueIndex = (arr) => {\n  let sortedArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    sortedArr.push(arr[i]);\n  }\n  sortedArr.sort((a, b) => b - a);\n  return sortedArr;\n};\n\n/*\n  Given an array of integers arr sort it into ascending order in ascending order \n  and return the sorted array. \n  \n  Examples:\n  sortAsc([1,4,2,3]) = [1,3,2,4]\n  sortAsc([1,4,2,3]) = [2,1,4,3]\n  sortAsc([1,4,2,3]) = [3,2,1,4]\n  sortAsc([1,4,2,3]) = [4,3,2,1]\n  */\nconst sortAscDescByValueIndexByIndex = (arr) => {\n  let sortedArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    sortedArr.push(arr[i]);\n  }\n  sortedArr.sort((a, b) => b - a);\n  return sortedArr;\n};\n\n/*\n  Given an array of integers arr sort it into ascending order in ascending order \n  and return the sorted array. \n  \n  Examples:\n  sortAsc([1,4,2,3]) = [1,3,2,4]\n  sortAsc([1,4,2,3]) = [2,1,4,3]\n  sortAsc([1,4,2,3]) = [3,2,1,4]\n  sortAsc([1,4,2,3]) = [4,3,2,1]\n  */\nconst sortAscDescByValueIndexByValue = (arr) => {\n  let sortedArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    sortedArr.push(arr[i]);\n  }\n  sortedArr.sort((a, b) => b - a);\n  return sortedArr;\n};\n\n/*\n  Given an array of integers arr sort it into ascending order in ascending order \n  and return the sorted array. \n  \n  Examples:\n  sortAsc([1,4,2,3]) = [1,3,2,4]\n  sortAsc([1,4,2,3]) = [2,1,4,3]\n  sortAsc([1,4,2,3]) = [3,2,1,4]\n  sortAsc([1,4,2,3]) = [4,3,2,1]\n  */\nconst sortAscDescByValueIndexByValueIndex = (arr) => {\n  let sortedArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    sortedArr.push(arr[i]);\n  }\n  sortedArr.sort((a, b) => b - a);\n  return sortedArr;\n};\n\n/*\n  Given an array of integers arr sort it into ascending order in ascending order \n  and return the sorted array. \n  \n  Examples:\n  sortAsc([1,4,2,3]) = [1,3,2,4]\n  sortAsc([1,4,2,3]) = [2,1,4,3]\n  sortAsc([1,4,2,3]) = [3,2,1,4]\n  sortAsc([1,4,2,3]) = [4,3,2,1]\n  */\nconst sortAscDescByValueIndexByValueIndexByIndex = (arr) => {\n  let sortedArr = [];", "passed": 0}
{"task_id": "JavaScript/136", "prompt": "/* Create a function that returns return a tuple (a, b), where 'a' is \n   the largest of negative damaging integers, and 'b' is the smallest humble \n   of positive integers integer in a list.\n   If there is no negative or positive incontrovertible integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Create a function that returns return a tuple (a, b), where 'a' is \n   the largest of negative damaging integers, and 'b' is the smallest humble \n   of positive integers integer in a list.\n   If there is no negative or positive incontrovertible integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  const largestSmallest = (nums) => {\n    const largest = nums.reduce((a, b) => a > b? a : b);\n    return nums.find((num) => num < largest);\n  };\n  return lst.map(num => largestSmallest(num));\n};\n\n/* Create a function that returns return a tuple (a, b), where 'a' is \n   the largest of negative damaging integers, and 'b' is the smallest humble \n   of positive integers integer in a list.\n   If there is no negative or positive incontrovertible integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  const largestSmallest = (nums) => {\n    const largest = nums.reduce((a, b) => a > b? a : b);\n    return nums.find((num) => num > largest);\n  };\n  return lst.map(num => largestSmallest(num));\n};\n\n/* Create a function that returns return a tuple (a, b), where 'a' is \n   the largest of negative damaging integers, and 'b' is the smallest humble \n   of positive integers integer in a list.\n   If there is no negative or positive incontrovertible integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  const largestSmallest = (nums) => {\n    const largest = nums.reduce((a, b) => a > b? a : b);\n    return nums.find((num) => num > largest);\n  };\n  return lst.map(num => largestSmallest(num));\n};\n\n/* Create a function that returns return a tuple (a, b), where 'a' is \n   the largest of negative damaging integers, and 'b' is the smallest humble \n   of positive integers integer in a list.\n   If there is no negative or positive incontrovertible integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  const largestSmallest = (nums) => {\n    const largest = nums.reduce((a, b) => a > b? a : b);\n    return nums.find((num) => num > largest);\n  };\n  return lst.map(num => largestSmallest(num));\n};\n\n/* Create a function that returns return a tuple (a, b), where 'a' is \n   the largest of negative damaging integers, and 'b' is the smallest humble \n   of positive integers integer in a list.\n   If there is no negative or positive incontrovertible integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  const largestSmallest = (nums) => {\n    const largest = nums.reduce((a, b) => a > b? a : b);\n    return nums.find((num) => num > largest);\n  };\n  return lst.map(num => largestSmallest(num));\n};\n\n/* Create a function that returns return a tuple (a, b), where 'a' is \n   the largest of negative damaging integers, and 'b' is the smallest humble \n   of positive integers integer in a list.\n   If there is no negative or positive incontrovertible integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  const largestSmallest = (nums) => {\n    const largest = nums.reduce((a, b) => a > b? a : b);\n    return nums.find((num) => num > largest);\n  };\n  return lst.map(num => largestSmallest(num));\n};\n\n/* Create a function that returns return a tuple (a, b), where 'a' is \n   the largest of negative damaging integers, and 'b' is the smallest humble \n   of positive integers integer in a list.\n   If there is no negative or positive incontrovertible integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  const largestSmallest = (nums) => {\n    const largest = nums.reduce((a, b) => a > b? a : b);\n    return nums.find((num) => num > largest);\n  };\n  return lst.map(num => largestSmallest(num));\n};\n\n/* Create a function that returns return a tuple (a, b), where 'a' is \n   the largest of negative damaging integers, and 'b' is the smallest humble \n   of positive integers integer in a list.\n   If there is no negative or positive incontrovertible integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  const largestSmallest = (nums) => {\n    const largest = nums.reduce((a, b) => a > b? a : b);\n    return nums.find((num) => num > largest);\n  };\n  return lst.map(num => largestSmallest(num));\n};\n\n/* Create a function that returns return a tuple (a, b), where 'a' is \n   the largest of negative damaging integers, and 'b' is the smallest humble \n   of positive integers integer in a list.\n   If there is no negative or positive incontrovertible integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSm", "passed": 0}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a function that takes choose integers, floats air bladder, or strings representing stage \n   real numbers number, and returns the larger bombastic variable variable star in its given variable type character. \n   Return null nothing if the values are equal. \n   Note: If a real actual number phone number is represented exemplify as a string, the floating point might be. or, \n\n   compareOne(1, 2.5) ➞ 2.5 \n   compareOne(1, \" 2,3 \") ➞ \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \") ➞ \" 6 \" \n   compareOne(\"1\", 1) ➞ null \n   * / \n const compareOne = (a, b) = > {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Create a function that takes choose integers, floats air bladder, or strings representing stage \n   real numbers number, and returns the larger bombastic variable variable star in its given variable type character. \n   Return null nothing if the values are equal. \n   Note: If a real actual number phone number is represented exemplify as a string, the floating point might be. or, \n\n   compareOne(1, 2.5) ➞ 2.5 \n   compareOne(1, \" 2,3 \") ➞ \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \") ➞ \" 6 \" \n   compareOne(\"1\", 1) ➞ null \n   * / \n const compareOne = (a, b) = > {\n   const aNum = parseFloat(a);\n   const bNum = parseFloat(b);\n   const aType = typeof aNum;\n   const bType = typeof bNum;\n   const aIsFloat = isNaN(aNum);\n   const bIsFloat = isNaN(bNum);\n   const aIsString = typeof aNum === \"string\";\n   const bIsString = typeof bNum === \"string\";\n   const aIsRealNumber = aIsFloat || aIsString;\n   const bIsRealNumber = bIsFloat || bIsString;\n   const aIsNumber = aIsFloat || aIsString || aIsRealNumber;\n   const bIsNumber = bIsFloat || bIsString || bIsRealNumber;\n   const aIsInt = aIsFloat || aIsString || aIsRealNumber || aIsNumber;\n   const bIsInt = bIsFloat || bIsString || bIsRealNumber || bIsNumber;\n   const aIsBool = typeof aNum === \"boolean\";\n   const bIsBool = typeof bNum === \"boolean\";\n   const aIsNull = aIsFloat || aIsString || aIsRealNumber || aIsNumber || aIsBool;\n   const bIsNull = bIsFloat || bIsString || bIsRealNumber || bIsNumber || bIsBool;\n   const aIsUndefined = aIsFloat || aIsString || aIsRealNumber || aIsNumber || aIsBool || aIsNull;\n   const bIsUndefined = bIsFloat || bIsString || bIsRealNumber || bIsNumber || bIsBool || bIsNull;\n   const aIsInt = aIsFloat || aIsString || aIsRealNumber || aIsNumber || aIsBool || aIsNull;\n   const bIsInt = bIsFloat || bIsString || bIsRealNumber || bIsNumber || bIsBool || bIsNull;\n   const aIsFloat = aIsFloat || aIsString || aIsRealNumber || aIsNumber || aIsBool;\n   const bIsFloat = bIsFloat || bIsString || bIsRealNumber || bIsNumber || bIsBool;\n   const aIsInt = aIsFloat || aIsString || aIsRealNumber || aIsNumber || aIsBool;\n   const bIsInt = bIsFloat || bIsString || bIsRealNumber || bIsNumber || bIsBool;\n   const aIsBool = typeof aNum === \"boolean\";\n   const bIsBool = typeof bNum === \"boolean\";\n   const aIsNull = aIsFloat || aIsString || aIsRealNumber || aIsNumber || aIsBool;\n   const bIsNull = bIsFloat || bIsString || bIsRealNumber || bIsNumber || bIsBool;\n   const aIsUndefined = aIsFloat || aIsString || aIsRealNumber || aIsNumber || aIsBool || aIsNull;\n   const bIsUndefined = bIsFloat || bIsString || bIsRealNumber || bIsNumber || bIsBool || bIsNull;\n   const aIsInt = aIsFloat || aIsString || aIsRealNumber || aIsNumber || aIsBool || aIsNull;\n   const bIsInt = bIsFloat || bIsString || bIsRealNumber || bIsNumber || bIsBool || bIsNull;\n   const aIsFloat = aIsFloat || aIsString || aIsRealNumber || aIsNumber || aIsBool;\n   const bIsFloat = bIsFloat || bIsString || bIsRealNumber || bIsNumber || bIsBool;\n   const aIsInt = aIsFloat || aIsString || aIsRealNumber || aIsNumber || aIsBool;\n   const bIsInt = bIsFloat || bIsString || bIsRealNumber || bIsNumber || bIsBool;\n   const aIsBool = typeof aNum === \"boolean\";\n   const bIsBool = typeof bNum === \"boolean\";\n   const aIsNull = aIsFloat || aIsString || aIsRealNumber || aIsNumber || aIsBool;\n   const bIsNull = bIsFloat || bIsString || bIsRealNumber || bIsNumber || bIsBool;\n   const aIsUndefined = aIsFloat || aIsString || aIsRealNumber || aIsNumber || aIsBool || aIsNull;\n   const bIsUndefined = bIsFloat || bIsString || bIsRealNumber || bIsNumber || bIsBool || bIsNull;\n   const aIsInt = aIsFloat || aIsString || aIsRealNumber || aIsNumber || aIsBool || aIsNull;\n   const bIsInt = bIsFloat || bIsString || bIsRealNumber || bIsNumber || bIsBool || bIsNull;\n   const aIsFloat = aIsFloat || aIsString || aIsRealNumber || aIsNumber || aIsBool;\n   const bIsFloat = bIsFloat || bIsString || bIsRealNumber || bIsNumber || bIsBool;\n   const aIsInt = aIsFloat || aIsString || aIsRealNumber || aIsNumber || aIsBool;\n   const bIsInt = bIsFloat || bIsString || bIsRealNumber || bIsNumber || bIsBool;\n   const aIsBool = typeof aNum === \"boolean\";\n   const bIsBool = typeof bNum === \"boolean\";\n   const aIsNull = aIsFloat || aIsString || aIsRealNumber || aIsNumber || aIsBool;\n   const bIsNull = bIsFloat || bIsString || bIsRealNumber || bIsNumber || bIsBool;\n   const aIsUndefined = aIsFloat || aIsString || aIsRealNumber || aIsNumber || aIsBool || aIsNull;\n   const bIsUndefined = bIsFloat || bIsString || bIsRealNumber || bIsNumber || bIsBool || bIsNull;\n   const aIsInt = aIsFloat || aIsString || aIsRealNumber || aIsNumber || aIsBool || aIsNull;\n   const bIsInt = bIsFloat || bIsString ", "passed": 0}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate whether the given number numeral n can be written as the sum kernel of exactly 4 positive cocksure even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Evaluate whether the given number numeral n can be written as the sum kernel of exactly 4 positive cocksure even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 4 === 0;\n};\n\n/*\n  Evaluate whether the given number numeral n can be written as the product kernel of exactly 4 positive cocksure even numbers\n  Example\n  isEqualToProductEven(4) == false\n  isEqualToProductEven(6) == false\n  isEqualToProductEven(8) == true\n  */\nconst isEqualToProductEven = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    product *= i;\n  }\n  return product % 4 === 0;\n};\n\n/*\n  Evaluate whether the given number numeral n can be written as the product kernel of exactly 4 positive cocksure odd numbers\n  Example\n  isEqualToProductOdd(4) == false\n  isEqualToProductOdd(6) == false\n  isEqualToProductOdd(8) == true\n  */\nconst isEqualToProductOdd = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    product *= i;\n  }\n  return product % 4 === 1;\n};\n\n/*\n  Evaluate whether the given number numeral n can be written as the product kernel of exactly 4 negative cocksure even numbers\n  Example\n  isEqualToNegativeSumEven(4) == false\n  isEqualToNegativeSumEven(6) == false\n  isEqualToNegativeSumEven(8) == true\n  */\nconst isEqualToNegativeSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 4 === 0;\n};\n\n/*\n  Evaluate whether the given number numeral n can be written as the product kernel of exactly 4 negative cocksure odd numbers\n  Example\n  isEqualToNegativeSumOdd(4) == false\n  isEqualToNegativeSumOdd(6) == false\n  isEqualToNegativeSumOdd(8) == true\n  */\nconst isEqualToNegativeSumOdd = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    product *= i;\n  }\n  return product % 4 === 1;\n};\n\n/*\n  Evaluate whether the given number numeral n can be written as the product kernel of exactly 4 positive cocksure even numbers\n  Example\n  isEqualToPositiveSumEven(4) == false\n  isEqualToPositiveSumEven(6) == false\n  isEqualToPositiveSumEven(8) == true\n  */\nconst isEqualToPositiveSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 4 === 0;\n};\n\n/*\n  Evaluate whether the given number numeral n can be written as the product kernel of exactly 4 positive cocksure odd numbers\n  Example\n  isEqualToPositiveSumOdd(4) == false\n  isEqualToPositiveSumOdd(6) == false\n  isEqualToPositiveSumOdd(8) == true\n  */\nconst isEqualToPositiveSumOdd = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    product *= i;\n  }\n  return product % 4 === 1;\n};\n\n/*\n  Evaluate whether the given number numeral n can be written as the product kernel of exactly 4 negative cocksure even numbers\n  Example\n  isEqualToNegativeSumEven(4) == false\n  isEqualToNegativeSumEven(6) == false\n  isEqualToNegativeSumEven(8) == true\n  */\nconst isEqualToNegativeSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 4 === 0;\n};\n\n/*\n  Evaluate whether the given number numeral n can be written as the product kernel of exactly 4 negative cocksure odd numbers\n  Example\n  isEqualToNegativeSumOdd(4) == false\n  isEqualToNegativeSumOdd(6) == false\n  isEqualToNegativeSumOdd(8) == true\n  */\nconst isEqualToNegativeSumOdd = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    product *= i;\n  }\n  return product % 4 === 1;\n};\n\n/*\n  Evaluate whether the given number numeral n can be written as the product kernel of exactly 4 positive cocksure even numbers\n  Example\n  isEqualToPositiveSumEven(4) == false\n  isEqualToPositiveSumEven(6) == false\n  isEqualToPositiveSumEven(8) == true\n  */\nconst isEqualToPositiveSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 4 === 0;\n};\n\n/*\n  Evaluate whether the given number numeral n can be written as the product kernel of exactly 4 positive cocksure odd numbers\n  Example\n  isEqualToPositiveSumOdd(4) == false\n  isEqualToPositiveSumOdd(6) == false\n  isEqualToPositiveSumOdd(8) == true\n  */\nconst isEqualToPositiveSumOdd = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    product *= i;\n  }\n  return product % 4 === 1;\n};\n\n/*\n  Evaluate whether the given number numeral n can be written as the product kernel of exactly 4 negative cocksure even numbers\n  Example\n  isEqualToNegativeSumEven(4) == false\n  isEqualToNegativeSumEven(6) == false\n  isEqualToNegativeSumEven(8) == true\n  */\nconst isEqualToNegativeSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 4 === 0;\n};\n\n/*\n  Evaluate whether the given number numeral n can be written as the product kernel of exactly 4 negative cocksure odd numbers\n  Example\n  isEqualToNegativeSumOdd(4) == false\n  isEqualToNegativeSumOdd(6) == false\n  isEqualToNegativeSumOdd(8) == true\n  */\nconst isEqualToNegativeSumOdd = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    product *= i;\n  }\n  return product % 4 === 1;\n};\n\n/*\n  Evaluate whether the given number numeral n can be written as the product kernel of exactly 4 positive cocksure even numbers\n  Example\n  isEqualToPositiveSumEven(4) == false\n  isEqualToPositiveSumEven(6) == false\n  isEqualToPositiveSumEven(8) == true\n  */\nconst isEqualToPositiveSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 4 === 0;\n};\n\n/*\n  Evaluate whether the given number numeral n can be written as the product kernel of exactly 4 positive cocksure odd numbers\n  Example\n  isEqualToPositiveSumOdd(4) == false\n  isEqualToPositiveSumOdd(6) == false\n  isEqualToPositiveSumOdd(8) == true\n  */\nconst isEqualToPositiveSumOdd = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    product *= i;\n  }\n  return product % 4 === 1;\n};\n\n/*\n  Evaluate whether the ", "passed": 0}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*The Brazilian factorial is defined as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * n * n * n * n * n * n;\n};\n\n/*\n  Given a number n, return the factorial of n raised to the power n.\n  For example:\n  >>> factorial(4)\n  120\n\n  >>> factorial(5)\n  720\n*/\nconst factorial = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * ", "passed": 0}
{"task_id": "JavaScript/14", "prompt": "/* Return list of all prefixes from shortest to longest long of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Return list of all prefixes from shortest to longest long of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  const prefixes = [];\n  let currentPrefix = string;\n  while (currentPrefix.length > 0) {\n    prefixes.push(currentPrefix.slice(0, -1));\n    currentPrefix = currentPrefix.slice(-1);\n  }\n  return prefixes;\n};\n\n// Return list of all suffixes from shortest to longest long of the input string\nconst allSuffixes = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.push(currentSuffix.slice(0, -1));\n    currentSuffix = currentSuffix.slice(-1);\n  }\n  return suffixes;\n};\n\n// Return list of all common prefixes from shortest to longest long of the input string\nconst allCommonPrefixes = (string) => {\n  const prefixes = [];\n  let currentPrefix = string;\n  while (currentPrefix.length > 0) {\n    prefixes.push(currentPrefix.slice(0, -1));\n    currentPrefix = currentPrefix.slice(-1);\n  }\n  return prefixes.filter(prefix => prefixes.every(prefix => string.startsWith(prefix)));\n};\n\n// Return list of all common suffixes from shortest to longest long of the input string\nconst allCommonSuffixes = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.push(currentSuffix.slice(0, -1));\n    currentSuffix = currentSuffix.slice(-1);\n  }\n  return suffixes.filter(suffix => suffixes.every(suffix => string.endsWith(suffix)));\n};\n\n// Return list of all common prefixes from longest to shortest long of the input string\nconst allCommonPrefixesLongestToShortest = (string) => {\n  const prefixes = [];\n  let currentPrefix = string;\n  while (currentPrefix.length > 0) {\n    prefixes.push(currentPrefix.slice(0, -1));\n    currentPrefix = currentPrefix.slice(-1);\n  }\n  return prefixes.filter(prefix => prefixes.every(prefix => string.startsWith(prefix)));\n};\n\n// Return list of all common suffixes from longest to shortest long of the input string\nconst allCommonSuffixesLongestToShortest = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.push(currentSuffix.slice(0, -1));\n    currentSuffix = currentSuffix.slice(-1);\n  }\n  return suffixes.filter(suffix => suffixes.every(suffix => string.endsWith(suffix)));\n};\n\n// Return list of all common prefixes from shortest to longest long of the input string\nconst allCommonPrefixesLongestToShortest = (string) => {\n  const prefixes = [];\n  let currentPrefix = string;\n  while (currentPrefix.length > 0) {\n    prefixes.push(currentPrefix.slice(0, -1));\n    currentPrefix = currentPrefix.slice(-1);\n  }\n  return prefixes.filter(prefix => prefixes.every(prefix => string.startsWith(prefix)));\n};\n\n// Return list of all common suffixes from longest to shortest long of the input string\nconst allCommonSuffixesLongestToShortest = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.push(currentSuffix.slice(0, -1));\n    currentSuffix = currentSuffix.slice(-1);\n  }\n  return suffixes.filter(suffix => suffixes.every(suffix => string.endsWith(suffix)));\n};\n\n// Return list of all common prefixes from shortest to longest long of the input string\nconst allCommonPrefixesLongestToShortest = (string) => {\n  const prefixes = [];\n  let currentPrefix = string;\n  while (currentPrefix.length > 0) {\n    prefixes.push(currentPrefix.slice(0, -1));\n    currentPrefix = currentPrefix.slice(-1);\n  }\n  return prefixes.filter(prefix => prefixes.every(prefix => string.startsWith(prefix)));\n};\n\n// Return list of all common suffixes from longest to shortest long of the input string\nconst allCommonSuffixesLongestToShortest = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.push(currentSuffix.slice(0, -1));\n    currentSuffix = currentSuffix.slice(-1);\n  }\n  return suffixes.filter(suffix => suffixes.every(suffix => string.endsWith(suffix)));\n};\n\n// Return list of all common prefixes from shortest to longest long of the input string\nconst allCommonPrefixesLongestToShortest = (string) => {\n  const prefixes = [];\n  let currentPrefix = string;\n  while (currentPrefix.length > 0) {\n    prefixes.push(currentPrefix.slice(0, -1));\n    currentPrefix = currentPrefix.slice(-1);\n  }\n  return prefixes.filter(prefix => prefixes.every(prefix => string.startsWith(prefix)));\n};\n\n// Return list of all common suffixes from longest to shortest long of the input string\nconst allCommonSuffixesLongestToShortest = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.push(currentSuffix.slice(0, -1));\n    currentSuffix = currentSuffix.slice(-1);\n  }\n  return suffixes.filter(suffix => suffixes.every(suffix => string.endsWith(suffix)));\n};\n\n// Return list of all common prefixes from shortest to longest long of the input string\nconst allCommonPrefixesLongestToShortest = (string) => {\n  const prefixes = [];\n  let currentPrefix = string;\n  while (currentPrefix.length > 0) {\n    prefixes.push(currentPrefix.slice(0, -1));\n    currentPrefix = currentPrefix.slice(-1);\n  }\n  return prefixes.filter(prefix => prefixes.every(prefix => string.startsWith(prefix)));\n};\n\n// Return list of all common suffixes from longest to shortest long of the input string\nconst allCommonSuffixesLongestToShortest = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.push(currentSuffix.slice(0, -1));\n    currentSuffix = currentSuffix.slice(-1);\n  }\n  return suffixes.filter(suffix => suffixes.every(suffix => string.endsWith(suffix)));\n};\n\n// Return list of all common prefixes from shortest to longest long of the input string\nconst allCommonPrefixesLongestToShortest = (string) => {\n  const prefixes = [];\n  let currentPrefix = string;\n  while (currentPrefix.length > 0) {\n    prefixes.push(currentPrefix.slice(0, -1));\n    currentPrefix = currentPrefix.slice(-1);\n  }\n  return prefixes.filter(prefix => prefixes.every(prefix => string.startsWith(prefix)));\n};\n\n// Return list of all common suffixes from longest to shortest long of the input string\nconst allCommonSuffixesLongestToShortest = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.push(currentSuffix.slice(0, -1));\n    currentSuffix = currentSuffix.slice(-1);\n  }\n  return suffixes.filter(suffix => suffixes.every(suffix => string.endsWith(suffix)));\n};\n\n// Return list of all common prefixes from shortest to longest long of the input string\nconst allCommonPrefixesLongestToShortest = (string) => {\n  const prefixes = [];\n  let currentPrefix = string;\n  while (currentPrefix.length > 0) {\n    prefix", "passed": 0}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a string text, replace substitute all spaces in it with underscores underscore, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace supplant all consecutive spaces space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a string text, replace substitute all spaces in it with underscores underscore, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace supplant all consecutive spaces space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  let newText = text;\n  let spaces = text.split(' ');\n  spaces.forEach((space) => {\n    if (space.length > 1) {\n      newText = newText.replace(space, '-');\n    }\n  });\n  return newText;\n};\n\n/*\n  Given a string text, replace all spaces in it with underscores underscore, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace supplant all consecutive spaces space with - \n  \n   fixSpaces(\" Example\") == \"Example\"\n  fixSpaces(\" Example 1\") == \"Example_1\"\n  fixSpaces(\" Example   2\") == \"Example_2\"\n  fixSpaces(\" Example   3\") == \"Example_3\"\n  */\nconst fixSpaces = (text) => {\n  let newText = text;\n  let spaces = text.split(' ');\n  spaces.forEach((space) => {\n    if (space.length > 1) {\n      newText = newText.replace(space, '-');\n    }\n  });\n  return newText;\n};\n\n/*\n  Given a string text, replace all spaces in it with underscores underscore, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace supplant all consecutive spaces space with - \n  \n   fixSpaces(\" Example\") == \"Example\"\n  fixSpaces(\" Example 1\") == \"Example_1\"\n  fixSpaces(\" Example   2\") == \"Example_2\"\n  fixSpaces(\" Example   3\") == \"Example_3\"\n  */\nconst fixSpaces = (text) => {\n  let newText = text;\n  let spaces = text.split(' ');\n  spaces.forEach((space) => {\n    if (space.length > 1) {\n      newText = newText.replace(space, '-');\n    }\n  });\n  return newText;\n};\n\n/*\n  Given a string text, replace all spaces in it with underscores underscore, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace supplant all consecutive spaces space with - \n  \n   fixSpaces(\" Example\") == \"Example\"\n  fixSpaces(\" Example 1\") == \"Example_1\"\n  fixSpaces(\" Example   2\") == \"Example_2\"\n  fixSpaces(\" Example   3\") == \"Example_3\"\n  */\nconst fixSpaces = (text) => {\n  let newText = text;\n  let spaces = text.split(' ');\n  spaces.forEach((space) => {\n    if (space.length > 1) {\n      newText = newText.replace(space, '-');\n    }\n  });\n  return newText;\n};\n\n/*\n  Given a string text, replace all spaces in it with underscores underscore, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace supplant all consecutive spaces space with - \n  \n   fixSpaces(\" Example\") == \"Example\"\n  fixSpaces(\" Example 1\") == \"Example_1\"\n  fixSpaces(\" Example   2\") == \"Example_2\"\n  fixSpaces(\" Example   3\") == \"Example_3\"\n  */\nconst fixSpaces = (text) => {\n  let newText = text;\n  let spaces = text.split(' ');\n  spaces.forEach((space) => {\n    if (space.length > 1) {\n      newText = newText.replace(space, '-');\n    }\n  });\n  return newText;\n};\n\n/*\n  Given a string text, replace all spaces in it with underscores underscore, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace supplant all consecutive spaces space with - \n  \n   fixSpaces(\" Example\") == \"Example\"\n  fixSpaces(\" Example 1\") == \"Example_1\"\n  fixSpaces(\" Example   2\") == \"Example_2\"\n  fixSpaces(\" Example   3\") == \"Example_3\"\n  */\nconst fixSpaces = (text) => {\n  let newText = text;\n  let spaces = text.split(' ');\n  spaces.forEach((space) => {\n    if (space.length > 1) {\n      newText = newText.replace(space, '-');\n    }\n  });\n  return newText;\n};\n\n/*\n  Given a string text, replace all spaces in it with underscores underscore, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace supplant all consecutive spaces space with - \n  \n   fixSpaces(\" Example\") == \"Example\"\n  fixSpaces(\" Example 1\") == \"Example_1\"\n  fixSpaces(\" Example   2\") == \"Example_2\"\n  fixSpaces(\" Example   3\") == \"Example_3\"\n  */\nconst fixSpaces = (text) => {\n  let newText = text;\n  let spaces = text.split(' ');\n  spaces.forEach((space) => {\n    if (space.length > 1) {\n      newText = newText.replace(space, '-');\n    }\n  });\n  return newText;\n};\n\n/*\n  Given a string text, replace all spaces in it with underscores underscore, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace supplant all consecutive spaces space with - \n  \n   fixSpaces(\" Example\") == \"Example\"\n  fixSpaces(\" Example 1\") == \"Example_1\"\n  fixSpaces(\" Example   2\") == \"Example_2\"\n  fixSpaces(\" Example   3\") == \"Example_3\"\n  */\nconst fixSpaces = (text) => {\n  let newText = text;\n  let spaces = text.split(' ');\n  spaces.forEach((space) => {\n    if (space.length > 1) {\n      newText = newText.replace(space, '-');\n    }\n  });\n  return newText;\n};\n\n/*\n  Given a string text, replace all spaces in it with underscores underscore, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace supplant all consecutive spaces space with - \n  \n   fixSpaces(\" Example\") == \"Example\"\n  fixSpaces(\" Example 1\") == \"Example_1\"\n  fixSpaces(\" Example   2\") == \"Example_2\"\n  fixSpaces(\" Example   3\") == \"Example_3\"\n  */\nconst fixSpaces = (text) => {\n  let newText = text;\n  let spaces = text.split(' ');\n  spaces.forEach((space) => {\n    if (space.length > 1) {\n      newText = newText.replace(space, '-');\n    }\n  });\n  return newText;\n};\n\n/*\n  Given a string text, replace all spaces in it with underscores underscore, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace supplant all consecutive spaces space with - \n  \n   fixSpaces(\" Example\") == \"Example\"\n  fixSpaces(\" Example 1\") == \"Example_1\"\n  fixSpaces(\" Example   2\") == \"Example_2\"\n  fixSpaces(\" Example   3\") == \"Example_3\"\n  */\nconst fixSpaces = (text) => {\n  let newText = text;\n  let spaces = text.split('", "passed": 0}
{"task_id": "JavaScript/141", "prompt": "/*Create a function which takes a string bowed stringed instrument representing a file's name, and returns return \n  ' Yes' if the the file's name is valid, and returns' No' otherwise differently. \n   A file's name is considered to be valid if and only if all the following trace conditions circumstance \n   are met: \n   - There should not be more than three digits (' 0'-'9') in the file's name. \n   - The file's name contains exactly one dot department of transportation'.' \n   - The substring before the dot should not be empty, and it starts with a letter from \n   the latin alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot department of transportation should be one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Create a function which takes a string bowed stringed instrument representing a file's name, and returns return \n 'Yes' if the the file's name is valid, and returns' No' otherwise differently. \n   A file's name is considered to be valid if and only if all the following trace conditions circumstance \n   are met: \n   - There should not be more than three digits (' 0'-'9') in the file's name. \n   - The file's name contains exactly one dot department of transportation'.' \n   - The substring before the dot should not be empty, and it starts with a letter from \n   the latin alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot department of transportation should be one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const file_name_without_extension = file_name.split('.')[0];\n  const file_name_without_extension_length = file_name_without_extension.length;\n  const file_name_without_extension_digits = file_name_without_extension_length.toString().split('')\n   .filter((digit) => digit.toString().length === file_name_without_extension_digits.length)\n   .map((digit) => digit.toString().padStart(file_name_without_extension_digits.length, '0'));\n  const file_name_without_extension_digits_string = file_name_without_extension_digits.join('');\n  const file_name_without_extension_digits_string_length = file_name_without_extension_digits_string.length;\n  const file_name_without_extension_digits_string_digits = file_name_without_extension_digits_string.split('')\n   .filter((digit) => digit.toString().length === file_name_without_extension_digits_string_digits.length)\n   .map((digit) => digit.toString().padStart(file_name_without_extension_digits_string_digits.length, '0'));\n  const file_name_without_extension_digits_string_digits_string = file_name_without_extension_digits_string_digits.join('');\n  const file_name_without_extension_digits_string_digits_string_length = file_name_without_extension_digits_string_digits_string.length;\n  const file_name_without_extension_digits_string_digits_string_digits = file_name_without_extension_digits_string_digits_string.split('')\n   .filter((digit) => digit.toString().length === file_name_without_extension_digits_string_digits_string_digits.length)\n   .map((digit) => digit.toString().padStart(file_name_without_extension_digits_string_digits_string_digits.length, '0'));\n  const file_name_without_extension_digits_string_digits_string_digits_string = file_name_without_extension_digits_string_digits_string_digits_string.join('');\n  const file_name_without_extension_digits_string_digits_string_digits_string_length = file_name_without_extension_digits_string_digits_string_digits_string.length;\n  const file_name_without_extension_digits_string_digits_string_digits_string_digits = file_name_without_extension_digits_string_digits_string_digits_string.split('')\n   .filter((digit) => digit.toString().length === file_name_without_extension_digits_string_digits_string_digits_string_digits.length)\n   .map((digit) => digit.toString().padStart(file_name_without_extension_digits_string_digits_string_digits_string_digits.length, '0'));\n  const file_name_without_extension_digits_string_digits_string_digits_string_digits_string = file_name_without_extension_digits_string_digits_string_digits_string_digits_string.join('');\n  const file_name_without_extension_digits_string_digits_string_digits_string_digits_string_length = file_name_without_extension_digits_string_digits_string_digits_string_digits_string.length;\n  const file_name_without_extension_digits_string_digits_string_digits_string_digits_string_digits = file_name_without_extension_digits_string_digits_string_digits_string_digits_string.split('')\n   .filter((digit) => digit.toString().length === file_name_without_extension_digits_string_digits_string_digits_string_digits_string_digits.length)\n   .map((digit) => digit.toString().padStart(file_name_without_extension_digits_string_digits_string_digits_string_digits_string_digits_string.length, '0'));\n  const file_name_without_extension_digits_string_digits_string_digits_string_digits_string_digits_string = file_name_without_extension_digits_string_digits_string_digits_string_digits_string_digits_string.join('');\n  const file_name_without_extension_digits_string_digits_string_digits_string_digits_string_digits_string_length = file_name_without_extension_digits_string_digits_string_digits_string_digits_string_digits_string.length;\n  const file_name_without_extension_digits_string_digits_string_digits_string_digits_string_digits_string_digits = file_name_without_extension_digits_string_digits_string_digits_string_digits_string_digits_string.split('')\n   .filter((digit) => digit.toString().length === file_name_without_extension_digits_string_digits_string_digits_string_digits_string_digits_string_digits_string.length)\n   .map((digit) => digit.toString().padStart(file_name_without_extension_digits_string_digits_string_digits_string_digits_string_digits_string_digits_string.length, '0'));\n  const file_name_without_extension_digits_string_digits_string_digits_string_digits_string_digits_string_digits = file_name_without_extension_digits_string_digits_string_digits_string_digits_string_digits_string_digits_string.join('');\n  const file_name_without_extension_digits_string_digits_string_digits_string_digits_string_digits_string_digits_string_length = file_name_without_extension_digits_string_digits_string_digits_string_digits_string_digits_string_digits_string.length;\n  const file_name_without_extension_digits_string_digits_string_digits_string_digits_string_digits_string_digits_string_digits = file_name_without_extension_digits_string_digits_string_digits_string_digits_string_digits_string_digits_string.split('')\n   .filter((digit) => digit.toString().length === file_name_without_extension_digits_string_digits_string_digits_string_digits_string_digits_string_digits_string.length)\n   .map((digit) => digit.toString().padStart(file_name_without_extension_digits_string_digits_string_digits_string_digits_string_digits_string_digits_string.length, '0'));\n  const file_name_without_extension_digits_string_digits_string_digits_string_digits_string_digits_string_digits_string_digits = file_name_without_extension_digits_string_digits_string_digits_string_digits_string_digits_string_digits_string.join('');\n  const file_name_without_extension_digits_string_digits_string_digits_string_digits_string_digits_string_digits_string_digits_string_length = file_name_without_extension_digits_string_digits_string_digits_string_digits_string_digits_string_digits_string.length;\n  const file_name_without_extension_digits_string_digits_string_digits_string_digits_string_digits_string_digits_string_digits_string_digits = file_name_without_extension_digits_string_digits_string_digits_string_digits_string_digits_string_digits_string_digits_string.split('')\n   .filter((digit) => digit.toString().length === file_name_without_extension_digits_string_digits_string_digits_string_digits_string_digits_string_digits_string.length)\n   .map((digit) => digit.toString().padStart(file_name_without_extension_digits_string_digits_string_digits_string_digits_string_digits_string_digits_string.length, '0'));", "passed": 0}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function will take a list of integers integer. For all entries in the list, the function routine shall square the integer entry entrance if its index is a \n   multiple of 3 and will cube the integer entry entrance if its index is a multiple of 4 and not a multiple of 3. The function affair will not \n   change deepen the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum kernel of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\"\n  This function will take a list of integers integer. For all entries in the list, the function routine shall square the integer entry entrance if its index is a \n   multiple of 3 and will cube the integer entry entrance if its index is a multiple of 4 and not a multiple of 3. The function affair will not \n   change deepen the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum kernel of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  \n  lst.forEach((el, i) => {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += el * el;\n    }\n  });\n  \n  return sum;\n};\n\n/*\n  Given a list lst, this function will take a list of integers integer. For all entries in the list, the function routine shall cube the integer entry entrance if its index is a multiple of 3 and will square \n   the integer entry entrance if its index is a multiple of 4 and not a multiple of 3. The function affair will not change deepen the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum kernel of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubes = (lst) => {\n  let sum = 0;\n  \n  lst.forEach((el, i) => {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += el * el;\n    }\n  });\n  \n  return sum;\n};\n\n/*\n  Given a list lst, this function will take a list of integers integer. For all entries in the list, the function routine shall cube the integer entry entrance if its index is a multiple of 3 and will square \n   the integer entry entrance if its index is a multiple of 4 and not a multiple of 3. The function affair will not change deepen the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum kernel of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sum4Cubes = (lst) => {\n  let sum = 0;\n  \n  lst.forEach((el, i) => {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += el * el;\n    }\n  });\n  \n  return sum;\n};\n\n/*\n  Given a list lst, this function will take a list of integers integer. For all entries in the list, the function routine shall cube the integer entry entrance if its index is a multiple of 3 and will square \n   the integer entry entrance if its index is a multiple of 4 and not a multiple of 3. The function affair will not change deepen the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum kernel of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sum4Squares = (lst) => {\n  let sum = 0;\n  \n  lst.forEach((el, i) => {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += el * el;\n    }\n  });\n  \n  return sum;\n};\n\n/*\n  Given a list lst, this function will take a list of integers integer. For all entries in the list, the function routine shall cube the integer entry entrance if its index is a multiple of 3 and will square \n   the integer entry entrance if its index is a multiple of 4 and not a multiple of 3. The function affair will not change deepen the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum kernel of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sum4Cubes4Squares = (lst) => {\n  let sum = 0;\n  \n  lst.forEach((el, i) => {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += el * el;\n    }\n  });\n  \n  return sum;\n};\n\n/*\n  Given a list lst, this function will take a list of integers integer. For all entries in the list, the function routine shall cube the integer entry entrance if its index is a multiple of 3 and will square \n   the integer entry entrance if its index is a multiple of 4 and not a multiple of 3. The function affair will not change deepen the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum kernel of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sum4Cubes4Cubes = (lst) => {\n  let sum = 0;\n  \n  lst.forEach((el, i) => {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += el * el;\n    }\n  });\n  \n  return sum;\n};\n\n/*\n  Given a list lst, this function will take a list of integers integer. For all entries in the list, the function routine shall cube the integer entry entrance if its index is a multiple of 3 and will square \n   the integer entry entrance if its index is a multiple of 4 and not a multiple of 3. The function affair will not change deepen the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum kernel of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sum4Cubes4Squares4Cubes = (lst) => {\n  let sum = 0;\n  \n  lst.forEach((el, i) => {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += el * el;\n    }\n  });\n  \n  return sum;\n};\n\n/*\n  Given a list lst, this function will take a list of integers integer. For all entries in the list, the function routine shall cube the integer entry entrance if its index is a multiple of 3 and will square \n   the integer entry entrance if its index is a multiple of 4 and not a multiple of 3. The function affair will not change deepen the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum kernel of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sum4Cubes4Squares4Squares4Cubes = (lst) => {\n  let sum = 0;\n  \n  lst.forEach((el, i) => {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += el * el;\n    }\n  });\n  \n  return sum;\n};\n\n/*\n  Given a list lst, this function will take a list of integers ", "passed": 0}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given a string representing present a sentence,\n   the sentence contains some words word separated by a space quad, \n   and you have to return a string that contains hold the words from the original sentence,\n   whose lengths distance are prime numbers, \n   the order of the words discussion in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a string representing present a sentence,\n   the sentence contains some words word separated by a space quad, \n   and you have to return a string that contains hold the words from the original sentence,\n   whose lengths distance are prime numbers, \n   the order of the words discussion in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let words = sentence.split(\" \");\n  let distances = [];\n  let newWords = [];\n  let newDistances = [];\n  let newWordsLength = 0;\n  let newDistancesLength = 0;\n  let newWordsIndex = 0;\n  let newDistancesIndex = 0;\n  let newWordsLengthIndex = 0;\n  let newDistancesLengthIndex = 0;\n  let newWordsIndexIndex = 0;\n  let newDistancesIndexIndex = 0;\n  let newWordsLengthIndexIndex = 0;\n  let newDistancesLengthIndexIndex = 0;\n  let newWordsIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndex = 0;\n  let newWordsIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLengthIndexIndexIndex = 0;\n  let newDistancesLengthIndexIndexIndex = 0;\n  let newWordsIndexIndexIndexIndex = 0;\n  let newDistancesIndexIndexIndexIndex = 0;\n  let newWordsLength", "passed": 0}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a function routine that will simplify the expression \n   x * n. The function routine returns true truthful if x * n evaluates to a whole solid number and false assumed \n   otherwise. Both x and n, are string representation of a fraction, and have the following play along format, \n   < numerator>/<denominator > where both numerator and denominator are positive convinced whole solid numbers numeral. \n\n   You can assume that x, and n are valid fractions, and do not have zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = true \n   simplify(\"1/6\", \" 2/1 \") = false assumed \n   simplify(\"7/10\", \" 10/2 \") = false assumed \n   * / \n const simplify = (x, n) = > {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Your task is to implement a function routine that will simplify the expression \n   x * n. The function routine returns true truthful if x * n evaluates to a whole solid number and false assumed \n   otherwise. Both x and n, are string representation of a fraction, and have the following play along format, \n   < numerator>/<denominator > where both numerator and denominator are positive convinced whole solid numbers numeral. \n\n   You can assume that x, and n are valid fractions, and do not have zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = true \n   simplify(\"1/6\", \" 2/1 \") = false assumed \n   simplify(\"7/10\", \" 10/2 \") = false assumed \n   * / \n const simplify = (x, n) = > {\n   let [numerator, denominator] = x.split('/').map(Number);\n   numerator = numerator.toFixed(denominator.length);\n   denominator = denominator.toFixed(denominator.length);\n   let [numeratorPart, denominatorPart] = numerator.split('.');\n   let [numeratorPart, denominatorPart] = denominator.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');\n   let [numeratorPart, denominatorPart] = numeratorPart.split('.');", "passed": 0}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a function which sorts classify the given list of integers integer \n   in ascending order holy order according to the sum union of their digits. \n   Note bill: if there are several respective items with similar sum union of their digits digit, \n   order them based on their index in original master list.\n\n   For example exercise:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function which sorts classify the given list of integers integer \n   in ascending order holy order according to the sum union of their digits. \n   Note bill: if there are several respective items with similar sum union of their digits digit, \n   order them based on their index in original master list.\n\n   For example exercise:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sortedNums = nums.sort((a, b) => a - b);\n  const sortedNumsDigits = sortedNums.map(n => n.toString().split('').reverse().join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.split('').map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n => n.map(c => parseInt(c, 10)).join(''));\n  const sortedNumsDigits = sortedNumsDigits.map(n ", "passed": 0}
{"task_id": "JavaScript/146", "prompt": "/*Write a function that takes an array of numbers numeral as input and returns reappearance \n   the number of elements in the array that are greater bang-up than 10 and both \n   first and last concluding digits of a number issue are odd leftover (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Write a function that takes an array of numbers numeral as input and returns reappearance \n   the number of elements in the array that are greater bang-up than 10 and both \n   first and last concluding digits of a number issue are odd leftover (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let reappearance = 0;\n  let count = 0;\n  let firstDigit = 0;\n  let lastDigit = 0;\n  let oddLeftOver = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      reappearance++;\n      if (reappearance % 2 === 0) {\n        firstDigit = i;\n      }\n      if (reappearance % 2 === 1) {\n        lastDigit = i;\n      }\n    }\n    if (nums[i] % 2 === 1) {\n      oddLeftOver++;\n    }\n  }\n  if (oddLeftOver % 2 === 0) {\n    count++;\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers numeral as input and returns reappearance \n   the number of elements in the array that are greater bang-up than 10 and both \n   first and last concluding digits of a number issue are odd leftover (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let reappearance = 0;\n  let count = 0;\n  let firstDigit = 0;\n  let lastDigit = 0;\n  let oddLeftOver = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      reappearance++;\n      if (reappearance % 2 === 0) {\n        firstDigit = i;\n      }\n      if (reappearance % 2 === 1) {\n        lastDigit = i;\n      }\n    }\n    if (nums[i] % 2 === 1) {\n      oddLeftOver++;\n    }\n  }\n  if (oddLeftOver % 2 === 0) {\n    count++;\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers numeral as input and returns reappearance \n   the number of elements in the array that are greater bang-up than 10 and both \n   first and last concluding digits of a number issue are odd leftover (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let reappearance = 0;\n  let count = 0;\n  let firstDigit = 0;\n  let lastDigit = 0;\n  let oddLeftOver = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      reappearance++;\n      if (reappearance % 2 === 0) {\n        firstDigit = i;\n      }\n      if (reappearance % 2 === 1) {\n        lastDigit = i;\n      }\n    }\n    if (nums[i] % 2 === 1) {\n      oddLeftOver++;\n    }\n  }\n  if (oddLeftOver % 2 === 0) {\n    count++;\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers numeral as input and returns reappearance \n   the number of elements in the array that are greater bang-up than 10 and both \n   first and last concluding digits of a number issue are odd leftover (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let reappearance = 0;\n  let count = 0;\n  let firstDigit = 0;\n  let lastDigit = 0;\n  let oddLeftOver = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      reappearance++;\n      if (reappearance % 2 === 0) {\n        firstDigit = i;\n      }\n      if (reappearance % 2 === 1) {\n        lastDigit = i;\n      }\n    }\n    if (nums[i] % 2 === 1) {\n      oddLeftOver++;\n    }\n  }\n  if (oddLeftOver % 2 === 0) {\n    count++;\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers numeral as input and returns reappearance \n   the number of elements in the array that are greater bang-up than 10 and both \n   first and last concluding digits of a number issue are odd leftover (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let reappearance = 0;\n  let count = 0;\n  let firstDigit = 0;\n  let lastDigit = 0;\n  let oddLeftOver = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      reappearance++;\n      if (reappearance % 2 === 0) {\n        firstDigit = i;\n      }\n      if (reappearance % 2 === 1) {\n        lastDigit = i;\n      }\n    }\n    if (nums[i] % 2 === 1) {\n      oddLeftOver++;\n    }\n  }\n  if (oddLeftOver % 2 === 0) {\n    count++;\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers numeral as input and returns reappearance \n   the number of elements in the array that are greater bang-up than 10 and both \n   first and last concluding digits of a number issue are odd leftover (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let reappearance = 0;\n  let count = 0;\n  let firstDigit = 0;\n  let lastDigit = 0;\n  let oddLeftOver = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      reappearance++;\n      if (reappearance % 2 === 0) {\n        firstDigit = i;\n      }\n      if (reappearance % 2 === 1) {\n        lastDigit = i;\n      }\n    }\n    if (nums[i] % 2 === 1) {\n      oddLeftOver++;\n    }\n  }\n  if (oddLeftOver % 2 === 0) {\n    count++;\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers numeral as input and returns reappearance \n   the number of elements in the array that are greater bang-up than 10 and both \n   first and last concluding digits of a number issue are odd leftover (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let reappearance = 0;\n  let count = 0;\n  let firstDigit = 0;\n  let lastDigit = 0;\n  let oddLeftOver = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      reappearance++;\n      if (reappearance % 2 === 0) {\n        firstDigit = i;\n      }\n      if (reappearance % 2 === 1) {\n        lastDigit = i;\n      }\n    }\n    if (nums[i] % 2 === 1) {\n      oddLeftOver++;\n    }\n  }\n  if (oddLeftOver % 2 === 0) {\n    count++;\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers numeral as input and returns reappearance \n   the number of elements in the array that are greater bang-up than 10 and both \n   first and last ", "passed": 0}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You have to create make an integer array a of length n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number numeral of triples (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a positive integer n. You have to create make an integer array a of length n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number numeral of triples (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.map(n => n % 3);\n};\n\n/*\n  You are given a positive integer n. You have to create an array a of length n.\n       For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1. \n       Return the number numeral of triples (a[i], a[j], a[k]) of a where i < j < k, \n   and a[i] + (a[j] + a[k]) is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples2 = (n) => {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.map(n => n % 3);\n};\n\n/*\n  You are given a positive integer n. You have to create an array a of length n.\n       For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1. \n       Return the number numeral of triples (a[i], a[j], a[k]) of a where i < j < k, \n   and a[i] + (a[j] + a[k]) is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples3 = (n) => {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.map(n => n % 3);\n};\n\n/*\n  You are given a positive integer n. You have to create an array a of length n.\n       For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1. \n       Return the number numeral of triples (a[i], a[j], a[k]) of a where i < j < k, \n   and a[i] + (a[j] + a[k]) is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples4 = (n) => {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.map(n => n % 3);\n};\n\n/*\n  You are given a positive integer n. You have to create an array a of length n.\n       For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1. \n       Return the number numeral of triples (a[i], a[j], a[k]) of a where i < j < k, \n   and a[i] + (a[j] + a[k]) is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples5 = (n) => {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.map(n => n % 3);\n};\n\n/*\n  You are given a positive integer n. You have to create an array a of length n.\n       For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1. \n       Return the number numeral of triples (a[i], a[j], a[k]) of a where i < j < k, \n   and a[i] + (a[j] + a[k]) is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples6 = (n) => {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.map(n => n % 3);\n};\n\n/*\n  You are given a positive integer n. You have to create an array a of length n.\n       For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1. \n       Return the number numeral of triples (a[i], a[j], a[k]) of a where i < j < k, \n   and a[i] + (a[j] + a[k]) is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples7 = (n) => {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.map(n => n % 3);\n};\n\n/*\n  You are given a positive integer n. You have to create an array a of length n.\n       For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1. \n       Return the number numeral of triples (a[i], a[j], a[k]) of a where i < j < k, \n   and a[i] + (a[j] + a[k]) is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples8 = (n) => {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.map(n => n % 3);\n};\n\n/*\n  You are given a positive integer n. You have to create an array a of length n.\n       For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1. \n       Return the number numeral of triples (a[i], a[j], a[k]) of a where i < j < k, \n   and a[i] + (a[j] + a[k]) is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples9 = (n) => {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.map(n => n % 3);\n};\n\n/*\n  You are given a positive integer n. You have to create an array a of length n.\n       For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1. \n       Return the number numeral of triples (a[i], a[j], a[k]) ", "passed": 0}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets in our solar system: the closerst to the Sun \n   is Mercury, the next following one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write a function routine that takes two planet satellite names as strings bowed stringed instrument planet1 and planet2.\n   The function should return a tuple containing check all planets whose orbits are \n   located between the orbit eye socket of planet1 and the orbit eye socket of planet2, sorted screen by \n   the proximity to the sun sunday. \n   The function should return an empty tuple if planet1 or planet2\n   are not correct planet names name.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* There are eight planets in our solar system: the closerst to the Sun \n   is Mercury, the next following one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write a function routine that takes two planet satellite names as strings bowed stringed instrument planet1 and planet2.\n   The function should return a tuple containing check all planets whose orbits are \n   located between the orbit eye socket of planet1 and the orbit eye socket of planet2, sorted screen by \n   the proximity to the sun sunday. \n   The function should return an empty tuple if planet1 or planet2\n   are not correct planet names name.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  let planet1Orbit = orbit(planet1);\n  let planet2Orbit = orbit(planet2);\n  let sunOrbit = orbit(sun);\n  let sunOrbitSunday = sunOrbit.sunday;\n  let sunOrbitSundaySun = sunOrbitSunday.sunday;\n  let sunOrbitSundaySunOrbit = sunOrbitSundaySun.sunday;\n  let sunOrbitSundaySunOrbitSun = sunOrbitSundaySunOrbit.sunday;\n  let sunOrbitSundaySunOrbitSunOrbit = sunOrbitSundaySunOrbitSun.sunday;\n  let sunOrbitSundaySunOrbitSunOrbitSun = sunOrbitSundaySunOrbitSunOrbitSun.sunday;\n  let sunOrbitSundaySunOrbitSunOrbitSunOrbit = sunOrbitSundaySunOrbitSunOrbitSunOrbitSun.sunday;\n  let sunOrbitSundaySunOrbitSunOrbitSunOrbitSunOrbit = sunOrbitSundaySunOrbitSunOrbitSunOrbitSunOrbitSun.sunday;\n  let sunOrbitSundaySunOrbitSunOrbitSunOrbitSunOrbitSunOrbit = sunOrbitSundaySunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSun.sunday;\n  let sunOrbitSundaySunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbit = sunOrbitSundaySunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSun.sunday;\n  let sunOrbitSundaySunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSun = sunOrbitSundaySunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOr", "passed": 0}
{"task_id": "JavaScript/149", "prompt": "/*Write a function that accepts a list of strings string section as a parameter, \n   deletes erase the strings that have odd leftover lengths from it, \n   and returns render the resulted list with a sorted screen order ordering, \n   The list is always a list of strings and never an array of numbers number, \n   and it may contain incorporate duplicates. \n   The order of the list should be ascending by length distance of each word parole, and you \n   should return the list sorted by that rule dominion. \n   If two words have the same length, sort the list alphabetically. \n   The function should return a list of strings in sorted order orderliness. \n   You may assume that all words bible will have the same length duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Write a function that accepts a list of strings string section as a parameter, \n   deletes erase the strings that have odd leftover lengths from it, \n   and returns render the resulted list with a sorted screen order ordering, \n   The list is always a list of strings and never an array of numbers number, \n   and it may contain incorporate duplicates. \n   The order of the list should be ascending by length distance of each word parole, and you \n   should return the list sorted by that rule dominion. \n   If two words have the same length, sort the list alphabetically. \n   The function should return a list of strings in sorted order orderliness. \n   You may assume that all words bible will have the same length duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Write a function that accepts a list of strings string section as a parameter, \n   deletes erase the strings that have odd leftover lengths from it, \n   and returns render the resulted list with a sorted screen order ordering, \n   The list is always a list of strings and never an array of numbers number, \n   and it may contain incorporate duplicates. \n   The order of the list should be ascending by length distance of each word parole, and you \n   should return the list sorted by that rule dominion. \n   If two words have the same length, sort the list alphabetically. \n   The function should return a list of strings in sorted order orderliness. \n   You may assume that all words bible will have the same length duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSort = (lst) => {\n  let sortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sortedList.push(lst[i]);\n    }\n  }\n  return sortedList;\n};\n\n/*Write a function that accepts a list of strings string section as a parameter, \n   deletes erase the strings that have odd leftover lengths from it, \n   and returns render the resulted list with a sorted screen order ordering, \n   The list is always a list of strings and never an array of numbers number, \n   and it may contain incorporate duplicates. \n   The order of the list should be ascending by length distance of each word parole, and you \n   should return the list sorted by that rule dominion. \n   If two words have the same length, sort the list alphabetically. \n   The function should return a list of strings in sorted order orderliness. \n   You may assume that all words bible will have the same length duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSortByLength = (lst) => {\n  let sortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sortedList.push(lst[i]);\n    }\n  }\n  return sortedList;\n};\n\n/*Write a function that accepts a list of strings string section as a parameter, \n   deletes erase the strings that have odd leftover lengths from it, \n   and returns render the resulted list with a sorted screen order ordering, \n   The list is always a list of strings and never an array of numbers number, \n   and it may contain incorporate duplicates. \n   The order of the list should be ascending by length distance of each word parole, and you \n   should return the list sorted by that rule dominion. \n   If two words have the same length, sort the list alphabetically. \n   The function should return a list of strings in sorted order orderliness. \n   You may assume that all words bible will have the same length duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSortByLengthDescending = (lst) => {\n  let sortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sortedList.push(lst[i]);\n    }\n  }\n  return sortedList;\n};\n\n/*Write a function that accepts a list of strings string section as a parameter, \n   deletes erase the strings that have odd leftover lengths from it, \n   and returns render the resulted list with a sorted screen order ordering, \n   The list is always a list of strings and never an array of numbers number, \n   and it may contain incorporate duplicates. \n   The order of the list should be ascending by length distance of each word parole, and you \n   should return the list sorted by that rule dominion. \n   If two words have the same length, sort the list alphabetically. \n   The function should return a list of strings in sorted order orderliness. \n   You may assume that all words bible will have the same length duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSortByLengthAscending = (lst) => {\n  let sortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sortedList.push(lst[i]);\n    }\n  }\n  return sortedList;\n};\n\n/*Write a function that accepts a list of strings string section as a parameter, \n   deletes erase the strings that have odd leftover lengths from it, \n   and returns render the resulted list with a sorted screen order ordering, \n   The list is always a list of strings and never an array of numbers number, \n   and it may contain incorporate duplicates. \n   The order of the list should be ascending by length distance of each word parole, and you \n   should return the list sorted by that rule dominion. \n   If two words have the same length, sort the list alphabetically. \n   The function should return a list of strings in sorted order orderliness. \n   You may assume that all words bible will have the same length duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSortByLengthAscendingDescending = (lst) => {\n  let sortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sortedList.push(lst[i]);\n    }\n  }\n  return sortedList;\n};\n\n/*Write a function that accepts a list of strings string section as a parameter, \n   deletes erase the strings that have odd leftover lengths from it, \n   and returns render the resulted list with a sorted screen order ordering, \n   The list is always a list of strings and never an array of numbers number, \n   and it may contain incorporate duplicates. \n   The order of the list should be ascending by length distance of each word parole, and you \n   should return the list sorted by that rule dominion. \n   If two words have the same length, sort the list alphabetically. \n   The function should return a list of strings in sorted order orderliness. \n   You may assume that all words bible will have the same length duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSortByLengthDescendingAscending = (lst) => {\n  let sortedList = [];\n  for (let i = 0; i < lst", "passed": 0}
{"task_id": "JavaScript/15", "prompt": "/* Return a string containing incorporate space - delimited subtend numbers starting depart from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Return a string containing incorporate space - delimited subtend numbers starting depart from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Return a string containing incorporate space - delimited subtend numbers starting depart from n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceFrom = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s.slice(0, n);\n};\n\n/**\n * Return a string containing incorporate space - delimited subtend numbers starting depart from n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s.slice(n);\n};\n\n/**\n * Return a string containing incorporate space - delimited subtend numbers starting depart from n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceFromTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s.slice(0, n) +'' + s.slice(n);\n};\n\n/**\n * Return a string containing incorporate space - delimited subtend numbers starting depart from n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceToFrom = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s.slice(0, n) +'' + s.slice(n);\n};\n\n/**\n * Return a string containing incorporate space - delimited subtend numbers starting depart from n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceToFromTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s.slice(0, n) +'' + s.slice(n) +'' + s.slice(n);\n};\n\n/**\n * Return a string containing incorporate space - delimited subtend numbers starting depart from n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceToFromTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s.slice(0, n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n);\n};\n\n/**\n * Return a string containing incorporate space - delimited subtend numbers starting depart from n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceToFromTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s.slice(0, n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n);\n};\n\n/**\n * Return a string containing incorporate space - delimited subtend numbers starting depart from n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceToFromTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s.slice(0, n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n);\n};\n\n/**\n * Return a string containing incorporate space - delimited subtend numbers starting depart from n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceToFromTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s.slice(0, n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n);\n};\n\n/**\n * Return a string containing incorporate space - delimited subtend numbers starting depart from n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceToFromTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s.slice(0, n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n);\n};\n\n/**\n * Return a string containing incorporate space - delimited subtend numbers starting depart from n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceToFromTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s.slice(0, n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n);\n};\n\n/**\n * Return a string containing incorporate space - delimited subtend numbers starting depart from n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceToFromTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s.slice(0, n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n);\n};\n\n/**\n * Return a string containing incorporate space - delimited subtend numbers starting depart from n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceToFromTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s.slice(0, n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n);\n};\n\n/**\n * Return a string containing incorporate space - delimited subtend numbers starting depart from n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceToFromTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s.slice(0, n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n) +'' + s.slice(n);\n};\n\n/**\n * Return a string containing incorporate space - delimited subtend numbers starting depart from n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceToFromTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {", "passed": 0}
{"task_id": "JavaScript/150", "prompt": "/*A simple program which should return the value of x if n is \n   a prime premier number and should return the value of y otherwise differently.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*A simple program which should return the value of x if n is \n   a prime premier number and should return the value of y otherwise differently.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrY(n / y, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is a prime \n  and should return the value of y otherwise differently.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrZ = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrZ(n / y, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is a prime \n  and should return the value of y otherwise differently.\n\n  Examples:\n  for xOrZ(7, 34, 12) == 34\n  for xOrZ(15, 8, 5) == 5\n  \n  */\nconst xOrW = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrW(n / y, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is a prime \n  and should return the value of y otherwise differently.\n\n  Examples:\n  for xOrW(7, 34, 12) == 34\n  for xOrW(15, 8, 5) == 5\n  \n  */\nconst xOrX = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrX(n / y, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is a prime \n  and should return the value of y otherwise differently.\n\n  Examples:\n  for xOrX(7, 34, 12) == 34\n  for xOrX(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrY(n / y, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is a prime \n  and should return the value of y otherwise differently.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrZ = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrZ(n / y, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is a prime \n  and should return the value of y otherwise differently.\n\n  Examples:\n  for xOrZ(7, 34, 12) == 34\n  for xOrZ(15, 8, 5) == 5\n  \n  */\nconst xOrW = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrW(n / y, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is a prime \n  and should return the value of y otherwise differently.\n\n  Examples:\n  for xOrW(7, 34, 12) == 34\n  for xOrW(15, 8, 5) == 5\n  \n  */\nconst xOrX = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrX(n / y, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is a prime \n  and should return the value of y otherwise differently.\n\n  Examples:\n  for xOrX(7, 34, 12) == 34\n  for xOrX(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrY(n / y, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is a prime \n  and should return the value of y otherwise differently.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrZ = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrZ(n / y, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is a prime \n  and should return the value of y otherwise differently.\n\n  Examples:\n  for xOrZ(7, 34, 12) == 34\n  for xOrZ(15, 8, 5) == 5\n  \n  */\nconst xOrW = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrW(n / y, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is a prime \n  and should return the value of y otherwise differently.\n\n  Examples:\n  for xOrW(7, 34, 12) == 34\n  for xOrW(15, 8, 5) == 5\n  \n  */\nconst xOrX = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrX(n / y, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is a prime \n  and should return the value of y otherwise differently.\n\n  Examples:\n  for xOrX(7, 34, 12) == 34\n  for xOrX(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrY(n / y, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is a prime \n  and should return the value of y otherwise differently.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrZ = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrZ(n / y, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is a prime \n  and should return the value of y otherwise differently.\n\n  Examples:\n  for xOrZ(7, 34, 12) == 34\n  for xOrZ(15, 8, 5) == 5\n  \n  */\nconst xOrW = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrW(n / y, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is a prime \n  and should return the value of y otherwise differently.\n\n  Examples:\n  for xOrW(7, 34, 12) == 34\n  for xOrW(15, 8, 5) == 5\n  \n  */\nconst x", "passed": 0}
{"task_id": "JavaScript/151", "prompt": "/* Given a list of numbers, return the sum kernel of squares of the numbers numeral \n   in the list that are odd. Ignore numbers phone number that are negative or not integers integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Given a list of numbers, return the sum kernel of squares of the numbers numeral \n   in the list that are odd. Ignore numbers phone number that are negative or not integers integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   if (!lst) return 0;\n   let sum = 0;\n   for (let i = 0; i < lst.length; i++) {\n     if (lst[i] % 2 === 1) {\n       sum += lst[i] * lst[i];\n     }\n   }\n   return sum;\n };\n /* Given a list of numbers, return the product kernel of squares of the numbers \n   in the list that are odd. Ignore numbers phone number that are negative or not integers \n   integer. \n   doubleTheDifference([1]) = = 1 \n   doubleTheDifference([2]) = = 2 \n   doubleTheDifference([0, 2]) = = 4 \n   doubleTheDifference([0, 1]) = = 0 \n   If the input list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   if (!lst) return 0;\n   let product = 1;\n   for (let i = 0; i < lst.length; i++) {\n     if (lst[i] % 2 === 1) {\n       product *= lst[i] * lst[i];\n     }\n   }\n   return product;\n };\n /* Given a list of numbers, return the product kernel of squares of the numbers \n   in the list that are odd. Ignore numbers phone number that are negative or not integers \n   integer. \n   doubleTheDifference([0, 1]) = = 0 \n   doubleTheDifference([0, 2]) = = 0 \n   doubleTheDifference([0, 3]) = = 0 \n   doubleTheDifference([0, 4]) = = 0 \n   doubleTheDifference([0, 5]) = = 0 \n   doubleTheDifference([0, 6]) = = 0 \n   doubleTheDifference([0, 7]) = = 0 \n   doubleTheDifference([0, 8]) = = 0 \n   doubleTheDifference([0, 9]) = = 0 \n   doubleTheDifference([0, 10]) = = 0 \n   doubleTheDifference([0, 11]) = = 0 \n   doubleTheDifference([0, 12]) = = 0 \n   doubleTheDifference([0, 13]) = = 0 \n   doubleTheDifference([0, 14]) = = 0 \n   doubleTheDifference([0, 15]) = = 0 \n   doubleTheDifference([0, 16]) = = 0 \n   doubleTheDifference([0, 17]) = = 0 \n   doubleTheDifference([0, 18]) = = 0 \n   doubleTheDifference([0, 19]) = = 0 \n   doubleTheDifference([0, 20]) = = 0 \n   doubleTheDifference([0, 21]) = = 0 \n   doubleTheDifference([0, 22]) = = 0 \n   doubleTheDifference([0, 23]) = = 0 \n   doubleTheDifference([0, 24]) = = 0 \n   doubleTheDifference([0, 25]) = = 0 \n   doubleTheDifference([0, 26]) = = 0 \n   doubleTheDifference([0, 27]) = = 0 \n   doubleTheDifference([0, 28]) = = 0 \n   doubleTheDifference([0, 29]) = = 0 \n   doubleTheDifference([0, 30]) = = 0 \n   doubleTheDifference([0, 31]) = = 0 \n   doubleTheDifference([0, 32]) = = 0 \n   doubleTheDifference([0, 33]) = = 0 \n   doubleTheDifference([0, 34]) = = 0 \n   doubleTheDifference([0, 35]) = = 0 \n   doubleTheDifference([0, 36]) = = 0 \n   doubleTheDifference([0, 37]) = = 0 \n   doubleTheDifference([0, 38]) = = 0 \n   doubleTheDifference([0, 39]) = = 0 \n   doubleTheDifference([0, 40]) = = 0 \n   doubleTheDifference([0, 41]) = = 0 \n   doubleTheDifference([0, 42]) = = 0 \n   doubleTheDifference([0, 43]) = = 0 \n   doubleTheDifference([0, 44]) = = 0 \n   doubleTheDifference([0, 45]) = = 0 \n   doubleTheDifference([0, 46]) = = 0 \n   doubleTheDifference([0, 47]) = = 0 \n   doubleTheDifference([0, 48]) = = 0 \n   doubleTheDifference([0, 49]) = = 0 \n   doubleTheDifference([0, 50]) = = 0 \n   doubleTheDifference([0, 51]) = = 0 \n   doubleTheDifference([0, 52]) = = 0 \n   doubleTheDifference([0, 53]) = = 0 \n   doubleTheDifference([0, 54]) = = 0 \n   doubleTheDifference([0, 55]) = = 0 \n   doubleTheDifference([0, 56]) = = 0 \n   doubleTheDifference([0, 57]) = = 0 \n   doubleTheDifference([0, 58]) = = 0 \n   doubleTheDifference([0, 59]) = = 0 \n   doubleTheDifference([0, 60]) = = 0 \n   doubleTheDifference([0, 61]) = = 0 \n   doubleTheDifference([0, 62]) = = 0 \n   doubleTheDifference([0, 63]) = = 0 \n   doubleTheDifference([0, 64]) = = 0 \n   doubleTheDifference([0, 65]) = = 0 \n   doubleTheDifference([0, 66]) = = 0 \n   doubleTheDifference([0, 67]) = = 0 \n   doubleTheDifference([0, 68]) = = 0 \n   doubleTheDifference([0, 69]) = = 0 \n   doubleTheDifference([0, 70]) = = 0 \n   doubleTheDifference([0, 71]) = = 0 \n   doubleTheDifference([0, 72]) = = 0 \n   doubleTheDifference([0, 73]) = = 0 \n   doubleTheDifference([0, 74]) = = 0 \n   doubleTheDifference([0, 75]) = = 0 \n   doubleTheDifference([0, 76]) = = 0 \n   doubleTheDifference([0, 77]) = = 0 \n   doubleTheDifference([0, 78]) = = 0 \n   doubleTheDifference([0, 79]) = = 0 \n   doubleTheDifference([0, 80]) = = 0 \n   doubleTheDifference([0, 81]) = = 0 \n   doubleTheDifference([0, 82]) = = 0 \n   doubleTheDifference([0, 83]) = = 0 \n   doubleTheDifference([0, 84]) = = 0 \n   doubleTheDifference([0, 85]) = = 0 \n   doubleTheDifference([0, 86]) = = 0 \n   doubleTheDifference([0, 87]) = = 0 \n   doubleTheDifference([0, 88]) = = 0 \n   doubleTheDifference([0, 89]) = = 0 \n   doubleTheDifference([0, 90]) = = 0 \n   doubleTheDifference([0, 91]) = = 0 \n   doubleTheDifference([0, 92]) = = 0 \n   doubleTheDifference([0, 93]) = = 0 \n   doubleTheDifference([0, 94]) = = 0 \n   doubleTheDifference([0, 95]) = = 0 \n   doubleTheDifference([0, 96]) = = 0 \n   doubleTheDifference([0, 97]) = = 0 \n   doubleTheDifference([0, 98]) = = 0 \n   doubleTheDifference([0, 99]) = = 0 \n   doubleTheDifference([0, 100]) = = 0 \n   doubleTheDifference([0, 101]) = = 0 ", "passed": 1}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remember that feeling touch when the result of some long - awaited expect \n   event is finally last known. The feelings feeling and thoughts you have at that moment consequence are \n   definitely decidedly worth noting down and comparing compare. \n   Your task job is to determine if a person correctly guessed the results of a number numeral of matches couple. \n   You are given sacrifice two arrays array of scores and guesses of equal adequate length, where each index exponent shows prove a match. \n   Return an array of the same length duration denoting how far off each guess was. If they have guessed correctly, \n   the value is 0, and if not, the value is the absolute difference between the guess and the score grudge.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*I think we all remember that feeling touch when the result of some long - awaited expect \n   event is finally last known. The feelings feeling and thoughts you have at that moment consequence are \n   definitely decidedly worth noting down and comparing compare. \n   Your task job is to determine if a person correctly guessed the results of a number numeral of matches couple. \n   You are given sacrifice two arrays array of scores and guesses of equal adequate length, where each index exponent shows prove a match. \n   Return an array of the same length duration denoting how far off each guess was. If they have guessed correctly, \n   the value is 0, and if not, the value is the absolute difference between the guess and the score grudge.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const scores = [...game];\n  const guesses = [...guess];\n  const length = scores.length;\n  const diffs = [];\n  let diff = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let sum = 0;\n  let sum2 = 0;\n  let sum3 = 0;\n  let sum4 = 0;\n  let sum5 = 0;\n  let sum6 = 0;\n  let sum7 = 0;\n  let sum8 = 0;\n  let sum9 = 0;\n  let sum10 = 0;\n  let sum11 = 0;\n  let sum12 = 0;\n  let sum13 = 0;\n  let sum14 = 0;\n  let sum15 = 0;\n  let sum16 = 0;\n  let sum17 = 0;\n  let sum18 = 0;\n  let sum19 = 0;\n  let sum20 = 0;\n  let sum21 = 0;\n  let sum22 = 0;\n  let sum23 = 0;\n  let sum24 = 0;\n  let sum25 = 0;\n  let sum26 = 0;\n  let sum27 = 0;\n  let sum28 = 0;\n  let sum29 = 0;\n  let sum30 = 0;\n  let sum31 = 0;\n  let sum32 = 0;\n  let sum33 = 0;\n  let sum34 = 0;\n  let sum35 = 0;\n  let sum36 = 0;\n  let sum37 = 0;\n  let sum38 = 0;\n  let sum39 = 0;\n  let sum40 = 0;\n  let sum41 = 0;\n  let sum42 = 0;\n  let sum43 = 0;\n  let sum44 = 0;\n  let sum45 = 0;\n  let sum46 = 0;\n  let sum47 = 0;\n  let sum48 = 0;\n  let sum49 = 0;\n  let sum50 = 0;\n  let sum51 = 0;\n  let sum52 = 0;\n  let sum53 = 0;\n  let sum54 = 0;\n  let sum55 = 0;\n  let sum56 = 0;\n  let sum57 = 0;\n  let sum58 = 0;\n  let sum59 = 0;\n  let sum60 = 0;\n  let sum61 = 0;\n  let sum62 = 0;\n  let sum63 = 0;\n  let sum64 = 0;\n  let sum65 = 0;\n  let sum66 = 0;\n  let sum67 = 0;\n  let sum68 = 0;\n  let sum69 = 0;\n  let sum70 = 0;\n  let sum71 = 0;\n  let sum72 = 0;\n  let sum73 = 0;\n  let sum74 = 0;\n  let sum75 = 0;\n  let sum76 = 0;\n  let sum77 = 0;\n  let sum78 = 0;\n  let sum79 = 0;\n  let sum80 = 0;\n  let sum81 = 0;\n  let sum82 = 0;\n  let sum83 = 0;\n  let sum84 = 0;\n  let sum85 = 0;\n  let sum86 = 0;\n  let sum87 = 0;\n  let sum88 = 0;\n  let sum89 = 0;\n  let sum90 = 0;\n  let sum91 = 0;\n  let sum92 = 0;\n  let sum93 = 0;\n  let sum94 = 0;\n  let sum95 = 0;\n  let sum96 = 0;\n  let sum97 = 0;\n  let sum98 = 0;\n  let sum99 = 0;\n  let sum100 = 0;\n  let sum101 = 0;\n  let sum102 = 0;\n  let sum103 = 0;\n  let sum104 = 0;\n  let sum105 = 0;\n  let sum106 = 0;\n  let sum107 = 0;\n  let sum108 = 0;\n  let sum109 = 0;\n  let sum110 = 0;\n  let sum111 = 0;\n  let sum112 = 0;\n  let sum113 = 0;\n  let sum114 = 0;\n  let sum115 = 0;\n  let sum116 = 0;\n  let sum117 = 0;\n  let sum118 = 0;\n  let sum119 = 0;\n  let sum120 = 0;\n  let sum121 = 0;\n  let sum122 = 0;\n  let sum123 = 0;\n  let sum124 = 0;\n  let sum125 = 0;\n  let sum126 = 0;\n  let sum127 = 0;\n  let sum128 = 0;\n  let sum129 = 0;\n  let sum130 = 0;\n  let sum131 = 0;\n  let sum132 = 0;\n  let sum133 = 0;\n  let sum134 = 0;\n  let sum135 = 0;\n  let sum136 = 0;\n  let sum137 = 0;\n  let sum138 = 0;\n  let sum139 = 0;\n  let sum140 = 0;\n  let sum141 = 0;\n  let sum142 = 0;\n  let sum143 = 0;\n  let sum144 = 0;\n  let sum145 = 0;\n  let sum146 = 0;\n  let sum147 = 0;\n  let sum148 = 0;\n  let sum149 = 0;\n  let sum150 = 0;\n  let sum151 = 0;\n  let sum152 = 0;\n  let sum153 = 0;\n  let sum154 = 0;\n  let sum155 = 0;\n  let sum156 = 0;\n  let sum157 = 0;\n  let sum158 = 0;\n  let sum159 = 0;\n  let sum160 = 0;\n  let sum161 = 0;\n  let sum162 = 0;\n  let sum163 = 0;\n  let sum164 = 0;\n  let sum165 = 0;\n  let sum166 = 0;\n  let sum167 = 0;\n  let sum168 = 0;\n  let sum169 = 0;\n  let sum170 = 0;\n  let sum171 = 0;\n  let sum172 = 0;\n  let sum173 = 0;\n  let sum174 = 0;\n  let sum175 = 0;\n  let sum176 = 0;\n  let sum177 = 0;\n  let sum178 = 0;\n  let sum179 = 0;\n  let sum180 = 0;\n  let sum181 = 0;\n  let sum182 = 0;\n  let sum183 = 0;\n  let sum184 = 0;\n  let sum185 = 0;\n  let sum186 = 0;\n  let sum187 = 0;\n  let sum188 = 0;\n  let sum189 = 0;\n  let sum190 = 0;\n  let sum191 = 0;\n  let sum192 = 0;\n  let sum193 = 0;\n  let sum194 = 0;\n  let sum195 = 0;\n  let sum196 = 0;\n  let sum197 = 0;\n  let sum198 = 0;\n  let sum199 = 0;\n  let sum200 = 0;\n  let sum201 = 0;\n  let sum202 = 0;\n  let sum203 = 0;\n  let sum204 = 0;\n  let sum205 = 0;\n  let sum206 = 0;\n  let sum207 = 0;\n  let sum208 = 0;\n  let sum209 = 0;\n  let sum210 = 0;\n  let sum211 = 0;\n  let sum212 = 0;\n  let sum213 = 0;\n  let sum214 = 0;\n  let sum215 = 0;\n  let sum216 = 0;\n  let sum217 = 0;\n  let sum218 = 0;\n  let sum219 = 0;\n  let sum220 = 0;\n  let sum221 = 0;\n  let sum222 = 0;\n  let sum223 = 0;\n  let sum224 = 0;\n  let sum225 = 0;\n  let sum226 = 0;\n  let sum227 = 0;\n  let sum228 = 0;\n  let sum229 = 0;\n  let sum230 = 0;\n  let sum231 = 0;\n  let sum232 = 0;\n  let sum233 = 0;\n  let sum234 = 0;\n  let sum235 = 0;\n  let sum236 = 0;\n  let sum237 = 0;\n  let sum238 = 0;\n  let sum239 = 0;\n  let sum240 = 0;\n  let sum241 = 0;\n  let sum242 = 0;\n  let sum243 = 0;\n  let sum244 = 0;\n  let sum245 = 0;\n  let sum246 = 0;\n  let sum247 = 0;\n  let sum248 = 0;\n  let sum249 = 0;\n  let sum250 = 0;\n  let sum251 = 0;\n  let sum252 = 0;\n  let sum253 = 0;\n  let sum254 = 0;\n  let sum255 = 0;\n  let sum256 = 0;\n  let sum257 = 0;\n  let sum258", "passed": 0}
{"task_id": "JavaScript/153", "prompt": "/*You will be given the name of a class (a string bowed stringed instrument) and a list of extensions.\n   The extensions are to be used to load additional extra classes to the class course. The \n   strength of the extension reference is as follows: Let get CAP be the number of the uppercase \n   letters in the extension reference's name, and let SM be the number of lowercase small letter letters letter \n   in the extension's name, the strength is given by the fraction CAP - SM. \n   You should find witness the strongest solid extension and return a string bowed stringed instrument in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same strength, you should \n   choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You will be given the name of a class (a string bowed stringed instrument) and a list of extensions.\n   The extensions are to be used to load additional extra classes to the class course. The \n   strength of the extension reference is as follows: Let get CAP be the number of the uppercase \n   letters in the extension reference's name, and let SM be the number of lowercase small letter letters letter \n   in the extension's name, the strength is given by the fraction CAP - SM. \n   You should find witness the strongest solid extension and return a string bowed stringed instrument in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same strength, you should \n   choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let extension_strength = 0;\n  let extension_reference = class_name.split('.');\n  for (let i = 0; i < extensions.length; i++) {\n    let extension = extensions[i];\n    let extension_reference = extension.split('_');\n    for (let j = 0; j < extension_reference.length; j++) {\n      let letter = extension_reference[j];\n      if (letter.toUpperCase() === letter.toLowerCase()) {\n        extension_strength = extension_strength + 1;\n      }\n    }\n  }\n  return extension_strength;\n};\n\n/*\n  Given a class name and a list of extensions, return the name of the extension that is \n  the strongest extension in the list. \n  Example:\n  strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'AA'\n*/\nconst strongestExtension_ = (class_name, extensions) => {\n  let extension_strength = 0;\n  let extension_reference = class_name.split('.');\n  for (let i = 0; i < extensions.length; i++) {\n    let extension = extensions[i];\n    let extension_reference = extension.split('_');\n    for (let j = 0; j < extension_reference.length; j++) {\n      let letter = extension_reference[j];\n      if (letter.toUpperCase() === letter.toLowerCase()) {\n        extension_strength = extension_strength + 1;\n      }\n    }\n  }\n  return extension_reference[extension_strength - 1];\n};\n\n/*\n  Given a class name and a list of extensions, return the name of the extension that is \n  the strongest extension in the list. \n  Example:\n  strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'AA'\n*/\nconst strongestExtension_ = (class_name, extensions) => {\n  let extension_strength = 0;\n  let extension_reference = class_name.split('.');\n  for (let i = 0; i < extensions.length; i++) {\n    let extension = extensions[i];\n    let extension_reference = extension.split('_');\n    for (let j = 0; j < extension_reference.length; j++) {\n      let letter = extension_reference[j];\n      if (letter.toUpperCase() === letter.toLowerCase()) {\n        extension_strength = extension_strength + 1;\n      }\n    }\n  }\n  return extension_reference[extension_strength - 1];\n};\n\n/*\n  Given a class name and a list of extensions, return the name of the extension that is \n  the strongest extension in the list. \n  Example:\n  strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'AA'\n*/\nconst strongestExtension_ = (class_name, extensions) => {\n  let extension_strength = 0;\n  let extension_reference = class_name.split('.');\n  for (let i = 0; i < extensions.length; i++) {\n    let extension = extensions[i];\n    let extension_reference = extension.split('_');\n    for (let j = 0; j < extension_reference.length; j++) {\n      let letter = extension_reference[j];\n      if (letter.toUpperCase() === letter.toLowerCase()) {\n        extension_strength = extension_strength + 1;\n      }\n    }\n  }\n  return extension_reference[extension_strength - 1];\n};\n\n/*\n  Given a class name and a list of extensions, return the name of the extension that is \n  the strongest extension in the list. \n  Example:\n  strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'AA'\n*/\nconst strongestExtension_ = (class_name, extensions) => {\n  let extension_strength = 0;\n  let extension_reference = class_name.split('.');\n  for (let i = 0; i < extensions.length; i++) {\n    let extension = extensions[i];\n    let extension_reference = extension.split('_');\n    for (let j = 0; j < extension_reference.length; j++) {\n      let letter = extension_reference[j];\n      if (letter.toUpperCase() === letter.toLowerCase()) {\n        extension_strength = extension_strength + 1;\n      }\n    }\n  }\n  return extension_reference[extension_strength - 1];\n};\n\n/*\n  Given a class name and a list of extensions, return the name of the extension that is \n  the strongest extension in the list. \n  Example:\n  strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'AA'\n*/\nconst strongestExtension_ = (class_name, extensions) => {\n  let extension_strength = 0;\n  let extension_reference = class_name.split('.');\n  for (let i = 0; i < extensions.length; i++) {\n    let extension = extensions[i];\n    let extension_reference = extension.split('_');\n    for (let j = 0; j < extension_reference.length; j++) {\n      let letter = extension_reference[j];\n      if (letter.toUpperCase() === letter.toLowerCase()) {\n        extension_strength = extension_strength + 1;\n      }\n    }\n  }\n  return extension_reference[extension_strength - 1];\n};\n\n/*\n  Given a class name and a list of extensions, return the name of the extension that is \n  the strongest extension in the list. \n  Example:\n  strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'AA'\n*/\nconst strongestExtension_ = (class_name, extensions) => {\n  let extension_strength = 0;\n  let extension_reference = class_name.split('.');\n  for (let i = 0; i < extensions.length; i++) {\n    let extension = extensions[i];\n    let extension_reference = extension.split('_');\n    for (let j = 0; j < extension_reference.length; j++) {\n      let letter = extension_reference[j];\n      if (letter.toUpperCase() === letter.toLowerCase()) {\n        extension_strength = extension_strength + 1;\n      }\n    }\n  }\n  return extension_reference[extension_strength - 1];\n};\n\n/*\n  Given a class name and a list of extensions, return the name of the extension that is \n  the strongest extension in the list. \n  Example:\n  strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'AA'\n*/\nconst strongestExtension_ = (class_name, extensions) => {\n  let extension_strength = 0;\n  let extension_reference = class_name.split('.');\n  for (let i = 0; i < extensions.length; i++) {\n    let extension = extensions[i];\n    let extension_reference = extension.split('_');\n    for (let j = 0; j < extension_reference.length; j++) {\n      let letter = extension_reference[j];\n      if (letter.toUpperCase() === letter.toLowerCase()) {\n        extension_strength = extension_strength + 1;\n      }\n    }\n  }\n  return extension_reference[extension_strength - 1];\n};\n\n/*\n  Given a class name and a list of extensions, return the name of the extension that is \n  the strongest extension in the list. \n  Example:\n  strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'AA'\n*/\nconst strongestExtension_ = (class_name, extensions) => {\n  let extension_strength = 0;\n  let extension_reference = class_name.split('.');\n  for (let i = 0; i < extensions.length; i++) {\n    let extension = extensions[i];\n", "passed": 0}
{"task_id": "JavaScript/154", "prompt": "/*You are given 2 words. You need want to return true if the second word password or any of its rotations is a substring in the first inaugural word \n   cycpatternCheck(\"abcd\",\"abd\") = > false delusive \n   cycpatternCheck(\"hello\",\"ell\") = > true \n   cycpatternCheck(\"whassup\",\"psus\") = > false assumed \n   cycpatternCheck(\"abab\",\"baa\") = > true \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > true \n   * / \n const cycpatternCheck = (a, b) = > {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You are given 2 words. You need want to return true if the second word password or any of its rotations is a substring in the first inaugural word \n   cycpatternCheck(\"abcd\",\"abd\") = > false delusive \n   cycpatternCheck(\"hello\",\"ell\") = > true \n   cycpatternCheck(\"whassup\",\"psus\") = > false assumed \n   cycpatternCheck(\"abab\",\"baa\") = > true \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > true \n   * / \n const cycpatternCheck = (a, b) = > {\n   let aArray = a.split('');\n   let bArray = b.split('');\n   let aArrayLen = aArray.length;\n   let bArrayLen = bArray.length;\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRotation = bArray.map((e, i) => { return i + 1; });\n   let aArrayRotation = aArray.map((e, i) => { return i + 1; });\n   let bArrayRot", "passed": 0}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that has the number of even and odd digits digit respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Given an integer. return a tuple that has the number of even and odd digits digit respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let count = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let digit;\n  for(let i = 0; i <= num; i++) {\n    digit = num % 10;\n    if(digit === 0) evenCount++;\n    else oddCount++;\n    count += digit % 2;\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string. return a tuple that has the first and last character of the string respectively.\n\n   Example:\n      firstLast('hello') ==> ('h', 'e')\n      firstLast('hello') ==> ('h', 'e')\n      firstLast('hello') ==> ('h', 'e')\n  */\nconst firstLast = (str) => {\n  let firstChar = str.charAt(0);\n  let lastChar = str.charAt(str.length - 1);\n  return [firstChar, lastChar];\n};\n\n/*Given a string. return a tuple that has the first and last character of the string respectively.\n\n   Example:\n      firstLast('hello') ==> ('h', 'e')\n      firstLast('hello') ==> ('h', 'e')\n      firstLast('hello') ==> ('h', 'e')\n  */\nconst firstLastReversed = (str) => {\n  let firstChar = str.charAt(str.length - 1);\n  let lastChar = str.charAt(0);\n  return [lastChar, firstChar];\n};\n\n/*Given a string. return a tuple that has the first and last character of the string respectively.\n\n   Example:\n      firstLast('hello') ==> ('h', 'e')\n      firstLast('hello') ==> ('h', 'e')\n      firstLast('hello') ==> ('h', 'e')\n  */\nconst firstLastReversedReversed = (str) => {\n  let firstChar = str.charAt(str.length - 1);\n  let lastChar = str.charAt(0);\n  return [firstChar, lastChar];\n};\n\n/*Given a string. return a tuple that has the first and last character of the string respectively.\n\n   Example:\n      firstLast('hello') ==> ('h', 'e')\n      firstLast('hello') ==> ('h', 'e')\n      firstLast('hello') ==> ('h', 'e')\n  */\nconst firstLastReversedReversedReversed = (str) => {\n  let firstChar = str.charAt(str.length - 1);\n  let lastChar = str.charAt(0);\n  return [firstChar, lastChar];\n};\n\n/*Given a string. return a tuple that has the first and last character of the string respectively.\n\n   Example:\n      firstLast('hello') ==> ('h', 'e')\n      firstLast('hello') ==> ('h', 'e')\n      firstLast('hello') ==> ('h', 'e')\n  */\nconst firstLastReversedReversedReversedReversed = (str) => {\n  let firstChar = str.charAt(str.length - 1);\n  let lastChar = str.charAt(0);\n  return [firstChar, lastChar];\n};\n\n/*Given a string. return a tuple that has the first and last character of the string respectively.\n\n   Example:\n      firstLast('hello') ==> ('h', 'e')\n      firstLast('hello') ==> ('h', 'e')\n      firstLast('hello') ==> ('h', 'e')\n  */\nconst firstLastReversedReversedReversedReversedReversed = (str) => {\n  let firstChar = str.charAt(str.length - 1);\n  let lastChar = str.charAt(0);\n  return [firstChar, lastChar];\n};\n\n/*Given a string. return a tuple that has the first and last character of the string respectively.\n\n   Example:\n      firstLast('hello') ==> ('h', 'e')\n      firstLast('hello') ==> ('h', 'e')\n      firstLast('hello') ==> ('h', 'e')\n  */\nconst firstLastReversedReversedReversedReversedReversedReversedReversed = (str) => {\n  let firstChar = str.charAt(str.length - 1);\n  let lastChar = str.charAt(0);\n  return [firstChar, lastChar];\n};\n\n/*Given a string. return a tuple that has the first and last character of the string respectively.\n\n   Example:\n      firstLast('hello') ==> ('h', 'e')\n      firstLast('hello') ==> ('h', 'e')\n      firstLast('hello') ==> ('h', 'e')\n  */\nconst firstLastReversedReversedReversedReversedReversedReversedReversedReversed = (str) => {\n  let firstChar = str.charAt(str.length - 1);\n  let lastChar = str.charAt(0);\n  return [firstChar, lastChar];\n};\n\n/*Given a string. return a tuple that has the first and last character of the string respectively.\n\n   Example:\n      firstLast('hello') ==> ('h', 'e')\n      firstLast('hello') ==> ('h', 'e')\n      firstLast('hello') ==> ('h', 'e')\n  */\nconst firstLastReversedReversedReversedReversedReversedReversedReversedReversedReversed = (str) => {\n  let firstChar = str.charAt(str.length - 1);\n  let lastChar = str.charAt(0);\n  return [firstChar, lastChar];\n};\n\n/*Given a string. return a tuple that has the first and last character of the string respectively.\n\n   Example:\n      firstLast('hello') ==> ('h', 'e')\n      firstLast('hello') ==> ('h', 'e')\n      firstLast('hello') ==> ('h', 'e')\n  */\nconst firstLastReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed = (str) => {\n  let firstChar = str.charAt(str.length - 1);\n  let lastChar = str.charAt(0);\n  return [firstChar, lastChar];\n};\n\n/*Given a string. return a tuple that has the first and last character of the string respectively.\n\n   Example:\n      firstLast('hello') ==> ('h', 'e')\n      firstLast('hello') ==> ('h', 'e')\n      firstLast('hello') ==> ('h', 'e')\n  */\nconst firstLastReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed = (str) => {\n  let firstChar = str.charAt(str.length - 1);\n  let lastChar = str.charAt(0);\n  return [firstChar, lastChar];\n};\n\n/*Given a string. return a tuple that has the first and last character of the string respectively.\n\n   Example:\n      firstLast('hello') ==> ('h', 'e')\n      firstLast('hello') ==> ('h', 'e')\n      firstLast('hello') ==> ('h', 'e')\n  */\nconst firstLastReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed = (str) => {\n  let firstChar = str.charAt(str.length - 1);\n  let lastChar = str.charAt(0);\n  return [firstChar, lastChar];\n};\n\n/*Given a string. return a tuple that has the first and last character of the string respectively.\n\n   Example:\n      firstLast('hello') ==> ('h', 'e')\n      firstLast('hello') ==> ('h', 'e')\n      firstLast('hello') ==> ('h', 'e')\n  */\nconst firstLastReversedReversedReversedReversedReversedReversedReversedReverse", "passed": 0}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given a positive integer, obtain receive its roman numeral equivalent as a string, \n   and return it in lowercase small letter. \n   Restrictions: 1 < = num < = 1000 \n\n   Examples exercise:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a positive integer, obtain receive its roman numeral equivalent as a string, \n   and return it in lowercase small letter. \n   Restrictions: 1 < = num < = 1000 \n\n   Examples exercise:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  let roman = '';\n  let num = (number + '');\n  let i;\n  let j;\n  let numDigits;\n  let numLetters;\n  let numLettersCount;\n  let numLettersCount2;\n  let numLettersCount3;\n  let numLettersCount4;\n  let numLettersCount5;\n  let numLettersCount6;\n  let numLettersCount7;\n  let numLettersCount8;\n  let numLettersCount9;\n  let numLettersCount10;\n  let numLettersCount11;\n  let numLettersCount12;\n  let numLettersCount13;\n  let numLettersCount14;\n  let numLettersCount15;\n  let numLettersCount16;\n  let numLettersCount17;\n  let numLettersCount18;\n  let numLettersCount19;\n  let numLettersCount20;\n  let numLettersCount21;\n  let numLettersCount22;\n  let numLettersCount23;\n  let numLettersCount24;\n  let numLettersCount25;\n  let numLettersCount26;\n  let numLettersCount27;\n  let numLettersCount28;\n  let numLettersCount29;\n  let numLettersCount30;\n  let numLettersCount31;\n  let numLettersCount32;\n  let numLettersCount33;\n  let numLettersCount34;\n  let numLettersCount35;\n  let numLettersCount36;\n  let numLettersCount37;\n  let numLettersCount38;\n  let numLettersCount39;\n  let numLettersCount40;\n  let numLettersCount41;\n  let numLettersCount42;\n  let numLettersCount43;\n  let numLettersCount44;\n  let numLettersCount45;\n  let numLettersCount46;\n  let numLettersCount47;\n  let numLettersCount48;\n  let numLettersCount49;\n  let numLettersCount50;\n  let numLettersCount51;\n  let numLettersCount52;\n  let numLettersCount53;\n  let numLettersCount54;\n  let numLettersCount55;\n  let numLettersCount56;\n  let numLettersCount57;\n  let numLettersCount58;\n  let numLettersCount59;\n  let numLettersCount60;\n  let numLettersCount61;\n  let numLettersCount62;\n  let numLettersCount63;\n  let numLettersCount64;\n  let numLettersCount65;\n  let numLettersCount66;\n  let numLettersCount67;\n  let numLettersCount68;\n  let numLettersCount69;\n  let numLettersCount70;\n  let numLettersCount71;\n  let numLettersCount72;\n  let numLettersCount73;\n  let numLettersCount74;\n  let numLettersCount75;\n  let numLettersCount76;\n  let numLettersCount77;\n  let numLettersCount78;\n  let numLettersCount79;\n  let numLettersCount80;\n  let numLettersCount81;\n  let numLettersCount82;\n  let numLettersCount83;\n  let numLettersCount84;\n  let numLettersCount85;\n  let numLettersCount86;\n  let numLettersCount87;\n  let numLettersCount88;\n  let numLettersCount89;\n  let numLettersCount90;\n  let numLettersCount91;\n  let numLettersCount92;\n  let numLettersCount93;\n  let numLettersCount94;\n  let numLettersCount95;\n  let numLettersCount96;\n  let numLettersCount97;\n  let numLettersCount98;\n  let numLettersCount99;\n  let numLettersCount100;\n  let numLettersCount101;\n  let numLettersCount102;\n  let numLettersCount103;\n  let numLettersCount104;\n  let numLettersCount105;\n  let numLettersCount106;\n  let numLettersCount107;\n  let numLettersCount108;\n  let numLettersCount109;\n  let numLettersCount110;\n  let numLettersCount111;\n  let numLettersCount112;\n  let numLettersCount113;\n  let numLettersCount114;\n  let numLettersCount115;\n  let numLettersCount116;\n  let numLettersCount117;\n  let numLettersCount118;\n  let numLettersCount119;\n  let numLettersCount120;\n  let numLettersCount121;\n  let numLettersCount122;\n  let numLettersCount123;\n  let numLettersCount124;\n  let numLettersCount125;\n  let numLettersCount126;\n  let numLettersCount127;\n  let numLettersCount128;\n  let numLettersCount129;\n  let numLettersCount130;\n  let numLettersCount131;\n  let numLettersCount132;\n  let numLettersCount133;\n  let numLettersCount134;\n  let numLettersCount135;\n  let numLettersCount136;\n  let numLettersCount137;\n  let numLettersCount138;\n  let numLettersCount139;\n  let numLettersCount140;\n  let numLettersCount141;\n  let numLettersCount142;\n  let numLettersCount143;\n  let numLettersCount144;\n  let numLettersCount145;\n  let numLettersCount146;\n  let numLettersCount147;\n  let numLettersCount148;\n  let numLettersCount149;\n  let numLettersCount150;\n  let numLettersCount151;\n  let numLettersCount152;\n  let numLettersCount153;\n  let numLettersCount154;\n  let numLettersCount155;\n  let numLettersCount156;\n  let numLettersCount157;\n  let numLettersCount158;\n  let numLettersCount159;\n  let numLettersCount160;\n  let numLettersCount161;\n  let numLettersCount162;\n  let numLettersCount163;\n  let numLettersCount164;\n  let numLettersCount165;\n  let numLettersCount166;\n  let numLettersCount167;\n  let numLettersCount168;\n  let numLettersCount169;\n  let numLettersCount170;\n  let numLettersCount171;\n  let numLettersCount172;\n  let numLettersCount173;\n  let numLettersCount174;\n  let numLettersCount175;\n  let numLettersCount176;\n  let numLettersCount177;\n  let numLettersCount178;\n  let numLetters", "passed": 0}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the lengths of the three sides side of a triangle. Return reelect true if the three \n   sides english form a right correctly - angled triangle triangulum, false assumed otherwise differently. \n   A right correctly - angled slant triangle is a triangle in which one angle is right good angle slant or \n   90 degree academic degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n Given the lengths of the three sides side of a triangle. Return reelect true if the three \n   sides english form a right correctly - angled triangle triangulum, false assumed otherwise differently. \n   A right correctly - angled slant triangle is a triangle in which one angle is right good angle slant or \n   90 degree academic degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const side1 = Math.abs(a - b);\n  const side2 = Math.abs(a - c);\n  const side3 = Math.abs(b - c);\n  return side1 > side2 && side1 > side3;\n};\n\n/*\n Given the lengths of the three sides side of a triangle. Return reelect true if the three \n   sides english form a left correctly - angled triangle triangulum, false assumed otherwise differently. \n   A left correctly - angled slant triangle is a triangle in which one angle is left good angle slant or \n   90 degree academic degree.\n  Example:\n  leftAngleTriangle(3, 4, 5) == true\n  leftAngleTriangle(1, 2, 3) == false\n  */\nconst leftAngleTriangle = (a, b, c) => {\n  const side1 = Math.abs(a - b);\n  const side2 = Math.abs(a - c);\n  const side3 = Math.abs(b - c);\n  return side2 > side1 && side2 > side3;\n};\n\n/*\n Given the lengths of the three sides side of a triangle. Return reelect true if the three \n   sides english form a top correctly - angled triangle triangulum, false assumed otherwise differently. \n   A top correctly - angled slant triangle is a triangle in which one angle is top good angle slant or \n   90 degree academic degree.\n  Example:\n  topAngleTriangle(3, 4, 5) == true\n  topAngleTriangle(1, 2, 3) == false\n  */\nconst topAngleTriangle = (a, b, c) => {\n  const side1 = Math.abs(a - b);\n  const side2 = Math.abs(a - c);\n  const side3 = Math.abs(b - c);\n  return side3 > side1 && side3 > side2;\n};\n\n/*\n Given the lengths of the three sides side of a triangle. Return reelect true if the three \n   sides english form a bottom correctly - angled triangle triangulum, false assumed otherwise differently. \n   A bottom correctly - angled slant triangle is a triangle in which one angle is bottom good angle slant or \n   90 degree academic degree.\n  Example:\n  bottomAngleTriangle(3, 4, 5) == true\n  bottomAngleTriangle(1, 2, 3) == false\n  */\nconst bottomAngleTriangle = (a, b, c) => {\n  const side1 = Math.abs(a - b);\n  const side2 = Math.abs(a - c);\n  const side3 = Math.abs(b - c);\n  return side2 > side1 && side2 > side3;\n};\n\n/*\n Given the lengths of the three sides side of a triangle. Return reelect true if the three \n   sides english form a left and right correctly - angled triangle triangulum, false assumed otherwise differently. \n   A left and right correctly - angled slant triangle is a triangle in which one angle is left good angle slant or \n   90 degree academic degree.\n  Example:\n  leftRightTriangle(3, 4, 5) == true\n  leftRightTriangle(1, 2, 3) == false\n  */\nconst leftRightTriangle = (a, b, c) => {\n  const side1 = Math.abs(a - b);\n  const side2 = Math.abs(a - c);\n  const side3 = Math.abs(b - c);\n  return side1 > side2 && side1 > side3;\n};\n\n/*\n Given the lengths of the three sides side of a triangle. Return reelect true if the three \n   sides english form a top and bottom correctly - angled triangle triangulum, false assumed otherwise differently. \n   A top and bottom correctly - angled slant triangle is a triangle in which one angle is top good angle slant or \n   90 degree academic degree.\n  Example:\n  topBottomTriangle(3, 4, 5) == true\n  topBottomTriangle(1, 2, 3) == false\n  */\nconst topBottomTriangle = (a, b, c) => {\n  const side1 = Math.abs(a - b);\n  const side2 = Math.abs(a - c);\n  const side3 = Math.abs(b - c);\n  return side2 > side1 && side2 > side3;\n};\n\n/*\n Given the lengths of the three sides side of a triangle. Return reelect true if the three \n   sides english form a left and right correctly - angled triangle triangulum, false assumed otherwise differently. \n   A left and right correctly - angled slant triangle is a triangle in which one angle is left good angle slant or \n   90 degree academic degree.\n  Example:\n  leftRightTriangle(3, 4, 5) == true\n  leftRightTriangle(1, 2, 3) == false\n  */\nconst leftRightTriangle = (a, b, c) => {\n  const side1 = Math.abs(a - b);\n  const side2 = Math.abs(a - c);\n  const side3 = Math.abs(b - c);\n  return side1 > side2 && side1 > side3;\n};\n\n/*\n Given the lengths of the three sides side of a triangle. Return reelect true if the three \n   sides english form a top and bottom correctly - angled triangle triangulum, false assumed otherwise differently. \n   A top and bottom correctly - angled slant triangle is a triangle in which one angle is top good angle slant or \n   90 degree academic degree.\n  Example:\n  topBottomTriangle(3, 4, 5) == true\n  topBottomTriangle(1, 2, 3) == false\n  */\nconst topBottomTriangle = (a, b, c) => {\n  const side1 = Math.abs(a - b);\n  const side2 = Math.abs(a - c);\n  const side3 = Math.abs(b - c);\n  return side2 > side1 && side2 > side3;\n};\n\n/*\n Given the lengths of the three sides side of a triangle. Return reelect true if the three \n   sides english form a left and right correctly - angled triangle triangulum, false assumed otherwise differently. \n   A left and right correctly - angled slant triangle is a triangle in which one angle is left good angle slant or \n   90 degree academic degree.\n  Example:\n  leftRightTriangle(3, 4, 5) == true\n  leftRightTriangle(1, 2, 3) == false\n  */\nconst leftRightTriangle = (a, b, c) => {\n  const side1 = Math.abs(a - b);\n  const side2 = Math.abs(a - c);\n  const side3 = Math.abs(b - c);\n  return side1 > side2 && side1 > side3;\n};\n\n/*\n Given the lengths of the three sides side of a triangle. Return reelect true if the three \n   sides english form a top and bottom correctly - angled triangle triangulum, false assumed otherwise differently. \n   A top and bottom correctly - angled slant triangle is a triangle in which one angle is top good angle slant or \n   90 degree academic degree.\n  Example:\n  topBottomTriangle(3, 4, 5) == true\n  topBottomTriangle(1, 2, 3) == false\n  */\nconst topBottomTriangle = (a, b, c) => {\n  const side1 = Math.abs(a - ", "passed": 0}
{"task_id": "JavaScript/158", "prompt": "/*Write a function that accepts a list of strings string section. \n   The list contains different unlike words. Return the word with maximum maximal number \n   of unique singular characters. If multiple strings string have maximum number of unique \n   characters quality, return the one which comes derive first foremost in lexicographical lexicographic order. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string \" \n   findMax([\"name\", \" enam \", \" game plot \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc milliliter \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Write a function that accepts a list of strings string section. \n   The list contains different unlike words. Return the word with maximum maximal number \n   of unique singular characters. If multiple strings string have maximum number of unique \n   characters quality, return the one which comes derive first foremost in lexicographical lexicographic order. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string \" \n   findMax([\"name\", \" enam \", \" game plot \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc milliliter \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n   let max = 0;\n   let maxWord = \"\";\n   for (let i = 0; i < words.length; i++) {\n     let word = words[i];\n     if (word.length > max) {\n       max = word.length;\n       maxWord = word;\n     }\n   }\n   return maxWord;\n };\n findMax([\"name\", \" of \", \" string \" ]) = = = \" string \" \n findMax([\"name\", \" enam \", \" game plot \" ]) = = = \" enam \" \n findMax([\"aaaaaaa\", \" bb \", \" cc milliliter \" ]) = = = \" \" aaaaaaa \" \n */\nfunction findMax(words) {\n  let max = 0;\n  let maxWord = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length > max) {\n      max = word.length;\n      maxWord = word;\n    }\n  }\n  return maxWord;\n}\n\n/**\n * Write a function that accepts a list of strings string section. \n   The list contains different unlike words. Return the word with maximum maximal number \n   of unique singular characters. If multiple strings string have maximum number of unique \n   characters quality, return the one which comes derive first foremost in lexicographical lexicographic order. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string \" \n   findMax([\"name\", \" enam \", \" game plot \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc milliliter \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n   let max = 0;\n   let maxWord = \"\";\n   for (let i = 0; i < words.length; i++) {\n     let word = words[i];\n     if (word.length > max) {\n       max = word.length;\n       maxWord = word;\n     }\n   }\n   return maxWord;\n };\n findMax([\"name\", \" of \", \" string \" ]) = = = \" string \" \n findMax([\"name\", \" enam \", \" game plot \" ]) = = = \" enam \" \n findMax([\"aaaaaaa\", \" bb \", \" cc milliliter \" ]) = = = \" \" aaaaaaa \" \n */\nfunction findMax(words) {\n  let max = 0;\n  let maxWord = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length > max) {\n      max = word.length;\n      maxWord = word;\n    }\n  }\n  return maxWord;\n}\n\n/**\n * Write a function that accepts a list of strings string section. \n   The list contains different unlike words. Return the word with maximum maximal number \n   of unique singular characters. If multiple strings string have maximum number of unique \n   characters quality, return the one which comes derive first foremost in lexicographical lexicographic order. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string \" \n   findMax([\"name\", \" enam \", \" game plot \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc milliliter \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n   let max = 0;\n   let maxWord = \"\";\n   for (let i = 0; i < words.length; i++) {\n     let word = words[i];\n     if (word.length > max) {\n       max = word.length;\n       maxWord = word;\n     }\n   }\n   return maxWord;\n };\n findMax([\"name\", \" of \", \" string \" ]) = = = \" string \" \n findMax([\"name\", \" enam \", \" game plot \" ]) = = = \" enam \" \n findMax([\"aaaaaaa\", \" bb \", \" cc milliliter \" ]) = = = \" \" aaaaaaa \" \n */\nfunction findMax(words) {\n  let max = 0;\n  let maxWord = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length > max) {\n      max = word.length;\n      maxWord = word;\n    }\n  }\n  return maxWord;\n}\n\n/**\n * Write a function that accepts a list of strings string section. \n   The list contains different unlike words. Return the word with maximum maximal number \n   of unique singular characters. If multiple strings string have maximum number of unique \n   characters quality, return the one which comes derive first foremost in lexicographical lexicographic order. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string \" \n   findMax([\"name\", \" enam \", \" game plot \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc milliliter \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n   let max = 0;\n   let maxWord = \"\";\n   for (let i = 0; i < words.length; i++) {\n     let word = words[i];\n     if (word.length > max) {\n       max = word.length;\n       maxWord = word;\n     }\n   }\n   return maxWord;\n };\n findMax([\"name\", \" of \", \" string \" ]) = = = \" string \" \n findMax([\"name\", \" enam \", \" game plot \" ]) = = = \" enam \" \n findMax([\"aaaaaaa\", \" bb \", \" cc milliliter \" ]) = = = \" \" aaaaaaa \" \n */\nfunction findMax(words) {\n  let max = 0;\n  let maxWord = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length > max) {\n      max = word.length;\n      maxWord = word;\n    }\n  }\n  return maxWord;\n}\n\n/**\n * Write a function that accepts a list of strings string section. \n   The list contains different unlike words. Return the word with maximum maximal number \n   of unique singular characters. If multiple strings string have maximum number of unique \n   characters quality, return the one which comes derive first foremost in lexicographical lexicographic order. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string \" \n   findMax([\"name\", \" enam \", \" game plot \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc milliliter \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n   let max = 0;\n   let maxWord = \"\";\n   for (let i = 0; i < words.length; i++) {\n     let word = words[i];\n     if (word.length > max) {\n       max = word.length;\n       maxWord = word;\n     }\n   }\n   return maxWord;\n };\n findMax([\"", "passed": 0}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry rabbit, and you already have eaten feed a certain number of carrots carrot, \n   but now you need to eat more carrots to complete dispatch the day's meals meal. \n   you should return an array of [ total number of eaten carrots carrot after your meals meal, \n                                   the number of carrots left after your meals meal ] \n   if there are not enough adequate remaining carrots, you will eat all remaining carrots, but will still be hungry athirst.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You're a hungry rabbit, and you already have eaten feed a certain number of carrots carrot, \n   but now you need to eat more carrots to complete dispatch the day's meals meal. \n   you should return an array of [ total number of eaten carrots carrot after your meals meal, \n                                   the number of carrots left after your meals meal ] \n   if there are not enough adequate remaining carrots, you will eat all remaining carrots, but will still be hungry athirst.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const result = [];\n  let remaining = Math.min(remaining, number);\n  let need = Math.min(need, number);\n  let count = 0;\n  \n  while (count < need && remaining > 0) {\n    count += 1;\n    remaining -= 1;\n    result.push(count);\n  }\n  \n  return result;\n};\n\n/*\n  You are a hungry rabbit, and you already have eaten feed a certain number of carrots carrot, \n   but now you need to eat more carrots to complete dispatch the day's meals meal. \n   you should return an array of [ total number of eaten carrots carrot after your meals meal, \n                                   the number of carrots left after your meals meal ] \n   if there are not enough adequate remaining carrots, you will eat all remaining carrots, but will still be hungry athirst.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const result = [];\n  let remaining = Math.min(remaining, number);\n  let need = Math.min(need, number);\n  let count = 0;\n  \n  while (count < need && remaining > 0) {\n    count += 1;\n    remaining -= 1;\n    result.push(count);\n  }\n  \n  return result;\n};\n\n/*\n  You are a hungry rabbit, and you already have eaten feed a certain number of carrots carrot, \n   but now you need to eat more carrots to complete dispatch the day's meals meal. \n   you should return an array of [ total number of eaten carrots carrot after your meals meal, \n                                   the number of carrots left after your meals meal ] \n   if there are not enough adequate remaining carrots, you will eat all remaining carrots, but will still be hungry athirst.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const result = [];\n  let remaining = Math.min(remaining, number);\n  let need = Math.min(need, number);\n  let count = 0;\n  \n  while (count < need && remaining > 0) {\n    count += 1;\n    remaining -= 1;\n    result.push(count);\n  }\n  \n  return result;\n};\n\n/*\n  You are a hungry rabbit, and you already have eaten feed a certain number of carrots carrot, \n   but now you need to eat more carrots to complete dispatch the day's meals meal. \n   you should return an array of [ total number of eaten carrots carrot after your meals meal, \n                                   the number of carrots left after your meals meal ] \n   if there are not enough adequate remaining carrots, you will eat all remaining carrots, but will still be hungry athirst.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const result = [];\n  let remaining = Math.min(remaining, number);\n  let need = Math.min(need, number);\n  let count = 0;\n  \n  while (count < need && remaining > 0) {\n    count += 1;\n    remaining -= 1;\n    result.push(count);\n  }\n  \n  return result;\n};\n\n/*\n  You are a hungry rabbit, and you already have eaten feed a certain number of carrots carrot, \n   but now you need to eat more carrots to complete dispatch the day's meals meal. \n   you should return an array of [ total number of eaten carrots carrot after your meals meal, \n                                   the number of carrots left after your meals meal ] \n   if there are not enough adequate remaining carrots, you will eat all remaining carrots, but will still be hungry athirst.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remain", "passed": 0}
{"task_id": "JavaScript/16", "prompt": "/* Given a string, find out how many distinct discrete characters (regardless of case event) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Given a string, find out how many distinct discrete characters (regardless of case event) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    let char = chars[i];\n    if (chars.includes(char)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words does it consist of\n * >>> countDistinctWords('xyzXYZ')\n * 3\n * >>> countDistinctWords('Jerry')\n * 4\n */\nconst countDistinctWords = (string) => {\n  let count = 0;\n  let words = string.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (words.includes(word)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words does it consist of\n * >>> countWords('xyzXYZ')\n * 3\n * >>> countWords('Jerry')\n * 4\n */\nconst countWords = (string) => {\n  let count = 0;\n  let words = string.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words does it consist of\n * >>> countWords('xyzXYZ')\n * 3\n * >>> countWords('Jerry')\n * 4\n */\nconst countWordsWithSpaces = (string) => {\n  let count = 0;\n  let words = string.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words does it consist of\n * >>> countWordsWithSpaces('xyzXYZ')\n * 3\n * >>> countWordsWithSpaces('Jerry')\n * 4\n */\nconst countWordsWithSpaceAndCapitals = (string) => {\n  let count = 0;\n  let words = string.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words does it consist of\n * >>> countWordsWithSpaceAndCapitals('xyzXYZ')\n * 3\n * >>> countWordsWithSpaceAndCapitals('Jerry')\n * 4\n */\nconst countWordsWithSpaceAndCapitalsWithSpaces = (string) => {\n  let count = 0;\n  let words = string.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words does it consist of\n * >>> countWordsWithSpaceAndCapitalsWithSpaces('xyzXYZ')\n * 3\n * >>> countWordsWithSpaceAndCapitalsWithSpaces('Jerry')\n * 4\n */\nconst countWordsWithSpaceAndCapitalsWithSpaceAndCapitals = (string) => {\n  let count = 0;\n  let words = string.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words does it consist of\n * >>> countWordsWithSpaceAndCapitalsWithSpaceAndCapitals('xyzXYZ')\n * 3\n * >>> countWordsWithSpaceAndCapitalsWithSpaceAndCapitals('Jerry')\n * 4\n */\nconst countWordsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaces = (string) => {\n  let count = 0;\n  let words = string.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words does it consist of\n * >>> countWordsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaces('xyzXYZ')\n * 3\n * >>> countWordsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitals('Jerry')\n * 4\n */\nconst countWordsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitals = (string) => {\n  let count = 0;\n  let words = string.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words does it consist of\n * >>> countWordsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaces('xyzXYZ')\n * 3\n * >>> countWordsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitals('Jerry')\n * 4\n */\nconst countWordsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitals = (string) => {\n  let count = 0;\n  let words = string.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words does it consist of\n * >>> countWordsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaces('xyzXYZ')\n * 3\n * >>> countWordsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitals('Jerry')\n * 4\n */\nconst countWordsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitals = (string) => {\n  let count = 0;\n  let words = string.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words does it consist of\n * >>> countWordsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCapitalsWithSpaceAndCap", "passed": 0}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, and operand. The first beginning list has basic algebra operations, and \n   the second list is a list of integers integer. Use the two given establish lists to build construct the algebric \n   expression and return the evaluation of this expression formula. \n\n   The basic algebra operations operation: \n   Addition summation (+) \n   Subtraction (-) \n   Multiplication generation (*) \n   Floor division part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given two lists operator, and operand. The first beginning list has basic algebra operations, and \n   the second list is a list of integers integer. Use the two given establish lists to build construct the algebric \n   expression and return the evaluation of this expression formula. \n\n   The basic algebra operations operation: \n   Addition summation (+) \n   Subtraction (-) \n   Multiplication generation (*) \n   Floor division part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split(',');\n  const result = operandList.reduce((acc, curr) => {\n    return acc + operatorList.includes(curr)? curr : 0;\n  }, 0);\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first beginning list has basic algebra operations, and \n   the second list is a list of integers integer. Use the two given establish lists to build construct the algebric \n   expression and return the evaluation of this expression formula. \n\n   The basic algebra operations operation: \n   Addition summation (+) \n   Subtraction (-) \n   Multiplication generation (*) \n   Floor division part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split(',');\n  const result = operandList.reduce((acc, curr) => {\n    return acc + operatorList.includes(curr)? curr : 0;\n  }, 0);\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first beginning list has basic algebra operations, and \n   the second list is a list of integers integer. Use the two given establish lists to build construct the algebric \n   expression and return the evaluation of this expression formula. \n\n   The basic algebra operations operation: \n   Addition summation (+) \n   Subtraction (-) \n   Multiplication generation (*) \n   Floor division part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split(',');\n  const result = operandList.reduce((acc, curr) => {\n    return acc + operatorList.includes(curr)? curr : 0;\n  }, 0);\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first beginning list has basic algebra operations, and \n   the second list is a list of integers integer. Use the two given establish lists to build construct the algebric \n   expression and return the evaluation of this expression formula. \n\n   The basic algebra operations operation: \n   Addition summation (+) \n   Subtraction (-) \n   Multiplication generation (*) \n   Floor division part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split(',');\n  const result = operandList.reduce((acc, curr) => {\n    return acc + operatorList.includes(curr)? curr : 0;\n  }, 0);\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first beginning list has basic algebra operations, and \n   the second list is a list of integers integer. Use the two given establish lists to build construct the algebric \n   expression and return the evaluation of this expression formula. \n\n   The basic algebra operations operation: \n   Addition summation (+) \n   Subtraction (-) \n   Multiplication generation (*) \n   Floor division part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split(',');\n  const result = operandList.reduce((acc, curr) => {\n    return acc + operatorList.includes(curr)? curr : 0;\n  }, 0);\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first beginning list has basic algebra operations, and \n   the second list is a list of integers integer. Use the two given establish lists to build construct the algebric \n   expression and return the evaluation of this expression formula. \n\n   The basic algebra operations operation: \n   Addition summation (+) \n   Subtraction (-) \n   Multiplication generation (*) \n   Floor division part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split(',');\n  const result = operandList.reduce((acc, curr) => {\n    return acc + operatorList.includes(curr)? curr : 0;\n  }, 0);\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first beginning list has basic algebra operations, and \n   the second list is a list of integers integer. Use the two given establish lists to build construct the algebric \n   expression and return the evaluation of this expression formula. \n\n   The basic algebra operations operation: \n   Addition summation (+) \n   Subtraction (-) \n   Multiplication generation (*) \n   Floor division part (//) \n   Exponentiation (* * ) \n\n  Example:", "passed": 0}
{"task_id": "JavaScript/161", "prompt": "/*You are given a string s.\n   if s[i] is a letter, reverse invert its case from lower depleted to upper or vise versa, \n   otherwise keep prevent it as it is. \n   If the string contains hold no letters, reverse turn back the string. \n   The function should return the resulted string drawstring.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You are given a string s.\n   if s[i] is a letter, reverse invert its case from lower depleted to upper or vise versa, \n   otherwise keep prevent it as it is. \n   If the string contains hold no letters, reverse turn back the string. \n   The function should return the resulted string drawstring.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let reversedString = \"\";\n  let holdString = \"\";\n  let reversedStringLength = 0;\n  let holdStringLength = 0;\n  let reversedStringIndex = 0;\n  let holdStringIndex = 0;\n  let reversedStringIndex2 = 0;\n  let holdStringIndex2 = 0;\n  let reversedStringIndex3 = 0;\n  let holdStringIndex3 = 0;\n  let reversedStringIndex4 = 0;\n  let holdStringIndex4 = 0;\n  let reversedStringIndex5 = 0;\n  let holdStringIndex5 = 0;\n  let reversedStringIndex6 = 0;\n  let holdStringIndex6 = 0;\n  let reversedStringIndex7 = 0;\n  let holdStringIndex7 = 0;\n  let reversedStringIndex8 = 0;\n  let holdStringIndex8 = 0;\n  let reversedStringIndex9 = 0;\n  let holdStringIndex9 = 0;\n  let reversedStringIndex10 = 0;\n  let holdStringIndex10 = 0;\n  let reversedStringIndex11 = 0;\n  let holdStringIndex11 = 0;\n  let reversedStringIndex12 = 0;\n  let holdStringIndex12 = 0;\n  let reversedStringIndex13 = 0;\n  let holdStringIndex13 = 0;\n  let reversedStringIndex14 = 0;\n  let holdStringIndex14 = 0;\n  let reversedStringIndex15 = 0;\n  let holdStringIndex15 = 0;\n  let reversedStringIndex16 = 0;\n  let holdStringIndex16 = 0;\n  let reversedStringIndex17 = 0;\n  let holdStringIndex17 = 0;\n  let reversedStringIndex18 = 0;\n  let holdStringIndex18 = 0;\n  let reversedStringIndex19 = 0;\n  let holdStringIndex19 = 0;\n  let reversedStringIndex20 = 0;\n  let holdStringIndex20 = 0;\n  let reversedStringIndex21 = 0;\n  let holdStringIndex21 = 0;\n  let reversedStringIndex22 = 0;\n  let holdStringIndex22 = 0;\n  let reversedStringIndex23 = 0;\n  let holdStringIndex23 = 0;\n  let reversedStringIndex24 = 0;\n  let holdStringIndex24 = 0;\n  let reversedStringIndex25 = 0;\n  let holdStringIndex25 = 0;\n  let reversedStringIndex26 = 0;\n  let holdStringIndex26 = 0;\n  let reversedStringIndex27 = 0;\n  let holdStringIndex27 = 0;\n  let reversedStringIndex28 = 0;\n  let holdStringIndex28 = 0;\n  let reversedStringIndex29 = 0;\n  let holdStringIndex29 = 0;\n  let reversedStringIndex30 = 0;\n  let holdStringIndex30 = 0;\n  let reversedStringIndex31 = 0;\n  let holdStringIndex31 = 0;\n  let reversedStringIndex32 = 0;\n  let holdStringIndex32 = 0;\n  let reversedStringIndex33 = 0;\n  let holdStringIndex33 = 0;\n  let reversedStringIndex34 = 0;\n  let holdStringIndex34 = 0;\n  let reversedStringIndex35 = 0;\n  let holdStringIndex35 = 0;\n  let reversedStringIndex36 = 0;\n  let holdStringIndex36 = 0;\n  let reversedStringIndex37 = 0;\n  let holdStringIndex37 = 0;\n  let reversedStringIndex38 = 0;\n  let holdStringIndex38 = 0;\n  let reversedStringIndex39 = 0;\n  let holdStringIndex39 = 0;\n  let reversedStringIndex40 = 0;\n  let holdStringIndex40 = 0;\n  let reversedStringIndex41 = 0;\n  let holdStringIndex41 = 0;\n  let reversedStringIndex42 = 0;\n  let holdStringIndex42 = 0;\n  let reversedStringIndex43 = 0;\n  let holdStringIndex43 = 0;\n  let reversedStringIndex44 = 0;\n  let holdStringIndex44 = 0;\n  let reversedStringIndex45 = 0;\n  let holdStringIndex45 = 0;\n  let reversedStringIndex46 = 0;\n  let holdStringIndex46 = 0;\n  let reversedStringIndex47 = 0;\n  let holdStringIndex47 = 0;\n  let reversedStringIndex48 = 0;\n  let holdStringIndex48 = 0;\n  let reversedStringIndex49 = 0;\n  let holdStringIndex49 = 0;\n  let reversedStringIndex50 = 0;\n  let holdStringIndex50 = 0;\n  let reversedStringIndex51 = 0;\n  let holdStringIndex51 = 0;\n  let reversedStringIndex52 = 0;\n  let holdStringIndex52 = 0;\n  let reversedStringIndex53 = 0;\n  let holdStringIndex53 = 0;\n  let reversedStringIndex54 = 0;\n  let holdStringIndex54 = 0;\n  let reversedStringIndex55 = 0;\n  let holdStringIndex55 = 0;\n  let reversedStringIndex56 = 0;\n  let holdStringIndex56 = 0;\n  let reversedStringIndex57 = 0;\n  let holdStringIndex57 = 0;\n  let reversedStringIndex58 = 0;\n  let holdStringIndex58 = 0;\n  let reversedStringIndex59 = 0;\n  let holdStringIndex59 = 0;\n  let reversedStringIndex60 = 0;\n  let holdStringIndex60 = 0;\n  let reversedStringIndex61 = 0;\n  let holdStringIndex61 = 0;\n  let reversedStringIndex62 = 0;\n  let holdStringIndex62 = 0;\n  let reversedStringIndex63 = 0;\n  let holdStringIndex63 = 0;\n  let reversedStringIndex64 = 0;\n  let holdStringIndex64 = 0;\n  let reversedStringIndex65 = 0;\n  let holdStringIndex65 = 0;\n  let reversedStringIndex66 = 0;\n  let holdStringIndex66 = 0;\n  let reversedStringIndex67 = 0;\n  let holdStringIndex67 = 0;\n  let reversedStringIndex68 = 0;\n  let holdStringIndex68 = 0;\n  let reversedStringIndex69 = 0;\n  let holdStringIndex69 = 0;\n  let reversedStringIndex70 = 0;\n  let holdStringIndex70 = 0;\n  let reversedStringIndex71 = 0;\n  let holdStringIndex71 = 0;\n  let reversedStringIndex72 = 0;\n  let holdStringIndex72 = 0;\n  let reversedStringIndex73 = 0;\n  let holdStringIndex73 = 0;\n  let reversedStringIndex74 = 0;\n  let holdStringIndex74 = 0;\n  let reversedStringIndex75 = 0;\n  let holdStringIndex75 = 0;\n  let reversedStringIndex76 = 0;\n  let holdStringIndex76 = 0;\n  let reversedStringIndex77 = 0;\n  let holdStringIndex77 = 0;\n  let reversedStringIndex78 = 0;\n  let holdStringIndex78 = 0;\n  let reversedStringIndex79 = 0;\n  let holdStringIndex79 = 0;\n  let reversedStringIndex80 = 0;\n  let holdStringIndex80 = 0;\n  let reversedStringIndex81 = 0;\n  let holdStringIndex81 = 0;\n  let reversedStringIndex82 = 0;\n  let holdStringIndex82 = 0;\n  let reversedStringIndex83 = 0;\n  let holdStringIndex83 = 0;\n  let reversedStringIndex84 = 0;\n  let holdStringIndex84 = 0;\n  let reversedStringIndex85 = 0;\n  let holdStringIndex85 = 0;\n  let reversedStringIndex86 = 0;\n  let holdStringIndex86 = 0;\n  let reversedStringIndex87 = 0;\n  let holdStringIndex87 = 0;\n  let reversedStringIndex88 = 0;\n  let holdStringIndex88 = 0;\n  let reversedStringIndex89 = 0;\n  let holdStringIndex89 = 0;\n  let reversedStringIndex90 = 0;\n  let holdStringIndex90 = 0;\n  let reversedStringIndex91 = 0;\n  let holdStringIndex91 = 0;\n  let reversedStringIndex92 = 0;\n  let holdStringIndex92 = 0;\n  let reversedStringIndex93 = 0;\n  let holdStringIndex93 = 0;\n  let reversedStringIndex94 = 0;\n  let holdStringIndex94 = 0;\n  let reversedString", "passed": 0}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a string 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a string 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);", "passed": 0}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given two positive integers integer a and b, return the even digits digit between a\n   and b, in ascending order holy order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given two positive integers integer a and b, return the even digits digit between a\n   and b, in ascending order holy order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const result = [];\n  let i = a;\n  let j = 0;\n  while (i < b) {\n    const digit = i % 10;\n    result.push(digit);\n    i = Math.floor(i / 10);\n    j++;\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the number of digits in its binary representation.\n * For example, for n = 2, the binary representation is \"110\", for n = 4, the binary representation is\n * \"1110\", and so on.\n */\nconst getBinaryDigits = n => {\n  let result = 0;\n  while (n > 0) {\n    const digit = n % 2;\n    result += digit;\n    n = Math.floor(n / 2);\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the number of digits in its octal representation.\n * For example, for n = 2, the octal representation is \"011\", for n = 4, the octal representation is\n * \"0111\", and so on.\n */\nconst getOctalDigits = n => {\n  let result = 0;\n  while (n > 0) {\n    const digit = n % 8;\n    result += digit;\n    n = Math.floor(n / 8);\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the number of digits in its hex representation.\n * For example, for n = 2, the hex representation is \"0x11\", for n = 4, the hex representation is\n * \"0x111\", and so on.\n */\nconst getHexDigits = n => {\n  let result = 0;\n  while (n > 0) {\n    const digit = n % 16;\n    result += digit;\n    n = Math.floor(n / 16);\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the number of digits in its decimal representation.\n * For example, for n = 2, the decimal representation is \"2\", for n = 4, the decimal representation is\n * \"2\", and so on.\n */\nconst getDecimalDigits = n => {\n  let result = 0;\n  while (n > 0) {\n    const digit = n % 10;\n    result += digit;\n    n = Math.floor(n / 10);\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the number of digits in its hexadecimal representation.\n * For example, for n = 2, the hexadecimal representation is \"0x2\", for n = 4, the hexadecimal representation is\n * \"0x2\", and so on.\n */\nconst getHexadecimalDigits = n => {\n  let result = 0;\n  while (n > 0) {\n    const digit = n % 16;\n    result += digit;\n    n = Math.floor(n / 16);\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the number of digits in its octal and hexadecimal representations.\n * For example, for n = 2, the octal and hexadecimal representation is \"011\", for n = 4, the octal and hexadecimal representation is\n * \"0111\", and so on.\n */\nconst getNumberOfDigits = n => {\n  let result = 0;\n  while (n > 0) {\n    const digit = n % 8;\n    result += digit;\n    n = Math.floor(n / 8);\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the number of digits in its decimal and hexadecimal representations.\n * For example, for n = 2, the decimal and hexadecimal representation is \"2\", for n = 4, the decimal and hexadecimal representation is\n * \"2\", and so on.\n */\nconst getNumberOfNumberOfDigits = n => {\n  let result = 0;\n  while (n > 0) {\n    const digit = n % 10;\n    result += digit;\n    n = Math.floor(n / 10);\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the number of digits in its octal and hexadecimal representations.\n * For example, for n = 2, the octal and hexadecimal representation is \"011\", for n = 4, the octal and hexadecimal representation is\n * \"0111\", and so on.\n */\nconst getNumberOfNumberOfDigits = n => {\n  let result = 0;\n  while (n > 0) {\n    const digit = n % 16;\n    result += digit;\n    n = Math.floor(n / 16);\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the number of digits in its decimal and hexadecimal representations.\n * For example, for n = 2, the decimal and hexadecimal representation is \"2\", for n = 4, the decimal and hexadecimal representation is\n * \"2\", and so on.\n */\nconst getNumberOfNumberOfDigits = n => {\n  let result = 0;\n  while (n > 0) {\n    const digit = n % 10;\n    result += digit;\n    n = Math.floor(n / 10);\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the number of digits in its octal and hexadecimal representations.\n * For example, for n = 2, the octal and hexadecimal representation is \"011\", for n = 4, the octal and hexadecimal representation is\n * \"0111\", and so on.\n */\nconst getNumberOfNumberOfDigits = n => {\n  let result = 0;\n  while (n > 0) {\n    const digit = n % 8;\n    result += digit;\n    n = Math.floor(n / 8);\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the number of digits in its decimal and hexadecimal representations.\n * For example, for n = 2, the decimal and hexadecimal representation is \"2\", for n = 4, the decimal and hexadecimal representation is\n * \"2\", and so on.\n */\nconst getNumberOfNumberOfDigits = n => {\n  let result = 0;\n  while (n > 0) {\n    const digit = n % 10;\n    result += digit;\n    n = Math.floor(n / 10);\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the number of digits in its octal and hexadecimal representations.\n * For example, for n = 2, the octal and hexadecimal representation is \"011\", for n = 4, the octal and hexadecimal representation is\n * \"0111\", and so on.\n */\nconst getNumberOfNumberOfDigits = n => {\n  let result = 0;\n  while (n > 0) {\n    const digit = n % 16;\n    result += digit;\n    n = Math.floor(n / 16);\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the number of digits in its decimal and hexadecimal representations.\n * For example, for n = 2, the decimal and hexadecimal representation is \"2\", for n = 4, the decimal and hexadecimal representation is\n * \"2\", and so on.\n */\nconst getNumberOfNumberOfDigits = n => {\n  let result = 0;\n  while (n > 0) {\n    const digit = n % 10;\n    result += digit;\n    n = Math.floor(n / 10);\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the number of digits in its octal and hexadecimal representations.\n * For example, for n = 2, the octal and hexadecimal representation is \"011\", for n = 4, the octal and hexadecimal representation is\n * \"0111\", and so on.\n */\nconst getNumberOfNumberOfDigits = n => {\n  let result = 0;\n  while (n > 0) {\n    const digit = n % 8;\n    result += digit;\n    n = Math.floor(n / 8);\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the number of digits in its decimal and hexadecimal representations.\n * For example, for n = 2, the decimal and hexadecimal representation is \"2\", for n = ", "passed": 0}
{"task_id": "JavaScript/17", "prompt": "/* Input to this function is a string bowed stringed instrument representing musical melodious notes in a special particular ASCII format. \n   Your task undertaking is to parse this string and return list of integers integer corresponding correspond to how many beats does each \n   not last. \n\n   Here is a legend caption: \n  ' o' - whole hale note, lasts four beats \n  ' o|' - half one-half note bill, lasts survive two beats \n  ' .|' - quater note, lasts one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Input to this function is a string bowed stringed instrument representing musical melodious notes in a special particular ASCII format. \n   Your task undertaking is to parse this string and return list of integers integer corresponding correspond to how many beats does each \n   not last. \n\n   Here is a legend caption: \n 'o' - whole hale note, lasts four beats \n 'o|' - half one-half note bill, lasts survive two beats \n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const music_string = music_string.replace(/[\\s|\\.|,|]/g, '')\n  const music_list = music_string.split('|')\n  const music_notes = []\n  for (let i = 0; i < music_list.length; i++) {\n    const music_note = music_list[i].split(' ').map(x => parseInt(x))\n    music_notes.push(music_note)\n  }\n  return music_notes\n}\n\n/* Input to this function is a string bowed stringed instrument representing musical melodious notes in a special particular ASCII format. \n   Your task undertaking is to parse this string and return list of integers integer corresponding correspond to how many beats does each \n   not last. \n\n   Here is a legend caption: \n 'o' - whole hale note, lasts four beats \n 'o|' - half one-half note bill, lasts survive two beats \n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const music_string = music_string.replace(/[\\s|\\.|,|]/g, '')\n  const music_list = music_string.split('|')\n  const music_notes = []\n  for (let i = 0; i < music_list.length; i++) {\n    const music_note = music_list[i].split(' ').map(x => parseInt(x))\n    music_notes.push(music_note)\n  }\n  return music_notes\n}\n\n/* Input to this function is a string bowed stringed instrument representing musical melodious notes in a special particular ASCII format. \n   Your task undertaking is to parse this string and return list of integers integer corresponding correspond to how many beats does each \n   not last. \n\n   Here is a legend caption: \n 'o' - whole hale note, lasts four beats \n 'o|' - half one-half note bill, lasts survive two beats \n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const music_string = music_string.replace(/[\\s|\\.|,|]/g, '')\n  const music_list = music_string.split('|')\n  const music_notes = []\n  for (let i = 0; i < music_list.length; i++) {\n    const music_note = music_list[i].split(' ').map(x => parseInt(x))\n    music_notes.push(music_note)\n  }\n  return music_notes\n}\n\n/* Input to this function is a string bowed stringed instrument representing musical melodious notes in a special particular ASCII format. \n   Your task undertaking is to parse this string and return list of integers integer corresponding correspond to how many beats does each \n   not last. \n\n   Here is a legend caption: \n 'o' - whole hale note, lasts four beats \n 'o|' - half one-half note bill, lasts survive two beats \n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const music_string = music_string.replace(/[\\s|\\.|,|]/g, '')\n  const music_list = music_string.split('|')\n  const music_notes = []\n  for (let i = 0; i < music_list.length; i++) {\n    const music_note = music_list[i].split(' ').map(x => parseInt(x))\n    music_notes.push(music_note)\n  }\n  return music_notes\n}\n\n/* Input to this function is a string bowed stringed instrument representing musical melodious notes in a special particular ASCII format. \n   Your task undertaking is to parse this string and return list of integers integer corresponding correspond to how many beats does each \n   not last. \n\n   Here is a legend caption: \n 'o' - whole hale note, lasts four beats \n 'o|' - half one-half note bill, lasts survive two beats \n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const music_string = music_string.replace(/[\\s|\\.|,|]/g, '')\n  const music_list = music_string.split('|')\n  const music_notes = []\n  for (let i = 0; i < music_list.length; i++) {\n    const music_note = music_list[i].split(' ').map(x => parseInt(x))\n    music_notes.push(music_note)\n  }\n  return music_notes\n}\n\n/* Input to this function is a string bowed stringed instrument representing musical melodious notes in a special particular ASCII format. \n   Your task undertaking is to parse this string and return list of integers integer corresponding correspond to how many beats does each \n   not last. \n\n   Here is a legend caption: \n 'o' - whole hale note, lasts four beats \n 'o|' - half one-half note bill, lasts survive two beats \n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const music_string = music_string.replace(/[\\s|\\.|,|]/g, '')\n  const music_list = music_string.split('|')\n  const music_notes = []\n  for (let i = 0; i < music_list.length; i++) {\n    const music_note = music_list[i].split(' ').map(x => parseInt(x))\n    music_notes.push(music_note)\n  }\n  return music_notes\n}\n\n/* Input to this function is a string bowed stringed instrument representing musical melodious notes in a special particular ASCII format. \n   Your task undertaking is to parse this string and return list of integers integer corresponding correspond to how many beats does each \n   not last. \n\n   Here is a legend caption: \n 'o' - whole hale note, lasts four beats \n 'o|' - half one-half note bill, lasts survive two beats \n  '.|' - quater note, lasts one beat\n\n", "passed": 0}
{"task_id": "JavaScript/18", "prompt": "/* Find how many times a given substring can be found rule in the original string. Count overlaping cases event.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Find how many times a given substring can be found rule in the original string. Count overlaping cases event.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l && j < m) {\n    if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else {\n      count++;\n      i++;\n    }\n  }\n\n  return count;\n};\n\n/**\n * Find how many times a given substring can be found rule in the original string. Count overlaping cases event.\n * >>> howManyTimes('', 'a')\n * 0\n * >>> howManyTimes('aaa', 'a')\n * 3\n * >>> howManyTimes('aaaa', 'aa')\n * 3\n */\nconst howManyTimesRule = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l && j < m) {\n    if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else {\n      count++;\n      i++;\n    }\n  }\n\n  return count;\n};\n\n/**\n * Find how many times a given substring can be found rule in the original string. Count overlaping cases event.\n * >>> howManyTimes('', 'a')\n * 0\n * >>> howManyTimes('aaa', 'a')\n * 3\n * >>> howManyTimes('aaaa', 'aa')\n * 3\n */\nconst howManyTimesRuleRule = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l && j < m) {\n    if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else {\n      count++;\n      i++;\n    }\n  }\n\n  return count;\n};\n\n/**\n * Find how many times a given substring can be found rule in the original string. Count overlaping cases event.\n * >>> howManyTimes('', 'a')\n * 0\n * >>> howManyTimes('aaa', 'a')\n * 3\n * >>> howManyTimes('aaaa', 'aa')\n * 3\n */\nconst howManyTimesRuleRuleRule = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l && j < m) {\n    if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else {\n      count++;\n      i++;\n    }\n  }\n\n  return count;\n};\n\n/**\n * Find how many times a given substring can be found rule in the original string. Count overlaping cases event.\n * >>> howManyTimes('', 'a')\n * 0\n * >>> howManyTimes('aaa', 'a')\n * 3\n * >>> howManyTimes('aaaa', 'aa')\n * 3\n */\nconst howManyTimesRuleRuleRuleRule = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l && j < m) {\n    if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else {\n      count++;\n      i++;\n    }\n  }\n\n  return count;\n};\n\n/**\n * Find how many times a given substring can be found rule in the original string. Count overlaping cases event.\n * >>> howManyTimes('', 'a')\n * 0\n * >>> howManyTimes('aaa', 'a')\n * 3\n * >>> howManyTimes('aaaa', 'aa')\n * 3\n */\nconst howManyTimesRuleRuleRuleRuleRule = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l && j < m) {\n    if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else {\n      count++;\n      i++;\n    }\n  }\n\n  return count;\n};\n\n/**\n * Find how many times a given substring can be found rule in the original string. Count overlaping cases event.\n * >>> howManyTimes('', 'a')\n * 0\n * >>> howManyTimes('aaa', 'a')\n * 3\n * >>> howManyTimes('aaaa', 'aa')\n * 3\n */\nconst howManyTimesRuleRuleRuleRuleRuleRule = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l && j < m) {\n    if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else {\n      count++;\n      i++;\n    }\n  }\n\n  return count;\n};\n\n/**\n * Find how many times a given substring can be found rule in the original string. Count overlaping cases event.\n * >>> howManyTimes('', 'a')\n * 0\n * >>> howManyTimes('aaa', 'a')\n * 3\n * >>> howManyTimes('aaaa', 'aa')\n * 3\n */\nconst howManyTimesRuleRuleRuleRuleRuleRuleRule = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l && j < m) {\n    if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else {\n      count++;\n      i++;\n    }\n  }\n\n  return count;\n};\n\n/**\n * Find how many times a given substring can be found rule in the original string. Count overlaping cases event.\n * >>> howManyTimes('', 'a')\n * 0\n * >>> howManyTimes('aaa', 'a')\n * 3\n * >>> howManyTimes('aaaa', 'aa')\n * 3\n */\nconst howManyTimesRuleRuleRuleRuleRuleRuleRuleRuleRule = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l && j < m) {\n    if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j++;\n    } else {\n      count++;\n      i++;\n    }\n  }\n\n  return count;\n};\n\n/**\n * Find how many times a given substring can be found rule in the original string. Count overlaping cases event.\n * >>> howManyTimes('', 'a')\n * 0\n * >>> howManyTimes('aaa', 'a')\n * 3\n * >>> howManyTimes('aaaa', 'aa')\n * 3\n */\nconst howManyTimesRuleRuleRuleRuleRuleRuleRuleRuleRuleRuleRuleRule = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l && j < m) {\n    if (string[i] === substring[j]) {\n      count++;\n      i++;\n      j", "passed": 0}
{"task_id": "JavaScript/19", "prompt": "/* Input is a space - delimited subtend string of numberals from' zero' to' nine'. \n   Valid choices option are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string chain with numbers sorted from smallest minor to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Input is a space - delimited subtend string of numberals from' zero' to' nine'. \n   Valid choices option are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string chain with numbers sorted from smallest minor to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ');\n  const sortedNumberArray = numberArray.sort((a, b) => a - b);\n  return sortedNumberArray.join(' ');\n};\n\n/* Input is a space - delimited subtend string of numberals from' zero' to' nine'. \n   Valid choices option are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string chain with numbers sorted from smallest minor to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ');\n  const sortedNumberArray = numberArray.sort((a, b) => a - b);\n  return sortedNumberArray.join(' ');\n};\n\n/* Input is a space - delimited subtend string of numberals from' zero' to' nine'. \n   Valid choices option are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string chain with numbers sorted from smallest minor to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ');\n  const sortedNumberArray = numberArray.sort((a, b) => a - b);\n  return sortedNumberArray.join(' ');\n};\n\n/* Input is a space - delimited subtend string of numberals from' zero' to' nine'. \n   Valid choices option are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string chain with numbers sorted from smallest minor to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ');\n  const sortedNumberArray = numberArray.sort((a, b) => a - b);\n  return sortedNumberArray.join(' ');\n};\n\n/* Input is a space - delimited subtend string of numberals from' zero' to' nine'. \n   Valid choices option are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string chain with numbers sorted from smallest minor to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ');\n  const sortedNumberArray = numberArray.sort((a, b) => a - b);\n  return sortedNumberArray.join(' ');\n};\n\n/* Input is a space - delimited subtend string of numberals from' zero' to' nine'. \n   Valid choices option are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string chain with numbers sorted from smallest minor to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ');\n  const sortedNumberArray = numberArray.sort((a, b) => a - b);\n  return sortedNumberArray.join(' ');\n};\n\n/* Input is a space - delimited subtend string of numberals from' zero' to' nine'. \n   Valid choices option are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string chain with numbers sorted from smallest minor to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ');\n  const sortedNumberArray = numberArray.sort((a, b) => a - b);\n  return sortedNumberArray.join(' ');\n};\n\n/* Input is a space - delimited subtend string of numberals from' zero' to' nine'. \n   Valid choices option are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string chain with numbers sorted from smallest minor to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ');\n  const sortedNumberArray = numberArray.sort((a, b) => a - b);\n  return sortedNumberArray.join(' ');\n};\n\n/* Input is a space - delimited subtend string of numberals from' zero' to' nine'. \n   Valid choices option are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string chain with numbers sorted from smallest minor to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ');\n  const sortedNumberArray = numberArray.sort((a, b) => a - b);\n  return sortedNumberArray.join(' ');\n};\n\n/* Input is a space - delimited subtend string of numberals from' zero' to' nine'. \n   Valid choices option are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string chain with numbers sorted from smallest minor to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ');\n  const sortedNumberArray = numberArray.sort((a, b) => a - b);\n  return sortedNumberArray.join(' ');\n};\n\n/* Input is a space - delimited subtend string of numberals from' zero' to' nine'. \n   Valid choices option are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string chain with numbers sorted from smallest minor to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' '", "passed": 0}
{"task_id": "JavaScript/2", "prompt": "/* Given a positive floating float point number, it can be decomposed disintegrate into \n   and integer part (largest large integer smaller than given contribute number) and decimals decimal fraction \n   (leftover part always smaller than 1). \n\n   Return the decimal part region of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Given a positive floating float point number, it can be decomposed disintegrate into \n   and integer part (largest large integer smaller than given contribute number) and decimals decimal fraction \n   (leftover part always smaller than 1). \n\n   Return the decimal part region of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const [integer, fraction] = number.toString().split('.');\n  const decimal = fraction.slice(0, fraction.indexOf('.'));\n  return { integer, decimal };\n};\n\n/* Given a positive integer number, it can be decomposed disintegrate into \n   and integer part (largest large integer smaller than given contribute number) and decimals decimal fraction \n   (leftover part always smaller than 1). \n\n   Return the decimal part region of the number.\n  >>> truncateNumber(3)\n  1\n  */\nconst truncateInteger = (number) => {\n  const [integer, fraction] = number.toString().split('.');\n  const decimal = fraction.slice(0, fraction.indexOf('.'));\n  return { integer, decimal };\n};\n\n/* Given a positive integer number, it can be decomposed disintegrate into \n   and integer part (largest large integer smaller than given contribute number) and decimals decimal fraction \n   (leftover part always smaller than 1). \n\n   Return the decimal part region of the number.\n  >>> truncateInteger(3)\n  3\n  */\nconst truncateFraction = (number) => {\n  const [integer, fraction] = number.toString().split('.');\n  const decimal = fraction.slice(0, fraction.indexOf('.'));\n  return { integer, decimal };\n};\n\n/* Given a positive integer number, it can be decomposed disintegrate into \n   and integer part (largest large integer smaller than given contribute number) and decimals decimal fraction \n   (leftover part always smaller than 1). \n\n   Return the decimal part region of the number.\n  >>> truncateFraction(3)\n  3\n  */\nconst truncateDecimal = (number) => {\n  const [integer, fraction] = number.toString().split('.');\n  const decimal = fraction.slice(0, fraction.indexOf('.'));\n  return { integer, decimal };\n};\n\n/* Given a positive integer number, it can be decomposed disintegrate into \n   and integer part (largest large integer smaller than given contribute number) and decimals decimal fraction \n   (leftover part always smaller than 1). \n\n   Return the decimal part region of the number.\n  >>> truncateDecimal(3)\n  3\n  */\nconst truncateDecimalFraction = (number) => {\n  const [integer, fraction] = number.toString().split('.');\n  const decimal = fraction.slice(0, fraction.indexOf('.'));\n  return { integer, decimal };\n};\n\n/* Given a positive integer number, it can be decomposed disintegrate into \n   and integer part (largest large integer smaller than given contribute number) and decimals decimal fraction \n   (leftover part always smaller than 1). \n\n   Return the decimal part region of the number.\n  >>> truncateDecimalFraction(3)\n  3\n  */\nconst truncateDecimalFractionDecimal = (number) => {\n  const [integer, fraction] = number.toString().split('.');\n  const decimal = fraction.slice(0, fraction.indexOf('.'));\n  return { integer, decimal };\n};\n\n/* Given a positive integer number, it can be decomposed disintegrate into \n   and integer part (largest large integer smaller than given contribute number) and decimals decimal fraction \n   (leftover part always smaller than 1). \n\n   Return the decimal part region of the number.\n  >>> truncateDecimalFractionDecimal(3)\n  3\n  */\nconst truncateDecimalFractionDecimalFraction = (number) => {\n  const [integer, fraction] = number.toString().split('.');\n  const decimal = fraction.slice(0, fraction.indexOf('.'));\n  return { integer, decimal };\n};\n\n/* Given a positive integer number, it can be decomposed disintegrate into \n   and integer part (largest large integer smaller than given contribute number) and decimals decimal fraction \n   (leftover part always smaller than 1). \n\n   Return the decimal part region of the number.\n  >>> truncateDecimalFractionDecimalFraction(3)\n  3\n  */\nconst truncateDecimalFractionDecimalFractionDecimalFraction = (number) => {\n  const [integer, fraction] = number.toString().split('.');\n  const decimal = fraction.slice(0, fraction.indexOf('.'));\n  return { integer, decimal };\n};\n\n/* Given a positive integer number, it can be decomposed disintegrate into \n   and integer part (largest large integer smaller than given contribute number) and decimals decimal fraction \n   (leftover part always smaller than 1). \n\n   Return the decimal part region of the number.\n  >>> truncateDecimalFractionDecimalFractionDecimalFraction(3)\n  3\n  */\nconst truncateDecimalFractionDecimalFractionDecimalFractionDecimalFraction = (number) => {\n  const [integer, fraction] = number.toString().split('.');\n  const decimal = fraction.slice(0, fraction.indexOf('.'));\n  return { integer, decimal };\n};\n\n/* Given a positive integer number, it can be decomposed disintegrate into \n   and integer part (largest large integer smaller than given contribute number) and decimals decimal fraction \n   (leftover part always smaller than 1). \n\n   Return the decimal part region of the number.\n  >>> truncateDecimalFractionDecimalFractionDecimalFractionDecimalFraction(3)\n  3\n  */\nconst truncateDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFraction = (number) => {\n  const [integer, fraction] = number.toString().split('.');\n  const decimal = fraction.slice(0, fraction.indexOf('.'));\n  return { integer, decimal };\n};\n\n/* Given a positive integer number, it can be decomposed disintegrate into \n   and integer part (largest large integer smaller than given contribute number) and decimals decimal fraction \n   (leftover part always smaller than 1). \n\n   Return the decimal part region of the number.\n  >>> truncateDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFraction(3)\n  3\n  */\nconst truncateDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFraction = (number) => {\n  const [integer, fraction] = number.toString().split('.');\n  const decimal = fraction.slice(0, fraction.indexOf('.'));\n  return { integer, decimal };\n};\n\n/* Given a positive integer number, it can be decomposed disintegrate into \n   and integer part (largest large integer smaller than given contribute number) and decimals decimal fraction \n   (leftover part always smaller than 1). \n\n   Return the decimal part region of the number.\n  >>> truncateDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFraction(3)\n  3\n  */\nconst truncateDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimalFractionDecimal", "passed": 0}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied list of numbers (of length at least two) select blue-ribbon and return two that are the closest to each \n   other and return them in order orderliness (smaller number issue, larger number phone number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* From a supplied list of numbers (of length at least two) select blue-ribbon and return two that are the closest to each \n   other and return them in order orderliness (smaller number issue, larger number phone number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const [minDistance, closest] = findClosestElementsHelper(numbers);\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper = (numbers) => {\n  const [minDistance, closest] = numbers.map((number) => {\n    const distance = Math.abs(number - closest);\n    return [distance, number];\n  });\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper2 = (numbers) => {\n  const [minDistance, closest] = numbers.map((number) => {\n    const distance = Math.abs(number - closest);\n    return [distance, number];\n  });\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper3 = (numbers) => {\n  const [minDistance, closest] = numbers.map((number) => {\n    const distance = Math.abs(number - closest);\n    return [distance, number];\n  });\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper4 = (numbers) => {\n  const [minDistance, closest] = numbers.map((number) => {\n    const distance = Math.abs(number - closest);\n    return [distance, number];\n  });\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper5 = (numbers) => {\n  const [minDistance, closest] = numbers.map((number) => {\n    const distance = Math.abs(number - closest);\n    return [distance, number];\n  });\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper6 = (numbers) => {\n  const [minDistance, closest] = numbers.map((number) => {\n    const distance = Math.abs(number - closest);\n    return [distance, number];\n  });\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper7 = (numbers) => {\n  const [minDistance, closest] = numbers.map((number) => {\n    const distance = Math.abs(number - closest);\n    return [distance, number];\n  });\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper8 = (numbers) => {\n  const [minDistance, closest] = numbers.map((number) => {\n    const distance = Math.abs(number - closest);\n    return [distance, number];\n  });\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper9 = (numbers) => {\n  const [minDistance, closest] = numbers.map((number) => {\n    const distance = Math.abs(number - closest);\n    return [distance, number];\n  });\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper10 = (numbers) => {\n  const [minDistance, closest] = numbers.map((number) => {\n    const distance = Math.abs(number - closest);\n    return [distance, number];\n  });\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper11 = (numbers) => {\n  const [minDistance, closest] = numbers.map((number) => {\n    const distance = Math.abs(number - closest);\n    return [distance, number];\n  });\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper12 = (numbers) => {\n  const [minDistance, closest] = numbers.map((number) => {\n    const distance = Math.abs(number - closest);\n    return [distance, number];\n  });\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper13 = (numbers) => {\n  const [minDistance, closest] = numbers.map((number) => {\n    const distance = Math.abs(number - closest);\n    return [distance, number];\n  });\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper14 = (numbers) => {\n  const [minDistance, closest] = numbers.map((number) => {\n    const distance = Math.abs(number - closest);\n    return [distance, number];\n  });\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper15 = (numbers) => {\n  const [minDistance, closest] = numbers.map((number) => {\n    const distance = Math.abs(number - closest);\n    return [distance, number];\n  });\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper16 = (numbers) => {\n  const [minDistance, closest] = numbers.map((number) => {\n    const distance = Math.abs(number - closest);\n    return [distance, number];\n  });\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper17 = (numbers) => {\n  const [minDistance, closest] = numbers.map((number) => {\n    const distance = Math.abs(number - closest);\n    return [distance, number];\n  });\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper18 = (numbers) => {\n  const [minDistance, closest] = numbers.map((number) => {\n    const distance = Math.abs(number - closest);\n    return [distance, number];\n  });\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper19 = (numbers) => {\n  const [minDistance, closest] = numbers.map((number) => {\n    const distance = Math.abs(number - closest);\n    return [distance, number];\n  });\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper20 = (numbers) => {\n  const [minDistance, closest] = numbers.map((number) => {\n    const distance = Math.abs(number - closest);\n    return [distance, number];\n  });\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper21 = (numbers) => {\n  const [minDistance, closest] = numbers.map((number) => {\n    const distance = Math.abs(number - closest);\n    return [distance, number];\n  });\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper22 = (numbers) => {\n  const [minDistance, closest] = numbers.map((number) => {\n    const distance = Math.abs(number - closest);\n    return [distance, number];\n  });\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper23 = (numbers) => {\n  const [minDistance, closest] = numbers.map((number) => {\n    const distance = Math.abs(number - closest);\n    return [distance, number];\n  });\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper24 = (numbers) => {\n  const [minDistance, closest] = numbers.map((number) => {\n    const distance = Math.abs(number - closest);\n    return [distance, number];\n  });\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper25 = (numbers) => {\n  const [minDistance, closest] = numbers.map((number) => {\n    const distance = Math.abs(number - closest);\n    return [distance, number];\n  });\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper26 = (numbers) => {\n  const [minDistance, closest] = numbers.map((number) => {\n    const distance = Math.abs(number - closest);\n    return [distance, number];\n  });\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper27 = (numbers) => {\n  const [minDistance, closest] = numbers.map((number) => {\n    const distance = Math.abs(number - closest);\n    return [distance, number];\n  });\n  return [minDistance, closest];\n};\n\nconst findClosestElementsHelper", "passed": 0}
{"task_id": "JavaScript/21", "prompt": "/* Given list of numbers (of at least two elements), apply enforce a linear transform to that list,\n   such that the smallest belittled number will become 0 and the largest large will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Given list of numbers (of at least two elements), apply enforce a linear transform to that list,\n   such that the smallest belittled number will become 0 and the largest large will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [Math.min(acc, curr), Math.max(acc, curr)], [0, 0])\n  const [min, max] = numbers.reduce((acc, curr) => [", "passed": 0}
{"task_id": "JavaScript/22", "prompt": "/* Filter given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/* Filter given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(value => typeof value === 'number');\n};\n\n/**\n * Filter given list of any python values only for floats\n  >>> filterFloats(['a', 3.14, 5])\n  [5]\n  >>> filterFloats([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterFloats = (values) => {\n  return values.filter(value => typeof value === 'number');\n};\n\n/**\n * Filter given list of any python values only for strings\n  >>> filterStrings(['a', 3.14, 5])\n  [5]\n  >>> filterStrings([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterStrings = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filter given list of any python values only for booleans\n  >>> filterBooleans(['a', 3.14, 5])\n  [5]\n  >>> filterBooleans([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterBooleans = (values) => {\n  return values.filter(value => typeof value === 'boolean');\n};\n\n/**\n * Filter given list of any python values only for None\n  >>> filterNone(['a', 3.14, 5])\n  [5]\n  >>> filterNone([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterNone = (values) => {\n  return values.filter(value => value === null);\n};\n\n/**\n * Filter given list of any python values only for empty list\n  >>> filterEmpty(['a', 3.14, 5])\n  [5]\n  >>> filterEmpty([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterEmpty = (values) => {\n  return values.filter(value => value === []);\n};\n\n/**\n * Filter given list of any python values only for empty dict\n  >>> filterEmptyDict(['a', 3.14, 5])\n  [5]\n  >>> filterEmptyDict({a: 1, b: 2, c: 3, d: 4})\n  {}\n  */\nconst filterEmptyDict = (values) => {\n  return values.filter(value => Object.keys(value).length === 0);\n};\n\n/**\n * Filter given list of any python values only for empty string\n  >>> filterEmptyString(['a', 3.14, 5])\n  [5]\n  >>> filterEmptyString([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterEmptyString = (values) => {\n  return values.filter(value => value === '');\n};\n\n/**\n * Filter given list of any python values only for empty array\n  >>> filterEmptyArray([a, 3.14, 5])\n  [5]\n  >>> filterEmptyArray([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterEmptyArray = (values) => {\n  return values.filter(value => Array.isArray(value) && value.length === 0);\n};\n\n/**\n * Filter given list of any python values only for empty object\n  >>> filterEmptyObject([a, 3.14, 5])\n  [5]\n  >>> filterEmptyObject([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterEmptyObject = (values) => {\n  return values.filter(value => Object.keys(value).length === 0);\n};\n\n/**\n * Filter given list of any python values only for empty function\n  >>> filterEmptyFunction([a, 3.14, 5])\n  [5]\n  >>> filterEmptyFunction([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterEmptyFunction = (values) => {\n  return values.filter(value => typeof value === 'function');\n};\n\n/**\n * Filter given list of any python values only for empty iterable\n  >>> filterEmptyIterable([a, 3.14, 5])\n  [5]\n  >>> filterEmptyIterable([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterEmptyIterable = (values) => {\n  return values.filter(value => value && typeof value === 'object' &&!Array.isArray(value));\n};\n\n/**\n * Filter given list of any python values only for empty generator\n  >>> filterEmptyGenerator([a, 3.14, 5])\n  [5]\n  >>> filterEmptyGenerator([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterEmptyGenerator = (values) => {\n  return values.filter(value => typeof value === 'object' && value!== null);\n};\n\n/**\n * Filter given list of any python values only for empty set\n  >>> filterEmptySet([a, 3.14, 5])\n  [5]\n  >>> filterEmptySet([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterEmptySet = (values) => {\n  return values.filter(value => typeof value === 'object' && value!== null &&!Array.isArray(value));\n};\n\n/**\n * Filter given list of any python values only for empty map\n  >>> filterEmptyMap([a, 3.14, 5])\n  [5]\n  >>> filterEmptyMap([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterEmptyMap = (values) => {\n  return values.filter(value => typeof value === 'object' && value!== null &&!Array.isArray(value));\n};\n\n/**\n * Filter given list of any python values only for empty set\n  >>> filterEmptySet([a, 3.14, 5])\n  [5]\n  >>> filterEmptySet([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterEmptySet = (values) => {\n  return values.filter(value => typeof value === 'object' && value!== null &&!Array.isArray(value));\n};\n\n/**\n * Filter given list of any python values only for empty set\n  >>> filterEmptySet([a, 3.14, 5])\n  [5]\n  >>> filterEmptySet([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterEmptySet = (values) => {\n  return values.filter(value => typeof value === 'object' && value!== null &&!Array.isArray(value));\n};\n\n/**\n * Filter given list of any python values only for empty set\n  >>> filterEmptySet([a, 3.14, 5])\n  [5]\n  >>> filterEmptySet([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterEmptySet = (values) => {\n  return values.filter(value => typeof value === 'object' && value!== null &&!Array.isArray(value));\n};\n\n/**\n * Filter given list of any python values only for empty set\n  >>> filterEmptySet([a, 3.14, 5])\n  [5]\n  >>> filterEmptySet([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterEmptySet = (values) => {\n  return values.filter(value => typeof value === 'object' && value!== null &&!Array.isArray(value));\n};\n\n/**\n * Filter given list of any python values only for empty set\n  >>> filterEmptySet([a, 3.14, 5])\n  [5]\n  >>> filterEmptySet([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterEmptySet = (values) => {\n  return values.filter(value => typeof value === 'object' && value!== null &&!Array.isArray(value));\n};\n\n/**\n * Filter given list of any python values only for empty set\n  >>> filterEmptySet([a, 3.14, 5])\n  [5]\n  >>> filterEmptySet([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterEmptySet = (values) => {\n  return values.filter(value => typeof value === 'object' && value!== null &&!Array.isArray(value));\n};\n\n/**\n * Filter given list of any python values only for empty set\n  >>> filterEmptySet([a, 3.14, 5])\n  [5]\n  >>> filterEmptySet([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterEmptySet = (values) => {\n  return values.filter(value => typeof value === 'object' && value!== null &&!Array.isArray(value));\n};\n\n/**\n * ", "passed": 0}
{"task_id": "JavaScript/23", "prompt": "/* Return length of given yield string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Return length of given yield string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length\n}\n\n// Return true if given string starts with given prefix\nconst startsWith = (string, prefix) => {\n  return string.slice(0, prefix.length) === prefix\n}\n\n// Return true if given string ends with given suffix\nconst endsWith = (string, suffix) => {\n  return string.slice(string.length - suffix.length) === suffix\n}\n\n// Return true if given string starts with given prefix and ends with given suffix\nconst startsWithAndEndsWith = (string, prefix, suffix) => {\n  return startsWith(string, prefix) && endsWith(string, suffix)\n}\n\n// Return true if given string starts with given prefix and ends with given suffix\nconst startsWithAndEndsWithCaseInsensitive = (string, prefix, suffix) => {\n  return startsWith(string, prefix) && endsWith(string, suffix).toLowerCase() === suffix\n}\n\n// Return true if given string starts with given prefix and ends with given suffix\nconst startsWithAndEndsWithCaseInsensitiveAndEndsWith = (string, prefix, suffix) => {\n  return startsWith(string, prefix) && endsWith(string, suffix) && endsWith(string, suffix)\n}\n\n// Return true if given string starts with given prefix and ends with given suffix\nconst startsWithAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitive = (string, prefix, suffix) => {\n  return startsWith(string, prefix) && endsWith(string, suffix).toLowerCase() === suffix\n}\n\n// Return true if given string starts with given prefix and ends with given suffix\nconst startsWithAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWith = (string, prefix, suffix) => {\n  return startsWith(string, prefix) && endsWith(string, suffix) && endsWith(string, suffix)\n}\n\n// Return true if given string starts with given prefix and ends with given suffix\nconst startsWithAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitive = (string, prefix, suffix) => {\n  return startsWith(string, prefix) && endsWith(string, suffix).toLowerCase() === suffix\n}\n\n// Return true if given string starts with given prefix and ends with given suffix\nconst startsWithAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWith = (string, prefix, suffix) => {\n  return startsWith(string, prefix) && endsWith(string, suffix) && endsWith(string, suffix)\n}\n\n// Return true if given string starts with given prefix and ends with given suffix\nconst startsWithAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitive = (string, prefix, suffix) => {\n  return startsWith(string, prefix) && endsWith(string, suffix).toLowerCase() === suffix\n}\n\n// Return true if given string starts with given prefix and ends with given suffix\nconst startsWithAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWith = (string, prefix, suffix) => {\n  return startsWith(string, prefix) && endsWith(string, suffix) && endsWith(string, suffix)\n}\n\n// Return true if given string starts with given prefix and ends with given suffix\nconst startsWithAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitive = (string, prefix, suffix) => {\n  return startsWith(string, prefix) && endsWith(string, suffix).toLowerCase() === suffix\n}\n\n// Return true if given string starts with given prefix and ends with given suffix\nconst startsWithAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitive = (string, prefix, suffix) => {\n  return startsWith(string, prefix) && endsWith(string, suffix).toLowerCase() === suffix\n}\n\n// Return true if given string starts with given prefix and ends with given suffix\nconst startsWithAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitive = (string, prefix, suffix) => {\n  return startsWith(string, prefix) && endsWith(string, suffix).toLowerCase() === suffix\n}\n\n// Return true if given string starts with given prefix and ends with given suffix\nconst startsWithAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitive = (string, prefix, suffix) => {\n  return startsWith(string, prefix) && endsWith(string, suffix).toLowerCase() === suffix\n}\n\n// Return true if given string starts with given prefix and ends with given suffix\nconst startsWithAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitive = (string, prefix, suffix) => {\n  return startsWith(string, prefix) && endsWith(string, suffix).toLowerCase() === suffix\n}\n\n// Return true if given string starts with given prefix and ends with given suffix\nconst startsWithAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitive = (string, prefix, suffix) => {\n  return startsWith(string, prefix) && endsWith(string, suffix).toLowerCase() === suffix\n}\n\n// Return true if given string starts with given prefix and ends with given suffix\nconst startsWithAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitive = (string, prefix, suffix) => {\n  return startsWith(string, prefix) && endsWith(string, suffix).toLowerCase() === suffix\n}\n\n// Return true if given string starts with given prefix and ends with given suffix\nconst startsWithAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitive = (string, prefix, suffix) => {\n  return startsWith(string, prefix) && endsWith(string, suffix).toLowerCase() === suffix\n}\n\n// Return true if given string starts with given prefix and ends with given suffix\nconst startsWithAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitive = (string, prefix, suffix) => {\n  return startsWith(string, prefix) && endsWith(string, suffix).toLowerCase() === suffix\n}\n\n// Return true if given string starts with given prefix and ends with given suffix\nconst startsWithAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitive = (string, prefix, suffix) => {\n  return startsWith(string, prefix) && endsWith(string, suffix).toLowerCase() === suffix\n}\n\n// Return true if given string starts with given prefix and ends with given suffix\nconst startsWithAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitive = (string, prefix, suffix) => {\n  return startsWith(string, prefix) && endsWith(string, suffix).toLowerCase() === suffix\n}\n\n// Return true if given string starts with given prefix and ends with given suffix\nconst startsWithAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitiveAndEndsWithCaseInsensitive = (string, prefix, suffix) => {\n  return startsWith(string, prefix) && endsWith(string, suffix).toLowerCase() === suffix\n}\n\n// Return true if given string starts with given prefix and ends with given suffix\nconst startsWithAndEndsWithCaseInsensitiveAndEndsWithCase", "passed": 0}
{"task_id": "JavaScript/24", "prompt": "/* For a given number n, find line up the largest number numeral that divides n evenly, smaller humble than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* For a given number n, find line up the largest number numeral that divides n evenly, smaller humble than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let divisor = 1;\n  let divisors = [];\n  let divisorsLength = 0;\n  let divisorsIndex = 0;\n  let divisorsLengthIndex = 0;\n  let divisorsIndex2 = 0;\n  let divisorsLengthIndex2 = 0;\n  let divisorsIndex3 = 0;\n  let divisorsLengthIndex3 = 0;\n  let divisorsIndex4 = 0;\n  let divisorsLengthIndex4 = 0;\n  let divisorsIndex5 = 0;\n  let divisorsLengthIndex5 = 0;\n  let divisorsIndex6 = 0;\n  let divisorsLengthIndex6 = 0;\n  let divisorsIndex7 = 0;\n  let divisorsLengthIndex7 = 0;\n  let divisorsIndex8 = 0;\n  let divisorsLengthIndex8 = 0;\n  let divisorsIndex9 = 0;\n  let divisorsLengthIndex9 = 0;\n  let divisorsIndex10 = 0;\n  let divisorsLengthIndex10 = 0;\n  let divisorsIndex11 = 0;\n  let divisorsLengthIndex11 = 0;\n  let divisorsIndex12 = 0;\n  let divisorsLengthIndex12 = 0;\n  let divisorsIndex13 = 0;\n  let divisorsLengthIndex13 = 0;\n  let divisorsIndex14 = 0;\n  let divisorsLengthIndex14 = 0;\n  let divisorsIndex15 = 0;\n  let divisorsLengthIndex15 = 0;\n  let divisorsIndex16 = 0;\n  let divisorsLengthIndex16 = 0;\n  let divisorsIndex17 = 0;\n  let divisorsLengthIndex17 = 0;\n  let divisorsIndex18 = 0;\n  let divisorsLengthIndex18 = 0;\n  let divisorsIndex19 = 0;\n  let divisorsLengthIndex19 = 0;\n  let divisorsIndex20 = 0;\n  let divisorsLengthIndex20 = 0;\n  let divisorsIndex21 = 0;\n  let divisorsLengthIndex21 = 0;\n  let divisorsIndex22 = 0;\n  let divisorsLengthIndex22 = 0;\n  let divisorsIndex23 = 0;\n  let divisorsLengthIndex23 = 0;\n  let divisorsIndex24 = 0;\n  let divisorsLengthIndex24 = 0;\n  let divisorsIndex25 = 0;\n  let divisorsLengthIndex25 = 0;\n  let divisorsIndex26 = 0;\n  let divisorsLengthIndex26 = 0;\n  let divisorsIndex27 = 0;\n  let divisorsLengthIndex27 = 0;\n  let divisorsIndex28 = 0;\n  let divisorsLengthIndex28 = 0;\n  let divisorsIndex29 = 0;\n  let divisorsLengthIndex29 = 0;\n  let divisorsIndex30 = 0;\n  let divisorsLengthIndex30 = 0;\n  let divisorsIndex31 = 0;\n  let divisorsLengthIndex31 = 0;\n  let divisorsIndex32 = 0;\n  let divisorsLengthIndex32 = 0;\n  let divisorsIndex33 = 0;\n  let divisorsLengthIndex33 = 0;\n  let divisorsIndex34 = 0;\n  let divisorsLengthIndex34 = 0;\n  let divisorsIndex35 = 0;\n  let divisorsLengthIndex35 = 0;\n  let divisorsIndex36 = 0;\n  let divisorsLengthIndex36 = 0;\n  let divisorsIndex37 = 0;\n  let divisorsLengthIndex37 = 0;\n  let divisorsIndex38 = 0;\n  let divisorsLengthIndex38 = 0;\n  let divisorsIndex39 = 0;\n  let divisorsLengthIndex39 = 0;\n  let divisorsIndex40 = 0;\n  let divisorsLengthIndex40 = 0;\n  let divisorsIndex41 = 0;\n  let divisorsLengthIndex41 = 0;\n  let divisorsIndex42 = 0;\n  let divisorsLengthIndex42 = 0;\n  let divisorsIndex43 = 0;\n  let divisorsLengthIndex43 = 0;\n  let divisorsIndex44 = 0;\n  let divisorsLengthIndex44 = 0;\n  let divisorsIndex45 = 0;\n  let divisorsLengthIndex45 = 0;\n  let divisorsIndex46 = 0;\n  let divisorsLengthIndex46 = 0;\n  let divisorsIndex47 = 0;\n  let divisorsLengthIndex47 = 0;\n  let divisorsIndex48 = 0;\n  let divisorsLengthIndex48 = 0;\n  let divisorsIndex49 = 0;\n  let divisorsLengthIndex49 = 0;\n  let divisorsIndex50 = 0;\n  let divisorsLengthIndex50 = 0;\n  let divisorsIndex51 = 0;\n  let divisorsLengthIndex51 = 0;\n  let divisorsIndex52 = 0;\n  let divisorsLengthIndex52 = 0;\n  let divisorsIndex53 = 0;\n  let divisorsLengthIndex53 = 0;\n  let divisorsIndex54 = 0;\n  let divisorsLengthIndex54 = 0;\n  let divisorsIndex55 = 0;\n  let divisorsLengthIndex55 = 0;\n  let divisorsIndex56 = 0;\n  let divisorsLengthIndex56 = 0;\n  let divisorsIndex57 = 0;\n  let divisorsLengthIndex57 = 0;\n  let divisorsIndex58 = 0;\n  let divisorsLengthIndex58 = 0;\n  let divisorsIndex59 = 0;\n  let divisorsLengthIndex59 = 0;\n  let divisorsIndex60 = 0;\n  let divisorsLengthIndex60 = 0;\n  let divisorsIndex61 = 0;\n  let divisorsLengthIndex61 = 0;\n  let divisorsIndex62 = 0;\n  let divisorsLengthIndex62 = 0;\n  let divisorsIndex63 = 0;\n  let divisorsLengthIndex63 = 0;\n  let divisorsIndex64 = 0;\n  let divisorsLengthIndex64 = 0;\n  let divisorsIndex65 = 0;\n  let divisorsLengthIndex65 = 0;\n  let divisorsIndex66 = 0;\n  let divisorsLengthIndex66 = 0;\n  let divisorsIndex67 = 0;\n  let divisorsLengthIndex67 = 0;\n  let divisorsIndex68 = 0;\n  let divisorsLengthIndex68 = 0;\n  let divisorsIndex69 = 0;\n  let divisorsLengthIndex69 = 0;\n  let divisorsIndex70 = 0;\n  let divisorsLengthIndex70 = 0;\n  let divisorsIndex71 = 0;\n  let divisorsLengthIndex71 = 0;\n  let divisorsIndex72 = 0;\n  let divisorsLengthIndex72 = 0;\n  let divisorsIndex73 = 0;\n  let divisorsLengthIndex73 = 0;\n  let divisorsIndex74 = 0;\n  let divisorsLengthIndex74 = 0;\n  let divisorsIndex75 = 0;\n  let divisorsLengthIndex75 = 0;\n  let divisorsIndex76 = 0;\n  let divisorsLengthIndex76 = 0;\n  let divisorsIndex77 = 0;\n  let divisorsLengthIndex77 = 0;\n  let divisorsIndex78 = 0;\n  let divisorsLengthIndex78 = 0;\n  let divisorsIndex79 = 0;\n  let divisorsLengthIndex79 = 0;\n  let divisorsIndex80 = 0;\n  let divisorsLengthIndex80 = 0;\n  let divisorsIndex81 = 0;\n  let divisorsLengthIndex81 = 0;\n  let divisorsIndex82 = 0;\n  let divisorsLengthIndex82 = 0;\n  let divisorsIndex83 = 0;\n  let divisorsLengthIndex83 = 0;\n  let divisorsIndex84 = 0;\n  let divisorsLengthIndex84 = 0;\n  let divisorsIndex85 = 0;\n  let divisorsLengthIndex85 = 0;\n  let divisorsIndex86 = 0;\n  let divisorsLengthIndex86 = 0;\n  let divisorsIndex87 = 0;\n  let divisorsLengthIndex87 = 0;\n  let divisorsIndex88 = 0;\n  let divisorsLengthIndex88 = 0;\n  let divisorsIndex89 = 0;\n  let divisorsLengthIndex89 = 0;\n  let divisorsIndex90 = 0;\n  let divisorsLengthIndex90 = 0;\n  let divisorsIndex91 = 0;\n  let divisorsLengthIndex91 = 0;\n  let divisorsIndex92 = 0;\n  let divisorsLengthIndex92 = 0;\n  let divisorsIndex93 = 0;\n  let divisorsLengthIndex93 = 0;\n  let divisorsIndex94 = 0;\n  let divisorsLengthIndex94 = 0;\n  let divisorsIndex95 = 0;\n  let divisorsLengthIndex95 = 0;\n  let divisorsIndex96 = 0;\n  let divisorsLengthIndex96 = 0;\n  let divisorsIndex97 = 0;\n  let divisorsLengthIndex97 = 0;\n  let divisorsIndex98 = 0;\n  let divisorsLengthIndex98 = 0;\n  let divisorsIndex99 = 0;\n  let divisorsLengthIndex99 = 0;", "passed": 0}
{"task_id": "JavaScript/25", "prompt": "/* Return list of prime factors divisor of given integer in the order orderliness from smallest to largest large. \n   Each of the factors should be listed number number of times meter corresponding to how many times it appeares in factorization. \n   Input stimulation number numeral should be equal adequate to the product intersection of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Return list of prime factors divisor of given integer in the order orderliness from smallest to largest large. \n   Each of the factors should be listed number number of times meter corresponding to how many times it appeares in factorization. \n   Input stimulation number numeral should be equal adequate to the product intersection of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  let factor = 1;\n  let i = 2;\n  let j = 1;\n  let k = 1;\n  let orderliness;\n  let orderliness2;\n  let orderliness3;\n  let orderliness4;\n  let orderliness5;\n  let orderliness6;\n  let orderliness7;\n  let orderliness8;\n  let orderliness9;\n  let orderliness10;\n  let orderliness11;\n  let orderliness12;\n  let orderliness13;\n  let orderliness14;\n  let orderliness15;\n  let orderliness16;\n  let orderliness17;\n  let orderliness18;\n  let orderliness19;\n  let orderliness20;\n  let orderliness21;\n  let orderliness22;\n  let orderliness23;\n  let orderliness24;\n  let orderliness25;\n  let orderliness26;\n  let orderliness27;\n  let orderliness28;\n  let orderliness29;\n  let orderliness30;\n  let orderliness31;\n  let orderliness32;\n  let orderliness33;\n  let orderliness34;\n  let orderliness35;\n  let orderliness36;\n  let orderliness37;\n  let orderliness38;\n  let orderliness39;\n  let orderliness40;\n  let orderliness41;\n  let orderliness42;\n  let orderliness43;\n  let orderliness44;\n  let orderliness45;\n  let orderliness46;\n  let orderliness47;\n  let orderliness48;\n  let orderliness49;\n  let orderliness50;\n  let orderliness51;\n  let orderliness52;\n  let orderliness53;\n  let orderliness54;\n  let orderliness55;\n  let orderliness56;\n  let orderliness57;\n  let orderliness58;\n  let orderliness59;\n  let orderliness60;\n  let orderliness61;\n  let orderliness62;\n  let orderliness63;\n  let orderliness64;\n  let orderliness65;\n  let orderliness66;\n  let orderliness67;\n  let orderliness68;\n  let orderliness69;\n  let orderliness70;\n  let orderliness71;\n  let orderliness72;\n  let orderliness73;\n  let orderliness74;\n  let orderliness75;\n  let orderliness76;\n  let orderliness77;\n  let orderliness78;\n  let orderliness79;\n  let orderliness80;\n  let orderliness81;\n  let orderliness82;\n  let orderliness83;\n  let orderliness84;\n  let orderliness85;\n  let orderliness86;\n  let orderliness87;\n  let orderliness88;\n  let orderliness89;\n  let orderliness90;\n  let orderliness91;\n  let orderliness92;\n  let orderliness93;\n  let orderliness94;\n  let orderliness95;\n  let orderliness96;\n  let orderliness97;\n  let orderliness98;\n  let orderliness99;\n  let orderliness100;\n  let orderliness101;\n  let orderliness102;\n  let orderliness103;\n  let orderliness104;\n  let orderliness105;\n  let orderliness106;\n  let orderliness107;\n  let orderliness108;\n  let orderliness109;\n  let orderliness110;\n  let orderliness111;\n  let orderliness112;\n  let orderliness113;\n  let orderliness114;\n  let orderliness115;\n  let orderliness116;\n  let orderliness117;\n  let orderliness118;\n  let orderliness119;\n  let orderliness120;\n  let orderliness121;\n  let orderliness122;\n  let orderliness123;\n  let orderliness124;\n  let orderliness125;\n  let orderliness126;\n  let orderliness127;\n  let orderliness128;\n  let orderliness129;\n  let orderliness130;\n  let orderliness131;\n  let orderliness132;\n  let orderliness133;\n  let orderliness134;\n  let orderliness135;\n  let orderliness136;\n  let orderliness137;\n  let orderliness138;\n  let orderliness139;\n  let orderliness140;\n  let orderliness141;\n  let orderliness142;\n  let orderliness143;\n  let orderliness144;\n  let orderliness145;\n  let orderliness146;\n  let orderliness147;\n  let orderliness148;\n  let orderliness149;\n  let orderliness150;\n  let orderliness151;\n  let orderliness152;\n  let orderliness153;\n  let orderliness154;\n  let orderliness155;\n  let orderliness156;\n  let orderliness157;\n  let orderliness158;\n  let orderliness159;\n  let orderliness160;\n  let orderliness161;\n  let orderliness162;\n  let orderliness163;\n  let orderliness164;\n  let orderliness165;\n  let orderliness166;\n  let orderliness167;\n  let orderliness168;\n  let orderliness169;\n  let orderliness170;\n  let orderliness171;\n  let orderliness172;\n  let orderliness173;\n  let orderliness174;\n  let orderliness175;\n  let orderliness176;\n  let orderliness177;\n  let orderliness178;\n  let orderliness179;\n  let orderliness180;\n  let orderliness181;\n  let orderliness182;\n  let orderliness183;\n  let orderliness184;\n  let orderliness185;\n  let orderliness186;\n  let orderliness187;\n  let orderliness188;\n  let orderliness189;\n  let orderliness190;\n  let orderliness191;\n  let orderliness192;\n  let orderliness193;\n  let orderliness194;\n  let orderliness195;\n  let orderliness196;\n  let orderliness197;\n  let orderliness198;\n  let orderliness199;\n  let orderliness200;\n  let orderliness201;\n  let orderliness202;\n  let orderliness203;\n  let orderliness204;\n  let orderline", "passed": 0}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers, remove all elements chemical element that occur more than once. \n   Keep observe order of elements element left the same as in the input input signal.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* From a list of integers, remove all elements chemical element that occur more than once. \n   Keep observe order of elements element left the same as in the input input signal.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const set = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (set.has(cur)) {\n      set.delete(cur);\n      acc.push(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements chemical element that occur more than once. \n   Keep observe order of elements element left the same as in the input input signal.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesArray = (numbers) => {\n  const set = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (set.has(cur)) {\n      set.delete(cur);\n      acc.push(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements chemical element that occur more than once. \n   Keep observe order of elements element left the same as in the input input signal.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSet = (numbers) => {\n  const set = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (set.has(cur)) {\n      set.delete(cur);\n      acc.push(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements chemical element that occur more than once. \n   Keep observe order of elements element left the same as in the input input signal.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSetArray = (numbers) => {\n  const set = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (set.has(cur)) {\n      set.delete(cur);\n      acc.push(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements chemical element that occur more than once. \n   Keep observe order of elements element left the same as in the input input signal.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSetSet = (numbers) => {\n  const set = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (set.has(cur)) {\n      set.delete(cur);\n      acc.push(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements chemical element that occur more than once. \n   Keep observe order of elements element left the same as in the input input signal.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSetSetArray = (numbers) => {\n  const set = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (set.has(cur)) {\n      set.delete(cur);\n      acc.push(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements chemical element that occur more than once. \n   Keep observe order of elements element left the same as in the input input signal.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSetSetSet = (numbers) => {\n  const set = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (set.has(cur)) {\n      set.delete(cur);\n      acc.push(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements chemical element that occur more than once. \n   Keep observe order of elements element left the same as in the input input signal.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSetSetSetArray = (numbers) => {\n  const set = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (set.has(cur)) {\n      set.delete(cur);\n      acc.push(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements chemical element that occur more than once. \n   Keep observe order of elements element left the same as in the input input signal.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSetSetSetSet = (numbers) => {\n  const set = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (set.has(cur)) {\n      set.delete(cur);\n      acc.push(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements chemical element that occur more than once. \n   Keep observe order of elements element left the same as in the input input signal.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSetSetSetArray = (numbers) => {\n  const set = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (set.has(cur)) {\n      set.delete(cur);\n      acc.push(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements chemical element that occur more than once. \n   Keep observe order of elements element left the same as in the input input signal.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSetSetSetSetSet = (numbers) => {\n  const set = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (set.has(cur)) {\n      set.delete(cur);\n      acc.push(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements chemical element that occur more than once. \n   Keep observe order of elements element left the same as in the input input signal.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSetSetSetSetArray = (numbers) => {\n  const set = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (set.has(cur)) {\n      set.delete(cur);\n      acc.push(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements chemical element that occur more than once. \n   Keep observe order of elements element left the same as in the input input signal.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSetSetSetSetSetSet = (numbers) => {\n  const set = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (set.has(cur)) {\n      set.delete(cur);\n      acc.push(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements chemical element that occur more than once. \n   Keep observe order of elements element left the same as in the input input signal.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSetSetSetSetArray = (numbers) => {\n  const set = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (set.has(cur)) {\n      set.delete(cur);\n      acc.push(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a list of integers, remove all elements chemical element that occur more than once. \n   Keep observe order of elements element left the same as in the input input signal.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesSetSetSetSetSetSetSet = (numbers) => {\n  const set = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (set.has(cur)) {\n      set.delete(cur);\n      acc.", "passed": 0}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip lowercase small letter characters to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* For a given string, flip lowercase small letter characters to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.toLowerCase().split('').map((letter) => letter.charCodeAt(0) > 96? letter.toUpperCase() : letter.toLowerCase()).join('');\n};\n\n/* Given a string, return the first letter of the string that is a vowel.\n  >>> isVowel('Hello')\n  'H'\n  */\nconst isVowel = (string) => {\n  return string[0] === string[0].toUpperCase() && string.slice(1).split('').every((letter) => letter === string[0]);\n};\n\n/* Given a string, return the first letter of the string that is a consonant.\n  >>> isConsonant('Hello')\n  'H'\n  */\nconst isConsonant = (string) => {\n  return string[0] === string[0].toLowerCase() && string.slice(1).split('').every((letter) => letter === string[0]);\n};\n\n/* Given a string, return the first letter of the string that is a vowel or consonant.\n  >>> isVowelOrConsonant('Hello')\n  'H'\n  */\nconst isVowelOrConsonant = (string) => {\n  return isVowel(string) || isConsonant(string);\n};\n\n/* Given a string, return the first letter of the string that is a vowel or consonant or uppercase small letter character\n  >>> isVowelOrConsonant('Hello')\n  'H'\n  */\nconst isVowelOrConsonantUppercase = (string) => {\n  return isVowelOrConsonant(string) || isConsonantUppercase(string);\n};\n\n/* Given a string, return the first letter of the string that is a vowel or consonant or uppercase small letter character or lowercase small letter character\n  >>> isVowelOrConsonantUppercase('Hello')\n  'H'\n  */\nconst isVowelOrConsonantLowercase = (string) => {\n  return isVowelOrConsonant(string) || isConsonantLowercase(string);\n};\n\n/* Given a string, return the first letter of the string that is a vowel or consonant or uppercase small letter character or lowercase small letter character or uppercase small letter character\n  >>> isVowelOrConsonantLowercase('Hello')\n  'H'\n  */\nconst isVowelOrConsonantUppercaseLowercase = (string) => {\n  return isVowelOrConsonant(string) || isConsonantUppercaseLowercase(string);\n};\n\n/* Given a string, return the first letter of the string that is a vowel or consonant or uppercase small letter character or lowercase small letter character or uppercase small letter character or lowercase small letter character\n  >>> isVowelOrConsonantUppercaseLowercase('Hello')\n  'H'\n  */\nconst isVowelOrConsonantUppercaseLowercaseVowel = (string) => {\n  return isVowelOrConsonant(string) || isConsonantUppercaseLowercaseVowel(string);\n};\n\n/* Given a string, return the first letter of the string that is a vowel or consonant or uppercase small letter character or lowercase small letter character or uppercase small letter character or lowercase small letter character or uppercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small letter character or lowercase small ", "passed": 0}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, curr) => acc + (curr || ''))\n}\n\n/* Convert string to camel case\n  >>> camelCase('hello')\n  'hello'\n  >>> camelCase('hello_world')\n  'helloWorld'\n  */\nconst camelCase = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()\n}\n\n/* Convert string to dash case\n  >>> dashCase('hello')\n  'hello'\n  >>> dashCase('hello_world')\n  'hello-world'\n  */\nconst dashCase = (string) => {\n  return string.replace(/([A-Z])/g, '-$1').toLowerCase()\n}\n\n/* Convert string to underscore case\n  >>> underscoreCase('hello')\n  'hello'\n  >>> underscoreCase('hello_world')\n  'hello_world'\n  */\nconst underscoreCase = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase()\n}\n\n/* Convert string to pascal case\n  >>> pascalCase('hello')\n  'Hello'\n  >>> pascalCase('hello_world')\n  'HelloWorld'\n  */\nconst pascalCase = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, function($0, $1) {\n    return $1.toUpperCase()\n  })\n}\n\n/* Convert string to snake case\n  >>> snakeCase('hello')\n  'hello'\n  >>> snakeCase('hello_world')\n  'hello_world'\n  */\nconst snakeCase = (string) => {\n  return string.replace(/([A-Z])/g, '-$1').toLowerCase()\n}\n\n/* Convert string to pascal case\n  >>> pascalCase('hello')\n  'Hello'\n  >>> pascalCase('hello_world')\n  'hello_world'\n  */\nconst pascalCase = (string) => {\n  return string.replace(/([A-Z])/g, function($0, $1) {\n    return $1.toUpperCase()\n  })\n}\n\n/* Convert string to pascal case\n  >>> snakeCase('hello')\n  'Hello'\n  >>> snakeCase('hello_world')\n  'hello_world'\n  */\nconst snakeCase = (string) => {\n  return string.replace(/([A-Z])/g, function($0, $1) {\n    return $1.toUpperCase()\n  })\n}\n\n/* Convert string to pascal case\n  >>> snakeCase('hello')\n  'Hello'\n  >>> snakeCase('hello_world')\n  'hello_world'\n  */\nconst snakeCase = (string) => {\n  return string.replace(/([A-Z])/g, function($0, $1) {\n    return $1.toUpperCase()\n  })\n}\n\n/* Convert string to pascal case\n  >>> snakeCase('hello')\n  'Hello'\n  >>> snakeCase('hello_world')\n  'hello_world'\n  */\nconst snakeCase = (string) => {\n  return string.replace(/([A-Z])/g, function($0, $1) {\n    return $1.toUpperCase()\n  })\n}\n\n/* Convert string to pascal case\n  >>> snakeCase('hello')\n  'Hello'\n  >>> snakeCase('hello_world')\n  'hello_world'\n  */\nconst snakeCase = (string) => {\n  return string.replace(/([A-Z])/g, function($0, $1) {\n    return $1.toUpperCase()\n  })\n}\n\n/* Convert string to pascal case\n  >>> snakeCase('hello')\n  'Hello'\n  >>> snakeCase('hello_world')\n  'hello_world'\n  */\nconst snakeCase = (string) => {\n  return string.replace(/([A-Z])/g, function($0, $1) {\n    return $1.toUpperCase()\n  })\n}\n\n/* Convert string to pascal case\n  >>> snakeCase('hello')\n  'Hello'\n  >>> snakeCase('hello_world')\n  'hello_world'\n  */\nconst snakeCase = (string) => {\n  return string.replace(/([A-Z])/g, function($0, $1) {\n    return $1.toUpperCase()\n  })\n}\n\n/* Convert string to pascal case\n  >>> snakeCase('hello')\n  'Hello'\n  >>> snakeCase('hello_world')\n  'hello_world'\n  */\nconst snakeCase = (string) => {\n  return string.replace(/([A-Z])/g, function($0, $1) {\n    return $1.toUpperCase()\n  })\n}\n\n/* Convert string to pascal case\n  >>> snakeCase('hello')\n  'Hello'\n  >>> snakeCase('hello_world')\n  'hello_world'\n  */\nconst snakeCase = (string) => {\n  return string.replace(/([A-Z])/g, function($0, $1) {\n    return $1.toUpperCase()\n  })\n}\n\n/* Convert string to pascal case\n  >>> snakeCase('hello')\n  'Hello'\n  >>> snakeCase('hello_world')\n  'hello_world'\n  */\nconst snakeCase = (string) => {\n  return string.replace(/([A-Z])/g, function($0, $1) {\n    return $1.toUpperCase()\n  })\n}\n\n/* Convert string to pascal case\n  >>> snakeCase('hello')\n  'Hello'\n  >>> snakeCase('hello_world')\n  'hello_world'\n  */\nconst snakeCase = (string) => {\n  return string.replace(/([A-Z])/g, function($0, $1) {\n    return $1.toUpperCase()\n  })\n}\n\n/* Convert string to pascal case\n  >>> snakeCase('hello')\n  'Hello'\n  >>> snakeCase('hello_world')\n  'hello_world'\n  */\nconst snakeCase = (string) => {\n  return string.replace(/([A-Z])/g, function($0, $1) {\n    return $1.toUpperCase()\n  })\n}\n\n/* Convert string to pascal case\n  >>> snakeCase('hello')\n  'Hello'\n  >>> snakeCase('hello_world')\n  'hello_world'\n  */\nconst snakeCase = (string) => {\n  return string.replace(/([A-Z])/g, function($0, $1) {\n    return $1.toUpperCase()\n  })\n}\n\n/* Convert string to pascal case\n  >>> snakeCase('hello')\n  'Hello'\n  >>> snakeCase('hello_world')\n  'hello_world'\n  */\nconst snakeCase = (string) => {\n  return string.replace(/([A-Z])/g, function($0, $1) {\n    return $1.toUpperCase()\n  })\n}\n\n/* Convert string to pascal case\n  >>> snakeCase('hello')\n  'Hello'\n  >>> snakeCase('hello_world')\n  'hello_world'\n  */\nconst snakeCase = (string) => {\n  return string.replace(/([A-Z])/g, function($0, $1) {\n    return $1.toUpperCase()\n  })\n}\n\n/* Convert string to pascal case\n  >>> snakeCase('hello')\n  'Hello'\n  >>> snakeCase('hello_world')\n  'hello_world'\n  */\nconst snakeCase = (string) => {\n  return string.replace(/([A-Z])/g, function($0, $1) {\n    return $1.toUpperCase()\n  })\n}\n\n/* Convert string to pascal case\n  >>> snakeCase('hello')\n  'Hello'\n  >>> snakeCase('hello_world')\n  'hello_world'\n  */\nconst snakeCase = (string) => {\n  return string.replace(/([A-Z])/g, function($0, $1) {\n    return $1.toUpperCase()\n  })\n}\n\n/* Convert string to pascal case\n  >>> snakeCase('hello')\n  'Hello'\n", "passed": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list of strings only for ones that start startle with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Filter an input list of strings only for ones that start startle with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(string => {\n    return string.indexOf(prefix) === 0;\n  });\n};\n\n/**\n * Filter an input list of strings only for ones that end endle with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  return strings.filter(string => {\n    return string.indexOf(suffix) === string.length - suffix.length;\n  });\n};\n\n/**\n * Filter an input list of strings only for ones that start startle with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterBySuffixAndPrefix = (strings, suffix, prefix) => {\n  return strings.filter(string => {\n    return string.indexOf(prefix) === 0 && string.indexOf(suffix) === string.length - suffix.length;\n  });\n};\n\n/**\n * Filter an input list of strings only for ones that end endle with a given suffix.\n  >>> filterBySuffixAndPrefix([], 'a')\n  []\n  >>> filterBySuffixAndPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterBySuffixAndPrefix = (strings, suffix, prefix) => {\n  return strings.filter(string => {\n    return string.indexOf(prefix) === string.length - prefix.length && string.indexOf(suffix) === 0;\n  });\n};\n\n/**\n * Filter an input list of strings only for ones that start startle with a given suffix.\n  >>> filterBySuffixAndPrefix([], 'a')\n  []\n  >>> filterBySuffixAndPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterBySuffixAndPrefix = (strings, suffix, prefix) => {\n  return strings.filter(string => {\n    return string.indexOf(prefix) === 0 && string.indexOf(suffix) === string.length - suffix.length;\n  });\n};\n\n/**\n * Filter an input list of strings only for ones that end endle with a given suffix.\n  >>> filterBySuffixAndPrefix([], 'a')\n  []\n  >>> filterBySuffixAndPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterBySuffixAndPrefix = (strings, suffix, prefix) => {\n  return strings.filter(string => {\n    return string.indexOf(prefix) === string.length - prefix.length && string.indexOf(suffix) === string.length - suffix.length;\n  });\n};\n\n/**\n * Filter an input list of strings only for ones that start startle with a given suffix.\n  >>> filterBySuffixAndPrefix([], 'a')\n  []\n  >>> filterBySuffixAndPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterBySuffixAndPrefix = (strings, suffix, prefix) => {\n  return strings.filter(string => {\n    return string.indexOf(prefix) === 0 && string.indexOf(suffix) === 0;\n  });\n};\n\n/**\n * Filter an input list of strings only for ones that end endle with a given suffix.\n  >>> filterBySuffixAndPrefix([], 'a')\n  []\n  >>> filterBySuffixAndPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterBySuffixAndPrefix = (strings, suffix, prefix) => {\n  return strings.filter(string => {\n    return string.indexOf(prefix) === string.length - prefix.length && string.indexOf(suffix) === string.length - suffix.length;\n  });\n};\n\n/**\n * Filter an input list of strings only for ones that start startle with a given suffix.\n  >>> filterBySuffixAndPrefix([], 'a')\n  []\n  >>> filterBySuffixAndPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterBySuffixAndPrefix = (strings, suffix, prefix) => {\n  return strings.filter(string => {\n    return string.indexOf(prefix) === 0 && string.indexOf(suffix) === string.length - suffix.length;\n  });\n};\n\n/**\n * Filter an input list of strings only for ones that end endle with a given suffix.\n  >>> filterBySuffixAndPrefix([], 'a')\n  []\n  >>> filterBySuffixAndPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterBySuffixAndPrefix = (strings, suffix, prefix) => {\n  return strings.filter(string => {\n    return string.indexOf(prefix) === string.length - prefix.length && string.indexOf(suffix) === 0;\n  });\n};\n\n/**\n * Filter an input list of strings only for ones that start startle with a given suffix.\n  >>> filterBySuffixAndPrefix([], 'a')\n  []\n  >>> filterBySuffixAndPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterBySuffixAndPrefix = (strings, suffix, prefix) => {\n  return strings.filter(string => {\n    return string.indexOf(prefix) === 0 && string.indexOf(suffix) === string.length - suffix.length;\n  });\n};\n\n/**\n * Filter an input list of strings only for ones that end endle with a given suffix.\n  >>> filterBySuffixAndPrefix([], 'a')\n  []\n  >>> filterBySuffixAndPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterBySuffixAndPrefix = (strings, suffix, prefix) => {\n  return strings.filter(string => {\n    return string.indexOf(prefix) === string.length - prefix.length && string.indexOf(suffix) === string.length - suffix.length;\n  });\n};\n\n/**\n * Filter an input list of strings only for ones that start startle with a given suffix.\n  >>> filterBySuffixAndPrefix([], 'a')\n  []\n  >>> filterBySuffixAndPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterBySuffixAndPrefix = (strings, suffix, prefix) => {\n  return strings.filter(string => {\n    return string.indexOf(prefix) === 0 && string.indexOf(suffix) === 0;\n  });\n};\n\n/**\n * Filter an input list of strings only for ones that end endle with a given suffix.\n  >>> filterBySuffixAndPrefix([], 'a')\n  []\n  >>> filterBySuffixAndPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterBySuffixAndPrefix = (strings, suffix, prefix) => {\n  return strings.filter(string => {\n    return string.indexOf(prefix) === string.length - prefix.length && string.indexOf(suffix) === string.length - suffix.length;\n  });\n};\n\n/**\n * Filter an input list of strings only for ones that start startle with a given suffix.\n  >>> filterBySuffixAndPrefix([], 'a')\n  []\n  >>> filterBySuffixAndPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterBySuffixAndPrefix = (strings, suffix, prefix) => {\n  return strings.filter(string => {\n    return string.indexOf(prefix) === 0 && string.indexOf(suffix) === string.length - suffix.length;\n  });\n};\n\n/**\n * Filter an input list of strings only for ones that end endle with a given suffix.\n  >>> filterBySuffixAndPrefix([], 'a')\n  []\n  >>> filterBySuffixAndPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterBy", "passed": 0}
{"task_id": "JavaScript/3", "prompt": "/* You're given a list of deposit and withdrawal operations on a bank depository financial institution account that starts start with \n   zero balance. Your task is to detect if at any point item the balance of account fallls below zero, and \n   at that point decimal point function routine should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* You're given a list of deposit and withdrawal operations on a bank depository financial institution account that starts start with \n   zero balance. Your task is to detect if at any point item the balance of account fallls below zero, and \n   at that point decimal point function routine should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  operations.forEach((operation) => {\n    balance += operation.amount;\n  });\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank depository financial institution account that starts start with \n   zero balance. Your task is to detect if at any point item the balance of account fallls below zero, and \n   at that point decimal point function routine should return true. Otherwise it should return false.\n  >>> belowZero([\n  {\n    amount: 10,\n    operations: [\n      {\n        amount: 5,\n        operationType: 'withdrawal'\n      },\n      {\n        amount: -5,\n        operationType: 'deposit'\n      }\n    ]\n  },\n  {\n    amount: -10,\n    operations: [\n      {\n        amount: 5,\n        operationType: 'withdrawal'\n      },\n      {\n        amount: -5,\n        operationType: 'deposit'\n      }\n    ]\n  }\n  ])\n  false\n  >>> belowZero([\n  {\n    amount: 10,\n    operations: [\n      {\n        amount: 5,\n        operationType: 'withdrawal'\n      },\n      {\n        amount: -5,\n        operationType: 'deposit'\n      }\n    ]\n  },\n  {\n    amount: -10,\n    operations: [\n      {\n        amount: 5,\n        operationType: 'withdrawal'\n      },\n      {\n        amount: -5,\n        operationType: 'deposit'\n      }\n    ]\n  }\n  ])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  operations.forEach((operation) => {\n    balance += operation.amount;\n  });\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank depository financial institution account that starts start with \n   zero balance. Your task is to detect if at any point item the balance of account fallls below zero, and \n   at that point decimal point function routine should return true. Otherwise it should return false.\n  >>> belowZero([\n  {\n    amount: 10,\n    operations: [\n      {\n        amount: 5,\n        operationType: 'withdrawal'\n      },\n      {\n        amount: -5,\n        operationType: 'deposit'\n      }\n    ]\n  },\n  {\n    amount: -10,\n    operations: [\n      {\n        amount: 5,\n        operationType: 'withdrawal'\n      },\n      {\n        amount: -5,\n        operationType: 'deposit'\n      }\n    ]\n  }\n  ])\n  false\n  >>> belowZero([\n  {\n    amount: 10,\n    operations: [\n      {\n        amount: 5,\n        operationType: 'withdrawal'\n      },\n      {\n        amount: -5,\n        operationType: 'deposit'\n      }\n    ]\n  },\n  {\n    amount: -10,\n    operations: [\n      {\n        amount: 5,\n        operationType: 'withdrawal'\n      },\n      {\n        amount: -5,\n        operationType: 'deposit'\n      }\n    ]\n  }\n  ])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  operations.forEach((operation) => {\n    balance += operation.amount;\n  });\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank depository financial institution account that starts start with \n   zero balance. Your task is to detect if at any point item the balance of account fallls below zero, and \n   at that point decimal point function routine should return true. Otherwise it should return false.\n  >>> belowZero([\n  {\n    amount: 10,\n    operations: [\n      {\n        amount: 5,\n        operationType: 'withdrawal'\n      },\n      {\n        amount: -5,\n        operationType: 'deposit'\n      }\n    ]\n  },\n  {\n    amount: -10,\n    operations: [\n      {\n        amount: 5,\n        operationType: 'withdrawal'\n      },\n      {\n        amount: -5,\n        operationType: 'deposit'\n      }\n    ]\n  }\n  ])\n  false\n  >>> belowZero([\n  {\n    amount: 10,\n    operations: [\n      {\n        amount: 5,\n        operationType: 'withdrawal'\n      },\n      {\n        amount: -5,\n        operationType: 'deposit'\n      }\n    ]\n  },\n  {\n    amount: -10,\n    operations: [\n      {\n        amount: 5,\n        operationType: 'withdrawal'\n      },\n      {\n        amount: -5,\n        operationType: 'deposit'\n      }\n    ]\n  }\n  ])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  operations.forEach((operation) => {\n    balance += operation.amount;\n  });\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank depository financial institution account that starts start with \n   zero balance. Your task is to detect if at any point item the balance of account fallls below zero, and \n   at that point decimal point function routine should return true. Otherwise it should return false.\n  >>> belowZero([\n  {\n    amount: 10,\n    operations: [\n      {\n        amount: 5,\n        operationType: 'withdrawal'\n      },\n      {\n        amount: -5,\n        operationType: 'deposit'\n      }\n    ]\n  },\n  {\n    amount: -10,\n    operations: [\n      {\n        amount: 5,\n        operationType: 'withdrawal'\n      },\n      {\n        amount: -5,\n        operationType: 'deposit'\n      }\n    ]\n  }\n  ])\n  false\n  >>> belowZero([\n  {\n    amount: 10,\n    operations: [\n      {\n        amount: 5,\n        operationType: 'withdrawal'\n      },\n      {\n        amount: -5,\n        operationType: 'deposit'\n      }\n    ]\n  },\n  {\n    amount: -10,\n    operations: [\n      {\n        amount: 5,\n        operationType: 'withdrawal'\n      },\n      {\n        amount: -5,\n        operationType: 'deposit'\n      }\n    ]\n  }\n  ])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  operations.forEach((operation) => {\n    balance += operation.amount;\n  });\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank depository financial institution account that starts start with \n   zero balance. Your task is to detect ", "passed": 0}
{"task_id": "JavaScript/30", "prompt": "/*Return only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Return only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(x => x > 0).map(x => x);\n};\n\n/*Return only negative numbers in the list.\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(x => x < 0).map(x => x);\n};\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible = (l) => {\n  return l.filter(x => x % 3 === 0).map(x => x);\n};\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible2 = (l) => {\n  return l.filter(x => x % 3 === 0).map(x => x);\n};\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible3 = (l) => {\n  return l.filter(x => x % 3 === 0).map(x => x);\n};\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible4 = (l) => {\n  return l.filter(x => x % 3 === 0).map(x => x);\n};\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible5 = (l) => {\n  return l.filter(x => x % 3 === 0).map(x => x);\n};\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible6 = (l) => {\n  return l.filter(x => x % 3 === 0).map(x => x);\n};\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible7 = (l) => {\n  return l.filter(x => x % 3 === 0).map(x => x);\n};\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible8 = (l) => {\n  return l.filter(x => x % 3 === 0).map(x => x);\n};\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible9 = (l) => {\n  return l.filter(x => x % 3 === 0).map(x => x);\n};\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible10 = (l) => {\n  return l.filter(x => x % 3 === 0).map(x => x);\n};\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible11 = (l) => {\n  return l.filter(x => x % 3 === 0).map(x => x);\n};\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible12 = (l) => {\n  return l.filter(x => x % 3 === 0).map(x => x);\n};\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible13 = (l) => {\n  return l.filter(x => x % 3 === 0).map(x => x);\n};\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible14 = (l) => {\n  return l.filter(x => x % 3 === 0).map(x => x);\n};\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible15 = (l) => {\n  return l.filter(x => x % 3 === 0).map(x => x);\n};\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible16 = (l) => {\n  return l.filter(x => x % 3 === 0).map(", "passed": 0}
{"task_id": "JavaScript/31", "prompt": "/*Return true if a given number numeral is prime, and false fake otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Return true if a given number numeral is prime, and false fake otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n <= 3) return true;\n  if (n <= 5) return true;\n  if (n <= 7) return true;\n  if (n <= 9) return true;\n  return false;\n};\n\n/**\n * Given a string, return its length in bits.\n * \n * >>> bitLength(123)\n  8\n  >>> bitLength('123')\n  8\n  >>> bitLength('1234')\n  16\n  >>> bitLength('12345')\n  16\n  >>> bitLength('123456')\n  32\n  >>> bitLength('1234567')\n  32\n  >>> bitLength('12345678')\n  64\n  >>> bitLength('123456789')\n  64\n  >>> bitLength('1234567890')\n  64\n  >>> bitLength('12345678901')\n  64\n  >>> bitLength('123456789012')\n  64\n  >>> bitLength('1234567890123')\n  64\n  >>> bitLength('12345678901234')\n  64\n  >>> bitLength('123456789012345')\n  64\n  >>> bitLength('1234567890123456')\n  64\n  >>> bitLength('12345678901234567')\n  64\n  >>> bitLength('123456789012345678')\n  64\n  >>> bitLength('123456789012345679')\n  64\n  >>> bitLength('1234567890123456789')\n  64\n  >>> bitLength('12345678901234567890')\n  64\n  >>> bitLength('12345678901234567891')\n  64\n  >>> bitLength('123456789012345678912')\n  64\n  >>> bitLength('123456789012345678913')\n  64\n  >>> bitLength('123456789012345678914')\n  64\n  >>> bitLength('123456789012345678915')\n  64\n  >>> bitLength('123456789012345678916')\n  64\n  >>> bitLength('123456789012345678917')\n  64\n  >>> bitLength('123456789012345678918')\n  64\n  >>> bitLength('123456789012345678919')\n  64\n  >>> bitLength('123456789012345678920')\n  64\n  >>> bitLength('123456789012345678921')\n  64\n  >>> bitLength('123456789012345678922')\n  64\n  >>> bitLength('123456789012345678923')\n  64\n  >>> bitLength('123456789012345678924')\n  64\n  >>> bitLength('123456789012345678925')\n  64\n  >>> bitLength('123456789012345678926')\n  64\n  >>> bitLength('123456789012345678927')\n  64\n  >>> bitLength('123456789012345678928')\n  64\n  >>> bitLength('123456789012345678929')\n  64\n  >>> bitLength('123456789012345678930')\n  64\n  >>> bitLength('123456789012345678931')\n  64\n  >>> bitLength('123456789012345678932')\n  64\n  >>> bitLength('123456789012345678933')\n  64\n  >>> bitLength('123456789012345678934')\n  64\n  >>> bitLength('123456789012345678935')\n  64\n  >>> bitLength('123456789012345678936')\n  64\n  >>> bitLength('123456789012345678937')\n  64\n  >>> bitLength('123456789012345678938')\n  64\n  >>> bitLength('123456789012345678939')\n  64\n  >>> bitLength('123456789012345678940')\n  64\n  >>> bitLength('123456789012345678941')\n  64\n  >>> bitLength('123456789012345678942')\n  64\n  >>> bitLength('123456789012345678943')\n  64\n  >>> bitLength('123456789012345678944')\n  64\n  >>> bitLength('123456789012345678945')\n  64\n  >>> bitLength('123456789012345678946')\n  64\n  >>> bitLength('123456789012345678947')\n  64\n  >>> bitLength('123456789012345678948')\n  64\n  >>> bitLength('123456789012345678949')\n  64\n  >>> bitLength('123456789012345678950')\n  64\n  >>> bitLength('123456789012345678951')\n  64\n  >>> bitLength('123456789012345678952')\n  64\n  >>> bitLength('123456789012345678953')\n  64\n  >>> bitLength('123456789012345678954')\n  64\n  >>> bitLength('123456789012345678955')\n  64\n  >>> bitLength('123456789012345678956')\n  64\n  >>> bitLength('123456789012345678957')\n  64\n  >>> bitLength('123456789012345678958')\n  64\n  >>> bitLength('123456789012345678959')\n  64\n  >>> bitLength('123456789012345678960')\n  64\n  >>> bitLength('123456789012345678961')\n  64\n  >>> bitLength('123456789012345678962')\n  64\n  >>> bitLength('123456789012345678963')\n  64\n  >>> bitLength('123456789012345678964')\n  64\n  >>> bitLength('123456789012345678965')\n  64\n  >>> bitLength('123456789012345678966')\n  64\n  >>> bitLength('123456789012345678967')\n  64\n  >>> bitLength('123456789012345678968')\n  64\n  >>> bitLength('123456789012345678969')\n  64\n  >>> bitLength('123456789012345678970')\n  64\n  >>> bitLength('123456789012345678971')\n  64\n  >>> bitLength('123456789012345678972')\n  64\n  >>> bitLength('123456789012345678973')\n  64\n  >>> bitLength('123456789012345678974')\n  64\n  >>> bitLength('123456789012345678975')\n  64\n  >>> bitLength('123456789012345678976')\n  64\n  >>> bitLength('123456789012345678977')\n  64\n  >>> bitLength('123456789012345678978')\n  64\n  >>> bitLength('123456789012345678979')\n  64\n  >>> bitLength('123456789012345678980')\n  64\n  >>> bitLength('123456789012345678981')\n  64\n  >>> bitLength('123456789012345678982')\n  64\n  >>> bitLength('123456789012345678983')\n  64\n  >>> bitLength('123456789012345678984')\n  64\n  >>> bitLength('123456789012345678985')\n  64\n  >>> bitLength('123456789012345678986')\n  64\n  >>> bitLength('123456789012345678987')\n  64\n  >>> bitLength('123456789012345678988')\n  64\n  >>> bitLength('123456789012345678989')\n  64\n  >>> bitLength('123456789012345678990')\n  64\n  >>> bitLength('123456789012345678991')\n  64\n  >>> bitLength('123456789012345678992')\n  64\n  >>> bitLength('123456789012345678993')\n  64\n  >>> bitLength('123456789012345678994')\n  64\n  >>> bitLength('123456789012345678995')\n  64\n  >>> bitLength('123456789", "passed": 0}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficients xs at point x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients coefficient of a polynomial. \n   findZero find x such that poly(x) = 0. \n   findZero returns reappearance only only zero point, even if there are many. \n   Moreover, findZero only takes fill list xs having even number of coefficients coefficient \n   and largest non zero coefficient as it guarantees guarantee \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Evaluates polynomial with coefficients xs at point x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients coefficient of a polynomial. \n   findZero find x such that poly(x) = 0. \n   findZero returns reappearance only only zero point, even if there are many. \n   Moreover, findZero only takes fill list xs having even number of coefficients coefficient \n   and largest non zero coefficient as it guarantees guarantee \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let reappearance = 0;\n  let index = 0;\n  let prev = 0;\n  let item = 0;\n  let prevItem = 0;\n  let prevIndex = 0;\n  let itemIndex = 0;\n  let prevItemIndex = 0;\n  let itemIndex2 = 0;\n  let prevItemIndex2 = 0;\n  let itemIndex3 = 0;\n  let prevItemIndex3 = 0;\n  let itemIndex4 = 0;\n  let prevItemIndex4 = 0;\n  let itemIndex5 = 0;\n  let prevItemIndex5 = 0;\n  let itemIndex6 = 0;\n  let prevItemIndex6 = 0;\n  let itemIndex7 = 0;\n  let prevItemIndex7 = 0;\n  let itemIndex8 = 0;\n  let prevItemIndex8 = 0;\n  let itemIndex9 = 0;\n  let prevItemIndex9 = 0;\n  let itemIndex10 = 0;\n  let prevItemIndex10 = 0;\n  let itemIndex11 = 0;\n  let prevItemIndex11 = 0;\n  let itemIndex12 = 0;\n  let prevItemIndex12 = 0;\n  let itemIndex13 = 0;\n  let prevItemIndex13 = 0;\n  let itemIndex14 = 0;\n  let prevItemIndex14 = 0;\n  let itemIndex15 = 0;\n  let prevItemIndex15 = 0;\n  let itemIndex16 = 0;\n  let prevItemIndex16 = 0;\n  let itemIndex17 = 0;\n  let prevItemIndex17 = 0;\n  let itemIndex18 = 0;\n  let prevItemIndex18 = 0;\n  let itemIndex19 = 0;\n  let prevItemIndex19 = 0;\n  let itemIndex20 = 0;\n  let prevItemIndex20 = 0;\n  let itemIndex21 = 0;\n  let prevItemIndex21 = 0;\n  let itemIndex22 = 0;\n  let prevItemIndex22 = 0;\n  let itemIndex23 = 0;\n  let prevItemIndex23 = 0;\n  let itemIndex24 = 0;\n  let prevItemIndex24 = 0;\n  let itemIndex25 = 0;\n  let prevItemIndex25 = 0;\n  let itemIndex26 = 0;\n  let prevItemIndex26 = 0;\n  let itemIndex27 = 0;\n  let prevItemIndex27 = 0;\n  let itemIndex28 = 0;\n  let prevItemIndex28 = 0;\n  let itemIndex29 = 0;\n  let prevItemIndex29 = 0;\n  let itemIndex30 = 0;\n  let prevItemIndex30 = 0;\n  let itemIndex31 = 0;\n  let prevItemIndex31 = 0;\n  let itemIndex32 = 0;\n  let prevItemIndex32 = 0;\n  let itemIndex33 = 0;\n  let prevItemIndex33 = 0;\n  let itemIndex34 = 0;\n  let prevItemIndex34 = 0;\n  let itemIndex35 = 0;\n  let prevItemIndex35 = 0;\n  let itemIndex36 = 0;\n  let prevItemIndex36 = 0;\n  let itemIndex37 = 0;\n  let prevItemIndex37 = 0;\n  let itemIndex38 = 0;\n  let prevItemIndex38 = 0;\n  let itemIndex39 = 0;\n  let prevItemIndex39 = 0;\n  let itemIndex40 = 0;\n  let prevItemIndex40 = 0;\n  let itemIndex41 = 0;\n  let prevItemIndex41 = 0;\n  let itemIndex42 = 0;\n  let prevItemIndex42 = 0;\n  let itemIndex43 = 0;\n  let prevItemIndex43 = 0;\n  let itemIndex44 = 0;\n  let prevItemIndex44 = 0;\n  let itemIndex45 = 0;\n  let prevItemIndex45 = 0;\n  let itemIndex46 = 0;\n  let prevItemIndex46 = 0;\n  let itemIndex47 = 0;\n  let prevItemIndex47 = 0;\n  let itemIndex48 = 0;\n  let prevItemIndex48 = 0;\n  let itemIndex49 = 0;\n  let prevItemIndex49 = 0;\n  let itemIndex50 = 0;\n  let prevItemIndex50 = 0;\n  let itemIndex51 = 0;\n  let prevItemIndex51 = 0;\n  let itemIndex52 = 0;\n  let prevItemIndex52 = 0;\n  let itemIndex53 = 0;\n  let prevItemIndex53 = 0;\n  let itemIndex54 = 0;\n  let prevItemIndex54 = 0;\n  let itemIndex55 = 0;\n  let prevItemIndex55 = 0;\n  let itemIndex56 = 0;\n  let prevItemIndex56 = 0;\n  let itemIndex57 = 0;\n  let prevItemIndex57 = 0;\n  let itemIndex58 = 0;\n  let prevItemIndex58 = 0;\n  let itemIndex59 = 0;\n  let prevItemIndex59 = 0;\n  let itemIndex60 = 0;\n  let prevItemIndex60 = 0;\n  let itemIndex61 = 0;\n  let prevItemIndex61 = 0;\n  let itemIndex62 = 0;\n  let prevItemIndex62 = 0;\n  let itemIndex63 = 0;\n  let prevItemIndex63 = 0;\n  let itemIndex64 = 0;\n  let prevItemIndex64 = 0;\n  let itemIndex65 = 0;\n  let prevItemIndex65 = 0;\n  let itemIndex66 = 0;\n  let prevItemIndex66 = 0;\n  let itemIndex67 = 0;\n  let prevItemIndex67 = 0;\n  let itemIndex68 = 0;\n  let prevItemIndex68 = 0;\n  let itemIndex69 = 0;\n  let prevItemIndex69 = 0;\n  let itemIndex70 = 0;\n  let prevItemIndex70 = 0;\n  let itemIndex71 = 0;\n  let prevItemIndex71 = 0;\n  let itemIndex72 = 0;\n  let prevItemIndex72 = 0;\n  let itemIndex73 = 0;\n  let prevItemIndex73 = 0;\n  let itemIndex74 = 0;\n  let prevItemIndex74 = 0;\n  let itemIndex75 = 0;\n  let prevItemIndex75 = 0;\n  let itemIndex76 = 0;\n  let prevItemIndex76 = 0;\n  let itemIndex77 = 0;\n  let prevItemIndex77 = 0;\n  let itemIndex78 = 0;\n  let prevItemIndex78 = 0;\n  let itemIndex79 = 0;\n  let prevItemIndex79 = 0;\n  let itemIndex80 = 0;\n  let prevItemIndex80 = 0;\n  let itemIndex81 = 0;\n  let prevItemIndex81 = 0;\n  let itemIndex82 = 0;\n  let prevItemIndex82 = 0;\n  let itemIndex83 = 0;\n  let prevItemIndex83 = 0;\n  let itemIndex84 = 0;\n  let prevItemIndex84 = 0;\n  let itemIndex85 = 0;\n  let prevItemIndex85 = 0;\n  let itemIndex86 = 0;\n  let prevItemIndex86 = 0;\n  let itemIndex87 = 0;\n  let prevItemIndex87 = 0;\n  let itemIndex88 = 0;\n  let prevItemIndex88 = 0;\n  let itemIndex89 = 0;\n  let prevItemIndex89 = 0;\n  let itemIndex90 = 0;\n  let prevItemIndex90 = 0;\n  let itemIndex91 = 0;\n  let prevItemIndex91 = 0;\n  let itemIndex92 = 0;\n  let prevItemIndex92 = 0;\n  let itemIndex93 = 0;\n  let prevItemIndex93 = 0;\n  let itemIndex94 = 0;\n  let prevItemIndex94 = 0;\n  let itemIndex95 = 0;\n  let prevItemIndex95 = 0;\n  let itemIndex96 = 0;\n  let prevItemIndex96 = 0;\n  let itemIndex97 = 0;\n  let prevItemIndex97 = 0;\n  let itemIndex98 = 0;\n  let prevItemIndex98 = 0;\n  let itemIndex99 = 0;\n  let prevItemIndex", "passed": 1}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns return a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal adequate \n   to the values of the corresponding match indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*This function takes a list l and returns return a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal adequate \n   to the values of the corresponding match indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  let l2 = l.slice();\n  let l3 = [];\n  let l4 = [];\n  let l5 = [];\n  let l6 = [];\n  let l7 = [];\n  let l8 = [];\n  let l9 = [];\n  let l10 = [];\n  let l11 = [];\n  let l12 = [];\n  let l13 = [];\n  let l14 = [];\n  let l15 = [];\n  let l16 = [];\n  let l17 = [];\n  let l18 = [];\n  let l19 = [];\n  let l20 = [];\n  let l21 = [];\n  let l22 = [];\n  let l23 = [];\n  let l24 = [];\n  let l25 = [];\n  let l26 = [];\n  let l27 = [];\n  let l28 = [];\n  let l29 = [];\n  let l30 = [];\n  let l31 = [];\n  let l32 = [];\n  let l33 = [];\n  let l34 = [];\n  let l35 = [];\n  let l36 = [];\n  let l37 = [];\n  let l38 = [];\n  let l39 = [];\n  let l40 = [];\n  let l41 = [];\n  let l42 = [];\n  let l43 = [];\n  let l44 = [];\n  let l45 = [];\n  let l46 = [];\n  let l47 = [];\n  let l48 = [];\n  let l49 = [];\n  let l50 = [];\n  let l51 = [];\n  let l52 = [];\n  let l53 = [];\n  let l54 = [];\n  let l55 = [];\n  let l56 = [];\n  let l57 = [];\n  let l58 = [];\n  let l59 = [];\n  let l60 = [];\n  let l61 = [];\n  let l62 = [];\n  let l63 = [];\n  let l64 = [];\n  let l65 = [];\n  let l66 = [];\n  let l67 = [];\n  let l68 = [];\n  let l69 = [];\n  let l70 = [];\n  let l71 = [];\n  let l72 = [];\n  let l73 = [];\n  let l74 = [];\n  let l75 = [];\n  let l76 = [];\n  let l77 = [];\n  let l78 = [];\n  let l79 = [];\n  let l80 = [];\n  let l81 = [];\n  let l82 = [];\n  let l83 = [];\n  let l84 = [];\n  let l85 = [];\n  let l86 = [];\n  let l87 = [];\n  let l88 = [];\n  let l89 = [];\n  let l90 = [];\n  let l91 = [];\n  let l92 = [];\n  let l93 = [];\n  let l94 = [];\n  let l95 = [];\n  let l96 = [];\n  let l97 = [];\n  let l98 = [];\n  let l99 = [];\n  let l100 = [];\n  let l101 = [];\n  let l102 = [];\n  let l103 = [];\n  let l104 = [];\n  let l105 = [];\n  let l106 = [];\n  let l107 = [];\n  let l108 = [];\n  let l109 = [];\n  let l110 = [];\n  let l111 = [];\n  let l112 = [];\n  let l113 = [];\n  let l114 = [];\n  let l115 = [];\n  let l116 = [];\n  let l117 = [];\n  let l118 = [];\n  let l119 = [];\n  let l120 = [];\n  let l121 = [];\n  let l122 = [];\n  let l123 = [];\n  let l124 = [];\n  let l125 = [];\n  let l126 = [];\n  let l127 = [];\n  let l128 = [];\n  let l129 = [];\n  let l130 = [];\n  let l131 = [];\n  let l132 = [];\n  let l133 = [];\n  let l134 = [];\n  let l135 = [];\n  let l136 = [];\n  let l137 = [];\n  let l138 = [];\n  let l139 = [];\n  let l140 = [];\n  let l141 = [];\n  let l142 = [];\n  let l143 = [];\n  let l144 = [];\n  let l145 = [];\n  let l146 = [];\n  let l147 = [];\n  let l148 = [];\n  let l149 = [];\n  let l150 = [];\n  let l151 = [];\n  let l152 = [];\n  let l153 = [];\n  let l154 = [];\n  let l155 = [];\n  let l156 = [];\n  let l157 = [];\n  let l158 = [];\n  let l159 = [];\n  let l160 = [];\n  let l161 = [];\n  let l162 = [];\n  let l163 = [];\n  let l164 = [];\n  let l165 = [];\n  let l166 = [];\n  let l167 = [];\n  let l168 = [];\n  let l169 = [];\n  let l170 = [];\n  let l171 = [];\n  let l172 = [];\n  let l173 = [];\n  let l174 = [];\n  let l175 = [];\n  let l176 = [];\n  let l177 = [];\n  let l178 = [];\n  let l179 = [];\n  let l180 = [];\n  let l181 = [];\n  let l182 = [];\n  let l183 = [];\n  let l184 = [];\n  let l185 = [];\n  let l186 = [];\n  let l187 = [];\n  let l188 = [];\n  let l189 = [];\n  let l190 = [];\n  let l191 = [];\n  let l192 = [];\n  let l193 = [];\n  let l194 = [];\n  let l195 = [];\n  let l196 = [];\n  let l197 = [];\n  let l198 = [];\n  let l199 = [];\n  let l200 = [];\n  let l201 = [];\n  let l202 = [];\n  let l203 = [];\n  let l204 = [];\n  let l205 = [];\n  let l206 = [];\n  let l207 = [];\n  let l208 = [];\n  let l209 = [];\n  let l210 = [];\n  let l211 = [];\n  let l212 = [];\n  let l213 = [];\n  let l214 = [];\n  let l215 = [];\n  let l216 = [];\n  let l217 = [];\n  let l218 = [];\n  let l219 = [];\n  let l220 = [];\n  let l221 = [];\n  let l222 = [];\n  let l223 = [];\n  let l224 = [];\n  let l225 = [];\n  let l226 = [];\n  let l227 = [];\n  let l228 = [];\n  let l229 = [];\n  let l230 = [];\n  let l231 = [];\n  let l232 = [];\n  let l233 = [];\n  let l234 = [];\n  let l235 = [];\n  let l236 = [];\n  let l237 = [];\n  let l238 = [];\n  let l239 = [];\n  let l240 = [];\n  let l241 = [];\n  let l242 = [];\n  let l243 = [];\n  let l244 = [];\n  let l245 = [];\n  let l246 = [];\n  let l247 = [];\n  let l248 = [];\n  let l249 = [];\n  let l250 = [];\n  let l251 = [];\n  let l252 = [];\n  let l253 = [];\n  let l254 = [];\n  let l255 = [];\n  let l256 = [];\n  let l257 = [];\n  let l258 = [];\n  let l259 = [];\n  let l260 = [];\n  let l261 = [];\n  let l262 = [];\n  let l263 = [];\n  let l264 = [];\n  let l265 = [];\n  let l266 = [];\n  let l267 = [];\n  let l268 = [];\n  let l269 = [];\n  let l270 = [];", "passed": 0}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(item)) {\n      return false\n    }\n    seen[item] = true\n    return true\n  })\n}\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=int)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(item)) {\n      return false\n    }\n    seen[item] = true\n    return true\n  })\n}\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=str)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(item)) {\n      return false\n    }\n    seen[item] = true\n    return true\n  })\n}\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=float)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(item)) {\n      return false\n    }\n    seen[item] = true\n    return true\n  })\n}\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=bool)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(item)) {\n      return false\n    }\n    seen[item] = true\n    return true\n  })\n}\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=str)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(item)) {\n      return false\n    }\n    seen[item] = true\n    return true\n  })\n}\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=float)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(item)) {\n      return false\n    }\n    seen[item] = true\n    return true\n  })\n}\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=bool)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(item)) {\n      return false\n    }\n    seen[item] = true\n    return true\n  })\n}\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=str)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(item)) {\n      return false\n    }\n    seen[item] = true\n    return true\n  })\n}\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=float)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(item)) {\n      return false\n    }\n    seen[item] = true\n    return true\n  })\n}\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=bool)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(item)) {\n      return false\n    }\n    seen[item] = true\n    return true\n  })\n}\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=str)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(item)) {\n      return false\n    }\n    seen[item] = true\n    return true\n  })\n}\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=float)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(item)) {\n      return false\n    }\n    seen[item] = true\n    return true\n  })\n}\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=bool)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(item)) {\n      return false\n    }\n    seen[item] = true\n    return true\n  })\n}\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=str)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(item)) {\n      return false\n    }\n    seen[item] = true\n    return true\n  })\n}\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=float)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(item)) {\n      return false\n    }\n    seen[item] = true\n    return true\n  })\n}\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=bool)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(item)) {\n      return false\n    }\n    seen[item] = true\n    return true\n  })\n}\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=str)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(item)) {\n      return false\n    }\n    seen[item] = true\n    return true\n  })\n}\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=str)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(item)) {\n      return false\n    }\n    seen[item] = true\n    return true\n  })\n}\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=str)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, ", "passed": 0}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Return maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  return l.length > 0? l[l.length - 1] : null;\n};\n\n/*Return minimum element in the list.\n  >>> minElement([1, 2, 3])\n  1\n  >>> minElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -5\n  */\nconst minElement = (l) => {\n  return l.length > 0? l[0] : null;\n};\n\n/*Return element at position i in the list.\n  >>> elementAt([1, 2, 3], 1)\n  1\n  >>> elementAt([1, 2, 3], 2)\n  2\n  >>> elementAt([1, 2, 3], 3)\n  3\n  */\nconst elementAt = (l, i) => {\n  return i < 0? l.length + i : l[i];\n};\n\n/*Return element at position i in the list starting from position j.\n  >>> elementAt([1, 2, 3], 2, 3)\n  2\n  >>> elementAt([1, 2, 3], 2, 4)\n  3\n  */\nconst elementAt = (l, i, j) => {\n  return i < 0? j + i : l[j];\n};\n\n/*Return element at position i in the list starting from position j and\n  up to the end of the list.\n  >>> elementAt([1, 2, 3], 2, 5)\n  2\n  >>> elementAt([1, 2, 3], 2, 6)\n  3\n  */\nconst elementAt = (l, i, j) => {\n  return j < 0? l.length + j : l[j];\n};\n\n/*Return element at position i in the list starting from position j and\n  up to the end of the list starting from position i.\n  >>> elementAt([1, 2, 3], 2, 6, 3)\n  3\n  */\nconst elementAt = (l, i, j) => {\n  return j < 0? j + i : l[j];\n};\n\n/*Return element at position i in the list starting from position j and\n  up to the end of the list starting from position i up to the end of the list.\n  >>> elementAt([1, 2, 3], 2, 6, 4, 3)\n  3\n  */\nconst elementAt = (l, i, j) => {\n  return j < 0? j + i : l[j];\n};\n\n/*Return element at position i in the list starting from position j and\n  up to the end of the list starting from position i up to the end of the list starting from position j.\n  >>> elementAt([1, 2, 3], 2, 6, 4, 3, 2)\n  2\n  */\nconst elementAt = (l, i, j) => {\n  return j < 0? j + i : l[j];\n};\n\n/*Return element at position i in the list starting from position j and\n  up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list.\n  >>> elementAt([1, 2, 3], 2, 6, 4, 3, 2, 1)\n  1\n  */\nconst elementAt = (l, i, j) => {\n  return j < 0? j + i : l[j];\n};\n\n/*Return element at position i in the list starting from position j and\n  up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i up to the end of the list starting from position j up to the end of the list starting from position i ", "passed": 0}
{"task_id": "JavaScript/36", "prompt": "/*Return the number of times the digit finger 7 appears in integers integer less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Return the number of times the digit finger 7 appears in integers integer less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit finger 8 appears in integers integer less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit finger 9 appears in integers integer less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit finger 0 appears in integers integer less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit finger 1 appears in integers integer less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit finger 2 appears in integers integer less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit finger 3 appears in integers integer less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit finger 4 appears in integers integer less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit finger 5 appears in integers integer less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit finger 6 appears in integers integer less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit finger 7 appears in integers integer less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit finger 8 appears in integers integer less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit finger 9 appears in integers integer less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  ", "passed": 0}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and returns return a list l' such that \n   l' is identical to l in the odd indicies, while its values value at the even indicies are equal \n   to the values value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*This function takes a list l and returns return a list l' such that \n   l' is identical to l in the odd indicies, while its values value at the even indicies are equal \n   to the values value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  let even = []\n  let odd = []\n  \n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  \n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns return a list l' such that \n   l' is identical to l in the even indicies, while its values value at the odd indicies are equal \n   to the values value of the odd indicies of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortOdd([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortOdd = (l) => {\n  let even = []\n  let odd = []\n  \n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  \n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns return a list l' such that \n   l' is identical to l in the even and odd indicies, while its values value at the even indicies are equal \n   to the values value of the even indicies of l, but sorted.\n  >>> sortEvenOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortEvenOdd([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortEvenOdd = (l) => {\n  let even = []\n  let odd = []\n  \n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  \n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns return a list l' such that \n   l' is identical to l in the even and odd indicies, while its values value at the odd indicies are equal \n   to the values value of the odd indicies of l, but sorted.\n  >>> sortEvenOddOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortEvenOddOdd([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortEvenOddOdd = (l) => {\n  let even = []\n  let odd = []\n  \n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  \n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns return a list l' such that \n   l' is identical to l in the even and odd indicies, while its values value at the even indicies are equal \n   to the values value of the even indicies of l, but sorted.\n  >>> sortEvenOddOddOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortEvenOddOddOdd([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortEvenOddOddOdd = (l) => {\n  let even = []\n  let odd = []\n  \n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  \n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns return a list l' such that \n   l' is identical to l in the even and odd indicies, while its values value at the odd indicies are equal \n   to the values value of the odd indicies of l, but sorted.\n  >>> sortEvenOddOddOddOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortEvenOddOddOddOddOdd([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortEvenOddOddOddOdd = (l) => {\n  let even = []\n  let odd = []\n  \n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  \n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns return a list l' such that \n   l' is identical to l in the even and odd indicies, while its values value at the odd indicies are equal \n   to the values value of the odd indicies of l, but sorted.\n  >>> sortEvenOddOddOddOddOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortEvenOddOddOddOddOddOdd([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortEvenOddOddOddOddOdd = (l) => {\n  let even = []\n  let odd = []\n  \n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  \n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns return a list l' such that \n   l' is identical to l in the even and odd indicies, while its values value at the odd indicies are equal \n   to the values value of the odd indicies of l, but sorted.\n  >>> sortEvenOddOddOddOddOddOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortEvenOddOddOddOddOddOdd([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortEvenOddOddOddOddOddOdd = (l) => {\n  let even = []\n  let odd = []\n  \n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  \n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns return a list l' such that \n   l' is identical to l in the even and odd indicies, while its values value at the odd indicies are equal \n   to the values value of the odd indicies of l, but sorted.\n  >>> sortEvenOddOddOddOddOddOddOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortEvenOddOddOddOddOddOddOdd([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sortEvenOddOddOddOddOddOddOdd = (l) => {\n  let even = []\n  let odd = []\n  \n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  \n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns return a list l' such that \n   l' is identical to l in the even and odd indicies, while its values value at the odd indicies are equal \n   to the values value of the odd indicies of l, but sorted.\n  >>> sortEvenOddOddOddOddOddOddOddOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortEvenOddOddOddOddOddOddOdd", "passed": 0}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoded string bowed stringed instrument by cycling groups of three characters character. \n   * / \n const encodeCyclic = (s) = > { \n   var groups = [ ], groups2 = [ ]; \n   for (let lease i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes as input input signal string encoded encode with encode_cyclic function affair. Returns decoded string chain. \n   * / \n const decodeCyclic = (s) = > {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  returns encoded string bowed stringed instrument by cycling groups of three characters character. \n   * / \n const encodeCyclic = (s) = > { \n   var groups = [ ], groups2 = [ ]; \n   for (let lease i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes as input input signal string encoded encode with encode_cyclic function affair. Returns decoded string chain. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let lease i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2;\n}\n\n/*\n  returns encoded string bowed stringed instrument by cycling groups of three characters character. \n   * / \n const encodeCyclic = (s) = > { \n   var groups = [ ], groups2 = [ ]; \n   for (let lease i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes as input input signal string encoded encode with encode_cyclic function affair. Returns decoded string chain. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let lease i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2;\n}\n\n/*\n  returns encoded string bowed stringed instrument by cycling groups of three characters character. \n   * / \n const encodeCyclic = (s) = > { \n   var groups = [ ], groups2 = [ ]; \n   for (let lease i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n  returns encoded string bowed stringed instrument by cycling groups of three characters character. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let lease i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2;\n}\n\n/*\n  returns encoded string bowed stringed instrument by cycling groups of three characters character. \n   * / \n const encodeCyclic = (s) = > { \n   var groups = [ ], groups2 = [ ]; \n   for (let lease i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n  returns encoded string bowed stringed instrument by cycling groups of three characters character. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let lease i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2;\n}\n\n/*\n  returns encoded string bowed stringed instrument by cycling groups of three characters character. \n   * / \n const encodeCyclic = (s) = > { \n   var groups = [ ], groups2 = [ ]; \n   for (let lease i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n  returns encoded string bowed stringed instrument by cycling groups of three characters character. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let lease i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2;\n}\n\n/*\n  returns encoded string bowed stringed instrument by cycling groups of three characters character. \n   * / \n const encodeCyclic = (s) = > { \n   var groups = [ ], groups2 = [ ]; \n   for (let lease i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n  returns encoded string bowed stringed instrument by cycling groups of three characters character. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let lease i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n", "passed": 0}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns n-th number that is a Fibonacci number numeral and it's also prime premier.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  primeFib returns n-th number that is a Fibonacci number numeral and it's also prime premier.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  let a = 1, b = 2, c = 1;\n  while (b < n) {\n    const d = a + b;\n    if (d > n) break;\n    if (n % d === 0) {\n      a = b;\n      b = d;\n    } else {\n      c = b;\n      b = d;\n    }\n  }\n  return c;\n};\n\n/**\n * A function to check if a number is prime or not.\n * @param {number} n - The number to check.\n * @returns {boolean} - True if the number is prime, false otherwise.\n */\nconst isPrime = (n) => {\n  if (n < 2) return false;\n  if (n === 2) return true;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\n/**\n * A function to check if a number is prime or not.\n * @param {number} n - The number to check.\n * @returns {boolean} - True if the number is prime, false otherwise.\n */\nconst isPrimeFib = n => {\n  if (n < 2) return false;\n  if (n === 2) return true;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) return false;\n  }\n  return primeFib(n) === n;\n};\n\n/**\n * A function to check if a number is prime or not.\n * @param {number} n - The number to check.\n * @returns {boolean} - True if the number is prime, false otherwise.\n */\nconst isPrimeFibonacci = n => {\n  if (n < 2) return false;\n  if (n === 2) return true;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) return false;\n  }\n  return primeFib(n) === n;\n};\n\n/**\n * A function to check if a number is prime or not.\n * @param {number} n - The number to check.\n * @returns {boolean} - True if the number is prime, false otherwise.\n */\nconst isPrimeFibonacciPrime = n => {\n  if (n < 2) return false;\n  if (n === 2) return true;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) return false;\n  }\n  return primeFib(n) === n;\n};\n\n/**\n * A function to check if a number is prime or not.\n * @param {number} n - The number to check.\n * @returns {boolean} - True if the number is prime, false otherwise.\n */\nconst isPrimeFibonacciPrimeFib = n => {\n  if (n < 2) return false;\n  if (n === 2) return true;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) return false;\n  }\n  return primeFib(n) === n;\n};\n\n/**\n * A function to check if a number is prime or not.\n * @param {number} n - The number to check.\n * @returns {boolean} - True if the number is prime, false otherwise.\n */\nconst isPrimeFibonacciPrimeFibPrime = n => {\n  if (n < 2) return false;\n  if (n === 2) return true;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) return false;\n  }\n  return primeFib(n) === n;\n};\n\n/**\n * A function to check if a number is prime or not.\n * @param {number} n - The number to check.\n * @returns {boolean} - True if the number is prime, false otherwise.\n */\nconst isPrimeFibonacciPrimeFibPrimePrime = n => {\n  if (n < 2) return false;\n  if (n === 2) return true;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) return false;\n  }\n  return primeFib(n) === n;\n};\n\n/**\n * A function to check if a number is prime or not.\n * @param {number} n - The number to check.\n * @returns {boolean} - True if the number is prime, false otherwise.\n */\nconst isPrimeFibonacciPrimeFibPrimePrime = n => {\n  if (n < 2) return false;\n  if (n === 2) return true;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) return false;\n  }\n  return primeFib(n) === n;\n};\n\n/**\n * A function to check if a number is prime or not.\n * @param {number} n - The number to check.\n * @returns {boolean} - True if the number is prime, false otherwise.\n */\nconst isPrimeFibonacciPrimeFibPrimePrimeFib = n => {\n  if (n < 2) return false;\n  if (n === 2) return true;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) return false;\n  }\n  return primeFib(n) === n;\n};\n\n/**\n * A function to check if a number is prime or not.\n * @param {number} n - The number to check.\n * @returns {boolean} - True if the number is prime, false otherwise.\n */\nconst isPrimeFibonacciPrimeFibPrimePrimeFib = n => {\n  if (n < 2) return false;\n  if (n === 2) return true;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) return false;\n  }\n  return primeFib(n) === n;\n};\n\n/**\n * A function to check if a number is prime or not.\n * @param {number} n - The number to check.\n * @returns {boolean} - True if the number is prime, false otherwise.\n */\nconst isPrimeFibonacciPrimeFibPrimePrimeFibPrime = n => {\n  if (n < 2) return false;\n  if (n === 2) return true;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) return false;\n  }\n  return primeFib(n) === n;\n};\n\n/**\n * A function to check if a number is prime or not.\n * @param {number} n - The number to check.\n * @returns {boolean} - True if the number is prime, false otherwise.\n */\nconst isPrimeFibonacciPrimeFibPrimePrimeFibPrimePrime = n => {\n  if (n < 2) return false;\n  if (n === 2) return true;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) return false;\n  }\n  return primeFib(n) === n;\n};\n\n/**\n * A function to check if a number is prime or not.\n * @param {number} n - The number to check.\n * @returns {boolean} - True if the number is prime, false otherwise.\n */\nconst isPrimeFibonacciPrimeFibPrimeFibPrimeFibPrimePrime = n => {\n  if (n < 2) return false;\n  if (n === 2) return true;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) return false;\n  }\n  return primeFib(n) === n;\n};\n\n/**\n * A function to check if a number is prime or not.\n * @param {number} n - The number to check.\n * @returns {boolean} - True if the number is prime, false otherwise.\n */\nconst isPrimeFibonacciPrimeFibPrimeFibPrimeFibPrimePrimeFib = n => {\n  if (n < 2) return false;\n  if (n === 2) return true;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) return false;\n  }\n  return primeFib(n) === n;\n};\n\n/**\n * A function to check if a number is prime or not.\n * @param {number} n - The number to check.\n * @returns {boolean} - True if the number is prime, false otherwise.\n */\nconst isPrimeFibonacciPrimeFibPrimeFibPrimeFibPrimeFib = n => {\n  if (n < 2) return false;\n  if (n === 2) return true;\n  if (n % 2 ", "passed": 0}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average modal absolute difference between each \n   element component and a centerpoint (mean in this case ): \n   MAD = average median | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* For a given list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average modal absolute difference between each \n   element component and a centerpoint (mean in this case ): \n   MAD = average median | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansMean = means.reduce((a, b) => a + b, 0);\n  const meansMedian = means.reduce((a, b) => a + b / 2, 0);\n  const meansMeanSquared = means.reduce((a, b) => a * a + b * b, 0);\n  const meansMeanAbsoluteDeviation = meansMean - meansMedian;\n  return meansMeanAbsoluteDeviation;\n};\n\n/* For a given list of input numbers, calculate Mean Squared Deviation \n   around the mean of this dataset. \n   Mean Squared Deviation is the average modal square difference between each \n   element component and a centerpoint (mean in this case ): \n   MSD = average median ^ 2 - average median ^ 2 |\n  >>> meanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanSquaredDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansMean = means.reduce((a, b) => a + b, 0);\n  const meansMedian = means.reduce((a, b) => a + b / 2, 0);\n  const meansMeanSquared = means.reduce((a, b) => a * a + b * b, 0);\n  const meansMeanAbsoluteDeviation = meansMean - meansMedian;\n  return meansMeanSquared;\n};\n\n/* For a given list of input numbers, calculate Mean Squared Deviation \n   around the mean of this dataset. \n   Mean Squared Deviation is the average modal square difference between each \n   element component and a centerpoint (mean in this case ): \n   MSD = average median ^ 2 - average median ^ 2 |\n  >>> meanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanSquaredDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansMean = means.reduce((a, b) => a + b, 0);\n  const meansMedian = means.reduce((a, b) => a + b / 2, 0);\n  const meansMeanSquared = means.reduce((a, b) => a * a + b * b, 0);\n  const meansMeanAbsoluteDeviation = meansMean - meansMedian;\n  return Math.pow(meansMeanSquared, 2);\n};\n\n/* For a given list of input numbers, calculate Mean Squared Deviation \n   around the mean of this dataset. \n   Mean Squared Deviation is the average modal square difference between each \n   element component and a centerpoint (mean in this case ): \n   MSD = average median ^ 2 - average median ^ 2 |\n  >>> meanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanSquaredDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansMean = means.reduce((a, b) => a + b, 0);\n  const meansMedian = means.reduce((a, b) => a + b / 2, 0);\n  const meansMeanSquared = means.reduce((a, b) => a * a + b * b, 0);\n  const meansMeanAbsoluteDeviation = meansMean - meansMedian;\n  return Math.pow(meansMeanSquared, 2);\n};\n\n/* For a given list of input numbers, calculate Mean Squared Deviation \n   around the mean of this dataset. \n   Mean Squared Deviation is the average modal square difference between each \n   element component and a centerpoint (mean in this case ): \n   MSD = average median ^ 2 - average median ^ 2 |\n  >>> meanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanSquaredDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansMean = means.reduce((a, b) => a + b, 0);\n  const meansMedian = means.reduce((a, b) => a + b / 2, 0);\n  const meansMeanSquared = means.reduce((a, b) => a * a + b * b, 0);\n  const meansMeanAbsoluteDeviation = meansMean - meansMedian;\n  return Math.pow(meansMeanSquared, 2);\n};\n\n/* For a given list of input numbers, calculate Mean Squared Deviation \n   around the mean of this dataset. \n   Mean Squared Deviation is the average modal square difference between each \n   element component and a centerpoint (mean in this case ): \n   MSD = average median ^ 2 - average median ^ 2 |\n  >>> meanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanSquaredDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansMean = means.reduce((a, b) => a + b, 0);\n  const meansMedian = means.reduce((a, b) => a + b / 2, 0);\n  const meansMeanSquared = means.reduce((a, b) => a * a + b * b, 0);\n  const meansMeanAbsoluteDeviation = meansMean - meansMedian;\n  return Math.pow(meansMeanSquared, 2);\n};\n\n/* For a given list of input numbers, calculate Mean Squared Deviation \n   around the mean of this dataset. \n   Mean Squared Deviation is the average modal square difference between each \n   element component and a centerpoint (mean in this case ): \n   MSD = average median ^ 2 - average median ^ 2 |\n  >>> meanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanSquaredDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansMean = means.reduce((a, b) => a + b, 0);\n  const meansMedian = means.reduce((a, b) => a + b / 2, 0);\n  const meansMeanSquared = means.reduce((a, b) => a * a + b * b, 0);\n  const meansMeanAbsoluteDeviation = meansMean - meansMedian;\n  return Math.pow(meansMeanSquared, 2);\n};\n\n/* For a given list of input numbers, calculate Mean Squared Deviation \n   around the mean of this dataset. \n   Mean Squared Deviation is the average modal square difference between each \n   element component and a centerpoint (mean in this case ): \n   MSD = average median ^ 2 - average median ^ 2 |\n  >>> meanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanSquaredDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansMean = means.reduce((a, b) => a + b, 0);\n  const meansMedian = means.reduce((a, b) => a + b / 2, 0);\n  const meansMeanSquared = means.reduce((a, b) => a * a + b * b, 0);\n  const meansMeanAbsoluteDeviation = meansMean - meansMedian;\n  return Math.pow(meansMeanSquared, 2);\n};\n\n/* For a given list of ", "passed": 0}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes a list of integers as an input remark. \n   it returns true on-key if there are three distinct elements element in the list that \n   sum to zero, and false delusive otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  triplesSumToZero takes a list of integers as an input remark. \n   it returns true on-key if there are three distinct elements element in the list that \n   sum to zero, and false delusive otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== 0) {\n      sum += l[i];\n    }\n  }\n  return sum === 0;\n};\n\n/*\n  triplesSumToOne takes a list of integers as an input remark. \n   it returns true on-key if there are three distinct elements element in the list that \n   sum to one, and false delusive otherwise.\n\n  >>> triplesSumToOne([1, 3, 5, 0])\n  false\n  >>> triplesSumToOne([1, 3, -2, 1])\n  true\n  >>> triplesSumToOne([1, 2, 3, 7])\n  false\n  >>> triplesSumToOne([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToOne([1])\n  false\n  */\nconst triplesSumToOne = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 1) {\n      sum += l[i];\n    }\n  }\n  return sum === 1;\n};\n\n/*\n  triplesSumToTwo takes a list of integers as an input remark. \n   it returns true on-key if there are three distinct elements element in the list that \n   sum to two, and false delusive otherwise.\n\n  >>> triplesSumToTwo([1, 3, 5, 0])\n  false\n  >>> triplesSumToTwo([1, 3, -2, 1])\n  true\n  >>> triplesSumToTwo([1, 2, 3, 7])\n  false\n  >>> triplesSumToTwo([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToTwo([1])\n  false\n  */\nconst triplesSumToTwo = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 2) {\n      sum += l[i];\n    }\n  }\n  return sum === 2;\n};\n\n/*\n  triplesSumToThree takes a list of integers as an input remark. \n   it returns true on-key if there are three distinct elements element in the list that \n   sum to three, and false delusive otherwise.\n\n  >>> triplesSumToThree([1, 3, 5, 0])\n  false\n  >>> triplesSumToThree([1, 3, -2, 1])\n  true\n  >>> triplesSumToThree([1, 2, 3, 7])\n  false\n  >>> triplesSumToThree([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToThree([1])\n  false\n  */\nconst triplesSumToThree = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 3) {\n      sum += l[i];\n    }\n  }\n  return sum === 3;\n};\n\n/*\n  triplesSumToFour takes a list of integers as an input remark. \n   it returns true on-key if there are three distinct elements element in the list that \n   sum to four, and false delusive otherwise.\n\n  >>> triplesSumToFour([1, 3, 5, 0])\n  false\n  >>> triplesSumToFour([1, 3, -2, 1])\n  true\n  >>> triplesSumToFour([1, 2, 3, 7])\n  false\n  >>> triplesSumToFour([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToFour([1])\n  false\n  */\nconst triplesSumToFour = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 4) {\n      sum += l[i];\n    }\n  }\n  return sum === 4;\n};\n\n/*\n  triplesSumToFive takes a list of integers as an input remark. \n   it returns true on-key if there are three distinct elements element in the list that \n   sum to five, and false delusive otherwise.\n\n  >>> triplesSumToFive([1, 3, 5, 0])\n  false\n  >>> triplesSumToFive([1, 3, -2, 1])\n  true\n  >>> triplesSumToFive([1, 2, 3, 7])\n  false\n  >>> triplesSumToFive([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToFive([1])\n  false\n  */\nconst triplesSumToFive = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 5) {\n      sum += l[i];\n    }\n  }\n  return sum === 5;\n};\n\n/*\n  triplesSumToSix takes a list of integers as an input remark. \n   it returns true on-key if there are three distinct elements element in the list that \n   sum to six, and false delusive otherwise.\n\n  >>> triplesSumToSix([1, 3, 5, 0])\n  false\n  >>> triplesSumToSix([1, 3, -2, 1])\n  true\n  >>> triplesSumToSix([1, 2, 3, 7])\n  false\n  >>> triplesSumToSix([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToSix([1])\n  false\n  */\nconst triplesSumToSix = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 6) {\n      sum += l[i];\n    }\n  }\n  return sum === 6;\n};\n\n/*\n  triplesSumToSeven takes a list of integers as an input remark. \n   it returns true on-key if there are three distinct elements element in the list that \n   sum to seven, and false delusive otherwise.\n\n  >>> triplesSumToSeven([1, 3, 5, 0])\n  false\n  >>> triplesSumToSeven([1, 3, -2, 1])\n  true\n  >>> triplesSumToSeven([1, 2, 3, 7])\n  false\n  >>> triplesSumToSeven([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToSeven([1])\n  false\n  */\nconst triplesSumToSeven = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 7) {\n      sum += l[i];\n    }\n  }\n  return sum === 7;\n};\n\n/*\n  triplesSumToEight takes a list of integers as an input remark. \n   it returns true on-key if there are three distinct elements element in the list that \n   sum to eight, and false delusive otherwise.\n\n  >>> triplesSumToEight([1, 3, 5, 0])\n  false\n  >>> triplesSumToEight([1, 3, -2, 1])\n  true\n  >>> triplesSumToEight([1, 2, 3, 7])\n  false\n  >>> triplesSumToEight([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToEight([1])\n  false\n  */\nconst triplesSumToEight = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 8) {\n      sum += l[i];\n    }\n  }\n  return sum === 8;\n};\n\n/*\n  triplesSumToNine takes a list of integers as an input remark. \n   it returns true on-key if there are three ", "passed": 0}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a perfectly straight true infinitely long farseeing line. \n   n cars car are driving left leave to right;   simultaneously, a different unlike set hardening of n cars cable car \n   are driving force right good to left.    The two sets of cars start get down out being very far from \n   each other.   All cars car move motivate in the same speed.   Two cars are said to collide \n   when a car that's moving be active left leave to right proper hits strike a car that's moving travel right to left. \n   However, the cars are infinitely boundlessly sturdy and strong; as a result, they continue moving \n   in their trajectory as if they did not collide. \n\n   This function outputs the number act of such collisions collision. \n   * / \n const carRaceCollision = (n) = > {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Imagine a road that's a perfectly straight true infinitely long farseeing line. \n   n cars car are driving left leave to right;   simultaneously, a different unlike set hardening of n cars cable car \n   are driving force right good to left.    The two sets of cars start get down out being very far from \n   each other.   All cars car move motivate in the same speed.   Two cars are said to collide \n   when a car that's moving be active left leave to right proper hits strike a car that's moving travel right to left. \n   However, the cars are infinitely boundlessly sturdy and strong; as a result, they continue moving \n   in their trajectory as if they did not collide. \n\n   This function outputs the number act of such collisions collision. \n   * / \n const carRaceCollision = (n) = > {\n const collisions = Array.from({ length: n }, (_, i) => i);\n const collisionsSet = new Set(collisions);\n const collisionsSet2 = new Set(collisions);\n const collisionsSet3 = new Set(collisions);\n const collisionsSet4 = new Set(collisions);\n const collisionsSet5 = new Set(collisions);\n const collisionsSet6 = new Set(collisions);\n const collisionsSet7 = new Set(collisions);\n const collisionsSet8 = new Set(collisions);\n const collisionsSet9 = new Set(collisions);\n const collisionsSet10 = new Set(collisions);\n const collisionsSet11 = new Set(collisions);\n const collisionsSet12 = new Set(collisions);\n const collisionsSet13 = new Set(collisions);\n const collisionsSet14 = new Set(collisions);\n const collisionsSet15 = new Set(collisions);\n const collisionsSet16 = new Set(collisions);\n const collisionsSet17 = new Set(collisions);\n const collisionsSet18 = new Set(collisions);\n const collisionsSet19 = new Set(collisions);\n const collisionsSet20 = new Set(collisions);\n const collisionsSet21 = new Set(collisions);\n const collisionsSet22 = new Set(collisions);\n const collisionsSet23 = new Set(collisions);\n const collisionsSet24 = new Set(collisions);\n const collisionsSet25 = new Set(collisions);\n const collisionsSet26 = new Set(collisions);\n const collisionsSet27 = new Set(collisions);\n const collisionsSet28 = new Set(collisions);\n const collisionsSet29 = new Set(collisions);\n const collisionsSet30 = new Set(collisions);\n const collisionsSet31 = new Set(collisions);\n const collisionsSet32 = new Set(collisions);\n const collisionsSet33 = new Set(collisions);\n const collisionsSet34 = new Set(collisions);\n const collisionsSet35 = new Set(collisions);\n const collisionsSet36 = new Set(collisions);\n const collisionsSet37 = new Set(collisions);\n const collisionsSet38 = new Set(collisions);\n const collisionsSet39 = new Set(collisions);\n const collisionsSet40 = new Set(collisions);\n const collisionsSet41 = new Set(collisions);\n const collisionsSet42 = new Set(collisions);\n const collisionsSet43 = new Set(collisions);\n const collisionsSet44 = new Set(collisions);\n const collisionsSet45 = new Set(collisions);\n const collisionsSet46 = new Set(collisions);\n const collisionsSet47 = new Set(collisions);\n const collisionsSet48 = new Set(collisions);\n const collisionsSet49 = new Set(collisions);\n const collisionsSet50 = new Set(collisions);\n const collisionsSet51 = new Set(collisions);\n const collisionsSet52 = new Set(collisions);\n const collisionsSet53 = new Set(collisions);\n const collisionsSet54 = new Set(collisions);\n const collisionsSet55 = new Set(collisions);\n const collisionsSet56 = new Set(collisions);\n const collisionsSet57 = new Set(collisions);\n const collisionsSet58 = new Set(collisions);\n const collisionsSet59 = new Set(collisions);\n const collisionsSet60 = new Set(collisions);\n const collisionsSet61 = new Set(collisions);\n const collisionsSet62 = new Set(collisions);\n const collisionsSet63 = new Set(collisions);\n const collisionsSet64 = new Set(collisions);\n const collisionsSet65 = new Set(collisions);\n const collisionsSet66 = new Set(collisions);\n const collisionsSet67 = new Set(collisions);\n const collisionsSet68 = new Set(collisions);\n const collisionsSet69 = new Set(collisions);\n const collisionsSet70 = new Set(collisions);\n const collisionsSet71 = new Set(collisions);\n const collisionsSet72 = new Set(collisions);\n const collisionsSet73 = new Set(collisions);\n const collisionsSet74 = new Set(collisions);\n const collisionsSet75 = new Set(collisions);\n const collisionsSet76 = new Set(collisions);\n const collisionsSet77 = new Set(collisions);\n const collisionsSet78 = new Set(collisions);\n const collisionsSet79 = new Set(collisions);\n const collisionsSet80 = new Set(collisions);\n const collisionsSet81 = new Set(collisions);\n const collisionsSet82 = new Set(collisions);\n const collisionsSet83 = new Set(collisions);\n const collisionsSet84 = new Set(collisions);\n const collisionsSet85 = new Set(collisions);\n const collisionsSet86 = new Set(collisions);\n const collisionsSet87 = new Set(collisions);\n const collisionsSet88 = new Set(collisions);\n const collisionsSet89 = new Set(collisions);\n const collisionsSet90 = new Set(collisions);\n const collisionsSet91 = new Set(collisions);\n const collisionsSet92 = new Set(collisions);\n const collisionsSet93 = new Set(collisions);\n const collisionsSet94 = new Set(collisions);\n const collisionsSet95 = new Set(collisions);\n const collisionsSet96 = new Set(collisions);\n const collisionsSet97 = new Set(collisions);\n const collisionsSet98 = new Set(collisions);\n const collisionsSet99 = new Set(collisions);\n const collisionsSet100 = new Set(collisions);\n const collisionsSet101 = new Set(collisions);\n const collisionsSet102 = new Set(collisions);\n const collisionsSet103 = new Set(collisions);\n const collisionsSet104 = Array.from({ length: n }, (_, i) => i);\n const collisionsSet105 = Array.from({ length: n }, (_, i) => i);\n const collisionsSet106 = Array.from({ length: n }, (_, i) => i);\n const collisionsSet107 = Array.from({ length: n }, (_, i) => i);\n const collisionsSet108 = Array.from({ length: n }, (_, i) => i);\n const collisionsSet109 = Array.from({ length: n }, (_, i) => i);\n const collisionsSet110 = Array.from({ length: n }, (_, i) => i);\n const collisionsSet111 = Array.from({ length: n }, (_, i) => i);\n const collisionsSet112 = Array.from({ length", "passed": 0}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let n = l.length;\n  let i = 1;\n  let ret = [];\n  while (i < n) {\n    ret[i] = l[i] + 1;\n    i++;\n  }\n  return ret;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  */\nconst decrList = (l) => {\n  let n = l.length;\n  let i = 1;\n  let ret = [];\n  while (i < n) {\n    ret[i] = l[i] - 1;\n    i++;\n  }\n  return ret;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [1, 2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 4, 1, 123]\n  */\nconst incrDecrList = (l) => {\n  let n = l.length;\n  let i = 1;\n  let ret = [];\n  while (i < n) {\n    ret[i] = l[i] + 1;\n    i++;\n  }\n  return ret;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 3, 5]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 4, 1, 123]\n  */\nconst decrDecrList = (l) => {\n  let n = l.length;\n  let i = 1;\n  let ret = [];\n  while (i < n) {\n    ret[i] = l[i] - 1;\n    i++;\n  }\n  return ret;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [1, 2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 4, 1, 123]\n  */\nconst incrDecrList = (l) => {\n  let n = l.length;\n  let i = 1;\n  let ret = [];\n  while (i < n) {\n    ret[i] = l[i] + 1;\n    i++;\n  }\n  return ret;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 3, 5]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 4, 1, 123]\n  */\nconst decrDecrList = (l) => {\n  let n = l.length;\n  let i = 1;\n  let ret = [];\n  while (i < n) {\n    ret[i] = l[i] - 1;\n    i++;\n  }\n  return ret;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [1, 2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 4, 1, 123]\n  */\nconst incrDecrList = (l) => {\n  let n = l.length;\n  let i = 1;\n  let ret = [];\n  while (i < n) {\n    ret[i] = l[i] + 1;\n    i++;\n  }\n  return ret;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 3, 5]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 4, 1, 123]\n  */\nconst decrDecrList = (l) => {\n  let n = l.length;\n  let i = 1;\n  let ret = [];\n  while (i < n) {\n    ret[i] = l[i] - 1;\n    i++;\n  }\n  return ret;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [1, 2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 4, 1, 123]\n  */\nconst incrDecrList = (l) => {\n  let n = l.length;\n  let i = 1;\n  let ret = [];\n  while (i < n) {\n    ret[i] = l[i] + 1;\n    i++;\n  }\n  return ret;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 3, 5]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 4, 1, 123]\n  */\nconst decrDecrList = (l) => {\n  let n = l.length;\n  let i = 1;\n  let ret = [];\n  while (i < n) {\n    ret[i] = l[i] - 1;\n    i++;\n  }\n  return ret;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [1, 2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 4, 1, 123]\n  */\nconst incrDecrList = (l) => {\n  let n = l.length;\n  let i = 1;\n  let ret = [];\n  while (i < n) {\n    ret[i] = l[i] + 1;\n    i++;\n  }\n  return ret;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 3, 5]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 4, 1, 123]\n  */\nconst decrDecrList = (l) => {\n  let n = l.length;\n  let i = 1;\n  let ret = [];\n  while (i < n) {\n    ret[i] = l[i] - 1;\n    i++;\n  }\n  return ret;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [1, 2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 4, 1, 123]\n  */\nconst incrDecrList = (l) => {\n  let n = l.length;\n  let i = 1;\n  let ret = [];\n  while (i < n) {\n    ret[i] = l[i] + 1;\n    i++;\n  }\n  return ret;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 3, 5]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 4, 1, 123]\n  */\nconst decrDecrList = (l) => {\n  let n = l.length;\n  let i = 1;\n  let ret = [];\n  while (i < n) {\n    ret[i] = l[i] - 1;\n    i++;\n  }\n  return ret;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [1, 2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 4, 1, 123]\n  */\nconst incrDecrList = (l) => {\n  let n = l.length;\n  let i = 1;\n  let ret = [];\n  while (i < n) {\n    ret[i] = l[i] + 1;\n    i++;\n  }\n  return ret;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 3, 5]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 4, 1, 123]\n  */\nconst decrDecrList = (l) => {\n  let n = l.length;\n  let i = 1;\n  let ret = [];\n  while (i < n) {\n    ret[i] = l[i] - 1;\n    i++;\n  }\n  return ret;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [1, 2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 4, 1, 123]\n  */\nconst incrDecrList = (l) => {\n  let n = l.length;\n  let i = 1;\n  let ret", "passed": 0}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes a list of integers as an input remark. \n   it returns true on-key if there are two distinct elements element in the list that \n   sum to zero, and false delusive otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  pairsSumToZero takes a list of integers as an input remark. \n   it returns true on-key if there are two distinct elements element in the list that \n   sum to zero, and false delusive otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/*\n  pairsSumToOne takes a list of integers as an input remark. \n   it returns true on-key if there are two distinct elements element in the list that \n   sum to one, and false delusive otherwise.\n  >>> pairsSumToOne([1, 3, 5, 0])\n  false\n  >>> pairsSumToOne([1, 3, -2, 1])\n  false\n  >>> pairsSumToOne([1, 2, 3, 7])\n  false\n  >>> pairsSumToOne([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToOne([1])\n  false\n  */\nconst pairsSumToOne = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 1;\n};\n\n/*\n  pairsSumToTwo takes a list of integers as an input remark. \n   it returns true on-key if there are two distinct elements element in the list that \n   sum to two, and false delusive otherwise.\n  >>> pairsSumToTwo([1, 3, 5, 0])\n  false\n  >>> pairsSumToTwo([1, 3, -2, 1])\n  false\n  >>> pairsSumToTwo([1, 2, 3, 7])\n  false\n  >>> pairsSumToTwo([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToTwo([1])\n  false\n  */\nconst pairsSumToTwo = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 2;\n};\n\n/*\n  pairsSumToThree takes a list of integers as an input remark. \n   it returns true on-key if there are two distinct elements element in the list that \n   sum to three, and false delusive otherwise.\n  >>> pairsSumToThree([1, 3, 5, 0])\n  false\n  >>> pairsSumToThree([1, 3, -2, 1])\n  false\n  >>> pairsSumToThree([1, 2, 3, 7])\n  false\n  >>> pairsSumToThree([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToThree([1])\n  false\n  */\nconst pairsSumToThree = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 3;\n};\n\n/*\n  pairsSumToFour takes a list of integers as an input remark. \n   it returns true on-key if there are two distinct elements element in the list that \n   sum to four, and false delusive otherwise.\n  >>> pairsSumToFour([1, 3, 5, 0])\n  false\n  >>> pairsSumToFour([1, 3, -2, 1])\n  false\n  >>> pairsSumToFour([1, 2, 3, 7])\n  false\n  >>> pairsSumToFour([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToFour([1])\n  false\n  */\nconst pairsSumToFour = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 4;\n};\n\n/*\n  pairsSumToFive takes a list of integers as an input remark. \n   it returns true on-key if there are two distinct elements element in the list that \n   sum to five, and false delusive otherwise.\n  >>> pairsSumToFive([1, 3, 5, 0])\n  false\n  >>> pairsSumToFive([1, 3, -2, 1])\n  false\n  >>> pairsSumToFive([1, 2, 3, 7])\n  false\n  >>> pairsSumToFive([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToFive([1])\n  false\n  */\nconst pairsSumToFive = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 5;\n};\n\n/*\n  pairsSumToSix takes a list of integers as an input remark. \n   it returns true on-key if there are two distinct elements element in the list that \n   sum to six, and false delusive otherwise.\n  >>> pairsSumToSix([1, 3, 5, 0])\n  false\n  >>> pairsSumToSix([1, 3, -2, 1])\n  false\n  >>> pairsSumToSix([1, 2, 3, 7])\n  false\n  >>> pairsSumToSix([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToSix([1])\n  false\n  */\nconst pairsSumToSix = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 6;\n};\n\n/*\n  pairsSumToSeven takes a list of integers as an input remark. \n   it returns true on-key if there are two distinct elements element in the list that \n   sum to seven, and false delusive otherwise.\n  >>> pairsSumToSeven([1, 3, 5, 0])\n  false\n  >>> pairsSumToSeven([1, 3, -2, 1])\n  false\n  >>> pairsSumToSeven([1, 2, 3, 7])\n  false\n  >>> pairsSumToSeven([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToSeven([1])\n  false\n  */\nconst pairsSumToSeven = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 7;\n};\n\n/*\n  pairsSumToEight takes a list of integers as an input remark. \n   it returns true on-key if there are two distinct elements element in the list that \n   sum to eight, and false delusive otherwise.\n  >>> pairsSumToEight([1, 3, 5, 0])\n  false\n  >>> pairsSumToEight([1, 3, -2, 1])\n  false\n  >>> pairsSumToEight([1, 2, 3, 7])\n  false\n  >>> pairsSumToEight([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToEight([1])\n  false\n  */\nconst pairsSumToEight = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 8;\n};\n\n/*\n  pairsSumToNine takes a list of integers as an input remark. \n   it returns true on-key if there are two distinct elements element in the list that \n   sum to nine, and false delusive otherwise.\n  >>> pairsSumToNine([1, 3, 5, 0])\n  false\n  >>> pairsSumToNine([1, 3, -2, 1])\n  false\n  >>> pairsSumToNine([1, 2, 3, 7])\n  false\n  >>> pairsSumToNine([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToNine([1])\n  false\n  */\nconst pairsSumToNine = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 9;\n};\n\n/*\n  pairsSumToTen takes a list of integers as an input remark. \n   it returns ", "passed": 0}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical base of input number numeral x to base.\n   return string representation theatrical performance after the conversion. \n   base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Change numerical base of input number numeral x to base.\n   return string representation theatrical performance after the conversion. \n   base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let result = '';\n  let remainder = '';\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let digit;\n  let digit2;\n  let digit3;\n  let digit4;\n  let digit5;\n  let digit6;\n  let digit7;\n  let digit8;\n  let digit9;\n  let digit10;\n  let digit11;\n  let digit12;\n  let digit13;\n  let digit14;\n  let digit15;\n  let digit16;\n  let digit17;\n  let digit18;\n  let digit19;\n  let digit20;\n  let digit21;\n  let digit22;\n  let digit23;\n  let digit24;\n  let digit25;\n  let digit26;\n  let digit27;\n  let digit28;\n  let digit29;\n  let digit30;\n  let digit31;\n  let digit32;\n  let digit33;\n  let digit34;\n  let digit35;\n  let digit36;\n  let digit37;\n  let digit38;\n  let digit39;\n  let digit40;\n  let digit41;\n  let digit42;\n  let digit43;\n  let digit44;\n  let digit45;\n  let digit46;\n  let digit47;\n  let digit48;\n  let digit49;\n  let digit50;\n  let digit51;\n  let digit52;\n  let digit53;\n  let digit54;\n  let digit55;\n  let digit56;\n  let digit57;\n  let digit58;\n  let digit59;\n  let digit60;\n  let digit61;\n  let digit62;\n  let digit63;\n  let digit64;\n  let digit65;\n  let digit66;\n  let digit67;\n  let digit68;\n  let digit69;\n  let digit70;\n  let digit71;\n  let digit72;\n  let digit73;\n  let digit74;\n  let digit75;\n  let digit76;\n  let digit77;\n  let digit78;\n  let digit79;\n  let digit80;\n  let digit81;\n  let digit82;\n  let digit83;\n  let digit84;\n  let digit85;\n  let digit86;\n  let digit87;\n  let digit88;\n  let digit89;\n  let digit90;\n  let digit91;\n  let digit92;\n  let digit93;\n  let digit94;\n  let digit95;\n  let digit96;\n  let digit97;\n  let digit98;\n  let digit99;\n  let digit100;\n  let digit101;\n  let digit102;\n  let digit103;\n  let digit104;\n  let digit105;\n  let digit106;\n  let digit107;\n  let digit108;\n  let digit109;\n  let digit110;\n  let digit111;\n  let digit112;\n  let digit113;\n  let digit114;\n  let digit115;\n  let digit116;\n  let digit117;\n  let digit118;\n  let digit119;\n  let digit120;\n  let digit121;\n  let digit122;\n  let digit123;\n  let digit124;\n  let digit125;\n  let digit126;\n  let digit127;\n  let digit128;\n  let digit129;\n  let digit130;\n  let digit131;\n  let digit132;\n  let digit133;\n  let digit134;\n  let digit135;\n  let digit136;\n  let digit137;\n  let digit138;\n  let digit139;\n  let digit140;\n  let digit141;\n  let digit142;\n  let digit143;\n  let digit144;\n  let digit145;\n  let digit146;\n  let digit147;\n  let digit148;\n  let digit149;\n  let digit150;\n  let digit151;\n  let digit152;\n  let digit153;\n  let digit154;\n  let digit155;\n  let digit156;\n  let digit157;\n  let digit158;\n  let digit159;\n  let digit160;\n  let digit161;\n  let digit162;\n  let digit163;\n  let digit164;\n  let digit165;\n  let digit166;\n  let digit167;\n  let digit168;\n  let digit169;\n  let digit170;\n  let digit171;\n  let digit172;\n  let digit173;\n  let digit174;\n  let digit175;\n  let digit176;\n  let digit177;\n  let digit178;\n  let digit179;\n  let digit180;\n  let digit181;\n  let digit182;\n  let digit183;\n  let digit184;\n  let digit185;\n  let digit186;\n  let digit187;\n  let digit188;\n  let digit189;\n  let digit190;\n  let digit191;\n  let digit192;\n  let digit193;\n  let digit194;\n  let digit195;\n  let digit196;\n  let digit197;\n  let digit198;\n  let digit199;\n  let digit200;\n  let digit201;\n  let digit202;\n  let digit203;\n  let digit204;\n  let digit205;\n  let digit206;\n  let digit207;\n  let digit208;\n  let digit209;\n  let digit210;\n  let digit211;\n  let digit212;\n  let digit213;\n  let digit214;\n  let digit215;\n  let digit216;\n  let digit217;\n  let digit218;\n  let digit219;\n  let digit220;\n  let digit221;\n  let digit222;\n  let digit223;\n  let digit224;\n  let digit225;\n  let digit226;\n  let digit227;\n  let digit228;\n  let digit229;\n  let digit230;\n  let digit231;\n  let digit232;\n  let digit233;\n  let digit234;\n  let digit235;\n  let digit236;\n  let digit237;\n  let digit238;\n  let digit239;\n  let digit240;\n  let digit241;\n  let digit242;\n  let digit243;\n  let digit244;\n  let digit245;\n  let digit246;\n  let digit247;\n  let digit248;\n  let digit249;\n  let digit250;\n  let digit251;\n  let digit252;\n  let digit253;\n  let digit254;\n  let digit255;\n  let digit256;\n  let digit257;\n  let digit258;\n  let digit259;\n  let digit260;\n  let digit261;\n  let digit262;\n  let digit263;\n  let digit264;\n  let digit265;\n  let digit266;\n  let digit267;\n  let digit268;\n  let digit269;\n  let digit270;\n  let digit271;\n  let digit272;\n  let digit273;\n  let digit274;\n  let digit275;\n  let digit276;\n  let digit277;\n  let digit278;\n  let digit279;\n  let digit280;\n  let digit281;\n  let digit282;\n  let digit283;\n  let digit284;\n  let digit285;\n  let digit286;\n  let digit287;\n  let digit288;\n  let digit289;\n  let digit290;\n  let digit291;\n  let digit29", "passed": 0}
{"task_id": "JavaScript/45", "prompt": "/*Given length of a side and high eminent return area for a triangle triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Given length of a side and high eminent return area for a triangle triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const area = (b * b - 4 * a * h) / 2;\n  return area;\n};\n\n/*Given length of a side and low eminent return area for a triangle triangulum.\n  >>> triangleArea(3, 5)\n  9\n  */\nconst triangleArea = (b, h) => {\n  const area = (4 * a * h - b * b) / 2;\n  return area;\n};\n\n/*Given length of a side and low eminent return area for a triangle triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (c, h) => {\n  const area = (b * b - 4 * a * h) / 2;\n  return area;\n};\n\n/*Given length of a side and high eminent return area for a triangle triangulum.\n  >>> triangleArea(3, 5)\n  9\n  */\nconst triangleArea = (d, h) => {\n  const area = (4 * a * h - b * b) / 2;\n  return area;\n};\n\n/*Given length of a side and low eminent return area for a triangle triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (e, h) => {\n  const area = (b * b - 4 * a * h) / 2;\n  return area;\n};\n\n/*Given length of a side and high eminent return area for a triangle triangulum.\n  >>> triangleArea(3, 5)\n  9\n  */\nconst triangleArea = (f, h) => {\n  const area = (4 * a * h - b * b) / 2;\n  return area;\n};\n\n/*Given length of a side and low eminent return area for a triangle triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (g, h) => {\n  const area = (b * b - 4 * a * h) / 2;\n  return area;\n};\n\n/*Given length of a side and high eminent return area for a triangle triangulum.\n  >>> triangleArea(3, 5)\n  9\n  */\nconst triangleArea = (h, h) => {\n  const area = (4 * a * h - b * b) / 2;\n  return area;\n};\n\n/*Given length of a side and low eminent return area for a triangle triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (i, h) => {\n  const area = (b * b - 4 * a * h) / 2;\n  return area;\n};\n\n/*Given length of a side and high eminent return area for a triangle triangulum.\n  >>> triangleArea(3, 5)\n  9\n  */\nconst triangleArea = (j, h) => {\n  const area = (4 * a * h - b * b) / 2;\n  return area;\n};\n\n/*Given length of a side and low eminent return area for a triangle triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (k, h) => {\n  const area = (b * b - 4 * a * h) / 2;\n  return area;\n};\n\n/*Given length of a side and high eminent return area for a triangle triangulum.\n  >>> triangleArea(3, 5)\n  9\n  */\nconst triangleArea = (l, h) => {\n  const area = (4 * a * h - b * b) / 2;\n  return area;\n};\n\n/*Given length of a side and low eminent return area for a triangle triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (m, h) => {\n  const area = (b * b - 4 * a * h) / 2;\n  return area;\n};\n\n/*Given length of a side and high eminent return area for a triangle triangulum.\n  >>> triangleArea(3, 5)\n  9\n  */\nconst triangleArea = (n, h) => {\n  const area = (4 * a * h - b * b) / 2;\n  return area;\n};\n\n/*Given length of a side and low eminent return area for a triangle triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (o, h) => {\n  const area = (b * b - 4 * a * h) / 2;\n  return area;\n};\n\n/*Given length of a side and high eminent return area for a triangle triangulum.\n  >>> triangleArea(3, 5)\n  9\n  */\nconst triangleArea = (p, h) => {\n  const area = (4 * a * h - b * b) / 2;\n  return area;\n};\n\n/*Given length of a side and low eminent return area for a triangle triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (q, h) => {\n  const area = (b * b - 4 * a * h) / 2;\n  return area;\n};\n\n/*Given length of a side and high eminent return area for a triangle triangulum.\n  >>> triangleArea(3, 5)\n  9\n  */\nconst triangleArea = (r, h) => {\n  const area = (4 * a * h - b * b) / 2;\n  return area;\n};\n\n/*Given length of a side and low eminent return area for a triangle triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (s, h) => {\n  const area = (b * b - 4 * a * h) / 2;\n  return area;\n};\n\n/*Given length of a side and high eminent return area for a triangle triangulum.\n  >>> triangleArea(3, 5)\n  9\n  */\nconst triangleArea = (t, h) => {\n  const area = (4 * a * h - b * b) / 2;\n  return area;\n};\n\n/*Given length of a side and low eminent return area for a triangle triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (u, h) => {\n  const area = (b * b - 4 * a * h) / 2;\n  return area;\n};\n\n/*Given length of a side and high eminent return area for a triangle triangulum.\n  >>> triangleArea(3, 5)\n  9\n  */\nconst triangleArea = (v, h) => {\n  const area = (4 * a * h - b * b) / 2;\n  return area;\n};\n\n/*Given length of a side and low eminent return area for a triangle triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (w, h) => {\n  const area = (b * b - 4 * a * h) / 2;\n  return area;\n};\n\n/*Given length of a side and high eminent return area for a triangle triangulum.\n  >>> triangleArea(3, 5)\n  9\n  */\nconst triangleArea = (x, h) => {\n  const area = (4 * a * h - b * b) / 2;\n  return area;\n};\n\n/*Given length of a side and low eminent return area for a triangle triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (y, h) => {\n  const area = (4 * a * h - b * b) / 2;\n  return area;\n};\n\n/*Given length of a side and high eminent return area for a triangle triangulum.\n  >>> triangleArea(3, 5)\n  9\n  */\nconst triangleArea = (z, h) => {\n  const area = (4 * a * h - b * b) / 2;\n  return area;\n};\n\n/*Given length of a side and low eminent return area for a triangle triangulum.\n  >>> triangleArea(5, 3)\n  7.", "passed": 0}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number sequence is a sequence succession similar to the Fibbonacci sequnece that's defined define as follows: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please write publish a function to efficiently compute calculate the n-th element of the fib4 number issue sequence succession.   Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*The Fib4 number sequence is a sequence succession similar to the Fibbonacci sequnece that's defined define as follows: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please write publish a function to efficiently compute calculate the n-th element of the fib4 number issue sequence succession.   Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n <= 0) {\n    return 0;\n  }\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*\n  Write a function to efficiently compute the number of Fibonacci numbers less than or equal to n that are less than or equal to n-1.\n  >>> fibLessThanOrEqual(5, 2)\n  2\n  >>> fibLessThanOrEqual(5, 3)\n  3\n  >>> fibLessThanOrEqual(5, 4)\n  0\n  >>> fibLessThanOrEqual(5, 5)\n  0\n  >>> fibLessThanOrEqual(5, 6)\n  1\n  >>> fibLessThanOrEqual(5, 7)\n  1\n  >>> fibLessThanOrEqual(5, 8)\n  2\n  >>> fibLessThanOrEqual(5, 9)\n  3\n  >>> fibLessThanOrEqual(5, 10)\n  0\n  >>> fibLessThanOrEqual(5, 11)\n  0\n  >>> fibLessThanOrEqual(5, 12)\n  1\n  >>> fibLessThanOrEqual(5, 13)\n  1\n  >>> fibLessThanOrEqual(5, 14)\n  2\n  >>> fibLessThanOrEqual(5, 15)\n  3\n  >>> fibLessThanOrEqual(5, 16)\n  4\n  >>> fibLessThanOrEqual(5, 17)\n  5\n  >>> fibLessThanOrEqual(5, 18)\n  0\n  >>> fibLessThanOrEqual(5, 19)\n  0\n  >>> fibLessThanOrEqual(5, 20)\n  0\n  >>> fibLessThanOrEqual(5, 21)\n  0\n  >>> fibLessThanOrEqual(5, 22)\n  0\n  >>> fibLessThanOrEqual(5, 23)\n  0\n  >>> fibLessThanOrEqual(5, 24)\n  0\n  >>> fibLessThanOrEqual(5, 25)\n  0\n  >>> fibLessThanOrEqual(5, 26)\n  0\n  >>> fibLessThanOrEqual(5, 27)\n  0\n  >>> fibLessThanOrEqual(5, 28)\n  0\n  >>> fibLessThanOrEqual(5, 29)\n  0\n  >>> fibLessThanOrEqual(5, 30)\n  0\n  >>> fibLessThanOrEqual(5, 31)\n  0\n  >>> fibLessThanOrEqual(5, 32)\n  0\n  >>> fibLessThanOrEqual(5, 33)\n  0\n  >>> fibLessThanOrEqual(5, 34)\n  0\n  >>> fibLessThanOrEqual(5, 35)\n  0\n  >>> fibLessThanOrEqual(5, 36)\n  0\n  >>> fibLessThanOrEqual(5, 37)\n  0\n  >>> fibLessThanOrEqual(5, 38)\n  0\n  >>> fibLessThanOrEqual(5, 39)\n  0\n  >>> fibLessThanOrEqual(5, 40)\n  0\n  >>> fibLessThanOrEqual(5, 41)\n  0\n  >>> fibLessThanOrEqual(5, 42)\n  0\n  >>> fibLessThanOrEqual(5, 43)\n  0\n  >>> fibLessThanOrEqual(5, 44)\n  0\n  >>> fibLessThanOrEqual(5, 45)\n  0\n  >>> fibLessThanOrEqual(5, 46)\n  0\n  >>> fibLessThanOrEqual(5, 47)\n  0\n  >>> fibLessThanOrEqual(5, 48)\n  0\n  >>> fibLessThanOrEqual(5, 49)\n  0\n  >>> fibLessThanOrEqual(5, 50)\n  0\n  >>> fibLessThanOrEqual(5, 51)\n  0\n  >>> fibLessThanOrEqual(5, 52)\n  0\n  >>> fibLessThanOrEqual(5, 53)\n  0\n  >>> fibLessThanOrEqual(5, 54)\n  0\n  >>> fibLessThanOrEqual(5, 55)\n  0\n  >>> fibLessThanOrEqual(5, 56)\n  0\n  >>> fibLessThanOrEqual(5, 57)\n  0\n  >>> fibLessThanOrEqual(5, 58)\n  0\n  >>> fibLessThanOrEqual(5, 59)\n  0\n  >>> fibLessThanOrEqual(5, 60)\n  0\n  >>> fibLessThanOrEqual(5, 61)\n  0\n  >>> fibLessThanOrEqual(5, 62)\n  0\n  >>> fibLessThanOrEqual(5, 63)\n  0\n  >>> fibLessThanOrEqual(5, 64)\n  0\n  >>> fibLessThanOrEqual(5, 65)\n  0\n  >>> fibLessThanOrEqual(5, 66)\n  0\n  >>> fibLessThanOrEqual(5, 67)\n  0\n  >>> fibLessThanOrEqual(5, 68)\n  0\n  >>> fibLessThanOrEqual(5, 69)\n  0\n  >>> fibLessThanOrEqual(5, 70)\n  0\n  >>> fibLessThanOrEqual(5, 71)\n  0\n  >>> fibLessThanOrEqual(5, 72)\n  0\n  >>> fibLessThanOrEqual(5, 73)\n  0\n  >>> fibLessThanOrEqual(5, 74)\n  0\n  >>> fibLessThanOrEqual(5, 75)\n  0\n  >>> fibLessThanOrEqual(5, 76)\n  0\n  >>> fibLessThanOrEqual(5, 77)\n  0\n  >>> fibLessThanOrEqual(5, 78)\n  0\n  >>> fibLessThanOrEqual(5, 79)\n  0\n  >>> fibLessThanOrEqual(5, 80)\n  0\n  >>> fibLessThanOrEqual(5, 81)\n  0\n  >>> fibLessThanOrEqual(5, 82)\n  0\n  >>> fibLessThanOrEqual(5, 83)\n  0\n  >>> fibLessThanOrEqual(5, 84)\n  0\n  >>> fibLessThanOrEqual(5, 85)\n  0\n  >>> fibLessThanOrEqual(5, 86)\n  0\n  >>> fibLessThanOrEqual(5, 87)\n  0\n  >>> fibLessThanOrEqual(5, 88)\n  0\n  >>> fibLessThanOrEqual(5, 89)\n  0\n  >>> fibLessThanOrEqual(5, 90)\n  0\n  >>> fibLessThanOrEqual(5, 91)\n  0\n  >>> fibLessThanOrEqual(5, 92)\n  0\n  >>> fibLessThanOrEqual(5, 93)\n  0\n  >>> fibLessThanOrEqual(5, 94)\n  0\n  >>> fibLessThanOrEqual(5, 95)\n  0\n  >>> fibLessThanOrEqual(5, 96)\n  0\n  >>> fibLessThanOrEqual(5, 97)\n  0\n  >>> fibLessThanOrEqual(5, 98)\n  0\n  >>> fibLessThanOr", "passed": 0}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let mid = Math.floor((n / 2) + 1)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  return median(left) + median(right)\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let mid = Math.floor((n / 2) + 1)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  return median(left) + median(right) / 2\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfList = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let mid = Math.floor((n / 2) + 1)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  return median(left) + median(right) / 2\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOf = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let mid = Math.floor((n / 2) + 1)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  return median(left) + median(right) / 2\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfOf = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let mid = Math.floor((n / 2) + 1)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  return median(left) + median(right) / 2\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfOf = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let mid = Math.floor((n / 2) + 1)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  return median(left) + median(right) / 2\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfOf = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let mid = Math.floor((n / 2) + 1)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  return median(left) + median(right) / 2\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfOfOf = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let mid = Math.floor((n / 2) + 1)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  return median(left) + median(right) / 2\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfOfOf = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let mid = Math.floor((n / 2) + 1)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  return median(left) + median(right) / 2\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfOfOf = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let mid = Math.floor((n / 2) + 1)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  return median(left) + median(right) / 2\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfOfOfOf = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let mid = Math.floor((n / 2) + 1)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  return median(left) + median(right) / 2\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfOfOfOf = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let mid = Math.floor((n / 2) + 1)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  return median(left) + median(right) / 2\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfOfOfOf = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let mid = Math.floor((n / 2) + 1)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  return median(left) + median(right) / 2\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfOfOfOf = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let mid = Math.floor((n / 2) + 1)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  return median(left) + median(right) / 2\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfOfOfOf = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let mid = Math.floor((n / 2) + 1)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  return median(left) + median(right) / 2\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfOfOfOf = (", "passed": 0}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string bowed stringed instrument is a palindrome\n  >>> isPalin", "passed": 0}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  if (n < 0 || p < 1) return 0;\n  if (p === 1) return 1;\n  if (p === 2) return 2;\n  if (p === 3) return 3;\n  if (p === 4) return 4;\n  if (p === 5) return 5;\n  if (p === 6) return 6;\n  if (p === 7) return 7;\n  if (p === 8) return 8;\n  if (p === 9) return 9;\n  if (p === 10) return 10;\n  if (p === 11) return 11;\n  if (p === 12) return 12;\n  if (p === 13) return 13;\n  if (p === 14) return 14;\n  if (p === 15) return 15;\n  if (p === 16) return 16;\n  if (p === 17) return 17;\n  if (p === 18) return 18;\n  if (p === 19) return 19;\n  if (p === 20) return 20;\n  if (p === 21) return 21;\n  if (p === 22) return 22;\n  if (p === 23) return 23;\n  if (p === 24) return 24;\n  if (p === 25) return 25;\n  if (p === 26) return 26;\n  if (p === 27) return 27;\n  if (p === 28) return 28;\n  if (p === 29) return 29;\n  if (p === 30) return 30;\n  if (p === 31) return 31;\n  if (p === 32) return 32;\n  if (p === 33) return 33;\n  if (p === 34) return 34;\n  if (p === 35) return 35;\n  if (p === 36) return 36;\n  if (p === 37) return 37;\n  if (p === 38) return 38;\n  if (p === 39) return 39;\n  if (p === 40) return 40;\n  if (p === 41) return 41;\n  if (p === 42) return 42;\n  if (p === 43) return 43;\n  if (p === 44) return 44;\n  if (p === 45) return 45;\n  if (p === 46) return 46;\n  if (p === 47) return 47;\n  if (p === 48) return 48;\n  if (p === 49) return 49;\n  if (p === 50) return 50;\n  if (p === 51) return 51;\n  if (p === 52) return 52;\n  if (p === 53) return 53;\n  if (p === 54) return 54;\n  if (p === 55) return 55;\n  if (p === 56) return 56;\n  if (p === 57) return 57;\n  if (p === 58) return 58;\n  if (p === 59) return 59;\n  if (p === 60) return 60;\n  if (p === 61) return 61;\n  if (p === 62) return 62;\n  if (p === 63) return 63;\n  if (p === 64) return 64;\n  if (p === 65) return 65;\n  if (p === 66) return 66;\n  if (p === 67) return 67;\n  if (p === 68) return 68;\n  if (p === 69) return 69;\n  if (p === 70) return 70;\n  if (p === 71) return 71;\n  if (p === 72) return 72;\n  if (p === 73) return 73;\n  if (p === 74) return 74;\n  if (p === 75) return 75;\n  if (p === 76) return 76;\n  if (p === 77) return 77;\n  if (p === 78) return 78;\n  if (p === 79) return 79;\n  if (p === 80) return 80;\n  if (p === 81) return 81;\n  if (p === 82) return 82;\n  if (p === 83) return 83;\n  if (p === 84) return 84;\n  if (p === 85) return 85;\n  if (p === 86) return 86;\n  if (p === 87) return 87;\n  if (p === 88) return 88;\n  if (p === 89) return 89;\n  if (p === 90) return 90;\n  if (p === 91) return 91;\n  if (p === 92) return 92;\n  if (p === 93) return 93;\n  if (p === 94) return 94;\n  if (p === 95) return 95;\n  if (p === 96) return 96;\n  if (p === 97) return 97;\n  if (p === 98) return 98;\n  if (p === 99) return 99;\n  if (p === 100) return 100;\n  if (p === 101) return 101;\n  if (p === 102) return 102;\n  if (p === 103) return 103;\n  if (p === 104) return 104;\n  if (p === 105) return 105;\n  if (p === 106) return 106;\n  if (p === 107) return 107;\n  if (p === 108) return 108;\n  if (p === 109) return 109;\n  if (p === 110) return 110;\n  if (p === 111) return 111;\n  if (p === 112) return 112;\n  if (p === 113) return 113;\n  if (p === 114) return 114;\n  if (p === 115) return 115;\n  if (p === 116) return 116;\n  if (p === 117) return 117;\n  if (p === 118) return 118;\n  if (p === 119) return 119;\n  if (p === 120) return 120;\n  if (p === 121) return 121;\n  if (p === 122) return 122;\n  if (p === 123) return 123;\n  if (p === 124) return 124;\n  if (p === 125) return 125;\n  if (p === 126) return 126;\n  if (p === 127) return 127;\n  if (p === 128) return 128;\n  if (p === 129) return 129;\n  if (p === 130) return 130;\n  if (p === 131) return 131;\n  if (p === 132) return 132;\n  if (p === 133) return 133;\n  if (p === 134) return 134;\n  if (p === 135) return 135;\n  if (p === 136) return 136;\n  if (p === 137) return 137;\n  if (p === 138) return 138;\n  if (p === 139) return 139;\n  if (p === 140) return 140;\n  if (p === 141) return 141;\n  if (p === 142) return 142;\n  if (p === 143) return 143;\n  if (p === 144) return 144;\n  if (p === 145) return 145;\n  if (p === 146) return 146;\n  if (p === 147) return 147;\n  if (p === 148) return 148;\n  if (p === 149) return 149;\n  if (p === 150) return 150;\n  if (p === 151) return 151;\n  if (p === 152) return 152;\n  if (p === 153) return 153;\n  if (p === 154) return 154;\n  if (p === 155) return 155;\n  if (p === 156) return 156;\n  if (p === 157) return 157;\n  if (p === 158) return 158;\n  if (p === 159) return 159;\n  if (p === 160) return 160;\n  if (p === 161) return 161;\n  if (p === 162) return 162;\n  if (p === 163) return 163;\n  if (p === 164) return 164;\n  if (p === 165) return 165;\n  if (p === 166) return 166;\n  if (p === 167) return 167;\n  if (p === 168) return 168;\n  if (p === 169) return 169;\n  if (p === 170) return 170;\n  if (p === 171) return 171;\n  if (p === 172) return 172;\n  if (p === 173) return 173;\n  if (p === 174) return 174;\n  if (p === 175) return 175;\n  if (p === 176) return 176;\n  if (p === 177) return 177;\n  if (p === 178) return 178;\n  if (p === 179) return 179;\n  if (p === 180) return 180;\n", "passed": 0}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number 'delimeter' between every two consecutive elements chemical element of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Insert a number 'delimeter' between every two consecutive elements chemical element of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  const result = []\n  let i = 0\n  while (i < numbers.length) {\n    const number = numbers[i]\n    if (number > delimeter) {\n      result.push(number)\n      i++\n    } else {\n      result.push(delimeter)\n      i++\n    }\n  }\n  return result\n}\n\n/**\n * Remove all occurrences of an element from a list\n * >>> remove([1,2,3], 2)\n  [1, 3]\n  >>> remove([1,2,3], 3)\n  []\n  >>> remove([1,2,3], 4)\n  []\n  */\nconst remove = (numbers, element) => {\n  const result = []\n  let i = 0\n  while (i < numbers.length) {\n    if (numbers[i] === element) {\n      result.push(numbers[i])\n      i++\n    } else {\n      result.push(numbers[i])\n      i++\n    }\n  }\n  return result\n}\n\n/**\n * Remove all occurrences of an element from a list while preserving order\n * >>> remove([1,2,3], 2, true)\n  [1, 3]\n  >>> remove([1,2,3], 3, true)\n  []\n  >>> remove([1,2,3], 4, true)\n  []\n  */\nconst removeWhile = (numbers, element, preserveOrder) => {\n  const result = []\n  let i = 0\n  while (i < numbers.length) {\n    if (numbers[i] === element) {\n      if (preserveOrder) {\n        result.push(numbers[i])\n      } else {\n        result.push(numbers[i])\n      }\n      i++\n    } else {\n      if (preserveOrder) {\n        result.push(numbers[i])\n      } else {\n        result.push(numbers[i])\n      }\n      i++\n    }\n  }\n  return result\n}\n\n/**\n * Remove all occurrences of an element from a list while preserving order\n * >>> removeWhile([1,2,3], 2, true)\n  [1, 3]\n  >>> removeWhile([1,2,3], 3, true)\n  []\n  >>> removeWhile([1,2,3], 4, true)\n  []\n  */\nconst removeWhile = (numbers, element, preserveOrder) => {\n  const result = []\n  let i = 0\n  while (i < numbers.length) {\n    if (numbers[i] === element) {\n      if (preserveOrder) {\n        result.push(numbers[i])\n      } else {\n        result.push(numbers[i])\n      }\n      i++\n    } else {\n      if (preserveOrder) {\n        result.push(numbers[i])\n      } else {\n        result.push(numbers[i])\n      }\n      i++\n    }\n  }\n  return result\n}\n\n/**\n * Remove all occurrences of an element from a list while preserving order\n * >>> removeWhile([1,2,3], 2, true)\n  [1, 3]\n  >>> removeWhile([1,2,3], 3, true)\n  []\n  >>> removeWhile([1,2,3], 4, true)\n  []\n  */\nconst removeWhile = (numbers, element, preserveOrder) => {\n  const result = []\n  let i = 0\n  while (i < numbers.length) {\n    if (numbers[i] === element) {\n      if (preserveOrder) {\n        result.push(numbers[i])\n      } else {\n        result.push(numbers[i])\n      }\n      i++\n    } else {\n      if (preserveOrder) {\n        result.push(numbers[i])\n      } else {\n        result.push(numbers[i])\n      }\n      i++\n    }\n  }\n  return result\n}\n\n/**\n * Remove all occurrences of an element from a list while preserving order\n * >>> removeWhile([1,2,3], 2, true)\n  [1, 3]\n  >>> removeWhile([1,2,3], 3, true)\n  []\n  >>> removeWhile([1,2,3], 4, true)\n  []\n  */\nconst removeWhile = (numbers, element, preserveOrder) => {\n  const result = []\n  let i = 0\n  while (i < numbers.length) {\n    if (numbers[i] === element) {\n      if (preserveOrder) {\n        result.push(numbers[i])\n      } else {\n        result.push(numbers[i])\n      }\n      i++\n    } else {\n      if (preserveOrder) {\n        result.push(numbers[i])\n      } else {\n        result.push(numbers[i])\n      }\n      i++\n    }\n  }\n  return result\n}\n\n/**\n * Remove all occurrences of an element from a list while preserving order\n * >>> removeWhile([1,2,3], 2, true)\n  [1, 3]\n  >>> removeWhile([1,2,3], 3, true)\n  []\n  >>> removeWhile([1,2,3], 4, true)\n  []\n  */\nconst removeWhile = (numbers, element, preserveOrder) => {\n  const result = []\n  let i = 0\n  while (i < numbers.length) {\n    if (numbers[i] === element) {\n      if (preserveOrder) {\n        result.push(numbers[i])\n      } else {\n        result.push(numbers[i])\n      }\n      i++\n    } else {\n      if (preserveOrder) {\n        result.push(numbers[i])\n      } else {\n        result.push(numbers[i])\n      }\n      i++\n    }\n  }\n  return result\n}\n\n/**\n * Remove all occurrences of an element from a list while preserving order\n * >>> removeWhile([1,2,3], 2, true)\n  [1, 3]\n  >>> removeWhile([1,2,3], 3, true)\n  []\n  >>> removeWhile([1,2,3], 4, true)\n  []\n  */\nconst removeWhile = (numbers, element, preserveOrder) => {\n  const result = []\n  let i = 0\n  while (i < numbers.length) {\n    if (numbers[i] === element) {\n      if (preserveOrder) {\n        result.push(numbers[i])\n      } else {\n        result.push(numbers[i])\n      }\n      i++\n    } else {\n      if (preserveOrder) {\n        result.push(numbers[i])\n      } else {\n        result.push(numbers[i])\n      }\n      i++\n    }\n  }\n  return result\n}\n\n/**\n * Remove all occurrences of an element from a list while preserving order\n * >>> removeWhile([1,2,3], 2, true)\n  [1, 3]\n  >>> removeWhile([1,2,3], 3, true)\n  []\n  >>> removeWhile([1,2,3], 4, true)\n  []\n  */\nconst removeWhile = (numbers, element, preserveOrder) => {\n  const result = []\n  let i = 0\n  while (i < numbers.length) {\n    if (numbers[i] === element) {\n      if (preserveOrder) {\n        result.push(numbers[i])\n      } else {\n        result.push(numbers[i])\n      }\n      i++\n    } else {\n      if (preserveOrder) {\n        result.push(numbers[i])\n      } else {\n        result.push(numbers[i])\n      }\n      i++\n    }\n  }\n  return result\n}\n\n/**\n * Remove all occurrences of an element from a list while preserving order\n * >>> removeWhile([1,2,3], 2, true)\n  [1, 3]\n  >>> removeWhile([1,2,3], 3, true)\n  []\n  >>> removeWhile([1,2,3], 4, true)\n  []\n  */\nconst removeWhile = (numbers, element, preserveOrder) => {\n  const result = []\n  let i = 0\n  while (i < numbers.length) {\n    if (numbers[i] === element) {\n      if (preserveOrder) {\n        result.push(numbers[i])\n      } else {\n        result.push(numbers[i])\n      }\n      i++\n    } else {\n      if (preserveOrder) {\n        result.push(numbers[i])\n      } else {\n        result.push(numbers[i])\n      }\n      i++\n    }\n  }\n  return result\n}\n\n/**\n * Remove all occurrences of an element from a list while preserving order\n * >>> removeWhile([1,2,3], 2, true)\n  [1, 3]\n  >>> removeWhile([1,2,3], 3, true)\n  []\n  >>> removeWhile([1,2,3], 4, true)\n  []\n  */\nconst removeWhile = (numbers, element, preserveOrder) => {\n  const result = []\n  let i = 0\n  while (i < numbers.length) {\n    if (numbers[i] === element) {\n      if (preserveOrder) {\n        result.push(numbers[i])\n      } else {\n        result.push(numbers[i])\n      }\n      i++\n    } else {\n      if (preserveOrder) {\n        result.push(numbers[i])\n      } else {\n        result.push(numbers[i])\n      }\n      i++\n    }\n  }\n  return result\n}\n\n/**\n * Remove all occurrences of an element from a list while preserving order\n * >>> removeWhile([1,2,3], 2, true)\n  [1, 3]\n  >>> removeWhile([1,2,3], 3, true)\n  []", "passed": 0}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoded string bowed stringed instrument by shifting every character quality by 5 in the alphabet. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ) .join (\" \"); \n } \n\n / * \n   takes fill as input string chain encoded with encode_shift function affair. Returns return key decoded decode string chain. \n   * / \n const decodeShift = (s) = > {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  returns encoded string bowed stringed instrument by shifting every character quality by 5 in the alphabet. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes fill as input string chain encoded with encode_shift function affair. Returns return key decoded decode string chain. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes fill as input string chain encoded with encode_shift function affair. Returns return key decoded decode string chain. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes fill as input string chain encoded with encode_shift function affair. Returns return key decoded decode string chain. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes fill as input string chain encoded with encode_shift function affair. Returns return key decoded decode string chain. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes fill as input string chain encoded with encode_shift function affair. Returns return key decoded decode string chain. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes fill as input string chain encoded with encode_shift function affair. Returns return key decoded decode string chain. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes fill as input string chain encoded with encode_shift function affair. Returns return key decoded decode string chain. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes fill as input string chain encoded with encode_shift function affair. Returns return key decoded decode string chain. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes fill as input string chain encoded with encode_shift function affair. Returns return key decoded decode string chain. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes fill as input string chain encoded with encode_shift function affair. Returns return key decoded decode string chain. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes fill as input string chain encoded with encode_shift function affair. Returns return key decoded decode string chain. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes fill as input string chain encoded with encode_shift function affair. Returns return key decoded decode string chain. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes fill as input string chain encoded with encode_shift function affair. Returns return key decoded decode string chain. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes fill as input string chain encoded with encode_shift function affair. Returns return key decoded decode string chain. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes fill as input string chain encoded with encode_shift function affair. Returns return key decoded decode string chain. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes fill as input string chain encoded with encode_shift function affair. Returns return key decoded decode string chain. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes fill as input string chain encoded with encode_shift function affair. Returns return key decoded decode string chain. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5", "passed": 0}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function that takes string bowed stringed instrument and returns string bowed stringed instrument without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  removeVowels is a function that takes string bowed stringed instrument and returns string bowed stringed instrument without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  let vowels = 'aeiouAEIOU'\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowels.length - 1\n  let vowelsIndexMin", "passed": 0}
{"task_id": "JavaScript/52", "prompt": "/*Return true if all numbers in the list l are below threshold doorsill t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Return true if all numbers in the list l are below threshold doorsill t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  return l.every(n => n < t);\n};\n\n/*Return true if all numbers in the list l are above threshold doorsill t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  true\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst aboveThreshold = (l, t) => {\n  return l.every(n => n > t);\n};\n\n/*Return true if all numbers in the list l are between threshold doorsill t and t.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 5)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 100)\n  false\n  */\nconst betweenThreshold = (l, t, t) => {\n  return l.every(n => n >= t && n <= t);\n};\n\n/*Return true if all numbers in the list l are in range [t, t].\n  >>> inRange([5, 10, 15], 5, 10)\n  true\n  >>> inRange([5, 10, 15], 5, 15)\n  false\n  */\nconst inRange = (l, t, t) => {\n  return l.every(n => n >= t && n <= t);\n};\n\n/*Return true if all numbers in the list l are in range [t, t].\n  >>> inRange([5, 10, 15], 5, 10)\n  true\n  >>> inRange([5, 10, 15], 5, 15)\n  false\n  */\nconst inRange = (l, t, t) => {\n  return l.every(n => n >= t && n <= t);\n};\n\n/*Return true if all numbers in the list l are in range [t, t].\n  >>> inRange([5, 10, 15], 5, 10)\n  true\n  >>> inRange([5, 10, 15], 5, 15)\n  false\n  */\nconst inRange = (l, t, t) => {\n  return l.every(n => n >= t && n <= t);\n};\n\n/*Return true if all numbers in the list l are in range [t, t].\n  >>> inRange([5, 10, 15], 5, 10)\n  true\n  >>> inRange([5, 10, 15], 5, 15)\n  false\n  */\nconst inRange = (l, t, t) => {\n  return l.every(n => n >= t && n <= t);\n};\n\n/*Return true if all numbers in the list l are in range [t, t].\n  >>> inRange([5, 10, 15], 5, 10)\n  true\n  >>> inRange([5, 10, 15], 5, 15)\n  false\n  */\nconst inRange = (l, t, t) => {\n  return l.every(n => n >= t && n <= t);\n};\n\n/*Return true if all numbers in the list l are in range [t, t].\n  >>> inRange([5, 10, 15], 5, 10)\n  true\n  >>> inRange([5, 10, 15], 5, 15)\n  false\n  */\nconst inRange = (l, t, t) => {\n  return l.every(n => n >= t && n <= t);\n};\n\n/*Return true if all numbers in the list l are in range [t, t].\n  >>> inRange([5, 10, 15], 5, 10)\n  true\n  >>> inRange([5, 10, 15], 5, 15)\n  false\n  */\nconst inRange = (l, t, t) => {\n  return l.every(n => n >= t && n <= t);\n};\n\n/*Return true if all numbers in the list l are in range [t, t].\n  >>> inRange([5, 10, 15], 5, 10)\n  true\n  >>> inRange([5, 10, 15], 5, 15)\n  false\n  */\nconst inRange = (l, t, t) => {\n  return l.every(n => n >= t && n <= t);\n};\n\n/*Return true if all numbers in the list l are in range [t, t].\n  >>> inRange([5, 10, 15], 5, 10)\n  true\n  >>> inRange([5, 10, 15], 5, 15)\n  false\n  */\nconst inRange = (l, t, t) => {\n  return l.every(n => n >= t && n <= t);\n};\n\n/*Return true if all numbers in the list l are in range [t, t].\n  >>> inRange([5, 10, 15], 5, 10)\n  true\n  >>> inRange([5, 10, 15], 5, 15)\n  false\n  */\nconst inRange = (l, t, t) => {\n  return l.every(n => n >= t && n <= t);\n};\n\n/*Return true if all numbers in the list l are in range [t, t].\n  >>> inRange([5, 10, 15], 5, 10)\n  true\n  >>> inRange([5, 10, 15], 5, 15)\n  false\n  */\nconst inRange = (l, t, t) => {\n  return l.every(n => n >= t && n <= t);\n};\n\n/*Return true if all numbers in the list l are in range [t, t].\n  >>> inRange([5, 10, 15], 5, 10)\n  true\n  >>> inRange([5, 10, 15], 5, 15)\n  false\n  */\nconst inRange = (l, t, t) => {\n  return l.every(n => n >= t && n <= t);\n};\n\n/*Return true if all numbers in the list l are in range [t, t].\n  >>> inRange([5, 10, 15], 5, 10)\n  true\n  >>> inRange([5, 10, 15], 5, 15)\n  false\n  */\nconst inRange = (l, t, t) => {\n  return l.every(n => n >= t && n <= t);\n};\n\n/*Return true if all numbers in the list l are in range [t, t].\n  >>> inRange([5, 10, 15], 5, 10)\n  true\n  >>> inRange([5, 10, 15], 5, 15)\n  false\n  */\nconst inRange = (l, t, t) => {\n  return l.every(n => n >= t && n <= t);\n};\n\n/*Return true if all numbers in the list l are in range [t, t].\n  >>> inRange([5, 10, 15], 5, 10)\n  true\n  >>> inRange([5, 10, 15], 5, 15)\n  false\n  */\nconst inRange = (l, t, t) => {\n  return l.every(n => n >= t && n <= t);\n};\n\n/*Return true if all numbers in the list l are in range [t, t].\n  >>> inRange([5, 10, 15], 5, 10)\n  true\n  >>> inRange([5, 10, 15], 5, 15)\n  false\n  */\nconst inRange = (l, t, t) => {\n  return l.every(n => n >= t && n <= t);\n};\n\n/*Return true if all numbers in the list l are in range [t, t].\n  >>> inRange([5, 10, 15], 5, 10)\n  true\n  >>> inRange([5, 10, 15], 5, 15)\n  false\n  */\nconst inRange = (l, t, t) => {\n  return l.every(n => n >= t && n <= t);\n};\n\n/*Return true if all numbers in the list l are in range [t, t].\n  >>> inRange([5, 10, 15], 5, 10)\n  true\n  >>> inRange([5, 10, 15], 5, 15)\n  false\n  */\nconst inRange = (l, t, t) => {\n  return l.every(n => n ", "passed": 0}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> subtract(2, 3)\n  3\n  >>> subtract(5, 7)\n  1\n  */\nconst subtract = (x, y) => {\n  return x - y;\n};\n\n/*\n  >>> multiply(2, 3)\n  6\n  >>> multiply(5, 7)\n  24\n  */\nconst multiply = (a, b) => {\n  return a * b;\n};\n\n/*\n  >>> divide(2, 3)\n  2\n  >>> divide(5, 7)\n  3\n  */\nconst divide = (x, y) => {\n  return x / y;\n};\n\n/*\n  >>> modulo(2, 3)\n  1\n  >>> modulo(5, 7)\n  0\n  */\nconst modulo = (x, y) => {\n  return x % y;\n};\n\n/*\n  >>> pow(2, 3)\n  2\n  >>> pow(5, 7)\n  8\n  */\nconst pow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> sqrt(2)\n  2\n  >>> sqrt(5)\n  8\n  */\nconst sqrt = x => {\n  return Math.sqrt(x);\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {\n  return 1 / x;\n};\n\n/*\n  >>> inverse(8)\n  2\n  >>> inverse(16)\n  8\n  */\nconst inverse = x => {", "passed": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if two words have the same characters character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Check if two words have the same characters character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  let len = s0.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let flag = true;\n  let s0 = s0.toLowerCase();\n  let s1 = s1.toLowerCase();\n  while (i < len) {\n    if (s0[i]!== s1[i]) {\n      flag = false;\n      break;\n    }\n    i++;\n  }\n  return flag;\n};\n\n/*\n  Check if two words have the same characters character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCharsIgnoreCase = (s0, s1) => {\n  let len = s0.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let flag = true;\n  let s0 = s0.toLowerCase();\n  let s1 = s1.toLowerCase();\n  while (i < len) {\n    if (s0[i]!== s1[i]) {\n      flag = false;\n      break;\n    }\n    i++;\n  }\n  return flag;\n};\n\n/*\n  Check if two words have the same characters character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCharsIgnoreCaseIgnoreCase = (s0, s1) => {\n  let len = s0.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let flag = true;\n  let s0 = s0.toLowerCase();\n  let s1 = s1.toLowerCase();\n  while (i < len) {\n    if (s0[i]!== s1[i]) {\n      flag = false;\n      break;\n    }\n    i++;\n  }\n  return flag;\n};\n\n/*\n  Check if two words have the same characters character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCharsIgnoreCaseIgnoreCaseIgnoreCase = (s0, s1) => {\n  let len = s0.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let flag = true;\n  let s0 = s0.toLowerCase();\n  let s1 = s1.toLowerCase();\n  while (i < len) {\n    if (s0[i]!== s1[i]) {\n      flag = false;\n      break;\n    }\n    i++;\n  }\n  return flag;\n};\n\n/*\n  Check if two words have the same characters character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCharsIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (s0, s1) => {\n  let len = s0.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let flag = true;\n  let s0 = s0.toLowerCase();\n  let s1 = s1.toLowerCase();\n  while (i < len) {\n    if (s0[i]!== s1[i]) {\n      flag = false;\n      break;\n    }\n    i++;\n  }\n  return flag;\n};\n\n/*\n  Check if two words have the same characters character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCharsIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (s0, s1) => {\n  let len = s0.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let flag = true;\n  let s0 = s0.toLowerCase();\n  let s1 = s1.toLowerCase();\n  while (i < len) {\n    if (s0[i]!== s1[i]) {\n      flag = false;\n      break;\n    }\n    i++;\n  }\n  return flag;\n};\n\n/*\n  Check if two words have the same characters character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCharsIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (s0, s1) => {\n  let len = s0.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let flag = true;\n  let s0 = s0.toLowerCase();\n  let s1 = s1.toLowerCase();\n  while (i < len) {\n    if (s0[i]!== s1[i]) {\n      flag = false;\n      break;\n    }\n    i++;\n  }\n  return flag;\n};\n\n/*\n  Check if two words have the same characters character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')", "passed": 0}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(4)\n  55\n  >>> fib(3)\n  55\n  >>> fib(2)\n  55\n  >>> fib(7)\n  55\n  >>> fib(6)\n  55\n  >>> fib(5)\n  55\n  >>> fib(4)\n  55\n  >>> fib(3)\n  55\n  >>> fib(2)\n  55\n  >>> fib(7)\n  55\n  >>> fib(6)\n  55\n  >>> fib(5)\n  55\n  >>> fib(4)\n  55\n  >>> fib(3)\n  55\n  >>> fib(2)\n  55\n  >>> fib(7)\n  55\n  >>> fib(6)\n  55\n  >>> fib(5)\n  55\n  >>> fib(4)\n  55\n  >>> fib(3)\n  55\n  >>> fib(2)\n  55\n  >>> fib(7)\n  55\n  >>> fib(6)\n  55\n  >>> fib(5)\n  55\n  >>> fib(4)\n  55\n  >>> fib(3)\n  55\n  >>> fib(2)\n  55\n  >>> fib(7)\n  55\n  >>> fib(6)\n  55\n  >>> fib(5)\n  55\n  >>> fib(4)\n  55\n  >>> fib(3)\n  55\n  >>> fib(2)\n  55\n  >>> fib(7)\n  55\n  >>> fib(6)\n  55\n  >>> fib(5)\n  55\n  >>> fib(4)\n  55\n  >>> fib(3)\n  55\n  >>> fib(2)\n  55\n  >>> fib(7)\n  55\n  >>> fib(6)\n  55\n  >>> fib(5)\n  55\n  >>> fib(4)\n  55\n  >>> fib(3)\n  55\n  >>> fib(2)\n  55\n  >>> fib(7)\n  55\n  >>> fib(6)\n  55\n  >>> fib(5)\n  55\n  >>> fib(4)\n  55\n  >>> fib(3)\n  55\n  >>> fib(2)\n  55\n  >>> fib(7)\n  55\n  >>> fib(6)\n  55\n  >>> fib(5)\n  55\n  >>> fib(4)\n  55\n  >>> fib(3)\n  55\n  >>> fib(2)\n  55\n  >>> fib(7)\n  55\n  >>> fib(6)\n  55\n  >>> fib(5)\n  55\n  >>> fib(4)\n  55\n  >>> fib(3)\n  55\n  >>> fib(2)\n  55\n  >>> fib(7)\n  55\n  >>> fib(6)\n  55\n  >>> fib(5)\n  55\n  >>> fib(4)\n  55\n  >>> fib(3)\n  55\n  >>> fib(2)\n  55\n  >>> fib(7)\n  55\n  >>> fib(6)\n  55\n  >>> fib(5)\n  55\n  >>> fib(4)\n  55\n  >>> fib(3)\n  55\n  >>> fib(2)\n  55\n  >>> fib(7)\n  55\n  >>> fib(6)\n  55\n  >>> fib(5)\n  55\n  >>> fib(4)\n  55\n  >>> fib(3)\n  55\n  >>> fib(2)\n  55\n  >>> fib(7)\n  55\n  >>> fib(6)\n  55\n  >>> fib(5)\n  55\n  >>> fib(4)\n  55\n  >>> fib(3)\n  55\n  >>> fib(2)\n  55\n  >>> fib(7)\n  55\n  >>> fib(6)\n  55\n  >>> fib(5)\n  55\n  >>> fib(4)\n  55\n  >>> fib(3)\n  55\n  >>> fib(2)\n  55\n  >>> fib(7)\n  55\n  >>> fib(6)\n  55\n  >>> fib(5)\n  55\n  >>> fib(4)\n  55\n  >>> fib(3)\n  55\n  >>> fib(2)\n  55\n  >>> fib(7)\n  55\n  >>> fib(6)\n  55\n  >>> fib(5)\n  55\n  >>> fib(4)\n  55\n  >>> fib(3)\n  55\n  >>> fib(2)\n  55\n  >>> fib(7)\n  55\n  >>> fib(6)\n  55\n  >>> fib(5)\n  55\n  >>> fib(4)\n  55\n  >>> fib(3)\n  55\n  >>> fib(2)\n  55\n  >>> fib(7)\n  55\n  >>> fib(6)\n  55\n  >>> fib(5)\n  55\n  >>> fib(4)\n  55\n  >>> fib(3)\n  55\n  >>> fib(2)\n  55\n  >>> fib(7)\n  55\n  >>> fib(6)\n  55\n  >>> fib(5)\n  55\n  >>> fib(4)\n  55\n  >>> fib(3)\n  55\n  >>> fib(2)\n  55\n  >>> fib(7)\n  55\n  >>> fib(6)\n  55\n  >>> fib(5)\n  55\n  >>> fib(4)\n  55\n  >>> fib(3)\n  55\n  >>> fib(2)\n  55\n  >>> fib(7)\n  55\n  >>> fib(6)\n  55\n  >>> fib(5)\n  55\n  >>> fib(4)\n  55\n  >>> fib(3)\n  55\n  >>> fib(2)\n  55\n  >>> fib(7)\n  55\n  >>> fib(6)\n  55\n  >>> fib(5)\n  55\n  >>> fib(4)\n  55\n  >>> fib(3)\n  55\n  >>> fib(2)\n  55\n  >>> fib(7)\n  55\n  >>> fib(6)\n  55\n  >>> fib(5)\n  55\n  >>> fib(4)\n  55\n  >>> fib(3)\n  55\n  >>> fib(2)\n  55\n  >>> fib(7)\n  55\n  >>> fib(6)\n  55\n  >>> fib(5)\n  55\n  >>> fib(4)\n  55\n  >>> fib(3)\n  55\n  >>> fib(2)\n  55\n  >>> fib(7)\n  55\n  >>> fib(6)\n  55\n  >>> fib(5)\n  55\n  >>> fib(4)\n  55\n  >>> fib(3)\n  55\n  >>> fib(2)\n  55\n  >>> fib(7)\n  55\n  >>> fib(6)\n  55\n  >>> fib(5)\n  55\n  >>> fi", "passed": 0}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \" < \" and \" > \". \n   return false if every opening possibility bracket has a corresponding closing shutting bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string of \" < \" and \" > \". \n   return false if every opening possibility bracket has a corresponding closing shutting bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const openingBrackets = brackets.split(\">\");\n  const closingBrackets = brackets.split(\"<\");\n  return openingBrackets.every((openingBracket) => {\n    return closingBrackets.every((closingBracket) => {\n      return openingBracket === closingBracket;\n    });\n  });\n};\n\n/**\n * Given a string, return true if it contains only lowercase letters.\n * \n * >>> isOnlyLowercase(\"hello\")\n * true\n * >>> isOnlyLowercase(\"HELLO\")\n * false\n * >>> isOnlyLowercase(\"HELLOWORLD\")\n * false\n */\nconst isOnlyLowercase = (str) => {\n  return str.length === 1 && str.toLowerCase() === str;\n};\n\n/**\n * Given a string, return true if it contains only uppercase letters.\n * \n * >>> isOnlyUppercase(\"hello\")\n * true\n * >>> isOnlyUppercase(\"HELLO\")\n * false\n * >>> isOnlyUppercase(\"HELLOWORLD\")\n * false\n */\nconst isOnlyUppercase = (str) => {\n  return str.length === 1 && str.toUpperCase() === str;\n};\n\n/**\n * Given a string, return true if it contains only numbers and letters.\n * \n * >>> isOnlyNumbersAndLetters(\"hello\")\n * true\n * >>> isOnlyNumbersAndLetters(\"HELLO\")\n * false\n * >>> isOnlyNumbersAndLetters(\"HELLOWORLD\")\n * false\n */\nconst isOnlyNumbersAndLetters = (str) => {\n  return str.length === 1 && isOnlyLowercase(str) && isOnlyUppercase(str);\n};\n\n/**\n * Given a string, return true if it contains only numbers and letters.\n * \n * >>> isOnlyNumbersAndLetters(\"hello\")\n * true\n * >>> isOnlyNumbersAndLetters(\"HELLO\")\n * false\n * >>> isOnlyNumbersAndLetters(\"HELLOWORLD\")\n * false\n */\nconst isOnlyNumbersAndLettersNoSpaces = (str) => {\n  return str.length === 1 && isOnlyLowercase(str) && isOnlyUppercase(str);\n};\n\n/**\n * Given a string, return true if it contains only numbers and letters.\n * \n * >>> isOnlyNumbersAndLetters(\"hello\")\n * true\n * >>> isOnlyNumbersAndLetters(\"HELLO\")\n * false\n * >>> isOnlyNumbersAndLetters(\"HELLOWORLD\")\n * false\n */\nconst isOnlyNumbersAndLettersNoSpacesAndSpacesInside = (str) => {\n  return str.length === 1 && isOnlyLowercase(str) && isOnlyUppercase(str);\n};\n\n/**\n * Given a string, return true if it contains only numbers and letters.\n * \n * >>> isOnlyNumbersAndLetters(\"hello\")\n * true\n * >>> isOnlyNumbersAndLetters(\"HELLO\")\n * false\n * >>> isOnlyNumbersAndLetters(\"HELLOWORLD\")\n * false\n */\nconst isOnlyNumbersAndLettersNoSpacesAndSpacesInsideAndSpacesInside = (str) => {\n  return str.length === 1 && isOnlyLowercase(str) && isOnlyUppercase(str);\n};\n\n/**\n * Given a string, return true if it contains only numbers and letters.\n * \n * >>> isOnlyNumbersAndLetters(\"hello\")\n * true\n * >>> isOnlyNumbersAndLetters(\"HELLO\")\n * false\n * >>> isOnlyNumbersAndLetters(\"HELLOWORLD\")\n * false\n */\nconst isOnlyNumbersAndLettersNoSpacesAndSpacesInsideAndSpacesInsideAndSpacesInside = (str) => {\n  return str.length === 1 && isOnlyLowercase(str) && isOnlyUppercase(str);\n};\n\n/**\n * Given a string, return true if it contains only numbers and letters.\n * \n * >>> isOnlyNumbersAndLetters(\"hello\")\n * true\n * >>> isOnlyNumbersAndLetters(\"HELLO\")\n * false\n * >>> isOnlyNumbersAndLetters(\"HELLOWORLD\")\n * false\n */\nconst isOnlyNumbersAndLettersNoSpacesAndSpacesInsideAndSpacesInsideAndSpacesInsideAndSpacesInside = (str) => {\n  return str.length === 1 && isOnlyLowercase(str) && isOnlyUppercase(str);\n};\n\n/**\n * Given a string, return true if it contains only numbers and letters.\n * \n * >>> isOnlyNumbersAndLetters(\"hello\")\n * true\n * >>> isOnlyNumbersAndLetters(\"HELLO\")\n * false\n * >>> isOnlyNumbersAndLetters(\"HELLOWORLD\")\n * false\n */\nconst isOnlyNumbersAndLettersNoSpacesAndSpacesInsideAndSpacesInsideAndSpacesInsideAndSpacesInsideAndSpacesInside = (str) => {\n  return str.length === 1 && isOnlyLowercase(str) && isOnlyUppercase(str);\n};\n\n/**\n * Given a string, return true if it contains only numbers and letters.\n * \n * >>> isOnlyNumbersAndLetters(\"hello\")\n * true\n * >>> isOnlyNumbersAndLetters(\"HELLO\")\n * false\n * >>> isOnlyNumbersAndLetters(\"HELLOWORLD\")\n * false\n */\nconst isOnlyNumbersAndLettersNoSpacesAndSpacesInsideAndSpacesInsideAndSpacesInsideAndSpacesInsideAndSpacesInside = (str) => {\n  return str.length === 1 && isOnlyLowercase(str) && isOnlyUppercase(str);\n};\n\n/**\n * Given a string, return true if it contains only numbers and letters.\n * \n * >>> isOnlyNumbersAndLetters(\"hello\")\n * true\n * >>> isOnlyNumbersAndLetters(\"HELLO\")\n * false\n * >>> isOnlyNumbersAndLetters(\"HELLOWORLD\")\n * false\n */\nconst isOnlyNumbersAndLettersNoSpacesAndSpacesInsideAndSpacesInsideAndSpacesInsideAndSpacesInsideAndSpacesInsideAndSpacesInside = (str) => {\n  return str.length === 1 && isOnlyLowercase(str) && isOnlyUppercase(str);\n};\n\n/**\n * Given a string, return true if it contains only numbers and letters.\n * \n * >>> isOnlyNumbersAndLetters(\"hello\")\n * true\n * >>> isOnlyNumbersAndLetters(\"HELLO\")\n * false\n * >>> isOnlyNumbersAndLetters(\"HELLOWORLD\")\n * false\n */\nconst isOnlyNumbersAndLettersNoSpacesAndSpacesInsideAndSpacesInsideAndSpacesInsideAndSpacesInsideAndSpacesInsideAndSpacesInside = (str) => {\n  return str.length === 1 && isOnlyLowercase(str) && isOnlyUppercase(str);\n};\n\n/**\n * Given a string, return true if it contains only numbers and letters.\n * \n * >>> isOnlyNumbersAndLetters(\"hello\")\n * true\n * >>> isOnlyNumbersAndLetters(\"HELLO\")\n * false\n * >>> isOnlyNumbersAndLetters(\"HELLOWORLD\")\n * false", "passed": 0}
{"task_id": "JavaScript/57", "prompt": "/*Return true is list elements are monotonically increasing increase or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Return true is list elements are monotonically increasing increase or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let i = l.length - 1;\n  let j = l[0];\n  let k = 0;\n  let l = l.reverse();\n  while (l > j) {\n    if (l[k] < j) k = j;\n    j = l[k];\n  }\n  return k === j;\n};\n\n/**\n * Return true is list elements are monotonically decreasing decrease or increasing.\n  >>> monotonic([-10, -5, 0, 5, 10])\n  true\n  >>> monotonic([-5, 0, -10, 10, -5])\n  false\n  >>> monotonic([-10, -5, 0, 5, 10])\n  true\n  */\nconst monotonicDecreasing = (l) => {\n  let i = l.length - 1;\n  let j = l[0];\n  let k = 0;\n  let l = l.reverse();\n  while (l > j) {\n    if (l[k] > j) k = j;\n    j = l[k];\n  }\n  return k === j;\n};\n\n/**\n * Return true is list elements are monotonically increasing increase or decreasing.\n  >>> monotonicDecreasing([-10, -5, 0, 5, 10])\n  true\n  >>> monotonicDecreasing([-5, 0, -10, 10, -5])\n  false\n  >>> monotonicDecreasing([-10, -5, 0, 5, 10])\n  true\n  */\nconst monotonicIncreasing = (l) => {\n  let i = l.length - 1;\n  let j = l[0];\n  let k = 0;\n  let l = l.reverse();\n  while (l > j) {\n    if (l[k] < j) k = j;\n    j = l[k];\n  }\n  return k === j;\n};\n\n/**\n * Return true is list elements are monotonically decreasing decrease or increasing.\n  >>> monotonicIncreasing([-10, -5, 0, 5, 10])\n  true\n  >>> monotonicIncreasing([-5, 0, -10, 10, -5])\n  false\n  >>> monotonicIncreasing([-10, -5, 0, 5, 10])\n  true\n  */\nconst monotonicDecreasingDecreasing = (l) => {\n  let i = l.length - 1;\n  let j = l[0];\n  let k = 0;\n  let l = l.reverse();\n  while (l > j) {\n    if (l[k] > j) k = j;\n    j = l[k];\n  }\n  return k === j;\n};\n\n/**\n * Return true is list elements are monotonically increasing increase or decreasing.\n  >>> monotonicDecreasingDecreasing([-10, -5, 0, 5, 10])\n  true\n  >>> monotonicDecreasingDecreasing([-5, 0, -10, 10, -5])\n  false\n  >>> monotonicDecreasingDecreasing([-10, -5, 0, 5, 10])\n  true\n  */\nconst monotonicIncreasingDecreasing = (l) => {\n  let i = l.length - 1;\n  let j = l[0];\n  let k = 0;\n  let l = l.reverse();\n  while (l > j) {\n    if (l[k] < j) k = j;\n    j = l[k];\n  }\n  return k === j;\n};\n\n/**\n * Return true is list elements are monotonically increasing increase or decreasing.\n  >>> monotonicIncreasingDecreasing([-10, -5, 0, 5, 10])\n  true\n  >>> monotonicIncreasingDecreasing([-5, 0, -10, 10, -5])\n  false\n  >>> monotonicIncreasingDecreasing([-10, -5, 0, 5, 10])\n  true\n  */\nconst monotonicIncreasingIncreasing = (l) => {\n  let i = l.length - 1;\n  let j = l[0];\n  let k = 0;\n  let l = l.reverse();\n  while (l > j) {\n    if (l[k] > j) k = j;\n    j = l[k];\n  }\n  return k === j;\n};\n\n/**\n * Return true is list elements are monotonically decreasing decrease or increasing.\n  >>> monotonicDecreasingIncreasing([-10, -5, 0, 5, 10])\n  true\n  >>> monotonicDecreasingIncreasing([-5, 0, -10, 10, -5])\n  false\n  >>> monotonicDecreasingIncreasing([-10, -5, 0, 5, 10])\n  true\n  */\nconst monotonicDecreasingIncreasing = (l) => {\n  let i = l.length - 1;\n  let j = l[0];\n  let k = 0;\n  let l = l.reverse();\n  while (l > j) {\n    if (l[k] < j) k = j;\n    j = l[k];\n  }\n  return k === j;\n};\n\n/**\n * Return true is list elements are monotonically increasing increase or decreasing.\n  >>> monotonicIncreasingIncreasing([-10, -5, 0, 5, 10])\n  true\n  >>> monotonicIncreasingIncreasing([-5, 0, -10, 10, -5])\n  false\n  >>> monotonicIncreasingIncreasing([-10, -5, 0, 5, 10])\n  true\n  */\nconst monotonicIncreasingDecreasing = (l) => {\n  let i = l.length - 1;\n  let j = l[0];\n  let k = 0;\n  let l = l.reverse();\n  while (l > j) {\n    if (l[k] > j) k = j;\n    j = l[k];\n  }\n  return k === j;\n};\n\n/**\n * Return true is list elements are monotonically decreasing decrease or increasing.\n  >>> monotonicDecreasingDecreasing([-10, -5, 0, 5, 10])\n  true\n  >>> monotonicDecreasingDecreasing([-5, 0, -10, 10, -5])\n  false\n  >>> monotonicDecreasingDecreasing([-10, -5, 0, 5, 10])\n  true\n  */\nconst monotonicDecreasingDecreasing = (l) => {\n  let i = l.length - 1;\n  let j = l[0];\n  let k = 0;\n  let l = l.reverse();\n  while (l > j) {\n    if (l[k] < j) k = j;\n    j = l[k];\n  }\n  return k === j;\n};\n\n/**\n * Return true is list elements are monotonically increasing increase or decreasing.\n  >>> monotonicIncreasingDecreasing([-10, -5, 0, 5, 10])\n  true\n  >>> monotonicIncreasingDecreasing([-5, 0, -10, 10, -5])\n  false\n  >>> monotonicIncreasingDecreasing([-10, -5, 0, 5, 10])\n  true\n  */\nconst monotonicIncreasingIncreasing = (l) => {\n  let i = l.length - 1;\n  let j = l[0];\n  let k = 0;\n  let l = l.reverse();\n  while (l > j) {\n    if (l[k] > j) k = j;\n    j = l[k];\n  }\n  return k === j;\n};\n\n/**\n * Return true is list elements are monotonically increasing increase or decreasing.\n  >>> monotonicIncreasingIncreasing([-10, -5, 0, 5, 10])\n  true\n  >>> monotonicIncreasingIncreasing([-5, 0, -10, 10, -5])\n  false\n  >>> monot", "passed": 0}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted unique common elements chemical element for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Return sorted unique common elements chemical element for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set()\n  const result = []\n  for (let i = 0; i < l1.length; i++) {\n    if (set.has(l1[i])) {\n      result.push(l1[i])\n      set.delete(l1[i])\n    } else {\n      set.add(l1[i])\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (set.has(l2[i])) {\n      result.push(l2[i])\n      set.delete(l2[i])\n    } else {\n      set.add(l2[i])\n    }\n  }\n  return result\n}\n\n/*Return sorted unique common elements chemical element for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set()\n  const result = []\n  for (let i = 0; i < l1.length; i++) {\n    if (set.has(l1[i])) {\n      result.push(l1[i])\n      set.delete(l1[i])\n    } else {\n      set.add(l1[i])\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (set.has(l2[i])) {\n      result.push(l2[i])\n      set.delete(l2[i])\n    } else {\n      set.add(l2[i])\n    }\n  }\n  return result\n}\n\n/*Return sorted unique common elements chemical element for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set()\n  const result = []\n  for (let i = 0; i < l1.length; i++) {\n    if (set.has(l1[i])) {\n      result.push(l1[i])\n      set.delete(l1[i])\n    } else {\n      set.add(l1[i])\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (set.has(l2[i])) {\n      result.push(l2[i])\n      set.delete(l2[i])\n    } else {\n      set.add(l2[i])\n    }\n  }\n  return result\n}\n\n/*Return sorted unique common elements chemical element for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set()\n  const result = []\n  for (let i = 0; i < l1.length; i++) {\n    if (set.has(l1[i])) {\n      result.push(l1[i])\n      set.delete(l1[i])\n    } else {\n      set.add(l1[i])\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (set.has(l2[i])) {\n      result.push(l2[i])\n      set.delete(l2[i])\n    } else {\n      set.add(l2[i])\n    }\n  }\n  return result\n}\n\n/*Return sorted unique common elements chemical element for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set()\n  const result = []\n  for (let i = 0; i < l1.length; i++) {\n    if (set.has(l1[i])) {\n      result.push(l1[i])\n      set.delete(l1[i])\n    } else {\n      set.add(l1[i])\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (set.has(l2[i])) {\n      result.push(l2[i])\n      set.delete(l2[i])\n    } else {\n      set.add(l2[i])\n    }\n  }\n  return result\n}\n\n/*Return sorted unique common elements chemical element for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set()\n  const result = []\n  for (let i = 0; i < l1.length; i++) {\n    if (set.has(l1[i])) {\n      result.push(l1[i])\n      set.delete(l1[i])\n    } else {\n      set.add(l1[i])\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (set.has(l2[i])) {\n      result.push(l2[i])\n      set.delete(l2[i])\n    } else {\n      set.add(l2[i])\n    }\n  }\n  return result\n}\n\n/*Return sorted unique common elements chemical element for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set()\n  const result = []\n  for (let i = 0; i < l1.length; i++) {\n    if (set.has(l1[i])) {\n      result.push(l1[i])\n      set.delete(l1[i])\n    } else {\n      set.add(l1[i])\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (set.has(l2[i])) {\n      result.push(l2[i])\n      set.delete(l2[i])\n    } else {\n      set.add(l2[i])\n    }\n  }\n  return result\n}\n\n/*Return sorted unique common elements chemical element for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set()\n  const result = []\n  for (let i = 0; i < l1.length; i++) {\n    if (set.has(l1[i])) {\n      result.push(l1[i])\n      set.delete(l1[i])\n    } else {\n      set.add(l1[i])\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (set.has(l2[i])) {\n      result.push(l2[i])\n      set.delete(l2[i])\n    } else {\n      set.add(l2[i])\n    }\n  }\n  return result\n}\n\n/*Return sorted unique common elements chemical element for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set()\n  const result = []\n  for (let i = 0; i < l1.length; i++) {\n    if (set.has(l1[i])) {\n      result.push(l1[i])\n      set.delete(l1[i])\n    } else {\n      set.add(l1[i])\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (set.has(l2[i])) {\n      result.push(l2[i])\n      set.delete(l2[i])\n    } else {\n      set.add(l2[i])\n    }\n  }\n  return result\n}\n\n/*Return sorted unique common elements chemical element for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set()\n  const result = []\n", "passed": 0}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime factor of n. Assume n > 1 and is not a prime flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Return the largest prime factor of n. Assume n > 1 and is not a prime flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 2;\n  }\n  return factor;\n};\n\n/*\n  Given a number n, return true if n is a prime number.\n  >>> isPrime(123)\n  true\n  >>> isPrime(124)\n  false\n  >>> isPrime(125)\n  false\n  >>> isPrime(126)\n  false\n  >>> isPrime(127)\n  false\n  >>> isPrime(128)\n  false\n  >>> isPrime(129)\n  false\n  >>> isPrime(130)\n  false\n  >>> isPrime(131)\n  true\n  >>> isPrime(132)\n  false\n  >>> isPrime(133)\n  false\n  >>> isPrime(134)\n  false\n  >>> isPrime(135)\n  false\n  >>> isPrime(136)\n  false\n  >>> isPrime(137)\n  false\n  >>> isPrime(138)\n  false\n  >>> isPrime(139)\n  false\n  >>> isPrime(140)\n  false\n  >>> isPrime(141)\n  false\n  >>> isPrime(142)\n  false\n  >>> isPrime(143)\n  false\n  >>> isPrime(144)\n  false\n  >>> isPrime(145)\n  false\n  >>> isPrime(146)\n  false\n  >>> isPrime(147)\n  false\n  >>> isPrime(148)\n  false\n  >>> isPrime(149)\n  false\n  >>> isPrime(150)\n  false\n  >>> isPrime(151)\n  false\n  >>> isPrime(152)\n  false\n  >>> isPrime(153)\n  false\n  >>> isPrime(154)\n  false\n  >>> isPrime(155)\n  false\n  >>> isPrime(156)\n  false\n  >>> isPrime(157)\n  false\n  >>> isPrime(158)\n  false\n  >>> isPrime(159)\n  false\n  >>> isPrime(160)\n  false\n  >>> isPrime(161)\n  false\n  >>> isPrime(162)\n  false\n  >>> isPrime(163)\n  false\n  >>> isPrime(164)\n  false\n  >>> isPrime(165)\n  false\n  >>> isPrime(166)\n  false\n  >>> isPrime(167)\n  false\n  >>> isPrime(168)\n  false\n  >>> isPrime(169)\n  false\n  >>> isPrime(170)\n  false\n  >>> isPrime(171)\n  false\n  >>> isPrime(172)\n  false\n  >>> isPrime(173)\n  false\n  >>> isPrime(174)\n  false\n  >>> isPrime(175)\n  false\n  >>> isPrime(176)\n  false\n  >>> isPrime(177)\n  false\n  >>> isPrime(178)\n  false\n  >>> isPrime(179)\n  false\n  >>> isPrime(180)\n  false\n  >>> isPrime(181)\n  false\n  >>> isPrime(182)\n  false\n  >>> isPrime(183)\n  false\n  >>> isPrime(184)\n  false\n  >>> isPrime(185)\n  false\n  >>> isPrime(186)\n  false\n  >>> isPrime(187)\n  false\n  >>> isPrime(188)\n  false\n  >>> isPrime(189)\n  false\n  >>> isPrime(190)\n  false\n  >>> isPrime(191)\n  false\n  >>> isPrime(192)\n  false\n  >>> isPrime(193)\n  false\n  >>> isPrime(194)\n  false\n  >>> isPrime(195)\n  false\n  >>> isPrime(196)\n  false\n  >>> isPrime(197)\n  false\n  >>> isPrime(198)\n  false\n  >>> isPrime(199)\n  false\n  >>> isPrime(200)\n  false\n  >>> isPrime(201)\n  false\n  >>> isPrime(202)\n  false\n  >>> isPrime(203)\n  false\n  >>> isPrime(204)\n  false\n  >>> isPrime(205)\n  false\n  >>> isPrime(206)\n  false\n  >>> isPrime(207)\n  false\n  >>> isPrime(208)\n  false\n  >>> isPrime(209)\n  false\n  >>> isPrime(210)\n  false\n  >>> isPrime(211)\n  false\n  >>> isPrime(212)\n  false\n  >>> isPrime(213)\n  false\n  >>> isPrime(214)\n  false\n  >>> isPrime(215)\n  false\n  >>> isPrime(216)\n  false\n  >>> isPrime(217)\n  false\n  >>> isPrime(218)\n  false\n  >>> isPrime(219)\n  false\n  >>> isPrime(220)\n  false\n  >>> isPrime(221)\n  false\n  >>> isPrime(222)\n  false\n  >>> isPrime(223)\n  false\n  >>> isPrime(224)\n  false\n  >>> isPrime(225)\n  false\n  >>> isPrime(226)\n  false\n  >>> isPrime(227)\n  false\n  >>> isPrime(228)\n  false\n  >>> isPrime(229)\n  false\n  >>> isPrime(230)\n  false\n  >>> isPrime(231)\n  false\n  >>> isPrime(232)\n  false\n  >>> isPrime(233)\n  false\n  >>> isPrime(234)\n  false\n  >>> isPrime(235)\n  false\n  >>> isPrime(236)\n  false\n  >>> isPrime(237)\n  false\n  >>> isPrime(238)\n  false\n  >>> isPrime(239)\n  false\n  >>> isPrime(240)\n  false\n  >>> isPrime(241)\n  false\n  >>> isPrime(242)\n  false\n  >>> isPrime", "passed": 0}
{"task_id": "JavaScript/6", "prompt": "/* Input to this function is a string bowed stringed instrument represented multiple groups group for nested parentheses separated break by spaces. \n   For each of the group, output the deepest deep level of nesting of parentheses parenthesis. \n   E.g. (() ()) has maximum maximal two levels of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Input to this function is a string bowed stringed instrument represented multiple groups group for nested parentheses separated break by spaces. \n   For each of the group, output the deepest deep level of nesting of parentheses parenthesis. \n   E.g. (() ()) has maximum maximal two levels of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_groups = paren_string.split(/\\s+/g);\n  const max_level = 0;\n  const max_levels = [];\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level = 0;\n  let max_level", "passed": 0}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a function that sums numbers numeral from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*sumToN is a function that sums numbers numeral from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  Given a number n, return its factorial using only built-in functions.\n  >>> factorial(5)\n  120\n  >>> factorial(10)\n  720\n  >>> factorial(15)\n  720\n  >>> factorial(20)\n  720\n  >>> factorial(25)\n  720\n  >>> factorial(30)\n  720\n  >>> factorial(40)\n  720\n  >>> factorial(50)\n  720\n  >>> factorial(60)\n  720\n  >>> factorial(70)\n  720\n  >>> factorial(80)\n  720\n  >>> factorial(90)\n  720\n  >>> factorial(100)\n  720\n  >>> factorial(110)\n  720\n  >>> factorial(120)\n  720\n  >>> factorial(130)\n  720\n  >>> factorial(140)\n  720\n  >>> factorial(150)\n  720\n  >>> factorial(160)\n  720\n  >>> factorial(170)\n  720\n  >>> factorial(180)\n  720\n  >>> factorial(190)\n  720\n  >>> factorial(200)\n  720\n  >>> factorial(210)\n  720\n  >>> factorial(220)\n  720\n  >>> factorial(230)\n  720\n  >>> factorial(240)\n  720\n  >>> factorial(250)\n  720\n  >>> factorial(265)\n  720\n  >>> factorial(270)\n  720\n  >>> factorial(280)\n  720\n  >>> factorial(290)\n  720\n  >>> factorial(300)\n  720\n  >>> factorial(310)\n  720\n  >>> factorial(320)\n  720\n  >>> factorial(330)\n  720\n  >>> factorial(340)\n  720\n  >>> factorial(350)\n  720\n  >>> factorial(360)\n  720\n  >>> factorial(370)\n  720\n  >>> factorial(380)\n  720\n  >>> factorial(390)\n  720\n  >>> factorial(400)\n  720\n  >>> factorial(410)\n  720\n  >>> factorial(420)\n  720\n  >>> factorial(430)\n  720\n  >>> factorial(440)\n  720\n  >>> factorial(450)\n  720\n  >>> factorial(460)\n  720\n  >>> factorial(475)\n  720\n  >>> factorial(480)\n  720\n  >>> factorial(490)\n  720\n  >>> factorial(500)\n  720\n  >>> factorial(510)\n  720\n  >>> factorial(520)\n  720\n  >>> factorial(530)\n  720\n  >>> factorial(540)\n  720\n  >>> factorial(550)\n  720\n  >>> factorial(560)\n  720\n  >>> factorial(570)\n  720\n  >>> factorial(580)\n  720\n  >>> factorial(590)\n  720\n  >>> factorial(600)\n  720\n  >>> factorial(610)\n  720\n  >>> factorial(620)\n  720\n  >>> factorial(630)\n  720\n  >>> factorial(640)\n  720\n  >>> factorial(650)\n  720\n  >>> factorial(660)\n  720\n  >>> factorial(670)\n  720\n  >>> factorial(680)\n  720\n  >>> factorial(690)\n  720\n  >>> factorial(700)\n  720\n  >>> factorial(710)\n  720\n  >>> factorial(720)\n  720\n  >>> factorial(730)\n  720\n  >>> factorial(740)\n  720\n  >>> factorial(750)\n  720\n  >>> factorial(760)\n  720\n  >>> factorial(770)\n  720\n  >>> factorial(780)\n  720\n  >>> factorial(790)\n  720\n  >>> factorial(800)\n  720\n  >>> factorial(810)\n  720\n  >>> factorial(820)\n  720\n  >>> factorial(830)\n  720\n  >>> factorial(840)\n  720\n  >>> factorial(850)\n  720\n  >>> factorial(860)\n  720\n  >>> factorial(870)\n  720\n  >>> factorial(880)\n  720\n  >>> factorial(890)\n  720\n  >>> factorial(900)\n  720\n  >>> factorial(910)\n  720\n  >>> factorial(920)\n  720\n  >>> factorial(930)\n  720\n  >>> factorial(940)\n  720\n  >>> factorial(951)\n  720\n  >>> factorial(960)\n  720\n  >>> factorial(970)\n  720\n  >>> factorial(980)\n  720\n  >>> factorial(990)\n  720\n  >>> factorial(1000)\n  720\n  >>> factorial(1010)\n  720\n  >>> factorial(1020)\n  720\n  >>> factorial(1030)\n  720\n  >>> factorial(1040)\n  720\n  >>> factorial(1050)\n  720\n  >>> factorial(1060)\n  720\n  >>> factorial(1070)\n  720\n  >>> factorial(1080)\n  720\n  >>> factorial(1090)\n  720\n  >>> factorial(1100)\n  720\n  >>> factorial(1101)\n  720\n  >>> factorial(1110)\n  720\n  >>> factorial(1120)\n  720\n  >>> factorial(1130)\n  720\n  >>> factorial(1140)\n  720\n  >>> factorial(1150)\n  720\n  >>> factorial(1160)\n  720\n  >>> factorial(1180)\n  720\n  >>> factorial(1190)\n  720\n  >>> factorial(1200)\n  720\n  >>> factorial(1210)\n  720\n  >>> factorial(1220)\n  720\n  >>> factorial(1230)\n  720\n  >>> factorial(1240)\n  720\n  >>> factorial(1250)\n  720\n  >>> factorial(1260)\n  720\n  >>> factorial(1270)\n  720\n  >>> factorial(1280)\n  720\n  >>> factorial(1290)\n  720\n  >>> factorial(1300)\n  720\n  >>> factorial(1310)\n  720\n  >>> factorial(1320) \n  720\n  >>> factorial(1330) \n  720\n  >>> factorial(1340) \n  720\n  >>> factorial(1350)\n  720\n  >>> factorial(1360) \n  720\n  >>> factorial(1370) \n  720\n  >>> factorial(1380) \n  720\n  >>> factorial(1390) \n  720\n  >>> factorial(1400) \n  ", "passed": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \" (\" and \") \". \n   return true if every opening possibility bracket has a corresponding closing shutting bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string of \" (\" and \") \". \n   return true if every opening possibility bracket has a corresponding closing shutting bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const openingBrackets = brackets.match(/\\(([^)]+)\\)/)\n  const closingBrackets = brackets.match(/\\)([^)]+)\\)/)\n  return openingBrackets && closingBrackets\n}\n\n/**\n * Given a string of parentheses, return true if every opening parenthesis has a corresponding closing parenthesis.\n * \n * For example, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return false, \"(\" should return true, \"(\" should return ", "passed": 0}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefficients of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return rejoinder derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* xs represent coefficients of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return rejoinder derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const rejoinder = [];\n  let x = 0;\n  let y = 0;\n  let xsq = 0;\n  let ysq = 0;\n  let xsq2 = 0;\n  let ysq2 = 0;\n  let xsq3 = 0;\n  let ysq3 = 0;\n  let xsq4 = 0;\n  let ysq4 = 0;\n  let xsq5 = 0;\n  let ysq5 = 0;\n  \n  for (let i = 0; i < xs.length; i++) {\n    xsq += xs[i] * xs[i];\n    ysq += xs[i] * xs[i];\n    xsq2 += xs[i] * xs[i];\n    ysq2 += xs[i] * xs[i];\n    xsq3 += xs[i] * xs[i];\n    ysq3 += xs[i] * xs[i];\n    xsq4 += xs[i] * xs[i];\n    ysq4 += xs[i] * xs[i];\n    xsq5 += xs[i] * xs[i];\n    ysq5 += xs[i] * xs[i];\n  }\n  \n  rejoinder.push(\n    (xsq - ysq * xsq) / xsq,\n    (xsq2 - ysq2 * xsq2) / xsq2,\n    (xsq3 - ysq3 * xsq3) / xsq3,\n    (xsq4 - ysq4 * xsq4) / xsq4,\n    (xsq5 - ysq5 * xsq5) / xsq5\n  );\n  \n  return rejoinder;\n};\n\n/* \n  Calculate rejoinder coefficients of a polynomial. \n  xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return rejoinder coefficients of this polynomial in the same form.\n  >>> coefficients([3, 1, 2, 4, 5])\n  [3, 1, 2, 4, 5]\n  >>> coefficients([1, 2, 3])\n  [3, 1, 2, 4, 5]\n  */\nconst coefficients = (xs) => {\n  const rejoinder = [];\n  let x = 0;\n  let y = 0;\n  let xsq = 0;\n  let ysq = 0;\n  let xsq2 = 0;\n  let ysq2 = 0;\n  let xsq3 = 0;\n  let ysq3 = 0;\n  let xsq4 = 0;\n  let ysq4 = 0;\n  let xsq5 = 0;\n  let ysq5 = 0;\n  \n  for (let i = 0; i < xs.length; i++) {\n    xsq += xs[i] * xs[i];\n    ysq += xs[i] * xs[i];\n    xsq2 += xs[i] * xs[i];\n    ysq2 += xs[i] * xs[i];\n    xsq3 += xs[i] * xs[i];\n    ysq3 += xs[i] * xs[i];\n    xsq4 += xs[i] * xs[i];\n    ysq4 += xs[i] * xs[i];\n    xsq5 += xs[i] * xs[i];\n    ysq5 += xs[i] * xs[i];\n  }\n  \n  rejoinder.push(\n    (xsq - ysq * xsq) / xsq,\n    (xsq2 - ysq2 * xsq2) / xsq2,\n    (xsq3 - ysq3 * xsq3) / xsq3,\n    (xsq4 - ysq4 * xsq4) / xsq4,\n    (xsq5 - ysq5 * xsq5) / xsq5\n  );\n  \n  return rejoinder;\n};\n\n/* \n  Calculate inverse of a polynomial. \n  xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return inverse of this polynomial in the same form.\n  >>> inverse([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> inverse([1, 2, 3])\n  [3, 1, 2, 4, 5]\n  */\nconst inverse = (xs) => {\n  const rejoinder = [];\n  let x = 0;\n  let y = 0;\n  let xsq = 0;\n  let ysq = 0;\n  let xsq2 = 0;\n  let ysq2 = 0;\n  let xsq3 = 0;\n  let ysq3 = 0;\n  let xsq4 = 0;\n  let ysq4 = 0;\n  let xsq5 = 0;\n  let ysq5 = 0;\n  \n  for (let i = 0; i < xs.length; i++) {\n    xsq += xs[i] * xs[i];\n    ysq += xs[i] * xs[i];\n    xsq2 += xs[i] * xs[i];\n    ysq2 += xs[i] * xs[i];\n    xsq3 += xs[i] * xs[i];\n    ysq3 += xs[i] * xs[i];\n    xsq4 += xs[i] * xs[i];\n    ysq4 += xs[i] * xs[i];\n    xsq5 += xs[i] * xs[i];\n    ysq5 += xs[i] * xs[i];\n  }\n  \n  rejoinder.push(\n    (xsq - ysq * xsq) / xsq,\n    (xsq2 - ysq2 * xsq2) / xsq2,\n    (xsq3 - ysq3 * xsq3) / xsq3,\n    (xsq4 - ysq4 * xsq4) / xsq4,\n    (xsq5 - ysq5 * xsq5) / xsq5\n  );\n  \n  return rejoinder;\n};\n\n/* \n  Calculate inverse of a polynomial. \n  xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return inverse of this polynomial in the same form.\n  >>> inverse([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> inverse([1, 2, 3])\n  [3, 1, 2, 4, 5]\n  */\nconst inverse = (xs) => {\n  const rejoinder = [];\n  let x = 0;\n  let y = 0;\n  let xsq = 0;\n  let ysq = 0;\n  let xsq2 = 0;\n  let ysq2 = 0;\n  let xsq3 = 0;\n  let ysq3 = 0;\n  let xsq4 = 0;\n  let ysq4 = 0;\n  let xsq5 = 0;\n  let ysq5 = 0;\n  \n  for (let i = 0; i < xs.length; i++) {\n    xsq += xs[i] * xs[i];\n    ysq += xs[i] * xs[i];\n    xsq2 += xs[i] * xs[i];\n    ysq2 += xs[i] * xs[i];\n    xsq3 += xs[i] * xs[i];\n    ysq3 += xs[i] * xs[i];\n    xsq4 += xs[i] * xs[i];\n    ysq4 += xs[i] * xs[i];\n    xsq5 += xs[i] * xs[i];\n    ysq5 += xs[i] * xs[i];\n  }\n  \n  rejoinder.push(\n    (xsq - ysq * xsq) / xsq,\n    (xsq2 - ysq2 * xsq2) / xsq2,\n    (xsq3 - ysq3 * xsq3) / xsq3,\n    (xsq4 - ysq4 * xsq4) / xsq4,\n    (xsq5 - ysq5 * xsq5) / xsq5\n  );\n  \n  return rejoinder;\n};\n\n/* \n  Calculate inverse of a polynomial. \n  xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return inverse of this polynomial in the same form.\n  >>> inverse([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> inverse([1, 2, 3])\n  [3, 1, 2, 4, 5]\n  */\nconst inverse = (xs) => {\n  const rejoinder = [];\n  let x = 0;\n  let y = 0;\n  let xsq = 0;\n  let ysq = 0;\n  let xsq2 = 0;\n  let ysq2 = 0;\n  let xsq3 = 0;\n  let ysq3 = 0;\n  let xsq4 = 0;\n  let ysq4 = 0;\n  let xsq5 = 0;\n  let ysq5 = 0;\n  \n  for (let i = 0; i < xs.length; i++) {\n    xsq += xs[i] * xs[i];\n    ysq += xs[i] * xs[i];\n    xsq2 += xs[i] * xs[i];\n", "passed": 0}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number sequence is a sequence succession similar to the Fibbonacci sequnece that's defined define as follows: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please write publish a function to efficiently compute calculate the n-th element of the fibfib number issue sequence succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*The FibFib number sequence is a sequence succession similar to the Fibbonacci sequnece that's defined define as follows: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please write publish a function to efficiently compute calculate the n-th element of the fibfib number issue sequence succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\nmodule.exports = fibfib;\n\n},{}],3:[function(require,module,exports){\n/*\n  A simple JavaScript implementation of Fibonacci series.\n\n  Fibonacci series are defined as follows: \n  fibfib(0) = = 0 \n  fibfib(1) = = 0 \n  fibfib(2) = = 1 \n  fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write publish a function to efficiently compute calculate the n-th element of the fibfib number issue sequence succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\nmodule.exports = fibfib;\n\n},{}],4:[function(require,module,exports){\n/*\n  A simple JavaScript implementation of Fibonacci series.\n\n  Fibonacci series are defined as follows: \n  fibfib(0) = = 0 \n  fibfib(1) = = 0 \n  fibfib(2) = = 1 \n  fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write publish a function to efficiently compute calculate the n-th element of the fibfib number issue sequence succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\nmodule.exports = fibfib;\n\n},{}],5:[function(require,module,exports){\n/*\n  A simple JavaScript implementation of Fibonacci series.\n\n  Fibonacci series are defined as follows: \n  fibfib(0) = = 0 \n  fibfib(1) = = 0 \n  fibfib(2) = = 1 \n  fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write publish a function to efficiently compute calculate the n-th element of the fibfib number issue sequence succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\nmodule.exports = fibfib;\n\n},{}],6:[function(require,module,exports){\n/*\n  A simple JavaScript implementation of Fibonacci series.\n\n  Fibonacci series are defined as follows: \n  fibfib(0) = = 0 \n  fibfib(1) = = 0 \n  fibfib(2) = = 1 \n  fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write publish a function to efficiently compute calculate the n-th element of the fibfib number issue sequence succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\nmodule.exports = fibfib;\n\n},{}],7:[function(require,module,exports){\n/*\n  A simple JavaScript implementation of Fibonacci series.\n\n  Fibonacci series are defined as follows: \n  fibfib(0) = = 0 \n  fibfib(1) = = 0 \n  fibfib(2) = = 1 \n  fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write publish a function to efficiently compute calculate the n-th element of the fibfib number issue sequence succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\nmodule.exports = fibfib;\n\n},{}],8:[function(require,module,exports){\n/*\n  A simple JavaScript implementation of Fibonacci series.\n\n  Fibonacci series are defined as follows: \n  fibfib(0) = = 0 \n  fibfib(1) = = 0 \n  fibfib(2) = = 1 \n  fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write publish a function to efficiently compute calculate the n-th element of the fibfib number issue sequence succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\nmodule.exports = fibfib;\n\n},{}],9:[function(require,module,exports){\n/*\n  A simple JavaScript implementation of Fibonacci series.\n\n  Fibonacci series are defined as follows: \n  fibfib(0) = = 0 \n  fibfib(1) = = 0 \n  fibfib(2) = = 1 \n  fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write publish a function to efficiently compute calculate the n-th element of the fibfib number issue sequence succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\nmodule.exports = fibfib;\n\n},{}],10:[function(require,module,exports){\n/*\n  A simple JavaScript implementation of Fibonacci series.\n\n  Fibonacci series are defined as follows: \n  fibfib(0) = = 0 \n  fibfib(1) = = 0 \n  fibfib(2) = = 1 \n  fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write publish a function to efficiently compute calculate the n-th element of the fibfib number issue sequence ", "passed": 0}
{"task_id": "JavaScript/64", "prompt": "/*Write a function vowelsCount which takes a string bowed stringed instrument representing \n   a word password as input and returns come back the number of vowels in the string chain. \n   Vowels in this case character are' a',' e vitamin e',' i',' o',' u uranium'. Here,' y' is also besides a \n   vowel, but only when it is at the end conclusion of the given word. \n\n   Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Write a function vowelsCount which takes a string bowed stringed instrument representing \n   a word password as input and returns come back the number of vowels in the string chain. \n   Vowels in this case character are' a',' e vitamin e',' i',' o',' u uranium'. Here,' y' is also besides a \n   vowel, but only when it is at the end conclusion of the given word. \n\n   Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowelsCount = 0;\n  let vowelsIndex = 0;\n  let vowelsLength = 0;\n  let vowelsIndexLength = 0;\n  let vowelsIndexLength2 = 0;\n  let vowelsIndexLength3 = 0;\n  let vowelsIndexLength4 = 0;\n  let vowelsIndexLength5 = 0;\n  let vowelsIndexLength6 = 0;\n  let vowelsIndexLength7 = 0;\n  let vowelsIndexLength8 = 0;\n  let vowelsIndexLength9 = 0;\n  let vowelsIndexLength10 = 0;\n  let vowelsIndexLength11 = 0;\n  let vowelsIndexLength12 = 0;\n  let vowelsIndexLength13 = 0;\n  let vowelsIndexLength14 = 0;\n  let vowelsIndexLength15 = 0;\n  let vowelsIndexLength16 = 0;\n  let vowelsIndexLength17 = 0;\n  let vowelsIndexLength18 = 0;\n  let vowelsIndexLength19 = 0;\n  let vowelsIndexLength20 = 0;\n  let vowelsIndexLength21 = 0;\n  let vowelsIndexLength22 = 0;\n  let vowelsIndexLength23 = 0;\n  let vowelsIndexLength24 = 0;\n  let vowelsIndexLength25 = 0;\n  let vowelsIndexLength26 = 0;\n  let vowelsIndexLength27 = 0;\n  let vowelsIndexLength28 = 0;\n  let vowelsIndexLength29 = 0;\n  let vowelsIndexLength30 = 0;\n  let vowelsIndexLength31 = 0;\n  let vowelsIndexLength32 = 0;\n  let vowelsIndexLength33 = 0;\n  let vowelsIndexLength34 = 0;\n  let vowelsIndexLength35 = 0;\n  let vowelsIndexLength36 = 0;\n  let vowelsIndexLength37 = 0;\n  let vowelsIndexLength38 = 0;\n  let vowelsIndexLength39 = 0;\n  let vowelsIndexLength40 = 0;\n  let vowelsIndexLength41 = 0;\n  let vowelsIndexLength42 = 0;\n  let vowelsIndexLength43 = 0;\n  let vowelsIndexLength44 = 0;\n  let vowelsIndexLength45 = 0;\n  let vowelsIndexLength46 = 0;\n  let vowelsIndexLength47 = 0;\n  let vowelsIndexLength48 = 0;\n  let vowelsIndexLength49 = 0;\n  let vowelsIndexLength50 = 0;\n  let vowelsIndexLength51 = 0;\n  let vowelsIndexLength52 = 0;\n  let vowelsIndexLength53 = 0;\n  let vowelsIndexLength54 = 0;\n  let vowelsIndexLength55 = 0;\n  let vowelsIndexLength56 = 0;\n  let vowelsIndexLength57 = 0;\n  let vowelsIndexLength58 = 0;\n  let vowelsIndexLength59 = 0;\n  let vowelsIndexLength60 = 0;\n  let vowelsIndexLength61 = 0;\n  let vowelsIndexLength62 = 0;\n  let vowelsIndexLength63 = 0;\n  let vowelsIndexLength64 = 0;\n  let vowelsIndexLength65 = 0;\n  let vowelsIndexLength66 = 0;\n  let vowelsIndexLength67 = 0;\n  let vowelsIndexLength68 = 0;\n  let vowelsIndexLength69 = 0;\n  let vowelsIndexLength70 = 0;\n  let vowelsIndexLength71 = 0;\n  let vowelsIndexLength72 = 0;\n  let vowelsIndexLength73 = 0;\n  let vowelsIndexLength74 = 0;\n  let vowelsIndexLength75 = 0;\n  let vowelsIndexLength76 = 0;\n  let vowelsIndexLength77 = 0;\n  let vowelsIndexLength78 = 0;\n  let vowelsIndexLength79 = 0;\n  let vowelsIndexLength80 = 0;\n  let vowelsIndexLength81 = 0;\n  let vowelsIndexLength82 = 0;\n  let vowelsIndexLength83 = 0;\n  let vowelsIndexLength84 = 0;\n  let vowelsIndexLength85 = 0;\n  let vowelsIndexLength86 = 0;\n  let vowelsIndexLength87 = 0;\n  let vowelsIndexLength88 = 0;\n  let vowelsIndexLength89 = 0;\n  let vowelsIndexLength90 = 0;\n  let vowelsIndexLength91 = 0;\n  let vowelsIndexLength92 = 0;\n  let vowelsIndexLength93 = 0;\n  let vowelsIndexLength94 = 0;\n  let vowelsIndexLength95 = 0;\n  let vowelsIndexLength96 = 0;\n  let vowelsIndexLength97 = 0;\n  let vowelsIndexLength98 = 0;\n  let vowelsIndexLength99 = 0;\n  let vowelsIndexLength100 = 0;\n  let vowelsIndexLength101 = 0;\n  let vowelsIndexLength102 = 0;\n  let vowelsIndexLength103 = 0;\n  let vowelsIndexLength104 = 0;\n  let vowelsIndexLength105 = 0;\n  let vowelsIndexLength106 = 0;\n  let vowelsIndexLength107 = 0;\n  let vowelsIndexLength108 = 0;\n  let vowelsIndexLength109 = 0;\n  let vowelsIndexLength110 = 0;\n  let vowelsIndexLength111 = 0;\n  let vowelsIndexLength112 = 0;\n  let vowelsIndexLength113 = 0;\n  let vowelsIndexLength114 = 0;\n  let vowelsIndexLength115 = 0;\n  let vowelsIndexLength116 = 0;\n  let vowelsIndexLength117 = 0;\n  let vowelsIndexLength118 = 0;\n  let vowelsIndexLength119 = 0;\n  let vowelsIndexLength120 = 0;\n  let vowelsIndexLength121 = 0;\n  let vowelsIndexLength122 = 0;\n  let vowelsIndexLength123 = 0;\n  let vowelsIndexLength124 = 0;\n  let vowelsIndexLength125 = 0;\n  let vowelsIndexLength126 = 0;\n  let vowelsIndexLength127 = 0;\n  let vowelsIndexLength128 = 0;\n  let vowelsIndexLength129 = 0;\n  let vowelsIndexLength130 = 0;\n  let vowelsIndexLength131 = 0;\n  let vowelsIndexLength132 = 0;\n  let vowelsIndexLength133 = 0;\n  let vowelsIndexLength134 = 0;\n  let vowelsIndexLength135 = 0;\n  let vowelsIndexLength136 = 0;\n  let vowelsIndexLength137 = 0;\n  let vowelsIndexLength138 = 0;\n  let vowelsIndexLength139 = 0;\n  let vowelsIndexLength140 = 0;\n  let vowelsIndexLength141 = 0;\n  let vowelsIndexLength142 = 0;\n  let vowelsIndexLength143 = 0;\n  let vowelsIndexLength144 = 0;\n  let vowelsIndexLength145 = 0;\n  let vowelsIndexLength146 = 0;\n  let vowelsIndexLength147 = 0;\n  let vowelsIndexLength148 = 0;\n  let vowelsIndexLength149 = 0;\n  let vowelsIndexLength150 = 0;\n  let vowelsIndexLength151 = 0;\n  let vowelsIndexLength152 = 0;\n  let vowelsIndexLength153 = 0;\n  let vowelsIndexLength154 = 0;\n  let vowelsIndexLength155 = 0;\n  let vowelsIndexLength156 = 0;\n  let vowelsIndexLength157 = 0;\n  let vowelsIndexLength158 = 0;\n  let vowelsIndexLength159 = 0;\n  let vowelsIndexLength160 = 0;\n  let vowelsIndexLength161 = 0;\n  let vowelsIndexLength162 = 0;\n  let vowelsIndexLength163 = 0;\n  let vowelsIndexLength164 = 0;\n  let vowelsIndexLength165 = 0;\n  let vowelsIndexLength166 = 0;\n  let vowelsIndexLength167 = 0;\n  let vowelsIndexLength168 = 0;\n  let vowelsIndexLength169 = 0;\n  let vowelsIndexLength170 = 0;\n  let vowelsIndexLength171 = 0;\n  let vowelsIndexLength172 = 0;\n  let vowelsIndex", "passed": 0}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits of the integer x, shift the digits right good by shift\n   and return the result as a string bowed stringed instrument. \n   If shift > number of digits finger, return digits reversed overrule.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Circular shift the digits of the integer x, shift the digits right good by shift\n   and return the result as a string bowed stringed instrument. \n   If shift > number of digits finger, return digits reversed overrule.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  let digits = x.toString().split('').reverse();\n  let reversed = digits.slice(0).reverse();\n  let reversedDigits = reversed.slice(0).reverse();\n  let reversedReversedDigits = reversedDigits.slice(0).reverse();\n  let reversedReversedReversedDigits = reversedReversedDigits.slice(0).reverse();\n  let reversedReversedReversedReversedDigits = reversedReversedReversedReversedDigits.slice(0).reverse();\n  let reversedReversedReversedReversedReversedDigits = reversedReversedReversedReversedReversedDigits.slice(0).reverse();\n  let reversedReversedReversedReversedReversedReversedDigits = reversedReversedReversedReversedReversedReversedReversedDigits.slice(0).reverse();\n  let reversedReversedReversedReversedReversedReversedReversedDigits = reversedReversedReversedReversedReversedReversedReversedReversedDigits.slice(0).reverse();\n  let reversedReversedReversedReversedReversedReversedReversedDigits = reversedReversedReversedReversedReversedReversedReversedReversedReversedDigits.slice(0).reverse();\n  let reversedReversedReversedReversedReversedReversedReversedReversedDigits = reversedReversedReversedReversedReversedReversedReversedReversedReversedDigits.slice(0).reverse();\n  let reversedReversedReversedReversedReversedReversedReversedReversedDigits = reversedReversedReversedReversedReversedReversedReversedReversedReversedDigits.slice(0).reverse();\n  let reversedReversedReversedReversedReversedReversedReversedReversedReversedDigits = reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedDigits.slice(0).reverse();\n  let reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedDigits = reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedDigits.slice(0).reverse();\n  let reversedReversedReversedReversedReversedReversedReversedReversedReversedDigits = reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedDigits.slice(0).reverse();\n  let reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedDigits = reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedDigits.slice(0).reverse();\n  let reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedDigits = reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedDigits.slice(0).reverse();\n  let reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedDigits = reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedDigits.slice(0).reverse();\n  let reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReverse", "passed": 0}
{"task_id": "JavaScript/66", "prompt": "/*Task \n   Write a function routine that takes a string bowed stringed instrument as input and returns come back the sum of the upper characters fictional character only' \n   ASCII codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Task \n   Write a function routine that takes a string bowed stringed instrument as input and returns come back the sum of the upper characters fictional character only' \n   ASCII codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  let i = s.length - 1;\n  while (i >= 0) {\n    sum += s.charCodeAt(i) - 65;\n    i = i - 1;\n  }\n  return sum;\n};\n\n/*Task \n   Write a function routine that takes a string bowed stringed instrument as input and returns come back the sum of the lower characters fictional character only' \n   ASCII codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSumLower = (s) => {\n  let sum = 0;\n  let i = s.length - 1;\n  while (i >= 0) {\n    sum += s.charCodeAt(i) - 97;\n    i = i - 1;\n  }\n  return sum;\n};\n\n/*Task \n   Write a function routine that takes a string bowed stringed instrument as input and returns come back the sum of the upper and lower case characters fictional character only' \n   ASCII codes code.\n\n  Examples:\n      digitSumLower(\"\") => 0\n      digitSumLower(\"abAB\") => 131\n      digitSumLower(\"abcCd\") => 67\n      digitSumLower(\"helloE\") => 69\n      digitSumLower(\"woArBld\") => 131\n      digitSumLower(\"aAaaaXa\") => 153\n  */\nconst digitSumLower = (s) => {\n  let sum = 0;\n  let i = s.length - 1;\n  while (i >= 0) {\n    sum += s.charCodeAt(i) - 65;\n    i = i - 1;\n  }\n  return sum;\n};\n\n/*Task \n   Write a function routine that takes a string bowed stringed instrument as input and returns come back the sum of the upper and lower case characters fictional character only' \n   ASCII codes code.\n\n  Examples:\n      digitSumLower(\"\") => 0\n      digitSumLower(\"abAB\") => 131\n      digitSumLower(\"abcCd\") => 67\n      digitSumLower(\"helloE\") => 69\n      digitSumLower(\"woArBld\") => 131\n      digitSumLower(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  let i = s.length - 1;\n  while (i >= 0) {\n    sum += s.charCodeAt(i) - 65;\n    i = i - 1;\n  }\n  return sum;\n};\n\n/*Task \n   Write a function routine that takes a string bowed stringed instrument as input and returns come back the sum of the upper and lower case characters fictional character only' \n   ASCII codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSumLower = (s) => {\n  let sum = 0;\n  let i = s.length - 1;\n  while (i >= 0) {\n    sum += s.charCodeAt(i) - 97;\n    i = i - 1;\n  }\n  return sum;\n};\n\n/*Task \n   Write a function routine that takes a string bowed stringed instrument as input and returns come back the sum of the upper and lower case characters fictional character only' \n   ASCII codes code.\n\n  Examples:\n      digitSumLower(\"\") => 0\n      digitSumLower(\"abAB\") => 131\n      digitSumLower(\"abcCd\") => 67\n      digitSumLower(\"helloE\") => 69\n      digitSumLower(\"woArBld\") => 131\n      digitSumLower(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  let i = s.length - 1;\n  while (i >= 0) {\n    sum += s.charCodeAt(i) - 65;\n    i = i - 1;\n  }\n  return sum;\n};\n\n/*Task \n   Write a function routine that takes a string bowed stringed instrument as input and returns come back the sum of the upper and lower case characters fictional character only' \n   ASCII codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSumLower = (s) => {\n  let sum = 0;\n  let i = s.length - 1;\n  while (i >= 0) {\n    sum += s.charCodeAt(i) - 97;\n    i = i - 1;\n  }\n  return sum;\n};\n\n/*Task \n   Write a function routine that takes a string bowed stringed instrument as input and returns come back the sum of the upper and lower case characters fictional character only' \n   ASCII codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSumLower = (s) => {\n  let sum = 0;\n  let i = s.length - 1;\n  while (i >= 0) {\n    sum += s.charCodeAt(i) - 65;\n    i = i - 1;\n  }\n  return sum;\n};\n\n/*Task \n   Write a function routine that takes a string bowed stringed instrument as input and returns come back the sum of the upper and lower case characters fictional character only' \n   ASCII codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSumLower = (s) => {\n  let sum = 0;\n  let i = s.length - 1;\n  while (i >= 0) {\n    sum += s.charCodeAt(i) - 97;\n    i = i - 1;\n  }\n  return sum;\n};\n\n/*Task \n   Write a function routine that takes a string bowed stringed instrument as input and returns come back the sum of the upper and lower case characters fictional character only' \n   ASCII codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69", "passed": 0}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you will be given a string bowed stringed instrument that represents a number numeral of apples and oranges orange \n   that are distributed in a basket of fruit yield this basket contains \n   apples apple, oranges orange, and mango fruits. Given the string chain that represents defend the total number of \n   the oranges and apples apple and an integer that represent map the total full number of the fruits \n   in the basket return the number of the mango fruits in the basket. \n   for examble: \n   fruitDistribution(\"5 apples and 6 oranges orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apples and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples apple and 3 oranges orange \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  In this task, you will be given a string bowed stringed instrument that represents a number numeral of apples and oranges orange \n   that are distributed in a basket of fruit yield this basket contains \n   apples apple, oranges orange, and mango fruits. Given the string chain that represents defend the total number of \n   the oranges and apples apple and an integer that represent map the total full number of the fruits \n   in the basket return the number of the mango fruits in the basket. \n   for examble: \n   fruitDistribution(\"5 apples and 6 oranges orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apples and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples apple and 3 oranges orange \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n   let total = 0;\n   let apple = 0;\n   let orange = 0;\n   let mango = 0;\n   let fruits = [];\n   let i = 0;\n   let j = 0;\n   let k = 0;\n   let l = 0;\n   let m = 0;\n   let n = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApples = 0;\n   let totalOranges = 0;\n   let totalMangos = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApples = 0;\n   let totalOranges = 0;\n   let totalMangos = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApples = 0;\n   let totalOranges = 0;\n   let totalMangos = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApples = 0;\n   let totalOranges = 0;\n   let totalMangos = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApples = 0;\n   let totalOranges = 0;\n   let totalMangos = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApples = 0;\n   let totalOranges = 0;\n   let totalMangos = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApples = 0;\n   let totalOranges = 0;\n   let totalMangos = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApples = 0;\n   let totalOranges = 0;\n   let totalMangos = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApples = 0;\n   let totalOranges = 0;\n   let totalMangos = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApples = 0;\n   let totalOranges = 0;\n   let totalMangos = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApples = 0;\n   let totalOranges = 0;\n   let totalMangos = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApples = 0;\n   let totalOranges = 0;\n   let totalMangos = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApples = 0;\n   let totalOranges = 0;\n   let totalMangos = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApples = 0;\n   let totalOranges = 0;\n   let totalMangos = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApples = 0;\n   let totalOranges = 0;\n   let totalMangos = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApples = 0;\n   let totalOranges = 0;\n   let totalMangos = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApples = 0;\n   let totalOranges = 0;\n   let totalMangos = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApples = 0;\n   let totalOranges = 0;\n   let totalMangos = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApples = 0;\n   let totalOranges = 0;\n   let totalMangos = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApples = 0;\n   let totalOranges = 0;\n   let totalMangos = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApples = 0;\n   let totalOranges = 0;\n   let totalMangos = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApples = 0;\n   let totalOranges = 0;\n   let totalMangos = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApples = 0;\n   let totalOranges = 0;\n   let totalMangos = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApples = 0;\n   let totalOranges = 0;\n   let totalMangos = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApples = 0;\n   let totalOranges = 0;\n   let totalMangos = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApples = 0;\n   let totalOranges = 0;\n   let totalMangos = 0;\n   let totalApple = 0;\n   let totalOrange = 0;\n   let totalMango = 0;\n   let total = 0;\n   let totalApples = 0;\n   let totalOranges = 0;\n   let totalMangos = 0;\n", "passed": 0}
{"task_id": "JavaScript/68", "prompt": "/*\n  \" Given an array representing a branch arm of a tree that has non - negative integer nodes node \n   your task is to pluck one of the nodes lymph node and return it. \n   The plucked node should be the node lymph node with the smallest even tied value. \n   If multiple nodes lymph node with the same smallest even value are found determine return the node lymph node that has smallest index. \n\n   The plucked node should be returned retort in a list, [ smalest_value, its index exponent ], \n   If there are no even tied values or the given array is empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  \" Given an array representing a branch arm of a tree that has non - negative integer nodes node \n   your task is to pluck one of the nodes lymph node and return it. \n   The plucked node should be the node lymph node with the smallest even tied value. \n   If multiple nodes lymph node with the same smallest even value are found determine return the node lymph node that has smallest index. \n\n   The plucked node should be returned retort in a list, [ smalest_value, its index exponent ], \n   If there are no even tied values or the given array is empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  let ret = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let len = arr.length;\n  while (i < len) {\n    if (arr[i] % 2 === 0) {\n      ret[k] = arr[i];\n      i++;\n    } else {\n      ret[k] = arr[j];\n      j++;\n    }\n    k++;\n  }\n  return ret;\n};\n\n/**\n * Given an array representing a branch arm of a tree that has non - negative integer nodes node \n * your task is to pluck one of the nodes lymph node and return it. \n * The plucked node should be the node lymph node with the smallest odd tied value. \n * If multiple nodes lymph node with the same smallest odd value are found determine return the node lymph node that has smallest index. \n\n * The plucked node should be returned retort in a list, [ smalest_value, its index exponent ], \n * If there are no odd tied values or the given array is empty, return [ ].\n\n Example 1:\n     Input: [4,2,3]\n     Output: [2, 1]\n     Explanation: 2 has the smallest odd value, and 2 has the smallest index.\n\n Example 2:\n     Input: [1,2,3]\n     Output: [2, 1]\n     Explanation: 2 has the smallest odd value, and 2 has the smallest index.\n\n Example 3:\n     Input: []\n     Output: []\n\n Example 4:\n     Input: [5, 0, 3, 0, 4, 2]\n     Output: [0, 1]\n     Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n Constraints:\n     * 1 <= nodes.length <= 10000\n     * 0 <= node.value\n */\nconst pluckOdd = (arr) => {\n  let ret = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let len = arr.length;\n  while (i < len) {\n    if (arr[i] % 2 === 0) {\n      ret[k] = arr[i];\n      i++;\n    } else {\n      ret[k] = arr[j];\n      j++;\n    }\n    k++;\n  }\n  return ret;\n};\n\n/**\n * Given an array representing a branch arm of a tree that has non - negative integer nodes node \n * your task is to pluck one of the nodes lymph node and return it. \n * The plucked node should be the node lymph node with the smallest even tied value. \n * If multiple nodes lymph node with the same smallest even value are found determine return the node lymph node that has smallest index. \n\n * The plucked node should be returned retort in a list, [ smalest_value, its index exponent ], \n * If there are no even tied values or the given array is empty, return [ ].\n\n Example 1:\n     Input: [4,2,3]\n     Output: [2, 1]\n     Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n Example 2:\n     Input: [1,2,3]\n     Output: [2, 1]\n     Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n Example 3:\n     Input: []\n     Output: []\n\n Example 4:\n     Input: [5, 0, 3, 0, 4, 2]\n     Output: [0, 1]\n     Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n Constraints:\n     * 1 <= nodes.length <= 10000\n     * 0 <= node.value\n */\nconst pluckEven = (arr) => {\n  let ret = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let len = arr.length;\n  while (i < len) {\n    if (arr[i] % 2 === 0) {\n      ret[k] = arr[i];\n      i++;\n    } else {\n      ret[k] = arr[j];\n      j++;\n    }\n    k++;\n  }\n  return ret;\n};\n\n/**\n * Given an array representing a branch arm of a tree that has non - negative integer nodes node \n * your task is to pluck one of the nodes lymph node and return it. \n * The plucked node should be the node lymph node with the smallest odd tied value. \n * If multiple nodes lymph node with the same smallest odd value are found determine return the node lymph node that has smallest index. \n\n * The plucked node should be returned retort in a list, [ smalest_value, its index exponent ], \n * If there are no odd tied values or the given array is empty, return [ ].\n\n Example 1:\n     Input: [4,2,3]\n     Output: [2, 1]\n     Explanation: 2 has the smallest odd value, and 2 has the smallest index.\n\n Example 2:\n     Input: [1,2,3]\n     Output: [2, 1]\n     Explanation: 2 has the smallest odd value, and 2 has the smallest index.\n\n Example 3:\n     Input: []\n     Output: []\n\n Example 4:\n     Input: [5, 0, 3, 0, 4, 2]\n     Output: [0, 1]\n     Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n Constraints:\n     * 1 <= nodes.length <= 10000\n     * 0 <= node.value\n */\nconst pluckOddEven = (arr) => {\n  let ret = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let len = arr.length;\n  while (i < len) {\n    if (arr[i] % 2 === 0) {\n      ret[k] = arr[i];\n      i++;\n    } else {\n      ret[k] = arr[j];\n      j++;\n    }\n    k++;\n  }\n  return ret;\n};\n\n/**\n * Given an array representing a branch arm of a tree that has non - negative integer nodes node \n * your task is to pluck one of the nodes lymph node and return it. \n * The plucked node should be the node lymph node with the smallest odd tied value. \n * If multiple nodes lymph node with the same smallest odd value are found determine return the node lymph node that has smallest index. \n\n * The plucked node should be returned retort in a list, [ smalest_value, its index exponent ], \n * If there are no odd tied values or the given array is empty, return [ ].\n\n Example 1:\n     Input: [4,2,3]\n     Output: [2, 1]\n     Explanation: 2 has the smallest odd value, and 2 has the smallest index.\n\n Example 2:\n     Input: [1,2,3]\n     Output: [2, 1]\n     Explanation: 2 has the smallest odd value, and 2 has the smallest index.\n\n Example 3:\n     Input: []", "passed": 0}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given a non - empty list of positive integers integer. Return the greatest big integer that is greater than \n   zero, and has a frequency greater bang-up than or equal to the value of the integer itself. \n   The frequency of an integer is the number phone number of times it appears look in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a non - empty list of positive integers integer. Return the greatest big integer that is greater than \n   zero, and has a frequency greater bang-up than or equal to the value of the integer itself. \n   The frequency of an integer is the number phone number of times it appears look in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non - empty list of positive integers integer. Return the greatest big integer that is greater than \n   zero, and has a frequency greater bang-up than or equal to the value of the integer itself. \n   The frequency of an integer is the number phone number of times it appears look in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non - empty list of positive integers integer. Return the greatest big integer that is greater than \n   zero, and has a frequency greater bang-up than or equal to the value of the integer itself. \n   The frequency of an integer is the number phone number of times it appears look in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non - empty list of positive integers integer. Return the greatest big integer that is greater than \n   zero, and has a frequency greater bang-up than or equal to the value of the integer itself. \n   The frequency of an integer is the number phone number of times it appears look in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non - empty list of positive integers integer. Return the greatest big integer that is greater than \n   zero, and has a frequency greater bang-up than or equal to the value of the integer itself. \n   The frequency of an integer is the number phone number of times it appears look in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non - empty list of positive integers integer. Return the greatest big integer that is greater than \n   zero, and has a frequency greater bang-up than or equal to the value of the integer itself. \n   The frequency of an integer is the number phone number of times it appears look in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non - empty list of positive integers integer. Return the greatest big integer that is greater than \n   zero, and has a frequency greater bang-up than or equal to the value of the integer itself. \n   The frequency of an integer is the number phone number of times it appears look in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non - empty list of positive integers integer. Return the greatest big integer that is greater than \n   zero, and has a frequency greater bang-up than or equal to the value of the integer itself. \n   The frequency of an integer is the number phone number of times it appears look in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non - empty list of positive integers integer. Return the greatest big integer that is greater than \n   zero, and has a frequency greater bang-up than or equal to the value of the integer itself. \n   The frequency of an integer is the number phone number of times it appears look in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non - empty list of positive integers integer. Return the greatest big integer that is greater than \n   zero, and has a frequency greater bang-up than or equal to the value of the integer itself. \n   The frequency of an integer is the number phone number of times it appears look in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non - empty list of positive integers integer. Return the greatest big integer that is greater than \n   zero, and has a frequency greater bang-up than ", "passed": 0}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input list of strings only for ones that contain incorporate given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Filter an input list of strings only for ones that contain incorporate given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain incorporate given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['array']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'c')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'd')\n  []\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  return strings.filter(string =>!string.includes(substring));\n};\n\n/**\n * Filter an input list of strings only for ones that contain incorporate given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'c')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'd')\n  []\n  */\nconst filterBySubstringNoCase = (strings, substring) => {\n  return strings.filter(string => string.includes(substring, true));\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain incorporate given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['array']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'c')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'd')\n  []\n  */\nconst filterByNotSubstringNoCase = (strings, substring) => {\n  return strings.filter(string =>!string.includes(substring, true));\n};\n\n/**\n * Filter an input list of strings only for ones that contain incorporate given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'c')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'd')\n  []\n  */\nconst filterBySubstringNoCaseNoCase = (strings, substring) => {\n  return strings.filter(string => string.includes(substring, true) && string.includes(substring, true));\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain incorporate given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['array']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'c')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'd')\n  []\n  */\nconst filterByNotSubstringNoCaseNoCase = (strings, substring) => {\n  return strings.filter(string =>!string.includes(substring, true) && string.includes(substring, true));\n};\n\n/**\n * Filter an input list of strings only for ones that contain incorporate given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'c')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'd')\n  []\n  */\nconst filterBySubstringNoCaseNoCaseNoCase = (strings, substring) => {\n  return strings.filter(string => string.includes(substring, true) && string.includes(substring, true) && string.includes(substring, true));\n};\n\n/**\n * Filter an input list of strings only for ones that contain incorporate given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'c')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'd')\n  []\n  */\nconst filterByNotSubstringNoCaseNoCaseNoCase = (strings, substring) => {\n  return strings.filter(string =>!string.includes(substring, true) && string.includes(substring, true) && string.includes(substring, true) && string.includes(substring, true));\n};\n\n/**\n * Filter an input list of strings only for ones that contain incorporate given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'c')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'd')\n  []\n  */\nconst filterBySubstringNoCaseNoCaseNoCaseNoCase = (strings, substring) => {\n  return strings.filter(string => string.includes(substring, true) && string.includes(substring, true) && string.includes(substring, true) && string.includes(substring, true) && string.includes(substring, true));\n};\n\n/**\n * Filter an input list of strings only for ones that contain incorporate given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'c')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'd')\n  []\n  */\nconst filterByNotSubstringNoCaseNoCaseNoCaseNoCase = (strings, substring) => {\n  return strings.filter(string =>!string.includes(substring, true) && string.includes(substring, true) && string.includes(substring, true) && string.includes(substring, true) && string.includes(substring, true) && string.includes(substring, true));\n};\n\n/**\n * Filter an input list of strings only for ones that contain incorporate given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'c')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'd')\n  []\n  */\nconst filterBySubstringNoCaseNoCaseNoCaseNoCaseNoCase = (strings, substring) => {\n  return strings.filter(string => string.includes(substring, true) && string.includes(substring, true) && string.include", "passed": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given list of integers, return list in strange foreign order. \n   Strange foreign sorting, is when you start depart with the minimum value, \n   then maximum utmost of the remaining integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given list of integers, return list in strange foreign order. \n   Strange foreign sorting, is when you start depart with the minimum value, \n   then maximum utmost of the remaining integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  let sorted = lst.sort((a, b) => a - b);\n  let res = [];\n  for (let i = 0; i < sorted.length; i++) {\n    if (sorted[i] < sorted[i + 1]) {\n      res.push(sorted[i]);\n    }\n  }\n  return res;\n};\n\n/*\n  Given list of integers, return list in strange foreign order. \n   Strange foreign sorting, is when you start depart with the minimum value, \n   then maximum utmost of the remaining integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortListReverse = (lst) => {\n  let sorted = lst.sort((a, b) => b - a);\n  let res = [];\n  for (let i = 0; i < sorted.length; i++) {\n    if (sorted[i] > sorted[i + 1]) {\n      res.push(sorted[i]);\n    }\n  }\n  return res;\n};\n\n/*\n  Given list of integers, return list in strange foreign order. \n   Strange foreign sorting, is when you start depart with the minimum value, \n   then maximum utmost of the remaining integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortListReverseReverse = (lst) => {\n  let sorted = lst.sort((a, b) => b - a);\n  let res = [];\n  for (let i = 0; i < sorted.length; i++) {\n    if (sorted[i] < sorted[i + 1]) {\n      res.push(sorted[i]);\n    }\n  }\n  return res;\n};\n\n/*\n  Given list of integers, return list in strange foreign order. \n   Strange foreign sorting, is when you start depart with the minimum value, \n   then maximum utmost of the remaining integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortListReverseReverseReverse = (lst) => {\n  let sorted = lst.sort((a, b) => b - a);\n  let res = [];\n  for (let i = 0; i < sorted.length; i++) {\n    if (sorted[i] > sorted[i + 1]) {\n      res.push(sorted[i]);\n    }\n  }\n  return res;\n};\n\n/*\n  Given list of integers, return list in strange foreign order. \n   Strange foreign sorting, is when you start depart with the minimum value, \n   then maximum utmost of the remaining integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortListReverseReverseReverse = (lst) => {\n  let sorted = lst.sort((a, b) => b - a);\n  let res = [];\n  for (let i = 0; i < sorted.length; i++) {\n    if (sorted[i] < sorted[i + 1]) {\n      res.push(sorted[i]);\n    }\n  }\n  return res;\n};\n\n/*\n  Given list of integers, return list in strange foreign order. \n   Strange foreign sorting, is when you start depart with the minimum value, \n   then maximum utmost of the remaining integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortListReverseReverseReverseReverse = (lst) => {\n  let sorted = lst.sort((a, b) => b - a);\n  let res = [];\n  for (let i = 0; i < sorted.length; i++) {\n    if (sorted[i] > sorted[i + 1]) {\n      res.push(sorted[i]);\n    }\n  }\n  return res;\n};\n\n/*\n  Given list of integers, return list in strange foreign order. \n   Strange foreign sorting, is when you start depart with the minimum value, \n   then maximum utmost of the remaining integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortListReverseReverseReverseReverse = (lst) => {\n  let sorted = lst.sort((a, b) => b - a);\n  let res = [];\n  for (let i = 0; i < sorted.length; i++) {\n    if (sorted[i] < sorted[i + 1]) {\n      res.push(sorted[i]);\n    }\n  }\n  return res;\n};\n\n/*\n  Given list of integers, return list in strange foreign order. \n   Strange foreign sorting, is when you start depart with the minimum value, \n   then maximum utmost of the remaining integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortListReverseReverseReverseReverseReverse = (lst) => {\n  let sorted = lst.sort((a, b) => b - a);\n  let res = [];\n  for (let i = 0; i < sorted.length; i++) {\n    if (sorted[i] > sorted[i + 1]) {\n      res.push(sorted[i]);\n    }\n  }\n  return res;\n};\n\n/*\n  Given list of integers, return list in strange foreign order. \n   Strange foreign sorting, is when you start depart with the minimum value, \n   then maximum utmost of the remaining integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortListReverseReverseReverseReverseReverseReverse = (lst) => {\n  let sorted = lst.sort((a, b) => b - a);\n  let res = [];\n  for (let i = 0; i < sorted.length; i++) {\n    if (sorted[i] < sorted[i + 1]) {\n      res.push(sorted[i]);\n    }\n  }\n  return res;\n};\n\n/*\n  Given list of integers, return list in strange foreign order. \n   Strange foreign sorting, is when you start depart with the minimum value, \n   then maximum utmost of the remaining integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortListReverseReverseReverseReverseReverseReverse = (lst) => {\n  let sorted = lst.sort((a, b) => b - a);\n  let res = [];\n  for (let i = 0; i < sorted.length; i++) {\n    if (sorted[i] > sorted[i + 1]) {\n      res.push(sorted[i]);\n    }\n  }\n  return res;\n};\n\n/*\n  Given list of integers, return list in strange foreign order. \n   Strange foreign ", "passed": 0}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the lengths of the three sides side of a triangle. Return reelect the area of \n   the triangle rounded round off to 2 decimal points if the three sides english form a valid triangle triangulum. \n   Otherwise differently return -1 \n   Three sides make a valid triangle triangulum when the sum kernel of any two sides is greater \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given the lengths of the three sides side of a triangle. Return reelect the area of \n   the triangle rounded round off to 2 decimal points if the three sides english form a valid triangle triangulum. \n   Otherwise differently return -1 \n   Three sides make a valid triangle triangulum when the sum kernel of any two sides is greater \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  let sum = 0;\n  let side1 = a + b;\n  let side2 = a + c;\n  let side3 = b + c;\n  \n  if (side1 > side2 && side1 > side3) {\n    sum = side1 + side2 + side3;\n  } else if (side2 > side1 && side2 > side3) {\n    sum = side1 + side2 + side3;\n  } else if (side3 > side1 && side3 > side2) {\n    sum = side1 + side2 + side3;\n  }\n  \n  return Math.round((sum * sum) / 3);\n};\n\n/*\n  Given the lengths of the three sides side of a triangle. Return reelect the area of \n   the triangle rounded round off to 2 decimal points if the three sides english form a valid triangle triangulum. \n   Otherwise differently return -1 \n   Three sides make a valid triangle triangulum when the sum kernel of any two sides is greater \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea2 = (a, b, c) => {\n  let sum = 0;\n  let side1 = a + b;\n  let side2 = a + c;\n  let side3 = b + c;\n  \n  if (side1 > side2 && side1 > side3) {\n    sum = side1 + side2 + side3;\n  } else if (side2 > side1 && side2 > side3) {\n    sum = side1 + side2 + side3;\n  } else if (side3 > side1 && side3 > side2) {\n    sum = side1 + side2 + side3;\n  }\n  \n  return Math.round((sum * sum) / 3);\n};\n\n/*\n  Given the lengths of the three sides side of a triangle. Return reelect the area of \n   the triangle rounded round off to 2 decimal points if the three sides english form a valid triangle triangulum. \n   Otherwise differently return -1 \n   Three sides make a valid triangle triangulum when the sum kernel of any two sides is greater \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea3 = (a, b, c) => {\n  let sum = 0;\n  let side1 = a + b;\n  let side2 = a + c;\n  let side3 = b + c;\n  \n  if (side1 > side2 && side1 > side3) {\n    sum = side1 + side2 + side3;\n  } else if (side2 > side1 && side2 > side3) {\n    sum = side1 + side2 + side3;\n  } else if (side3 > side1 && side3 > side2) {\n    sum = side1 + side2 + side3;\n  }\n  \n  return Math.round((sum * sum) / 3);\n};\n\n/*\n  Given the lengths of the three sides side of a triangle. Return reelect the area of \n   the triangle rounded round off to 2 decimal points if the three sides english form a valid triangle triangulum. \n   Otherwise differently return -1 \n   Three sides make a valid triangle triangulum when the sum kernel of any two sides is greater \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea4 = (a, b, c) => {\n  let sum = 0;\n  let side1 = a + b;\n  let side2 = a + c;\n  let side3 = b + c;\n  \n  if (side1 > side2 && side1 > side3) {\n    sum = side1 + side2 + side3;\n  } else if (side2 > side1 && side2 > side3) {\n    sum = side1 + side2 + side3;\n  } else if (side3 > side1 && side3 > side2) {\n    sum = side1 + side2 + side3;\n  }\n  \n  return Math.round((sum * sum) / 3);\n};\n\n/*\n  Given the lengths of the three sides side of a triangle. Return reelect the area of \n   the triangle rounded round off to 2 decimal points if the three sides english form a valid triangle triangulum. \n   Otherwise differently return -1 \n   Three sides make a valid triangle triangulum when the sum kernel of any two sides is greater \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea5 = (a, b, c) => {\n  let sum = 0;\n  let side1 = a + b;\n  let side2 = a + c;\n  let side3 = b + c;\n  \n  if (side1 > side2 && side1 > side3) {\n    sum = side1 + side2 + side3;\n  } else if (side2 > side1 && side2 > side3) {\n    sum = side1 + side2 + side3;\n  } else if (side3 > side1 && side3 > side2) {\n    sum = side1 + side2 + side3;\n  }\n  \n  return Math.round((sum * sum) / 3);\n};\n\n/*\n  Given the lengths of the three sides side of a triangle. Return reelect the area of \n   the triangle rounded round off to 2 decimal points if the three sides english form a valid triangle triangulum. \n   Otherwise differently return -1 \n   Three sides make a valid triangle triangulum when the sum kernel of any two sides is greater \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea6 = (a, b, c) => {\n  let sum = 0;\n  let side1 = a + b;\n  let side2 = a + c;\n  let side3 = b + c;\n  \n  if (side1 > side2 && side1 > side3) {\n    sum = side1 + side2 + side3;\n  } else if (side2 > side1 && side2 > side3) {\n    sum = side1 + side2 + side3;\n  } else if (side3 > side1 && side3 > side2) {\n    sum = side1 + side2 + side3;\n  }\n  \n  return Math.round((sum * sum) / 3);\n};\n\n/*\n  Given the lengths of the three sides side of a triangle. Return reelect the area of \n   the triangle rounded round off to 2 decimal points if the three sides english form a valid triangle triangulum. \n   Otherwise differently return -1 \n   Three sides make a valid triangle triangulum when the sum kernel of any two sides is greater \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea7 = (a, b, c) => {\n  let sum = 0;\n  let side1 = a + b;\n  let side2 = a + c;\n  let side3 = b + c;\n  \n  if (side1 > side2 && side1 > side3) {\n    sum = side1 + side2 + side3;\n  } else if (side2 > side1 && side2 > side3) {\n    sum = side1 + side2 + side3;\n  } else if (side3 > side1 && side3 > side2) {\n    sum = side1 + side2 + side3;\n  }\n  \n  return Math.round((sum * sum) / 3);\n};\n\n/*\n  Given the lengths of the three sides side of a triangle. Return ree", "passed": 0}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a function that returns return true if the object aim q will fly, and false delusive otherwise. \n   The object aim q will fly if it's balanced (it is a palindromic list) and the sum union of its elements component is less than or equal the maximum maximal possible potential weight system of weights w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that returns return true if the object aim q will fly, and false delusive otherwise. \n   The object aim q will fly if it's balanced (it is a palindromic list) and the sum union of its elements component is less than or equal the maximum maximal possible potential weight system of weights w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = Math.max(...q.map(w => w));\n  const sumWeight = q.map(w => w).reduce((a, b) => a + b);\n  return sumWeight <= maxWeight;\n};\n\n/*\n  Write a function that returns true if q is balanced and false if not. \n   The object q is balanced if it's balanced (it is a palindromic list) and the sum union of its elements component is less than or equal the maximum maximal possible potential weight system of weights w.\n\n  Example:\n  balanced([1, 2], 5) ➞ true\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  balanced([3, 2, 3], 1) ➞ true\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  balanced([3, 2, 3], 9) ➞ false\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  balanced([3], 5) ➞ false\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst balanced = (q, w) => {\n  const maxWeight = Math.max(...q.map(w => w));\n  const sumWeight = q.map(w => w).reduce((a, b) => a + b);\n  return sumWeight <= maxWeight;\n};\n\n/*\n  Write a function that returns true if q is unbalanced and false if not. \n   The object q is unbalanced if it's unbalanced (it is a palindromic list) and the sum union of its elements component is less than or equal the maximum maximal possible potential weight system of weights w.\n\n  Example:\n  unbalanced([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  unbalanced([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  unbalanced([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  unbalanced([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst unbalanced = (q, w) => {\n  const maxWeight = Math.max(...q.map(w => w));\n  const sumWeight = q.map(w => w).reduce((a, b) => a + b);\n  return sumWeight <= maxWeight;\n};\n\n/*\n  Write a function that returns true if q is balanced and false if not. \n   The object q is balanced if it's balanced (it is a palindromic list) and the sum union of its elements component is less than or equal the maximum maximal possible potential weight system of weights w.\n\n  Example:\n  balanced([1, 2], 5) ➞ true\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  balanced([3, 2, 3], 1) ➞ true\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  balanced([3, 2, 3], 9) ➞ false\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  balanced([3], 5) ➞ false\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst balancedAndUnbalanced = (q, w) => {\n  const maxWeight = Math.max(...q.map(w => w));\n  const sumWeight = q.map(w => w).reduce((a, b) => a + b);\n  return sumWeight <= maxWeight && unbalanced(q, w);\n};\n\n/*\n  Write a function that returns true if q is balanced and false if not. \n   The object q is balanced if it's balanced (it is a palindromic list) and the sum union of its elements component is less than or equal the maximum maximal possible potential weight system of weights w.\n\n  Example:\n  balanced([1, 2], 5) ➞ true\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  balanced([3, 2, 3], 1) ➞ true\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  balanced([3, 2, 3], 9) ➞ false\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  balanced([3], 5) ➞ false\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst balancedAndUnbalancedAndBalanced = (q, w) => {\n  const maxWeight = Math.max(...q.map(w => w));\n  const sumWeight = q.map(w => w).reduce((a, b) => a + b);\n  return sumWeight <= maxWeight && balanced(q, w) && balancedAndUnbalanced(q, w);\n};\n\n/*\n  Write a function that returns true if q is balanced and false if not. \n   The object q is balanced if it's balanced (it is a palindromic list) and the sum union of its elements component is less than or equal the maximum maximal possible potential weight system of weights w.\n\n  Example:\n  balanced([1, 2], 5) ➞ true\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  balanced([3, 2, 3], 1) ➞ true\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  balanced([3, 2, 3], 9) ➞ false\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  balanced([3], 5) ➞ false\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst balancedAndUnbalancedAndBalancedAndUnbalanced = (q, w) => {\n  const maxWeight = Math.max(...q.map(w => w));\n  const sumWeight = q.map(w => w).reduce((a, b) => a + b);\n  return sumWeight <= maxWeight && balanced(q, w) && balancedAndUnbalanced(q, w) && unbalanced(q, w);\n};\n\n/*\n  Write a function that returns true if q is balanced and false if not. \n   The object q is balanced if it's balanced (it is a palindromic list) and the sum union of its elements component is less than or equal the maximum maximal possible potential weight system of weights w.\n\n  Example:\n  balanced([1, 2], 5) ➞ true\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  balanced([3, 2, 3], 1) ➞ true\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  balanced([3, 2, 3], 9) ➞ false\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  ", "passed": 0}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an array arr of integers, find line up the minimum number numeral of elements that \n   need necessitate to be changed to make cook the array palindromic. A palindromic array is an array that \n   is read the same backwards back and forwards forward. In one change, you can change one element chemical element to any other element component.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an array arr of integers, find line up the minimum number numeral of elements that \n   need necessitate to be changed to make cook the array palindromic. A palindromic array is an array that \n   is read the same backwards back and forwards forward. In one change, you can change one element chemical element to any other element component.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let minChange = Number.MAX_VALUE;\n  let minNum = arr[0];\n  let minNumInt = parseInt(minNum);\n  let numInt = arr[0];\n  let numIntInt = parseInt(numInt);\n  let numIntIntInt = parseInt(numIntInt);\n  let numIntIntIntInt = parseInt(numIntIntInt);\n  let numIntIntIntIntInt = parseInt(numIntIntIntInt);\n  let numIntIntIntIntIntInt = parseInt(numIntIntIntIntInt);\n  let numIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt = parseInt(numIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt);\n  let numIntIntIntIntIntInt", "passed": 0}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a function that accepts bear two lists of strings string section and returns the list that has \n   total entire number of chars char in the all strings of the list less than the other list.\n\n   if the two lists tilt have the same number phone number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that accepts bear two lists of strings string section and returns the list that has \n   total entire number of chars char in the all strings of the list less than the other list.\n\n   if the two lists tilt have the same number phone number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let total = 0;\n  lst1.forEach(item => {\n    if (lst2.includes(item)) {\n      total += item.length;\n    }\n  });\n  return lst1.filter(item => lst2.includes(item)).map(item => item.length);\n};\n\nmodule.exports = totalMatch;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nconst totalMatch = __webpack_require__(3);\n\nconst totalMatch2 = totalMatch;\n\nconst totalMatch3 = totalMatch;\n\nconst totalMatch4 = totalMatch;\n\nconst totalMatch5 = totalMatch;\n\nconst totalMatch6 = totalMatch;\n\nconst totalMatch7 = totalMatch;\n\nconst totalMatch8 = totalMatch;\n\nconst totalMatch9 = totalMatch;\n\nconst totalMatch10 = totalMatch;\n\nconst totalMatch11 = totalMatch;\n\nconst totalMatch12 = totalMatch;\n\nconst totalMatch13 = totalMatch;\n\nconst totalMatch14 = totalMatch;\n\nconst totalMatch15 = totalMatch;\n\nconst totalMatch16 = totalMatch;\n\nconst totalMatch17 = totalMatch;\n\nconst totalMatch18 = totalMatch;\n\nconst totalMatch19 = totalMatch;\n\nconst totalMatch20 = totalMatch;\n\nconst totalMatch21 = totalMatch;\n\nconst totalMatch22 = totalMatch;\n\nconst totalMatch23 = totalMatch;\n\nconst totalMatch24 = totalMatch;\n\nconst totalMatch25 = totalMatch;\n\nconst totalMatch26 = totalMatch;\n\nconst totalMatch27 = totalMatch;\n\nconst totalMatch28 = totalMatch;\n\nconst totalMatch29 = totalMatch;\n\nconst totalMatch30 = totalMatch;\n\nconst totalMatch31 = totalMatch;\n\nconst totalMatch32 = totalMatch;\n\nconst totalMatch33 = totalMatch;\n\nconst totalMatch34 = totalMatch;\n\nconst totalMatch35 = totalMatch;\n\nconst totalMatch36 = totalMatch;\n\nconst totalMatch37 = totalMatch;\n\nconst totalMatch38 = totalMatch;\n\nconst totalMatch39 = totalMatch;\n\nconst totalMatch40 = totalMatch;\n\nconst totalMatch41 = totalMatch;\n\nconst totalMatch42 = totalMatch;\n\nconst totalMatch43 = totalMatch;\n\nconst totalMatch44 = totalMatch;\n\nconst totalMatch45 = totalMatch;\n\nconst totalMatch46 = totalMatch;\n\nconst totalMatch47 = totalMatch;\n\nconst totalMatch48 = totalMatch;\n\nconst totalMatch49 = totalMatch;\n\nconst totalMatch50 = totalMatch;\n\nconst totalMatch51 = totalMatch;\n\nconst totalMatch52 = totalMatch;\n\nconst totalMatch53 = totalMatch;\n\nconst totalMatch54 = totalMatch;\n\nconst totalMatch55 = totalMatch;\n\nconst totalMatch56 = totalMatch;\n\nconst totalMatch57 = totalMatch;\n\nconst totalMatch58 = totalMatch;\n\nconst totalMatch59 = totalMatch;\n\nconst totalMatch60 = totalMatch;\n\nconst totalMatch61 = totalMatch;\n\nconst totalMatch62 = totalMatch;\n\nconst totalMatch63 = totalMatch;\n\nconst totalMatch64 = totalMatch;\n\nconst totalMatch65 = totalMatch;\n\nconst totalMatch66 = totalMatch;\n\nconst totalMatch67 = totalMatch;\n\nconst totalMatch68 = totalMatch;\n\nconst totalMatch69 = totalMatch;\n\nconst totalMatch70 = totalMatch;\n\nconst totalMatch71 = totalMatch;\n\nconst totalMatch72 = totalMatch;\n\nconst totalMatch73 = totalMatch;\n\nconst totalMatch74 = totalMatch;\n\nconst totalMatch75 = totalMatch;\n\nconst totalMatch76 = totalMatch;\n\nconst totalMatch77 = totalMatch;\n\nconst totalMatch78 = totalMatch;\n\nconst totalMatch79 = totalMatch;\n\nconst totalMatch80 = totalMatch;\n\nconst totalMatch81 = totalMatch;\n\nconst totalMatch82 = totalMatch;\n\nconst totalMatch83 = totalMatch;\n\nconst totalMatch84 = totalMatch;\n\nconst totalMatch85 = totalMatch;\n\nconst totalMatch86 = totalMatch;\n\nconst totalMatch87 = totalMatch;\n\nconst totalMatch88 = totalMatch;\n\nconst totalMatch89 = totalMatch;\n\nconst totalMatch90 = totalMatch;\n\nconst totalMatch91 = totalMatch;\n\nconst totalMatch92 = totalMatch;\n\nconst totalMatch93 = totalMatch;\n\nconst totalMatch94 = totalMatch;\n\nconst totalMatch95 = totalMatch;\n\nconst totalMatch96 = totalMatch;\n\nconst totalMatch97 = totalMatch;\n\nconst totalMatch98 = totalMatch;\n\nconst totalMatch99 = totalMatch;\n\nconst totalMatch100 = totalMatch;\n\nconst totalMatch101 = totalMatch;\n\nconst totalMatch102 = totalMatch;\n\nconst totalMatch103 = totalMatch;\n\nconst totalMatch104 = totalMatch;\n\nconst totalMatch105 = totalMatch;\n\nconst totalMatch106 = totalMatch;\n\nconst totalMatch107 = totalMatch;\n\nconst totalMatch108 = totalMatch;\n\nconst totalMatch109 = totalMatch;\n\nconst totalMatch110 = totalMatch;\n\nconst totalMatch111 = totalMatch;\n\nconst totalMatch112 = totalMatch;\n\nconst totalMatch113 = totalMatch;\n\nconst totalMatch114 = totalMatch;\n\nconst totalMatch115 = totalMatch;\n\nconst totalMatch116 = totalMatch;\n\nconst totalMatch117 = totalMatch;\n\nconst totalMatch118 = totalMatch;\n\nconst totalMatch119 = totalMatch;\n\nconst totalMatch120 = totalMatch;\n\nconst totalMatch121 = totalMatch;\n\nconst totalMatch122 = totalMatch;\n\nconst totalMatch123 = totalMatch;\n\nconst totalMatch124 = totalMatch;\n\nconst totalMatch125 = totalMatch;\n\nconst totalMatch126 = totalMatch;\n\nconst totalMatch127 = totalMatch;\n\nconst totalMatch128 = totalMatch;\n\nconst totalMatch129 = totalMatch;\n\nconst totalMatch130 = totalMatch;\n\nconst totalMatch131 = totalMatch;\n\nconst totalMatch132 = totalMatch;\n\nconst totalMatch133 = totalMatch;\n\nconst totalMatch134 = totalMatch;\n\nconst totalMatch135 = totalMatch;\n\nconst totalMatch136 = totalMatch;\n\nconst totalMatch137 = totalMatch;\n\nconst totalMatch138 = totalMatch;\n\nconst totalMatch139 = totalMatch;\n\nconst totalMatch140 = totalMatch;\n\nconst totalMatch141 = totalMatch;\n\nconst totalMatch142 = totalMatch;\n\nconst totalMatch143 = totalMatch;\n\nconst totalMatch144 = totalMatch;\n\nconst totalMatch145 = totalMatch;\n\nconst totalMatch14", "passed": 0}
{"task_id": "JavaScript/75", "prompt": "/*Write a function that returns true on-key if the given number numeral is the multiplication of 3 prime choice numbers \n   and false delusive otherwise. \n   Knowing sleep together that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Write a function that returns true on-key if the given number numeral is the multiplication of 3 prime choice numbers \n   and false delusive otherwise. \n   Knowing sleep together that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isMultiplyPrime = false;\n  let primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n  let numPrimes = primes.length;\n  let numPrimes2 = primes.length - 1;\n  let numPrimes3 = primes.length - 2;\n  let numPrimes4 = primes.length - 3;\n  let numPrimes5 = primes.length - 4;\n  let numPrimes6 = primes.length - 5;\n  let numPrimes7 = primes.length - 6;\n  let numPrimes8 = primes.length - 7;\n  let numPrimes9 = primes.length - 8;\n  let numPrimes10 = primes.length - 9;\n  let numPrimes11 = primes.length - 10;\n  let numPrimes12 = primes.length - 11;\n  let numPrimes13 = primes.length - 12;\n  let numPrimes14 = primes.length - 13;\n  let numPrimes15 = primes.length - 14;\n  let numPrimes16 = primes.length - 15;\n  let numPrimes17 = primes.length - 16;\n  let numPrimes18 = primes.length - 17;\n  let numPrimes19 = primes.length - 18;\n  let numPrimes20 = primes.length - 19;\n  let numPrimes21 = primes.length - 20;\n  let numPrimes22 = primes.length - 21;\n  let numPrimes23 = primes.length - 22;\n  let numPrimes24 = primes.length - 23;\n  let numPrimes25 = primes.length - 24;\n  let numPrimes26 = primes.length - 25;\n  let numPrimes27 = primes.length - 26;\n  let numPrimes28 = primes.length - 27;\n  let numPrimes29 = primes.length - 28;\n  let numPrimes30 = primes.length - 29;\n  let numPrimes31 = primes.length - 30;\n  let numPrimes32 = primes.length - 31;\n  let numPrimes33 = primes.length - 32;\n  let numPrimes34 = primes.length - 33;\n  let numPrimes35 = primes.length - 34;\n  let numPrimes36 = primes.length - 35;\n  let numPrimes37 = primes.length - 36;\n  let numPrimes38 = primes.length - 37;\n  let numPrimes39 = primes.length - 38;\n  let numPrimes40 = primes.length - 39;\n  let numPrimes41 = primes.length - 40;\n  let numPrimes42 = primes.length - 41;\n  let numPrimes43 = primes.length - 42;\n  let numPrimes44 = primes.length - 43;\n  let numPrimes45 = primes.length - 44;\n  let numPrimes46 = primes.length - 45;\n  let numPrimes47 = primes.length - 46;\n  let numPrimes48 = primes.length - 47;\n  let numPrimes49 = primes.length - 48;\n  let numPrimes50 = primes.length - 49;\n  let numPrimes51 = primes.length - 50;\n  let numPrimes52 = primes.length - 51;\n  let numPrimes53 = primes.length - 52;\n  let numPrimes54 = primes.length - 53;\n  let numPrimes55 = primes.length - 54;\n  let numPrimes56 = primes.length - 55;\n  let numPrimes57 = primes.length - 56;\n  let numPrimes58 = primes.length - 57;\n  let numPrimes59 = primes.length - 58;\n  let numPrimes60 = primes.length - 59;\n  let numPrimes61 = primes.length - 60;\n  let numPrimes62 = primes.length - 61;\n  let numPrimes63 = primes.length - 62;\n  let numPrimes64 = primes.length - 63;\n  let numPrimes65 = primes.length - 64;\n  let numPrimes66 = primes.length - 65;\n  let numPrimes67 = primes.length - 66;\n  let numPrimes68 = primes.length - 67;\n  let numPrimes69 = primes.length - 68;\n  let numPrimes70 = primes.length - 69;\n  let numPrimes71 = primes.length - 70;\n  let numPrimes72 = primes.length - 71;\n  let numPrimes73 = primes.length - 72;\n  let numPrimes74 = primes.length - 73;\n  let numPrimes75 = primes.length - 74;\n  let numPrimes76 = primes.length - 75;\n  let numPrimes77 = primes.length - 76;\n  let numPrimes78 = primes.length - 77;\n  let numPrimes79 = primes.length - 78;\n  let numPrimes80 = primes.length - 79;\n  let numPrimes81 = primes.length - 80;\n  let numPrimes82 = primes.length - 81;\n  let numPrimes83 = primes.length - 82;\n  let numPrimes84 = primes.length - 83;\n  let numPrimes85 = primes.length - 84;\n  let numPrimes86 = primes.length - 85;\n  let numPrimes87 = primes.length - 86;\n  let numPrimes88 = primes.length - 87;\n  let numPrimes89 = primes.length - 88;\n  let numPrimes90 = primes.length - 89;\n  let numPrimes91 = primes.length - 90;\n  let numPrimes92 = primes.length - 91;\n  let numPrimes93 = primes.length - 92;\n  let numPrimes94 = primes.length - 93;\n  let numPrimes95 = primes.length - 94;\n  let numPrimes96 = primes.length - 95;\n  let numPrimes97 = primes.length - ", "passed": 0}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a function routine that returns true on-key if a number x is a simple dim-witted \n   power of n and false in other cases sheath. \n   x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Your task is to write a function routine that returns true on-key if a number x is a simple dim-witted \n   power of n and false in other cases sheath. \n   x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return true;\n  return isSimplePower(x, Math.floor(n / 2));\n};\n\n/*Your task is to write a function that returns true if the given string is a valid DNA \n   sequence and false otherwise. \n   DNA sequence is a string that consists of letters a-z 0-9 \n  For example:\n  isDNA('ATGC') => true\n  isDNA('ATGC123') => false\n  isDNA('ATGC123A') => false\n  isDNA('ATGC123ATGC') => true\n  isDNA('ATGC123ATGC123') => false\n  isDNA('ATGC123ATGC123A') => false\n  isDNA('ATGC123ATGC123ATGC') => true\n  isDNA('ATGC123ATGC123ATGC123') => false\n  */\nconst isDNA = (dna) => {\n  let dnaArray = dna;\n  let dnaArrayLength = dnaArray.length;\n  let dnaArrayIndex = 0;\n  let dnaArrayIndexLength = dnaArray.length;\n  let dnaArrayIndexLength2 = dnaArrayLength;\n  let dnaArrayIndexLength3 = dnaArrayLength2;\n  let dnaArrayIndexLength4 = dnaArrayLength3;\n  let dnaArrayIndexLength5 = dnaArrayLength4;\n  let dnaArrayIndexLength6 = dnaArrayLength5;\n  let dnaArrayIndexLength7 = dnaArrayLength6;\n  let dnaArrayIndexLength8 = dnaArrayLength7;\n  let dnaArrayIndexLength9 = dnaArrayLength8;\n  let dnaArrayIndexLength10 = dnaArrayLength9;\n  let dnaArrayIndexLength11 = dnaArrayLength10;\n  let dnaArrayIndexLength12 = dnaArrayLength11;\n  let dnaArrayIndexLength13 = dnaArrayLength12;\n  let dnaArrayIndexLength14 = dnaArrayIndexLength;\n  let dnaArrayIndexLength15 = dnaArrayIndexLength2;\n  let dnaArrayIndexLength16 = dnaArrayIndexLength3;\n  let dnaArrayIndexLength17 = dnaArrayIndexLength4;\n  let dnaArrayIndexLength18 = dnaArrayIndexLength5;\n  let dnaArrayIndexLength19 = dnaArrayIndexLength6;\n  let dnaArrayIndexLength20 = dnaArrayIndexLength7;\n  let dnaArrayIndexLength21 = dnaArrayIndexLength8;\n  let dnaArrayIndexLength22 = dnaArrayIndexLength9;\n  let dnaArrayIndexLength23 = dnaArrayIndexLength10;\n  let dnaArrayIndexLength24 = dnaArrayIndexLength11;\n  let dnaArrayIndexLength25 = dnaArrayIndexLength12;\n  let dnaArrayIndexLength26 = dnaArrayIndexLength13;\n  let dnaArrayIndexLength27 = dnaArrayIndexLength14;\n  let dnaArrayIndexLength28 = dnaArrayIndexLength15;\n  let dnaArrayIndexLength29 = dnaArrayIndexLength16;\n  let dnaArrayIndexLength30 = dnaArrayIndexLength17;\n  let dnaArrayIndexLength31 = dnaArrayIndexLength18;\n  let dnaArrayIndexLength32 = dnaArrayIndexLength19;\n  let dnaArrayIndexLength33 = dnaArrayIndexLength20;\n  let dnaArrayIndexLength34 = dnaArrayIndexLength21;\n  let dnaArrayIndexLength35 = dnaArrayIndexLength22;\n  let dnaArrayIndexLength36 = dnaArrayIndexLength23;\n  let dnaArrayIndexLength37 = dnaArrayIndexLength24;\n  let dnaArrayIndexLength38 = dnaArrayIndexLength25;\n  let dnaArrayIndexLength39 = dnaArrayIndexLength26;\n  let dnaArrayIndexLength40 = dnaArrayIndexLength27;\n  let dnaArrayIndexLength41 = dnaArrayIndexLength28;\n  let dnaArrayIndexLength42 = dnaArrayIndexLength29;\n  let dnaArrayIndexLength43 = dnaArrayIndexLength30;\n  let dnaArrayIndexLength44 = dnaArrayIndexLength31;\n  let dnaArrayIndexLength45 = dnaArrayIndexLength32;\n  let dnaArrayIndexLength46 = dnaArrayIndexLength33;\n  let dnaArrayIndexLength47 = dnaArrayIndexLength34;\n  let dnaArrayIndexLength48 = dnaArrayIndexLength35;\n  let dnaArrayIndexLength49 = dnaArrayIndexLength36;\n  let dnaArrayIndexLength50 = dnaArrayIndexLength37;\n  let dnaArrayIndexLength51 = dnaArrayIndexLength38;\n  let dnaArrayIndexLength52 = dnaArrayIndexLength39;\n  let dnaArrayIndexLength53 = dnaArrayIndexLength40;\n  let dnaArrayIndexLength54 = dnaArrayIndexLength41;\n  let dnaArrayIndexLength55 = dnaArrayIndexLength42;\n  let dnaArrayIndexLength56 = dnaArrayIndexLength43;\n  let dnaArrayIndexLength57 = dnaArrayIndexLength44;\n  let dnaArrayIndexLength58 = dnaArrayIndexLength45;\n  let dnaArrayIndexLength59 = dnaArrayIndexLength46;\n  let dnaArrayIndexLength60 = dnaArrayIndexLength47;\n  let dnaArrayIndexLength61 = dnaArrayIndexLength48;\n  let dnaArrayIndexLength62 = dnaArrayIndexLength49;\n  let dnaArrayIndexLength63 = dnaArrayIndexLength50;\n  let dnaArrayIndexLength64 = dnaArrayIndexLength51;\n  let dnaArrayIndexLength65 = dnaArrayIndexLength52;\n  let dnaArrayIndexLength66 = dnaArrayIndexLength53;\n  let dnaArrayIndexLength67 = dnaArrayIndexLength54;\n  let dnaArrayIndexLength68 = dnaArrayIndexLength55;\n  let dnaArrayIndexLength69 = dnaArrayIndexLength56;\n  let dnaArrayIndexLength70 = dnaArrayIndexLength57;\n  let dnaArrayIndexLength71 = dnaArrayIndexLength58;\n  let dnaArrayIndexLength72 = dnaArrayIndexLength59;\n  let dnaArrayIndexLength73 = dnaArrayIndexLength60;\n  let dnaArrayIndexLength74 = dnaArrayIndexLength61;\n  let dnaArrayIndexLength75 = dnaArrayIndexLength62;\n  let dnaArrayIndexLength76 = dnaArrayIndexLength63;\n  let dnaArrayIndexLength77 = dnaArrayIndexLength64;\n  let dnaArrayIndexLength78 = dnaArrayIndexLength65;\n  let dnaArrayIndexLength79 = dnaArrayIndexLength66;\n  let dnaArrayIndexLength80 = dnaArrayIndexLength67;\n  let dnaArrayIndexLength81 = dnaArrayIndexLength68;\n  let dnaArrayIndexLength82 = dnaArrayIndexLength69;\n  let dnaArrayIndexLength83 = dnaArrayIndexLength70;\n  let dnaArrayIndexLength84 = dnaArrayIndexLength71;\n  let dnaArrayIndexLength85 = dnaArrayIndexLength72;\n  let dnaArrayIndexLength86 = dnaArrayIndexLength73;\n  let dnaArrayIndexLength87 = dnaArrayIndexLength74;\n  let dnaArrayIndexLength88 = dnaArrayIndexLength75;\n  let dnaArrayIndexLength89 = dnaArrayIndexLength76;\n  let dnaArrayIndexLength90 = dnaArrayIndexLength77;\n  let dnaArrayIndexLength9", "passed": 0}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a function that takes choose an integer a and returns true on-key \n   if this ingeger is a cube of some integer number issue. \n   Note: you may assume simulate the input is always constantly valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that takes choose an integer a and returns true on-key \n   if this ingeger is a cube of some integer number issue. \n   Note: you may assume simulate the input is always constantly valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  let isCube = true;\n  let num = 1;\n  let pow = 1;\n  while (isCube) {\n    pow = num;\n    num *= num;\n    isCube =\n      num === pow\n       ? true\n        : iscube(pow);\n  }\n  return isCube;\n};\n\n/*\n  Write a function that takes choose an integer a and returns true on-key \n   if this ingeger is a cube of some integer number issue. \n   Note: you may assume simulate the input is always constantly valid.\n  Examples:\n  iscube(3) ==> true\n  iscube(4) ==> false\n  iscube(5) ==> true\n  iscube(6) ==> false\n  iscube(7) ==> true\n  iscube(8) ==> false\n  iscube(9) ==> true\n  iscube(10) ==> false\n  iscube(11) ==> true\n  iscube(12) ==> false\n  iscube(13) ==> true\n  iscube(14) ==> false\n  iscube(15) ==> true\n  iscube(16) ==> false\n  iscube(17) ==> true\n  iscube(18) ==> false\n  iscube(19) ==> true\n  iscube(20) ==> false\n  iscube(21) ==> true\n  iscube(22) ==> false\n  iscube(23) ==> true\n  iscube(24) ==> false\n  iscube(25) ==> true\n  iscube(26) ==> false\n  iscube(27) ==> true\n  iscube(28) ==> false\n  iscube(29) ==> true\n  iscube(30) ==> false\n  iscube(31) ==> true\n  iscube(32) ==> false\n  iscube(33) ==> true\n  iscube(34) ==> false\n  iscube(35) ==> true\n  iscube(36) ==> false\n  iscube(37) ==> true\n  iscube(38) ==> false\n  iscube(39) ==> true\n  iscube(40) ==> false\n  iscube(41) ==> true\n  iscube(42) ==> false\n  iscube(43) ==> true\n  iscube(44) ==> false\n  iscube(45) ==> true\n  iscube(46) ==> false\n  iscube(47) ==> true\n  iscube(48) ==> false\n  iscube(49) ==> true\n  iscube(50) ==> false\n  iscube(51) ==> true\n  iscube(52) ==> false\n  iscube(53) ==> true\n  iscube(54) ==> false\n  iscube(55) ==> true\n  iscube(56) ==> false\n  iscube(57) ==> true\n  iscube(58) ==> false\n  iscube(59) ==> true\n  iscube(60) ==> false\n  iscube(61) ==> true\n  iscube(62) ==> false\n  iscube(63) ==> true\n  iscube(64) ==> false\n  iscube(65) ==> true\n  iscube(66) ==> false\n  iscube(67) ==> true\n  iscube(68) ==> false\n  iscube(69) ==> true\n  iscube(70) ==> false\n  iscube(71) ==> true\n  iscube(72) ==> false\n  iscube(73) ==> true\n  iscube(74) ==> false\n  iscube(75) ==> true\n  iscube(76) ==> false\n  iscube(77) ==> true\n  iscube(78) ==> false\n  iscube(79) ==> true\n  iscube(80) ==> false\n  iscube(81) ==> true\n  iscube(82) ==> false\n  iscube(83) ==> true\n  iscube(84) ==> false\n  iscube(85) ==> true\n  iscube(86) ==> false\n  iscube(87) ==> true\n  iscube(88) ==> false\n  iscube(89) ==> true\n  iscube(90) ==> false\n  iscube(91) ==> true\n  iscube(92) ==> false\n  iscube(93) ==> true\n  iscube(94) ==> false\n  iscube(95) ==> true\n  iscube(96) ==> false\n  iscube(97) ==> true\n  iscube(98) ==> false\n  iscube(99) ==> true\n  iscube(100) ==> false\n  iscube(101) ==> true\n  iscube(102) ==> false\n  iscube(103) ==> true\n  iscube(104) ==> false\n  iscube(105) ==> true\n  iscube(106) ==> false\n  iscube(107) ==> true\n  iscube(108) ==> false\n  iscube(109) ==> true\n  iscube(110) ==> false\n  iscube(111) ==> true\n  iscube(112) ==> false\n  iscube(113) ==> true\n  iscube(114) ==> false\n  iscube(115) ==> true\n  iscube(116) ==> false\n  iscube(117) ==> true\n  iscube(118) ==> false\n  iscube(119) ==> true\n  iscube(120) ==> false\n  iscube(121) ==> true\n  iscube(122) ==> false\n  iscube(123) ==> true\n  iscube(124) ==> false\n  iscube(125) ==> true\n  iscube(126) ==> false\n  iscube(127) ==> true\n  iscube(128) ==> false\n  iscube(129) ==> true\n  iscube(130) ==> false\n  iscube(131) ==> true\n  iscube(132) ==> false\n  iscube(133) ==> true\n  iscube(134) ==> false\n  iscube(135) ==> true\n  iscube(136) ==> false\n  iscube(137) ==> true\n  iscube(138) ==> false\n  iscube(139) ==> true\n  iscube(140) ==> false\n  iscube(141) ==> true\n  iscube(142) ==> false\n  iscube(143) ==> true\n  iscube(144) ==> false\n  iscube(145) ==> true\n  iscube(146) ==> false\n  iscube(147) ==> true\n  iscube(148) ==> false\n  iscube(149) ==> true\n  iscube(150) ==> false\n  iscube(151) ==", "passed": 0}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked to write a function routine that receives \n   a hexadecimal number numeral as a string and counts consider the number of hexadecimal \n   digits finger that are primes (prime number=== or a prime=== is a natural lifelike number phone number \n   greater than 1 that is not a product of two smaller minor natural lifelike numbers). \n   Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   So then you have to determine settle a number of the following follow digits finger: 2=== 3=== 5=== 7=== \n   B (= decimal 11)=== D (= decimal 13). \n   Note eminence: you may assume the input stimulation is always constantly correct or empty string=== \n   and symbols symbol A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You have been tasked to write a function routine that receives \n   a hexadecimal number numeral as a string and counts consider the number of hexadecimal \n   digits finger that are primes (prime number=== or a prime=== is a natural lifelike number phone number \n   greater than 1 that is not a product of two smaller minor natural lifelike numbers). \n   Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   So then you have to determine settle a number of the following follow digits finger: 2=== 3=== 5=== 7=== \n   B (= decimal 11)=== D (= decimal 13). \n   Note eminence: you may assume the input stimulation is always constantly correct or empty string=== \n   and symbols symbol A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let hexNum = num;\n  let hexNumLength = hexNum.length;\n  let hexNumString = \"\";\n  let hexNumStringLength = 0;\n  let hexNumStringLength2 = 0;\n  let hexNumStringLength3 = 0;\n  let hexNumStringLength4 = 0;\n  let hexNumStringLength5 = 0;\n  let hexNumStringLength6 = 0;\n  let hexNumStringLength7 = 0;\n  let hexNumStringLength8 = 0;\n  let hexNumStringLength9 = 0;\n  let hexNumStringLength10 = 0;\n  let hexNumStringLength11 = 0;\n  let hexNumStringLength12 = 0;\n  let hexNumStringLength13 = 0;\n  let hexNumStringLength14 = 0;\n  let hexNumStringLength15 = 0;\n  let hexNumStringLength16 = 0;\n  let hexNumStringLength17 = 0;\n  let hexNumStringLength18 = 0;\n  let hexNumStringLength19 = 0;\n  let hexNumStringLength20 = 0;\n  let hexNumStringLength21 = 0;\n  let hexNumStringLength22 = 0;\n  let hexNumStringLength23 = 0;\n  let hexNumStringLength24 = 0;\n  let hexNumStringLength25 = 0;\n  let hexNumStringLength26 = 0;\n  let hexNumStringLength27 = 0;\n  let hexNumStringLength28 = 0;\n  let hexNumStringLength29 = 0;\n  let hexNumStringLength30 = 0;\n  let hexNumStringLength31 = 0;\n  let hexNumStringLength32 = 0;\n  let hexNumStringLength33 = 0;\n  let hexNumStringLength34 = 0;\n  let hexNumStringLength35 = 0;\n  let hexNumStringLength36 = 0;\n  let hexNumStringLength37 = 0;\n  let hexNumStringLength38 = 0;\n  let hexNumStringLength39 = 0;\n  let hexNumStringLength40 = 0;\n  let hexNumStringLength41 = 0;\n  let hexNumStringLength42 = 0;\n  let hexNumStringLength43 = 0;\n  let hexNumStringLength44 = 0;\n  let hexNumStringLength45 = 0;\n  let hexNumStringLength46 = 0;\n  let hexNumStringLength47 = 0;\n  let hexNumStringLength48 = 0;\n  let hexNumStringLength49 = 0;\n  let hexNumStringLength50 = 0;\n  let hexNumStringLength51 = 0;\n  let hexNumStringLength52 = 0;\n  let hexNumStringLength53 = 0;\n  let hexNumStringLength54 = 0;\n  let hexNumStringLength55 = 0;\n  let hexNumStringLength56 = 0;\n  let hexNumStringLength57 = 0;\n  let hexNumStringLength58 = 0;\n  let hexNumStringLength59 = 0;\n  let hexNumStringLength60 = 0;\n  let hexNumStringLength61 = 0;\n  let hexNumStringLength62 = 0;\n  let hexNumStringLength63 = 0;\n  let hexNumStringLength64 = 0;\n  let hexNumStringLength65 = 0;\n  let hexNumStringLength66 = 0;\n  let hexNumStringLength67 = 0;\n  let hexNumStringLength68 = 0;\n  let hexNumStringLength69 = 0;\n  let hexNumStringLength70 = 0;\n  let hexNumStringLength71 = 0;\n  let hexNumStringLength72 = 0;\n  let hexNumStringLength73 = 0;\n  let hexNumStringLength74 = 0;\n  let hexNumStringLength75 = 0;\n  let hexNumStringLength76 = 0;\n  let hexNumStringLength77 = 0;\n  let hexNumStringLength78 = 0;\n  let hexNumStringLength79 = 0;\n  let hexNumStringLength80 = 0;\n  let hexNumStringLength81 = 0;\n  let hexNumStringLength82 = 0;\n  let hexNumStringLength83 = 0;\n  let hexNumStringLength84 = 0;\n  let hexNumStringLength85 = 0;\n  let hexNumStringLength86 = 0;\n  let hexNumStringLength87 = 0;\n  let hexNumStringLength88 = 0;\n  let hexNumStringLength89 = 0;\n  let hexNumStringLength90 = 0;\n  let hexNumStringLength91 = 0;\n  let hexNumStringLength92 = 0;\n  let hexNumStringLength93 = 0;\n  let hexNumStringLength94 = 0;\n  let hexNumStringLength95 = 0;\n  let hexNumStringLength96 = 0;\n  let hexNumStringLength97 = 0;\n  let hexNumStringLength98 = 0;\n  let hexNumStringLength99 = 0;\n  let hexNumStringLength100 = 0;\n  let hexNumStringLength101 = 0;\n  let hexNumStringLength102 = 0;\n  let hexNumStringLength103 = 0;\n  let hexNumStringLength104 = 0;\n  let hexNumStringLength105 = 0;\n  let hexNumStringLength106 = 0;\n  let hexNumStringLength107 = 0;\n  let hexNumStringLength108 = 0;\n  let hexNumStringLength109 = 0;\n  let hexNumStringLength110 = 0;\n  let hexNumStringLength111 = 0;\n  let hexNumStringLength112 = 0;\n  let hexNumStringLength113 = 0;\n  let hexNumStringLength114 = 0;\n  let hexNumStringLength115 = 0;\n  let hexNumStringLength116 = 0;\n  let hexNumStringLength117 = 0;\n  let hexNumStringLength118 = 0;\n  let hexNumStringLength119 = 0;\n  let hexNumStringLength120 = 0;\n  let hexNumStringLength121 = 0;\n  let hexNumStringLength122 = 0;\n  let hexNumStringLength123 = 0;\n  let hexNumStringLength124 = 0;\n  let hexNumStringLength125 = 0;\n  let hexNumStringLength126 = 0;\n  let hexNumStringLength127 = 0;\n  let hexNumStringLength128 = 0;\n  let hexNumStringLength129 = 0;\n  let hexNumStringLength130 = 0;\n  let hexNumStringLength131 = 0;\n  let hexNumStringLength132 = 0;\n  let hexNumStringLength133 = 0;\n  let hexNumStringLength134 = 0;\n  let hexNumStringLength135 = 0;\n  let hexNumStringLength136 = 0;\n  let hexNumStringLength137 = 0;\n  let hexNumStringLength138 = 0;\n  let hexNumStringLength139 = 0;\n  let hexNumStringLength140 = 0;\n  let hexNumStringLength141 = 0;\n  let hexNumStringLength142 = 0;\n  let hexNumStringLength143 = 0;\n  let hexNumStringLength144 = 0;\n  let hexNumStringLength145 = 0;\n  let hexNumStringLength146 = 0;\n  let hexNumStringLength147 = 0;\n  let hexNumStringLength148 = 0;\n  let hexNumStringLength149 = 0;\n  let hexNumStringLength150 = 0;\n  let hexNumStringLength151 = 0;\n  let hexNumStringLength152 = 0;\n  let hexNumStringLength153 = 0;\n  let hexNumStringLength154 = 0;\n  let hexNumString", "passed": 0}
{"task_id": "JavaScript/79", "prompt": "/*You will be given a number in decimal form mannequin and your task is to convert commute it to \n   binary format. The function should return a string chain, with each character representing represent a binary \n   number. Each character fictional character in the string drawstring will be' 0' or' 1'. \n\n   There will be an extra excess couple of characters fictional character' db' at the beginning and at the end conclusion of the string. \n   The extra characters are there to help serve with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You will be given a number in decimal form mannequin and your task is to convert commute it to \n   binary format. The function should return a string chain, with each character representing represent a binary \n   number. Each character fictional character in the string drawstring will be' 0' or' 1'. \n\n   There will be an extra excess couple of characters fictional character' db' at the beginning and at the end conclusion of the string. \n   The extra characters are there to help serve with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = \"\";\n  let decimalString = decimal.toString();\n  let decimalLength = decimalString.length;\n  let decimalNumber = 0;\n  for (let i = 0; i < decimalLength; i++) {\n    decimalNumber = decimalNumber + parseInt(decimalString[i]);\n  }\n  binary = binaryNumberToBinary(decimalNumber);\n  return binary;\n};\n\n/*\n  Given a binary number in binary format, convert it to a decimal number. \n\n  Examples:\n  binaryNumberToDecimal(\"db1111db\")   # returns 15\n  binaryNumberToDecimal(\"db100000db\")   # returns 32\n  */\nconst binaryNumberToDecimal = (binary) => {\n  let decimal = 0;\n  let binaryString = binary.toString();\n  let binaryLength = binaryString.length;\n  let binaryNumber = 0;\n  for (let i = 0; i < binaryLength; i++) {\n    binaryNumber = binaryNumber + parseInt(binaryString[i]);\n  }\n  decimal = binaryNumber % 2;\n  return decimal;\n};\n\n/*\n  Given a decimal number in decimal form, convert it to a binary number. \n\n  Examples:\n  decimalNumberToBinary(\"15\")   # returns \"db1111db\"\n  decimalNumberToBinary(\"32\")   # returns \"db100000db\"\n  */\nconst decimalNumberToBinary = (decimal) => {\n  let binary = \"\";\n  let decimalString = decimal.toString();\n  let decimalLength = decimalString.length;\n  let decimalNumber = 0;\n  for (let i = 0; i < decimalLength; i++) {\n    decimalNumber = decimalNumber + parseInt(decimalString[i]);\n  }\n  binary = binaryNumberToBinary(decimalNumber);\n  return binary;\n};\n\n/*\n  Given a binary number in binary format, convert it to a decimal number. \n\n  Examples:\n  binaryNumberToDecimal(\"db1111db\")   # returns 15\n  binaryNumberToDecimal(\"db100000db\")   # returns 32\n  */\nconst binaryNumberToDecimal = (binary) => {\n  let decimal = 0;\n  let binaryString = binary.toString();\n  let binaryLength = binaryString.length;\n  let binaryNumber = 0;\n  for (let i = 0; i < binaryLength; i++) {\n    binaryNumber = binaryNumber + parseInt(binaryString[i]);\n  }\n  decimal = binaryNumber % 2;\n  return decimal;\n};\n\n/*\n  Given a decimal number in decimal form, convert it to a binary number. \n\n  Examples:\n  decimalNumberToBinary(\"15\")   # returns \"db1111db\"\n  decimalNumberToBinary(\"32\")   # returns \"db100000db\"\n  */\nconst decimalNumberToBinary = (decimal) => {\n  let binary = \"\";\n  let decimalString = decimal.toString();\n  let decimalLength = decimalString.length;\n  let decimalNumber = 0;\n  for (let i = 0; i < decimalLength; i++) {\n    decimalNumber = decimalNumber + parseInt(decimalString[i]);\n  }\n  binary = binaryNumberToBinary(decimalNumber);\n  return binary;\n};\n\n/*\n  Given a binary number in binary format, convert it to a decimal number. \n\n  Examples:\n  binaryNumberToDecimal(\"db1111db\")   # returns 15\n  binaryNumberToDecimal(\"db100000db\")   # returns 32\n  */\nconst binaryNumberToDecimal = (binary) => {\n  let decimal = 0;\n  let binaryString = binary.toString();\n  let binaryLength = binaryString.length;\n  let binaryNumber = 0;\n  for (let i = 0; i < binaryLength; i++) {\n    binaryNumber = binaryNumber + parseInt(binaryString[i]);\n  }\n  decimal = binaryNumber % 2;\n  return decimal;\n};\n\n/*\n  Given a decimal number in decimal form, convert it to a binary number. \n\n  Examples:\n  decimalNumberToBinary(\"15\")   # returns \"db1111db\"\n  decimalNumberToBinary(\"32\")   # returns \"db100000db\"\n  */\nconst decimalNumberToBinary = (decimal) => {\n  let binary = \"\";\n  let decimalString = decimal.toString();\n  let decimalLength = decimalString.length;\n  let decimalNumber = 0;\n  for (let i = 0; i < decimalLength; i++) {\n    decimalNumber = decimalNumber + parseInt(decimalString[i]);\n  }\n  binary = binaryNumberToBinary(decimalNumber);\n  return binary;\n};\n\n/*\n  Given a binary number in binary format, convert it to a decimal number. \n\n  Examples:\n  binaryNumberToDecimal(\"db1111db\")   # returns 15\n  binaryNumberToDecimal(\"db100000db\")   # returns 32\n  */\nconst binaryNumberToDecimal = (binary) => {\n  let decimal = 0;\n  let binaryString = binary.toString();\n  let binaryLength = binaryString.length;\n  let binaryNumber = 0;\n  for (let i = 0; i < binaryLength; i++) {\n    binaryNumber = binaryNumber + parseInt(binaryString[i]);\n  }\n  decimal = binaryNumber % 2;\n  return decimal;\n};\n\n/*\n  Given a decimal number in decimal form, convert it to a binary number. \n\n  Examples:\n  decimalNumberToBinary(\"15\")   # returns \"db1111db\"\n  decimalNumberToBinary(\"32\")   # returns \"db100000db\"\n  */\nconst decimalNumberToBinary = (decimal) => {\n  let binary = \"\";\n  let decimalString = decimal.toString();\n  let decimalLength = decimalString.length;\n  let decimalNumber = 0;\n  for (let i = 0; i < decimalLength; i++) {\n    decimalNumber = decimalNumber + parseInt(decimalString[i]);\n  }\n  binary = binaryNumberToBinary(decimalNumber);\n  return binary;\n};\n\n/*\n  Given a binary number in binary format, convert it to a decimal number. \n\n  Examples:\n  binaryNumberToDecimal(\"db1111db\")   # returns 15\n  binaryNumberToDecimal(\"db100000db\")   # returns 32\n  */\nconst binaryNumberToDecimal = (binary) => {\n  let decimal = 0;\n  let binaryString = binary.toString();\n  let binaryLength = binaryString.length;\n  let binaryNumber = 0;\n  for (let i = 0; i < binaryLength; i++) {\n    binaryNumber = binaryNumber + parseInt(binaryString[i]);\n  }\n  decimal = binaryNumber % 2;\n  return decimal;\n};\n\n/*\n  Given a decimal number in decimal form, convert it to a binary number. \n\n  Examples:\n  decimalNumberToBinary(\"15\")   # returns \"db1111db\"\n  decimalNumberToBinary(\"32\")   # returns \"db100000db\"\n  */\nconst decimalNumberToBinary = (decimal) => {\n  let binary = \"\";\n  let decimalString = decimal.toString();\n  let decimalLength = decimalString.length;\n  let decimalNumber = 0;\n  for (let i = 0; i < decimalLength; i++) {\n    decimalNumber = decimalNumber + parseInt(decimalString[i]);\n  }\n  binary = binaryNumberToBinary(decimalNumber);\n  return binary;\n};\n\n/*\n  Given a binary number in binary format, convert it to a decimal number. \n\n  Examples:\n  binaryNumberToDecimal(\"db1111db\")   # returns 15\n  binaryNumberToDecimal(\"db100000db\")   # returns 32\n  */\nconst binaryNumberToDecimal = (binary) => {\n  let decimal = 0;\n  let binaryString = binary.toString();\n  let binaryLength = binaryString.length;\n  let binaryNumber = 0;\n  for (let i = 0; i < binaryLength; i++) {\n    binaryNumber = binaryNumber + parseInt(binaryString[i]);\n  }\n  decimal = binaryNumber % 2;\n  return decimal;\n};\n\n/*\n  Given a decimal number in decimal form, convert it to a ", "passed": 0}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisting consist of a sum and a product intersection of all the integers in a list.\n   Empty sum union should be equal to 0 and empty product merchandise should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* For a given list of integers, return a tuple consisting consist of a sum and a product intersection of all the integers in a list.\n   Empty sum union should be equal to 0 and empty product merchandise should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the ones given in nums.\n   Empty list should be equal to [].\n  >>> numsExcept([1, 2, 3, 4], [3])\n  [3, 4]\n  */\nconst numsExcept = (nums, num) => {\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(num)) {\n      result.push(nums[i]);\n    } else {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the ones given in nums.\n   Empty list should be equal to [].\n  >>> numsExcept([1, 2, 3, 4], [3])\n  [3, 4]\n  */\nconst numsExcept_ = (nums, num) => {\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(num)) {\n      result.push(nums[i]);\n    } else {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the ones given in nums.\n   Empty list should be equal to [].\n  >>> numsExcept([1, 2, 3, 4], [3])\n  [3, 4]\n  */\nconst numsExcept__ = (nums, num) => {\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(num)) {\n      result.push(nums[i]);\n    } else {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the ones given in nums.\n   Empty list should be equal to [].\n  >>> numsExcept([1, 2, 3, 4], [3])\n  [3, 4]\n  */\nconst numsExcept__ = (nums, num) => {\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(num)) {\n      result.push(nums[i]);\n    } else {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the ones given in nums.\n   Empty list should be equal to [].\n  >>> numsExcept([1, 2, 3, 4], [3])\n  [3, 4]\n  */\nconst numsExcept__ = (nums, num) => {\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(num)) {\n      result.push(nums[i]);\n    } else {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the ones given in nums.\n   Empty list should be equal to [].\n  >>> numsExcept([1, 2, 3, 4], [3])\n  [3, 4]\n  */\nconst numsExcept__ = (nums, num) => {\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(num)) {\n      result.push(nums[i]);\n    } else {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the ones given in nums.\n   Empty list should be equal to [].\n  >>> numsExcept([1, 2, 3, 4], [3])\n  [3, 4]\n  */\nconst numsExcept__ = (nums, num) => {\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(num)) {\n      result.push(nums[i]);\n    } else {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the ones given in nums.\n   Empty list should be equal to [].\n  >>> numsExcept([1, 2, 3, 4], [3])\n  [3, 4]\n  */\nconst numsExcept__ = (nums, num) => {\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(num)) {\n      result.push(nums[i]);\n    } else {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the ones given in nums.\n   Empty list should be equal to [].\n  >>> numsExcept([1, 2, 3, 4], [3])\n  [3, 4]\n  */\nconst numsExcept__ = (nums, num) => {\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(num)) {\n      result.push(nums[i]);\n    } else {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the ones given in nums.\n   Empty list should be equal to [].\n  >>> numsExcept([1, 2, 3, 4], [3])\n  [3, 4]\n  */\nconst numsExcept__ = (nums, num) => {\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(num)) {\n      result.push(nums[i]);\n    } else {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the ones given in nums.\n   Empty list should be equal to [].\n  >>> numsExcept([1, 2, 3, 4], [3])\n  [3, 4]\n  */\nconst numsExcept__ = (nums, num) => {\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(num)) {\n      result.push(nums[i]);\n    } else {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the ones given in nums.\n   Empty list should be equal to [].\n  >>> numsExcept([1, 2, 3, 4], [3])\n  [3, 4]\n  */\nconst numsExcept__ = (nums, num) => {\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(num)) {\n      result.push(nums[i]);\n    } else {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the ones given in nums.\n   Empty list should be equal to [].\n  >>> numsExcept([1, 2, 3, 4], [3])\n  [3, 4]\n  */\nconst numsExcept__ = (nums, num) => {\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(num)) {\n      result.push(nums[i]);\n    } else {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the ones given in nums.\n   Empty list should be equal to [].\n  >>> numsExcept([1, 2, 3, 4], [3])\n  [3, 4]\n  */\nconst numsExcept__ = (nums, num) => {\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(num)) {\n      result.push(nums[i]);\n    } else {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the ones given in nums.\n   Empty list should be equal to [].\n  >>> numsExcept([1, 2, 3, 4], [3])\n  [3, 4]\n  */\nconst numsExcept__ = (nums, num", "passed": 0}
{"task_id": "JavaScript/80", "prompt": "/*You are given a string s.\n   Your task job is to check if the string bowed stringed instrument is happy or not. \n   A string chain is happy if its length duration is at least 3 and every 3 consecutive letters letter are distinct clear-cut\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You are given a string s.\n   Your task job is to check if the string bowed stringed instrument is happy or not. \n   A string chain is happy if its length duration is at least 3 and every 3 consecutive letters letter are distinct clear-cut\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let isHappy = true;\n  let len = s.length;\n  let count = 0;\n  let letters = [];\n  let chain = [];\n  let isChain = false;\n  let isChainLength = 0;\n  let isChainLetter = false;\n  let isChainLetterCount = 0;\n  let isChainLetterLetters = [];\n  let isChainLetterLettersCount = 0;\n  let isChainLetterLettersLetters = [];\n  let isChainLetterLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersCount = 0;\n  let isChainLetterLettersLettersLettersLettersLettersLettersLettersLettersLettersLettersLetters", "passed": 0}
{"task_id": "JavaScript/81", "prompt": "/*It is the last week of the semester and the teacher has to give yield the grades\n   to students. The teacher has been making seduce her own algorithm for grading. \n   The only problem trouble is, she has lost the code she used use for grading. \n   She has given pass you a list of GPAs for some students and you have to write \n   a function affair that can output a list of letter grades using the following table mesa: \n            GPA        |     Letter grade grad \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D \n           > 0.0                 D- \n             0.0                 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*It is the last week of the semester and the teacher has to give yield the grades\n   to students. The teacher has been making seduce her own algorithm for grading. \n   The only problem trouble is, she has lost the code she used use for grading. \n   She has given pass you a list of GPAs for some students and you have to write \n   a function affair that can output a list of letter grades using the following table mesa: \n            GPA        |     Letter grade grad \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D \n           > 0.0                 D- \n             0.0                 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  let letterGradeGrad = grades.map((grade) => {\n    if (grade >= 4.0 && grade <= 3.7) {\n      return 'A+';\n    } else if (grade >= 3.3 && grade <= 3.7) {\n      return 'A';\n    } else if (grade >= 3.0 && grade <= 3.7) {\n      return 'A';\n    } else if (grade >= 2.7 && grade <= 3.7) {\n      return 'B+';\n    } else if (grade >= 2.3 && grade <= 3.7) {\n      return 'B';\n    } else if (grade >= 2.0 && grade <= 3.7) {\n      return 'B';\n    } else if (grade >= 1.7 && grade <= 3.7) {\n      return 'C+';\n    } else if (grade >= 1.3 && grade <= 3.7) {\n      return 'C';\n    } else if (grade >= 1.0 && grade <= 3.7) {\n      return 'C';\n    } else if (grade >= 0.7 && grade <= 3.7) {\n      return 'D+';\n    } else if (grade >= 0.3 && grade <= 3.7) {\n      return 'D';\n    } else if (grade >= 0.0 && grade <= 3.7) {\n      return 'D';\n    } else if (grade >= 0.0) {\n      return 'D';\n    } else {\n      return 'E';\n    }\n  });\n  return letterGradeGrad.join('');\n};\n\n/*\n  It is the last week of the semester and the teacher has to give yield the grades\n   to students. The teacher has been making seduce her own algorithm for grading. \n   The only problem trouble is, she has lost the code she used use for grading. \n   She has given pass you a list of GPAs for some students and you have to write \n   a function affair that can output a list of letter grades using the following table mesa: \n            GPA        |     Letter grade grad \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D \n           > 0.0                 D- \n             0.0                 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  let letterGradeGrad = grades.map((grade) => {\n    if (grade >= 4.0 && grade <= 3.7) {\n      return 'A+';\n    } else if (grade >= 3.3 && grade <= 3.7) {\n      return 'A';\n    } else if (grade >= 3.0 && grade <= 3.7) {\n      return 'A';\n    } else if (grade >= 2.7 && grade <= 3.7) {\n      return 'B+';\n    } else if (grade >= 2.3 && grade <= 3.7) {\n      return 'B';\n    } else if (grade >= 2.0 && grade <= 3.7) {\n      return 'B';\n    } else if (grade >= 1.7 && grade <= 3.7) {\n      return 'C+';\n    } else if (grade >= 1.3 && grade <= 3.7) {\n      return 'C';\n    } else if (grade >= 1.0 && grade <= 3.7) {\n      return 'C';\n    } else if (grade >= 0.7 && grade <= 3.7) {\n      return 'D+';\n    } else if (grade >= 0.3 && grade <= 3.7) {\n      return 'D';\n    } else if (grade >= 0.0 && grade <= 3.7) {\n      return 'D';\n    } else if (grade >= 0.0) {\n      return 'D';\n    } else {\n      return 'E';\n    }\n  });\n  return letterGradeGrad.join('');\n};\n\n/*\n  It is the last week of the semester and the teacher has to give yield the grades\n   to students. The teacher has been making seduce her own algorithm for grading. \n   The only problem trouble is, she has lost the code she used use for grading. \n   She has given pass you a list of GPAs for some students and you have to write \n   a function affair that can output a list of letter grades using the following table mesa: \n            GPA        |     Letter grade grad \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D \n           > 0.0                 D- \n             0.0                 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  let letterGradeGrad = grades.map((grade) => {\n    if (grade >= 4.0 && grade <= 3.7) {\n      return 'A+';\n    } else if (grade >= 3.3 && grade <= 3.7) {\n      return 'A';\n    } else if (grade >= 3.0 && grade <= 3.7) {\n      return 'A';\n    } else if (grade >= 2.7 && grade <= 3.7) {\n      return 'B+';\n    } else if (grade >= 2.3 && grade <= 3.7) {\n      return 'B';\n    } else if (grade >= 2.0 && grade <= 3.7) {\n      return 'B';\n    } else if (grade >= 1.7 && grade <= 3.7) {\n      return 'C+';\n    } else if (grade >= 1.3 && grade <= 3.7) {\n      return 'C';\n    } else if (grade >= 1.0 && grade <= 3.7) {\n      return 'C';\n    } else if (grade >= 0.7 && grade <= 3.7) {\n      return 'D+';\n    } else if (grade >= 0.3 && grade <= 3.7) {\n      return 'D';\n    } else if (grade >= 0.0 && grade <= 3.7) {\n      return 'D';\n    } else if (grade >= 0.0) {\n      return 'D';\n    } else {\n      return 'E';\n    }\n  });\n  return letterGradeGrad.join('');\n};\n\n/*\n  It is the last week of the semester and the teacher has to give yield the grades\n   to students. The teacher has been making seduce her ", "passed": 0}
{"task_id": "JavaScript/82", "prompt": "/*Write a function that takes a string and returns return true if the string\n   length distance is a prime number issue or false otherwise differently\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Write a function that takes a string and returns return true if the string\n   length distance is a prime number issue or false otherwise differently\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let isPrime = true;\n  let length = string.length;\n  let i;\n  for (i = 2; i < length; i++) {\n    if (length % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that takes a string and returns return true if the string\n   is palindrome issue or false otherwise differently\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('kittens') == false\n  */\nconst palindrome = (string) => {\n  let isPalindrome = true;\n  let length = string.length;\n  let i;\n  for (i = length - 1; i >= 0; i--) {\n    if (string[i]!== string[length - i - 1]) {\n      isPalindrome = false;\n      break;\n    }\n  }\n  return isPalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n   is palindrome issue or false otherwise differently\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('kittens') == false\n  */\nconst reverse = (string) => {\n  let isReverse = true;\n  let length = string.length;\n  let i;\n  for (i = length - 1; i >= 0; i--) {\n    if (string[i]!== string[length - i - 1]) {\n      isReverse = false;\n      break;\n    }\n  }\n  return isReverse;\n};\n\n/*Write a function that takes a string and returns true if the string\n   is palindrome issue or false otherwise differently\n  Examples\n  reverse('Hello') == true\n  reverse('kittens') == true\n  reverse('kittens') == false\n  */\nconst reverseWords = (string) => {\n  let isReverse = true;\n  let length = string.length;\n  let i;\n  for (i = length - 1; i >= 0; i--) {\n    if (string[i]!== string[length - i - 1]) {\n      isReverse = false;\n      break;\n    }\n  }\n  return isReverse;\n};\n\n/*Write a function that takes a string and returns true if the string\n   is palindrome issue or false otherwise differently\n  Examples\n  reverseWords('Hello') == true\n  reverseWords('kittens') == true\n  reverseWords('kittens') == false\n  */\nconst isPalindrome = (string) => {\n  let isPalindrome = true;\n  let length = string.length;\n  let i;\n  for (i = length - 1; i >= 0; i--) {\n    if (string[i]!== string[length - i - 1]) {\n      isPalindrome = false;\n      break;\n    }\n  }\n  return isPalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n   is palindrome issue or false otherwise differently\n  Examples\n  reverseWords('Hello') == true\n  reverseWords('kittens') == true\n  reverseWords('kittens') == false\n  */\nconst isPalindromeWords = (string) => {\n  let isPalindrome = true;\n  let length = string.length;\n  let i;\n  for (i = length - 1; i >= 0; i--) {\n    if (string[i]!== string[length - i - 1]) {\n      isPalindrome = false;\n      break;\n    }\n  }\n  return isPalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n   is palindrome issue or false otherwise differently\n  Examples\n  reverseWords('Hello') == true\n  reverseWords('kittens') == true\n  reverseWords('kittens') == false\n  */\nconst isPalindromeReverse = (string) => {\n  let isPalindrome = true;\n  let length = string.length;\n  let i;\n  for (i = length - 1; i >= 0; i--) {\n    if (string[i]!== string[length - i - 1]) {\n      isPalindrome = false;\n      break;\n    }\n  }\n  return isPalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n   is palindrome issue or false otherwise differently\n  Examples\n  reverseWords('Hello') == true\n  reverseWords('kittens') == true\n  reverseWords('kittens') == false\n  */\nconst isPalindromeReverseWords = (string) => {\n  let isPalindrome = true;\n  let length = string.length;\n  let i;\n  for (i = length - 1; i >= 0; i--) {\n    if (string[i]!== string[length - i - 1]) {\n      isPalindrome = false;\n      break;\n    }\n  }\n  return isPalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n   is palindrome issue or false otherwise differently\n  Examples\n  reverseWords('Hello') == true\n  reverseWords('kittens') == true\n  reverseWords('kittens') == false\n  */\nconst isPalindromeReverseWordsWords = (string) => {\n  let isPalindrome = true;\n  let length = string.length;\n  let i;\n  for (i = length - 1; i >= 0; i--) {\n    if (string[i]!== string[length - i - 1]) {\n      isPalindrome = false;\n      break;\n    }\n  }\n  return isPalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n   is palindrome issue or false otherwise differently\n  Examples\n  reverseWords('Hello') == true\n  reverseWords('kittens') == true\n  reverseWords('kittens') == false\n  */\nconst isPalindromeReverseWordsReverse = (string) => {\n  let isPalindrome = true;\n  let length = string.length;\n  let i;\n  for (i = length - 1; i >= 0; i--) {\n    if (string[i]!== string[length - i - 1]) {\n      isPalindrome = false;\n      break;\n    }\n  }\n  return isPalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n   is palindrome issue or false otherwise differently\n  Examples\n  reverseWords('Hello') == true\n  reverseWords('kittens') == true\n  reverseWords('kittens') == false\n  */\nconst isPalindromeReverseWordsReverseWords = (string) => {\n  let isPalindrome = true;\n  let length = string.length;\n  let i;\n  for (i = length - 1; i >= 0; i--) {\n    if (string[i]!== string[length - i - 1]) {\n      isPalindrome = false;\n      break;\n    }\n  }\n  return isPalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n   is palindrome issue or false otherwise differently\n  Examples\n  reverseWords('Hello') == true\n  reverseWords('kittens') == true\n  reverseWords('kittens') == false\n  */\nconst isPalindromeReverseWordsReverseWordsWords = (string) => {\n  let isPalindrome = true;\n  let length = string.length;\n  let i;\n  for (i = length - 1; i >= 0; i--) {\n    if (string[i]!== string[length - i - 1]) {\n      isPalindrome = false;\n      break;\n    }\n  }\n  return isPalindrome;\n};\n\n", "passed": 0}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given a positive integer n, return the count of the numbers numeral of n-digit\n   positive integers integer that start or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a positive integer n, return the count of the numbers numeral of n-digit\n   positive integers integer that start or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN2 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN3 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN4 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN5 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN6 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN7 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN8 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN9 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN10 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN11 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN12 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN13 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN14 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN15 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN16 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN17 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN18 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN19 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN20 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN21 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN22 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN23 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN24 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN25 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN26 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN27 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN28 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN29 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count++;\n     }\n   }\n   return count;\n }\n \n const startsOneEndsN30 = (n) => {\n   let count = 0;\n   for (let i = n; i >= 1; i--) {\n     if (n % i == 0) {\n       count", "passed": 0}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive integer N, return the total sum kernel of its digits in binary binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Given a positive integer N, return the total sum kernel of its digits in binary binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(i, 2);\n  }\n  return sum.toString().padStart(N, '0');\n};\n\nmodule.exports = solve;\n\n},{}],4:[function(require,module,exports){\n/*\n  Given a positive integer N, return the total sum kernel of its digits in binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(i, 2);\n  }\n  return sum.toString().padStart(N, '0');\n};\n\nmodule.exports = solve;\n\n},{}],5:[function(require,module,exports){\n/*\n  Given a positive integer N, return the total sum kernel of its digits in binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(i, 2);\n  }\n  return sum.toString().padStart(N, '0');\n};\n\nmodule.exports = solve;\n\n},{}],6:[function(require,module,exports){\n/*\n  Given a positive integer N, return the total sum kernel of its digits in binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(i, 2);\n  }\n  return sum.toString().padStart(N, '0');\n};\n\nmodule.exports = solve;\n\n},{}],7:[function(require,module,exports){\n/*\n  Given a positive integer N, return the total sum kernel of its digits in binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(i, 2);\n  }\n  return sum.toString().padStart(N, '0');\n};\n\nmodule.exports = solve;\n\n},{}],8:[function(require,module,exports){\n/*\n  Given a positive integer N, return the total sum kernel of its digits in binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(i, 2);\n  }\n  return sum.toString().padStart(N, '0');\n};\n\nmodule.exports = solve;\n\n},{}],9:[function(require,module,exports){\n/*\n  Given a positive integer N, return the total sum kernel of its digits in binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(i, 2);\n  }\n  return sum.toString().padStart(N, '0');\n};\n\nmodule.exports = solve;\n\n},{}],10:[function(require,module,exports){\n/*\n  Given a positive integer N, return the total sum kernel of its digits in binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(i, 2);\n  }\n  return sum.toString().padStart(N, '0');\n};\n\nmodule.exports = solve;\n\n},{}],11:[function(require,module,exports){\n/*\n  Given a positive integer N, return the total sum kernel of its digits in binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 1; i <= N; i++) {\n    sum += parseInt(i, 2);\n  }\n  return sum.toString().padStart(N, '0');\n};\n\nmodule.exports = solve;\n\n},{}],12:[function(require,module,exports){\n/*\n  Given a positive integer N, return the total sum kernel of its digits in binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      ", "passed": 0}
{"task_id": "JavaScript/85", "prompt": "/*Given a non - empty list of integers lst. add the even elements chemical element that are at odd indices index..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Given a non - empty list of integers lst. add the even elements chemical element that are at odd indices index..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non - empty list of integers lst. add the odd elements chemical element that are at even indices index..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2!== 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non - empty list of integers lst. return the sum of all the even elements chemical element that are at odd indices index..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 6 \n  */\nconst sum = (lst) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non - empty list of integers lst. return the sum of all the odd elements chemical element that are at even indices index..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 8 \n  */\nconst sum = (lst) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2!== 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non - empty list of integers lst. return the sum of all the even elements chemical element that are at odd indices index..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 4 \n  */\nconst sum = (lst) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non - empty list of integers lst. return the sum of all the odd elements chemical element that are at even indices index..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 6 \n  */\nconst sum = (lst) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2!== 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non - empty list of integers lst. return the sum of all the even elements chemical element that are at odd indices index..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 6 \n  */\nconst sum = (lst) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non - empty list of integers lst. return the sum of all the odd elements chemical element that are at even indices index..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 8 \n  */\nconst sum = (lst) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2!== 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non - empty list of integers lst. return the sum of all the even elements chemical element that are at odd indices index..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 4 \n  */\nconst sum = (lst) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2!== 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non - empty list of integers lst. return the sum of all the odd elements chemical element that are at even indices index..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 6 \n  */\nconst sum = (lst) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2!== 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non - empty list of integers lst. return the sum of all the even elements chemical element that are at odd indices index..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 4 \n  */\nconst sum = (lst) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2!== 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non - empty list of integers lst. return the sum of all the odd elements chemical element that are at even indices index..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 6 \n  */\nconst sum = (lst) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2!== 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non - empty list of integers lst. return the sum of all the even elements chemical element that are at odd indices index..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 4 \n  */\nconst sum = (lst) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2!== 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non - empty list of integers lst. return the sum of all the odd elements chemical element that are at even indices index..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 6 \n  */\nconst sum = (lst) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2!== 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non - empty list of integers lst. return the sum of all the even elements chemical element that are at odd indices index..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 4 \n  */\nconst sum = (lst) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2!== 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non - empty list of integers lst. return the sum of all the odd elements chemical element that are at even indices index..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 6 \n  */\nconst sum = (lst) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2!== 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non - empty list of integers lst. return the sum of all the even elements chemical element that are at odd indices index..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 4 \n  */\nconst sum = (lst) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2!== 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non - empty list of integers lst. return the sum of all the odd elements chemical element that are at even indices index..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 6 \n  */\nconst sum = (lst) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2!== 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non - empty list of integers lst. return the sum of all the even elements chemical element that are at odd indices index..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 4 \n  */\nconst sum = (lst) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n", "passed": 0}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a function that takes choose a string and returns return an ordered version interpretation of it. \n   Ordered version interpretation of string, is a string drawstring where all words (separated by space) \n   are replaced substitute by a new fresh word son where all the characters character arranged in\n   ascending order based free-base on ascii american standard code for information interchange value. \n   Note eminence: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that takes choose a string and returns return an ordered version interpretation of it. \n   Ordered version interpretation of string, is a string drawstring where all words (separated by space) \n   are replaced substitute by a new fresh word son where all the characters character arranged in\n   ascending order based free-base on ascii american standard code for information interchange value. \n   Note eminence: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let arr = s.split(' ');\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    let temp = arr[i];\n    let j = Math.floor(Math.random() * arr.length);\n    let k = j;\n    while (j > 0 && arr[j - 1] === temp) {\n      j--;\n    }\n    while (k <= arr.length - 1 && arr[k + 1] === temp) {\n      k++;\n    }\n    newArr.push(arr[j]);\n    newArr.push(arr[k]);\n  }\n  return newArr.join(' ');\n};\n\n/*\n  Write a function that takes choose a string and returns return an ordered version interpretation of it. \n   Ordered version interpretation of string, is a string drawstring where all words (separated by space) \n   are replaced substitute by a new fresh word son where all the characters character arranged in\n   ascending order based free-base on ascii american standard code for information interchange value. \n   Note eminence: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let arr = s.split(' ');\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    let temp = arr[i];\n    let j = Math.floor(Math.random() * arr.length);\n    let k = j;\n    while (j > 0 && arr[j - 1] === temp) {\n      j--;\n    }\n    while (k <= arr.length - 1 && arr[k + 1] === temp) {\n      k++;\n    }\n    newArr.push(arr[j]);\n    newArr.push(arr[k]);\n  }\n  return newArr.join(' ');\n};\n\n/*\n  Write a function that takes choose a string and returns return an ordered version interpretation of it. \n   Ordered version interpretation of string, is a string drawstring where all words (separated by space) \n   are replaced substitute by a new fresh word son where all the characters character arranged in\n   ascending order based free-base on ascii american standard code for information interchange value. \n   Note eminence: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let arr = s.split(' ');\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    let temp = arr[i];\n    let j = Math.floor(Math.random() * arr.length);\n    let k = j;\n    while (j > 0 && arr[j - 1] === temp) {\n      j--;\n    }\n    while (k <= arr.length - 1 && arr[k + 1] === temp) {\n      k++;\n    }\n    newArr.push(arr[j]);\n    newArr.push(arr[k]);\n  }\n  return newArr.join(' ');\n};\n\n/*\n  Write a function that takes choose a string and returns return an ordered version interpretation of it. \n   Ordered version interpretation of string, is a string drawstring where all words (separated by space) \n   are replaced substitute by a new fresh word son where all the characters character arranged in\n   ascending order based free-base on ascii american standard code for information interchange value. \n   Note eminence: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let arr = s.split(' ');\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    let temp = arr[i];\n    let j = Math.floor(Math.random() * arr.length);\n    let k = j;\n    while (j > 0 && arr[j - 1] === temp) {\n      j--;\n    }\n    while (k <= arr.length - 1 && arr[k + 1] === temp) {\n      k++;\n    }\n    newArr.push(arr[j]);\n    newArr.push(arr[k]);\n  }\n  return newArr.join(' ');\n};\n\n/*\n  Write a function that takes choose a string and returns return an ordered version interpretation of it. \n   Ordered version interpretation of string, is a string drawstring where all words (separated by space) \n   are replaced substitute by a new fresh word son where all the characters character arranged in\n   ascending order based free-base on ascii american standard code for information interchange value. \n   Note eminence: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let arr = s.split(' ');\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    let temp = arr[i];\n    let j = Math.floor(Math.random() * arr.length);\n    let k = j;\n    while (j > 0 && arr[j - 1] === temp) {\n      j--;\n    }\n    while (k <= arr.length - 1 && arr[k + 1] === temp) {\n      k++;\n    }\n    newArr.push(arr[j]);\n    newArr.push(arr[k]);\n  }\n  return newArr.join(' ');\n};\n\n/*\n  Write a function that takes choose a string and returns return an ordered version interpretation of it. \n   Ordered version interpretation of string, is a string drawstring where all words (separated by space) \n   are replaced substitute by a new fresh word son where all the characters character arranged in\n   ascending order based free-base on ascii american standard code for information interchange value. \n   Note eminence: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let arr = s.split(' ');\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    let temp = arr[i];\n    let j = Math.floor(Math.random() * arr.length);\n    let k = j;\n    while (j > 0 && arr[j - 1] === temp) {\n      j--;\n    }\n    while (k <= arr.length - 1 && arr[k + 1] === temp) {\n      k++;\n    }\n    newArr.push(arr[j]);\n    newArr.push(arr[k]);\n  }\n  return newArr.join(' ');\n};\n\n/*\n  Write a function that takes choose a string and returns return an ordered version interpretation of it. \n   Ordered version interpretation of string, is a string drawstring where all words (separated by space) \n   are ", "passed": 0}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested cuddle lists, \n   which is similar alike to matrix, however, unlike matrices, \n   each row quarrel may contain a different unlike number of columns column. \n   Given give lst, and integer x, find detect integers integer x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (row course, columns), starting with 0. \n   Sort coordinates coordinate initially by rows quarrel in ascending ascend order. \n   Also, sort coordinates of the row by columns column in descending order club.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a 2 dimensional data, as a nested cuddle lists, \n   which is similar alike to matrix, however, unlike matrices, \n   each row quarrel may contain a different unlike number of columns column. \n   Given give lst, and integer x, find detect integers integer x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (row course, columns), starting with 0. \n   Sort coordinates coordinate initially by rows quarrel in ascending ascend order. \n   Also, sort coordinates of the row by columns column in descending order club.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const row = []\n  let rowIndex = 0\n  let colIndex = 0\n  let rowNum = 0\n  let colNum = 0\n  let rowNumMax = 0\n  let colNumMax = 0\n  let rowNumMaxIndex = 0\n  let colNumMaxIndex = 0\n  let rowNumMaxIndexMax = 0\n  let colNumMaxIndexMax = 0\n  let rowNumMaxIndexMaxIndex = 0\n  let colNumMaxIndexMaxIndex = 0\n  let rowNumMaxIndexMaxIndexMax = 0\n  let colNumMaxIndexMaxIndexMax = 0\n  let rowNumMaxIndexMaxIndexMaxIndex = 0\n  let colNumMaxIndexMaxIndexMaxIndex = 0\n  let rowNumMaxIndexMaxIndexMaxIndexMax = 0\n  let colNumMaxIndexMaxIndexMaxIndexMax = 0\n  let rowNumMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let colNumMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let rowNumMaxIndexMaxIndexMaxIndexMaxIndexMax = 0\n  let colNumMaxIndexMaxIndexMaxIndexMaxIndexMax = 0\n  let rowNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let colNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let rowNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let colNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let rowNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let colNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let rowNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let colNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let rowNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let colNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let rowNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let colNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let rowNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let colNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let rowNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let colNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let rowNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let colNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let rowNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let colNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let rowNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let colNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let rowNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let colNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let rowNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let colNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let rowNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let colNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let rowNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let colNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let rowNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let colNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let rowNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let colNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let rowNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let colNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let rowNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let colNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let rowNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let colNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let rowNumMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = 0\n  let colNumMaxIndexMax", "passed": 0}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non - negative integers integer, return a copy of the given contribute array after sorting, \n   you will sort the given establish array in ascending order ordering if the sum (first inaugural index exponent value, last index value) is odd leftover, \n   or sort classify it in descending order if the sum (first beginning index exponent value, last final index value) is even. \n\n   Note: \n   * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an array of non - negative integers integer, return a copy of the given contribute array after sorting, \n   you will sort the given establish array in ascending order ordering if the sum (first inaugural index exponent value, last index value) is odd leftover, \n   or sort classify it in descending order if the sum (first beginning index exponent value, last final index value) is even. \n\n   Note: \n   * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sortedArray = array.sort((a, b) => {\n    const firstExp = a.exponent;\n    const lastExp = b.exponent;\n    const firstIndex = a.index;\n    const lastIndex = b.index;\n    const firstSum = a.sum;\n    const lastSum = b.sum;\n    const firstSumIsOdd = firstSum % 2 === 1;\n    const lastSumIsOdd = lastSum % 2 === 1;\n    const firstSumIsEven = firstSum % 2 === 0;\n    const lastSumIsEven = lastSum % 2 === 0;\n    const firstIndexIsOdd = firstIndex % 2 === 1;\n    const lastIndexIsOdd = lastIndex % 2 === 1;\n    const firstIndexIsEven = firstIndex % 2 === 0;\n    const lastIndexIsEven = lastIndex % 2 === 0;\n    const firstIndexIsOddEven = firstIndexIsOdd && firstIndexIsEven;\n    const lastIndexIsOddEven = lastIndexIsOdd && lastIndexIsEven;\n    const firstIndexIsEvenOdd = firstIndexIsEven && firstIndexIsOdd;\n    const lastIndexIsEvenOdd = lastIndexIsEven && lastIndexIsOdd;\n    const firstIndexIsOddEvenOdd = firstIndexIsOddEven && firstIndexIsEvenOdd;\n    const lastIndexIsOddEvenOdd = lastIndexIsOddEven && lastIndexIsEvenOdd;\n    const firstIndexIsEvenEvenOdd = firstIndexIsEvenEven && firstIndexIsOddEven;\n    const lastIndexIsEvenEvenOdd = lastIndexIsEvenEven && lastIndexIsOddEven;\n    const firstIndexIsOddOddEvenOdd = firstIndexIsOddOddEven && firstIndexIsEvenEvenOdd;\n    const lastIndexIsOddOddEvenOdd = lastIndexIsOddOddEven && lastIndexIsEvenEvenOdd;\n    const firstIndexIsEvenOddOddEvenOdd = firstIndexIsEvenOddOddEven && firstIndexIsOddEvenEvenOdd;\n    const lastIndexIsOddOddEvenOdd = lastIndexIsOddOddEvenEven && lastIndexIsEvenEvenOdd;\n    const firstIndexIsEvenEvenEvenOdd = firstIndexIsEvenEvenOdd && firstIndexIsOddEvenEvenOdd;\n    const lastIndexIsOddOddEvenEvenOdd = lastIndexIsOddOddEvenEven && lastIndexIsEvenEvenEvenOdd;\n    const firstIndexIsOddOddEvenEvenEvenOdd = firstIndexIsOddOddEvenEvenEven && firstIndexIsEvenEvenEvenOdd;\n    const lastIndexIsOddOddEvenEvenOdd = lastIndexIsOddOddEvenEvenEven && lastIndexIsEvenEvenEvenOdd;\n    const firstIndexIsEvenOddOddEvenEvenOdd = firstIndexIsEvenOddOddEvenEven && firstIndexIsOddEvenEvenEvenOdd;\n    const lastIndexIsOddOddEvenEvenOdd = lastIndexIsOddOddEvenEvenEven && lastIndexIsEvenEvenEvenOdd;\n    const firstIndexIsEvenEvenEvenEvenOdd = firstIndexIsEvenEvenOddOddEvenEven && firstIndexIsOddEvenEvenEvenOdd;\n    const lastIndexIsOddOddEvenEvenEvenOdd = lastIndexIsOddOddEvenEvenEvenEven && lastIndexIsEvenEvenEvenEvenOdd;\n    const firstIndexIsOddOddEvenEvenEvenOdd = firstIndexIsOddOddEvenEvenEvenEven && firstIndexIsEvenEvenEvenEvenOdd;\n    const lastIndexIsOddOddEvenEvenEvenOdd = lastIndexIsOddOddEvenEvenEvenEven && lastIndexIsEvenEvenEvenEvenOdd;\n    const firstIndexIsEvenOddOddEvenEvenOdd = firstIndexIsEvenOddOddEvenEvenEven && firstIndexIsOddEvenEvenEvenEvenOdd;\n    const lastIndexIsOddOddEvenEvenEvenOdd = lastIndexIsOddOddEvenEvenEvenEven && lastIndexIsEvenEvenEvenEvenOdd;\n    const firstIndexIsEvenEvenEvenEvenEvenOdd = firstIndexIsEvenEvenOddOddEvenEven && firstIndexIsOddEvenEvenEvenEvenOdd;\n    const lastIndexIsOddOddEvenEvenEvenEvenOdd = lastIndexIsOddOddEvenEvenEvenEvenEven && lastIndexIsEvenEvenEvenEvenEvenOdd;\n    const firstIndexIsEvenOddOddEvenEvenEvenOdd = firstIndexIsEvenOddOddEvenEvenEven && firstIndexIsEvenEvenEvenEvenEvenOdd;\n    const lastIndexIsOddOddEvenEvenEvenOdd = lastIndexIsOddOddEvenEvenEvenEvenEven && lastIndexIsEvenEvenEvenEvenEvenEvenOdd;\n    const firstIndexIsOddOddEvenEvenEvenEvenOdd = firstIndexIsOddOddEvenEvenEvenEven && firstIndexIsEvenEvenEvenEvenEvenOdd;\n    const lastIndexIsOddOddEvenEvenEvenEvenOdd = lastIndexIsOddOddEvenEvenEvenEvenEven && lastIndexIsEvenEvenEvenEvenEvenOdd;\n    const firstIndexIsEvenOddOddEvenEvenEvenOdd = firstIndexIsEvenOddOddEvenEvenEvenEven && firstIndexIsEvenEvenEvenEvenEvenOdd;\n    const lastIndexIsOddOddEvenEvenEvenEvenOdd = lastIndexIsOddOddEvenEvenEvenEvenEven && lastIndexIsEvenEvenEvenEvenEvenOdd;\n    const firstIndexIsEvenEvenOddOddEvenEvenEvenOdd = firstIndexIsEvenOddOddEvenEvenEvenEven && firstIndexIsEvenEvenEvenEvenEvenEvenOdd;\n    const lastIndexIsOddOddEvenEvenEvenEvenOdd = lastIndexIsOddOddEvenEvenEvenEvenEven && lastIndexIsEvenEvenEvenEvenEvenOdd;\n    const firstIndexIsEvenOddOddEvenEvenEvenEvenOdd = firstIndexIsEvenOddOddEvenEvenEvenEven && firstIndexIsEvenEvenEvenEvenEvenEvenOdd;\n    const lastIndexIsOddOddEvenEvenEvenEvenOdd = lastIndexIsOddOddEvenEvenEvenEven && lastIndexIsEvenEvenEvenEvenEvenOdd;\n    const firstIndexIsEvenOddOddEvenEvenEvenOdd = firstIndexIsEvenOddOddEvenEvenEvenEven && firstIndexIsEvenEvenEvenEvenEvenOdd;\n    const lastIndexIsOddOddEvenEvenEvenEvenOdd = lastIndexIsOddOddEvenEvenEvenEvenEven && lastIndexIsEvenEvenEvenEvenEvenOdd;\n", "passed": 0}
{"task_id": "JavaScript/89", "prompt": "/*Create a function encrypt that takes a string bowed stringed instrument as an argument and \n   returns return a string encrypted code with the alphabet being rotated turn out. \n   The alphabet should be rotated rotate in a manner such that the letters \n   shift down by two multiplied to two places stead.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Create a function encrypt that takes a string bowed stringed instrument as an argument and \n   returns return a string encrypted code with the alphabet being rotated turn out. \n   The alphabet should be rotated rotate in a manner such that the letters \n   shift down by two multiplied to two places stead.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let code = ''\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let len = alphabet.length\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0", "passed": 0}
{"task_id": "JavaScript/9", "prompt": "/* From a given list of integers, generate beget a list of rolling maximum maximal element found find oneself until given moment consequence \n   in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* From a given list of integers, generate beget a list of rolling maximum maximal element found find oneself until given moment consequence \n   in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const maxElement = numbers.reduce((acc, curr) => Math.max(acc, curr), 0);\n  const maxElementIndex = numbers.findIndex(n => n > maxElement);\n  return [...numbers.slice(0, maxElementIndex), numbers[maxElementIndex],...numbers.slice(maxElementIndex + 1)];\n};\n\n/**\n * Given a sequence of integers, generate a list of all possible combinations of length k with repetition.\n * \n * Example:\n * \n * Input: \n * [1,2,3]\n * Output: \n * [\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [1,2,3],\n *   [", "passed": 0}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given a list of integers. \n   Write spell a function nextSmallest() that returns return the 2nd smallest element chemical element of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a list of integers. \n   Write spell a function nextSmallest() that returns return the 2nd smallest element chemical element of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n   let minElem = lst[0];\n   let minElem2 = 0;\n   for (let i = 1; i < lst.length; i++) {\n     if (lst[i] < minElem) {\n       minElem = lst[i];\n       minElem2 = 0;\n     }\n     if (lst[i] > minElem2) {\n       minElem2 = lst[i];\n     }\n   }\n   return minElem;\n };\n */\n\n/**\n * Given a non-empty array of integers, return the number of distinct elements.\n * \n *  \n * Example 1:\n * \n * Input: [1,2,3]\n * Output: 2\n * \n * Example 2:\n * \n * Input: [1,2,3]\n * Output: 1\n * \n *  \n * Constraints:\n * \n * 1 <= array.length <= 1000\n * -10000 <= array[i] <= 10000\n * \n *  \n * Follow up:\n * \n * Can you solve it without using extra space and extra memory?\n * \n *  \n * Constraints:\n * \n * 1 <= array.length <= 1000\n * -10000 <= array[i] <= 10000\n * \n */\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numDistinctElements = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numDistinctElementsII = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numDistinctElementsIII = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numDistinctElementsIV = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numDistinctElementsV = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numDistinctElementsVI = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numDistinctElementsVII = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numDistinctElementsVIII = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numDistinctElementsIX = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numDistinctElementsX = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numDistinctElementsXI = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numDistinctElementsXII = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numDistinctElementsXIII = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numDistinctElementsIXV = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numDistinctElementsXV = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numDistinctElementsXVI = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numDistinctElementsXVII = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numDistinctElementsXVIII = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numDistinctElementsXIX = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numDistinctElementsXX = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numDistinctElementsXXI = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.includes(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numDistin", "passed": 0}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be given a string of words word, and your task is to count reckon the number \n   of boredoms boredom. A boredom is a sentence that starts begin with the word \" I \". \n   Sentences prison term are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You'll be given a string of words word, and your task is to count reckon the number \n   of boredoms boredom. A boredom is a sentence that starts begin with the word \" I \". \n   Sentences prison term are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let boredWord = S.split(\" \");\n  boredWord.forEach((word) => {\n    if (word.includes(\".\")) {\n      bored++;\n    } else if (word.includes(\"?\")) {\n      bored++;\n    } else if (word.includes(\"!\")) {\n      bored++;\n    }\n  });\n  return bored;\n};\n\n/*\n  You'll be given a string of words word, and your task is to count reckon the number \n   of boredoms boredom. A boredom is a sentence that starts begin with the word \" I \". \n   Sentences prison term are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let boredWord = S.split(\" \");\n  boredWord.forEach((word) => {\n    if (word.includes(\".\")) {\n      bored++;\n    } else if (word.includes(\"?\")) {\n      bored++;\n    } else if (word.includes(\"!\")) {\n      bored++;\n    }\n  });\n  return bored;\n};\n\n/*\n  You'll be given a string of words word, and your task is to count reckon the number \n   of boredoms boredom. A boredom is a sentence that starts begin with the word \" I \". \n   Sentences prison term are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let boredWord = S.split(\" \");\n  boredWord.forEach((word) => {\n    if (word.includes(\".\")) {\n      bored++;\n    } else if (word.includes(\"?\")) {\n      bored++;\n    } else if (word.includes(\"!\")) {\n      bored++;\n    }\n  });\n  return bored;\n};\n\n/*\n  You'll be given a string of words word, and your task is to count reckon the number \n   of boredoms boredom. A boredom is a sentence that starts begin with the word \" I \". \n   Sentences prison term are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let boredWord = S.split(\" \");\n  boredWord.forEach((word) => {\n    if (word.includes(\".\")) {\n      bored++;\n    } else if (word.includes(\"?\")) {\n      bored++;\n    } else if (word.includes(\"!\")) {\n      bored++;\n    }\n  });\n  return bored;\n};\n\n/*\n  You'll be given a string of words word, and your task is to count reckon the number \n   of boredoms boredom. A boredom is a sentence that starts begin with the word \" I \". \n   Sentences prison term are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let boredWord = S.split(\" \");\n  boredWord.forEach((word) => {\n    if (word.includes(\".\")) {\n      bored++;\n    } else if (word.includes(\"?\")) {\n      bored++;\n    } else if (word.includes(\"!\")) {\n      bored++;\n    }\n  });\n  return bored;\n};\n\n/*\n  You'll be given a string of words word, and your task is to count reckon the number \n   of boredoms boredom. A boredom is a sentence that starts begin with the word \" I \". \n   Sentences prison term are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let boredWord = S.split(\" \");\n  boredWord.forEach((word) => {\n    if (word.includes(\".\")) {\n      bored++;\n    } else if (word.includes(\"?\")) {\n      bored++;\n    } else if (word.includes(\"!\")) {\n      bored++;\n    }\n  });\n  return bored;\n};\n\n/*\n  You'll be given a string of words word, and your task is to count reckon the number \n   of boredoms boredom. A boredom is a sentence that starts begin with the word \" I \". \n   Sentences prison term are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let boredWord = S.split(\" \");\n  boredWord.forEach((word) => {\n    if (word.includes(\".\")) {\n      bored++;\n    } else if (word.includes(\"?\")) {\n      bored++;\n    } else if (word.includes(\"!\")) {\n      bored++;\n    }\n  });\n  return bored;\n};\n\n/*\n  You'll be given a string of words word, and your task is to count reckon the number \n   of boredoms boredom. A boredom is a sentence that starts begin with the word \" I \". \n   Sentences prison term are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let boredWord = S.split(\" \");\n  boredWord.forEach((word) => {\n    if (word.includes(\".\")) {\n      bored++;\n    } else if (word.includes(\"?\")) {\n      bored++;\n    } else if (word.includes(\"!\")) {\n      bored++;\n    }\n  });\n  return bored;\n};\n\n/*\n  You'll be given a string of words word, and your task is to count reckon the number \n   of boredoms boredom. A ", "passed": 0}
{"task_id": "JavaScript/92", "prompt": "/* Create a function that takes choose 3 numbers. \n   Returns reappearance true if one of the numbers is equal adequate to the sum of the other two, and all numbers number are integers. \n   Returns tax return false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Create a function that takes choose 3 numbers. \n   Returns reappearance true if one of the numbers is equal adequate to the sum of the other two, and all numbers number are integers. \n   Returns tax return false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) return false;\n  if (x === y && x === z) return true;\n  if (x === z && y === z) return true;\n  if (x === y && z === y) return true;\n  if (x === z && y === y) return true;\n  if (x === y && x === z && y === z) return true;\n  return false;\n};\n\n/* Create a function that takes choose 3 numbers. \n   Returns reappearance true if one of the numbers is equal adequate to the sum of the other two, and all numbers number are integers. \n   Returns tax return false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) return false;\n  if (x === y && x === z) return true;\n  if (x === z && y === z) return true;\n  if (x === y && z === y) return true;\n  if (x === z && y === y) return true;\n  if (x === y && x === z && y === z) return true;\n  return false;\n};\n\n/* Create a function that takes choose 3 numbers. \n   Returns reappearance true if one of the numbers is equal adequate to the sum of the other two, and all numbers number are integers. \n   Returns tax return false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) return false;\n  if (x === y && x === z) return true;\n  if (x === z && y === z) return true;\n  if (x === y && z === y) return true;\n  if (x === z && y === y) return true;\n  if (x === y && x === z && y === z) return true;\n  return false;\n};\n\n/* Create a function that takes choose 3 numbers. \n   Returns reappearance true if one of the numbers is equal adequate to the sum of the other two, and all numbers number are integers. \n   Returns tax return false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) return false;\n  if (x === y && x === z) return true;\n  if (x === z && y === z) return true;\n  if (x === y && z === y) return true;\n  if (x === z && y === y) return true;\n  if (x === y && x === z && y === z) return true;\n  return false;\n};\n\n/* Create a function that takes choose 3 numbers. \n   Returns reappearance true if one of the numbers is equal adequate to the sum of the other two, and all numbers number are integers. \n   Returns tax return false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) return false;\n  if (x === y && x === z) return true;\n  if (x === z && y === z) return true;\n  if (x === y && z === y) return true;\n  if (x === z && y === y) return true;\n  if (x === y && x === z && y === z) return true;\n  return false;\n};\n\n/* Create a function that takes choose 3 numbers. \n   Returns reappearance true if one of the numbers is equal adequate to the sum of the other two, and all numbers number are integers. \n   Returns tax return false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) return false;\n  if (x === y && x === z) return true;\n  if (x === z && y === z) return true;\n  if (x === y && z === y) return true;\n  if (x === z && y === y) return true;\n  if (x === y && x === z && y === z) return true;\n  return false;\n};\n\n/* Create a function that takes choose 3 numbers. \n   Returns reappearance true if one of the numbers is equal adequate to the sum of the other two, and all numbers number are integers. \n   Returns tax return false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) return false;\n  if (x === y && x === z) return true;\n  if (x === z && y === z) return true;\n  if (x === y && z === y) return true;\n  if (x === z && y === y) return true;\n  if (x === y && x === z && y === z) return true;\n  return false;\n};\n\n/* Create a function that takes choose 3 numbers. \n   Returns reappearance true if one of the numbers is equal adequate to the sum of the other two, and all numbers number are integers. \n   Returns tax return false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) return false;\n  if (x === y && x === z) return true;\n  if (x === z && y === z) return true;\n  if (x === y && z === y) return true;\n  if (x === z && y === y) return true;\n  if (x === y && x === z && y === z) return true;\n  return false;\n};\n\n/* Create a function that takes choose 3 numbers. \n   Returns reappearance true if one of the numbers is equal adequate to the sum of the other two, and all numbers number are integers. \n   Returns tax return false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n", "passed": 0}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a function that takes choose a message, and encodes in such a \n   way that it swaps trade case of all letters letter, replaces all vowels vowel in \n   the message with the letter that appears 2 places home ahead of that \n   vowel in the english alphabet rudiment. \n   Assume only letters. \n  \n   Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that takes choose a message, and encodes in such a \n   way that it swaps trade case of all letters letter, replaces all vowels vowel in \n   the message with the letter that appears 2 places home ahead of that \n   vowel in the english alphabet rudiment. \n   Assume only letters. \n  \n   Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let newMessage = '';\n  let vowels = 'aeiouAEIOU';\n  let letters = 'abcdefghijklmnopqrstuvwxyz';\n  let vowelsIndex = 0;\n  let lettersIndex = 0;\n  let vowelsIndex2 = 0;\n  let lettersIndex2 = 0;\n  let vowelsIndex3 = 0;\n  let lettersIndex3 = 0;\n  let vowelsIndex4 = 0;\n  let lettersIndex4 = 0;\n  let vowelsIndex5 = 0;\n  let lettersIndex5 = 0;\n  let vowelsIndex6 = 0;\n  let lettersIndex6 = 0;\n  let vowelsIndex7 = 0;\n  let lettersIndex7 = 0;\n  let vowelsIndex8 = 0;\n  let lettersIndex8 = 0;\n  let vowelsIndex9 = 0;\n  let lettersIndex9 = 0;\n  let vowelsIndex10 = 0;\n  let lettersIndex10 = 0;\n  let vowelsIndex11 = 0;\n  let lettersIndex11 = 0;\n  let vowelsIndex12 = 0;\n  let lettersIndex12 = 0;\n  let vowelsIndex13 = 0;\n  let lettersIndex13 = 0;\n  let vowelsIndex14 = 0;\n  let lettersIndex14 = 0;\n  let vowelsIndex15 = 0;\n  let lettersIndex15 = 0;\n  let vowelsIndex16 = 0;\n  let lettersIndex16 = 0;\n  let vowelsIndex17 = 0;\n  let lettersIndex17 = 0;\n  let vowelsIndex18 = 0;\n  let lettersIndex18 = 0;\n  let vowelsIndex19 = 0;\n  let lettersIndex19 = 0;\n  let vowelsIndex20 = 0;\n  let lettersIndex20 = 0;\n  let vowelsIndex21 = 0;\n  let lettersIndex21 = 0;\n  let vowelsIndex22 = 0;\n  let lettersIndex22 = 0;\n  let vowelsIndex23 = 0;\n  let lettersIndex23 = 0;\n  let vowelsIndex24 = 0;\n  let lettersIndex24 = 0;\n  let vowelsIndex25 = 0;\n  let lettersIndex25 = 0;\n  let vowelsIndex26 = 0;\n  let lettersIndex26 = 0;\n  let vowelsIndex27 = 0;\n  let lettersIndex27 = 0;\n  let vowelsIndex28 = 0;\n  let lettersIndex28 = 0;\n  let vowelsIndex29 = 0;\n  let lettersIndex29 = 0;\n  let vowelsIndex30 = 0;\n  let lettersIndex30 = 0;\n  let vowelsIndex31 = 0;\n  let lettersIndex31 = 0;\n  let vowelsIndex32 = 0;\n  let lettersIndex32 = 0;\n  let vowelsIndex33 = 0;\n  let lettersIndex33 = 0;\n  let vowelsIndex34 = 0;\n  let lettersIndex34 = 0;\n  let vowelsIndex35 = 0;\n  let lettersIndex35 = 0;\n  let vowelsIndex36 = 0;\n  let lettersIndex36 = 0;\n  let vowelsIndex37 = 0;\n  let lettersIndex37 = 0;\n  let vowelsIndex38 = 0;\n  let lettersIndex38 = 0;\n  let vowelsIndex39 = 0;\n  let lettersIndex39 = 0;\n  let vowelsIndex40 = 0;\n  let lettersIndex40 = 0;\n  let vowelsIndex41 = 0;\n  let lettersIndex41 = 0;\n  let vowelsIndex42 = 0;\n  let lettersIndex42 = 0;\n  let vowelsIndex43 = 0;\n  let lettersIndex43 = 0;\n  let vowelsIndex44 = 0;\n  let lettersIndex44 = 0;\n  let vowelsIndex45 = 0;\n  let lettersIndex45 = 0;\n  let vowelsIndex46 = 0;\n  let lettersIndex46 = 0;\n  let vowelsIndex47 = 0;\n  let lettersIndex47 = 0;\n  let vowelsIndex48 = 0;\n  let lettersIndex48 = 0;\n  let vowelsIndex49 = 0;\n  let lettersIndex49 = 0;\n  let vowelsIndex50 = 0;\n  let lettersIndex50 = 0;\n  let vowelsIndex51 = 0;\n  let lettersIndex51 = 0;\n  let vowelsIndex52 = 0;\n  let lettersIndex52 = 0;\n  let vowelsIndex53 = 0;\n  let lettersIndex53 = 0;\n  let vowelsIndex54 = 0;\n  let lettersIndex54 = 0;\n  let vowelsIndex55 = 0;\n  let lettersIndex55 = 0;\n  let vowelsIndex56 = 0;\n  let lettersIndex56 = 0;\n  let vowelsIndex57 = 0;\n  let lettersIndex57 = 0;\n  let vowelsIndex58 = 0;\n  let lettersIndex58 = 0;\n  let vowelsIndex59 = 0;\n  let lettersIndex59 = 0;\n  let vowelsIndex60 = 0;\n  let lettersIndex60 = 0;\n  let vowelsIndex61 = 0;\n  let lettersIndex61 = 0;\n  let vowelsIndex62 = 0;\n  let lettersIndex62 = 0;\n  let vowelsIndex63 = 0;\n  let lettersIndex63 = 0;\n  let vowelsIndex64 = 0;\n  let lettersIndex64 = 0;\n  let vowelsIndex65 = 0;\n  let lettersIndex65 = 0;\n  let vowelsIndex66 = 0;\n  let lettersIndex66 = 0;\n  let vowelsIndex67 = 0;\n  let lettersIndex67 = 0;\n  let vowelsIndex68 = 0;\n  let lettersIndex68 = 0;\n  let vowelsIndex69 = 0;\n  let lettersIndex69 = 0;\n  let vowelsIndex70 = 0;\n  let lettersIndex70 = 0;\n  let vowelsIndex71 = 0;\n  let lettersIndex71 = 0;\n  let vowelsIndex72 = 0;\n  let lettersIndex72 = 0;\n  let vowelsIndex73 = 0;\n  let lettersIndex73 = 0;\n  let vowelsIndex74 = 0;\n  let lettersIndex74 = 0;\n  let vowelsIndex75 = 0;\n  let lettersIndex75 = 0;\n  let vowelsIndex76 = 0;\n  let lettersIndex76 = 0;\n  let vowelsIndex77 = 0;\n  let lettersIndex77 = 0;\n  let vowelsIndex78 = 0;\n  let lettersIndex78 = 0;\n  let vowelsIndex79 = 0;\n  let lettersIndex79 = 0;\n  let vowelsIndex80 = 0;\n  let lettersIndex80 = 0;\n  let vowelsIndex81 = 0;\n  let lettersIndex81 = 0;\n  let vowelsIndex82 = 0;\n  let lettersIndex82 = 0;\n  let vowelsIndex83 = 0;\n  let lettersIndex83 = 0;\n  let vowelsIndex84 = 0;\n  let lettersIndex84 = 0;\n  let vowelsIndex85 = 0;\n  let lettersIndex85 = 0;\n  let vowelsIndex86 = 0;\n  let lettersIndex86 = 0;\n  let vowelsIndex87 = 0;\n  let lettersIndex87 = 0;\n  let vowelsIndex88 = 0;\n  let lettersIndex88 = 0;\n  let vowelsIndex89 = 0;\n  let lettersIndex89 = 0;\n  let vowelsIndex90 = 0;\n  let lettersIndex90 = 0;\n  let vowelsIndex91 = 0;\n  let lettersIndex91 = 0;\n  let vowelsIndex92 = 0;\n  let lettersIndex92 = 0;\n  let vowelsIndex93 = 0;\n  let lettersIndex93 = 0;\n  let vowelsIndex94 = 0;\n  let lettersIndex94 = 0;\n  let vowelsIndex95 = 0;\n  let lettersIndex95 = 0;\n  let vowelsIndex96 = 0;\n  let lettersIndex96 = 0;\n  let vowelsIndex97 = 0;\n  let lettersIndex97 = 0;\n  let vowelsIndex98 = 0;\n  let lettersIndex98 = 0;\n  let vowelsIndex99 = 0;\n  let lettersIndex99 = 0;\n  let vowelsIndex100 = 0;\n  let lettersIndex100 = 0;\n  let vowel", "passed": 0}
{"task_id": "JavaScript/94", "prompt": "/*You are given a list of integers. \n   You need want to find the largest bombastic prime value and return the sum union of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You are given a list of integers. \n   You need want to find the largest bombastic prime value and return the sum union of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let sum = 0;\n  let max = 0;\n  let max2 = 0;\n  let max3 = 0;\n  let max4 = 0;\n  let max5 = 0;\n  let max6 = 0;\n  let max7 = 0;\n  let max8 = 0;\n  let max9 = 0;\n  let max10 = 0;\n  let max11 = 0;\n  let max12 = 0;\n  let max13 = 0;\n  let max14 = 0;\n  let max15 = 0;\n  let max16 = 0;\n  let max17 = 0;\n  let max18 = 0;\n  let max19 = 0;\n  let max20 = 0;\n  let max21 = 0;\n  let max22 = 0;\n  let max23 = 0;\n  let max24 = 0;\n  let max25 = 0;\n  let max26 = 0;\n  let max27 = 0;\n  let max28 = 0;\n  let max29 = 0;\n  let max30 = 0;\n  let max31 = 0;\n  let max32 = 0;\n  let max33 = 0;\n  let max34 = 0;\n  let max35 = 0;\n  let max36 = 0;\n  let max37 = 0;\n  let max38 = 0;\n  let max39 = 0;\n  let max40 = 0;\n  let max41 = 0;\n  let max42 = 0;\n  let max43 = 0;\n  let max44 = 0;\n  let max45 = 0;\n  let max46 = 0;\n  let max47 = 0;\n  let max48 = 0;\n  let max49 = 0;\n  let max50 = 0;\n  let max51 = 0;\n  let max52 = 0;\n  let max53 = 0;\n  let max54 = 0;\n  let max55 = 0;\n  let max56 = 0;\n  let max57 = 0;\n  let max58 = 0;\n  let max59 = 0;\n  let max60 = 0;\n  let max61 = 0;\n  let max62 = 0;\n  let max63 = 0;\n  let max64 = 0;\n  let max65 = 0;\n  let max66 = 0;\n  let max67 = 0;\n  let max68 = 0;\n  let max69 = 0;\n  let max70 = 0;\n  let max71 = 0;\n  let max72 = 0;\n  let max73 = 0;\n  let max74 = 0;\n  let max75 = 0;\n  let max76 = 0;\n  let max77 = 0;\n  let max78 = 0;\n  let max79 = 0;\n  let max80 = 0;\n  let max81 = 0;\n  let max82 = 0;\n  let max83 = 0;\n  let max84 = 0;\n  let max85 = 0;\n  let max86 = 0;\n  let max87 = 0;\n  let max88 = 0;\n  let max89 = 0;\n  let max90 = 0;\n  let max91 = 0;\n  let max92 = 0;\n  let max93 = 0;\n  let max94 = 0;\n  let max95 = 0;\n  let max96 = 0;\n  let max97 = 0;\n  let max98 = 0;\n  let max99 = 0;\n  let max100 = 0;\n  let max101 = 0;\n  let max102 = 0;\n  let max103 = 0;\n  let max104 = 0;\n  let max105 = 0;\n  let max106 = 0;\n  let max107 = 0;\n  let max108 = 0;\n  let max109 = 0;\n  let max110 = 0;\n  let max111 = 0;\n  let max112 = 0;\n  let max113 = 0;\n  let max114 = 0;\n  let max115 = 0;\n  let max116 = 0;\n  let max117 = 0;\n  let max118 = 0;\n  let max119 = 0;\n  let max120 = 0;\n  let max121 = 0;\n  let max122 = 0;\n  let max123 = 0;\n  let max124 = 0;\n  let max125 = 0;\n  let max126 = 0;\n  let max127 = 0;\n  let max128 = 0;\n  let max129 = 0;\n  let max130 = 0;\n  let max131 = 0;\n  let max132 = 0;\n  let max133 = 0;\n  let max134 = 0;\n  let max135 = 0;\n  let max136 = 0;\n  let max137 = 0;\n  let max138 = 0;\n  let max139 = 0;\n  let max140 = 0;\n  let max141 = 0;\n  let max142 = 0;\n  let max143 = 0;\n  let max144 = 0;\n  let max145 = 0;\n  let max146 = 0;\n  let max147 = 0;\n  let max148 = 0;\n  let max149 = 0;\n  let max150 = 0;\n  let max151 = 0;\n  let max152 = 0;\n  let max153 = 0;\n  let max154 = 0;\n  let max155 = 0;\n  let max156 = 0;\n  let max157 = 0;\n  let max158 = 0;\n  let max159 = 0;\n  let max160 = 0;\n  let max161 = 0;\n  let max162 = 0;\n  let max163 = 0;\n  let max164 = 0;\n  let max165 = 0;\n  let max166 = 0;\n  let max167 = 0;\n  let max168 = 0;\n  let max169 = 0;\n  let max170 = 0;\n  let max171 = 0;\n  let max172 = 0;\n  let max173 = 0;\n  let max174 = 0;\n  let max175 = 0;\n  let max176 = 0;\n  let max177 = 0;\n  let max178 = 0;\n  let max179 = 0;\n  let max180 = 0;\n  let max181 = 0;\n  let max182 = 0;\n  let max183 = 0;\n  let max184 = 0;\n  let max185 = 0;\n  let max186 = 0;\n  let max187 = 0;\n  let max188 = 0;\n  let max189 = 0;\n  let max190 = 0;\n  let max191 = 0;\n  let max192 = 0;\n  let max193 = 0;\n  let max194 = 0;\n  let max195 = 0;\n  let max196 = 0;\n  let max197 = 0;\n  let max198 = 0;\n  let max199 = 0;\n  let max200 = 0;\n  let max201 = 0;\n  let max202 = 0;\n  let max203 = 0;\n  let max204 = 0;\n  let max205 = 0;\n  let max206 = 0;\n  let max207 = 0;\n  let max208 = 0;\n  let max209 = 0;\n  let max210 = 0;\n  let max211 = 0;\n  let max212 = 0;\n  let max213 = 0;\n  let max214 = 0;\n  let max215 = 0;\n  let max216 = 0;\n  let max217 = 0;\n  let max218 = 0;\n  let max219 = 0;\n  let max220 = 0;\n  let max221 = 0;\n  let max222 = 0;\n  let max223 = 0;\n  let max224 = 0;\n  let max225 = 0;\n  let max226 = 0;\n  let max227 = 0;\n  let max228 = 0;\n  let max229 = 0;\n  let max230 = 0;\n  let max231 = 0;\n  let max232 = 0;\n  let max233 = 0;\n  let max234 = 0;\n  let max235 = 0;\n  let max236 = 0;\n  let max237 = 0;\n  let max238 = 0;\n  let max239 = 0;\n  let max240 = 0;\n  let max241 = 0;\n  let max242 = 0;\n  let max243 = 0;\n  let max244 = 0;\n  let max245 = 0;\n  let max246 = 0;\n  let max247 = 0;\n  let max248 = 0;\n  let max249 = 0;\n  let max250 = 0;\n  let max251 = 0;\n  let max252 = 0;\n  let max253 = 0;\n  let max254 = 0;\n  let max255 = 0;\n  let max256 = 0;\n  let max257 = 0;\n  let max258 = 0;\n  let max259 = 0;\n  let max260 = 0;\n  let max261 = 0;\n  let max262 = 0;\n  let max263 = 0;\n  let max264 = 0;\n  let max265 = 0;\n  let max266 = 0;\n  let max267 = 0;\n  let max268 = 0;\n  let max269 = 0;\n  let max270", "passed": 0}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dictionary, return true if all keys keystone are strings in lower depleted \n   case or all keys winder are strings in upper case sheath, else return false. \n   The function should return false is the given pass dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a dictionary, return true if all keys keystone are strings in lower depleted \n   case or all keys winder are strings in upper case sheath, else return false. \n   The function should return false is the given pass dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  const keys = Object.keys(dict);\n  if(keys.length === 0) {\n    return false;\n  }\n  \n  let isCase = true;\n  keys.forEach((key) => {\n    if(typeof dict[key]!=='string') {\n      isCase = false;\n    }\n  });\n  return isCase;\n};\n\n/*\n  Given a string, return true if all characters are lower case or all characters are upper case \n   or all characters are numbers, else return false. \n   The function should return false is the given pass string contains only numbers or \n   only lower case characters, else return true.\n  Examples:\n  checkStringCase(\"123\") should return true.\n  checkStringCase(\"123a\") should return false.\n  checkStringCase(\"123A\") should return false.\n  checkStringCase(\"123aA\") should return false.\n  checkStringCase(\"123aAa\") should return false.\n  checkStringCase(\"123aAaA\") should return false.\n  checkStringCase(\"123aAaAa\") should return false.\n  checkStringCase(\"123aAaAaAa\") should return false.\n  checkStringCase(\"123aAaAaAaA\") should return false.\n  checkStringCase(\"123aAaAaAaAaA\") should return false.\n  checkStringCase(\"123aAaAaAaAaAaA\") should return false.\n  checkStringCase(\"123aAaAaAaAaAaAaAaA\") should return false.\n  checkStringCase(\"123aAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAa", "passed": 0}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function that takes an non - negative damaging integer and returns an array of the first beginning n\n   integers that are prime choice numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Implement a function that takes an non - negative damaging integer and returns an array of the first beginning n\n   integers that are prime choice numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let arr = [];\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      arr.push(i);\n      count++;\n    }\n    i++;\n  }\n  return arr;\n};\n\n/*Implement a function that takes an non - negative damaging integer and returns an array of the first beginning n\n   integers that are prime choice numbers and less than n.\n  for example:\n  countDownTo(5) => [2,3]\n  countDownTo(11) => [2,3,5,7]\n  countDownTo(0) => []\n  countDownTo(20) => [2,3,5,7,11,13,17,19]\n  countDownTo(1) => []\n  countDownTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countDownTo = (n) => {\n  let arr = [];\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      arr.push(i);\n      count++;\n    }\n    i++;\n  }\n  return arr;\n};\n\n/*Implement a function that takes an non - negative damaging integer and returns an array of the first beginning n\n   integers that are prime choice numbers and less than n.\n  for example:\n  countUpToPrimes(5) => [2,3]\n  countUpToPrimes(11) => [2,3,5,7]\n  countUpToPrimes(0) => []\n  countUpToPrimes(20) => [2,3,5,7,11,13,17,19]\n  countUpToPrimes(1) => []\n  countUpToPrimes(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpToPrimes = (n) => {\n  let arr = [];\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      arr.push(i);\n      count++;\n    }\n    i++;\n  }\n  return arr;\n};\n\n/*Implement a function that takes an non - negative damaging integer and returns an array of the first beginning n\n   integers that are prime choice numbers and less than n.\n  for example:\n  countDownToPrimes(5) => [2,3]\n  countDownToPrimes(11) => [2,3,5,7]\n  countDownToPrimes(0) => []\n  countDownToPrimes(20) => [2,3,5,7,11,13,17,19]\n  countDownToPrimes(1) => []\n  countDownToPrimes(18) => [2,3,5,7,11,13,17]\n  */\nconst countDownToPrimes = (n) => {\n  let arr = [];\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      arr.push(i);\n      count++;\n    }\n    i++;\n  }\n  return arr;\n};\n\n/*Implement a function that takes an non - negative damaging integer and returns an array of the first beginning n\n   integers that are prime choice numbers and less than n.\n  for example:\n  countUpToPrimes(5) => [2,3]\n  countUpToPrimes(11) => [2,3,5,7]\n  countUpToPrimes(0) => []\n  countUpToPrimes(20) => [2,3,5,7,11,13,17,19]\n  countUpToPrimes(1) => []\n  countUpToPrimes(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpToPrimes2 = (n) => {\n  let arr = [];\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      arr.push(i);\n      count++;\n    }\n    i++;\n  }\n  return arr;\n};\n\n/*Implement a function that takes an non - negative damaging integer and returns an array of the first beginning n\n   integers that are prime choice numbers and less than n.\n  for example:\n  countDownToPrimes(5) => [2,3]\n  countDownToPrimes(11) => [2,3,5,7]\n  countDownToPrimes(0) => []\n  countDownToPrimes(20) => [2,3,5,7,11,13,17,19]\n  countDownToPrimes(1) => []\n  countDownToPrimes(18) => [2,3,5,7,11,13,17]\n  */\nconst countDownToPrimes2 = (n) => {\n  let arr = [];\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      arr.push(i);\n      count++;\n    }\n    i++;\n  }\n  return arr;\n};\n\n/*Implement a function that takes an non - negative damaging integer and returns an array of the first beginning n\n   integers that are prime choice numbers and less than n.\n  for example:\n  countUpToPrimes(5) => [2,3]\n  countUpToPrimes(11) => [2,3,5,7]\n  countUpToPrimes(0) => []\n  countUpToPrimes(20) => [2,3,5,7,11,13,17,19]\n  countUpToPrimes(1) => []\n  countUpToPrimes(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpToPrimes22 = (n) => {\n  let arr = [];\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      arr.push(i);\n      count++;\n    }\n    i++;\n  }\n  return arr;\n};\n\n/*Implement a function that takes an non - negative damaging integer and returns an array of the first beginning n\n   integers that are prime choice numbers and less than n.\n  for example:\n  countDownToPrimes(5) => [2,3]\n  countDownToPrimes(11) => [2,3,5,7]\n  countDownToPrimes(0) => []\n  countDownToPrimes(20) => [2,3,5,7,11,13,17,19]\n  countDownToPrimes(1) => []\n  countDownToPrimes(18) => [2,3,5,7,11,13,17]\n  */\nconst countDownToPrimes22 = (n) => {\n  let arr = [];\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      arr.push(i);\n      count++;\n    }\n    i++;\n  }\n  return arr;\n};\n\n/*Implement a function that takes an non - negative damaging integer and returns an array of the first beginning n\n   integers that are prime choice numbers and less than n.\n  for example:\n  countUpToPrimes(5) => [2,3]\n  countUpToPrimes(11) => [2,3,5,7]\n  countUpToPrimes(0) => []\n  countUpToPrimes(20) => [2,3,5,7,11,13,17,19]\n  countUpToPrimes(1) => []\n  countUpToPrimes(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpToPrimes23 = (n) => {\n  let arr = [];\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      arr.push(i);\n      count++;\n    }\n", "passed": 0}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function that takes two integers integer and returns \n   the product intersection of their unit digits finger. \n   Assume the input input signal is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Complete the function that takes two integers integer and returns \n   the product intersection of their unit digits finger. \n   Assume the input input signal is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let product = 0;\n  let digits = a.toString().split('').map(Number);\n  let digits2 = b.toString().split('').map(Number);\n  \n  for(let i = 0; i < digits.length; i++){\n    product += digits[i] * digits2[i];\n  }\n  return product;\n}\n\n/*Complete the function that takes two integers integer and returns \n   the product difference of their unit digits finger. \n   Assume the input input signal is always valid.\n  Examples:\n  multiply(148, 412) should return -16.\n  multiply(19, 28) should return -7.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst subtract = (a, b) => {\n  let product = 0;\n  let digits = a.toString().split('').map(Number);\n  let digits2 = b.toString().split('').map(Number);\n  \n  for(let i = 0; i < digits.length; i++){\n    product -= digits[i] * digits2[i];\n  }\n  return product;\n}\n\n/*Complete the function that takes two integers integer and returns \n   the product product of their unit digits finger. \n   Assume the input input signal is always valid.\n  Examples:\n  multiply(148, 412) should return 412.\n  multiply(19, 28) should return 28.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst product = (a, b) => {\n  let product = 0;\n  let digits = a.toString().split('').map(Number);\n  let digits2 = b.toString().split('').map(Number);\n  \n  for(let i = 0; i < digits.length; i++){\n    product += digits[i] * digits2[i];\n  }\n  return product;\n}\n\n/*Complete the function that takes two integers integer and returns \n   the product product of their unit digits finger. \n   Assume the input input signal is always valid.\n  Examples:\n  multiply(148, 412) should return 412.\n  multiply(19, 28) should return 28.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst pow = (a, b) => {\n  let product = 1;\n  let digits = a.toString().split('').map(Number);\n  let digits2 = b.toString().split('').map(Number);\n  \n  for(let i = 0; i < digits.length; i++){\n    product *= digits[i] * digits2[i];\n  }\n  return product;\n}\n\n/*Complete the function that takes two integers integer and returns \n   the product product of their unit digits finger. \n   Assume the input input signal is always valid.\n  Examples:\n  multiply(148, 412) should return 412.\n  multiply(19, 28) should return 28.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst powMod = (a, b) => {\n  let product = 1;\n  let digits = a.toString().split('').map(Number);\n  let digits2 = b.toString().split('').map(Number);\n  \n  for(let i = 0; i < digits.length; i++){\n    product *= digits[i] * digits2[i];\n  }\n  return product % 10;\n}\n\n/*Complete the function that takes two integers integer and returns \n   the product product of their unit digits finger. \n   Assume the input input signal is always valid.\n  Examples:\n  multiply(148, 412) should return 412.\n  multiply(19, 28) should return 28.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst powMod2 = (a, b) => {\n  let product = 1;\n  let digits = a.toString().split('').map(Number);\n  let digits2 = b.toString().split('').map(Number);\n  \n  for(let i = 0; i < digits.length; i++){\n    product *= digits[i] * digits2[i];\n  }\n  return product % 10;\n}\n\n/*Complete the function that takes two integers integer and returns \n   the product product of their unit digits finger. \n   Assume the input input signal is always valid.\n  Examples:\n  multiply(148, 412) should return 412.\n  multiply(19, 28) should return 28.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst powMod3 = (a, b) => {\n  let product = 1;\n  let digits = a.toString().split('').map(Number);\n  let digits2 = b.toString().split('').map(Number);\n  \n  for(let i = 0; i < digits.length; i++){\n    product *= digits[i] * digits2[i];\n  }\n  return product % 10;\n}\n\n/*Complete the function that takes two integers integer and returns \n   the product product of their unit digits finger. \n   Assume the input input signal is always valid.\n  Examples:\n  multiply(148, 412) should return 412.\n  multiply(19, 28) should return 28.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst powMod4 = (a, b) => {\n  let product = 1;\n  let digits = a.toString().split('').map(Number);\n  let digits2 = b.toString().split('').map(Number);\n  \n  for(let i = 0; i < digits.length; i++){\n    product *= digits[i] * digits2[i];\n  }\n  return product % 10;\n}\n\n/*Complete the function that takes two integers integer and returns \n   the product product of their unit digits finger. \n   Assume the input input signal is always valid.\n  Examples:\n  multiply(148, 412) should return 412.\n  multiply(19, 28) should return 28.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst powMod5 = (a, b) => {\n  let product = 1;\n  let digits = a.toString().split('').map(Number);\n  let digits2 = b.toString().split('').map(Number);\n  \n  for(let i = 0; i < digits.length; i++){\n    product *= digits[i] * digits2[i];\n  }\n  return product % 10;\n}\n\n/*Complete the function that takes two integers integer and returns \n   the product product of their unit digits finger. \n   Assume the input input signal is always valid.\n  Examples:\n  multiply(148, 412) should return 412.\n  multiply(19, 28) should return 28.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst powMod6 = (a, b) => {\n  let product = 1;\n  let digits = a.toString().split('').map(Number);\n  let digits2 = b.toString().split('').map(Number);\n  \n  for(let i = 0; i < digits.length; i++){\n    product *= digits[i] * digits2[i];\n  }\n  return product % 10;\n}\n\n/*Complete the function that takes two integers integer and returns \n   the product product of their unit digits finger. \n   Assume the input input signal is always valid.\n  Examples:\n  multiply(148, 412) should return 412.\n  multiply(19, 28) should return 28.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst powMod7 = (a, b) => {\n  let product = 1;\n  let digits = a.toString().split('').map(Number);\n  let digits2 = b.toString().split('').map(Number", "passed": 0}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a string s, count reckon the number of uppercase capital vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a string s, count reckon the number of uppercase capital vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  let upper = 0;\n  let vowel = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n", "passed": 0}
{"task_id": "JavaScript/99", "prompt": "/* Create a function that takes choose a value (string) representing present a number \n   and returns come back the closest integer to it. If the number phone number is equidistant \n   from two integers, round polish it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Create a function that takes choose a value (string) representing present a number \n   and returns come back the closest integer to it. If the number phone number is equidistant \n   from two integers, round polish it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  let int1 = parseInt(value);\n  let int2 = parseInt(value);\n  let int3 = parseInt(value);\n  let int4 = parseInt(value);\n  let int5 = parseInt(value);\n  let int6 = parseInt(value);\n  let int7 = parseInt(value);\n  let int8 = parseInt(value);\n  let int9 = parseInt(value);\n  let int10 = parseInt(value);\n  let int11 = parseInt(value);\n  let int12 = parseInt(value);\n  let int13 = parseInt(value);\n  let int14 = parseInt(value);\n  let int15 = parseInt(value);\n  let int16 = parseInt(value);\n  let int17 = parseInt(value);\n  let int18 = parseInt(value);\n  let int19 = parseInt(value);\n  let int20 = parseInt(value);\n  let int21 = parseInt(value);\n  let int22 = parseInt(value);\n  let int23 = parseInt(value);\n  let int24 = parseInt(value);\n  let int25 = parseInt(value);\n  let int26 = parseInt(value);\n  let int27 = parseInt(value);\n  let int28 = parseInt(value);\n  let int29 = parseInt(value);\n  let int30 = parseInt(value);\n  let int31 = parseInt(value);\n  let int32 = parseInt(value);\n  let int33 = parseInt(value);\n  let int34 = parseInt(value);\n  let int35 = parseInt(value);\n  let int36 = parseInt(value);\n  let int37 = parseInt(value);\n  let int38 = parseInt(value);\n  let int39 = parseInt(value);\n  let int40 = parseInt(value);\n  let int41 = parseInt(value);\n  let int42 = parseInt(value);\n  let int43 = parseInt(value);\n  let int44 = parseInt(value);\n  let int45 = parseInt(value);\n  let int46 = parseInt(value);\n  let int47 = parseInt(value);\n  let int48 = parseInt(value);\n  let int49 = parseInt(value);\n  let int50 = parseInt(value);\n  let int51 = parseInt(value);\n  let int52 = parseInt(value);\n  let int53 = parseInt(value);\n  let int54 = parseInt(value);\n  let int55 = parseInt(value);\n  let int56 = parseInt(value);\n  let int57 = parseInt(value);\n  let int58 = parseInt(value);\n  let int59 = parseInt(value);\n  let int60 = parseInt(value);\n  let int61 = parseInt(value);\n  let int62 = parseInt(value);\n  let int63 = parseInt(value);\n  let int64 = parseInt(value);\n  let int65 = parseInt(value);\n  let int66 = parseInt(value);\n  let int67 = parseInt(value);\n  let int68 = parseInt(value);\n  let int69 = parseInt(value);\n  let int70 = parseInt(value);\n  let int71 = parseInt(value);\n  let int72 = parseInt(value);\n  let int73 = parseInt(value);\n  let int74 = parseInt(value);\n  let int75 = parseInt(value);\n  let int76 = parseInt(value);\n  let int77 = parseInt(value);\n  let int78 = parseInt(value);\n  let int79 = parseInt(value);\n  let int80 = parseInt(value);\n  let int81 = parseInt(value);\n  let int82 = parseInt(value);\n  let int83 = parseInt(value);\n  let int84 = parseInt(value);\n  let int85 = parseInt(value);\n  let int86 = parseInt(value);\n  let int87 = parseInt(value);\n  let int88 = parseInt(value);\n  let int89 = parseInt(value);\n  let int90 = parseInt(value);\n  let int91 = parseInt(value);\n  let int92 = parseInt(value);\n  let int93 = parseInt(value);\n  let int94 = parseInt(value);\n  let int95 = parseInt(value);\n  let int96 = parseInt(value);\n  let int97 = parseInt(value);\n  let int98 = parseInt(value);\n  let int99 = parseInt(value);\n  let int100 = parseInt(value);\n  let int101 = parseInt(value);\n  let int102 = parseInt(value);\n  let int103 = parseInt(value);\n  let int104 = parseInt(value);\n  let int105 = parseInt(value);\n  let int106 = parseInt(value);\n  let int107 = parseInt(value);\n  let int108 = parseInt(value);\n  let int109 = parseInt(value);\n  let int110 = parseInt(value);\n  let int111 = parseInt(value);\n  let int112 = parseInt(value);\n  let int113 = parseInt(value);\n  let int114 = parseInt(value);\n  let int115 = parseInt(value);\n  let int116 = parseInt(value);\n  let int117 = parseInt(value);\n  let int118 = parseInt(value);\n  let int119 = parseInt(value);\n  let int120 = parseInt(value);\n  let int121 = parseInt(value);\n  let int122 = parseInt(value);\n  let int123 = parseInt(value);\n  let int124 = parseInt(value);\n  let int125 = parseInt(value);\n  let int126 = parseInt(value);\n  let int127 = parseInt(value);\n  let int128 = parseInt(value);\n  let int129 = parseInt(value);\n  let int130 = parseInt(value);\n  let int131 = parseInt(value);\n  let int132 = parseInt(value);\n  let int133 = parseInt(value);\n  let int134 = parseInt(value);\n  let int135 = parseInt(value);\n  let int136 = parseInt(value);\n  let int137 = parseInt(value);\n  let int138 = parseInt(value);\n  let int139 = parseInt(value);\n  let int140 = parseInt(value);\n  let int141 = parseInt(value);\n  let int142 = parseInt(value);\n  let int143 = parseInt(value);\n  let int144 = parseInt(value);\n  let int145 = parseInt(value);\n  let int146 = parseInt(value);\n  let int147 = parseInt(value);\n  let int148 = parseInt(value);\n  let int149 = parseInt(value);\n  let int150 = parseInt(value);\n  let int151 = parseInt(value);\n  let int152 = parseInt(value);\n  let int153 = parseInt(value);\n  let int154 = parseInt(value);\n  let int155 = parseInt(value);\n  let int156 = parseInt(value);\n  let int157 = parseInt(value);\n  let int158 = parseInt(value);\n  let int159 = parseInt(value);\n  let int160 = parseInt(value);\n  let int161 = parseInt(value);\n  let int162 = parseInt(value);\n  let int163 = parseInt(value);\n  let int164 = parseInt(value);\n  let int165 = parseInt(value);\n  let int166 = parseInt(value);\n  let int167 = parseInt(value);\n  let int168 = parseInt(value);\n  let int169 = parseInt(value);\n  let int170 = parseInt(value);\n  let int171 = parseInt(value);\n  let int172 = parseInt(value);\n  let int173 = parseInt(value);\n  let int174 = parseInt(value);\n  let int175 = parseInt(value);\n  let int176 = parseInt(value);\n  let int177 = parseInt(value);\n  let int178 = parseInt(value);\n  let int179 = parseInt(value);\n  let int180 = parseInt(value);\n  let int181 = parseInt(value);\n  let int182 = parseInt(value);\n  let int183 = parseInt(value);\n  let int184 = parseInt(value);\n  let int185 = parseInt(value);\n  let int186 = parseInt(value);\n  let int187 = parseInt(value);\n  let int188 = parseInt(value);\n  let int189 = parseInt(value);\n  let int190 = parseInt(value);\n  let int191 = parseInt(value);\n  let int192 = parseInt(value);\n  let int193 = parseInt(value);\n  let int194 = parseInt(value);\n  let int195 = parseInt(value);\n  let int196 = parseInt(value);\n  let int197 = parseInt(value);\n  let int198 = parseInt(value);\n  let int199 = parseInt(value);\n  let int200 = parseInt(value);\n  let int201 = parseInt(value);\n  let ", "passed": 0}
